- en: Getting Notification from Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the big advantages of Ansible, compared to a bash script, is its idempotency,
    ensuring that everything is in order. This is a very nice feature that not only
    assures you that nothing has changed the configurations on your server, but also
    that new configurations will be applied in a short time.
  prefs: []
  type: TYPE_NORMAL
- en: Due to these reasons, many people run their `master.yaml` file once a day. When
    you do this (and probably you should!), you want some kind of feedback sent to
    you by Ansible itself. There are also many other cases where you may want Ansible
    to send messages to you or your team. For instance, if you use Ansible to deploy
    your application, you may want to send an IRC message (or other kinds of group
    chat messages) to your development team channel, so that they are all informed
    of the status of your system.
  prefs: []
  type: TYPE_NORMAL
- en: Other times, you want Ansible to notify Nagios that it's going to break something,
    so that Nagios does not worry and does not start to shoot emails and messages
    to your system administrators. In this chapter, we are going to look at multiple
    ways to help you to set up Ansible Playbooks that can both work with your monitoring
    system and eventually send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Email notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible XMPP/Jabber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slack and Rocket chat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a message to an IRC channel (community information and contributing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon Simple Notification Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nagios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the examples will require third-party systems (to send messages to),
    which you may or may not be using. If you do not have access to one of these systems,
    the relative example will not be executable for you. This is not a big problem,
    since you can still read the section and many notification modules are very similar
    to another. You might find that a module that is more suitable for your environment
    is present and functions in a very similar way. For a full list of Ansible notification
    modules, you can refer to [https://docs.ansible.com/ansible/latest/modules/list_of_notification_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_notification_modules.html).
  prefs: []
  type: TYPE_NORMAL
- en: You can download all of the files from this book's GitHub repository at: [https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter06](https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Sending emails with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's frequent that a user needs to be promptly notified about an action that
    an Ansible Playbook performs. This can be either because it's important that this
    user knows about it, or because there is an automated system that has to be notified
    in order to (not) start some procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest and most common way of alerting people is to send emails. Ansible
    allows you to send emails from your playbook using a `mail` module. You can use
    this module in between any of your tasks and notify your user whenever required.
    Also, in some cases, you cannot automate each and every thing because either you
    lack the authority or it requires some manual checking and confirmation. If this
    is the case, you can notify the responsible user that Ansible has done its job
    and it''s time for them to perform their duty. Let''s use the `mail` module to
    notify your users with a very simple playbook called `uptime_and_email.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding playbook firstly reads the current machine uptime, issuing the
    `uptime` command, and then sends it via email to the `me@fale.io` email address.
    To send the email, we clearly need some additional information, such as the SMTP
    host, a valid set of SMTP credentials, and the content of the email. This example
    is very easy and will allow us to keep the examples short, but obviously, you
    can generate the emails in a similar way in very long and complex playbooks. If
    we focus on the `mail` task a little bit, we can see that we are using it with
    the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: An email server to be used to send the email (also with login information, which
    is required for this server)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The receiver email address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The email subject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The email body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other interesting parameters that the `mail` module supports are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `attach` parameter: This is used to add attachments to the email that will
    be generated. This is very useful when, for instance, you want to send a log via
    an email.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `port` parameter: This is used to specify which port is used by the email
    server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interesting thing about this module is that the only mandatory field is `subject`,
    and not the body, as many people would expect. The RFC 2822 does not force the
    presence of either the subject or the body, so an email without both of them is
    still valid, but it would be very hard for a human to manage such formatted email.
    Ansible, therefore, will always send emails with both subject and body, and if
    the body is empty, it will use the `subject` string both in the subject and in
    the body.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now proceed to execute the script to validate its functionality with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This playbook might not work on some machines, since the `-p` parameter of `uptime`
    is Linux-specific and might not work on other POSIX operating systems, such as
    macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'By running the previous playbook, we will have a result similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, as expected, Ansible has sent me an email with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This module can be used in many different ways. An example of a real-world case
    that I've seen is a playbook that was created to automate a piece of a very complex,
    but sequential process, where multiple people were involved. Each person had a
    specific point in the process in which they had to start their work and the next
    person in the chain cannot start their work before the previous person completed
    theirs. The key to keep the process ticking was each person emailing the next
    person in the chain to notify them that their own part was completed and therefore
    the receiver needed to start their work in the process. The people in the process
    generally carried out the email notification manually. When we started to automate
    that procedure, we did it for one specific piece and no one noticed that that
    part was automated.
  prefs: []
  type: TYPE_NORMAL
- en: Having such long processes tracked via email is not the best way to handle them
    since errors are easy to make, potentially losing track of the process. Also,
    those kind of complex and sequential processes tend to be very slow, but it's
    widely used in organizations and often you cannot change it.
  prefs: []
  type: TYPE_NORMAL
- en: There are cases where the process needs to send notifications in a more real-time
    way than emails, so XMPP could be a good way to do it.
  prefs: []
  type: TYPE_NORMAL
- en: XMPP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Emails are slow, unreliable, and often people do not react to them immediately.
    There are cases where you want to send a real-time message to one of your users.
    Many organizations rely on XMPP/Jabber for their internal chat system and the
    great thing is that Ansible is able to directly send messages to XMPP/Jabber users
    and conference rooms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s tweak the previous example to send uptime information to a user in the
    `uptime_and_xmpp_user.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you want to use the Ansible `jabber` task, you will need to have the `xmpppy`
    library installed on the system that will perform the task. One way to install
    it is by using your package manager. For instance, on Fedora you can just execute
    `sudo dnf install -y python2-xmpp` and it will be installed. You can also use
    `pip install xmpppy`.
  prefs: []
  type: TYPE_NORMAL
- en: The first task is exactly the same as we had in the previous section, while
    the second one has small differences. As you can see, the `jabber` module is very
    similar to the `mail` module and requires similar parameters. In the XMPP case,
    we don't need to specify the server host and port, since that information is automatically
    gathered by XMPP from the DNS. In cases where we would need to use a different
    server host or port, we can use, respectively, the `host` and `port` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now proceed to execute the script to validate its functionality with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have a result similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In cases where we want to send a message to a conference room instead of a
    single user, it is enough to change the receiver in the  `to` parameter, by adding
    the associated conference room instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Except for the receiver change and the addition of `(mailto:sysop@conference.fale.io)/ansiblebot`
    which identifies the chat handle to use (`ansiblebot`, in this case), XMPP handles
    users and conference rooms in the same way, so it's very easy to switch from one
    to the other.
  prefs: []
  type: TYPE_NORMAL
- en: Although XMPP is fairly popular, not every company uses it. Another collaboration
    platform that Ansible can send messages to is Slack.
  prefs: []
  type: TYPE_NORMAL
- en: Slack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last few years, many new chat and collaboration platforms have appeared.
    One of the most used ones is Slack. Slack is a cloud-based team collaboration
    tool, and this allows even easier integration with Ansible than XMPP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put the following lines in the `uptime_and_slack.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed, this module has an even simpler syntax than the XMPP one. In
    fact, it only needs to know the token (which you can generate on the Slack website),
    the channel to send the message to, and the message itself.
  prefs: []
  type: TYPE_NORMAL
- en: Since version 1.8 of Ansible, the new version of the Slack token is required,
    for instance, `G522SJP14/D563DW213/7Qws484asdWD4w12Md3avf4FeD`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the playbook with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Slack''s goal is to make communications more efficient, it allows us
    to tweak multiple aspects of the message. The most interesting points, from my
    point of view, are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`color`: This allows you to specify a color bar to be put at the beginning
    of the message to identify the following states:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Good: green bar'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Normal: no bar'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Warning: yellow bar'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Danger: red bar'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`icon_url`: This allows you to change the user image for that message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following code would send a message with a warning color and
    a custom user image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since not every company is comfortable with Slack being able to see their private
    conversations, there are alternatives, such as Rocket Chat.
  prefs: []
  type: TYPE_NORMAL
- en: Rocket Chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many companies like the functionality of Slack, but do not want to lose out
    on the privacy that an on-premises service gives you when using Slack. **Rocket
    Chat** is an open source software solution that implements most of the features
    of Slack, as well as the majority of its interface. Being open source, every company
    can install it on-premises and manage it in a way that is compliant with their
    IT rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'As Rocket Chat''s goal is to be a drop-in replacement for Slack, from our point
    of view, very few changes need to be done. In fact, we can create the `uptime_and_rocket.yaml` file
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the only lines that changed are the sixth and seventh, where
    the word `slack` has been replaced by `rocketchat`. Also, we need to add the domain
    field specifying where our installation of Rocket Chat is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Another way to self-host a company's conversations is by using IRC, a very old
    but still commonly used protocol. Ansible is also able to send messages using
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Internet Relay Chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Internet Relay Chat** (**IRC**) is probably the most well-known and widely-used
    chat protocol of the 1990s and it''s still used today. Its popularity and continued
    use is mainly due to its use in open source communities and its simplicity. From
    an Ansible perspective, IRC is a pretty straightforward module and we can use
    it, as shown in the following example (to be put in the `uptime_and_irc.yaml`
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You need the `socket` Python library installed to use the Ansible IRC module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the IRC module, the following fields are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '`channel`: This is to specify in which channel your message will be delivered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msg`: This is the message you want to send.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other configurations you will usually specify are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`server`: Select `server` to connect to, if not `localhost`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port`: Select `port` to connect to, if not `6667`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`: This to specify the message `color`, if not `black`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nick`: This to specify the `nick` sending the message, if not `ansible`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use_ssl`: Use SSL and TLS security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`style`: This is if you want to send your message with bold, italic, underline,
    or reverse style.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the code with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have seen many different communication systems that are probably in place
    in your company or project, but those are usually used for a human-to-human or
    a machine-to-human communication. Machine-to-machine communication usually uses
    different systems, such as Amazon SNS.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Simple Notification Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you want your playbooks to be agnostic in the way you receive the
    alert. This has several advantages, mainly in terms of flexibility. In fact, in
    this model, Ansible will deliver the messages to a notification service and the
    notification service will then take care of delivering them. **Amazon Simple Notification
    Service** (**SNS**) is not the only notification service available, but it''s
    probably the most used. SNS has the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Messages**: Messages generated by publishers identified by a UUID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publishers**: Programs generating messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Topics**: Named groups of messages, which can be thought of in a similar
    way to chat channels or rooms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscribers**: Clients that will receive all messages published in the topics
    they have subscribed to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So in our case, we will have, specifically, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Messages**: Ansible notifications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publishers**: Ansible itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Topics**: Probably different topics to group messages based on the system
    and/or the kind of notification (for example, storage, networking, or computing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscribers**: The people in your team that have to be notified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we said, one of the big advantages of SNS is that you can decouple the way
    Ansible sends messages (the SNS API) from the way your users will receive them.
    In fact, you will be able to choose different delivery systems per user and per
    topic rules, and eventually you can change them dynamically to ensure that the
    messages are sent in the best way possible for any situation. The five ways SNS
    can send messages, at the moment, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon **Lambda** functions (serverless functions written in Python, Java, and
    JavaScript)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon **Simple Queue Service** (**SQS**) (a message queuing system)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP(S) call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how we can send SNS messages with Ansible. To do so, we can create
    a file called `uptime_and_sns.yaml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using the `msg` key to set the message that will be
    sent, `topic` to choose the most appropriate topic, and `subject` will be used
    as the subject for email deliveries. There are many other options you can set.
    Mainly, they are useful for sending different messages using different delivery
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, it would make sense to send a short message via SMS (in the end,
    the first **S** in **SMS** means **short**) and longer and more detailed messages
    via emails. To do so, the SNS module provides us with the following delivery-specific
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sms`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we have seen in previous chapter, AWS modules require credentials, and we
    can set them up in multiple ways. The three AWS-specific parameters that are needed
    to run this module are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aws_access_key`: This is the AWS access key; if not specified, the environmental
    variable, `aws_access_key`, will be considered or the content of `~/.aws/credentials`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aws_secret_key`: This is the AWS secret key; if not specified, the environmental
    variable, `aws_secret_key`, will be considered or the content of `~/.aws/credentials`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`region`: This is the AWS region to use; if not specified, the environmental
    variable, `ec2_region`, will be considered or the content of `~/.aws/config`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the code with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There are cases where we want to notify a monitoring system so that it will
    not trigger any alarm due to Ansible actions. A common example of such a system
    is Nagios.
  prefs: []
  type: TYPE_NORMAL
- en: Nagios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Nagios** is one of the most used tools for controlling the status of services
    and servers. Nagios is capable of regularly auditing the state of servers and
    services and notifying users in case of problems. If you have Nagios in your environment,
    you need to be very careful when you administer your machines, because in cases
    where Nagios finds servers or services in an unhealthy state, it will start sending
    emails and SMS and making calls to your team. When you run Ansible scripts against
    nodes that are controlled by Nagios, you have to be even more careful, because
    you risk emails, SMS messages, and calls being triggered during the night or other
    inappropriate times. To avoid this, Ansible is able to notify Nagios beforehand,
    so that Nagios does not send notifications in that time window, even if some services
    are down (for instance, because they are rebooted) or other checks fail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are going to stop a service, wait for five minutes, and
    then start it again since this would actually create a Nagios failure in the majority
    of configurations. In fact, usually, Nagios is configured to accept up to two
    consecutive failures of a test (with usually one execution every minute), putting
    the service in a warning state before raising a critical state. We are going to
    create the `long_restart_service.yaml` file, which will trigger the Nagios critical
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This should trigger a Nagios alert and result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If no Nagios alert has been triggered, either your Nagios installation does
    not track that service or five minutes is not enough to make it raise a critical
    state. To check, you should get in contact to the person or the team that manages
    your Nagios installation, since Nagios allows full configuration to a point where
    it's very hard to predict how Nagios will behave without knowing its configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create a very similar playbook that will ensure that Nagios will
    not send any alerts. We are going to create a file called `long_restart_service_no_alert.yaml`
    with the following content (the full code is available on GitHub):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have added two tasks. The first is to inform Nagios not to
    send alerts for the HTTPd service on the given host, and the second is to inform
    Nagios to start sending alerts for the service again. Even if you do not specify
    the service and therefore all alerts on that host are silenced, my advice is to
    disable only the alert you are going to break so that Nagios is still able to
    work normally on the majority of your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: If the playbook run fails before reaching the re-enablement of the alerts, your
    alerts will stay *disabled*.
  prefs: []
  type: TYPE_NORMAL
- en: This module's goal is to toggle the Nagios alerts as well as schedule downtime,
    and from Ansible 2.2, this module can also unschedule downtimes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This should trigger a Nagios alert and result in the following output (the
    full code output is available on GitHub):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To use the Nagios module, you need to delegate the action to your Nagios server
    using the `delegate_to` parameter, as shown in the example.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, what you want to achieve with a Nagios integration is exactly the
    opposite. In fact, you are not interested in muting it, but you want Nagios to
    handle your test results. A common case is if you want to leverage your Nagios
    configuration to notify your administrators of the output of a task. To do so,
    we can use the Nagios `nsca` utility, integrating it into our playbooks. Ansible
    does not yet have a specific module for managing it, but you can always run it
    using the command module, leveraging the `send_nsca` CLI program.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how we can teach Ansible to send notifications
    to other systems and people. You learned to send notifications through a variety
    of systems, including email and messaging services, such as Slack. Finally, you
    learned how to prevent Nagios from sending unwanted notifications about system
    health during periods when you are operating it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to create a module so that you can extend
    Ansible to perform any kind of task.
  prefs: []
  type: TYPE_NORMAL
