- en: Complex Environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve seen how you can develop Ansible playbooks and test them. The
    final aspect is how to release playbooks into production. In most cases, you will
    have multiple environments to deal with before the playbook is released into production.
    This is similar to software that your developers have written. Many companies
    have multiple environments, and usually your playbook will follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Staging environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some companies name those environments in different ways, and some companies
    have additional environments, such as the certification environment where all
    software has to be certified before it can go to production.
  prefs: []
  type: TYPE_NORMAL
- en: When you write your playbooks and set up roles, we strongly recommend that you
    keep in mind the notion of the environments right from the start. It might be
    worthwhile to talk to your software and operations teams to figure out exactly
    how many environments your setup has to cater to. We'll list a couple of approaches
    with examples that you can follow in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Code based on the Git branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software distribution strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a web app with a revision control system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a web app with RPM packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building compiled software with RPM packaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to follow the examples in this chapter, you will need a UNIX machine
    capable of building RPM packages. My suggestion would be a Fedora or CentOS installation
    (either bare metal or in a virtual machine).
  prefs: []
  type: TYPE_NORMAL
- en: You can download all the files from this book's GitHub repository at [https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter09](https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: Code based on the Git branch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume you have four environments to take care of, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Git branch-based method, you will have one environment per branch. You
    will always make changes to **Development** first, and then promote those changes
    to **Testing** (merge or cherry-pick, and tag commits in Git), **Stage**, and
    **Production**. In this approach, you will hold one single inventory file, one
    set of variable files, and, finally, a bunch of folders dedicated to roles and
    playbooks per branch.
  prefs: []
  type: TYPE_NORMAL
- en: A single stable branch with multiple folders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this approach, you will always maintain the development and master branches.
    The initial code is committed to the development branch, and once stable, you
    will promote it to the master branch. The same roles and playbooks that exist
    in the master branch will run across all environments. On the other hand, you
    will have separate folders for each of your environments. Let''s look at an example.
    We''ll show how you can have a separate configuration and an inventory for two
    environments: staging and production. You can extend it to your scenario to fit
    all the environments you use. First, let''s look at the playbook in `playbooks/variables.yaml`
    that will run across these multiple environments and has the following content.
    Full code is available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there are two sets of tasks in this playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: Tasks that run against DB servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks that run against web servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also an extra task to print the environment name that is common to
    all servers in a particular environment. We will also have two different inventory
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one will be called `inventory/production` and will have the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one will be called `inventory/staging` and will have the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have two machines for the `web` section and one for the `db`
    in each environment. Furthermore, we have a different set of machines for stage
    and production environments. The additional section, `[ENVIRONMENT:children]`,
    allows you to create a group of groups. This would mean that any variables that
    are defined in the `ENVIRONMENT` section will apply to both the `db` and `web`
    groups, unless they're overridden in the individual sections, respectively. The
    next interesting part would be to look at variable values for each of the environments
    and see how they are separated out in each environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the variables that will be the same for all our environments,
    located in `inventory/group_vars/all`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The only variable that is the same for both our environments is `db_user`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now look at the production-specific variables, located in `inventory/group_vars/production`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now look at the stage-specific variables located in `inventory/group_vars/staging`,
    we will find the same variables we had in the production one, but with different
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now validate that we received the expected results. First, we are going
    to run against the staging environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We should receive an output similar to the following. Full code output is available
    in GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run against the production environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the Ansible run picked up all of the relevant variables that
    were defined for the staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using this approach to gain a stable master branch for multiple environments,
    it's best to use a mix of environment-specific directories, `group_vars`, and
    inventory groups to tackle the scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Software distribution strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying applications is probably one of the most complex tasks in the **Information
    and Communication Technology** (**ICT**) field. This is mainly caused by the fact
    that it often requires changing the state of the majority of machines that are
    somehow part of that application. In fact, often, you find yourself having to
    change the state of load balancers, distribution servers, application servers,
    and database servers all at the same time during a deployment. New technologies,
    such as containers, are trying to make those operations simpler, but often it
    is not easy or possible to just move a legacy application to a container.
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to look at the various software distribution strategies and
    how Ansible can help with each one.
  prefs: []
  type: TYPE_NORMAL
- en: Copying files from the local machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is probably the oldest strategy to distribute software. The idea is to
    have the files on the local machine (often used to develop the code) and as soon
    as the change is made, a copy of the file is put on the server (usually via FTP).
    This way of deploying code was often used for web development, where the code
    (usually in PHP) does not need any compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This distribution strategy should be avoided due to its multiple problems:'
  prefs: []
  type: TYPE_NORMAL
- en: It's very hard to rollback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's impossible to track changes to the various deployments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's no deployment history.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's easy to make errors during the deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although this distribution strategy can be very easily automated with Ansible,
    I strongly suggest that you immediately move to a different strategy that allows
    you to have a safer distribution strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Revision control system with branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many companies are using this technique to distribute their software, mainly
    for uncompiled software. The idea behind this technique is to set up your server
    to use a local copy of your code repository. With SVN, this was possible but not
    very easy to manage properly, while Git allowed a simplification of this technique,
    making it very popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique has big advantages over the one we have just seen; the main
    ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy rollbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very easy to obtain the history of changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very easy deployments (mainly if Git is used)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, this technique still has multiple disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: No deployment history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hard for compiled software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possible security problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I'd like to discuss the possible security problems you may encounter with this
    technique a little bit more. What can be very tempting is to download your Git
    repository directly in the folder that you use to distribute the content, so if
    it's a web server, this would be the `/var/www/` folder. This has obvious advantages,
    since to deploy you'll only need to perform a `git pull`. The disadvantage is
    that Git will create the `/var/www/.git` folder, which will contain your entire
    Git repository (history included) and, if not properly protected, will be freely
    downloadable by anyone.
  prefs: []
  type: TYPE_NORMAL
- en: About 1% of Alexa's top 1 million websites have the Git folder publicly accessible,
    so be very careful if you want to use this distribution strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Revision control system with tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way of using revision control systems that is a little bit more complex
    but that has some advantages is leveraging the tagging system. This method requires
    you to tag every time a new deployment has to be done and then check the specific
    tag on the server.
  prefs: []
  type: TYPE_NORMAL
- en: This has all the advantages of the previous method, with the addition of the
    deployment history. The compiled software problem and possible security problems
    are the same as in the previous method.
  prefs: []
  type: TYPE_NORMAL
- en: RPM packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common way to deploy software (mainly for compiled applications, but
    also advantageous for non-compiled applications) is using some kind of packaging
    system. Some languages, such as Java, have included systems (WAR, in Java's case),
    but there are also packaging systems that can be used for any kind of applications,
    such as **RPM Package Manager** (**RPM**). RPM was originally developed by Erik
    Troan and Marc Ewing, and released in 1997 for Red Hat Linux. Since then, it has
    been adopted by many Linux distributions and is one of the two main ways to distribute
    software in the Linux world, with the other being DEB. The disadvantage of these
    systems is that they are a little bit more complex than the previous methods,
    but those systems can grant a higher level of security, as well as versioning.
    Also, these systems are easily injectable in a CI/CD pipeline, so the real complexity
    is much lower than what it could seem at first sight.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see how we can deploy the code in the ways we talked about in the *Software
    distribution strategy* section, we will need an environment, and obviously we
    are going to create it using Ansible. First of all, to ensure that our roles are
    properly loaded, we need the `ansible.cfg` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need the `playbooks/groups/web.yaml` file to allow us to properly
    bootstrap our web servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can imagine from the previous file content, we will need to create the
    roles `common` and `webserver`, which are very similar to the ones we created
    in [Chapter 4](99cce790-a03d-4810-b707-83e05bb45043.xhtml), *Handling Complex
    Deployment*. We will start with the `roles/common/tasks/main.yaml` file with the
    following content. The full code is available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is its `motd` template in `roles/common/templates/motd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now move to the `webserver` role—more specifically, to the `roles/webserver/tasks/main.yaml`
    file. Full code file is available in GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to create the handler in `roles/webserver/handlers/main.yaml`
    with this content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the following content to the `roles/webserver/templates/index.html.j2`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we need to touch the `roles/webserver/files/website.conf` file, leaving
    it empty for now, but it needs to exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now provision a couple of CentOS machines (I provisioned `ws01.fale.io`
    and `ws02.fale.io`) and ensure that the inventory is right. We can configure those
    machines by running their group playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following output. Full code output is available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can now point our browser to our nodes on port `80` to check that the HTTPd
    page is displayed as expected. Now that we have the basic webserver up and running,
    we can now focus on deploying a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a web app with a revision control system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now going to perform our first deployment of the web application from
    a revision control system (Git) directly to our server using Ansible. So, we are
    going to deploy a simple PHP application that will be composed of only a single
    PHP page. The source is available at the following repository: [https://github.com/Fale/demo-php-app](https://github.com/Fale/demo-php-app).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy it, we will need the following code placed in `playbooks/manual/rcs_deploy.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run the deployer with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'At the moment, our application is not yet reachable, since we have no HTTPd
    rule for that folder. To achieve this, we will need to change the `roles/webserver/files/website.conf`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are just displaying this application to the users who are
    reaching our server with the `app.fale.io` URL and not to everyone. This will
    ensure that all your users will have a consistent experience. Also, you can see
    that we are blocking all access to the `.git` folder (and all its content). This
    is needed for the security reasons we mentioned in the S*oftware distribution
    strategy* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now re-run the web playbook to ensure that our HTTPd configuration gets
    propagated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result we are going to receive. Full code output is available on
    GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can now check and see that everything works properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen how we can get a source from Git and deploy it to a web server
    so that it''s promptly available to our users. We are now going to dive into another
    distribution strategy: deploying a web app with RPM packages.'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a web app with RPM packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To deploy an RPM package, we will need to create it in the first place. To do
    so, the first thing we need is a **SPEC file**.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a SPEC file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create a SPEC file, which is a recipe for
    instructing `rpmbuild` on how to actually create the RPM package. We are going
    to locate the SPEC file in `spec/demo-php-app.spec`. Following is the snippet
    content and the full code is available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what the various parts do and mean before moving on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Those first three lines are variables declarations.
  prefs: []
  type: TYPE_NORMAL
- en: The first one will disable the generation of a debug package. By default, `rpmbuild`
    will create a debug package every time and include all debugging symbols, but
    in this case we don't have any debugging symbols, since we are not making any
    compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second puts the hash of the commit in the `commit0` variable. The third
    one calculates the value of `shortcommit0`, which is calculated as the first eight
    characters of the `commit0` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we declare the name, version, release number, and summary.
    The difference between version and release is that the version is the upstream
    version, while the release is the SPEC version for that upstream release.
  prefs: []
  type: TYPE_NORMAL
- en: 'The license is the source license, not the SPEC license. The URL is used to
    track the upstream website. The `source0` field is used by `rpmbuild` to find
    out how the source file is called (if more than one file is present, we can user
    `source1`, `source2`, and so on). Also, if the source fields are valid URI, we
    can use the `spectool` to download them automatically. This is the `description` of
    the software that''s packaged in the RPM package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `prep` phase is the one where the source(s) get uncompressed and eventually
    patch(es) are applied. The `%autosetup` will `uncompress` the first source, as
    well as apply all patches. In this part, you can also perform other operations
    that need to be executed before the `build` phase and have the goal of preparing
    the environment for the `build` phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we would put all actions of the `build` phase. In our case, our sources
    do not need to be compiled, and therefore it is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `install` phase, we put the files in the `%{buildroot}` folder, which
    will mimic the target filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `files` section is needed to declare which files are to be put in the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `changelog` is needed to track who released a new version when and with
    which changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the SPEC file, we need to build it. To do so, we could use
    a production machine, but this would increase the attack surface to that machine,
    so it''s better to avoid it. There are multiple ways to build your RPM software.
    The four main ways are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automate the manual way with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Koji
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at the differences very briefly.
  prefs: []
  type: TYPE_NORMAL
- en: Building RPMs manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to build an RPM package is doing so in a manual way.
  prefs: []
  type: TYPE_NORMAL
- en: The big advantage is that you need only a few, simple steps to install `build`,
    and for this reason many people who are starting with RPM start from here. The
    disadvantage is that the process will be manual, and therefore human errors can
    spoil the result. Also, a manual build is very difficult to audit, since the only
    auditable part is the output and not the process itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build RPM packages, you will need a Fedora or an EL (Red Hat Enterprise
    Linux, CentOS, Scientific Linux, Oracle Enterprise Linux) system. If you are using
    Fedora, you will need to execute the following command to install all the necessary
    software:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are running an EL system, the command you''ll need to execute is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In either case, you''ll need to add the user you''ll use to the `mock` group,
    and to do so, you need to execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Linux loads the users at login, so to apply a group change, you need to restart
    your session.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can copy the SPEC file into the folder (usually, `$HOME`
    is a good one) and perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create the `$HOME/rpmbuild/SOURCES` folder that is needed in the
    process. The `-p` option will automatically create all folders in the path that
    are missing. We used `spectool` to download the source file and place it in the
    appropriate directory. The `spectool` will automatically get the URL from the
    SPEC file so that we don''t have to remember it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to create an `src.rpm` file, and to do so, we can use `rpmbuild`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will output something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Some small differences in the name could be present; for instance, you will
    probably have a different `$HOME` folder and you could have something other than
    `fc24`, if you are using something different than Fedora 24 to build the package.
    At this point, we can create the binary file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Mock allows us to build RPM packages in a clean environment and also, thanks
    to the `-r` option, it allows us to build for different versions of Fedora, EL,
    and Mageia. This command will give you a very long output, which we''ll not cover
    here, but in the last few lines, there is useful information. If everything is
    built properly, this is the last few lines you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The second-to-last line contains the path where you can find the results. If
    you look in that folder, you should find the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The three log files are very useful in case of problems during the compilation.
    The `src.rpm` file will be a copy of the `src.rpm` file we created with the first
    command, while the `x86_64.rpm` file is the mock one we created and the one we
    will need to install on our machines.
  prefs: []
  type: TYPE_NORMAL
- en: Building RPMs with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since doing all of those steps manually can be long, boring, and error-prone,
    we can automate them with Ansible. The resulting playbook will probably not be
    the cleanest one, but will be able to execute all operations in a repeatable way.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, we are going to build a new machine from scratch. I''ll call
    this machine `builder01.fale.io`, and we are also going to change the `inventory/production`
    file to match this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Before diving into the `builders` role, we will need to do a couple of changes
    to the `webserver` roles to enable a new repository. The first is adding a task
    in `roles/webserver/tasks/main.yaml` to the end of the file, with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The second change is actually creating the `roles/webserver/files/privaterepo.repo`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now execute the `webserver` group playbook to make the changes effective
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output should appear. Full code output is available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the only change has been the deployment of our newly generated
    repository file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to create a role for `builders` with a `tasks` file located in
    `roles/builder/tasks/main.yaml` with the following content. The full code is available
    on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, as part of the `builder` role, we need the `roles/builder/handlers/main.yaml`
    handler file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can guess from the `tasks` file, we will also need the `roles/builder/files/repo.conf`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a new `group` playbook in `playbooks/groups/builders.yaml` with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create the host itself with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We are expecting a result similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all the parts of the infrastructure ready, we can create the
    `playbooks/manual/rpm_deploy.yaml` file with the following content. The full code
    is available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed, this playbook has a lot of commands and shells that are not
    very clean. In the future, it may be possible to write a playbook with the same
    features but with modules. Most actions are the same, as we discussed in the previous
    section. The new actions are toward the end; in fact, in this case, we copy the
    generated RPM file to a specific folder, we invoke `createrepo` to generate a
    repository in that folder, and then we force all web servers to update the generated
    package to the last version.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure the security of your application, it is important that the repository
    is only accessible internally and not publicly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run the playbook with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We expect a result such as the following. Full code output is available on
    GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Building RPMs with CI/CD pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although this is not covered in this book, in more complex cases, you may want
    to use a CI/CD pipeline to create and manage RPM packages. The two main pipelines
    are based on two different types of software:'
  prefs: []
  type: TYPE_NORMAL
- en: Koji
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Koji software has been developed by the Fedora community and Red Hat. It
    is released under the terms of the LGPL 2.1 license. This is the pipeline that
    currently gets used by Fedora, CentOS, as well as many other companies and communities
    to create all their RPMs (both for official testing, also known as **scratch builds**).
    Koji, by default, is not triggered by commit; it needs to be called **manually** from
    a user (through a web interface or CLI). Koji will automatically download the
    last version of the SPEC file in Git, download the source from a side-cache (this
    is optional, but suggested) or from the original location, and trigger the mock
    build. Koji supports only a mock build due to the fact that it is the only system
    that allows consistent and repeatable builds. Koji can store all the output artifacts
    forever or for a limited amount of time, based on the configuration. This is to
    ensure a very high level of auditability.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins is one of the most-used CI/CD managers and can also be used for RPM
    pipelines. The big disadvantage is that it needs to be configured from scratch
    with the consequence that more time is required, but this means it has more flexibility.
    Also, a big advantage of Jenkins is that many companies already have an instance
    of Jenkins, and this makes it easier to set up and maintain the infrastructure,
    since you can reuse an installation you already have, and therefore you don't
    have to manage fewer systems overall.
  prefs: []
  type: TYPE_NORMAL
- en: Building compiled software with RPM packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**RPM packaging** is very useful for non-binary applications and close to a
    necessity for binary applications. This is also true because the difference in
    complexity is pretty low between a non-binary and a binary case. In fact, the
    build and the installation will work in exactly the same way. The only thing that
    will change is the SPEC file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the SPEC file that''s needed to compile and package a simple
    `Hello World!` application written in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's very similar to the one we saw for the PHP demo application.
    Let's look at the differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dive a little bit into the various parts of the SPEC file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we don't have the line to disable the debug package. Every time
    you package a compiled application, you should let `rpm` create the debug symbols
    package so that in the case of crashes, it will be easier to debug and understand
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following part of the SPEC file is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the changes in this section are only due to the fact that the
    new package has a different name and `URL`, but they are not linked by the fact
    that this is a compilable application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the non-compiled application, we did not need any packages present at build
    time, while in this case we will need the `make` and the `gcc` (compiler) applications.
    Different applications could require different tools and/or libraries to be present
    on the system at build time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `description` is package-specific and is not influenced by the compilation
    of the package. In the same way, the `%prep` phase works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `%build` phase, we now have to make `%{?_smp_mflags}`. This is needed
    to tell `rpmbuild` to actually run `make` to build our application. The `_smp_mflags`
    variable will include a set of parameters to optimize the compilation to be multi-thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'During the `%install` phase, we will issue the `%make_install` command. This
    macro will call `make install` with a set of additional parameters to ensure that
    the libraries are located in the right folder, as well as the binaries and so
    forth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we only need to place the `hello` binary that was located in
    the right folder of the `buildroot` during the `%install` phase, and also add
    the `LICENSE` file containing the license:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `%changelog` is very similar to the other SPEC file we saw, since it is
    not influenced by the involvement of a compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have completed this, you can place it in `spec/hello-world.spec`
    and tweak `playbooks/manual/rpm_deploy.yaml` by saving it into `playbooks/manual/hello_deploy.yaml`
    with the following code snippet. The full code is available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the only thing that we changes is that all references to `demo-php-app`
    got replaced with `hello-world`. Run it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to get the following result. Full code output is available on
    GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: You could eventually create a playbook that accepts the name of the package
    to build as a parameter, so that you don't need a different playbook for every
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to distribute software in your environment,so now, we will
    speak about deployment strategies, that is, how to upgrade your application without
    your service suffering from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three different problems you might incur during an update:'
  prefs: []
  type: TYPE_NORMAL
- en: Downtime during the update rollout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new version has problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new version seems to work, until it fails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first problem is known to every system administrator. During the update,
    you are probably going to restart some services, and for the time between the
    start and the end of the service, your application will not be available on that
    machine. To address this problem, you would need multiple machines with a smart
    load balancer in front that will remove specify nodes from the pool of available
    nodes just before the upgrade on that specific node is performed, to add them
    back later as soon as the node has been upgraded.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem can be prevented in multiple ways. The cleanest one would
    be testing in the CI/CD pipeline. In fact, those kinds of problems are pretty
    easy to find with simple tests. This can also be prevented with the methods we
    are going to see soon.
  prefs: []
  type: TYPE_NORMAL
- en: The third problem is by far the most complex. Manytimes, even ones on a global
    scale, have been generated by these kinds of problems. Usually, the problem is
    that the new version has some performance problems or memory leaks. Since the
    majority of deployments are done in the period of least load of the servers, as
    soon as the load increases, a performance problem or memory leak could kill your
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to use those methods in a proper way, you have to be able to ensure
    that your software can accept rollbacks. There are cases where this is not possible
    (that is, a database table gets removed in an update). We will not discuss how
    to avoid this, since this is part of the development strategy, and is not related
    to Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work around those problems, two common deployment patterns are used: the
    **canary deployment** and the **blue/green deployment**.'
  prefs: []
  type: TYPE_NORMAL
- en: Canary deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The canary deployment is a technique that involves updating a small percentage
    of your machines (often 5%) to the new version and instructing the load balancers
    to send only an equivalent amount of traffic to it. This has several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: During the update, you never have less than 95% of the capacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the new version completely fails, you lose 5% of the capacity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the load balancer divides the traffic between your new and your old version,
    if the new version has problems, only 5% of your users will see the problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You only need to have 5% capacity more than your expected load
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canary deployment is able to prevent all three problems we mentioned with a
    very small overhead (5%) and with low cost in the case of rollback (5%). For those
    reasons, this technique is used a lot by huge companies. Often, to ensure a similar
    user experience to users that live close to one another, geography is used to
    choose whether the user is going to hit the old or the new version.
  prefs: []
  type: TYPE_NORMAL
- en: When the test seems to be a success, the percentage can be increased progressively
    until 100% is reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s possible to implement a canary deployment in multiple ways in Ansible.
    The way I suggest is the cleanest one, that is, using the inventory files, so
    that you have something such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In this way, you can set all the variables on the web group (the variables are
    going to be the same, no matter what the version OS, or at least they should be),
    but you can run a playbook easily against the canary group, the main group, or
    both groups at the same time. Another option would be to create two different
    inventory files, one for the canary group and the other for the main group with
    the groups, having the same name so that variables are shared.
  prefs: []
  type: TYPE_NORMAL
- en: Blue/green deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Blue/green deployment is very different compared to canary deployment, and
    it has some advantages and some disadvantages. The main advantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Easier to implement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows quicker iterations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All users get moved at the same time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rollbacks have no performance degradation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among the disadvantages, the main ones are the fact that you need to have double
    the machines available than what your application requires. This disadvantage
    can be easily mitigated if the application is running on a cloud (either private,
    public, or hybrid) scaling up the application resources for the deployment and
    then scale them back down.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing blue/green deployment in Ansible is very easy. The simplest way
    is to create two different inventories (one for blue and one for green) and then
    simply manage your infrastructure as if they are different environments, such
    as production, staging, development, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, Ansible feels slow, mainly if you have a very long list of tasks
    to execute and/or if you have a huge amount of machines. There are multiple reasons
    for this, and ways to avoid it, and we are going to look at three of those ways.
  prefs: []
  type: TYPE_NORMAL
- en: Pipelining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the reasons Ansible is slow by default is that for every module execution
    and for every host, Ansible will perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: SSH handshake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Close the SSH connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, this means that if you have 10 tasks to be executed on a single
    remote server, Ansible will open (and close) the connection 10 times. Since the
    SSH protocol is an encrypted protocol, this makes the SSH handshake an even longer
    process, since the two parts have to negotiate the cyphers every single time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible allows us to reduce the execution time drastically by initiating the
    connections at the beginning of the playbook and keeping them alive for the whole
    execution so that it does not need to re-open the connection at every task. Over
    the course of Ansible''s life, this feature has changed names multiple times,
    as well as the way it''s enabled. From version 1.5, it''s been called **pipelining**,
    and the way to enable it is by adding the following line to your `ansible.cfg`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The reason this feature is not enabled by default is that many distributions
    ship with the `requiretty` option in `sudo`. The pipelining mode in Ansible and
    the `requiretty` option in `sudo` conflict and will make your playbooks fail.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to enable the pipelining mode, ensure that the `sudo requiretty`
    mode is disabled on your target machines.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing with_items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to execute similar operations multiple times, it's possible to repeat
    the same task multiple times with different parameters or use the `with_items`
    option. Aside from the fact that `with_items` makes your code easier to read and
    to follow, it could also improve your performance. An example is with the installation
    of packages (that is, the `apt`, `dnf`, `yum`, `package` modules) where Ansible
    will perform a single command if you use `with_items`, as opposed to a single
    command for each package if you don't. As you can imagine, this can help boost
    your performance.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what happens when your tasks are executed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even after you have implemented the methods we just talked about to speed up
    the playbook''s execution, you may still find that some tasks take a very long
    time. This is very common with some tasks, even if it''s possible with many other
    modules. The modules that usually give you this problem are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Packaging management (that is, `apt`, `dnf`, `yum`, `package`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud machine creation (that is, `digital_ocean`, `ec2`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason for this slowness is often non-Ansible specific. An example case
    could be if you used a packaging management module to update your machines. This
    requires downloading tens or hundreds of megabytes on every machine and installing
    a high quantity of software. A way to speed up this kind of operation is to have
    a local repository in your data center and have all your machines pointing to
    it instead of your distribution repositories. This will allow your machines to
    download at higher speed and without using the public connection that is often
    limited in bandwidth, or metered.
  prefs: []
  type: TYPE_NORMAL
- en: It's often important to understand what the modules do in the background to
    optimize the playbook's execution.
  prefs: []
  type: TYPE_NORMAL
- en: In the cloud machine creation case, Ansible just performs an API call to the
    chosen cloud provider and waits for the machine to be ready. DigitalOcean machines
    can take up to one minute to be created (and other clouds much longer), so Ansible
    will wait for that amount of time. Some modules have an asynchronous mode to avoid
    this wait period, but you'll have to ensure that the machine is ready before using
    it; otherwise, the modules that use the created machine will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how you can deploy an application with Ansible,
    as well as the various distribution and deployment strategies you can use. We
    also saw how to create RPM packages with Ansible and how to optimize the performance
    of Ansible using different methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at how to use Ansible on Windows machines,
    where to find roles written by other people and how to use them, and a user interface
    for Ansible.
  prefs: []
  type: TYPE_NORMAL
