- en: Scaling to Multiple Hosts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have specified the hosts in the command line. This
    worked well while having a single host to work on, but it will not work very well
    when managing multiple servers. In this chapter, we will see exactly how to leverage
    inventories to manage multiple servers. Also, we will introduce topics such as
    host variables and group variables to make it possible to easily and quickly set
    up similar but different hosts. We will speak about loops in **Ansible**, which
    allows you to reduce the amount of code you write and at the same time make it
    more readable as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with inventory files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can  download all the files from this book's GitHub repository at [https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter03](https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter03)[.](https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter03)
  prefs: []
  type: TYPE_NORMAL
- en: Working with inventory files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **inventory file** is the source of truth for Ansible (there is also an advanced
    concept called **dynamic inventory**, which we will cover later). It follows the
    **Initialization** (**INI**) format and tells Ansible whether the remote host
    or hosts provided by the user are genuine.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible can run its tasks against multiple hosts in parallel. To do this, you
    can directly pass the list of hosts to Ansible using an inventory file. For such
    parallel execution, Ansible allows you to group your hosts in the inventory file;
    the file passes the group's name to Ansible. Ansible will search for that group
    in the inventory file and run its tasks against all the hosts listed in that group.
  prefs: []
  type: TYPE_NORMAL
- en: You can pass the inventory file to Ansible using the `-i` or `--inventory-file`
    option followed by the path to the file. If you do not explicitly specify any
    inventory file to Ansible, it will take the default path from the `host_file`
    parameter of `ansible.cfg`, which defaults to `/etc/ansible/hosts`.
  prefs: []
  type: TYPE_NORMAL
- en: When using the `-i` parameter, if the value is a list (it contains at least
    one comma), it will be used as the inventory list, while if the variable is a
    string, it will be used as the inventory file path.
  prefs: []
  type: TYPE_NORMAL
- en: The basic inventory file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving into the concept, let''s first look at a basic inventory file
    called `hosts` that we can use instead of the list we used in the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Ansible can take either an FQDN or an IP address within the inventory file.
  prefs: []
  type: TYPE_NORMAL
- en: We can now perform the same operations that we did in the previous chapter,
    tweaking the Ansible command parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to install the web server, we used this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have substituted the list of hosts with the inventory filename.
  prefs: []
  type: TYPE_NORMAL
- en: Groups in an inventory file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The advantages of inventory files are noticeable when we have more complex situations.
    Let's say our website is getting more complicated and we now need a more complex
    environment. In our example, our website will require a MySQL database. Also,
    we will decide to have two web servers. In this scenario, it makes sense to group
    different machines based on their role in our infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible allows us to create an INI-like file with groups (INI sections) and
    hosts. Here''s what our hosts file would change to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can instruct playbooks to run only on hosts in a certain group. In the
    previous chapter, we have created three different playbooks for our website example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`firstrun.yaml` is generic and will have to be run on every machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`common_tasks.yaml` is generic and will have to be run on every machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webserver.yaml` is specific for web servers and therefore should not be run
    on any other machines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the only file that is specific for a group of the servers is the `webserver.yaml`
    one, we only need to change it. To do so, let''s open the `webserver.yaml` file
    and change content from **`- hosts: all` **to `- hosts: webserver`.'
  prefs: []
  type: TYPE_NORMAL
- en: With only those three playbooks, we cannot proceed with creating our environment
    with three servers. Since we don't have a playbook to set up the database yet
    (we will see it in the next chapter), we will provision the two web servers (`ws01.fale.io`
    and `ws02.fale.io`) completely, and, for the database server, we will only provision
    the base system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before running the Ansible playbooks, we will need to provision the environment.
    To do so, create the following vagrant file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Simply by running `vagrant up`, Vagrant will generate the whole environment
    for us. After a while of Vagrant outputting stuff in the shell, it should give
    you back the Command Prompt. When this happens, check that in the last few lines
    there were no errors, to be sure that everything went as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have provisioned the environment, we can proceed by executing the
    `firstrun` playbook, which will ensure that our Ansible user is present and has
    the right SSH-key set up. To do so, we can run it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following would be the result. Full output file is available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the output is very similar to what we received with a single
    host, but with one line per host at each step. In this case, all the machines
    were in the same state and the same steps have been performed, so we see that
    they all acted the same, but with more complex scenarios, you can have different
    machines returning different states on the same step. We can also execute the
    other two playbooks with similar results.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions in the inventory file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you have a large number of servers, it is common and helpful to give them
    predictable names, for instance, call all web servers `wsXY` or `webXY`, or call
    the database servers `dbXY`. If you do so, you can reduce the number of lines
    in your hosts file, increasing its readability. For instance, our hosts file can
    be simplified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have used `[01:02]` that will match for all occurrences
    between the first number (`01` in our case) and the last (`02` in our case). In
    our case, the gain is not huge, but if you have 40 web servers, you can cut 39
    lines from your hosts file.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have seen how to create an inventory file, how to add groups
    to an Ansible inventory, how to leverage ranges to speed up the process of the
    creation of inventories, and how to run an Ansible playbook against an inventory.
    We will now see how to set variables in inventories and how to use them in our
    playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Working with variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible allows you to define variables in many ways, from a variable file within
    a playbook, by passing it from the Ansible command using the `-e` / `--extra-vars`
    option. You can also do it by passing it to an inventory file. You can define
    variables in an inventory file either on a per-host basis, for an entire group,
    or by creating a variable file in the directory where your inventory file exists.
  prefs: []
  type: TYPE_NORMAL
- en: Host variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s possible to declare variables for a specific host, declaring them in
    the hosts file. For instance, we may want to specify different engines for our
    web servers. Let''s suppose that one needs to reply to a specific domain, while
    the other needs to reply to a different domain name. In this case, we would do
    it with the following hosts file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Every time we execute a playbook with this inventory, Ansible will first read
    the inventory file, and it will assign, on a per-host basis, the value of the
    `domainname` variable. In this way, all playbooks running on web servers will
    be able to refer to the `domainname` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Group variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are other cases where you want to set a variable that is valid for the
    whole group. Let''s suppose that we want to declare the variable `https_enabled`
    to `True` and its value has to be equal for all web servers. In this case, we
    can create a `[webserver:vars]` section, so we will use the following hosts file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remember that host variables will override group variables if the same variable
    is declared in both spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Variable files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you have a lot of variables to declare for each host and group, and
    the hosts file gets hard to read. In those cases, you can move the variables to
    specific files. For host-level variables, you'll need to create a file named the
    same as your host in the `host_vars` folder, while for group variables you'll
    have to use the group name for the file name and place them in the `group_vars`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we want to replicate the previous example of host-based variables using
    files, we will need to create the `host_vars/ws01.fale.io` file with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create the `host_vars/ws02.fale.io` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'While if we want to replicate the group-based variables example, we will need
    to have the `group_vars/webserver` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Inventory variables follow a hierarchy; at the top of this is the common variable
    file (we discussed this in the previous section, *Working with inventory files*)
    that will override any of the host variables, group variables, and inventory variable
    files. After this come the host variables, which will override group variables;
    lastly, group variables will override inventory variable files.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding configuration parameters with an inventory file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can override some of Ansible's configuration parameters directly through
    the inventory file. These configuration parameters will override all the other
    parameters that are set either through `ansible.cfg`, environment variables, or
    set in the playbooks themselves. Variables passed to the `ansible-playbook/ansible`
    command have priority over any other variable, including the ones set in the inventory
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the list of some parameters you can override from an inventory
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible_user`: This parameter is used to override the user that is used for
    communicating with the remote host. Sometimes, a certain machine needs a different
    user; in those cases, this variable will help you. For instance, if you are running
    Ansible from the *ansible* user but on the remote machine you need to connect
    to the *automation* user, setting `ansible_user=automation` will make it happen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_port`: This parameter will override the default SSH port with the
    user-specified port. Sometimes, sysadmin chooses to run SSH on a non-standard
    port. In this case, you''ll need to instruct Ansible about the change. If in your
    environment the SSH port is 22022 instead of 22, you will need to use `ansible_port=22022`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_host`: This parameter is used to override the host for an alias. If
    you want to connect by the DNS name (that is: `ws01.fale.io`) to the `10.0.0.3`
    machine, but for some reason the DNS would not resolve the host properly, you
    can force Ansible to use this IP instead of what the DNS would resolve, by setting
    the `ansible_host=10.0.0.3` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_connection`: This specifies the connection type to the remote host.
    The values are SSH, Paramiko, or local. Even though Ansible could connect to the
    local machine using its SSH daemon, this wastes lots of resources. In those cases,
    you can specify `ansible_connection=local` so that Ansible will open a standard
    shell instead of SSH.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_private_key_file`: This parameter will override the private key used
    for SSH; this will be useful if you want to use specific keys for a specific host.
    A common use case is if you have hosts spread across multiple data centers, multiple
    AWS regions, or different kinds of applications. Private keys can potentially
    be different in such scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible__type`: By default, Ansible uses the `sh` shell; you can override
    this using the `ansible_shell_type` parameter. Changing this to `csh`, `ksh`,
    and so on will make Ansible use the commands of that shell. This can be useful
    if you need to execute some `csh` or `ksh` scripts you have and it would be too
    costly to deal with them right away.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with dynamic inventories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are environments where you have a system that creates and destroys machines
    automatically. We will see how to do this with Ansible in [Chapter 5](9bd9ae64-df2b-4dd0-b43e-da6da4553943.xhtml),
    *Going Cloud.* In such environments, the list of machines changes very quickly
    and keeping the hosts file becomes complicated. In this case, we can use dynamic
    inventories to solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind dynamic inventories is that Ansible will not read the hosts
    file but instead execute a script that will return the list of hosts to Ansible
    in JSON format. This allows you, for instance, to query your cloud provider and
    ask it directly about the machines in your entire infrastructure that are running
    at any given moment.
  prefs: []
  type: TYPE_NORMAL
- en: Many scripts for the most common cloud providers are already available through
    Ansible at [https://github.com/ansible/ansible/tree/devel/contrib/inventory](https://github.com/ansible/ansible/tree/devel/contrib/inventory),
    but you can create a custom script if you have different needs. The Ansible inventory
    scripts can be written in any language but, for consistency reasons, dynamic inventory
    scripts should be written in Python. Remember that these scripts need to be executable
    directly, so please remember to set them with the executable flag (`chmod + x
    inventory.py`).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will take a look at Amazon Web Services and DigitalOcean scripts that
    can be downloaded from the official Ansible repository.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To allow Ansible to gather data from **Amazon Web Services** (**AWS**) about
    your EC2 instances, you need to download the following two files from Ansible''s
    GitHub repository at [https://github.com/ansible/ansible](https://github.com/ansible/ansible):'
  prefs: []
  type: TYPE_NORMAL
- en: The `ec2.py` inventory script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ec2.ini` file, which contains the configuration for your EC2 inventory
    script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible uses **Boto**, the AWS Python SDK, to communicate with AWS using APIs.
    To allow this communication, you need to export the `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the inventory in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Pass it directly to an `ansible-playbook` command using the `-i` option and
    copy the `ec2.ini` file to your current directory where you are running the Ansible
    commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the `ec2.py` file to `/etc/ansible/hosts`, and make it executable using
    `chmod +x`, and copy the `ec2.ini` file to `/etc/ansible/ec2.ini`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ec2.py` file will create multiple groups based on the region, availability
    zone, tags, and so on. You can check the contents of the inventory file by running
    `./ec2.py --list`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example playbook with the EC2 dynamic inventory, which will simply
    ping all machines in my account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we executed the ping module, we expect the machines available in the
    configured account to reply to us. Since I have just one EC2 machine with the
    IP address 52.28.138.231 currently in my account, we can expect it to reply, and
    in fact the EC2 I have on my account responded with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we're using the `ec2.py` script instead of a static
    inventory file with the `-i` option and the ping command.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can use these inventory scripts to perform various types of operations.
    For example, you can integrate them with your deployment script to figure out
    all the nodes in a single zone and deploy to them if you're performing your deployment
    zone-wise (a zone represents a data center) in AWS.
  prefs: []
  type: TYPE_NORMAL
- en: If you simply want to know what the web servers in the cloud are and you've
    tagged them using a certain convention, you can do that by using the dynamic inventory
    script by filtering out the tags. Furthermore, if you have special scenarios that
    are not covered by your present script, you can enhance it to provide the required
    set of nodes in JSON format and then act on those nodes from the playbooks. If
    you're using a database to manage your inventory, your inventory script can query
    the database and dump a JSON. It could even sync with your cloud and update your
    database on a regular basis.
  prefs: []
  type: TYPE_NORMAL
- en: DigitalOcean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we used the EC2 files in [https://github.com/ansible/ansible/tree/devel/contrib/inventory](https://github.com/ansible/ansible/tree/devel/contrib/inventory)
    to pull data from AWS, we can do the same for DigitalOcean. The only difference
    will be that we have to fetch the `digital_ocean.ini` and the `digital_ocean.py`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: As before, we will need to tweak the `digital_ocean.ini` options, if needed,
    and to make the Python file executable. The only option that you'll probably need
    to change is `api_token`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can try to ping the two machines I''ve provisioned on DigitalOcean with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the two droplets I have on my account respond with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We have now seen how easy it is to retrieve data from many different cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: Working with iterates in Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that up to now we have never used cycles, so every time
    we had to do multiple, similar operations, we wrote the code multiple times. An
    example of this is the `webserver.yaml` code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, this is the last part of the `webserver.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the last two blocks of the `webserver.yaml` code do very similar
    operations: ensure that a certain port of the firewall is open.'
  prefs: []
  type: TYPE_NORMAL
- en: Using standard iteration – with_items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Repeating code is not a problem per se, but it does not scale.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible allows us to use iteration to improve the code both as clarity and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve the preceding code, we can use a simple iteration: `with_items`.'
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to iterate in a list of items. At every iteration, the designated
    item of the list will be available to us in the item variable. This allows us
    to perform multiple similar operations in a single block.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can therefore change the last part of the `webserver.yaml` code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can execute it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We receive the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the output is slightly different than the previous execution.
    In fact, on the lines for operations with loops, we can see the `item` that was
    processed in that specific iteration of the `Ensure HTTP and HTTPS can pass the
    firewall` block.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen that we can iterate on a list of items, but Ansible allows
    us other kinds of iterations as well.
  prefs: []
  type: TYPE_NORMAL
- en: Using nested loops – with_nested
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are cases where you have to iterate all elements of a list with all items
    from other lists (Cartesian product). One case that is very common is when you
    have to create multiple folders in multiple paths. In our example, we will create
    the folders `mail` and `public_html` in the home folders of the users `alice`
    and `bob`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do so with the following code snippet from the `with_nested.yaml` file;
    the full code is available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We receive the following result. Full output file is available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, Ansible created the users alice and bob on all
    target machines, and it also created the folders `$HOME/mail` and `$HOME/public_html`
    for both users on all machines.
  prefs: []
  type: TYPE_NORMAL
- en: Fileglobs loop – with_fileglobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we want to perform an action on every file present in a certain
    folder. This could be handy if you want to copy multiple files with similar names
    from one folder to another. To do so, you can create a file called `with_fileglobs.yaml`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can execute it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This results in the following output. Full output file is available on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As for our goal, we have created the /tmp/iproute2 folder and populated with
    a copy of the files in the `/etc/iproute2` folder. This pattern is often used
    to create backups of configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Using an integer loop – with_sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many times, you''ll need to iterate over the integer numbers. An example could
    be to create ten folders called `fileXY`, where `X` and `Y` are sequential numbers
    from `1` to `10`. To do so, we can create a file called `with_sequence.yaml` with
    the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the majority of Ansible commands, where we can use the single-line notation
    for objects and the standard YAML multi-line notation, `with_sequence` only supports
    the single line notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then execute it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Ansible supports many more types of loop, but since they are used far less,
    you can refer directly to the official documentation about loops at: [http://docs.ansible.com/ansible/playbooks_loops.html](http://docs.ansible.com/ansible/playbooks_loops.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored a large number of concepts that will help
    scale your infrastructure beyond the single node. We started with inventory files
    used to instruct Ansible about our machines, and then we covered how to have host-specific
    and group-specific variables while running the same command on multiple heterogeneous
    hosts. We then moved on to dynamic inventories that are populated directly by
    some other system (usually a cloud provider). Finally, we analyzed multiple kinds
    of iteration in the Ansible playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will structure our Ansible files in a saner way to ensure
    maximum readability. To do this, we introduce roles that simplify the management
    of complex environments even more.
  prefs: []
  type: TYPE_NORMAL
