- en: Debugging and Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like software code, testing infrastructure code is an all-important task. There
    should ideally be no code floating around in production that has not been tested,
    especially when you have strict customer SLAs to meet, and this is true even for
    the infrastructure. In this chapter, we''ll look at syntactic checks, testing
    without applying the code on the machines (the no-op mode), and functional testing
    for playbooks, which are at the core of Ansible and trigger the various tasks
    you want to perform on the remote hosts. It is recommended that you integrate
    some of these into your **Continuous Integration** (**CI**) system that you have
    for Ansible to better test your playbooks. We''ll be looking at the following
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking mode with and without `--diff`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As part of functional testing, we will be looking at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Assertions on the end state of the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `--syntax-check` option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `ANSIBLE_KEEP_REMOTE_FILES` and `ANSIBLE_DEBUG` flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will then look at how to manage exceptions and how to voluntarily trigger
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, there are no specific requirements except the usual ones,
    such as Ansible, Vagrant, and a shell.
  prefs: []
  type: TYPE_NORMAL
- en: You can download all of the files from this book's GitHub repository at [https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter08](https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Syntax checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever you run a playbook, Ansible first checks the syntax of the playbook
    file. If an error is encountered, Ansible will error out saying there was a syntax
    error and will not proceed unless you fix that error. This syntax checking is
    performed only when you run the `ansible-playbook` command. When writing a big
    playbook, or if you have included task files, it might be difficult to fix all
    of the errors; this might end up wasting more time. In order to deal with such
    situations, Ansible provides a way to check your YAML syntax as you keep progressing
    with your playbook. For this example, we will need to create the `playbooks/setup_apache.yaml` file
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our example file, we need to run it with the `--syntax-check`
    parameter; so, you will need to invoke Ansible as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ansible-playbook` command checked the YAML syntax of the `setup_apache.yml`
    playbook and showed that the syntax of the playbook was correct. Let''s look at
    the resulting errors from the invalid syntax in the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The error shows that there is an indentation error in the `Enable Apache` task.
    Ansible also gives you the line number, column number, and the filename where
    this error is found (even if this is not a guarantee of the exact location of
    the error). This should definitely be one of the basic tests that you should run
    as part of your CI for Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: The check mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The check mode (also known as the **dry-run** or **no-op mode**) will run your
    playbook in a no-operation mode—that is, it will not apply any changes to the
    remote host; instead, it will just show the changes that will be introduced when
    a task is run. Whether the check mode is actually enabled or not depends on each
    module. There are few commands that you may find interesting. All of these commands
    will have to be run in `/usr/lib/python2.7/site-packages/ansible/modules`, or
    where your Ansible module folder is (different paths could be possible based on
    the operating system you are using as well as the way you installed Ansible).
  prefs: []
  type: TYPE_NORMAL
- en: 'To count the number of available modules on your installation, you can perform
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With Ansible 2.7.2, the result of this command is `2095`, since Ansible has
    that many modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see how many of these support the check mode, you can run the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With Ansible 2.7.2, the result of this command is `1239`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also find the following command useful for listing all modules that
    support the check mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This helps you to test how your playbook will behave and check whether there
    may be any failures before running it on your production server. You run a playbook
    in the check mode by simply passing the `--check` option to your `ansible-playbook`
    command. Let''s see how the check mode works with the `setup_apache.yml` playbook,
    running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding run, instead of making the changes on the target host, Ansible
    highlighted all of the changes that would have occurred during the actual run.
    From the preceding run, you can find that the `httpd` service was already installed
    on the target host. Because of this, Ansible''s exit message for that task was
    OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, with the second task, it found that the `httpd` service was not running
    on the target host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When you run the preceding playbook again without the check mode enabled, Ansible
    will make sure that the service state is running.
  prefs: []
  type: TYPE_NORMAL
- en: Indicating differences between files using --diff
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the check mode, you can use the `--diff` option to show the changes that
    would be applied to a file. To be able to see the `--diff` option in use, we need
    to create a `playbooks/setup_and_config_apache.yaml` playbook to match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we added a task that will ensure a certain state of the `/etc/httpd/conf.d/userdir.conf`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to create a template file placed in `templates/userdir.conf` with
    the following content (the full file is available on GitHub):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this template, we only changed the `UserDir enabled` line, which, by default,
    is `UserDir disabled`.
  prefs: []
  type: TYPE_NORMAL
- en: The `--diff` option doesn't work with the `file` module; you will have to use
    the `template` module only.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now test the result of this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are using the `--check` parameter that will ensure this
    will be a dry run. We will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, Ansible compares the current file of the remote host with the
    source file; a line starting with `+` indicates that a line was added to the file,
    while `-` indicates that a line was removed.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `--diff` without the `--check` option, which will allow Ansible
    to make the specified changes and show the difference between two files.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `--diff` and `--check` modes together is a test step that can potentially
    be used as part of your CI tests to assert how many steps have changed as part
    of the run. Another case where you can use those features together is the part
    of the deployment process that checks what exactly will change when you run Ansible
    on that machine.
  prefs: []
  type: TYPE_NORMAL
- en: There are also cases—which should not happen, but sometimes do—where you have
    not run a playbook on a machine for a very long time and you are worried that
    running it again will break something. Using those options together should help
    you to understand whether it was just worrying you or whether this is a real risk.
  prefs: []
  type: TYPE_NORMAL
- en: Functional testing in Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wikipedia says functional testing is a **quality assurance** (**QA**) process
    and a type of black-box testing that bases its test cases on the specifications
    of the software component under the test. Functions are tested by feeding them
    input and examining the output; the internal program structure is rarely considered.
    Functional testing is as important as code when it comes to infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: From an infrastructure perspective, with respect to functional testing, we test
    output of our Ansible runs on the actual machines. Ansible provides multiple ways
    to perform the functional testing of your playbook; let's look at some of the
    most commonly used methods.
  prefs: []
  type: TYPE_NORMAL
- en: Functional testing using assert
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The check mode will only work when you want to check whether a task will change
    anything on the host or not. This will not help when you want to check whether
    the output of your module is what you expected. For example, let's say you wrote
    a module that will check whether a port is up or not. In order to test this, you
    might need to check the output of your module and see whether it matches the desired
    output or not. To perform such tests, Ansible provides a way to directly compare
    the output of a module with the desired output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this works by creating the `playbooks/assert_ls.yaml` file with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding playbook, we''re running the `ls` command on the target host
    and registering the output of that command in the `list_files` variable. Further
    to this, we ask Ansible to check whether the output of the `ls` command has the
    expected result. We do this using the `assert` module, which uses some conditional
    checks to verify whether or not the `stdout` value of a task meets the expected
    output of the user. Let''s run the preceding playbook to see what output Ansible
    returns, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we don''t have the file, we will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we re-run the playbook after we create the expected file, this will be the
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This time, the task passed with an OK message as `testfile.txt` was present
    in the `list_files` variable. Likewise, you can match multiple strings in a variable
    or multiple variables using the `and` and `or` operators. The assertion feature
    is quite powerful, and users who have written either unit or integration tests
    in their projects will be quite happy to see this feature!
  prefs: []
  type: TYPE_NORMAL
- en: Testing with tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tags are a great way to test a bunch of tasks without running an entire playbook.
    We can use tags to run actual tests on the nodes to verify the state that the
    user intended to be in the playbook. We can treat this as another way to run integration
    tests for Ansible on the actual box. The tag method to test can be run on the
    actual machines where you run Ansible, and it can be used primarily during deployments
    to test the state of your end systems. In this section, we'll first look at how
    to use `tags` in general, their features that can possibly help us, not just with
    testing but even for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add tags in your playbook, use the `tags` parameter followed by one or more
    tag names separated by commas or YAML lists. Let''s create a simple playbook in
    `playbooks/tags_example.yaml` to see how the tags work with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now run the playbook, the file will be created and destroyed. We can
    see it running with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It will give us this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since this is not an idempotent playbook, if we run it over and over, we will
    always see the same result, as the playbook will create and delete the file every
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we added two tags: `file_present` and `file_absent`. You can now simply
    pass the `file_present` tag or the `file_absent` tag to only perform one of the
    actions, like in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the `-t file_present` part, only the tasks with the `file_present`
    tag will be executed; in fact, this will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can also use tags to perform a set of tasks on the remote host, just like
    taking a server out of a load balancer and adding it back to the load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `--check` option with tags. By doing this, you can test
    your tasks without actually running them on your hosts. This allows you to test
    a bunch of individual tasks directly, instead of copying your tasks to a temporary
    playbook and running it from there.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the --skip-tags option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible also provides a way to skip some tags in a playbook. If you have a
    long playbook with multiple tags, such as 10, and you want to execute them all
    but one, then it would not be a good idea to pass nine tags to Ansible. The situation
    would be more difficult if you forgot to pass a tag and the `ansible-run` command
    fails. To overcome such situations, Ansible provides a way to skip a couple of
    tags, instead of passing multiple tags, which should run. Its functioning is pretty
    straightforward, and can be triggered in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all tasks have been executed except the one with the `file_present`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding debugging commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible allows us to use two very powerful variables to help us to debug.
  prefs: []
  type: TYPE_NORMAL
- en: The `ANSIBLE_KEEP_REMOTE_FILES` variable allows us to tell Ansible to keep the
    files it creates on remote machines so that we can go back and debug them.
  prefs: []
  type: TYPE_NORMAL
- en: The `ANSIBLE_DEBUG` variable allows us to tell Ansible to print all debug content
    to the shell. The debug output is often overkill, but it might help with some
    very complex-to-solve issues.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to find problems in your playbooks. Sometimes, you know that
    a specific step can fail, but it's OK. In this case, we should manage the exception
    properly. Let's look at how to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Managing exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many cases where, for one reason or another, you want your playbook
    and roles to carry on in case one or more tasks fail. A typical example of this
    could be that you want to check whether software is installed or not. Let''s look
    at the following example to install Java 11 if, and only if, Java 8 is not installed.
    In the `roles/java/tasks/main.yaml` file, we are going to enter the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Before going forward with the other parts that are needed to execute this role,
    I'd like to spend a few words on the various parts of the role task list, since
    there are many new things.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this task, we will execute an `rpm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can have two possible output:'
  prefs: []
  type: TYPE_NORMAL
- en: Fail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the complete name of the JDK package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we want only to check whether the package exists or not and then to go
    forward, we register the output (the *fifth* line) and ignore eventual failures
    (the *sixth* line).
  prefs: []
  type: TYPE_NORMAL
- en: 'When it fails, it means that `Java8` is not installed, and therefore we can
    proceed to install `Java11`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After we create the role, we will need the `hosts` file containing the host
    machine; in my case, it will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need a playbook to apply the role, placed in `playbooks/hosts/j01.fale.io.yaml`
    and with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now execute it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the installation check failed since Java was not installed on
    the machine, and for this reason, the other task has been executed as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Trigger failure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are cases when you want to trigger a failure directly. This can happen
    for multiple reasons, even if there are disadvantages in doing so since, when
    you trigger the failure, the playbook will be brutally interrupted and this could
    leave your machine in an inconsistent state if you are not careful. One case where
    I have seen it work very well is when you are running a non-idempotent playbook
    (for instance, building a newer version of an application) and you need a variable
    (for instance, the version/branch to deploy) set. In this case, you can check
    that the expected variable is correctly configured before starting to run the
    operations to ensure that everything will work as expected later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put the following code in `playbooks/maven_build.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we expect the user to add `--extra-vars "version=$[TAG/BRANCH]"`
    in the script-calling command. We could have put a branch to use by default, but
    this is too risky because the user may lose focus and forget to add the right
    branch name themselves, which would lead to compiling (and deploying) the wrong
    version of the application. The `fail` module also allows us to specify a message
    that will be displayed to the user.
  prefs: []
  type: TYPE_NORMAL
- en: I think that the `fail` task is far more useful in playbooks that are run manually
    since, when a playbook is automatically run, managing the exception is often better
    than failing.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `fail` module, you will be able to quit from playbooks as soon as
    a problem is detected.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to debug Ansible playbooks using syntax checking,
    the checking mode with and without `--diff`, and functional testing.
  prefs: []
  type: TYPE_NORMAL
- en: As part of functional testing, we have seen how to perform assertions on the
    end state of the system, how to leverage tags for testing as well as how to use
    the `--syntax-check` option and the `ANSIBLE_KEEP_REMOTE_FILES` and `ANSIBLE_DEBUG`
    flags. Then, we moved to the management of failures, and, lastly, we saw how to
    trigger failures intentionally.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss multi-tier environments as well as deployment
    methodologies.
  prefs: []
  type: TYPE_NORMAL
