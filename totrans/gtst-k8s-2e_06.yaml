- en: Storage and Running Stateful Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss how to attach persistent volumes and create
    storage for stateful applications and data. We will walk through storage concerns
    and how we can persist data across pods and the container life cycle. We will
    explore the **PersistentVolumes** types as well as **PersistentVolumeClaim**.
    Finally, we will take a look at the new **StatefulSets** release in version 1.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Persistent storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PersistentVolumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PersistentVolumeClaims
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: StorageClasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: StatefulSets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we only worked with workloads that we could start and stop at will,
    with no issue. However, real-world applications often carry state and record data
    that we prefer (even insist) not to lose. The transient nature of containers themselves
    can be a big challenge. If you recall our discussion of layered file systems in
    [Chapter 1](772262b1-5b78-4a9b-bbb4-09c6fd858fdf.xhtml), *Introduction to Kubernetes*,
    the top layer is writable. (It's also frosting, which is delicious.) However,
    when the container dies, the data goes with it. The same is true for crashed containers
    that Kubernetes restarts.
  prefs: []
  type: TYPE_NORMAL
- en: This is where** volumes** or disks come into play. A volume that exists outside
    the container allows us to save our important data across containers outages.
    Further, if we have a volume at the pod level, data can be shared between containers
    in the same application stack and within the same pod.
  prefs: []
  type: TYPE_NORMAL
- en: Docker itself has some support for volumes, but Kubernetes gives us persistent
    storage that lasts beyond the lifetime of a single container. The volumes are
    tied to pods and live and die with those pods. Additionally, a pod can have multiple
    volumes from a variety of sources. Let's take a look at some of these sources.
  prefs: []
  type: TYPE_NORMAL
- en: Temporary disks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the easiest ways to achieve improved persistence amid container crashes
    and data sharing within a pod is to use the `emptydir` volume. This volume type
    can be used with either the storage volumes of the node machine itself or an optional
    RAM disk for higher performance.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we improve our persistence beyond a single container, but when a pod
    is removed, the data will be lost. Machine reboot will also clear any data from
    RAM-type disks. There may be times when we just need some shared temporary space
    or have containers that process data and hand it off to another container before
    they die. Whatever the case, here is a quick example of using this temporary disk
    with the RAM-backed option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your favorite editor and create a file like the one in the following *Listing
    6-1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-1*: `storage-memory.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example is probably of second nature by now, but we will once
    again issue a `create` command followed by an `exec` command to see the folders
    in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us a bash shell in the container itself. The `ls` command shows
    us a `memory-pd` folder at the top level. We use `grep` to filter the output,
    but you can run the command without `| grep memory-pd` to see all folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06302_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Temporary storage inside a container
  prefs: []
  type: TYPE_NORMAL
- en: Again, this folder is quite temporary as everything is stored in the node's
    (minion's) RAM. When the node gets restarted, all the files will be erased. We
    will look at a more permanent example next.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many companies will already have significant infrastructure running in the public
    cloud. Luckily, Kubernetes has native support for the durable storage provided
    by two of the most popular providers.
  prefs: []
  type: TYPE_NORMAL
- en: GCE persistent disks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have the following from the GCE website:'
  prefs: []
  type: TYPE_NORMAL
- en: <q>Google Persistent Disk is durable and high performance block storage for
    the Google Cloud Platform. Persistent Disk provide SSD and HDD storage which can
    be attached to instances running in either Google Compute Engine or Google Container
    Engine. Storage volumes can be transparently resized, quickly backed up, and offer
    the ability to support simultaneous readers. </q>(you can refer to more details
    about this in point 1 in the *References* section at the end of the chapter)
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new **GCE persistent disk**.
  prefs: []
  type: TYPE_NORMAL
- en: From the console, in Compute Engine, go to Disks. On this new screen, click
    on the Create Disk button. We'll be presented with a screen similar to the following GCE
    new persistent disk image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a name for this volume and give it a brief description. Make sure that
    Zone is the same as the nodes in your cluster. GCE PDs can only be attached to
    machines in the same zone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter `mysite-volume-1` in the Name field. Choose the zone matching at least
    one node in your cluster. Choose None (blank disk) for Source type and give `10`
    (10 GB) as value in Size (GB). Finally, click on Create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06302_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: GCE new persistent disk
  prefs: []
  type: TYPE_NORMAL
- en: 'The nice thing about PDs on GCE is that they allow for mounting to multiple
    machines (nodes in our case). However, when mounting to multiple machines, the
    volume must be in read-only mode. So, let''s first mount this to a single pod,
    so we can create some files. Use *Listing 6-2*: `storage-gce.yaml` as follows
    to create a pod that will mount the disk in read/write mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-2*: `storage-gce.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s issue a `create` command followed by a `describe` command to
    find out which node it is running on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the node and save the pod IP address for later. Then, open an SSH session
    into that node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06302_06_03-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Pod describe with persistent disk
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''ve already looked at the volume from inside the running container,
    let''s access it directly from the node (minion) itself this time. We will run
    a `df` command to see where it is mounted, but we will need to switch to root
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the GCE volume is mounted directly to the node itself. We can
    use the mount path listed in the output of the earlier `df` command. Use `cd`
    to change to the folder now. Then, create a new file named `index.html` with your
    favorite editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter a quaint message such as `Hello from my GCE PD!`. Now save the file and
    exit the editor. If you recall from *Listing 6-2*, the PD is mounted directly
    to the Nginx HTML directory. So, let''s test this out while we still have the
    SSH session open on the node. Do a simple `curl` command to the pod IP we wrote
    down earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You should see Hello from my GCE PD! or whatever message you saved in the `index.html`
    file. In a real-world scenario, we can use the volume for an entire website or
    any other central storage. Let's take a look at running a set of load balanced
    web servers all pointing to the same volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, leave the SSH session with two `exit` commands. Before we proceed, we
    will need to remove our `test-gce` pod so that the volume can be mounted read-only
    across a number of nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create a RC that will run three web servers all mounting the same
    persistent disk, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-3*: `http-pd-controller.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also create an external service, so we can see it from outside the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-4*: `http-pd-service.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and create these two resources now. Wait a few moments for the external
    IP to get assigned. After this, a `describe` command will give us the IP we can
    use in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is the result of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06302_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: K8s service with GCE PD shared across three pods
  prefs: []
  type: TYPE_NORMAL
- en: If you don't see the LoadBalancer Ingress field yet, it probably needs more
    time to get assigned. Type the IP address from LoadBalancer Ingress into a browser,
    and you should see your familiar `index.html` file show up with the text we entered
    previously!
  prefs: []
  type: TYPE_NORMAL
- en: AWS Elastic Block Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: K8s also supports AWS **Elastic Block Store** (**EBS**) volumes. Like the GCE
    PDs, EBS volumes are required to be attached to an instance running in the same
    availability zone. A further limitation is that EBS can only be mounted to a single
    instance at one time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For brevity, we will not walk through an AWS example, but a sample YAML file
    is included to get you started. Again, remember to create the EBS volume before
    your pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-5*: `storage-aws.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: Other storage options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes supports a variety of other types of storage volumes. A full list
    can be found here: [http://kubernetes.io/v1.0/docs/user-guide/volumes.html#types-of-volumes](http://kubernetes.io/v1.0/docs/user-guide/volumes.html#types-of-volumes).
    [](http://kubernetes.io/v1.0/docs/user-guide/volumes.html#types-of-volumes)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few that may be of particular interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nfs`: This type allows us to mount a **Network File Share** (**NFS**), which
    can be very useful for both persisting the data and sharing it across the infrastructure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gitrepo`: As you might have guessed, this option clones a Git repo into a
    new and empty folder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PersistentVolumes and StorageClasses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far, we've seen examples of directly provisioning the storage within our
    pod definitions. This works quite well if you have full control over your cluster
    and infrastructure, but at larger scales, application owners will want to use
    storage that is managed separately. Typically, a central IT team or the cloud
    provider itself will take care of the details behind provisioning storage and
    leave the application owners to worry about their primary concern, the application
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: In order to accommodate this, we need some way for the application to specify
    and request storage without being concerned with how that storage is provided.
    This is where `PersistentVolumes` and `PersistentVolumeClaims` come into play. `PersistentVolumes`
    are similar to `volumes` we created earlier, but they are provided by the cluster
    administer and are not dependent on a particular pod. This volume can then be
    claimed by pods using `PersistentVolumeClaims`.
  prefs: []
  type: TYPE_NORMAL
- en: '`PersistentVolumeClaims` allows us to specify the details of the storage needed.
    We can defined the amount of storage as well as the access type such as `ReadWriteOnce`
    (read and write by one node), `ReadOnlyMany` (read-only by multiple nodes), and `ReadWriteMany` (read
    and write by many nodes). Of course, which modes are supported is dependent on
    the backing storage provider. For example, we saw in the AWS EBS example that
    mounting to multiple nodes was not an option.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Kubernetes provides two other methods for specifying certain groupings
    or types of storage volumes. The first is the use of selectors as we have seen
    previously for pod selection. Here, labels can be applied to storage volumes and
    then claims can reference these labels to further filter the volume they are provided.
    Second, Kubernetes has a concept of StorageClass which allows us specify a storage
    provisioner and parameters for the type of volumes it provisions.
  prefs: []
  type: TYPE_NORMAL
- en: We will dive into StorageClasses in the next section, but here is a quick example
    of a `PersistentVolumeClaims` for illustration purposes. You can see in the annotations
    that we request `1Gi` of storage in `ReadWriteOnce` mode with a StorageClass of
    `solidstate` and label of `aws-storage`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-6:* `pvc-example.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: StatefulSets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of **StatefulSets** is to provide some consistency and predictability
    to application deployments with stateful data. Thus far, we have deployed applications
    to the cluster defining loose requirements around needed resources such as computer
    and storage. The cluster has scheduled our workload on any node that can meet
    these requirements. While we can use some of these constraints to deploy in a
    more predictable manner, it will be helpful if we had a construct built to help
    us provide this consistency.
  prefs: []
  type: TYPE_NORMAL
- en: StatefulSets were set to GA in 1.6 as we went to press. There were previously
    beta in version 1.5 and were known as PetSets prior to that (alpha in 1.3 and
    1.4).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where StatefulSets come in. StatefulSets provide us first with numbered
    and reliable naming for both network access and storage claims. The pods themselves
    are names with the following convention, where `N` is from 0 to the number of
    replicas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that a Statefulset called `db` with 3 replicas will create the following
    pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This gives Kubernetes a way to associate network names and `PersistentVolumes`
    with specific pods. Additionally, it also serves to order creation and termination
    of pods. Pod will be started from `0` to `N` and terminated from `N` to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: A stateful example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of a stateful application. First, we will
    want to create and use a StorageClass as we discussed earlier. This will allow
    us to hook into the Google Cloud Persistent Disk provisioner. The Kubernetes community
    is building provisioners for a variety of `StorageClasses` including GCP and AWS.
    Each provisioner has its own set of parameters available. Both GCP and AWS providers
    let you choose the type of disk (solid-state, standard, and so on) as well as
    the fault zone which is needed to match the pod attaching to it. AWS additionally
    allows you to specify encryption parameters as well as IOPs for Provisioned IOPs
    volumes. There are a number of other provisioners in the works including Azure
    and a variety of non-cloud options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-7:* `solidstate-sc.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command with the preceding listing to create a `StorageClass`
    kind of SSD drives in `us-central1-b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a `StatefulSet` kind with our trusty `httpwhalesay` demo
    (you can refer to more details about this in point 2 in the *References* section
    at the end of the chapter). While this application does include any real state,
    we can see the storage claims and explore the communication path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-8:* `sayhey-statefulset.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to get to start the creation of this StatefulSet.
    If you observe pod creation closely, you will see it create whaleset-0, whaleset-1,
    and whaleset-2 in succession:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately after this, we can see our StatefulSet and the corresponding pods
    using the familiar `get` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'These pods should create an output similar to the following images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06302_06_05.png)'
  prefs: []
  type: TYPE_IMG
- en: StatefulSet listing
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get pods` output will show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06302_06_06.png)'
  prefs: []
  type: TYPE_IMG
- en: Pods created by StatefulSet
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your timing, the pods may still be creating. As you can see in
    the preceding image, the third container is still being spun up.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see the volumes the set has created and claim for each pod. First
    PersistentVolumes themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command should show the three PersistentVolumes named `www-whaleset-N`.
    We notice the size is `1Gi` and the access mode is set to **ReadWriteOnce** (`RWO`)
    just as we defined in our StorageClass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06302_06_07.png)'
  prefs: []
  type: TYPE_IMG
- en: The PersistentVolumes listing
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we can look at the PersistentVolumeClaims that reserve the volumes for
    each pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06302_06_08.png)'
  prefs: []
  type: TYPE_IMG
- en: The PersistentVolumeClaims listing
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice much of the same settings here as with the PVs themselves. You
    might also notice the end of the claim name (or PV name in the previous listing)
    looks like `www-whaleset-N`. `www` is the mount name we specified in the preceding
    YAML definition. This is then appended to the pod name to create the actual PV
    and PVC name. One more area we can ensure that the proper disk is linked with
    it is matching pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another area where this alignment is important is in the network communication.
    StatefulSets also provide consistent naming here. Before we can do this, let''s
    create a service endpoint so we have a common entry point for incoming requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 6-9:* `sayhey-svc.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s open a shell in one of the pods and see if we can communicate with
    another in the set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command gives us a bash shell in the first whaleset pod. We can
    now use the `Service` name to make a simple HTTP request. We can use both the
    short name, `sayhey-svc`, and the fully qualified name, `sayhey-svc.default.svc.cluster.local`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see an output similar to the following image. The service endpoint
    acts as a common communication point for all three pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06302_06_09-1.png)'
  prefs: []
  type: TYPE_IMG
- en: HTTP Whalesay curl output (whalesay-0 Pod)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see if we can communicate with a specific pod in the StatefulSet.
    As we noticed earlier, the StatefulSet named the pod in an orderly manner. It
    also gives them hostnames in a similar fashion so that there is a specific DNS
    entry for each pod in the set. Again, we will see the convention of `"Name of
    Set"-N` and then add the fully qualified service URL. The following example shows
    this for `whaleset-1`, which is the second Pod in our set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this command from our existing Bash shell in whaleset-0 will show us
    the output from `whaleset-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06302_06_10-1.png)'
  prefs: []
  type: TYPE_IMG
- en: HTTP Whalesay curl output (whalesay-1 Pod)
  prefs: []
  type: TYPE_NORMAL
- en: You can exit out of this shell now with `exit`.
  prefs: []
  type: TYPE_NORMAL
- en: For learning purposes, it can also be instructive to describe some of the items
    from this section in more detail. For example, `kubectl describe svc sayhey-svc`
    will show us all three pod IP address in the service endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored a variety of persistent storage options and how
    to implement them with our pods. We looked at PersistentVolumes and also PersistentVolumeClaims,
    which allow us to separate storage provisioning and application storage requests.
    Additionally, we looked at StorageClasses for provisioning groups of storage according
    to a specification.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored the new StatefulSets abstraction and learned how we can deploy
    stateful applications in a consistent and ordered manner. In the next chapter,
    we will look at how to integrate Kubernetes with Continuous Integration and Delivery
    pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://cloud.google.com/persistent-disk/](https://cloud.google.com/persistent-disk/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HTTP Whalesay is an adaptation of Docker whalesaym which is in-turn an adaptation
    of Linux cowsay (circa 1999, Tony Monroe) - [https://hub.docker.com/r/docker/whalesay/](https://hub.docker.com/r/docker/whalesay/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
