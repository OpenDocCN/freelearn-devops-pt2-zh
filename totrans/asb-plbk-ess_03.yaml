- en: Chapter 2. Going Modular with Ansible Roles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章。使用 Ansible 角色进行模块化
- en: In the last chapter, you learned about writing a simple playbook with Ansible.
    You also learned about the concepts of plays which map hosts to tasks. Writing
    tasks in a single playbook may work fine for a very simple setup. However, if
    we have multiple applications spanning across number of hosts, this will quickly
    become unmanageable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了使用 Ansible 编写简单 playbook。你还了解了将主机映射到任务的 plays 概念。在单个 playbook 中编写任务对于非常简单的设置可能效果很好。然而，如果我们有多个跨越多个主机的应用程序，这将很快变得难以管理。
- en: 'In this chapter, you will be introduced to the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将会接触到以下概念：
- en: What makes a role and what are roles used for?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是角色，角色用于什么？
- en: How to create roles to provide abstraction?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建角色以提供抽象化？
- en: Organizing content to provide modularity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织内容以提供模块化
- en: Using include statements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包含语句
- en: Writing simple tasks and handlers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写简单任务和处理程序
- en: Installing packages, managing services, and serving files with Ansible modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 模块安装包、管理服务和提供文件
- en: Understanding roles
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解角色
- en: In real-life scenarios, we will mostly be configuring web servers, database
    servers, load balancers, middleware queues, and so on. If you take one step back
    and look at the big picture, you will realize that you are configuring groups
    of identical servers in a repeatable fashion.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中的场景中，我们大多数时间都会配置 web 服务器、数据库服务器、负载均衡器、中间件队列等等。如果你退一步看一下大局，你会意识到你正在以可重复的方式配置一组相同的服务器。
- en: To manage such infrastructures in the most efficient way, we need some abstraction
    which allows us to define what we need to configure in each of these groups, and
    call them by name. That's exactly what roles do. Ansible roles allow us to configure
    groups of nodes at the same time, without repeating ourselves. Roles also provide
    a way to create modular code, which then can then be shared and reused.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以最有效的方式管理这样的基础设施，我们需要一些抽象化的方法，使我们能够定义每个组中需要配置的内容，并通过名称进行调用。这正是角色所做的。Ansible
    角色允许我们同时配置多个节点组，而不需要重复自己。角色还提供了一种创建模块化代码的方法，然后可以共享和重用。
- en: Naming roles
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名角色
- en: 'A common practice is to create roles that map to each application or component
    of your infrastructure that you would like to configure. For example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的做法是创建映射到你想要配置的基础设施的每个应用程序或组件的角色。例如：
- en: Nginx
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nginx
- en: MySQL
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL
- en: MongoDB
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB
- en: Tomcat
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tomcat
- en: The directory layout for roles
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色的目录布局
- en: Roles are nothing but directories laid out in a specific manner. Roles follow
    predefined directory layout conventions and expect each component to be in the
    path meant for it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 角色只不过是以特定方式布局的目录。角色遵循预定义的目录布局约定，并期望每个组件都在为其准备的路径中。
- en: 'The following is an example of a role, called Nginx:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个名为 Nginx 的角色示例：
- en: '![The directory layout for roles](img/B03800_02_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![角色的目录布局](img/B03800_02_01.jpg)'
- en: 'Let''s now look at the rules of the game and what each of the components in
    the preceding diagram is for:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看游戏规则以及前面图表中的每个组件的作用：
- en: Each role contains a directory which is named after itself, for example, `Nginx`,
    with `roles/` as its parent directory. Each named role directory contains one
    or more optional subdirectories. The most common subdirectories to be present
    are tasks, templates, and handlers. Each of these subdirectories typically contain
    the `main.yml` file, which is a default file.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个角色都包含一个以自己命名的目录，例如，`Nginx`，其父目录为`roles/`。每个命名角色目录包含一个或多个可选的子目录。最常见的子目录通常包含
    `tasks`、`templates` 和 `handlers`。每个子目录通常包含 `main.yml` 文件，这是一个默认文件。
- en: Tasks contain the core logic, for example, they will have code specifications
    to install packages, start services, manage files, and so on. If we consider a
    role to be a movie, a task would be the protagonist.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务包含核心逻辑，例如，它们将具有安装包、启动服务、管理文件等代码规范。如果我们将角色比作电影，那么任务将是主角。
- en: Tasks alone cannot do everything. Considering our analogy with movies, it's
    incomplete without the supporting cast. Protagonists have friends, cars, lovers,
    and antagonists to complete the story. Similarly, tasks consume data, call for
    static or dynamic files, trigger actions, and so on. That's where files, handlers,
    templates, defaults, and `vars` come in. Let's look at what these are for.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务本身无法完成所有工作。考虑我们与电影的类比，缺少支持角色是不完整的。主角有朋友、车辆、爱人和反派分子，来完成故事。同样，任务消耗数据，调用静态或动态文件，触发动作等。这就是文件、处理程序、模板、默认值和`vars`发挥作用的地方。让我们看看这些是什么。
- en: Vars and defaults provide data about your application/role, for example, which
    port your server should run on, the path for storing the application data, which
    user to run the service as, and so on. Default variables were introduced in version
    1.3 and these allow us to provide sane defaults. These can later be overridden
    from other places, for example, `vars`, `group_vars`, and `host_vars`. Variables
    are merged and precedence rules apply. This gives us a lot of flexibility to configure
    our servers selectively. For example, running the web server on port `80` on all
    hosts except for the ones in the staging environment, which should run it on port
    `8080`.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vars`和默认值提供了关于您的应用程序/角色的数据，例如，您的服务器应该运行在哪个端口，存储应用程序数据的路径，应该以哪个用户身份运行服务等等。默认变量是在1.3版本中引入的，这些可以为我们提供合理的默认值。这些稍后可以被其他地方覆盖，例如，`vars`、`group_vars`和`host_vars`。变量被合并，并且存在优先规则。这给了我们很大的灵活性来有选择性地配置我们的服务器。例如，在除了在暂存环境中应该在端口`8080`上运行之外的所有主机上运行web服务器，在端口`80`上。'
- en: Files and templates subdirectories provide options for managing files. Typically,
    the files subdirectory is used to copy over static files to destination hosts,
    for example, some application installers archive static text files, and so on.
    In addition to static files, frequently you may need to manage files that are
    are generated on the fly. For example, a configuration file that has parameters
    such as port, user, and memory, which can be provided dynamically using variables.
    Generating such files requires a special type of primitive, called templates.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件和模板子目录提供了管理文件的选项。通常，文件子目录用于将静态文件复制到目的主机，例如，一些应用程序安装程序将静态文本文件存档，等等。除了静态文件，你可能经常需要管理动态生成的文件。例如，具有参数（例如端口、用户和内存）的配置文件，可以使用变量动态提供。生成这些文件需要一种称为模板的特殊类型的原始。
- en: Tasks can trigger actions based on the change of a state or a condition. In
    a movie, the protagonist may chase the antagonist and take revenge based on the
    provocation or an event. An example event is kidnapping the protagonist's lady
    love. Similarly, you may need to perform an action on your hosts, for example,
    restarting a service based on what happened earlier, which could be a change in
    the state of a configuration file. This trigger-action relationship can be specified
    using a handler.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务可以根据状态或条件的更改触发动作。在电影中，主角可以追逐反派，基于挑衅或事件进行报复。一个例子是绑架主角的爱人这个事件。同样地，您可能需要根据之前发生的事情在您的主机上执行一个动作，例如，重新启动一个服务，这可能是由于配置文件状态的更改。可以使用处理程序指定此触发-动作关系。
- en: Continuing our analogy, many popular movies have sequels and sometimes even
    prequels. In such cases, one should watch it in a particular order, as the storyline
    of a sequel depends on something that happened in the previous movie. Similarly,
    a role can have a dependency on another role. A very common example is, before
    installing Tomcat, Java should be present on the system. These dependencies are
    defined in the meta subdirectory of a role.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的类比，许多热门电影有续集，有时甚至有前传。在这种情况下，应该按照特定的顺序观看，因为续集的故事情节取决于发生在以前的电影中的事情。同样地，一个角色可以依赖于另一个角色。一个非常常见的例子是，在安装Tomcat之前，系统上应该存在Java。这些依赖关系定义在一个角色的meta子目录中。
- en: Let's get hands-on with this by creating a role for the Nginx application. Let's
    take a problem statement, try to solve it, and learn about roles in the process.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过为Nginx应用程序创建一个角色来动手实践这个。让我们提出一个问题陈述，尝试解决它，并在过程中了解角色。
- en: Consider the following scenario. With the onset of the soccer world cup, we
    need to create a web server to serve up a page on sports news.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情景。随着足球世界杯的开始，我们需要创建一个Web服务器来提供有关体育新闻的页面。
- en: 'Being a follower of agile methodologies, we will do this in phases. In the
    first phase, we will just install a web server and serve up a home page. Let''s
    now break this down into the steps we need to take to achieve this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为敏捷方法的追随者，我们将分阶段进行。在第一阶段，我们将只安装一个 Web 服务器并提供一个主页。现在让我们将此分解为实现此目标所需的步骤：
- en: Install a web server. In this case, we will use 'Nginx' as it is a lightweight
    web server.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装一个 Web 服务器。在这种情况下，我们将使用'Nginx'，因为它是一个轻量级的 Web 服务器。
- en: Manage configuration for the Nginx web server.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理 Nginx Web 服务器的配置。
- en: Start the web server after installing it.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后启动 Web 服务器。
- en: Copy over an HTML file, which will be served as a home page.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制一个 HTML 文件，它将作为主页提供。
- en: 'Now that we have identified what steps to take, we also need to map them to
    the respective module types we will use to achieve each of these:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了要采取的步骤，我们还需要将它们映射到我们将用于实现每个步骤的相应模块类型：
- en: Installing Nginx = Package module (apt)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Nginx = 包模块（apt）
- en: Configuring Nginx = File module (file)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Nginx = 文件模块（file）
- en: Starting Nginx = Systems module (service)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动 Nginx = 系统模块（service）
- en: Serve Webpage = Files module (file)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供网页 = 文件模块（file）
- en: Before we start writing code, we will start creating a layout to organize our
    files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我们将先创建一个布局来组织我们的文件。
- en: Creating a site-wide playbook, nesting, and using include statements
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建站点范围的播放，嵌套和使用 include 语句
- en: 'As a best practice, we will create a top-level file, which will contain the
    blueprint of our complete infrastructure. Technically, we can include everything
    that we need to configure inside just one file. However, that would have two problems:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，我们将创建一个顶级文件，其中将包含我们完整基础设施的蓝图。从技术上讲，我们可以将所有需要配置的内容都包含在一个文件中。但是，这会有两个问题：
- en: It would quickly get out of control as we start adding tasks, variables, and
    handlers to this single file. It would be a nightmare to maintain such code.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着我们开始向这个单一文件添加任务、变量和处理程序，它会很快失控。维护这样的代码将是一场噩梦。
- en: It would also be difficult to reuse and share such code. One of the advantages
    of using a tool such as Ansible is its ability to separate data from code. Data
    is organization-specific, and code is generic. This generic code can then be shared
    with others. However, if you write everything in a single file, it would be impossible
    to do so.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这也将难以重用和共享这样的代码。使用 Ansible 等工具的优点之一是它能够将数据与代码分离。数据是组织特定的，而代码是通用的。然后，可以与其他人共享此通用代码。但是，如果您将所有内容都写在一个文件中，这将是不可能的。
- en: 'To avoid this problem, we will start organizing our code in a modular fashion,
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，我们将以模块化的方式开始组织我们的代码，如下所示：
- en: We will create roles for each of the applications that we need to configure.
    In this case, it is Nginx
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将为需要配置的每个应用程序创建角色。在这种情况下，它是 Nginx
- en: Our web server may need to install more than one application in addition to
    Nginx, for example, PHP and OpenSSL. To encapsulate all of these, we will create
    a playbook named `www.yml`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 Web 服务器可能需要安装除了 Nginx 之外的多个应用程序，例如 PHP 和 OpenSSL。为了封装所有这些内容，我们将创建一个名为`www.yml`的播放。
- en: The preceding playbook that we created will map hosts with the Nginx role. We
    may add more roles to it later.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建的前置播放将主机与 Nginx 角色进行映射。我们以后可能会添加更多角色。
- en: We will add this playbook to the top-level playbook, that is, `site.yml`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将把这个播放添加到顶层播放，即`site.yml`
- en: 'The following diagram depicts the preceding steps in a very simple manner:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表简要描述了前面的步骤：
- en: '![Creating a site-wide playbook, nesting, and using include statements](img/B03800_02_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![创建站点范围的播放，嵌套和使用 include 语句](img/B03800_02_02.jpg)'
- en: 'Here is our `site.yml` file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`site.yml`文件：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding `include` directive assists us with modularizing the code. Instead
    of writing it all in one file, we split the logic and import what is required.
    In this case, we will include another playbook, which is called a **nested playbook**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `include` 指令帮助我们模块化代码。我们不是将所有内容都写在一个文件中，而是拆分逻辑并导入所需的内容。在这种情况下，我们将包含另一个播放，称为**嵌套播放**。
- en: 'The following are some guidelines on what can be included and how:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于可以包含和如何包含的指南：
- en: The `include` directive can be used to include tasks, handlers, and even other
    playbooks
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`指令可用于包含任务、处理程序，甚至其他播放'
- en: If you include a playbook inside another like we did in the `site.yml` file,
    you cannot substitute the variables
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在另一个文件中包含一个播放，就像我们在`site.yml`文件中所做的那样，您不能替换变量
- en: The `include` keyword can be used in combination with regular task/handler specifications
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include` 关键字可与常规任务/处理程序规格结合使用。'
- en: It's possible to pass parameters with include statements. This is called as
    **parameterized** **include**
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在include语句中传递参数。这被称为**参数化include**。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Roles and auto-includes**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**Roles和自动包括**'
- en: Roles have implicit rules to auto include files. So long as you follow the directory
    layout conventions, you are assured that all your tasks, handlers, and the rest
    of the files are included automatically. Hence, it's important to create the subdirectories
    with the exact names as specified by Ansible.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Roles具有隐式规则来自动包括文件。只要遵循目录布局约定，您可以确保所有任务、处理程序以及其他文件都会自动包含。因此，创建与Ansible指定的完全相同名称的子目录非常重要。
- en: Creating the www playbook
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建www playbook
- en: 'We created a site-wide playbook and used an include statement to call another
    playbook by the name `www.yml`. We will now create this file with one play, which
    maps our web server hosts to the Nginx role:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个网站范围的playbook，并使用include语句来调用另一个名为`www.yml`的playbook。我们现在将创建这个文件，其中包含一个play，将我们的web服务器主机映射到Nginx
    role：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The above code works as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以上代码的工作方式如下：
- en: Run this code on any host that maps to the `[www]` group specified in the hosts
    file.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何映射到hosts文件中指定的`[www]`组的主机上运行此代码。
- en: For each directory inside the `roles/nginx/*` file, include `roles/nginx/*/main.yml`
    to the play. This includes `tasks`, `handlers`, `vars`, `meta`, `default,` and
    so on. This is where the auto include rules apply.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`roles/nginx/*`文件内的每个目录，将`roles/nginx/*/main.yml`包含到play中。这包括`tasks`、`handlers`、`vars`、`meta`、`default`等等。这就是自动包括规则适用的地方。
- en: The default and custom role paths
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认和自定义role路径
- en: 'By default, Ansible looks inside the `roles/` subdirectory of the project that
    we create playbooks for. Being top-class devops engineers, we will follow the
    best practice to have a centralized, version-controlled repository to store all
    your roles. We may also end up reusing the roles created by community. Once we
    do this, we can reuse these roles across multiple projects. In such cases, we
    will check out the code at one or more locations, for example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible会查找我们为其创建playbooks的项目的子目录`roles/`。作为一流的devops工程师，我们将遵循最佳实践，建立一个集中的、版本受控的仓库，用于存储您的所有role。我们可能最终会重用
    community 创建的roles。这样做后，我们可以在多个项目中重用这些roles。在这种情况下，我们将在一个或多个位置检出代码，例如：
- en: '`/deploy/ansible/roles`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/deploy/ansible/roles`'
- en: '`/deploy/ansible/community/roles`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/deploy/ansible/community/roles`'
- en: 'For nondefault paths, we will need to add the `roles_path` parameter to `ansible.cfg`
    as shown in the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非默认路径，我们需要在 `ansible.cfg` 中添加`roles_path`参数，如下命令所示：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Parameterizing the roles
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化roles
- en: 'At times, we may need to override default parameters specified inside vars
    or the default directory of a role, for example, running web servers on port 8080
    instead of 80\. In such cases, we can also pass parameters to roles in the preceding
    playbook, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要在role的vars或default目录中覆盖默认参数，例如，在端口8080上运行web服务器而不是80。在这种情况下，我们也可以在前面的playbook中传递参数给roles，如下所示：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating a base role
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本role
- en: In the previous chapter, we created a simple playbook with all plays written
    inside the same file. After discovering new and exciting information about roles,
    we will start refactoring our code and making it modular.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个简单的playbook，所有play都写在同一个文件中。在发现关于roles的新信息后，我们将开始重构我们的代码，使其具有模块化。
- en: Refactoring our code – creating a base role
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构我们的代码 — 创建一个基本role
- en: 'We have written two plays in the `simple_playbook.yml` file. We intended to
    run the first play on all hosts. This play has tasks to create users, install
    essential packages, and so on:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`simple_playbook.yml`文件中编写了两个play。我们打算在所有主机上运行第一个play。该play有任务来创建用户，安装必要的软件包，等等：
- en: '![Refactoring our code – creating a base role](img/B03800_02_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![重构我们的代码 — 创建一个基本role](img/B03800_02_03.jpg)'
- en: 'It''s a good practice to combine all such essential tasks and create a base
    role. You can name it as base, common, essential, or whatever you please, but
    the concept remains the same. We will now move this code to the base role:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这类基本任务组合在一起并创建一个基本role是一种良好的实践。您可以将其命名为base、common、essential或任何您喜欢的名称，但概念是相同的。我们现在将此代码移至base
    role中：
- en: 'Create the directory layout for the base role. Since we are only going to specify
    tasks, we just need one subdirectory inside the base:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为基本role创建目录布局。由于我们只会指定任务，所以我们只需要在base内创建一个子目录：
- en: '[PRE4]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Create the `main.yml` file inside `roles/base/tasks` to specify tasks for the
    base role.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `roles/base/tasks` 目录下创建 `main.yml` 文件，以指定基本角色的任务。
- en: 'Edit the `main.yml` file and add the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `main.yml` 文件，并添加以下代码：
- en: '[PRE5]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating an Nginx role
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Nginx 角色
- en: 'We will now create a separate role for Nginx and move the previous code that
    we wrote in the `simple_playbook.yml` file to it, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为 Nginx 创建一个单独的角色，并将之前在 `simple_playbook.yml` 文件中编写的代码移动到其中，如下所示：
- en: 'Create the directory layout for the Nginx role:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 Nginx 角色创建目录布局：
- en: '[PRE6]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the `install.yml` file inside `roles/base`. Move the Nginx-related tasks
    to it. It should look like this:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `roles/base` 目录下创建 `install.yml` 文件。将与 Nginx 相关的任务移动到其中。它应该如下所示：
- en: '[PRE7]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will also create the `service.yml` file to manage the state of the Nginx
    daemon:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将创建 `service.yml` 文件来管理 Nginx 守护程序的状态：
- en: '[PRE8]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We looked at the `include` directive earlier. We will use it to include both
    the `install.yml` and `service.yml` files in the `main.yml` file, as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前看过 `include` 指令。我们将使用它来在 `main.yml` 文件中包含 `install.yml` 和 `service.yml`
    文件，如下所示：
- en: '[PRE9]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Best Practice**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳实践**'
- en: Why are we creating multiple files to hold the code that installs packages and
    manages services, separately? That's because well-factored roles allow you to
    selectively enable specific features. For example, at times, you may want to deploy
    services in multiple phases. In the first phase, you may just want to install
    and configure applications, and start services only in the second phase of your
    deployment. In such cases, having modular tasks can help. You can always include
    them all in the `main.yml` file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要创建多个文件来分别保存安装包和管理服务的代码呢？因为精心设计的角色允许您选择性地启用特定的功能。例如，有时您可能想要在多个阶段部署服务。在第一阶段，您可能只想安装和配置应用程序，并在部署的第二阶段才启动服务。在这种情况下，具有模块化任务可以帮助。您始终可以将它们全部包含在
    `main.yml` 文件中。
- en: Adding role dependencies
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加角色依赖关系
- en: 'We have some essential tasks specified in the base role. We may keep on adding
    more tasks which are a prerequisite for the applications that follow. In such
    cases, we would like our Nginx role to be dependent on the base role. We will
    now specify this dependency inside the meta subdirectory. Let''s take a look at
    the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本角色中指定了一些重要的任务。我们可以不断添加更多任务，这些任务是后续应用程序的先决条件。在这种情况下，我们希望我们的 Nginx 角色依赖于基本角色。现在让我们在
    meta 子目录中指定这个依赖关系。让我们看看以下步骤：
- en: Create the `main.yml` file inside the `roles/nginx/meta/main.yml` path.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `roles/nginx/meta/main.yml` 路径下创建 `main.yml` 文件。
- en: 'Add the following code to the `main.yml` file inside the `meta` directory:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `meta` 目录下的 `main.yml` 文件中添加以下代码：
- en: '[PRE10]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding specification will ensure that the base role is always applied
    before any task in Nginx starts running.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述规范将确保在任何 Nginx 任务开始运行之前始终应用基本角色。
- en: Managing files for Nginx
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理 Nginx 的文件
- en: As per our solution to the scenario, we already have Ansible tasks to install
    Nginx and to start the service. We still don't have a web page to serve yet, and
    we did not think about the Nginx site configurations. We don't expect Nginx to
    magically know about how and where to serve the web page from, do we?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对情景的解决方案，我们已经有了安装 Nginx 和启动服务的 Ansible 任务。但我们还没有要提供的网页内容，也没有考虑过 Nginx 站点配置。我们难道指望
    Nginx 神奇地知道如何以及从哪里提供网页吗？
- en: 'We need to perform the following steps to serve the HTML page:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行以下步骤来提供 HTML 页面服务：
- en: Create a site configuration that lets Nginx know which port to listen to for
    requests, and what to do when a request comes.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个站点配置，让 Nginx 知道监听请求的端口，并在请求到来时执行什么操作。
- en: Create some HTML content, which will be served when an HTTP request comes in.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些 HTML 内容，当收到 HTTP 请求时将提供服务。
- en: Add code to `tasks/main.yml` to copy over these files.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `tasks/main.yml` 中添加代码以复制这些文件。
- en: 'You might have noticed, both steps 1 and 2 require that you create and manage
    some files on the host, which will run the Nginx web server. You also learned
    about the file and the subdirectory of a role. You guessed it right. We will use
    this subdirectory to host our files and have them copied over to all the Nginx
    hosts with Ansible. So, let''s create these files now using the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，步骤 1 和步骤 2 都要求你在托管 Nginx Web 服务器的主机上创建和管理一些文件。你还了解了角色的文件和子目录。你猜对了。我们将使用这个子目录来托管我们的文件，并将它们复制到所有使用
    Ansible 的 Nginx 主机上。所以，现在让我们使用以下命令创建这些文件：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a `default.configuration` file to manage the default Nginx site configurations.
    This file should contain parameters such as port, server name, and web root configurations,
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`default.configuration`文件来管理默认的 Nginx 站点配置。这个文件应该包含端口、服务器名称和 Web 根配置等参数，如下所示：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will also create an `index.html` file, which we will push to all web servers:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个`index.html`文件，将其推送到所有的 Web 服务器上：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we have created these files, we will add tasks to copy these over
    and put them in `roles/nginx/tasks/configure.yml,` as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了这些文件，我们将添加任务来将它们复制过去，并放在`roles/nginx/tasks/configure.yml`中，如下所示：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will also update the `main.yaml` file inside tasks to include the newly
    created file, and add it before the `service.yml` file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在任务中的`main.yaml`文件中更新，包括新创建的文件，并在`service.yml`文件之前添加：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Automating events and actions with handlers
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用处理程序自动化事件和操作
- en: 'Let''s assume that we are managing Nginx manually, and that we have to change
    the port that Nginx listens to from the default site to `8080`. What would we
    do to make this happen? Sure, we would edit the `default.conf` file and change
    the port from 80 to 8080\. However, would that be enough? Would that make Nginx
    listen to port 8080 immediately after editing this file? The answer is no. There
    is one more step involved. Let''s take a look at the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在手动管理 Nginx，并且我们需要将 Nginx 监听的端口从默认站点更改为`8080`。我们需要做什么来实现这一点？当然，我们会编辑`default.conf`文件，将端口从`80`更改为`8080`。但是，这样就足够了吗？这样一编辑文件，Nginx
    会立即监听端口`8080`吗？答案是否定的。还需要一步骤。让我们来看一下下面的截图：
- en: '![Automating events and actions with handlers](img/B03800_02_04.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![使用处理程序自动化事件和操作](img/B03800_02_04.jpg)'
- en: When we change a configuration file, we will typically also restart/reload the
    service so that it reads our modifications and applies those.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更改配置文件时，通常也会重新启动/重新加载服务，以便读取我们的修改并应用这些修改。
- en: So far, so good. Now let's come back to our Ansible code. We are going to run
    this code in an automated fashion on a large number of servers, possibly hundreds.
    Considering this, it's not feasible for us to log in to each system to restart
    services after every change. This defeats the purpose of automating the process.
    Now, how do we ask Ansible to take action when an event occurs? That's where handlers
    can help.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都好。现在让我们回到我们的 Ansible 代码。我们将以自动化的方式在大量服务器上运行此代码，可能是数百台服务器。考虑到这一点，我们不可能登录到每个系统上，在每次更改后重新启动服务。这会违反自动化过程的目的。那么，当事件发生时，我们如何要求
    Ansible采取行动呢？这就是处理程序能够帮助的地方。
- en: You learned that Ansible modules are idempotent. They will enforce a change
    in state only if there is a configuration drift. When managing with Ansible, we
    will commit the preceding port change in the `default.conf` file inside `roles/nginx/files`.
    If we launch an Ansible run after making this change then, while executing, it
    will compare the file inside our role with the one on the system, detect the configuration
    drift, and copy it over to the changed file. With Ansible, this is where we will
    add a notification that will trigger a handler to run. In this case, we will call
    a handler to restart the Nginx service.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到 Ansible 模块是幂等的。只有在存在配置漂移时，它们才会强制改变状态。在使用 Ansible 进行管理时，我们将在`roles/nginx/files`下提交之前的端口更改`default.conf`文件。如果在进行此更改后启动
    Ansible 运行，它将在执行过程中比较我们角色中的文件与系统上的文件，检测到配置漂移，并将其复制到更改的文件中。而使用 Ansible，我们将添加一个通知，它将触发一个处理程序运行。在这种情况下，我们将调用处理程序重新启动
    Nginx 服务。
- en: 'Let''s now add this handler to `roles/nginx/handlers/main.yml`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将这个处理程序添加到`roles/nginx/handlers/main.yml`中：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Handlers are similar to regular tasks. They specify a module's name, instance,
    and state. Why do we not add them with regular tasks then? Well, we only need
    to execute handlers,when an event occurs, not every time we run, ansible. And
    that's the exact reason why we create a separate section for it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序与普通任务类似。它们指定了一个模块的名称、实例和状态。为什么我们不将它们与普通任务一起添加呢？好吧，我们只需要在发生事件时执行处理程序，而不是每次运行
    Ansible 时都执行。这就是为什么我们为它创建一个单独的部分的确切原因。
- en: 'Now that we have written the handler, we also need to add a trigger for it.
    We will do this by adding the `notify` directive to `roles/tasks/nginx/configure.yml`,
    as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经写了处理程序，我们还需要为它添加一个触发器。我们将通过在 `roles/tasks/nginx/configure.yml` 中添加`notify`指令来实现，如下所示：
- en: '![Automating events and actions with handlers](img/B03800_02_05.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![使用处理程序自动化事件和操作](img/B03800_02_05.jpg)'
- en: Tip
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Even when multiple tasks notify the handler, it will be called only once, toward
    the end. This will avoid multiple restarts of the same service unnecessarily.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 即使多个任务通知处理程序，处理程序也只会在最后调用一次。这将避免不必要地多次重新启动同一服务。
- en: 'By now, our Nginx role layout looks more complete and has files, handlers,
    tasks, and directories with individual tasks to manage each phase of the Nginx
    setup. The role layout is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的 Nginx 角色布局看起来更完整，并且具有文件、处理程序、任务和具有管理 Nginx 设置每个阶段的单独任务的目录。角色布局如下：
- en: '![Automating events and actions with handlers](img/B03800_02_06.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![使用处理程序自动化事件和操作](img/B03800_02_06.jpg)'
- en: Adding pre-tasks and post-tasks to playbooks
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 playbook 中添加预先任务和后置任务
- en: 'We would like to print status messages before and after we begin applying Nginx.
    Let''s add it to our `www.yml` playbook with the `pre_tasks` and `post_tasks`
    parameters:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在开始应用 Nginx 之前和之后打印状态消息。让我们使用`www.yml` playbook，并添加`pre_tasks`和`post_tasks`参数：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding example, we only printed some messages using the `echo` command.
    However, we can create tasks using any of the modules available with Ansible,
    which can run before, or after, applying roles.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们仅使用`echo`命令打印了一些消息。但是，我们可以使用 Ansible 提供的任何模块创建任务，这些任务可以在应用角色之前或之后运行。
- en: Running playbooks with roles
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用角色运行 playbook
- en: 'Let''s now apply the refactored code to our hosts. We are going to launch only
    the site-wide playbook, that is, the `site.yml` file and then rely on the include
    statements and roles to do the magic:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将重构后的代码应用到我们的主机上。我们将仅启动站点范围的 playbook，即`site.yml`文件，然后依赖于包含语句和角色来完成工作：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下的屏幕截图：
- en: '![Running playbooks with roles](img/B03800_02_07.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![使用角色运行 Playbook](img/B03800_02_07.jpg)'
- en: 'In addition to the output we saw last time, there are some new messages this
    time. Let''s analyze those:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上次看到的输出之外，这次还有一些新的消息。让我们来分析一下：
- en: Before and after, roles are applied, pre-tasks and post-tasks get triggered;
    this prints messages using the shell module.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用角色之前和之后，将触发预先任务和后置任务；这将使用 shell 模块打印消息。
- en: We now have the code to copy to the `config` and .`html` file for our Nginx
    web server.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们有了复制到我们的 Nginx Web 服务器的`config`和`.html`文件的代码。
- en: We also see that the handler triggers an Nginx service restart. This is due
    to the change in the state for the `configuration` file, which triggers the handler.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还看到处理程序触发了 Nginx 服务的重新启动。这是由于`configuration`文件状态的改变，触发了处理程序。
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Did you notice that tasks in the base role also get triggered, even when we
    have not mentioned the base role in the `www` playbook? This is where meta information
    is useful. Remember we had specified a dependency on the base role inside `meta/main.yml`
    for Nginx? That's what did the trick.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了吗？即使我们没有在`www` playbook 中提及基础角色，基础角色中的任务也会被触发。这就是元信息的作用。记得我们在 Nginx 的`meta/main.yml`中为基础角色指定了一个依赖关系吗？那就是起作用的地方。
- en: 'Dependencies:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Review questions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: 'Do you think you''ve understood the chapter well enough? Try answering the
    following questions to test your understanding:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为你是否足够理解了本章？试着回答以下问题来测试你的理解：
- en: Roles contain ___ and ___ subdirectories to specify variables/parameters.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 角色包含 ___ 和 ___ 子目录以指定变量/参数。
- en: How do you specify a dependency on another role?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何指定对另一个角色的依赖关系？
- en: When we add roles to a play, why is it not required that we use the `include`
    directives? How do the tasks, handlers, and so on, get added to the play automatically?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们向 play 中添加角色时，为什么不需要使用`include`指令？任务、处理程序等是如何自动添加到 play 中的？
- en: Why do we have a separate section for handlers if they resemble regular tasks?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果处理程序与常规任务相似，为什么我们需要一个单独的部分来处理处理程序？
- en: Which module can be used to copy over static files to destination hosts?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个模块可以用于将静态文件复制到目标主机？
- en: How do you specify the tasks to be run before applying a role in a playbook?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 playbook 中指定在应用角色之前运行的任务？
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use roles to provide abstraction and to
    help modularizing code for reuse. That's exactly what you see community doing.
    Creating roles, and sharing them with you. You also learned about `include` directives,
    directory layout for roles, and adding role dependencies. We then went on to refactor
    our code and created a base role, the Nginx role. We also looked at how to manage
    events and take actions using handlers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何使用角色提供抽象并帮助模块化代码以供重用。这正是社区正在做的事情。创建角色，并与你分享。你还学习了关于`include`指令、角色的目录布局以及添加角色依赖项。然后我们进行了代码重构，并创建了一个基本角色，即
    Nginx 角色。我们还了解了如何管理事件并使用处理程序采取行动。
- en: In the next chapter, we will extend the concepts of roles and start adding dynamic
    data with variables and templates.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展角色的概念，并开始使用变量和模板添加动态数据。
