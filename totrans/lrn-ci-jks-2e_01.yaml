- en: Concepts of Continuous Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成的概念
- en: 'We will begin this chapter with an overview of the two primary software development
    methodologies of the era: Waterfall, and agile. An understanding of their concepts
    and implications will help us answer how **Continuous Integration** (**CI**) came
    into existence.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从介绍当今两种主要软件开发方法论开始：瀑布模型和敏捷开发。理解它们的概念和影响将帮助我们回答**持续集成**（**CI**）是如何产生的。
- en: 'Next, we will try to understand the concept behind CI and the elements that
    make it. Reading through the topics, you will see how CI helps projects go agile.
    After completing this chapter, you should be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试理解CI背后的概念及构成要素。通过阅读这些内容，您将了解到CI如何帮助项目实现敏捷。完成本章后，您应该能够：
- en: Describe how CI came into existence.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述CI是如何产生的。
- en: Define what CI is.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义什么是CI。
- en: Describe the elements of CI.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述CI的要素。
- en: Software Development Life Cycle
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件开发生命周期
- en: 'For those of you who are not familiar with the term: Software Development Life
    Cycle, let us try to understand it.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些对术语“软件开发生命周期”不太熟悉的人，让我们尝试理解一下。
- en: The **Software Development Life Cycle**, also sometimes referred to as **SDLC**
    for short, is the process of planning, developing, testing, and deploying software.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**软件开发生命周期**，有时简称为**SDLC**，是规划、开发、测试和部署软件的过程。'
- en: 'Teams follow a sequence of phases, and each phase uses the outcome of its previous
    phase, as shown in the following diagram:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 团队按照一系列阶段进行工作，每个阶段都利用了其前一个阶段的结果，如下图所示：
- en: '![](img/357ee6b7-7641-4d0a-93d7-88d28c7a61e5.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/357ee6b7-7641-4d0a-93d7-88d28c7a61e5.png)'
- en: Software Development Life Cycle
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发生命周期
- en: Let's take a look at the SDLC phases in detail.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解SDLC的各个阶段。
- en: Requirement analysis
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求分析
- en: This is the first stage of the cycle. Here, the business team (mostly comprised
    of business analysts) perform a requirement analysis of their project's business
    needs. The requirements can be internal to the organization, or external, from
    a customer. This study involves finding the nature and scope of the requirements.
    With the gathered information, there is a proposal to either improve the system
    or create a new one. The project cost gets decided, and benefits are laid out.
    Then the project goals are defined.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是循环的第一个阶段。在这里，业务团队（主要由业务分析师组成）对其项目的业务需求进行需求分析。需求可能是组织内部的，也可能是来自客户的外部需求。这项研究涉及发现需求的性质和范围。根据收集到的信息，提出了改进系统或创建新系统的建议。项目成本得到确定，并列出了利益。然后确定项目目标。
- en: Design
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计
- en: The second phase is the design phase. Here, the system architects and the system
    designers formulate the desired features of the software solution and create a
    project plan. This plan may include process diagrams, overall interface, and layout
    design, along with a vast set of documentation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段是设计阶段。在这里，系统架构师和系统设计师制定软件解决方案的期望功能，并创建项目计划。该计划可能包括流程图、整体接口和布局设计，以及大量的文档。
- en: Implementation
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: The third phase is the implementation phase. Here, the project manager creates
    and assigns work to the developers. The developers develop the code depending
    on the tasks and goals defined in the design phase. This phase may last from a
    few months to a year, depending on the project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第三阶段是实现阶段。在这里，项目经理创建并分配工作给开发人员。开发人员根据设计阶段定义的任务和目标开发代码。这个阶段可能会持续几个月到一年，这取决于项目的规模。
- en: Testing
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: The fourth phase is the testing phase. When all the decided features are developed,
    the testing team takes over. For the next few months, all features are thoroughly
    tested. Every module of the software is collected and tested. Defects are raised
    if any bugs or errors occur while testing. In the event of a failure, the development
    team quickly acts to resolve the failures. The thoroughly tested code is then
    deployed into the production environment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第四阶段是测试阶段。当所有确定的功能都开发完成后，测试团队接管。在接下来的几个月里，所有功能都会经过彻底的测试。软件的每个模块都会被收集和测试。如果在测试过程中出现任何错误或bug，就会提出缺陷。在出现故障时，开发团队会迅速采取措施解决故障。经过彻底测试的代码随后会被部署到生产环境中。
- en: Evolution
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演进
- en: The last phase is the evolution phase or the maintenance phase. Feedback from
    the users/customers is analyzed, and the whole cycle of developing, testing, and
    releasing the new features and fixes in the form of patches or upgrades repeats.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后阶段是演进阶段或维护阶段。用户/客户的反馈被分析，整个开发、测试和发布新功能和修复的循环以补丁或升级的形式重复。
- en: Waterfall model of software development
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件开发的瀑布模型
- en: One of the most famous and widely used software development processes is the
    Waterfall model. The Waterfall model is a sequential software development process.
    It was derived from the manufacturing industry. One can see a highly structured
    flow of processes that run in one direction. At the time of its creation, there
    were no other software development methodologies, and the only thing the developers
    could have imagined was the production line process that was simple to adapt for
    software development.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名且广泛使用的软件开发过程之一是瀑布模型。瀑布模型是一个顺序软件开发过程，源自制造业。人们可以看到高度结构化的流程在一个方向上运行。在其创立时期，没有其他软件开发方法论，开发人员唯一能够想象的就是简单适用于软件开发的生产线流程。
- en: 'The following diagram illustrates the Waterfall model of software development:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了软件开发的瀑布模型：
- en: '![](img/3e822d7c-11be-4aba-a2b8-394915bed092.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e822d7c-11be-4aba-a2b8-394915bed092.png)'
- en: Waterfall model
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 瀑布模型
- en: The Waterfall approach is simple to understand, as the steps involved are similar
    to that of the SDLC.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 瀑布方法简单易懂，因为所涉及的步骤类似于SDLC。
- en: First, there is a requirement analysis phase, which is followed by the designing
    phase. There is a considerable time spent on the analysis and the designing part.
    And once it's over, there are no further additions or deletions. In short, once
    the development begins, there is no modification allowed in the design.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是需求分析阶段，然后是设计阶段。在分析和设计部分花费了相当多的时间。一旦完成，就不再进行添加或删除。简而言之，在开发开始后，设计中不允许修改。
- en: Then comes the implementation phase, where the actual development takes place.
    The development cycle can range from three months to six months. During this time,
    the testing team is usually free. When the development cycle is completed, a whole
    week's time is planned for performing the integration of the source code. During
    this time, many integration issues pop up and are fixed immediately. This stage
    is followed by the testing phase.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是实施阶段，实际的开发将在此阶段进行。开发周期可以长达三个月至六个月。这段时间，测试团队通常是空闲的。开发周期结束后，计划整合源代码需要一整周时间。在此期间，会出现许多集成问题，并立即进行修复。这个阶段后是测试阶段。
- en: When the testing starts, it goes on for another three months or more, depending
    on the software solution. After the testing completes successfully, the source
    code is then deployed in the production environment. For this, a day or so is
    again planned to carry out the deployment in production. There is a possibility
    that some deployment issues may pop up. When the software solution goes live,
    teams get feedback and may also anticipate issues.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试开始时，会持续三个月甚至更长时间，取决于软件解决方案。测试成功后，源代码将部署在生产环境中。为此，会再次计划一天左右来进行生产部署。可能会出现一些部署问题。软件解决方案上线后，团队会收到反馈，也可能预料到问题。
- en: The last phase is the maintenance phase. Feedback from the users/customers is
    analyzed, and the whole cycle of developing, testing, and releasing new features
    and fixes in the form of patches or upgrades repeats.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后阶段是维护阶段。用户/客户的反馈被分析，整个开发、测试和发布新功能和修复的循环以补丁或升级的形式重复。
- en: There is no doubt that the Waterfall model worked remarkably for decades. However,
    flaws did exist, but they were simply ignored for a long time. Since, way back
    then software projects had ample time and resources to get the job done.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，瀑布模型在数十年间运行良好。然而，存在缺陷，但长时间以来被忽视。因为在那个时代，软件项目有足够的时间和资源来完成工作。
- en: However, looking at the way software technologies have changed over the past
    few years, we can easily say that the Waterfall model won't suit the requirements
    of the current world.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，看着过去几年软件技术的变化，我们可以说瀑布模型无法满足当前世界的需求。
- en: Disadvantages of the Waterfall model
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 瀑布模型的缺点
- en: 'The following are some of the disadvantages of the Waterfall model:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是瀑布模型的一些缺点：
- en: Working software is produced only at the end of the SDLC, which lasts for a
    year or so in most cases.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可工作的软件仅在大多数情况下持续一年左右的SDLC结束时产生。
- en: There is a huge amount of uncertainty.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在大量不确定性。
- en: It is not suitable for projects where the demand for new features is too frequent.
    For example, e-commerce projects.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不适用于对新功能需求过于频繁的项目。例如，电子商务项目。
- en: Integration is performed only after the entire development phase is complete.
    As a result, integration issues are found at a much later stage and in large quantities.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在整个开发阶段完成后执行集成。因此，集成问题会在更晚的阶段和大量发现。
- en: There is no backward traceability.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不存在向后追溯。
- en: It's difficult to measure progress within stages.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在各个阶段内很难衡量进度。
- en: Advantages of the Waterfall model
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 瀑布模型的优点
- en: 'By looking at the disadvantages of the Waterfall model, we can say that it''s
    mostly suitable for projects where:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看瀑布模型的缺点，我们可以说它主要适用于以下项目：
- en: The requirements are well documented and fixed.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求已经很好地记录并且是固定的。
- en: There is enough funding available to maintain a management team, a testing team,
    a development team, a build and release team, a deployment team, and so on.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有足够的资金可供维护管理团队、测试团队、开发团队、构建和发布团队、部署团队等。
- en: The technology is fixed, and not dynamic.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术是固定的，而不是动态的。
- en: There are no ambiguous requirements. And most importantly, they don't pop up
    during any other phase apart from the requirement analysis phase.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有模棱两可的要求。最重要的是，它们不会在除了需求分析阶段之外的任何其他阶段中出现。
- en: Agile to the rescue
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏捷来拯救
- en: The name **Agile** rightly suggests *quick and easy*. Agile is a collection
    of methods where software is developed through collaboration among self-organized
    teams. The principles behind agile are incremental, quick, flexible software development,
    and it promotes adaptive planning.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 名称**敏捷**恰如其分地暗示了*快速且简单*。敏捷是一种通过自组织团队之间的协作开发软件的方法集。敏捷背后的原则是增量、快速、灵活的软件开发，并促进自适应规划。
- en: The Agile software development process is an alternative to the traditional
    software development processes discussed earlier.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷软件开发过程是传统软件开发过程的替代方案。
- en: The twelve agile principles
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏捷十二原则
- en: 'The following are the twelve principles of the agile model:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是敏捷模型的十二原则：
- en: Customer satisfaction through early and continuous delivery of useful software.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过尽早和持续地交付有用的软件来实现客户满意度。
- en: Welcome changing requirements, even late in development.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欢迎在开发的后期接受变更的需求。
- en: Working software is frequently delivered (in weeks, rather than months).
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经常交付可工作的软件（以周为单位，而不是月）。
- en: Close daily cooperation between businesses, people, and developers.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务、人员和开发者之间的密切日常合作。
- en: Projects are built around motivated individuals, who should be trusted.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目围绕着应该受到信任的积极主动的个人构建。
- en: Face-to-face conversation is the best form of communication (co-location).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面对面的交流是最好的沟通方式（共同位置）。
- en: Working software is the principal measure of progress.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可工作的软件是进度的主要衡量标准。
- en: Sustainable development—able to maintain a constant pace.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可持续发展——能够保持稳定的速度。
- en: Continuous attention to technical excellence and good design.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续关注技术卓越和良好的设计。
- en: Simplicity—the art of maximizing the amount of work not done—is essential.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单——最大化未完成工作量的艺术是必不可少的。
- en: Self-organizing teams.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自组织团队。
- en: Regular adaptation to changing circumstances.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期适应变化的环境。
- en: To know more about the Agile principles visit the link: [http://www.agilemanifesto.org](http://www.agilemanifesto.org).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于敏捷原则的内容，请访问链接：[http://www.agilemanifesto.org](http://www.agilemanifesto.org)。
- en: The twelve principles of Agile software development indicate the expectations
    of the current software industry and its advantages over the Waterfall model.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷软件开发的十二原则表明了当前软件行业的期望以及其在瀑布模型上的优势。
- en: How does the Agile software development process work?
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏捷软件开发过程是如何工作的？
- en: In the Agile software development process, the whole software application is
    split into multiple features or modules. These features are delivered in iterations.
    Each iteration lasts for three weeks, and involves cross-functional teams that
    work simultaneously in various areas, such as planning, requirement analysis,
    designing, coding, unit testing, and acceptance testing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷软件开发过程中，整个软件应用被分割成多个特性或模块。这些特性以迭代方式交付。每个迭代持续三周，涉及到跨职能团队同时在各个领域工作，如规划、需求分析、设计、编码、单元测试和验收测试。
- en: 'As a result, no person sits idle at any given point in time. This is quite
    different from the Waterfall model wherein while the development team is busy
    developing the software, the testing team, the production team, and everyone else
    is idle or underutilized. The following diagram illustrates the Agile model of
    software development:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在任何给定时间点，没有人处于空闲状态。这与瀑布模型大不相同，在瀑布模型中，尽管开发团队正在忙于开发软件，但测试团队、生产团队和其他所有人都是空闲或利用率不高的。以下图示了软件开发的敏捷模型：
- en: '![](img/1e48e17b-d7e3-436f-9f70-3a42b1ff01fc.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e48e17b-d7e3-436f-9f70-3a42b1ff01fc.png)'
- en: Agile methodology
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷方法论
- en: From the preceding diagram, we can see that there is no time spent on requirement
    analysis or design. Instead, a very high-level plan is prepared, just enough to
    outline the scope of the project.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图中我们可以看到，没有时间花费在需求分析或设计上。相反，准备了一个非常高层次的计划，仅足以勾勒项目的范围。
- en: The team then goes through a series of iterations. Iteration can be classified
    as time frames, each lasting for a month or even a week in some mature projects.
    In this duration, a project team develops and tests features. The goal is to develop,
    test, and release a feature in a single iteration. At the end of the iteration,
    the feature goes for a demo. If the clients like it, then the feature goes live.
    But, if it gets rejected, the feature is taken as a backlog, re-prioritized, and
    again worked upon in the consecutive iteration.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后团队经历一系列迭代。迭代可以分类为时间框架，每个时间框架持续一个月，甚至在一些成熟项目中持续一周。在此期间，项目团队开发和测试特性。目标是在单个迭代中开发、测试和发布一个特性。在迭代结束时，该特性进行演示。如果客户喜欢它，那么该特性就上线了。但是，如果被拒绝，该特性将作为待办事项，重新排优先级，并在后续迭代中再次进行处理。
- en: There is also a possibility of parallel development and testing. In a single
    iteration, one can develop and test more than one feature in parallel.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 也存在并行开发和测试的可能性。在单个迭代中，可以并行开发和测试多个特性。
- en: Advantages of Agile software development process
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏捷软件开发过程的优势
- en: 'Let us see some of the advantages of the Agile software development process:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下敏捷软件开发过程的一些优势：
- en: '**Functionality can be developed and demonstrated rapidly**: In an agile process,
    the software project is divided by features, and each feature is called as a backlog.
    The idea is to develop either a single or a set of features right from its conceptualization
    till its deployment, in a week or a month. This puts at least a feature or two
    on the customer''s plate, which they can then start using.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能可以迅速开发和演示**：在敏捷过程中，软件项目被划分为特性，并且每个特性被称为一个待办事项。其想法是从概念化到部署，一周或一个月内开发单个或一组特性。这至少让客户有一个或两个特性可以使用。'
- en: '**Resource requirement is less**: In Agile, there are no separate development
    and testing teams. Neither is there a build or release team, or a deployment team.
    In Agile, a single project team contains around eight members. Each member of
    the team is capable of doing everything.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源需求较少**：在敏捷中，没有单独的开发和测试团队。也没有构建或发布团队，或者部署团队。在敏捷中，一个项目团队包含约八名成员。团队的每个成员都能做所有事情。'
- en: '**Promotes teamwork and cross-training**: Since there is a small team of about
    eight members, the team members switch their roles in turns and learn from each
    other''s experience.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**促进团队合作和交叉培训**：由于团队规模小约为八名成员，团队成员轮流担任角色，并从彼此的经验中学习。'
- en: '**Suitable for projects where requirements frequently change**: In an Agile
    model of software development, the complete software is divided into features,
    and each feature is developed and delivered in a short time span. Hence, changing
    the feature, or even completely discarding it, doesn''t affect the whole project.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适用于需求经常变化的项目**：在软件开发的敏捷模型中，整个软件被分割成特性，每个特性在短时间内开发和交付。因此，更改特性，甚至完全放弃它，都不会影响整个项目。'
- en: '**Minimalistic documentation**: This methodology focuses primarily on delivering
    working software quickly, rather than creating huge documents. Documentation exists,
    but it''s limited to the overall functionality.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**极简主义文档**：这种方法主要专注于快速交付可工作的软件，而不是创建庞大的文档。文档存在，但仅限于整体功能。'
- en: '**Little or no planning required**: Since features are developed one after
    the other in a short period, there is no need for extensive planning.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**几乎不需要计划**：由于功能在短时间内依次开发，因此无需进行广泛的规划。'
- en: '**Parallel development**: Iteration consists of one or more features developed
    in sequence, or even in parallel.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行开发**：迭代由一个或多个功能依次开发，甚至是并行开发。'
- en: The Scrum framework
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scrum框架
- en: Scrum is a framework for developing and sustaining complex products that are
    based on the Agile software development process. It is more than a process; it's
    a framework with certain roles, tasks, and teams. Scrum was written by **Ken Schwaber** and
    **Jeff Sutherland**; together, they created *The Scrum Guide*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Scrum是一个基于敏捷软件开发流程的开发和维护复杂产品的框架。它不仅仅是一个过程；它是一个具有特定角色、任务和团队的框架。Scrum由**肯·施瓦伯**和**杰夫·萨瑟兰**编写；他们一起创作了*Scrum指南*。
- en: In a Scrum framework, the development team decides on how to develop a feature.
    This is because the team knows best about the problem they are presented with.
    I assume most of the readers are happy after reading this.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scrum框架中，开发团队决定如何开发一个功能。这是因为团队最了解他们所面临的问题。我假设大多数读者在阅读完这篇文章后都会感到满意。
- en: Scrum relies on a self-organizing and cross-functional team. The Scrum team
    is self-organizing; hence, there is no overall team leader who decides which person
    will do which task, or how a problem will be solved.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Scrum依赖于一个自组织和跨职能的团队。Scrum团队是自组织的；因此，没有总体团队领导者决定哪个人将做哪个任务，或者如何解决问题。
- en: Important terms used in the Scrum framework
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scrum框架中使用的重要术语
- en: 'The following are the important terms used in the Scrum framework:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Scrum框架中使用的重要术语：
- en: '**The Sprint**: Sprint is a timebox during which a usable and potentially releasable
    product gets created. A new Sprint starts immediately after the conclusion of
    the previous Sprint. A Sprint may last between two weeks to one month, depending
    on the project''s command over Scrum.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冲刺**：冲刺是在其中创建一个可用且可能可发布的产品的时间段。一个新的冲刺在上一个冲刺结束后立即开始。冲刺的持续时间可能介于两周到一个月之间，具体取决于对Scrum的命令。'
- en: '**Product Backlog**: The Product Backlog is a list of all the required features
    in a software solution. The list is dynamic. That is, now and then the customers
    or team members add or delete items to the Product Backlog.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品待办列表**：产品待办列表是软件解决方案中所有必需功能的列表。该列表是动态的。也就是说，客户或团队成员时不时地向产品待办列表中添加或删除项目。'
- en: '**Sprint Backlog**: The Sprint Backlog is the set of Product Backlog items,
    selected for the Sprint.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冲刺待办列表**：冲刺待办列表是为冲刺选择的产品待办列表项目集合。'
- en: '**Increment**: The Increment is the sum of all the Product Backlog items completed
    during a Sprint and the value of the Increments from all the previous Sprints.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增量**：增量是在冲刺期间完成的所有产品待办列表项目以及所有先前冲刺的增量价值的总和。'
- en: '**The Development Team**: The Development Team does the work of delivering
    a releasable set of features named Increment at the end of each Sprint. Only members
    of the Development Team create the Increment. Development Teams are empowered
    by the organization to organize and manage their work. The resulting synergy optimizes
    the Development Team''s overall efficiency and effectiveness.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发团队**：开发团队负责在每个冲刺结束时交付一个可发布的功能集合，称为增量。只有开发团队的成员创建增量。开发团队由组织授权组织和管理他们的工作。由此产生的协同作用优化了开发团队的整体效率和效果。'
- en: '**The Product Owner**: The Product Owner is a mediator between the Scrum Team
    and everyone else. He is the front face of the Scrum Team and interacts with customers,
    infrastructure teams, admin teams, everyone involved in the Scrum, and so on.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品负责人**：产品负责人是Scrum团队与所有其他人之间的中介。他是Scrum团队的前台，并与客户、基础架构团队、管理团队以及所有参与Scrum的人等进行交互。'
- en: '**The Scrum Master**: The Scrum Master is responsible for ensuring Scrum is
    understood and enacted. Scrum Masters do this by ensuring that the Scrum Team
    follows the Scrum theory, practices, and rules.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scrum主管**：Scrum主管负责确保人们了解并执行Scrum。Scrum主管通过确保Scrum团队遵循Scrum理论、实践和规则来做到这一点。'
- en: How does Scrum work?
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scrum如何工作？
- en: 'The Product Owner, the Scrum Master, and the Scrum Team together follow a set
    of stringent procedures to deliver the software features. The following diagram
    explains the Scrum development process:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 产品负责人，Scrum Master和Scrum团队共同遵循一套严格的程序来交付软件功能。以下图表解释了Scrum开发过程：
- en: '![](img/5769741f-1b23-4f9f-8510-161d08fcb172.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5769741f-1b23-4f9f-8510-161d08fcb172.png)'
- en: Scrum methodology
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Scrum方法论
- en: Let us see some of the important aspects of the Scrum software development process
    that the team goes through.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看团队经历的Scrum软件开发过程的一些重要方面。
- en: Sprint Planning
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冲刺计划
- en: Sprint Planning is an opportunity for the Scrum Team to plan the features in
    the current Sprint cycle. The plan is created mainly by the developers. Once the
    plan is created, it is explained to the Scrum Master and the Product Owner. The
    Sprint Planning is a timeboxed activity, and it is usually around eight hours
    in total for a one-month Sprint cycle. It is the responsibility of the Scrum Master
    to ensure everyone participates in the Sprint Planning activity.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 冲刺计划是Scrum团队规划当前冲刺周期功能的机会。计划主要由开发人员创建。一旦计划创建完成，它会向Scrum Master和Product Owner解释。冲刺计划是一个时间框定的活动，通常在一个月的冲刺周期中总共约八小时。确保每个人都参与冲刺计划活动是Scrum
    Master的责任。
- en: 'In the meeting, the Development Team takes into consideration the following
    items:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在会议中，开发团队考虑以下项目：
- en: The number of Product Backlogs to be worked on (both new and the old ones from
    the last Sprint).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要处理的产品待办事项数量（包括上一个冲刺的新事项和旧事项）。
- en: Team performances in the last Sprint.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一个冲刺中的团队表现。
- en: Projected capacity of the Development Team.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发团队的预期容量。
- en: Sprint cycle
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冲刺周期
- en: During the Sprint cycle, the developers simply work on completing the backlogs
    decided in the Sprint Planning. The duration of a Sprint may last from two weeks
    to one month, depending on the number of backlogs.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在冲刺周期内，开发人员只需完成冲刺计划中决定的待办事项。冲刺的持续时间可能会从两周到一个月不等，这取决于待办事项的数量。
- en: Daily Scrum meeting
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每日Scrum会议
- en: This happens on a daily basis. During the Scrum meeting, the Development Team
    discusses what was accomplished yesterday, and what will be accomplished today.
    They also discuss the things that are stopping them from achieving their goal.
    The Development Team does not attend any other meeting or discussion apart from
    the Scrum meeting.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每天发生的事情。在Scrum会议期间，开发团队讨论昨天完成的工作，以及今天将要完成的工作。他们还讨论阻止他们实现目标的事情。开发团队除了Scrum会议外，不参加任何其他会议或讨论。
- en: Monitoring Sprint progress
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控冲刺进展
- en: The Daily Scrum is a good opportunity for a team to measure its progress. The
    Scrum Team can track the total work remaining, and by doing so, they can estimate
    the likelihood of achieving the Sprint Goal.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每日Scrum是团队测量进展的好机会。Scrum团队可以跟踪剩余的总工作量，通过这样做，他们可以估计实现冲刺目标的可能性。
- en: Sprint Review
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冲刺计划
- en: In the Sprint Review, the Development Team demonstrates the features that have
    been accomplished. The Product Owner updates on the Product Backlog status to
    date. The Product Backlog list is updated depending on the product performance
    or usage in the market. Sprint Review is a four-hour activity altogether for a
    one-month Sprint.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在冲刺回顾中，开发团队展示已完成的功能。Product Owner更新到目前为止的产品待办事项状态。产品待办事项列表根据产品在市场上的表现或使用情况进行更新。冲刺回顾对于一个月的冲刺来说是一个总共四小时的活动。
- en: Sprint Retrospective
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冲刺回顾
- en: In this meeting, the team discusses the things that went well, and the things
    that need improvement. The team then decides the points on which it has to improve
    to perform better in the upcoming Sprint. This meeting usually occurs after the
    Sprint Review and before the Sprint Planning.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次会议上，团队讨论了做得好的事情和需要改进的事情。然后，团队决定了要在即将到来的冲刺中改进的要点。这次会议通常在冲刺回顾之后，冲刺计划之前进行。
- en: Continuous Integration
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: Continuous Integration (CI) is a software development practice where developers
    frequently integrate their work with the project's Integration branch and create
    a build.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成（CI）是一种软件开发实践，开发人员经常将他们的工作与项目的集成分支相结合，并创建一个构建。
- en: Integration is the act of submitting your private work (modified code) to the
    common work area (the potential software solution). This is technically done by
    merging your private work (personal branch) with the common work area (Integration
    branch). Or we can say, pushing your private branch to the remote branch.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 集成是将您的个人工作（修改后的代码）提交到公共工作区（潜在的软件解决方案）的行为。这在技术上通过将您的个人工作（个人分支）与公共工作区（集成分支）合并来完成。或者我们可以说，将您的个人分支推送到远程分支。
- en: CI is necessary to bring out issues encountered during the integration as early
    as possible. This can be understood from the following diagram, which depicts
    various issues encountered during a single CI cycle.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成是为了尽早发现集成过程中遇到的问题。可以从下图中理解这一点，该图描述了单个持续集成周期中遇到的各种问题。
- en: A build failure can occur due to either an improper code or a human error while
    doing a build (assuming that the tasks are done manually). An integration issue
    can occur if the developers do not rebase their local copy of code frequently
    with the code on the Integration branch. A testing issue can occur if the code
    does not pass any of the unit or integration test cases.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 构建失败可能是由于不正确的代码或在构建过程中出现人为错误（假设任务是手动完成的）而导致的。如果开发人员不经常将他们的本地代码副本与集成分支上的代码重新基准，则可能会出现集成问题。如果代码未通过任何单元测试或集成测试用例，则可能会出现测试问题。
- en: 'In the event of an issue, the developer has to modify the code to fix it:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现问题时，开发人员必须修改代码以修复它：
- en: '![](img/c923f2eb-e6e1-4dd7-b42c-28c428b8c2b0.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c923f2eb-e6e1-4dd7-b42c-28c428b8c2b0.png)'
- en: CI process
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成过程
- en: Agile runs on CI
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏捷运行在持续集成上
- en: The Agile software development process focuses mainly on fast delivery, and
    CI helps Agile in achieving that speed. But how does CI do that? Let us understand
    by using a simple case.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷软件开发过程主要关注快速交付，持续集成帮助敏捷实现了这一速度。但是持续集成是如何做到的呢？让我们通过一个简单的案例来理解。
- en: Developing a feature involves many code changes, and between every code change,
    there are a set of tasks to perform, such as checking-in the code, polling the
    version control system for changes, building the code, unit testing, integration,
    building on the integrated code, integration testing, and packaging. In a CI environment,
    all these steps are made fast and error-free by using a CI tool such as *Jenkins*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个功能涉及到许多代码更改，在每次代码更改之间，有一系列任务要执行，比如检入代码，轮询版本控制系统以查看更改，构建代码，单元测试，集成，基于集成代码构建，集成测试和打包。在持续集成环境中，使用诸如*Jenkins*之类的持续集成工具可以使所有这些步骤变得快速且无错误。
- en: 'Adding notifications makes things even faster. The sooner the team members
    are aware of a build, integration, or deployment failure, the quicker they can
    act. The following diagram depicts all the steps involved in a CI process:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 添加通知可以使事情变得更快。团队成员越早意识到构建、集成或部署失败，他们就能越快采取行动。下图描述了持续集成过程中涉及的所有步骤：
- en: '![](img/1ce449b9-0115-4152-9e16-c5039649c57d.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1ce449b9-0115-4152-9e16-c5039649c57d.png)'
- en: CI process with notifications
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 带通知的持续集成过程
- en: In this way, the team quickly moves from feature to feature. In simple terms,
    the *agility* of the agile software development is greatly due to CI.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 团队通过这种方式快速从一个功能转移到另一个功能。简单地说，敏捷软件开发的*敏捷性*很大程度上是由持续集成所致。
- en: Types of projects that benefit from CI
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从持续集成中受益的项目类型
- en: The amount of code written for the embedded systems presents inside a car is
    more than the one present inside a fighter jet. In today's world, embedded software
    is inside every product, modern or traditional. Be it cars, TVs, refrigerators,
    wrist watches, or bikes; all have little or more software-dependent features.
    Consumer products are becoming smarter day by day. Nowadays, we can see a product
    being marketed more using its smart and intelligent features than its hardware
    capabilities. For example, an air conditioner is marketed by its wireless control
    features, and TVs are being marketed by their smart features, like embedded web
    browsers, and so on.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车内嵌系统中编写的代码量比战斗机内嵌系统中的代码量更多。在今天的世界中，嵌入式软件存在于每一种产品中，无论是现代产品还是传统产品。无论是汽车、电视、冰箱、手表还是自行车，所有产品都有多少与软件相关的功能。消费品每天都在变得更加智能。如今，我们可以看到一个产品更多地通过其智能和智能功能来进行市场推广，而不是其硬件功能。例如，空调通过其无线控制功能进行市场推广，电视则通过其智能功能（如嵌入式网页浏览器等）进行市场推广，等等。
- en: 'The need to market new products has increased the complexity of products. This
    increase in software complexity had brought the Agile software development and
    CI methodologies to the limelight, though there were times when agile software
    development was used by a team of no more than 30-40 people that were working
    on a simple project. Almost all types of projects benefit from CI: mostly the
    web-based projects, for example, the e-commerce websites, and mobile phone apps.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 推广新产品的需求增加了产品的复杂性。软件复杂性的增加使得敏捷软件开发和 CI 方法学备受关注，尽管过去有时敏捷软件开发仅被30-40人的小团队用于简单项目。几乎所有类型的项目都受益于
    CI：主要是基于 Web 的项目，例如电子商务网站和手机应用程序。
- en: CI and agile methodologies are used in projects that are based on Java, .NET,
    Ruby on Rails, and every other programming language present today. The only place
    where you will see it not being used is in the legacy systems. However, even they
    are going agile. Projects based on SAS, Mainframes; all are trying to benefit
    from CI.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: CI 和敏捷方法论在基于 Java、.NET、Ruby on Rails 和今天存在的每一种编程语言的项目中都被使用。唯一不使用它的地方是在传统系统中。然而，它们甚至也在转向敏捷。基于
    SAS、主机的项目；都在尝试从 CI 中受益。
- en: Elements of CI
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI 的元素
- en: Let us see the important elements of the CI process.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 CI 过程的重要元素。
- en: Version control system
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制系统
- en: This is the most basic and the most important requirement for implementing CI.
    A **Version Control System,** sometimes also called a **Revision Control System,**
    is a tool to manage your code history. It can be centralized or distributed. Some
    of the famous centralized version control systems are SVN and IBM Rational ClearCase.
    In the distributed segment, we have tools like GIT and Mercurial.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现 CI 的最基本和最重要的要求。**版本控制系统**，有时也称为**修订控制系统**，是管理代码历史记录的工具。它可以是集中式的或分布式的。一些著名的集中式版本控制系统包括
    SVN 和 IBM Rational ClearCase。在分布式部分，我们有像 Git 和 Mercurial 这样的工具。
- en: Ideally, everything that is required to build software must be version controlled.
    A version control tool offers many features, such as tagging, branching, and so
    on.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，构建软件所需的一切都必须进行版本控制。版本控制工具提供许多功能，如标记、分支等。
- en: Branching strategy
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支策略
- en: When using a Version Control System, keep the branching to a minimum. A few
    companies have only one main branch, and all the development activity happens
    on that. Nevertheless, most of the companies follow some branching strategies.
    This is because there is always a possibility that a part of the team may work
    on one release, while others may work on another release. Other times, there is
    a need to support the older release versions. Such scenarios always lead companies
    to use multiple branches.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用版本控制系统时，应将分支保持在最低限度。一些公司只有一个主分支，所有的开发活动都在这个分支上进行。然而，大多数公司都遵循一些分支策略。这是因为总会有一部分团队可能在一个发布版上工作，而另一部分团队可能在另一个发布版上工作。有时，需要支持旧版本的发布。这些情况总是导致公司使用多个分支。
- en: 'GitFlow is another way of managing your code using multiple branches. In the
    following method, the Master/Production branch is kept clean and contains only
    the releasable, ready-to-ship code. All the development happens on the Feature
    branches, with the Integration branch serving as a common place to integrate all
    the features. The following diagram is a moderate version of the GitFlow:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: GitFlow 是另一种使用多个分支管理代码的方式。在以下方法中，Master/Production 分支保持清洁，仅包含可发布、准备好发货的代码。所有的开发都在
    Feature 分支上进行，Integration 分支作为一个公共集成所有功能的地方。以下图示是 GitFlow 的一个中等版本：
- en: '![](img/2d249a6c-ede9-4a30-82d0-6bf59340a4f0.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d249a6c-ede9-4a30-82d0-6bf59340a4f0.png)'
- en: Branching strategy
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 分支策略
- en: GitFlow branching model
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitFlow 分支模型
- en: 'The following diagram illustrates the full version of GitFlow. We have a Master/Production
    branch that contains only the production-ready code. The Feature branches are
    where all of the development takes place. The Integration branch is where the
    code gets integrated and tested for quality. In addition to that, we have release
    branches that are pulled out from the Integration branch as and when there is
    a stable release. All bug fixes related to a release happen in the Release branches.
    There is also a Hotfix branch that is pulled out of the Master/Production branch
    as and when there is a need for a hotfix:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了完整版本的 GitFlow。我们有一个包含仅生产就绪代码的 Master/Production 分支。功能分支是所有开发都发生的地方。集成分支是代码集成和测试质量的地方。除此之外，我们还有从集成分支拉出的发布分支，只要有稳定版本发布，就会有与发布相关的所有错误修复。还有一个热修复分支，只要有必要进行热修复，就会从
    Master/Production 分支拉出来：
- en: '![](img/a452caa6-2dd5-4b7b-b374-fcd04f8ea34d.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a452caa6-2dd5-4b7b-b374-fcd04f8ea34d.png)'
- en: GitFlow branching strategy
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: GitFlow 分支策略
- en: CI tool
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI 工具
- en: 'What is a CI tool? Well, it is nothing more than an orchestrator. A CI tool
    is at the center of the CI system, connected to the Version Control System, build
    tools, Binary Repository Manager tool, testing and production environments, quality
    analysis tool, test automation tool, and so on. There are many CI tools: Build
    Forge, Bamboo, and TeamCity, to name a few. But the prime focus of our book is
    Jenkins:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 CI 工具？嗯，它不过是一个协调者。CI 工具位于 CI 系统的中心，连接到版本控制系统、构建工具、二进制存储库管理工具、测试和生产环境、质量分析工具、测试自动化工具等等。有许多
    CI 工具：Build Forge、Bamboo 和 TeamCity 等等。但我们书中的重点是 Jenkins：
- en: '![](img/89003f6b-027e-46f8-baa2-c3fe1109e946.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89003f6b-027e-46f8-baa2-c3fe1109e946.png)'
- en: Centralized CI server
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式 CI 服务器
- en: A CI tool provides options to create pipelines. Each pipeline has its own purpose.
    There are pipelines to take care of CI. Some take care of testing; some take care
    of deployments, and so on. Technically, a pipeline is a flow of jobs. Each job
    is a set of tasks that run sequentially. Scripting is an integral part of a CI tool
    that performs various kinds of tasks. The tasks may be as simple as copying a
    folder/file from one location to the other, or they can be complex Perl scripts
    to monitor machines for file modifications. Nevertheless, the script is getting
    replaced by the growing number of plugins available in Jenkins. Now you need not
    script to build a Java code; there are plugins available for it. All you need
    to do is install and configure a plugin to get the job done. Technically, plugins
    are nothing but small modules written in Java. They remove the burden of scripting
    from the developer's head. We will learn more about pipelines in the upcoming
    chapters.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: CI 工具提供了创建流水线的选项。每个流水线都有其自身的目的。有一些流水线负责 CI。有些负责测试；有些负责部署等等。技术上，流水线是作业的流动。每个作业是一组按顺序运行的任务。脚本编写是
    CI 工具的一个组成部分，它执行各种类型的任务。这些任务可能是简单的，比如从一个位置复制文件/文件夹到另一个位置，或者它们可能是复杂的 Perl 脚本，用于监视文件修改的机器。尽管如此，随着
    Jenkins 中可用插件数量的增加，脚本正在被替换。现在，你不需要脚本来构建 Java 代码；有相应的插件可用。你所需要做的就是安装和配置一个插件来完成工作。技术上，插件只是用
    Java 编写的小模块。它们减轻了开发人员的脚本编写负担。我们将在后续章节中更多地了解流水线。
- en: Self-triggered builds
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自触发构建
- en: 'The next important thing to understand is the self-triggered automated build.
    Build automation is simply a series of automated steps that compile the code and
    generate executables. The build automation can take the help of build tools like
    Ant and Maven. The self-triggered automated build is the most important part of
    a CI system. There are two main factors that call for an automated build mechanism:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要理解的重要事情是自触发自动化构建。构建自动化只是一系列自动化步骤，用于编译代码和生成可执行文件。构建自动化可以借助构建工具如 Ant 和 Maven。自触发自动化构建是
    CI 系统中最重要的部分。有两个主要因素需要自动化构建机制：
- en: Speed.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度。
- en: Catching integration or code issues as early as possible.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽早捕获集成或代码问题。
- en: There are projects where 100 to 200 builds happen per day. In such cases, speed
    plays an important factor. If the builds are automated, then it can save a lot
    of time. Things become even more interesting if the triggering of the build is
    made self-driven, without any manual intervention. Auto-triggered build on every
    code change further saves time.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有些项目每天会有 100 到 200 次构建。在这种情况下，速度是一个重要因素。如果构建是自动化的，那么可以节省很多时间。如果构建的触发是自动驱动的，而不需要任何手动干预，事情就变得更有趣了。在每次代码更改时自动触发构建进一步节省时间。
- en: 'When builds are frequent and fast, the probability of finding an error (build
    error, compilation error, or integration error) in the framework of SDLC is higher
    and faster:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建频繁且快速时，SDLC 框架中发现错误（构建错误、编译错误或集成错误）的概率更高且更快：
- en: '![](img/07304f0b-783a-498e-b707-c033986ca49d.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07304f0b-783a-498e-b707-c033986ca49d.png)'
- en: Probability of error versus build graph
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 错误概率与构建图
- en: Code coverage
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖
- en: 'Code coverage is the amount of code (in percentage) that is covered by your
    test case. The metrics that you might see in your coverage reports could be more
    or less as defined in the following table:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖是您的测试用例覆盖的代码量（以百分比表示）。您在覆盖报告中看到的度量标准可能更多或更少，如下表所定义：
- en: '| **Type of coverage** | **Description** |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **覆盖类型** | **描述** |'
- en: '| Function | The number of functions called out of the total number of functions
    defined |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| Function | 被调用的函数数量占定义的函数总数的比例 |'
- en: '| Statement | The number of statements in the program that are truly called
    out of the total number |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| Statement | 程序中实际调用的语句数占总数的比例 |'
- en: '| Branches | The number of branches of the control structures executed |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| Branches | 执行的控制结构的分支数 |'
- en: '| Condition | The number of Boolean sub-expressions that are being tested for
    a true and a false value |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| Condition | 正在测试的布尔子表达式的数量，测试真值和假值 |'
- en: '| Line | The number of lines of source code that are being tested out of the
    total number of lines present inside the code |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| Line | 正在测试的源代码行数占代码总行数的比例 |'
- en: Types of code coverage
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖类型
- en: 'This coverage percentage is calculated by dividing the number of items tested
    by the number of items found. The following screenshot illustrates the code coverage
    report from  SonarQube:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 该覆盖率百分比通过将被测试项的数量除以找到的项的数量来计算。以下截图显示了来自 SonarQube 的代码覆盖报告：
- en: '**![](img/ccf7322a-5472-4ad9-98f5-bacf5798ade3.png)**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/ccf7322a-5472-4ad9-98f5-bacf5798ade3.png)**'
- en: Code coverage report on SonarQube
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: SonarQube 上的代码覆盖报告
- en: Code coverage tools
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖工具
- en: 'You might find several options to create coverage reports, depending on the
    language(s) you use. Some of the popular tools are listed as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您使用的语言，可能会发现几种创建覆盖报告的选项。以下是一些流行工具：
- en: '| **Language** | **Tools** |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **语言** | **工具** |'
- en: '| Java | Atlassian Clover, Cobertura, JaCoCo |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| Java | Atlassian Clover, Cobertura, JaCoCo |'
- en: '| C#/.NET | OpenCover, dotCover |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| C#/.NET | OpenCover, dotCover |'
- en: '| C++ | OpenCppCoverage, gcov |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| C++ | OpenCppCoverage, gcov |'
- en: '| Python | Coverage.py |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| Python | Coverage.py |'
- en: '| Ruby | SimpleCov |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| Ruby | SimpleCov |'
- en: Static code analysis
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态代码分析
- en: Static code analysis, also commonly called **white-box** testing, is a form
    of software testing that looks for the structural qualities of the code. For example,
    it answers how robust or maintainable the code is. Static code analysis is performed
    without actually executing programs. It is different from the functional testing,
    which looks into the functional aspects of software, and is dynamics.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析，通常也称为**白盒**测试，是一种查找代码结构质量的软件测试形式。例如，它回答了代码的健壮性或可维护性如何。静态代码分析是在实际执行程序之前执行的。它与功能测试不同，功能测试着眼于软件的功能方面，并且是动态的。
- en: Static code analysis is the evaluation of software's inner structures. For example,
    is there a piece of code used repetitively? Does the code contain lots of commented
    lines? How complex is the code? Using the metrics defined by a user, an analysis
    report is generated that shows the code quality regarding maintainability. It
    doesn't question the code's functionality.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析是对软件内部结构的评估。例如，是否有一段重复使用的代码？代码中是否包含大量的注释行？代码有多复杂？使用用户定义的度量标准，生成了一个分析报告，显示了代码在可维护性方面的质量。它不质疑代码的功能。
- en: Some of the static code analysis tools like SonarQube come with a dashboard,
    which shows various metrics and statistics of each run. Usually, as part of CI,
    the static code analysis is triggered every time a build runs. As discussed in
    the previous sections, static code analysis can also be included before a developer
    tries to check-in his code. Hence, a code of low quality can be prevented right
    at the initial stage.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一些静态代码分析工具，如 SonarQube，配备了仪表板，显示每次运行的各种指标和统计数据。通常作为 CI 的一部分，每次运行构建时都会触发静态代码分析。如前几节讨论的，静态代码分析也可以在开发人员尝试提交代码之前包含。因此，低质量的代码可以在最初阶段就被阻止。
- en: 'They support many languages, such as Java, C/C++, Objective-C, C#, PHP, Flex,
    Groovy, JavaScript, Python, PL/SQL, COBOL, and so on. The following screenshots illustrate
    the static code analysis report using SonarQube:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 他们支持许多语言，如Java、C/C++、Objective-C、C#、PHP、Flex、Groovy、JavaScript、Python、PL/SQL、COBOL等等。以下截图展示了使用SonarQube进行静态代码分析报告：
- en: '![](img/ab5d269d-6d44-449e-b6da-be6b1d649e1c.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab5d269d-6d44-449e-b6da-be6b1d649e1c.png)'
- en: Static code analysis report
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析报告
- en: '![](img/da3b4670-eb42-4f16-a02d-deffe64d51ae.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da3b4670-eb42-4f16-a02d-deffe64d51ae.png)'
- en: Static code analysis report
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析报告
- en: Automated testing
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试
- en: Testing is an important part of an SDLC. To maintain quality software, it is
    necessary that the software solution goes through various test scenarios. Giving
    less importance to testing can result in customer dissatisfaction and a delayed
    product.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是SDLC的重要组成部分。为了保持软件质量，必须让软件解决方案通过各种测试场景。对测试的重视不足可能导致客户不满意和产品延迟。
- en: Since testing is a manual, time-consuming, and repetitive task, automating the
    testing process can significantly increase the speed of software delivery. However,
    automating the testing process is a bit more difficult than automating the build,
    release, and deployment processes. It usually takes a lot of effort to automate
    nearly all the test cases used in a project. It is an activity that matures over
    time.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试是一项手动、耗时且重复的任务，自动化测试流程可以显着提高软件交付速度。然而，自动化测试流程要比自动化构建、发布和部署流程困难得多。通常需要大量工作来自动化项目中几乎所有使用的测试用例。这是一个随着时间逐渐成熟的活动。
- en: Hence, when beginning to automate the testing, we need to take a few factors
    into consideration. Test cases that are of great value and easy to automate must
    be considered first. For example, automate the testing where the steps are the
    same, although they run with different data every time. Further, automate the
    testing where software functionality is tested on various platforms. Also, automate
    the testing that involves a software application running with different configurations.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在开始自动化测试时，我们需要考虑一些因素。首先考虑那些价值高且易于自动化的测试用例。例如，在步骤相同的情况下自动化测试，尽管每次都使用不同的数据。此外，自动化测试涉及在各种平台上测试软件功能的测试。还要自动化测试涉及使用不同配置运行软件应用程序的测试。
- en: Previously, the world was mostly dominated by desktop applications. Automating
    the testing of a GUI-based system was quite difficult. This called for scripting
    languages where the manual mouse and keyboard entries were scripted and executed
    to test the GUI application. Nevertheless, today the software world is completely
    dominated by web and mobile-based applications, which are easy to test through
    an automated approach using a test automation tool.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，世界主要由桌面应用程序主导。自动化GUI系统的测试相当困难。这就需要脚本语言，其中手动鼠标和键盘输入被脚本化并执行以测试GUI应用程序。然而，如今，软件世界完全被基于Web和移动的应用程序主导，可以通过使用测试自动化工具的自动化方法轻松测试。
- en: Once a code is built, packaged, and deployed, testing should run automatically
    to validate the software. Traditionally, the process followed is to have an environment
    for SIT, UAT, PT, and pre-production. First, the release goes through SIT, which
    stands for system integration testing. Here, testing is performed on an integrated
    code to check its functionality altogether. If the integration testing is passed,
    the code is deployed to the next environment, which is UAT, where it goes through
    user acceptance testing, and then it can lastly be deployed in PT, where it goes
    through performance testing. In this way, the testing is prioritized.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码构建、打包和部署完成，就应该自动运行测试来验证软件。传统上，遵循的流程是为SIT、UAT、PT和预生产环境准备环境。首先，发布通过SIT，即系统集成测试。在这里，对集成代码进行测试，以检查其功能是否完全。如果集成测试通过，则代码将部署到下一个环境，即UAT，在那里经过用户验收测试，最后可以部署到PT，在那里经过性能测试。通过这种方式，测试得到了优先考虑。
- en: It is not always possible to automate all the testing. But, the idea is to automate
    whatever testing that is possible. The preceding method discussed requires the
    need to have many environments and also a higher number of automated deployments
    into various environments. To avoid this, we can go for another method where there
    is only one environment where the build is deployed, and then the basic tests
    are run, and after that, long-running tests are triggered manually.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 并不总是可能自动化所有的测试。但是，思想是尽可能自动化所有可能的测试。前述的方法需要许多环境，以及在各种环境中进行更高数量的自动化部署。为了避免这种情况，我们可以采用另一种方法，在这种方法中，只有一个环境部署了构建，然后运行基本测试，然后手动触发长时间
- en: Binary repository tools
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制存储库工具
- en: As part of the SDLC, the source code is continuously built into binary artifacts
    using CI. Therefore, there should be a place to store these built packages for
    later use. The answer is, using a binary repository tool. But what is a binary
    repository tool?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 作为SDLC的一部分，源代码被持续地使用CI构建成二进制产物。因此，应该有一个地方来存储这些构建包以供以后使用。答案是，使用一个二进制存储库工具。但是什么是二进制存储库工具？
- en: 'A binary repository tool is a Version Control System for binary files. Do not
    confuse this with the Version Control System discussed in the previous sections.
    The former is responsible for versioning the source code, and the latter is for
    binary files, such as `.rar`, `.war`, `.exe`, `.msi`, and so on. Along with managing
    built artifacts, a binary repository tool can also manage 3-party binaries that
    are required for a build. For example, the Maven plugin always downloads the plugins
    required to build the code into a folder. Rather than downloading the plugins
    again and again, they can be managed using a repository tool:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制存储库工具是用于二进制文件的版本控制系统。不要将其与前面讨论的版本控制系统混淆。前者负责对源代码进行版本控制，而后者负责二进制文件，例如`.rar`、`.war`、`.exe`、`.msi`等文件。除了管理构建产物外，二进制存储库工具还可以管理构建所需的第三方二进制文件。例如，Maven插件始终会下载构建代码所需的插件到一个文件夹中。与其一遍又一遍地下载插件，不如使用存储库工具管理：
- en: '![](img/704daee7-e279-40f8-ac8c-2fb2e1f88c33.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/704daee7-e279-40f8-ac8c-2fb2e1f88c33.png)'
- en: Repository tool
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库工具
- en: From the above illustration, you can see as soon as a build gets created and
    passes all the checks, the built artifact is uploaded to the binary repository
    tool. From here, the developers and testers can manually pick them, deploy them,
    and test them. Or, if the automated deployment is in place, then the built artifacts
    are automatically deployed to the respective test environment. So, what're the
    advantages of using a binary repository?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的说明中，您可以看到，一旦创建了一个构建并通过了所有的检查，构建产物就会被上传到二进制存储库工具中。从这里，开发人员和测试人员可以手动选择、部署和测试它们。或者，如果自动部署已经就位，那么构建产物将自动部署到相应的测试环境。那么，使用二进制存储库的优势是什么呢？
- en: 'A binary repository tool does the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制存储库工具执行以下操作：
- en: Every time a built artifact gets generated, it is stored in a binary repository
    tool. There are many advantages of storing the build artifacts. One of the most
    important advantages is that the build artifacts are located in a centralized
    location from where they can be accessed when needed.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次生成构建产物时，都会存储在一个二进制存储库工具中。存储构建产物有许多优点。其中一个最重要的优点是，构建产物位于一个集中的位置，可以在需要时访问。
- en: It can store third-party binary plugins, modules that are required by the build
    tools. Hence, the build tool need not download the plugins every time a build
    runs. The repository tool is connected to the online source and keeps updating
    the plugin repository.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以存储构建工具所需的第三方二进制插件、模块。因此，构建工具不需要每次运行构建时都下载插件。存储库工具连接到在线源并不断更新插件存储库。
- en: It records what, when, and who created a build package.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录了什么、何时以及谁创建了一个构建包。
- en: It provides a staging like environments to manage releases better. This also
    helps in speeding up the CI process.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了类似于**环境**的分段，以更好地管理发布。这也有助于加速CI流程。
- en: In a CI environment, the frequency of build is too high, and each build generates
    a package. Since all the built packages are in one place, developers are at liberty
    to choose what to promote and what not to promote in higher environments.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CI环境中，构建的频率太高，每个构建都会生成一个包。由于所有构建的包都在一个地方，开发人员可以自由选择在高级环境中推广什么，而不推广什么。
- en: Automated packaging
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动打包
- en: There is a possibility that a build may have many components. Let's take, for
    example, a build that has a `.rar` file as an output. Along with that, it has
    some Unix configuration files, release notes, some executables, and also some
    database changes. All of these different components need to be together. The task
    of creating a single archive or a single media out of many components is called
    **packaging**. Again, this can be automated using the CI tools and can save a
    lot of time.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能一个构建可能有许多组件。例如，让我们考虑一个具有`.rar`文件作为输出的构建。除此之外，它还有一些Unix配置文件、发布说明、一些可执行文件，以及一些数据库更改。所有这些不同的组件需要在一起。将许多组件创建为单个存档或单个媒体的任务称为**打包**。同样，这可以使用CI工具自动化，并节省大量时间。
- en: Benefits of using CI
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CI的好处
- en: The following are some of the benefits of using CI. The list is brief, and not
    comprehensive.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用CI的一些好处。该列表简要概述，不全面。
- en: Freedom from long integrations
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摆脱长时间的集成
- en: Integrating the code rarely, as seen in the Waterfall model, can lead to *merge
    hell*. It is a situation wherein teams spend weeks resolving the merge issues.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 很少进行代码集成，正如在瀑布模型中所见，可能导致*合并地狱*。这是一个团队花费数周解决合并问题的情况。
- en: In contrast to this, integrating every single commit on your Feature branch
    with the Integration branch and testing it for issues (CI) allows you to find
    integration issues as early as possible.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，将特性分支上的每个提交与集成分支进行集成，并对其进行问题测试（CI），允许您尽早发现集成问题。
- en: Metrics
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指标
- en: Tools like Jenkins, SonarQube, Artifactory, and GitHub allow you to generate
    trends over a period. All of these trends can help project managers and teams
    to make sure the project is heading in the right direction and with the right
    pace.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins、SonarQube、Artifactory和GitHub等工具可以让您在一段时间内生成趋势。所有这些趋势都可以帮助项目经理和团队确保项目朝着正确的方向和正确的步伐发展。
- en: Catching issues faster
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更快地发现问题
- en: This is the most important advantage of having a carefully implemented CI system.
    Any integration issue or merge issue gets caught early. The CI system has the
    facility to send notification as soon as the build fails.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是仔细实施CI系统的最重要优势。任何集成问题或合并问题都会被及早发现。CI系统有能力在构建失败时立即发送通知。
- en: Rapid development
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速开发
- en: From a technical perspective, CI helps teams work more efficiently. Projects
    that use CI follow an automatic and continuous approach while building, testing,
    and integrating their code. This results in a faster development.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，CI有助于团队更高效地工作。使用CI的项目在构建、测试和集成其代码时采用自动和持续的方法。这导致开发速度更快。
- en: Developers spend more time developing their code and zero time building, packaging,
    integrating, and deploying it, as everything is automated. This also helps teams
    that are geographically distributed to work together. With a good *software configuration
    management process* in place, people can work on widely distributed teams.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员花费更多时间开发他们的代码，零时间构建、打包、集成和部署它，因为一切都是自动化的。这也有助于地理上分布的团队共同工作。有了良好的*软件配置管理流程*，人们可以在广泛分布的团队上工作。
- en: Spend more time adding features
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 花更多时间添加功能
- en: In the past, build and release activities were managed by the developers, along
    with the regular development work. It was followed by a trend of having separate
    teams that handled the build, release, and deployment activities. And it didn't
    stop there; this new model suffered from communication issues and a lack of coordination
    among developers, release engineers, and testers. However, using CI, all the build,
    release, and deployment work gets automated. Therefore, the development team need
    not worry about anything other than developing features. In most cases, even the
    complete testing is automated. Therefore by using a CI process, the development
    team can spend more time developing the code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，构建和发布活动由开发人员负责，与常规开发工作一起进行。随后出现了一个趋势，即有专门的团队负责构建、发布和部署活动。而且事情并没有止步于此；这种新模式遭遇了开发人员、发布工程师和测试人员之间的沟通问题和协调不足。然而，使用CI，所有构建、发布和部署工作都得到了自动化。因此，开发团队无需担心其他任何事情，只需开发功能即可。在大多数情况下，甚至连完整测试都是自动化的。因此，通过使用CI流程，开发团队可以花更多时间开发代码。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: '"Behind every successful agile project, there is a Continuous Integration process."'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: “每个成功的敏捷项目背后都有一个持续集成的过程。”
- en: In this chapter, we took a glance through the history of software engineering
    processes. We learned about CI and the elements that make it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们粗略地了解了软件工程流程的历史。我们学习了持续集成（CI）及其组成要素。
- en: The various concepts and terminologies discussed in this chapter form a foundation
    for the upcoming chapters. Without these, the coming chapters are mere technical
    know-how.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的各种概念和术语构成了后续章节的基础。没有这些，接下来的章节只是技术知识。
- en: In the next chapter, we will learn how to install Jenkins on various platforms.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在各种平台上安装Jenkins。
