- en: Automating Simple Tasks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化简单任务
- en: As mentioned in the previous chapter, Ansible can be used to both create and
    manage a whole infrastructure, as well as be integrated into an infrastructure
    that is already working.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，Ansible 可用于创建和管理整个基础架构，也可集成到已经运行的基础架构中。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: YAML
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAML
- en: Working with Playbook
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Playbook
- en: Ansible velocity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 速度
- en: Variables in Playbook
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Playbook 中的变量
- en: Creating the Ansible User
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Ansible 用户
- en: Configuring a basic server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置基本服务器
- en: Installing and configuring a web server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置 Web 服务器
- en: Publishing a website
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布网站
- en: Jinja2 templates
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jinja2 模板
- en: First, we will talk about **YAML Ain't Markup Language** (**YAML**), a human-readable
    data serialization language that is widely used in Ansible.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论**YAML Ain't Markup Language**（**YAML**），这是一种人类可读的数据序列化语言，广泛用于 Ansible。
- en: Technical Requirement
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can  download all the files from this book's GitHub repository at: [https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter02).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本书的 GitHub 存储库下载所有文件：[https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter02)。
- en: YAML
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAML
- en: 'YAML, like many other data serialization languages (such as JSON), has very
    few, basic concepts:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: YAML，像许多其他数据序列化语言（如 JSON）一样，有着极少的基本概念：
- en: Declarations
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明
- en: Lists
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: Associative arrays
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联数组
- en: 'A declaration is very similar to a variable in any other language, which is
    as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 声明与任何其他语言中的变量非常相似，如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To create a list, we will have to use `-`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建列表，我们将使用`-`：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'YAML uses indentation to logically divide parents from children. So, if we
    want to create associative arrays (also known as objects), we would just need
    to add an indentation:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 使用缩进来在逻辑上将父项与子项分隔开来。因此，如果我们想创建关联数组（也称为对象），我们只需要添加一个缩进：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Obviously, we can mix those together as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以将它们混合在一起，如下所示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Those are the basics of YAML. YAML can do much more, but for now, this will
    be enough.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 YAML 的基础知识。YAML 可以做得更多，但目前这些就足够了。
- en: Hello Ansible
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好 Ansible
- en: As we have seen in the previous chapter, it is possible to use Ansible to automate
    simple tasks that you probably already perform daily.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一章中看到的，可以使用 Ansible 自动化您可能每天已经执行的简单任务。
- en: 'Let''s start by checking whether or not a remote machine is reachable; in other
    words, let''s start by pinging a machine. The simplest way to do this is to run
    the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查远程机器是否可达开始；换句话说，让我们从对机器进行 ping 开始。这样做的最简单方法是运行以下命令：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `HOST` is an IP address, the **Fully Qualified Domain Name** (**FQDN**),
    or an alias of a machine where you have SSH access (you can use a **Vagrant**
    host, as we have seen in the previous chapter).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`HOST`是您拥有 SSH 访问权限的机器的 IP 地址、**Fully Qualified Domain Name**（**FQDN**）或别名（您可以使用像我们在上一章中看到的
    **Vagrant** 主机）。
- en: After `HOST`, the comma is mandatory, because otherwise, it would not be seen
    as a list, but as a string.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HOST`之后，逗号是必需的，因为否则，它不会被视为列表，而是视为字符串。
- en: 'In this case, we have performed it against a virtual machine on our system:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们执行了针对我们系统上的虚拟机：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should receive something like this as a result:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该收到类似这样的结果：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s see what we did and why. Let''s start from the Ansible help. To
    query it, we can use the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们做了什么以及为什么。让我们从 Ansible 帮助开始。要查询它，我们可以使用以下命令：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To make it easier to read, we have removed all the output related to options
    that we have not used:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易阅读，我们已删除了与我们未使用的选项相关的所有输出：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So, what we did was as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们所做的是：
- en: We invoked Ansible.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用了 Ansible。
- en: We instructed Ansible to run on all hosts.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们指示 Ansible 在所有主机上运行。
- en: We specified our inventory (also known as the list of the hosts).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们指定了我们的清单（也称为主机列表）。
- en: We specified the module we wanted to run (`ping`).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们指定了要运行的模块（`ping`）。
- en: 'Now that we can ping the server, let''s try `echo hello ansible!`, as shown
    in the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以 ping 服务器，让我们尝试`echo hello ansible!`，如下命令所示：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should receive something like this as a result:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该收到类似这样的结果：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this example, we used an additional option. Let''s check the Ansible help
    to see what it does:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用了一个额外的选项。让我们检查 Ansible 帮助以查看它的作用：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you may have guessed from the context and the name, the `args` options allow
    you to pass additional arguments to the module. Some modules (such as `ping`)
    do not support any arguments, while others (such as `shell`) will require arguments.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从上下文和名称可以猜到，`args` 选项允许你向模块传递额外的参数。某些模块（如 `ping`）不支持任何参数，而其他模块（如 `shell`）将需要参数。
- en: Working with playbooks
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 playbooks
- en: '**Playbooks** are one of the core features of Ansible and tell Ansible what
    to execute. They are like a to-do list for Ansible that contains a list of tasks;
    each task internally links to a piece of code called a **module**. Playbooks are
    simple, human-readable YAML files, while modules are a piece of code that can
    be written in any language, with the condition that its output be in the JSON
    format. You can have multiple tasks listed in a playbook, and these tasks would
    be executed serially by Ansible. You can think of playbooks as an equivalent of
    manifests in Puppet, states in Salt, or cookbooks in Chef; they allow you to enter
    a list of tasks or commands you want to execute on your remote system.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**Playbooks** 是 Ansible 的核心特性之一，告诉 Ansible 要执行什么。它们就像 Ansible 的待办事项列表，包含一系列任务；每个任务内部链接到一个称为
    **模块** 的代码片段。Playbooks 是简单易读的 YAML 文件，而模块是可以用任何语言编写的代码片段，条件是其输出格式为 JSON。你可以在一个
    playbook 中列出多个任务，这些任务将由 Ansible 串行执行。你可以将 playbooks 视为 Puppet 中的清单、Salt 中的状态或
    Chef 中的菜谱的等价物；它们允许你输入你想在远程系统上执行的任务或命令列表。'
- en: Studying the anatomy of a playbook
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 研究 playbook 的结构
- en: Playbooks can have a list of remote hosts, user variables, tasks, handlers,
    and so on. You can also override most of the configuration settings through a
    playbook. Let's start looking at the anatomy of a playbook.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Playbooks 可以具有远程主机列表、用户变量、任务、处理程序等。你还可以通过 playbook 覆盖大部分配置设置。让我们开始研究 playbook
    的结构。
- en: 'The purpose of the playbook that we are going to consider now is to ensure
    that the `httpd` package is installed and the service is **enabled** and **started**.
    This is the content of the `setup_apache.yaml` file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要考虑的 playbook 的目的是确保 `httpd` 包已安装并且服务已 **启用** 和 **启动**。这是 `setup_apache.yaml`
    文件的内容：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `setup_apache.yaml` file is an example of a playbook. The file is comprised
    of three main parts, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup_apache.yaml` 文件是一个 playbook 的示例。文件由三个主要部分组成，如下所示：'
- en: '`hosts`: This lists the host or host group that we want to run the task against.
    The hosts field is required. It is used by Ansible to determine which hosts will
    be targeted by the listed tasks. If a host group is provided instead of a host,
    Ansible will try to look up the hosts belonging to it based on the inventory file.
    If there is no match, Ansible will skip all the tasks for that host group. The
    `--list-hosts` option, along with the playbook (`ansible-playbook <playbook> --list-hosts`),
    will tell you exactly which hosts the playbook will run against.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hosts`: 这列出了我们要针对哪个主机或主机组运行任务。hosts 字段是必需的。Ansible 使用它来确定哪些主机将成为列出任务的目标。如果提供的是主机组而不是主机，则
    Ansible 将尝试根据清单文件查找属于它的主机。如果没有匹配项，Ansible 将跳过该主机组的所有任务。`--list-hosts` 选项以及 playbook
    (`ansible-playbook <playbook> --list-hosts`) 将告诉你准确地 playbook 将运行在哪些主机上。'
- en: '`remote_user`: This is one of the configuration parameters of Ansible (consider,
    for example, `tom'' - remote_user`) that tells Ansible to use a particular user
    (in this case, `tom`) while logging into the system.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remote_user`: 这是 Ansible 的配置参数之一（例如，`tom'' - remote_user`），告诉 Ansible 在登录系统时使用特定用户（在本例中为
    `tom`）。'
- en: '`tasks`: Finally, we come to tasks. All playbooks should contain tasks. Tasks
    are a list of actions that you want to perform. A `tasks` field contains the name
    of the task (that is, the help text for the user about the task), a module that
    should be executed, and arguments that are required for the module. Let''s look
    at the single task that is listed in the playbook, as shown in the preceding snippet
    of code.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasks`: 最后，我们来到了任务。所有 playbook 应该包含任务。任务是你想执行的一系列操作。一个 `tasks` 字段包含了任务的名称（即，用户关于任务的帮助文本）、应该执行的模块以及模块所需的参数。让我们看一下在
    playbook 中列出的单个任务，如前面代码片段所示。'
- en: All examples in the book would be executed on CentOS, but the same set of examples
    with a few changes would work on other distributions as well.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有示例将在 CentOS 上执行，但是对同一组示例进行少量更改后也可以在其他发行版上运行。
- en: 'In the preceding case, there are two tasks. The `name` parameter represents
    what the task is doing and is `present` mainly to improve readability, as we''ll
    see during the playbook run. The `name` parameter is optional. The `yum` and `service` modules
    have their own set of parameters. Almost all modules have the `name` parameter
    (there are exceptions, such as the `debug` module), which indicates what component
    the actions are performed on. Let''s look at the other parameters:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，有两个任务。`name`参数表示任务正在做什么，并且主要是为了提高可读性，正如我们在playbook运行期间将看到的那样。`name`参数是可选的。`yum`和`service`模块有自己的一组参数。几乎所有模块都有`name`参数（有例外，比如`debug`模块），它表示对哪个组件执行操作。让我们看看其他参数：
- en: The `state` parameter holds the latest value in the `yum` module, and it indicates
    that the `httpd` package should have been installed. The command to execute roughly
    translates to `yum install httpd`.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`参数在`yum`模块中保存了最新的值，它表示应该安装`httpd`软件包。执行的命令大致相当于`yum install httpd`。'
- en: In the `service` module's scenario, the `state` parameter with the started value
    indicates that the `httpd` service should be started, and it roughly translates
    to a `/etc/init.d/httpd` start. In this module, we also have the `enabled` parameter,
    which defines whether the service should start at boot or not.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`service`模块的场景中，带有`started`值的`state`参数表示`httpd`服务应该启动，它大致相当于`/etc/init.d/httpd`启动。在此模块中，我们还有`enabled`参数，它定义了服务是否应该在启动时启动。
- en: 'The `become: True` parameter represents the fact that the tasks should be executed
    with `sudo` access. If the `sudo` user''s file does not allow the user to run
    the particular command, then the playbook will fail when it is run.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`become: True`参数表示任务应该以`sudo`访问权限执行。如果`sudo`用户的文件不允许用户运行特定命令，那么当运行playbook时，playbook将失败。'
- en: You might have questions about why there is no package module that figures out
    the architecture internally and runs the `yum`, `apt`, or any other package options
    depending on the architecture of the system. Ansible populates the package manager
    value into a variable named `ansible_pkg_manager`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么没有一个包模块能够在内部确定架构并根据系统的架构运行`yum`、`apt`或任何其他包选项。Ansible将包管理器的值填充到一个名为`ansible_pkg_manager`的变量中。
- en: In general, we need to remember that the number of packages that have a common
    name across different operating systems are a small subset of the number of packages
    that are actually present. For example, the `httpd` package is called `httpd`
    in Red Hat systems, but is called `apache2` in Debian-based systems. We also need
    to remember that every package manager has its own set of options that make it
    powerful; as a result, it makes more sense to use explicit package manager names
    so that the full set of options are available to the end user writing the playbook.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们需要记住，在不同操作系统中具有通用名称的软件包的数量是实际存在的软件包数量的一个很小的子集。例如，`httpd`软件包在Red Hat系统中称为`httpd`，但在基于Debian的系统中称为`apache2`。我们还需要记住，每个包管理器都有自己的一组选项，使其功能强大；因此，使用明确的包管理器名称更合理，这样终端用户编写playbook时就可以使用完整的选项集。
- en: Running a playbook
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行playbook
- en: 'Now, it''s time (yes, finally!) to run the playbook. To instruct Ansible to
    execute a playbook instead of a module, we will have to use a different command
    (`ansible-playbooks`) that has a syntax very similar to the `ansible` command
    we already saw:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候（是的，终于！）运行playbook了。为了指示Ansible执行playbook而不是模块，我们将不得不使用一个语法非常类似于我们已经看到的`ansible`命令的不同命令（`ansible-playbooks`）：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, aside from the host-pattern (that is specified in the playbook),
    which has disappeared, and the module option, which has been replaced by the playbook
    name, nothing has changed. So, to execute this command on my machine, the exact
    command is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，除了在playbook中指定的主机模式（已消失）和模块选项（已被playbook名称替换）之外，没有任何变化。因此，要在我的机器上执行此命令，确切的命令如下：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The result is the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Wow! The example worked. Let''s now check whether the `httpd` package is installed
    and is now up-and-running on the machine. To check if HTTPd is installed, the
    easiest way is to ask `rpm`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！示例运行成功。现在让我们检查一下`httpd`软件包是否已安装并且现在正在机器上运行。要检查HTTPd是否已安装，最简单的方法是询问`rpm`：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If everything worked properly, you should have an output like the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常工作，你应该有如下输出：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To see the status of the service, we can ask `systemd`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看服务的状态，我们可以询问`systemd`：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The expected result is something like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果如下所示：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The end state, according to the playbook, has been achieved. Let''s briefly
    look at exactly what happens during the playbook run:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 根据playbook，已达到最终状态。让我们简要地看一下playbook运行过程中确切发生了什么：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This line advises us that a playbook is going to start here, and that it will
    be executed on `all` hosts:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此行建议我们将从这里开始执行playbook，并且将在所有主机上执行：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `TASK` lines show the name of the task (`setup`, in this case), and its
    effect on each host. Sometimes, people get confused by the `setup` task. In fact,
    if you look at the playbook, there is no `setup` task. This is because Ansible,
    before executing the tasks that we have asked it to, will try to connect to the
    machine and gather information about it that could be useful later. As you can
    see, the task resulted in a green `ok` state, so it succeeded, and nothing was
    changed on the server:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`TASK` 行显示任务的名称（在本例中为`setup`）以及其对每个主机的影响。有时，人们会对`setup`任务感到困惑。实际上，如果您查看playbook，您会发现没有`setup`任务。这是因为在执行我们要求的任务之前，Ansible会尝试连接到机器并收集有关以后可能有用的信息。正如您所看到的，该任务结果显示为绿色的`ok`状态，因此成功了，并且服务器上没有发生任何更改：'
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These two task''s states are yellow, and spell `changed`. This means that those
    tasks were executed and have succeeded, but they have actually changed something
    on the machine:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个任务的状态是黄色的，并拼写为`changed`。这意味着这些任务已执行并成功，但实际上已更改了机器上的某些内容：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Those last few lines are a recapitulation of how the playbook went. Let''s
    rerun the task now and see the output after both the tasks have actually run:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几行是playbook执行情况的总结。现在让我们重新运行任务，然后查看两个任务实际运行后的输出：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you would have expected, the two tasks in question give an output of `ok`,
    which means that the desired state was already met prior to running the task.
    It's important to remember that many tasks, such as the **gathering facts** task,
    obtain information regarding a particular component of the system and do not necessarily
    change anything on the system; so, these tasks didn't display the changed output
    earlier.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所预期的那样，所涉及的两个任务的输出为`ok`，这意味着在运行任务之前已满足了所需状态。重要的是要记住，许多任务（例如**收集事实**任务）会获取有关系统特定组件的信息，并不一定会更改系统中的任何内容；因此，这些任务之前没有显示更改的输出。
- en: 'The `PLAY RECAP` section in the first and second run are shown as follows.
    You will see the following output during the first run:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次和第二次运行时，`PLAY RECAP`部分显示如下。在第一次运行时，您将看到以下输出：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You will see the following output during the second run:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次运行时，您将看到以下输出：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, the difference is that the first task's output shows `changed=2`,
    which means that the system state changed twice due to two tasks. It's very useful
    to look at this output, since, if a system has achieved its desired state and
    then you run the playbook on it, the expected output should be `changed=0`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，区别在于第一个任务的输出显示`changed=2`，这意味着由于两个任务而更改了系统状态两次。查看此输出非常有用，因为如果系统已达到其所需状态，然后您在其上运行playbook，则预期输出应为`changed=0`。
- en: If you're thinking of the word **idempotency** at this stage, you're absolutely
    right and deserve a pat on the back! Idempotency is one of the key tenets of configuration
    management. Wikipedia defines idempotency as an operation that, if applied twice
    to any value, gives the same result as if it were applied once. The earliest examples
    of this that you would have encountered in your childhood would be multiplicative
    operations on the number `1`, where `1*1=1` every single time.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在这个阶段考虑了**幂等性**这个词，那么您是完全正确的，并且值得表扬！幂等性是配置管理的关键原则之一。维基百科将幂等性定义为一个操作，如果对任何值应用两次，则其结果与仅应用一次时相同。您在童年时期遇到的最早的例子是对数字`1`进行乘法运算，其中`1*1=1`每次都成立。
- en: Most of the configuration management tools have taken this principle and applied
    it to the infrastructure as well. In a large infrastructure, it is highly recommended
    to monitor or track the number of changed tasks in your infrastructure and alert
    the concerned tasks if you find oddities; this applies to any configuration management
    tool in general. In an ideal state, the only time you should see changes is when
    you're introducing a new change in the form of any **Create**, **Remove**, **Update**,
    or **Delete** (**CRUD**) operation on various system components. If you're wondering
    how you can do it with Ansible, keep reading the book and you'll eventually find
    the answer!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数配置管理工具都采用了这个原则，并将其应用于基础架构。在大型基础架构中，强烈建议监视或跟踪基础架构中更改任务的数量，并在发现异常时警告相关任务；这通常适用于任何配置管理工具。在理想状态下，你只应该在引入新的更改时看到更改，比如对各种系统组件进行**创建**、**删除**、**更新**或**删除**（**CRUD**）操作。如果你想知道如何在
    Ansible 中实现它，继续阅读本书，你最终会找到答案的！
- en: 'Let''s proceed. You could have also written the preceding tasks as follows,
    but when the tasks are run from an end user''s perspective, they are quite readable
    (we will call this file `setup_apache_no_com.yaml`):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续。你也可以将前面的任务写成如下形式，但是从最终用户的角度来看，任务非常易读（我们将此文件称为`setup_apache_no_com.yaml`）：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s run the playbook again to spot any difference in the output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行 playbook，以发现输出中的任何差异：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output would be as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, the difference is in the readability. Wherever possible, it''s
    recommended to keep the tasks as simple as possible (the **KISS** principle: **Keep
    It Simple, Stupid**) to allow for the maintainability of your scripts in the long
    run.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，区别在于可读性。在可能的情况下，建议尽可能简化任务（**KISS**原则：**保持简单，笨拙**），以确保长期保持脚本的可维护性。
- en: Now that we've seen how you can write a basic playbook and run it against a
    host, let's look at other options that would help you while running playbooks.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何编写一个基本的 playbook 并对其运行到主机，让我们看看在运行 playbooks 时会帮助你的其他选项。
- en: Ansible verbosity
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 详细程度
- en: One of the first options that anyone picks up is the debug option. To understand
    what is happening when you run the playbook, you can run it with the verbose (`-v`)
    option. Every extra `v` will provide the end user with more debug output.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人首先选择的选项之一是调试选项。为了了解在运行 playbook 时发生了什么，你可以使用详细（`-v`）选项运行它。每个额外的`v`将为最终用户提供更多的调试输出。
- en: 'Let''s see an example of using those options to debug a simple `ping` command
    (`ansible all -i test01.fale.io, -m ping`):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用这些选项调试简单`ping`命令（`ansible all -i test01.fale.io, -m ping`）的示例：
- en: 'The `-v` option provides the default output:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`选项提供了默认输出：'
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `-vv` option adds a little more information about the Ansible environment
    and the handlers:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-vv`选项会提供有关 Ansible 环境和处理程序的更多信息：'
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `-vvv` option adds a lot more information. For instance, it shows the `ssh`
    command that Ansible uses to create a temporary file on the remote host and run
    the script remotely. Full script is available on GitHub.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-vvv`选项提供了更多信息。例如，它显示 Ansible 用于在远程主机上创建临时文件并在远程运行脚本的`ssh`命令。完整脚本可在 GitHub
    上找到。'
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now we understood what is happening when you run the playbook,  with the verbose
    -`vvv` option.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了在运行 playbook 时发生了什么，使用详细`-vvv`选项。
- en: Variables in playbooks
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: playbook 中的变量
- en: Sometimes, it is important to `set` and `get` variables in a playbook.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在 playbook 中设置和获取变量是很重要的。
- en: Very often, you'll need to automate multiple similar operations. In those cases,
    you'll want to create a single playbook that can be called with different variables
    to ensure code reusability.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，你会需要自动化多个类似的操作。在这些情况下，你将想要创建一个可以使用不同变量调用的单个 playbook，以确保代码的可重用性。
- en: 'Another case where variables are very important is when you have more than
    one data center, and some values will be data center-specific. A common example
    are the DNS servers. Let''s analyze the following simple code that will introduce
    us to the Ansible way to set and get variables:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个情况下变量非常重要的案例是当你有多个数据中心时，一些值将是特定于数据中心的。一个常见的例子是 DNS 服务器。让我们分析下面的简单代码，这将向我们介绍设置和获取变量的
    Ansible 方法：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s run it in the usual way:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以通常的方式运行它：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should see the following result:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下结果：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If we analyze the code we have just executed, it should be pretty clear what's
    going on. We set a variable (that in Ansible are called `facts`) and then we print
    it with the `debug` function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分析刚刚执行的代码，应该很清楚发生了什么。我们设置了一个变量（在 Ansible 中称为 `facts`），然后用 `debug` 函数打印它。
- en: Variables should always be between quotes when you use this expanded version
    of YAML.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用这个扩展版本的 YAML 时，变量应该总是用引号括起来。
- en: Ansible allows you to set your variables in many different ways – that is, either
    by passing a variable file, declaring it in a playbook, passing it to the `ansible-playbook`
    command using `-e / --extra-vars`, or by declaring it in an inventory file (we
    will be discussing this in depth in the next chapter).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 允许你以许多不同的方式设置变量 - 也就是说，通过传递一个变量文件，在 playbook 中声明它，使用 `-e / --extra-vars`
    参数将它传递给 `ansible-playbook` 命令，或者在清单文件中声明它（我们将在下一章中深入讨论这一点）。
- en: 'It''s now time to start using some metadata that Ansible obtained during the
    setup phase. Let''s start by looking at the data that is gathered by Ansible.
    To do this, we will execute the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始使用 Ansible 在设置阶段获取的一些元数据了。让我们开始查看 Ansible 收集的数据。为此，我们将执行以下代码：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In our specific case, this means executing the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们特定的情况下，这意味着执行以下代码：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can obviously do the same with a playbook, but this way is faster. Also,
    for the `setup` case, you will only need to see the output during the development
    to be sure to use the right variable name for your goal.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 显然我们也可以用 playbook 来做同样的事情，但这种方式更快。另外，对于 `setup` 情况，你只需要在开发过程中看到输出以确保使用正确的变量名称来达到你的目标。
- en: The output will be something like this. Full code output is available on GitHub.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将会是类似这样的。完整的代码输出可在 GitHub 上找到。
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see from this huge list of options, you can gain a huge quantity
    of information, and you can use them as any other variable. Let''s print the OS
    name and the version. To do so, we can create a new playbook called `setup_variables.yaml`,
    with the following content:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从这个大量选项的列表中所看到的，你可以获得大量的信息，并且你可以像使用任何其他变量一样使用它们。让我们打印操作系统的名称和版本。为此，我们可以创建一个名为
    `setup_variables.yaml` 的新 playbook，内容如下：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Run it with the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码运行它：
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will give us the following output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下输出：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see, it printed the OS name and version as expected. In addition
    to the methods seen previously, it''s also possible to pass a variable using a
    command-line argument. In fact, if we look in the Ansible help, we will notice
    the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它按预期打印了操作系统的名称和版本。除了之前看到的方法之外，还可以使用命令行参数传递变量。实际上，如果我们查看 Ansible 帮助，我们会注意到以下内容：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The same lines are present in the `ansible-playbook` command, as well. Let''s
    make a small playbook called `cli_variables.yaml`, with the following content:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ansible-playbook` 命令中也存在相同的行。让我们创建一个名为 `cli_variables.yaml` 的小 playbook，内容如下：
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Execute it with the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码执行它：
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will receive the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会收到以下内容：
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If we forgot to add the additional parameter to specify the variable, we would
    have executed it as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记添加额外参数来指定变量，我们将会这样执行它：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We would have received the following output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会收到以下输出：
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now that we have learned the basics of playbooks, let's create a web server
    from scratch using them. To do so, let's start from the beginning, creating an
    Ansible user and then moving forward from there.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了 playbook 的基础知识，让我们使用它们从头开始创建一个 Web 服务器。为此，让我们从创建一个 Ansible 用户开始，然后从那里继续。
- en: As you will notice in the previous example, a **WARNING** popped up, informing
    us that we were re-declaring a reserved variable (name). The full list of reserved
    variables (as of Ansible 2.7) are as follows: `add`, `append`, `as_integer_ratio`,
    `bit_length`, `capitalize`, `center`, `clear`, `conjugate`, `copy`, `count`, `decode`,
    `denominator`, `difference`, `difference_update`, `discard`, `encode`, `endswith`,
    `expandtabs`, `extend`, `find`, `format`, `fromhex`, `fromkeys`, `get`, `has_key`,
    `hex`, `imag`, `index`, `insert`, `intersection`, `intersection_update`, `isalnum`,
    `isalpha`, `isdecimal`, `isdigit`, `isdisjoint`, `is_integer`, `islower`, `isnumeric`,
    `isspace`, `issubset`, `issuperset`, `istitle`, `isupper`, `items`, `iteritems`,
    `iterkeys`, `itervalues`, `join`, `keys`, `ljust`, `lower`, `lstrip`, `numerator`,
    `partition`, `pop`, `popitem`, `real`, `remove`, `replace`, `reverse`, `rfind`,
    `rindex`, `rjust`, `rpartition`, `rsplit`, `rstrip`, `setdefault`, `sort`, `split`,
    `splitlines`, `startswith`, `strip`, `swapcase`, `symmetric_difference`, `symmetric_difference_update`,
    `title`, `translate`, `union`, `update`, `upper`, `values`, `viewitems`, `viewkeys`,
    `viewvalues`, `zfill`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们注意到一个**警告**弹出，通知我们正在重新声明一个保留变量（name）。截至 Ansible 2.7，完整的保留变量列表如下：`add`、`append`、`as_integer_ratio`、`bit_length`、`capitalize`、`center`、`clear`、`conjugate`、`copy`、`count`、`decode`、`denominator`、`difference`、`difference_update`、`discard`、`encode`、`endswith`、`expandtabs`、`extend`、`find`、`format`、`fromhex`、`fromkeys`、`get`、`has_key`、`hex`、`imag`、`index`、`insert`、`intersection`、`intersection_update`、`isalnum`、`isalpha`、`isdecimal`、`isdigit`、`isdisjoint`、`is_integer`、`islower`、`isnumeric`、`isspace`、`issubset`、`issuperset`、`istitle`、`isupper`、`items`、`iteritems`、`iterkeys`、`itervalues`、`join`、`keys`、`ljust`、`lower`、`lstrip`、`numerator`、`partition`、`pop`、`popitem`、`real`、`remove`、`replace`、`reverse`、`rfind`、`rindex`、`rjust`、`rpartition`、`rsplit`、`rstrip`、`setdefault`、`sort`、`split`、`splitlines`、`startswith`、`strip`、`swapcase`、`symmetric_difference`、`symmetric_difference_update`、`title`、`translate`、`union`、`update`、`upper`、`values`、`viewitems`、`viewkeys`、`viewvalues`、`zfill`。
- en: Creating the Ansible user
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Ansible 用户
- en: 'When you create a machine (or rent one from any hosting company), it arrives
    with only the `root` user, or other users such as `vagrant`. Let''s start creating
    a playbook that ensures that an Ansible user is created, it''s accessible with
    an SSH key, and is able to perform actions on behalf of other users (`sudo`) with
    no password required. We often call this playbook `firstrun.yaml`, since we execute
    it as soon as a new machine is created, but after that, we don''t use it, since
    we disable the default user for security reasons. Our script will look something
    like the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一台机器（或从任何托管公司租用一台机器）时，它只带有`root`用户，或其他用户，如`vagrant`。让我们开始创建一个 Playbook，确保创建一个
    Ansible 用户，可以使用 SSH 密钥访问它，并且能够代表其他用户（`sudo`）执行操作而无需密码。我们经常将此 Playbook 称为 `firstrun.yaml`，因为我们在创建新机器后立即执行它，但之后我们不再使用它，因为出于安全原因，我们会禁用默认用户。我们的脚本将类似于以下内容：
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Before running it, let's look at it a little bit. We have used three different
    modules (`user`, `authorized_key`, and `lineinfile`) that we have never seen.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行之前，让我们稍微看一下。我们使用了三个不同的模块（`user`、`authorized_key` 和 `lineinfile`），这些我们从未见过。
- en: The `user` module, as the name suggests, allows us to make sure a user is present
    (or absent).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`user` 模块，正如其名称所示，允许我们确保用户存在（或不存在）。'
- en: The `authorized_key` module allows us to ensure that a certain SSH key can be
    used to log in as a specific user on that machine. This module will not substitute
    all the SSH keys that are already enabled for that user, but will simply add (or
    remove) the specified key. If you want to alter this behavior, you can use the
    `exclusive` option, which allows you to delete all the SSH keys that are not specified
    in this step.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`authorized_key` 模块允许我们确保某个 SSH 密钥可以用于登录到该机器上的特定用户。此模块不会替换已为该用户启用的所有 SSH 密钥，而只会添加（或删除）指定的密钥。如果您想改变此行为，可以使用
    `exclusive` 选项，它允许您删除在此步骤中未指定的所有 SSH 密钥。'
- en: The `lineinfile` module allows us to alter the content of a file. It works in
    a very similar way to **sed** (a stream editor), where you specify the regular
    expression that will be used to match the line, and then specify the new line
    that will be used to substitute the matched line. If no line is matched, the line
    is added at the end of the file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`lineinfile` 模块允许我们修改文件的内容。它的工作方式与**sed**（流编辑器）非常相似，您指定用于匹配行的正则表达式，然后指定要用于替换匹配行的新行。如果没有匹配的行，则该行将添加到文件的末尾。'
- en: 'Now let''s run it with the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用以下代码运行它：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will give us the following result:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们带来以下结果：
- en: '[PRE50]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Configuring a basic server
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置基本服务器
- en: After we have created the user for Ansible with the necessary privileges, we
    can go on to make some other small changes to the OS. To make it clearer, we will
    see how each action is performed, and then we'll look at the whole playbook.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 Ansible 创建了具有必要权限的用户之后，我们可以继续对操作系统进行一些其他小的更改。为了更清晰，我们将看到每个动作是如何执行的，然后我们将查看整个
    playbook。
- en: Enabling EPEL
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用 EPEL
- en: '**EPEL** is the most important repository for Enterprise Linux and it contains
    a lot of additional packages. It''s also a safe repository, since no package in
    EPEL will conflict with packages in the base repository.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**EPEL** 是企业 Linux 中最重要的仓库，它包含许多附加软件包。它也是一个安全的仓库，因为 EPEL 中的任何软件包都不会与基本仓库中的软件包发生冲突。'
- en: 'To enable EPEL in RHEL/CentOS 7, it is enough to just install the `epel-release`
    package. To do so in Ansible, we will use the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 RHEL/CentOS 7 中启用 EPEL，只需安装 `epel-release` 软件包即可。要在 Ansible 中执行此操作，我们将使用以下内容：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see, we have used the `yum` module, as we did in one of the first
    examples of the chapter, specifying the name of the package and that we want it
    to be present.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了 `yum` 模块，就像我们在本章的第一个示例中所做的那样，指定了软件包的名称以及我们希望它存在。
- en: Installing Python bindings for SELinux
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 SELinux 的 Python 绑定
- en: 'Since Ansible is written in Python, and mainly uses the Python bindings to
    operate on the operating system, we will need to install the Python bindings for
    SELinux:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Ansible 是用 Python 编写的，并且主要使用 Python 绑定来操作操作系统，因此我们需要安装 SELinux 的 Python 绑定：
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This could be written in a shorter way, using a cycle, but we'll see how to
    do this in the next chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用更短的方式编写，使用循环，但我们将在下一章中看到如何做到这一点。
- en: Upgrading all installed packages
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级所有已安装的软件包
- en: 'To upgrade all installed packages, we will need to use the `yum` module again,
    but with a different parameter; in fact, we would use the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要升级所有已安装的软件包，我们将需要再次使用 `yum` 模块，但是使用不同的参数；实际上，我们将使用以下内容：
- en: '[PRE53]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see, we have specified `*` as the package name (this stands for a
    wildcard to match all installed packages) and the `state` parameter is `latest`.
    This will upgrade all installed packages to the latest version available.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已将 `*` 指定为软件包名称（这代表了一个通配符，用于匹配所有已安装的软件包），并且 `state` 参数为 `latest`。这将会将所有已安装的软件包升级到可用的最新版本。
- en: You may remember that, when we talked about the `present` state, we said that
    it was going to install the last available version. So, what's the difference
    between `present` and `latest`? `present` will install the latest version if the
    package is not installed, while if the package is already installed (no matter
    the version), it will go forward without making any change. `latest` will install
    the latest version if the package is not installed, and if the package is already
    installed, it will check whether a newer version is available, and, if it is,
    Ansible will update the package.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得，当我们谈到 `present` 状态时，我们说它将安装最新可用版本。那么 `present` 和 `latest` 之间有什么区别？`present`
    将在未安装软件包时安装最新版本，而如果软件包已安装（无论版本如何），它将继续前进而不进行任何更改。`latest` 将在未安装软件包时安装最新版本，并且如果软件包已安装，它将检查是否有更新版本可用，如果有，则
    Ansible 将更新软件包。
- en: Ensuring that NTP is installed, configured, and running
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保 NTP 已安装、配置并运行
- en: 'To make sure NTP is present, we use the `yum` module:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要确保 NTP 存在，我们使用 `yum` 模块：
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now that we know that NTP is installed, we should ensure that the server is
    using the `timezone` that we want. To do so, we will create a symbolic link in
    `/etc/localtime` that will point to the wanted `zoneinfo` file:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道 NTP 已安装，我们应该确保服务器使用我们想要的 `timezone`。为此，我们将在 `/etc/localtime` 中创建一个符号链接，该链接将指向所需的
    `zoneinfo` 文件：
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As you can see, we have used the `file` module, specifying that it needs to
    be a link (`state: link`).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所见，我们使用了 `file` 模块，指定它需要是一个链接（`state: link`）。'
- en: 'To complete the NTP configuration, we need to start the `ntpd` service and
    ensure that it will run at every consequent boot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成 NTP 配置，我们需要启动 `ntpd` 服务，并确保它将在每次后续引导时运行：
- en: '[PRE56]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Ensuring that FirewallD is present and enabled
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保 FirewallD 存在并已启用
- en: 'As you can imagine, the first step is to ensure that FirewallD is installed:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以想象，第一步是确保 FirewallD 已安装：
- en: '[PRE57]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Since we want to be sure that we will not lose our SSH connection when we enable
    FirewallD, we will ensure that SSH traffic can always pass through it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在启用 FirewallD 时不会丢失 SSH 连接，因此我们将确保 SSH 流量始终可以通过它传递：
- en: '[PRE58]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To do so, we have used the `firewalld` module. This module will take parameters
    that are very similar to the ones the `firewall-cmd` console would use. You will
    have to specify the service that is to be authorized to pass the firewall, whether
    you want this rule to apply immediately or not, and whether or not you want the
    rule to be permanent, so that after a reboot the rule will still be present.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们使用了`firewalld`模块。此模块将采用与`firewall-cmd`控制台非常相似的参数。您将需要指定要通过防火墙的服务，是否要立即应用此规则以及是否要将规则设置为永久性规则，以便在重新启动后规则仍然存在。
- en: You can specify the service name (such as `ssh`) using the `service` parameter,
    or you can specify the port (such as `22/tcp`) using the `port` parameter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`service`参数指定服务名称（如`ssh`），也可以使用`port`参数指定端口（如`22/tcp`）。
- en: 'Now that we have installed FirewallD and we are sure that our SSH connection
    will survive, we can enable it as we do any other service:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了FirewallD，并且确保我们的SSH连接将存活，我们可以像对待其他任何服务一样启用它：
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Adding a customized MOTD
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自定义MOTD。
- en: To add the MOTD, we will need a template that will be the same for all servers,
    and a task to use the template.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加MOTD，我们将需要一个模板，该模板将对所有服务器都相同，并且一个任务来使用该模板。
- en: 'I find it very useful to add a MOTD to every server. It''s even more useful
    if you use Ansible, because you can use it to warn your users that changes to
    the system could be overwritten by Ansible. My usual template is called `motd`,
    and has this content:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现为每个服务器添加MOTD非常有用。如果你使用Ansible，那就更有用了，因为你可以用它来警告用户系统的更改可能会被Ansible覆盖。我通常的模板叫做`motd`，内容如下：
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is a `jinja2` template, and it allows us to use every variable set in
    the playbooks. This also allows us to use complex syntax for conditionals and
    cycles that we will see later in this chapter. To populate a file from a template
    in Ansible, we will need to use the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`jinja2`模板，它允许我们使用在playbooks中设置的每个变量。这也允许我们使用后面将在本章中看到的复杂的条件和循环语法。为了从Ansible中的模板填充文件，我们将需要使用以下命令：
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `template` module allows us to specify a local file (`src`) that will be
    interpreted by `jinja2`, and the output of this operation will be saved on the
    remote machine in a specific path (`dest`), will be owned by a specific user (`owner`)
    and group (`group`), and will have a specific access mode (`mode`).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`template`模块允许我们指定一个本地文件（`src`），该文件将被`jinja2`解释，并且此操作的输出将保存在远程机器上的特定路径（`dest`）中，将由特定用户（`owner`）和组（`group`）拥有，并且将具有特定的访问模式（`mode`）。'
- en: Changing the hostname
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改主机名。
- en: 'To keep things simple, I find it useful to set the hostname of a machine to
    something meaningful. To do so, we can use a very simple Ansible module called
    `hostname`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我发现将机器的主机名设置为有意义的内容很有用。为此，我们可以使用一个非常简单的Ansible模块叫做`hostname`：
- en: '[PRE62]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Reviewing and running the playbook
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复审并运行playbook。
- en: 'Putting everything together, we now have the following playbook (called `common_tasks.yaml`
    for simplicity):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 把所有事情都放在一起，我们现在有了以下playbook（为简单起见称为`common_tasks.yaml`）：
- en: '[PRE63]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Since this `playbook` is pretty complex, we can run the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个`playbook`相当复杂，我们可以运行以下命令：
- en: '[PRE64]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This asks Ansible to print all the tasks in a shorter form so that we can quickly
    see what tasks a `playbook` performs. The output should be something like the
    following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求Ansible以更简洁的形式打印所有任务，以便我们可以快速查看`playbook`执行的任务。输出应该类似于以下内容：
- en: '[PRE65]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can now run the `playbook` with the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下命令运行`playbook`：
- en: '[PRE66]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We will receive the following output. Full code output is available on GitHub.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到以下输出。完整的代码输出可在GitHub上找到。
- en: '[PRE67]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Installing and configuring a web server
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置web服务器。
- en: Now that we have made some generic changes to the operating system, let's move
    on to actually creating a web server. We are splitting those two phases so that
    we can share the first phase between every machine and apply the second only to
    web servers.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对操作系统进行了一些通用更改，让我们继续实际创建web服务器。我们将这两个阶段拆分开来，以便我们可以在每台机器之间共享第一个阶段，并仅将第二个应用于Web服务器。
- en: 'For this second phase, we will create a new playbook called `webserver.yaml`
    with the following content:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个第二阶段，我们将创建一个名为`webserver.yaml`的新playbook，内容如下：
- en: '[PRE68]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As you can see, the first two tasks are the same as the ones in the example
    at the beginning of this chapter, and the last two tasks are used to instruct
    FirewallD to let the `HTTP` and `HTTPS` traffic pass.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，前两个任务与本章开头示例中的任务相同，最后两个任务用于指示FirewallD允许`HTTP`和`HTTPS`流量通过。
- en: 'Let''s run this script with the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This results in the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now that we have a web server, let's publish a small, single-page, static website.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Publishing a website
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since our website will be a simple, single-page website, we can easily create
    it and publish it using a single Ansible task. To make this page a little bit
    more interesting, we will create it from a template that will be populated by
    Ansible with a little data about the machine. The script to publish it will be
    called `deploy_website.yaml`, and will have the following content:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let''s start with a simple template that we will call `index.html.j2`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, we can test our website deployment by running the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We should receive the following output:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If you now go to your IP/FQDN test machine in your browser, you'll find the
    **Hello World!** page.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Jinja2 templates
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Jinja2** is a widely-used and fully-featured template engine for Python.
    Let''s look at some syntax that will help us with Ansible. This paragraph is not
    a replacement for the official documentation, but its goal is to teach you some
    components that you''ll find very useful when using with Ansible.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, we can print variable content simply by using the `{{ VARIABLE_NAME
    }}` syntax. If we want to print just an element of an array, we can use `{{ ARRAY_NAME['KEY']
    }}`, and if we want to print a property of an object, we can use `{{ OBJECT_NAME.PROPERTY_NAME
    }}`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can improve our previous static page in the following way:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Filters
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From time to time, we may want to change the style of a string a little bit,
    without writing specific code for it; for example, we may want to capitalize some
    text. To do so, we can use one of Jinja2's filters, such as `{{ VARIABLE_NAME
    | capitalize }}`. There are many filters available for Jinja2, and you can find
    the full list at [http://jinja.pocoo.org/docs/dev/templates/#builtin-filters](http://jinja.pocoo.org/docs/dev/templates/#builtin-filters).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One thing you may often find useful in a template engine is the possibility
    of printing different strings depending on the content (or existence) of a string.
    So, we can improve our static web page in the following way:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: As you can see, we have added the capability to print the main IPv4 address
    for the `eth0` connection, if the connection is `active`. With conditionals, we
    can also use the tests.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: For a full list of builtin tests, please refer to [http://jinja.pocoo.org/docs/dev/templates/#builtin-tests](http://jinja.pocoo.org/docs/dev/templates/#builtin-tests).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to obtain the same result, we could also have written the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: There are a lot of different tests that will really help you to create easy-to-read,
    effective templates.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Cycles
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `jinja2` template system also offers the capability to create cycles. Let''s
    add a feature to our page that will print the main IPv4 network address for each
    device, instead of only `eth0`. We will then have the following code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As you can see, the syntax for cycles is familiar if you already know Python.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，如果您已经了解Python的语法，那么对于循环语句的语法是熟悉的。
- en: These few pages on Jinja2 templating were not a substitute for the official
    documentation. In fact, Jinja2 templates are much more powerful than what we have
    seen here. The goal here is to give you the basic Jinja2 templates that are most
    often used in Ansible.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这几页关于Jinja2模板化编程的内容并不能替代官方文档。实际上，Jinja2模板比我们在这里看到的要更强大。这里的目标是为您提供最常用于Ansible的基本Jinja2模板。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started looking at YAML, and saw what a playbook is, how
    it works, and how to use it to create a web server (and a deployment for your
    static website). We have also seen multiple Ansible modules, such as the `user`,
    `yum`, `service`, FirewalID, lineinfile, and template modules. At the end of the
    chapter, we focused on templates.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始学习YAML，并了解了playbook是什么，它如何工作以及如何使用它来创建Web服务器（和静态网站的部署）。我们还看到了多个Ansible模块，例如`user`、`yum`、`service`、`FirewalID`、`lineinfile`和`template`模块。在章节的最后，我们重点关注了模板。
- en: In the next chapter, we will talk about inventories, so that we can easily manage
    multiple machines.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论库存，以便我们可以轻松地管理多台机器。
