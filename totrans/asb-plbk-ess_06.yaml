- en: Chapter 5. Controlling Execution Flow – Conditionals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Control structures refer to anything and everything that have an effect on
    a program''s execution flow. Control structures are mainly of the following two
    types:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Conditional
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterative
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At times, we need to execute code conditionally based on a value of a variable,
    type of platform, or even a result of some other command. There are times when
    we also need to iterate multiple objects, such as list hashes or multilevel variables.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages and tools use powerful but machine-friendly constructs,
    such as `if else`, `for`, `unless`, `do while`, and so on. However, Ansible stays
    true to its design tenet of being a human-friendly automation language and manages
    to achieve the same with the omnipotent `when` and `with_*` constructs, which
    are closer to the English language. Let's begin to explore how it does so.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Using conditional controls with the `when` statements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using variables and facts to skip subroutines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying roles selectively
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conditional control structures in Jinja2 templates
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conditional control structure
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conditional control structures allow Ansible to follow an alternate path, skip
    a task, or select a specific file to import based on certain conditions. In a
    generic programming language, this is done with the help of `if-then`, `else if`,
    `else`, `case` statements. Ansible does this using the "`when`" statement. Some
    example conditions are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Whether a certain variable is defined
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether an earlier command sequence is successful
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the task has run before
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether a platform on a target node matches the supported platforms
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether a certain file exists
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The when statements
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already used the `when` statement to extract the WordPress archive
    based on the result of another command, which is:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This would be vaguely equivalent to writing a shell snippet, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In addition to checking the preceding code, we could simply write conditions
    based on the result of the task itself, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For the failed statement to work, we need to add the `ignore_errors: True`
    statement to the earlier task that registers the variable. The following flowchart
    depicts the same logic:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![The when statements](img/B03800_05_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: Fact-based selection
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Facts are a good source of information to detect platform-specific information
    and make a choice based on it, especially when you have hybrid environments. Based
    on this selection, we could:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Decide whether to execute a task
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide whether to include a task file
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide whether to import a file
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide whether to apply a role on the target node
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have already used fact-based selection while writing MySQL, where we used
    the fact `ansible_os_family` to:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Import the `vars` file for non-Debian-based systems.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include platform-specific tasks for package installation.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippet shows both the use cases:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![Fact-based selection](img/B03800_05_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: Refactoring the MySQL role
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our existing MySQL role installs and configures only the server. More often
    than not, all we need to do is just install the MySQL client package and not the
    server. We don't have the ability to selectively do so.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The scenario:**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: We have been tasked to refactor the MySQL role and make it conditionally install
    the MySQL server based on a variable value. By default, it should just install
    MySQL client packages.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Boolean variables could be useful to set up an an on/off switch. We will add
    a variable and set its default value to `false`. This time, we will create a multilevel
    variable or a nested hash.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Multilevel variable dictionaries
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have been naming variables as `mysql_bind`, `mysql_port`, and so
    on and using an underscore to categorize them. Variables can instead be better
    categorized and organized if you define them with multiple-level dictionaries,
    for example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Multilevel variables can then be accessed inside the code as `mysql[''config][''bind'']`
    or `mysql[''config][''port'']`. Let''s now update the `roles/mysql/defaults/main.yml`
    file to use multilevel variables and also create a new Boolean variable `mysql.server`,
    which acts as a flag:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![Multilevel variable dictionaries](img/B03800_05_03.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: Additionally, we would have to update files in the `vars` directory in the `mysql`
    role to define the variables with a new style, all tasks, handlers, and templates
    to reference them appropriately. This process is added as part of the text to
    avoid redundancy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Merging hashes
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multilevel variables or, in essence, dictionaries defined from different locations
    may need to be merged. For example, if we define default configuration parameters
    in the role `default` and then override a few from the `vars` directory in the
    role, the resultant variable `hash` should contain items from the **defaults**
    plus overridden values from **vars**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![Merging hashes](img/B03800_05_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'However, by default, Ansible will replace the dictionary, and in the preceding
    example, instead of getting a merged dictionary, we would lose the user and port
    `vars` as `vars` in the role has higher precedence. This can be avoided by setting
    the `hash_behavior` parameter to `merge` instead of `replace`, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This should be set on the Ansible control host and does not require us to restart
    any service.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the MySQL server selectively
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After refactoring the code and adding a flag controlled by a variable, we are
    ready to selectively configure the MySQL server. We have the `mysql.server` variable,
    which takes the Boolean value of `True`/`False`. This variable could be used to
    decide whether to skip server configurations, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s also add tasks to install the MySQL client package as well as the Python
    bindings required by Ansible''s MySQL module:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, the package names come from the following variable `hash`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By default, the `mysql.server` parameter has been set to `False`. How do we
    enable this only for the database servers? There are plenty of ways we can do
    so. We would choose playbook variables this time, since we have one dedicated
    to DB servers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the MySQL server selectively](img/B03800_05_05.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: Conditional control structure in Jinja2 templates
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible uses Jinja2 as a template engine. Hence, it would be useful for us
    to understand Jinja2 control structures in addition to the ones supported by Ansible
    tasks. Jinja2''s syntax encloses the control structures inside the `{% %}` blocks.
    For conditional control, Jinja2 uses the familiar `if` statements, which have
    the following syntax:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Updating the MySQL template
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The template that we created earlier to generate the `my.cnf` file assumes
    that all the variables referred in it are defined somewhere. There is a chance
    that this is not always the case, which could result in errors while running Ansible.
    Could we selectively include configuration parameters in the `my.cnf` file? The
    answer is yes. We could check whether a variable is defined and only then, we
    will add it to the file, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s analyze the preceding code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Since we are setting the default value for the `mysql['config']['user']` parameter,
    there is no need to check whether it's defined. It's already handled gracefully.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all other parameters, we check whether the variable is defined using a condition,
    such as `if mysql.config.pid is defined`. This would skip the parameter if it's
    not defined rather than throwing an error.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a task only once
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At times, a specific task in a role may need to be executed only once during
    a playbook execution, even though the role is applied to many hosts. This could
    be achieved with the `run_once` conditional:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since we are using the `run_once` option, the preceding task would run on the
    first host in the inventory that the role is being applied to. All consequent
    hosts would skip this task.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Executing roles conditionally
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Nginx role that we created earlier to set up web server supports only Debian-based
    systems. Running this logic on other systems could lead to failure. For example,
    the Nginx role uses the `apt` module to install packages, which would not work
    on RedHat-based systems, which depend on the `yum` package manager. This could
    be avoided by adding the `when` statement with a fact to selectively execute based
    on an OS family. The following is the snippet from the `www.yml` playbook:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Review questions
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you think you''ve understood the chapter well enough? Try answering the
    following questions to test your understanding:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: What is the replacement for the `if else` statements in Ansible?
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you selectively import platform-specific variables?
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do Jinja2 templates use `__` and `__` to delimit control structures?
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you skip running roles on incompatible platforms?
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learnt about how to control execution flow using the `when`
    statements, conditional imports, selective includes, and so on. You also learnt
    how to use variables and facts to selectively skip routines and execute platform-specific
    subroutines. We refactored the MySQL role to start using dictionaries of variables
    to conditionally configure the MySQL server and to use more intelligent templates
    with prechecks for defined variables.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用`when`语句、条件导入、选择性包含等来控制执行流程。你还学会了如何使用变量和事实来有选择地跳过例程并执行特定于平台的子例程。我们对MySQL角色进行了重构，开始使用变量字典有条件地配置MySQL服务器，并使用更智能的模板来预检已定义的变量。
- en: In the next chapter, we will begin exploring the second type of control structures,
    that is. iterative control structures, where we will start looping arrays and
    hashes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始探索第二种控制结构，即迭代控制结构，我们将开始循环数组和哈希。
