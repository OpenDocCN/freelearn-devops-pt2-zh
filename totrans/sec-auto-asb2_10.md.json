["```\nfrom ansible.module_utils.basic import AnsibleModule\n\nmodule = AnsibleModule(\n    argument_spec=dict(\n        answer=dict(choices=['yes', 'no'], default='yes'),\n    )\n)\n\nanswer = module.params['answer']\nif answer == 'no':\n    module.fail_json(changed=True, msg='Failure! We failed because we answered no.')\n\nmodule.exit_json(changed=True, msg='Success! We passed because we answered yes.')\n```", "```\n$ ANSIBLE_LIBRARY=. ansible -m ansible_module_hello_world.py -a answer=yes localhost\n\n [WARNING]: provided hosts list is empty, only localhost is available\n\nlocalhost | SUCCESS => {\n    \"changed\": true,\n    \"msg\": \"Success! We passed because we answered yes.\"\n}\n```", "```\n$ ANSIBLE_LIBRARY=. ansible -m ansible_module_hello_world -a answer=no localhost\n\n [WARNING]: provided hosts list is empty, only localhost is available\n\nlocalhost | FAILED! => {\n    \"changed\": true,\n    \"failed\": true,\n    \"msg\": \"Failure! We failed because we answered no.\"\n}\n```", "```\n- name: Setting Developer Environment\n  hosts: dev\n  remote_user: madhu\n  become: yes\n  vars:\n    ansible_code_path: \"/home/madhu/ansible-code\"\n\n  tasks:\n    - name: installing prerequirements if not installed\n      apt:\n        name: \"{{ item }}\"\n        state: present\n        update_cache: yes\n\n      with_items:\n        - git\n        - virtualenv\n        - python-pip\n\n    - name: downloading ansible repo locally\n      git:\n        repo: https://github.com/ansible/ansible.git\n        dest: \"{{ ansible_code_path }}/venv\"\n\n    - name: creating virtual environment\n      pip:\n        virtualenv: \"{{ ansible_code_path }}\"\n        virtualenv_command: virtualenv\n        requirements: \"{{ ansible_code_path }}/venv/requirements.txt\"\n```", "```\n$ docker run -u zap -p 8080:8080 -i owasp/zap2docker-stable zap.sh -daemon -host 0.0.0.0 -port 8080 -config api.disablekey=true -config api.addrs.addr.name=.* -config api.addrs.addr.regex=true\n```", "```\nANSIBLE_METADATA = {\n    'metadata_version': '1.1',\n    'status': ['preview'],\n    'supported_by': 'community'\n}\n```", "```\nfrom ansible.module_utils.basic import AnsibleModule\n```", "```\ndef run_module():\n    # define the available arguments/parameters that a user can pass to\n    # the module\n    module_args = dict(\n        name=dict(type='str', required=True),\n        new=dict(type='bool', required=False, default=False)\n    )\n\n    # seed the result dict in the object\n    # we primarily care about changed and state\n    # change is if this module effectively modified the target\n    # state will include any data that you want your module to pass back\n    # for consumption, for example, in a subsequent task\n    result = dict(\n        changed=False,\n        original_message='',\n        message=''\n    )\n\n    # the AnsibleModule object will be our abstraction working with Ansible\n    # this includes instantiation, a couple of common attr would be the\n    # args/params passed to the execution, as well as if the module\n    # supports check mode\n    module = AnsibleModule(\n        argument_spec=module_args,\n        supports_check_mode=True\n    )\n```", "```\n # during the execution of the module, if there is an exception or a\n    # conditional state that effectively causes a failure, run\n    # AnsibleModule.fail_json() to pass in the message and the result\n    if module.params['name'] == 'fail me':\n        module.fail_json(msg='You requested this to fail', **result)\n\n    # in the event of a successful module execution, you will want to\n    # simple AnsibleModule.exit_json(), passing the key/value results\n    module.exit_json(**result)\n```", "```\ndef main():\n    run_module()\n\nif __name__ == '__main__':\n    main()\n```", "```\nfrom zapv2 import ZAPv2\n```", "```\nzap = ZAPv2(apikey=apikey, proxies={'http': 'http://127.0.0.1:8090', 'https': 'http://127.0.0.1:8090'})\n```", "```\nzap.urlopen(target)\n# Give the sites tree a chance to get updated\ntime.sleep(2)\n\nprint 'Spidering target %s' % target\nscanid = zap.spider.scan(target)\n\n# Give the Spider a chance to start\ntime.sleep(2)\nwhile (int(zap.spider.status(scanid)) < 100):\n    print 'Spider progress %: ' + zap.spider.status(scanid)\n    time.sleep(2)\n\nprint 'Spider completed'\n# Give the passive scanner a chance to finish\ntime.sleep(5)\n\nprint 'Scanning target %s' % target\nscanid = zap.ascan.scan(target)\nwhile (int(zap.ascan.status(scanid)) < 100):\n    print 'Scan progress %: ' + zap.ascan.status(scanid)\n    time.sleep(5)\n\nprint 'Scan completed'\n\n# Report the results\n\nprint 'Hosts: ' + ', '.join(zap.core.hosts)\nprint 'Alerts: '\npprint (zap.core.alerts())\n```", "```\ntry: \n    from zapv2 import ZAPv2\n    HAS_ZAPv2 = True\nexcept ImportError:\n    HAS_ZAPv2 = False \n\nfrom ansible.module_utils.basic import AnsibleModule\nimport time\ndef run_module():\n    module_args = dict(\n        host=dict(type='str', required=True),\n        target=dict(type='str', required=True)\n    )\n\n    result = dict(\n        changed=False,\n        original_message='',\n        message=''\n    )\n\n    module = AnsibleModule(\n        argument_spec=module_args,\n        supports_check_mode=True\n    )\n\n    if not HAS_ZAPv2:\n        module.fail_json(msg = 'OWASP python-owasp-zap-v2.4 required. pip install python-owasp-zap-v2.4')\n\nif module.check_mode:\n    return result\nhost = module.params['host']\ntarget = module.params['target']\napikey = None\nzap = ZAPv2(apikey=apikey, proxies={'http':host,'https':host})\nzap.urlopen(target)\ntry:\n    scanid = zap.spider.scan(target)\n    time.sleep(2)\n    while (int(zap.spider.status(scanid)) < 100):\n        time.sleep(2)\nexcept:\n    module.fail_json(msg='Spidering failed')\ntime.sleep(5)\n\ntry:\n    scanid = zap.ascan.scan(target)\n    while (int(zap.ascan.status(scanid)) < 100):\n        time.sleep(5)\nexcept:\n    module.fail_json(msg='Scanning failed')\n\nresult['output'] = zap.core.alerts()\nresult['target'] = module.params['target']\nresult['host'] = module.params['host']\nmodule.exit_json(**result)\n\ndef main():\n    run_module()\nif __name__ == '__main__':\n    main()\n```", "```\nansible -m owasp_zap_test_module localhost -a \"host=http://172.16.1.102:8080 target=http://testphp.vulnweb.com\" -vvv\n```", "```\n- name: Testing OWASP ZAP Test Module\n  connection: local\n  hosts: localhost\n  tasks:\n  - name: Scan a website\n    owasp_zap_test_module:\n      host: \"http://172.16.1.102:8080\"\n      target: \"http://testphp.vulnweb.com\"\n```", "```\nansible-playbook owasp-zap-site-scan-module-playbook.yml\n```", "```\nmodule_args = dict(\n    host=dict(type='str', required=True),\n    target=dict(type='str', required=True),\n    apikey=dict(type='str',required=False,default=None),\n    scantype=dict(default='passive', choices=['passive','active'])\n)\n```", "```\nscantype = module.params['scantype']\n```", "```\nif scantype == 'active':\n    try:\n        scanid = zap.ascan.scan(target)\n        while (int(zap.ascan.status(scanid)) < 100):\n            time.sleep(5)\n    except:\n        module.fail_json(msg='Active Scan Failed')\nelse:\n    try:\n        while (int(zap.pscan.records_to_scan) > 0):\n            time.sleep(2)\n    except:\n        module.fail_json(msg='Passive Scan Failed')\n```", "```\nUsing the new and improved module in our playbook\n- name: Testing OWASP ZAP Test Module\n  connection: local\n  hosts: localhost\n  tasks:\n  - name: Scan a website\n    owasp_zap_test_module:\n      host: \"http://172.16.1.102:8080\"\n      target: \"http://testphp.vulnweb.com\"\n      scantype: passive\n    register: output\n  - name: Print version\n    debug:\n      msg: \"Scan Report: {{ output }}\"\n```", "```\nimport json\nfrom collections import namedtuple\nfrom ansible.parsing.dataloader import DataLoader\nfrom ansible.vars.manager import VariableManager\nfrom ansible.inventory.manager import InventoryManager\nfrom ansible.playbook.play import Play\nfrom ansible.executor.task_queue_manager import TaskQueueManager\nfrom ansible.plugins.callback import CallbackBase\n```", "```\ntry</span>:\n    tqm = TaskQueueManager(\n              inventory=inventory,\n              variable_manager=variable_manager,\n              loader=loader,\n              options=options,\n              passwords=passwords,\n              stdout_callback=results_callback,  # Use our custom callback instead of the ``default`` callback plugin\n          )\n    result = tqm.run(play)\n```", "```\nimport ansible.runner\n\nrunner = ansible.runner.Runner(\n   module_name='ping',\n   module_args='',\n   pattern='web*',\n   forks=10\n)\ndatastructure = runner.run()\n```"]