- en: Creating a Custom Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus on how to write and test custom modules. We've already
    discussed how modules work and how to use them within your tasks. To quickly recap,
    a module in Ansible is a piece of code that is transferred and executed onto your
    remote host every time you run an Ansible task (it can also run locally if you've
    used `local_action`).
  prefs: []
  type: TYPE_NORMAL
- en: From my experience, I've seen custom modules being written whenever a certain
    functionality needs to be exposed as a first-class task. The same functionality
    can be achieved without the module, but it will require a series of tasks with
    existing modules to accomplish the end goal (and sometimes, command and shell
    modules too). For example, let's say that you want to provision a server through **Preboot
    Execution Environment** (**PXE**). Without a custom module, you would probably
    use a few shell or command tasks to accomplish this. However, with a custom module,
    you can just pass the required parameters to it and the business logic will be
    embedded within the custom module in order to perform the PXE boot. This gives
    you the ability to write playbooks that are much simpler to read, and gives your
    code better reusability, since you create the module once and can use it everywhere
    in your roles and playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments that you pass to a module, provided they are in a **key-value**
    format, will be forwarded in a separate file along with the module. Ansible expects
    at least two variables in your module output (that is, the result of the module
    running), whether it passed or failed, and a message for the user – and they both
    have to be in JSON format. If you adhere to this simple rule, you can customize
    your module as much as you want!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Python modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bash modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you choose a particular technology or tool, you generally start with what
    it offers. You slowly understand the philosophy then went into building the tool
    and what problems it helps you solve. However, you only truly feel comfortable
    and in control when you understand how it works in depth. At some stage, to utilize
    the complete power of a tool, you'll have to customize it in ways that suit your
    particular needs. Over a period of time, tools that provide you with an easy way
    to plug in new functionalities stay, and those that don't, disappear from the
    market. It's a similar story with Ansible as well. All tasks in the Ansible playbook
    are modules of some kind, and it comes loaded with hundreds of modules. You will
    find a module for almost anything that you might need. However, there are always
    exceptions, and this is where the power to extend Ansible's functionality, by
    adding custom modules comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Chef provides **Lightweight Resources and Providers** (**LWRPs**) to perform
    this activity and Ansible allows you to extend its functionality using custom
    modules. With Ansible, you can write the module in any language of your choice
    (provided that you have an interpreter of that language), whereas, in Chef, the
    module has to be in Ruby. Ansible developers recommend using Python for any complex
    module, as there is out-of-the-box support to parse arguments; almost all ***nix**
    systems have Python installed by default and Ansible itself is written in Python.
    In this chapter, we will also learn how to write modules in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make your custom modules available to Ansible, you can do one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the path to your custom module in the `ANSIBLE_LIBRARY` environment
    variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `--module-path` command-line option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drop the modules in the `library` directory in your Ansible top-level directory
    and add `library=library` in the `[default]` section of your `ansible.cfg` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download all the files from this book's GitHub repository at [https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter07](https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have this background information, let's take a look at some code!
  prefs: []
  type: TYPE_NORMAL
- en: Using Python to write modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible allows users to write modules in any language. Writing the module in
    Python, however, has its own advantages. You can take advantage of Ansible''s
    libraries to shorten your code – an advantage that is not available for modules
    written in other languages. Parsing user arguments, handling errors, and returning
    the required values becomes easier with the help of the Ansible libraries. Additionally,
    since Ansible is written in Python, you will have the same language for your whole
    Ansible code base, making reviews easier and maintainability higher. We will see
    two examples of a custom Python module, one using the Ansible library and one
    without, in order to give you a glimpse of how custom modules work. Make sure
    that you organize your directory structure as mentioned in the previous section
    before creating the module. The first example creates a module named `check_user`.
    To do this, we will need to create the `check_user.py` file in the `library` folder
    within the Ansible top-level directory. The full code is available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding custom module, `check_user`, will check whether a user exists
    on a host. The module expects a user argument from Ansible. Let''s break down
    the preceding module and see what it does. We first declare the Python interpreter and
    import the libraries that are required to parse the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `sys` library, we then parse the arguments, which are passed in a
    file by Ansible. The arguments are in the `param1=value1 param2=value2` format,
    where `param1` and `param2` are the parameters, and `value1` and `value2` are
    the values of the parameters. There are multiple ways in which to split arguments
    and create a dictionary, and we''ve chosen an easy way to perform the operation.
    We first create a list of arguments by splitting the arguments with a whitespace
    character, and then we separate the key and value by splitting the arguments with
    an `=` character and assigning it to a Python dictionary. For example, if you
    have a string such as `user=foo gid=1000`, then you will first create a list, `["user=foo",
    "gid=1000"]`, and then loop over this list to create a dictionary. This dictionary
    will be `{"user": "foo", "gid": 1000}`; this is performed using the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We separate the arguments based on a whitespace character, because this is the
    standard, followed by core Ansible modules. You can use any separator instead
    of whitespace, but we encourage you to maintain uniformity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the user argument, we then check whether this user exists on the
    host, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `pwd` library to check the `passwd` file for the user. For the sake
    of simplicity, we use two variables: one to store the success or failure message
    and the other to store the message for the user. Finally, we use the variables
    created in the `try-catch` block to check whether the module succeeded or failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If the module succeeds, then it will exit the execution with an exit code of
    `0` (`exit(0)`); otherwise, it will exit with a non-zero code. Ansible will look
    for the failed variable and, if it is set to `True`, it will exit unless you have
    explicitly asked Ansible to ignore the error using the `ignore_errors` parameter.
    You can use customized modules like any other core module of Ansible. To test
    the custom module, we will need a playbook, so let''s create the `playbooks/check_user.yaml` file
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we used the `check_user` module like any other core module.
    Ansible will execute this module onto the remote host by copying the module to
    the remote host with the arguments in a separate file. Let''s see how this playbook
    runs with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We should receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As expected, since we have the `root` user, but not `this_user_does_not_exists`,
    it passed the first check, but failed at the second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible also provides a Python library to parse user arguments and handle errors
    and returns. It''s time to explore how the Ansible Python library can be used
    to make your code shorter, faster, and less prone to error. To do so, let''s create
    a file called `library/check_user_py2.py` with the following code. The full code
    is available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the preceding module and see how it works, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we do not import `sys`, `shlex`, and `json`; we are no longer
    using them since all the operations that required them are now done by the Ansible
    `module_utils` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, we performed a lot of processing on the argument file to get the
    final user arguments. Ansible makes it easy by providing an `AnsibleModule` class,
    which does all the processing on its own and provides us with the final arguments.
    The `required=True` parameter means that the argument is mandatory and the execution
    will fail if the argument is not passed. The default value required is `False`,
    which will allow users to skip the argument. You can then access the value of
    the arguments through the `module.params` dictionary by calling the `get` method
    on `module.params`. The logic to check users on the remote host will remain the
    same, but the error handling and return aspect will change as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: One of the advantages of using the `AnsibleModule` object is that you have a
    very nice facility to handle returning values to the playbook. We will go into
    more depth in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: We could have condensed the logic for checking users and the return aspect,
    but we kept them divided for readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that everything works as expected, we can create a new playbook in
    `playbooks/check_user_py2.yaml` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we should receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This output is consistent with our expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Working with exit_json and fail_json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible provides a faster and shorter method for handling success and failure
    through the `exit_json` and `fail_json` methods, respectively. You can directly
    pass a message to these methods and Ansible will take care of the rest. You can
    also pass additional variables to these methods and Ansible will print those variables
    to `stdout`. For example, apart from the message, you might also want to print
    the `uid` and `gid` parameters of the user. You can do this by passing these variables
    to the `exit_json` method, separated by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how you can return multiple values to `stdout`, as demonstrated
    in the following code, placed in  `library/check_user_id.py`. The full code is
    available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we return the `uid` and `gid` parameters of the user, along
    with the message, `msg`. You can have multiple values and Ansible will print all
    of them in  dictionary format. Create a playbook in `playbooks/check_user_id.yaml`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We should receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we completed the working of both methods, which, in turn, helped us to
    find a quicker way to handle success and failure in Ansible while passing parameters
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Python modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you have seen, you can test your modules by creating very simple playbooks
    to run them.  To do so, we''ll need to clone the Ansible official repository (if
    you haven''t done so yet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, source an environmental file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the `test-module` utility to run the script by passing the filename
    as a command-line argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It's also easy to execute the script directly if you have not used `AnsibleModule`.
    This is because this module requires a lot of Ansible-specific variables, so it's
    more complicated to "simulate" an Ansible run than to actually run Ansible itself.
  prefs: []
  type: TYPE_NORMAL
- en: Using bash modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bash modules in Ansible are no different to any other bash scripts, except in
    the way that they print the data on `stdout`. Bash modules can be as straightforward
    as checking whether a process is running on the remote host, to running some more
    complex commands.
  prefs: []
  type: TYPE_NORMAL
- en: As previously stated, the general recommendation is to use Python for modules.
    In my opinion, the second-best choice (only for very easy modules) is the `bash`
    module, due to its simplicity and user base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `library/kill_java.sh` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `bash` module will take the `service_name` argument and forcefully
    kill all of the Java processes that belong to that service. As you know, Ansible
    passes the argument file to the module. We then source the argument file using
    the `$1` source. This will actually set the environment variable with the name, `service_name`.
    We then access this variable using `$service_name`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We then check to see if we obtained any `PIDS` for the service and run a loop
    over it to forcefully kill all of the Java processes that match `service_name`.
    Once they''re killed, we exit the module with `failed=False` and a message with
    an exit code of `0`, as you can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do not find any running processes for the service, we will still exit
    the module with an exit code of `0`, because terminating the Ansible run might
    not make sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can also terminate the Ansible run by printing `failed=True` with an exit
    code of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible allows you to return a key-value output if the language itself doesn''t
    support JSON. This makes Ansible more developer and sysadmin-friendly, and allows
    custom modules to be written in any language of your choice. Let''s test the `bash`
    module by passing the arguments file to the module. We can now create an arguments
    file in `/tmp/arguments` that has the `service_name` parameter set to `jenkins`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can run the module like any other bash script. Let''s see what happens
    when we run it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We should receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the module did not fail even though there was no Jenkins process
    running on the localhost.
  prefs: []
  type: TYPE_NORMAL
- en: If you receive the `jps command does not exists` error instead of the mentioned
    output, your machine is probably missing Java. If so, you can install it by following
    the instructions for your operating system at [https://www.java.com/en/download/help/download_options.xml](https://www.java.com/en/download/help/download_options.xml).
  prefs: []
  type: TYPE_NORMAL
- en: Using Ruby modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing modules in Ruby is as easy as writing a module in Python or bash. You
    just need to take care of the arguments, errors, return statements, and, of course,
    know basic Ruby! Let''s create the `library/rsync.rb` file with the following
    code. The full code is available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding module, we first process the user arguments, then copy the
    file using the `rsync` library, and finally, return the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use this, you need to ensure that the `rsync` library for Ruby
    is present on your system. To do so, you can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Let's break down the preceding code and see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first write a method, `print_message`, which will print the output in a
    JSON format. By doing this, we can reuse the same code in multiple places. Remember,
    the output of your module should contain `failed=true` if you want the Ansible
    run to fail; otherwise, Ansible will think that the module succeeded and will
    continue with the next task. The output that is obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We then process the argument file, which contains a key-value pair separated
    by a whitespace character. This is similar to what we did with the Python module
    earlier, where we took care of parsing out the arguments. We also perform some
    checks to make sure that the user has not missed any required argument. In this
    case, we check if the `src` and `dest` parameters have been specified, and print
    a message if the arguments are not provided. Further checks could include the
    format and type of arguments. You can add these checks and any other checks that
    you deem important. For example, if one of your parameters is a `date` parameter,
    then you''d need to verify that the input is actually the right date. Consider
    the following piece of code, which shows the discussed parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the required arguments, we will go ahead and copy the file using
    the `rsync` library, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we check if the `rsync` task passed or failed, and then call the `print_message`
    function to print the output on `stdout`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test your Ruby module by simply passing the arguments file to the module.
    To do so, we can create the `/tmp/arguments` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now run the module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We will leave the `serverspec` testing for you to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Testing modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is often undervalued because of the lack of understanding of its purpose
    and the benefits that it can bring to a business. Testing modules are as important
    as testing any other part of the Ansible playbook, because a small change in a
    module can break your entire playbook. We will take the example of the Python
    module that we wrote in the *Using Python to write modules* section of this chapter
    and write an integration test using Python's `nose` test framework. Unit tests
    are also encouraged, but for our scenario, where we check whether a user exists
    remotely, an integration test makes more sense.
  prefs: []
  type: TYPE_NORMAL
- en: '`nose` is a Python test framework; you can find out more information about
    this test framework at [https://nose.readthedocs.org/en/latest/](https://nose.readthedocs.org/en/latest/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To `test` the module, we convert our previous module into a Python class so
    that we can directly import the class into our test, and run only the main logic
    of the module. The following code shows the `library/check_user_py3.py` restructured
    module, which will check whether a user exists on a remote host. The full code
    is available on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, we created a class named `User`. We instantiated
    the class and called the `check_if_user_exists` method to check whether the user
    actually exists on the remote machine. It''s time to write an integration test
    now. We assume that you have the `nose` package installed on your system. If not,
    don''t worry! You can still install the package using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now write the integration test file in `library/test_check_user_py3.py`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding integration test, we import the `nose` package and our `check_user` module.
    We call the `User` class by passing the user that we want to check. We then check
    whether the user exists on the remote host by calling the `check_if_user_exists()`
    method. The `nose` methods – `assert_true`, `assert_false`, and `assert_equals` –
    can be used to compare the expected value against the actual value. Only if the
    `assert` methods pass, will the test also pass. You can have multiple tests inside
    the same file by having multiple methods whose names start with `test_`; for example,
    the `test_check_user_positive()` and `test_check_user_negative()` methods. `nose`
    tests will take all the methods that start with `test_` and execute them.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we actually created two tests for just one function. This is
    a key part of tests. Always try cases where you know it will work, but also, do
    not forget to test cases where you expect it to fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now test whether it works by running `nose` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You should receive an output that is similar to the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the test passed because the `root` user existed on the host,
    while the `this_user_does_not_exists` user did not.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `-v` option with `nose` tests for the **verbose** mode.
  prefs: []
  type: TYPE_NORMAL
- en: For more complicated modules, we recommend that you write unit tests and integration
    tests. You might be wondering why we didn't use `serverspec` to test the module.
  prefs: []
  type: TYPE_NORMAL
- en: We still recommend running `serverspec` tests for functional testing as part
    of playbooks; however, for unit and integration tests, it's recommended to use
    well-known frameworks. Similarly, if you write Ruby modules, we recommend that
    you write tests for them with a framework such as `rspec`. If your custom Ansible
    module has multiple parameters with multiple combinations, then you will write
    more tests to test each scenario. Finally, we recommend that you run all these
    tests as part of your CI system, be it Jenkins, Travis, or any other system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this, we come to the end of this rather small but important chapter, which
    focused on how you can extend Ansible by writing your own custom modules. You
    learned how to use Python, bash, and Ruby in order to write your modules. We've
    also learned how to write integration tests for modules so that they can be integrated
    into your CI system. In the future, hopefully, extending your Ansible functionality
    by using modules will be much easier!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will step into the world of provisioning, deployment,
    and orchestration, and look at how Ansible solves our infrastructure problems
    when we provision new instances or want to deploy software updates to various
    instances in our environments. We promise that this journey will be fun!
  prefs: []
  type: TYPE_NORMAL
