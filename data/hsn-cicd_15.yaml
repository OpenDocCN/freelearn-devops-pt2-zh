- en: Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: In the last chapter, [Chapter 14](c8355d57-1eb8-4e45-93f5-a32513185de3.xhtml), *CircleCI
    UI Logging and Debugging*, we covered more advanced debugging and logging techniques
    using CircleCI and went over more options using the CircleCI API. In the last
    chapter of the book, we will go over best practices for different types of testing,
    such as unit testing, integration testing, system testing, and acceptance testing.
    We will go over best practices with password management and use the Vault library
    as an example. Lastly, we will go over best practices in deployments in CI/CD
    and write a custom Go script to create a GitHub release.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章，[第14章]（c8355d57-1eb8-4e45-93f5-a32513185de3.xhtml），*CircleCI UI日志记录和调试*中，我们使用CircleCI涵盖了更高级的调试和日志记录技术，并介绍了使用CircleCI
    API的更多选项。在本书的最后一章中，我们将介绍不同类型测试的最佳实践，如单元测试、集成测试、系统测试和验收测试。我们将介绍密码管理的最佳实践，并以Vault库为例。最后，我们将介绍CI/CD中部署的最佳实践，并编写一个自定义的Go脚本来创建GitHub发布。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Best practices for different types of testing in CI/CD
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI/CD中不同类型测试的最佳实践
- en: Best practices in password and secrets storage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码和秘密存储的最佳实践
- en: Best practices in deployment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署的最佳实践
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter will require some basic programming skills, as we will discuss
    some programming language-specific material in the deployment script and in the
    unit test example as well. It would be very helpful to have some familiarity with
    Unix programming and what a Bash shell is.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将需要一些基本的编程技能，因为我们将在部署脚本和单元测试示例中讨论一些特定于编程语言的材料。熟悉Unix编程和Bash shell将非常有帮助。
- en: Best practices for different types of testing in CI/CD
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI/CD中不同类型测试的最佳实践
- en: 'In [Chapter 3](e80cf8c3-7464-4c16-865b-78e3c264a98e.xhtml), *Basics of Continuous
    Delivery*, we went over acceptance testing and spoke briefly about how an acceptance
    test suite can serve as a regression test suite. In this section, we will talk
    about different types of software testing that you can do and formulate some best
    practices with each type of test. We will go over the following types of tests:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章]（e80cf8c3-7464-4c16-865b-78e3c264a98e.xhtml），*持续交付的基础知识*中，我们介绍了验收测试，并简要讨论了验收测试套件如何作为回归测试套件。在本节中，我们将讨论您可以进行的不同类型的软件测试，并制定每种测试的最佳实践。我们将介绍以下类型的测试：
- en: Smoke testing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 烟雾测试
- en: Unit testing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration testing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: System testing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统测试
- en: Acceptance testing
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验收测试
- en: Smoke testing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 烟雾测试
- en: Smoke tests are a special kind of test that help verify basic functionality
    in your application. Smoke tests will assume some basic implementation and environmental
    setup. Smoke tests are typically run at the beginning of a test cycle that behave
    as a sanity check before starting a complete test suite.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 烟雾测试是一种特殊的测试，有助于验证应用程序的基本功能。烟雾测试将假定一些基本实现和环境设置。烟雾测试通常在测试周期开始时运行，作为完整测试套件开始之前的理智检查。
- en: The main idea behind a smoke test is to catch glaring problems when working
    on new features in a software system. Smoke tests are not meant to be exhaustive
    but instead are meant to run very quickly. Let's say that a software company follows
    agile software development practices and there are 2 week sprints where new features
    are added to the product. When a new feature is merged into the release, meaning
    the main trunk of the software, a smoke test fails, and this should immediately
    raise a red flag that the new feature may have broken existing functionality.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 烟雾测试的主要目的是在软件系统的新功能开发中捕捉明显的问题。烟雾测试不是为了详尽无遗，而是为了快速运行。假设一个软件公司遵循敏捷软件开发实践，每两周进行一次冲刺，向产品添加新功能。当新功能合并到发布中，即软件的主干时，烟雾测试失败，这应立即引起警觉，表明新功能可能破坏了现有功能。
- en: You can create smoke tests that are context-specific when testing a new functionality
    in a system that will employ some basic assumptions and that can assert that the
    requirements are being met. You can create smoke tests that are run before any
    integration testing is done and before any deployments are done for staging environments,
    and these smoke tests will check different conditions on each staging environment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建特定上下文的烟雾测试，用于测试系统中的新功能，这些测试将采用一些基本假设，并断言是否满足要求。您可以在进行任何集成测试之前以及在为暂存环境进行任何部署之前运行这些烟雾测试，并且这些烟雾测试将检查每个暂存环境的不同条件。
- en: Smoke test example
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 烟雾测试示例
- en: 'We will use an existing application that I have built that shows a list of
    users in a table. The application is called `containerized-golang-and-vuejs` ([https://github.com/jbelmont/containerized-golang-and-vuejs](https://github.com/jbelmont/containerized-golang-and-vuejs))
    and it shows how to use the containers, Golang and Vue.js for reference purposes.
    The first thing we will do is to make sure that the application is running using
    a `makefile` task called `make dev`. This command does the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我构建的现有应用程序，该应用程序显示表中的用户列表。该应用程序称为`containerized-golang-and-vuejs`（[https://github.com/jbelmont/containerized-golang-and-vuejs](https://github.com/jbelmont/containerized-golang-and-vuejs)），它展示了如何使用容器、Golang和Vue.js作为参考。我们首先要做的是确保应用程序正在使用名为`make
    dev`的`makefile`任务运行。此命令执行以下操作：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To summarize, this command spins up four Docker containers and, when it is up
    and running, we should be able to hit `http://localhost:8080`. Now, in reality,
    a smoke test would hit a live running application but this is just for demonstration
    purposes for a smoke test. We will use an end-to-end testing library called **Cypress**
    ([https://www.cypress.io/](https://www.cypress.io/)) but we could just as easily
    use another library for this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，此命令会启动四个Docker容器，当它运行时，我们应该能够访问`http://localhost:8080`。现实中，烟雾测试会访问运行中的应用程序，但这只是用于演示烟雾测试的目的。我们将使用一个名为**Cypress**（[https://www.cypress.io/](https://www.cypress.io/)）的端到端测试库，但我们也可以使用另一个库。
- en: 'We will write the following simple smoke test using JavaScript:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用JavaScript编写以下简单的冒烟测试：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can read more about Cypress in the Getting Started ([https://docs.cypress.io/guides/getting-started/writing-your-first-test.html#](https://docs.cypress.io/guides/getting-started/writing-your-first-test.html#))
    documents but this test is essentially verifying that the page is loading with
    data and Cypress takes screenshots so we can visually verify the page.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在入门指南（[https://docs.cypress.io/guides/getting-started/writing-your-first-test.html#](https://docs.cypress.io/guides/getting-started/writing-your-first-test.html#)）文档中了解更多关于Cypress的信息，但这个测试基本上是验证页面是否加载了数据，Cypress会拍摄屏幕截图，以便我们可以直观地验证页面。
- en: 'Here is the screenshot that the Cypress library took:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Cypress库拍摄的屏幕截图：
- en: '![](assets/b6cbc20c-13d3-47f2-b58f-97231623e841.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b6cbc20c-13d3-47f2-b58f-97231623e841.png)'
- en: For this simple application, we can be sure that the application is roughly
    working, but a more complete smoke test may go through a login screen and then
    do a basic action that the application is expected to do.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的应用程序，我们可以确信应用程序大致工作正常，但更完整的冒烟测试可能会通过登录界面，然后执行应用程序预期执行的基本操作。
- en: Another nice feature of Cypress is that it can take videos of the tests showing
    all the steps that the test is taking, which can further verify that the application
    is meeting the basic requirements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress的另一个好功能是它可以录制测试的视频，显示测试所采取的所有步骤，这可以进一步验证应用程序是否满足基本要求。
- en: Unit testing
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests can be considered the foundation of software testing in that unit
    tests test individual blocks of code, such as a function or a class/object. With
    a unit test, you are testing the functionality of functions and/or classes on
    their own. Because of this fact, unit tests typically stub out or mock out any
    external dependencies so that that the test can focus entirely on the function
    and/or class in question.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以被认为是软件测试的基础，因为单元测试测试代码的单个块，比如一个函数或一个类/对象。通过单元测试，您可以测试函数和/或类的功能。由于这个事实，单元测试通常会存根或模拟任何外部依赖，以便测试可以完全专注于相关的函数和/或类。
- en: Unit tests are fundamental to testing a system in terms of correctness of behavior
    of individual components. The fact that unit tests are limited in this respect
    means that it is easier to isolate where defects have occurred at. Unit tests
    are often used to test code branches and how a function may handle different types
    of input. Unit tests are typically the first tests that developers will run in
    a build while QA engineers may run smoke tests first and then follow that with
    any unit tests.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试在测试系统的组件行为正确方面是基础的。单元测试在这方面的限制意味着更容易隔离缺陷发生的位置。单元测试通常用于测试代码分支以及函数如何处理不同类型的输入。开发人员通常会在构建中首先运行单元测试，而QA工程师可能会首先运行冒烟测试，然后进行任何单元测试。
- en: Individual developers will run unit tests on their workstations prior to submitting
    changes to version control projects, such as GitHub. With that being said, continuous
    integration servers, such as Jenkins, Travis CI, and CircleCI, will run unit tests
    before running any integration tests, as we have seen in the previous chapters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 个别开发人员将在提交更改到版本控制项目（如GitHub）之前在他们的工作站上运行单元测试。话虽如此，持续集成服务器（如Jenkins、Travis CI和CircleCI）将在运行任何集成测试之前运行单元测试，正如我们在前几章中所看到的。
- en: Unit test example
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试示例
- en: 'We will look at a previous project called `circleci-jobs-example` ([https://github.com/packtci/circleci-jobs-example](https://github.com/packtci/circleci-jobs-example))
    that has several unit tests that have been written to test individual functions.
    In the repository, we have a file called `sort.js` that has the following function
    in it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个名为`circleci-jobs-example`（[https://github.com/packtci/circleci-jobs-example](https://github.com/packtci/circleci-jobs-example)）的先前项目，该项目有几个单元测试用于测试单个函数。在存储库中，我们有一个名为`sort.js`的文件，其中包含以下函数：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This function takes an array of objects and sorts the objects by the `firstName`
    attribute. For our unit test, we simply want to test that the `sortListOfNames`
    function will sort the first name in alphabetical order. Here is the unit test
    that we have written in the `tape.js` ([https://github.com/substack/tape](https://github.com/substack/tape))
    testing library:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个对象数组，并按照`firstName`属性对对象进行排序。对于我们的单元测试，我们只想测试`sortListOfNames`函数是否按字母顺序排序第一个名字。这是我们在`tape.js`（[https://github.com/substack/tape](https://github.com/substack/tape)）测试库中编写的单元测试：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can see here that the unit test is able to isolate and test only the behavior
    of the `sortListOfNames` function, which is very useful because, if the `sortListOfNames`
    function were to have any issues, we can quickly isolate where the regression
    is occurring. Now, granted this function is very basic and simple, but you can
    see that unit tests serve an important purpose in a continuous integration build's
    job in catching regressions in software.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到，单元测试能够隔离并测试`sortListOfNames`函数的行为，这非常有用，因为如果`sortListOfNames`函数出现任何问题，我们可以快速确定回归发生的位置。当然，虽然这个函数非常基本和简单，但您可以看到单元测试在持续集成构建中捕捉软件回归方面起着重要作用。
- en: Integration testing
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration tests will test groups of software components as they work with
    each other. While unit tests can help validate the functionality of a block on
    code in isolation, integration tests help test blocks of code as they interact
    with one another. Integration tests are useful because they can help catch different
    types of issues that arise when software components interact.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试将测试软件组件组合在一起的方式。虽然单元测试可以帮助验证代码块在隔离状态下的功能，但集成测试可以帮助测试代码块在彼此交互时的情况。集成测试很有用，因为它们可以帮助捕捉软件组件交互时出现的不同类型的问题。
- en: While unit tests may be run in a developer's workstation, integration tests
    are usually run when code is checked into source control. A CI server will check
    out the code, perform build steps, and then follow with any smoke tests and then
    run unit tests and then integration tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单元测试可能在开发人员的工作站上运行，但集成测试通常在代码检入源代码控制时运行。CI服务器将检出代码，执行构建步骤，然后进行任何冒烟测试，然后运行单元测试，然后运行集成测试。
- en: Since integration tests are a higher level of abstraction and test software
    components interacting with each other, they help protect the health of a code
    base. When developers introduce new features to a system, the integration tests
    can help ensure that the new code is working with other blocks of code as expected.
    Integration tests can help ensure that new features in a system can safely be
    deployed to an environment. Integration tests are usually the first types of tests
    that are done outside of a developer's workstation and help show whether they
    may be environmental dependency breakages and whether newer code is behaving properly
    with external libraries and external services and/or data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集成测试是更高级的抽象级别，并且测试软件组件相互交互，它们有助于保护代码库的健康。当开发人员向系统引入新功能时，集成测试可以帮助确保新代码与其他代码块按预期工作。集成测试可以帮助确保系统中的新功能可以安全地部署到环境中。集成测试通常是在开发人员的工作站之外进行的第一种测试类型，并有助于显示是否存在环境依赖性破坏以及新代码是否与外部库、外部服务和/或数据正常行为。
- en: Integration test example
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试示例
- en: We will look at a public API, such as CircleCI, and write an integration test
    that hits the API endpoint and verifies that the status code and the body of the
    request are what we would expect. This would typically be a local API that you
    are working on and want verification of correct behavior but, as an example, we
    will hit the CircleCI for illustration purposes only. We will create a new repository
    in GitHub using our `packtci` user and call it `integration-test-example` ([https://github.com/packtci/integration-test-example](https://github.com/packtci/integration-test-example))[.
    We will use several libraries including `supertest` (](https://github.com/packtci/integration-test-example)[https://github.com/visionmedia/supertest](https://github.com/visionmedia/supertest)), 
    a Node.js library, `baloo` ([https://github.com/h2non/baloo](https://github.com/h2non/baloo)),
    a Golang library to hit API endpoints, and , finally, just `curl` and `bash`.
    It does not matter which library that you use; I am using these libraries for
    demonstration purposes only.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个公共API，比如CircleCI，并编写一个集成测试，以访问API端点并验证请求的状态代码和主体是否符合我们的预期。这通常是您正在使用的本地API，并且希望验证正确行为，但作为示例，我们将仅用于说明目的访问CircleCI。我们将在GitHub中使用我们的`packtci`用户创建一个名为`integration-test-example`的新存储库([https://github.com/packtci/integration-test-example](https://github.com/packtci/integration-test-example))。我们将使用几个库，包括`supertest`
    ([https://github.com/visionmedia/supertest](https://github.com/visionmedia/supertest))，一个Node.js库，`baloo`
    ([https://github.com/h2non/baloo](https://github.com/h2non/baloo))，一个用于访问API端点的Golang库，最后是`curl`和`bash`。您使用哪个库并不重要；我只是为了演示目的而使用这些库。
- en: API testing example using the supertest Node.js library
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用supertest Node.js库的API测试示例
- en: 'In this integration test example, we hit the `GET /projects` ([https://circleci.com/docs/api/v1-reference/#projects](https://circleci.com/docs/api/v1-reference/#projects))
    endpoint in CircleCI. Here is the code testing this endpoint:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个集成测试示例中，我们访问CircleCI中的`GET /projects` ([https://circleci.com/docs/api/v1-reference/#projects](https://circleci.com/docs/api/v1-reference/#projects))端点。以下是测试此端点的代码：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we test that the endpoint returns a `200` HTTP response and that it has
    a body and that there is an attribute in the array of objects of `oss`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们测试端点是否返回`200`的HTTP响应，是否有主体，以及`oss`对象数组中是否有属性。
- en: API testing example with the baloo Golang library
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用baloo Golang库的API测试示例
- en: 'In this integration test, we hit the `GET /user` ([https://developer.travis-ci.com/resource/user#User](https://developer.travis-ci.com/resource/user#User))
    endpoint in the Travis API. Here is the code testing this endpoint:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个集成测试中，我们访问Travis API中的`GET /user` ([https://developer.travis-ci.com/resource/user#User](https://developer.travis-ci.com/resource/user#User))端点。以下是测试此端点的代码：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we test that the response is a `200` and that the body has values.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们测试响应是否为`200`，并且主体具有值。
- en: API testing example with curl, bash, and jq
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用curl、bash和jq的API测试示例
- en: 'In this integration test example, we will hit `GET: /project/:vcs-type/:username/:project`
    ([https://circleci.com/docs/api/v1-reference/#recent-builds-project](https://circleci.com/docs/api/v1-reference/#recent-builds-project)),
    a recent build endpoint in the CircleCI API. Here is the code testing this endpoint:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个集成测试示例中，我们将访问CircleCI API中的最近构建端点`GET: /project/:vcs-type/:username/:project`
    ([https://circleci.com/docs/api/v1-reference/#recent-builds-project](https://circleci.com/docs/api/v1-reference/#recent-builds-project))。以下是测试此端点的代码：'
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we test that we received an `author_name` attribute from the endpoint
    that should be returned in the JSON payload.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们测试是否从应该在JSON有效负载中返回的端点接收了`author_name`属性。
- en: System testing
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统测试
- en: System tests are typically broader integration tests that extend integration
    tests. System tests will aggregate groups of functionality in an application and
    so are even wider in scope than integration tests. System tests will usually be
    run after integration tests as they are testing larger behaviors in an application
    and will take longer to run.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试通常是扩展集成测试的更广泛的集成测试。系统测试将聚合应用程序中的功能组，并且比集成测试的范围更广。系统测试通常在集成测试之后运行，因为它们正在测试应用程序中的更大行为，并且运行时间更长。
- en: System test example
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统测试示例
- en: 'System tests can include:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试可以包括：
- en: '**Usability testing**: A type of test that tests the ease of use in the system
    and the overall ability of the system to meet its proposed functionality'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性测试**：一种测试类型，测试系统的易用性以及系统满足其拟议功能的整体能力'
- en: '**Load testing**: A type of test that will measure the behavior of a system
    under real-world load'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载测试**：一种测试类型，用于测量系统在真实负载下的行为'
- en: '**Regression testing**: A type of test that checks that the system is behaving
    normally whenever newer features are added to a system'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回归测试**：一种测试类型，用于检查系统在添加新功能时是否正常运行'
- en: There are other types of system testing but we have only included some common
    types of system tests.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型的系统测试，但我们只包括了一些常见的系统测试类型。
- en: Acceptance testing
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验收测试
- en: We have gone over acceptance tests throughout the book but, to reiterate, an
    acceptance test is a formal verification of the behavior of an application. Acceptance
    tests will typically be the last types of tests that you will write in a CI/CD
    pipeline as they are longer running and more involved in terms of the verification
    aspect of acceptance tests as a whole.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整本书中都讨论了验收测试，但是，验收测试是对应用程序行为的正式验证。验收测试通常是CI/CD流水线中的最后一种测试，因为它们运行时间较长，并且在验收测试的验证方面更为复杂。
- en: Acceptance tests can also serve as a regression test suite since they provide
    assurances that the application is behaving as it should. There are some libraries
    that use a formal domain-specific language called **Gherkin** ([https://docs.cucumber.io/gherkin/reference/](https://docs.cucumber.io/gherkin/reference/)).
    This has specific files that write down what is called **acceptance criteria. **These
    stipulate what the new feature needs to do and it is not uncommon for a software
    company to write an acceptance test that is failing at the beginning of the sprint
    and that will pass once the acceptance criteria have been met when the feature
    is implemented correctly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试也可以作为回归测试套件，因为它们可以保证应用程序的行为符合预期。有一些库使用一种称为**Gherkin**的正式领域特定语言（[https://docs.cucumber.io/gherkin/reference/](https://docs.cucumber.io/gherkin/reference/)）。这些库有特定的文件，写下了所谓的**验收标准**。这些标准规定了新功能需要做什么，对于软件公司来说，编写一个在冲刺开始时失败，一旦满足验收标准就会通过的验收测试并不罕见。
- en: Acceptance test example
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验收测试示例
- en: 'We can look at a very simple example of an acceptance test in my repository
    called `cucumber-examples` ([https://github.com/jbelmont/cucumber-examples](https://github.com/jbelmont/cucumber-examples)),
    which has a Gherkin file that checks that our acceptance criteria is met for a
    simple calculator program:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我的名为`cucumber-examples`（[https://github.com/jbelmont/cucumber-examples](https://github.com/jbelmont/cucumber-examples)）的存储库中查看一个非常简单的验收测试示例，其中有一个Gherkin文件，检查我们的验收标准是否满足了一个简单的计算器程序：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice here that the Gherkin syntax is human-readable and is meant to be read
    as a list of declarations for the new functionality. Here, we state that we want
    to be able to do a simple math addition operation and then provide a scenario
    to fulfill this. Here is the code that implements this functionality:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Gherkin语法是人类可读的，意在被阅读为新功能声明的列表。在这里，我们声明我们想要能够进行简单的数学加法运算，然后提供一个场景来实现这一点。以下是实现此功能的代码：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This file is a JavaScript class that does simple addition and here is another
    class that has a list of scenarios that add a list of numbers up:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件是一个执行简单加法的JavaScript类，这里还有另一个类，其中列出了一系列将数字相加的场景：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is a very simple acceptance test but it is meant to illustrate the fact
    that an acceptance test is a formal verification that the new feature is behaving
    as it is should be.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的验收测试，但它旨在说明验收测试是对新功能行为的正式验证。
- en: Best practices for running different tests in a CI/CD pipeline
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CI/CD流水线中运行不同测试的最佳实践
- en: 'We described the the following stages in [Chapter 3](e80cf8c3-7464-4c16-865b-78e3c264a98e.xhtml),
    *Basics of Continuous Delivery*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](e80cf8c3-7464-4c16-865b-78e3c264a98e.xhtml)中描述了以下阶段，*持续交付的基础*：
- en: The first stage of a CI/CD pipeline will typically encompass a build and commit
    stage. This is where you build any artifacts needed for the rest of the pipeline
    and run your unit test suite in the build. The first stage is meant to be very
    fast running as developers need to have a short feedback loop or else you risk
    developers bypassing this stage.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI/CD流水线的第一个阶段通常包括构建和提交阶段。这是您构建流水线其余部分所需的任何构件并在构建中运行单元测试套件的地方。第一阶段旨在运行非常快，因为开发人员需要有一个短的反馈循环，否则您可能会冒着开发人员绕过此阶段的风险。
- en: The second stage of a CI/CD pipeline will typically run integration tests as
    they are longer running types of tests and can be run after the first stage of
    the pipeline runs and passes. The second stage is a layer of assurance that any
    new functionality has broken integrated components of a system.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI/CD流水线的第二阶段通常会运行集成测试，因为它们是运行时间较长的测试类型，并且可以在流水线的第一阶段运行并通过后运行。第二阶段是对系统的任何新功能是否破坏了系统集成组件的一层保证。
- en: The third stage of a CI/CD pipeline might consist of a suite of load tests and
    or regression tests and or security tests and will be much longer running than
    the first two stages of the CI/CD pipeline.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI/CD流水线的第三阶段可能包括一套负载测试、回归测试和安全测试，并且比CI/CD流水线的前两个阶段运行时间更长。
- en: The fourth stage can be where the acceptance tests are run, although I have
    personally seen companies that run an acceptance test suite in tandem with integration
    tests and so they only had three stages in their CI/CD pipeline. The stages we
    have laid out in this chapter are not hard and fast rules but merely some suggestions,
    as each application is unique in its behavior.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四阶段可以是验收测试的运行阶段，尽管我个人见过一些公司同时运行验收测试套件和集成测试，因此它们的CI/CD流水线只有三个阶段。我们在本章中列出的阶段并不是硬性规定，而只是一些建议，因为每个应用程序在行为上都是独特的。
- en: Best practices in password and secrets storage
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码和秘密存储的最佳实践
- en: As we have seen throughout the chapters covering Jenkins, Travis CI, and CircleCI,
    each continuous integration server has a way to store secure information such
    as passwords, API keys, and secrets. It is dangerous to run certain actions in
    the CI server, such as execution tracing with Bash by using the `set -x` option
    in Bash. It is better to either use the CI server's functionality to securely
    store passwords and secrets, such as the context settings for each project in
    CircleCI ,which cannot be seen by anyone other than a project owner. You can also
    use a tool such as **Vault** ([https://www.vaultproject.io/intro/index.html](https://www.vaultproject.io/intro/index.html))
    to securely store your passwords and that can be retrieved using a RESTful API
    or use something like the **Amazon Key Management Service** ([https://aws.amazon.com/secrets-manager/](https://aws.amazon.com/secrets-manager/)). 
    We will briefly look at using Vault for password needs in a local development
    environment and make calls to Vault's RESTful API.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在涵盖Jenkins、Travis CI和CircleCI的章节中所看到的，每个持续集成服务器都有一种存储安全信息（如密码、API密钥和秘密）的方法。在CI服务器中运行某些操作是危险的，比如在Bash中使用`set
    -x`选项进行执行跟踪。最好是使用CI服务器的功能来安全地存储密码和秘密，比如CircleCI中每个项目的上下文设置，只有项目所有者才能看到。您也可以使用诸如**Vault**（[https://www.vaultproject.io/intro/index.html](https://www.vaultproject.io/intro/index.html)）这样的工具来安全地存储密码，并可以使用RESTful
    API检索，或者使用**Amazon Key Management Service**（[https://aws.amazon.com/secrets-manager/](https://aws.amazon.com/secrets-manager/)）等工具。我们将简要介绍在本地开发环境中使用Vault来满足密码需求，并调用Vault的RESTful
    API。
- en: Vault installation
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vault安装
- en: 'Installing Vault ([https://www.vaultproject.io/](https://www.vaultproject.io/))
    can be done at the Install Vault ([https://www.vaultproject.io/intro/getting-started/install.html](https://www.vaultproject.io/intro/getting-started/install.html))
    link. Once you download Vault, you will need to move the single binary into a
    `PATH` that your OS will be able to find. Here is a sample run that I did on my
    local machine:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Vault（[https://www.vaultproject.io/](https://www.vaultproject.io/)）可以在安装Vault（[https://www.vaultproject.io/intro/getting-started/install.html](https://www.vaultproject.io/intro/getting-started/install.html)）链接中完成。下载Vault后，您需要将单个二进制文件移动到操作系统可以找到的`PATH`中。以下是我在本地机器上运行的示例：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The last command will move the binary called `vault` into the `/usr/local/bin` directory
    that is in my path and I should now be able run the `vault` command and see the
    help menu like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个命令将把名为`vault`的二进制文件移动到我的路径中的`/usr/local/bin`目录中，然后我现在应该能够运行`vault`命令并查看帮助菜单，如下所示：
- en: '![](assets/ba4e906c-281a-493d-a0ad-c8a27fee3ac7.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ba4e906c-281a-493d-a0ad-c8a27fee3ac7.png)'
- en: Notice here that the `vault` command has `Common commands` and `Other commands`
    that can be run.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`vault`命令有`常用命令`和`其他命令`可以运行。
- en: Starting the dev server for Vault
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动Vault的开发服务器
- en: 'We need to run the vault server `-dev` command to start the dev server:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要运行`vault server -dev`命令来启动开发服务器：
- en: '![](assets/a3a2506b-8d4c-4052-929a-edb6e6b98f9c.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a3a2506b-8d4c-4052-929a-edb6e6b98f9c.png)'
- en: Notice here that we get a list of instructions to set up our local dev environment.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们得到了一系列指令，以设置我们的本地开发环境。
- en: Keep in mind that this is just for demonstration purposes and that the dev mode
    is not meant for a production instance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这仅用于演示目的，开发模式不适用于生产实例。
- en: Checking the status of the Vault server
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查Vault服务器的状态
- en: 'In the following screenshot, we check the status of the dev Vault server:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，我们检查了开发Vault服务器的状态：
- en: '![](assets/b65767c5-89fe-4798-b037-13f337dcda02.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b65767c5-89fe-4798-b037-13f337dcda02.png)'
- en: The first thing we did was export the `VAULT_ADDR` environment variable in a
    new shell, as we will be using this command, and then we checked the status of
    our dev Vault server.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在新的shell中导出`VAULT_ADDR`环境变量，因为我们将使用此命令，然后检查我们的开发Vault服务器的状态。
- en: Setting  an API secret in Vault
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Vault中设置API密钥
- en: 'In the following screenshot, we set an API secret and then retrieve it with
    Vault:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，我们设置了一个API密钥，然后使用Vault检索它：
- en: '![](assets/3ae0f090-6fe2-4d41-a498-e5129098b6b8.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3ae0f090-6fe2-4d41-a498-e5129098b6b8.png)'
- en: 'We can also list out all the secrets in the Vault like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以列出Vault中的所有秘密，如下所示：
- en: '![](assets/1739eb77-a4b6-48f0-a019-c469a29de376.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1739eb77-a4b6-48f0-a019-c469a29de376.png)'
- en: Using the Vault RESTful API
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vault RESTful API
- en: 'Remember that we are running a dev Vault server instance and so we can run
    `curl` as a REST client to the Vault API on our local machine. Let''s us run the
    following `curl` command to check whether our Vault instance has been initialized,
    which it should be at this point:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们正在运行开发Vault服务器实例，因此我们可以在本地机器上作为REST客户端运行`curl`到Vault API。让我们运行以下`curl`命令，检查我们的Vault实例是否已初始化，此时应该已经初始化：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We need to create a file called `config.hcl` in order to bypass TLS defaults
    for Vault with the following content:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个名为`config.hcl`的文件，以便使用以下内容绕过Vault的TLS默认设置：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will need to unseal the Vault and log in, as the following screenshot shows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解封Vault并登录，如下截图所示：
- en: '![](assets/b8f7a876-40b2-4c9d-8562-c19506f908c2.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b8f7a876-40b2-4c9d-8562-c19506f908c2.png)'
- en: 'Notice here that we get a token, which is what we will need to make requests
    to the RESTful API using the following HTTP header: `X-Vault-Token: 3507d8cc-5ca2-28b5-62f9-a54378f3366d`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，我们得到了一个令牌，这是我们将需要使用以下HTTP标头进行RESTful API请求的令牌：`X-Vault-Token: 3507d8cc-5ca2-28b5-62f9-a54378f3366d`。'
- en: Vault RESTful API endpoint GET /v1/sys/raw/logical
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vault RESTful API端点GET /v1/sys/raw/logical
- en: 'Here is a sample `curl GET` request for the endpoint:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于端点的示例`curl GET`请求：
- en: '![](assets/fc5603a4-a40c-4fa9-bd99-53169818e0b3.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fc5603a4-a40c-4fa9-bd99-53169818e0b3.png)'
- en: Notice here that we used the token that was printed from the standard output
    after we ran the Vault login `ROOT_KEY` command. This endpoint returns the list
    of keys for the given path, which in this case is `/sys/raw/logical`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在运行Vault登录`ROOT_KEY`命令后从标准输出中打印出的令牌。此端点返回给定路径的密钥列表，在本例中为`/sys/raw/logical`。
- en: Overall best practices for secrets management
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 秘密管理的总体最佳实践
- en: As we have stated before throughout the book, it is not good practice to commit
    raw passwords and secrets into source control and you will need to have a way
    to safely retrieve passwords when running CI/CD pipelines. You can use the CI
    server itself to store passwords and secrets and then retrieve them using environment
    variables or you can use services such as Vault to securely store your passwords.
    Remember that it can be unsafe to use execution tracing in shell scripts in CI
    environments so be mindful when debugging builds and using the `set -x` flag in
    Bash.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在整本书中所述，将原始密码和秘密提交到源代码控制中并不是一个好的做法，您需要有一种安全地检索密码的方法来运行CI/CD流水线。您可以使用CI服务器本身来存储密码和秘密，然后使用环境变量检索它们，或者您可以使用Vault等服务来安全地存储密码。请记住，在CI环境中使用shell脚本的执行跟踪可能是不安全的，因此在调试构建和在Bash中使用`set
    -x`标志时要谨慎。
- en: Best practices in deployment
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署最佳实践
- en: In [Chapter 3](e80cf8c3-7464-4c16-865b-78e3c264a98e.xhtml), *Basics of Continuous
    Delivery*, we went over what a deployment is, explained the deployment pipeline,
    and spoke about test gates in a deployment pipeline. We also spoke about deployment
    scripting and about the deployment ecosystem.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](e80cf8c3-7464-4c16-865b-78e3c264a98e.xhtml)中，*持续交付的基础*，我们讨论了部署是什么，解释了部署流水线，并谈到了部署流水线中的测试门。我们还谈到了部署脚本和部署生态系统。
- en: 'Let''s highlight some other good strategies when doing deployments:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在部署时突出一些其他好的策略：
- en: Creating a deployment checklist
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建部署清单
- en: Releasing automation
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布自动化
- en: Creating a deployment checklist
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建部署清单
- en: Every company will have unique constraints and so it is not possible to create
    a deployment checklist that satisfies the constraints of every company but, in
    general, here are some guidelines that may be helpful throughout all deployments.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每家公司都会有独特的限制，因此不可能创建一个满足每家公司限制的部署清单，但是总的来说，以下是一些可能在所有部署中有所帮助的指南。
- en: Collaboration among developers and operations
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发人员和运维之间的协作
- en: There should be communication between the development team and operations to
    properly coordinate a deployment. This is critical because miscommunications are
    bound to happen and so close communication should be happening during a deployment
    to avoid outages and lost of data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队和运维之间应该进行沟通，以便正确协调部署。这很关键，因为误解是不可避免的，因此在部署过程中应该进行密切的沟通，以避免中断和数据丢失。
- en: Releasing automation
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化发布
- en: Manual processes are error-prone and so a deployment should be automated as
    much as possible to avoid human error. Manual processes are not repeatable and
    are not sustainable, as deployments become more complicated. It is better to have
    automation scripts that take human error out of the equation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 手动流程容易出错，因此应尽可能自动化部署，以避免人为错误。手动流程不可重复，也不可持续，因为部署变得更加复杂。最好有自动化脚本，可以排除人为错误。
- en: Deployment script example
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署脚本示例
- en: There are many different options in terms of where software can be deployed.
    In this way, a deployment script can vary greatly depending on whether a project
    is open source, private, or enterprise. Many open source projects simply create
    a GitHub release ([https://help.github.com/articles/creating-releases/](https://help.github.com/articles/creating-releases/))
    for each new release and automate the process by using a Bash script. Some companies
    may use **Heroku** ([https://devcenter.heroku.com/start](https://devcenter.heroku.com/start))
    as their provider or some may use **AWS CodeDeploy** ([https://aws.amazon.com/codedeploy/](https://aws.amazon.com/codedeploy/))
    but, in the end, you want to automate your deployment process so that there is
    a standard and automated way to deploy your software. It is also good to have
    a deployment script that will collate version control commits and be able to display
    new features and bug fixes in each software release.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件部署的位置方面有许多不同的选择。因此，根据项目是开源、私有还是企业，部署脚本可能会有很大的不同。许多开源项目只是为每个新版本创建一个GitHub发布（[https://help.github.com/articles/creating-releases/](https://help.github.com/articles/creating-releases/)），并通过使用Bash脚本自动化该过程。一些公司可能使用**Heroku**（[https://devcenter.heroku.com/start](https://devcenter.heroku.com/start)）作为他们的提供商，或者一些公司可能使用**AWS
    CodeDeploy**（[https://aws.amazon.com/codedeploy/](https://aws.amazon.com/codedeploy/)），但最终，您希望自动化您的部署过程，以便有一个标准和自动化的方式来部署您的软件。还很好地拥有一个部署脚本，可以整理版本控制提交，并能够在每个软件发布中显示新功能和错误修复。
- en: Automated GitHub release example
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化的GitHub发布示例
- en: We will use the following endpoint in the GitHub API to automate the release
    strategy: `POST /repos/:owner/:repo/releases`. The documentation for  this endpoint
    can be found at [https://developer.github.com/v3/repos/releases/#create-a-release](https://developer.github.com/v3/repos/releases/#create-a-release).
    We will create a Golang script in the `multiple-languages` ([https://github.com/packtci/multiple-languages](https://github.com/packtci/multiple-languages) )
    GitHub repository that will create a new GitHub release.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用GitHub API中的以下端点来自动化发布策略：`POST /repos/:owner/:repo/releases`。此端点的文档可以在[https://developer.github.com/v3/repos/releases/#create-a-release](https://developer.github.com/v3/repos/releases/#create-a-release)找到。我们将在`multiple-languages`（[https://github.com/packtci/multiple-languages](https://github.com/packtci/multiple-languages)）GitHub存储库中创建一个Golang脚本，用于创建新的GitHub发布。
- en: Golang script example
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Golang脚本示例
- en: 'We will use Golang to make an HTTP request and give the Go script some command-line
    arguments. These will be used to formulate the following `request` body that will
    have the following shape:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Golang发出HTTP请求，并为Go脚本提供一些命令行参数。这些参数将用于构建以下`request`主体，其形式如下：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is the first part of the deployment script:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是部署脚本的第一部分：
- en: '![](assets/9f6eb61c-5117-4ab1-973e-272dfdf0fed4.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9f6eb61c-5117-4ab1-973e-272dfdf0fed4.png)'
- en: 'In this part of the script, we declare our package of `main` and then get some
    command-line arguments that we will need to make our HTTP request. We need to
    parse them and check if they are are set, which is what the `checkArgs` function
    does when it gets called in the `main` function, as shown in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的这一部分中，我们声明了`main`包，并获取了一些我们需要发出HTTP请求的命令行参数。我们需要解析它们并检查它们是否设置，这就是在`main`函数中调用`checkArgs`函数时所做的，如下面的屏幕截图所示：
- en: '![](assets/85330f7b-a713-4b57-adcb-2b12d9a4527d.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/85330f7b-a713-4b57-adcb-2b12d9a4527d.png)'
- en: 'Now, in this second part of the script, we are in our `main` function and here
    we parse the command-line arguments and then invoke our `checkArgs` function.
    Next, we create an anonymous struct that we will use to create our `request` body
    and then we set up the HTTP request and set our HTTP headers. In the last part
    of the script, we make our request and print out the release URL:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在脚本的第二部分中，我们在`main`函数中，解析命令行参数，然后调用我们的`checkArgs`函数。接下来，我们创建一个匿名结构，用于创建我们的请求体，然后设置HTTP请求并设置HTTP头。在脚本的最后部分，我们发出请求并打印发布URL。
- en: '![](assets/e3fac44d-4378-4ea5-bb7d-45ccd0c785d6.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e3fac44d-4378-4ea5-bb7d-45ccd0c785d6.png)'
- en: 'Let us show a run in a Terminal session for this deployment script:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在终端会话中展示这个部署脚本的运行：
- en: '![](assets/638b14c2-3c95-471c-b8d0-21262191a5fa.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/638b14c2-3c95-471c-b8d0-21262191a5fa.png)'
- en: Notice here that we provided the four command-line arguments after `go run deploy.go`
    and the script printed out a release URL at the end.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在`go run deploy.go`之后提供了四个命令行参数，脚本在最后打印出了发布URL。
- en: 'Let us go to the Releases tab in the `multiple-languages` ([https://github.com/packtci/multiple-languages/releases](https://github.com/packtci/multiple-languages/releases))
    repository and click on our new release, which looks like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到`multiple-languages`（[https://github.com/packtci/multiple-languages/releases](https://github.com/packtci/multiple-languages/releases)）存储库中的Releases选项卡，并单击我们的新发布，它看起来像这样：
- en: '![](assets/50c11e35-f9cc-4b21-8fee-ed1e4925eb47.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/50c11e35-f9cc-4b21-8fee-ed1e4925eb47.png)'
- en: Best practices for a deployment script
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署脚本的最佳实践
- en: It is best to automate the deployment process when releasing new software for
    your consumers. It is not necessary to create a custom deployment script as we
    have done here as their are great libraries that you can use that are more structured
    and feature rich than this small script that we wrote. For example, you can use
    the **GoReleaser** ([https://goreleaser.com/](https://goreleaser.com/)) automation
    release script that works fantastically  for Go projects. There are many libraries
    available that are language-specific as well as options in CI providers, such
    TravisCI ,that will deploy your software to providers, such as the Google App
    Engine ([https://docs.travis-ci.com/user/deployment/google-app-engine/](https://docs.travis-ci.com/user/deployment/google-app-engine/))
    and more.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在为消费者发布新软件时，最好自动化部署过程。不必像我们在这里所做的那样创建自定义部署脚本，因为有很多优秀的库可供使用，它们比我们编写的这个小脚本更结构化和功能丰富。例如，您可以使用**GoReleaser**（[https://goreleaser.com/](https://goreleaser.com/)）自动化发布脚本，非常适用于Go项目。还有许多可用的库是特定于语言的，以及CI提供者的选项，例如TravisCI，可以将您的软件部署到提供者，例如Google
    App Engine（[https://docs.travis-ci.com/user/deployment/google-app-engine/](https://docs.travis-ci.com/user/deployment/google-app-engine/)）等。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this last chapter, we covered best practices for different types of tests
    in a CI/CD pipeline, including unit tests, integration tests, system tests, and
    acceptance tests. We provided code examples and showed ways of how to test an
    API endpoint using Node.js, Golang, and a shell script. We covered best practices
    in password management and showed how to use the Vault library to securely manage
    secrets and showed how to use the Vault API. We finished the chapter by showing
    some best practices regarding deployment. We talked about a deployment checklist,
    release automation, and we wrote a custom release script in Golang to create a
    GitHub release.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这最后一章中，我们涵盖了CI/CD流水线中不同类型测试的最佳实践，包括单元测试、集成测试、系统测试和验收测试。我们提供了代码示例，并展示了如何使用Node.js、Golang和shell脚本测试API端点的方法。我们介绍了密码管理的最佳实践，并展示了如何使用Vault库安全管理秘密以及如何使用Vault
    API。我们最后讨论了一些关于部署的最佳实践，包括部署清单、发布自动化以及使用Golang编写自定义发布脚本。
- en: This is the end of the book and I hope that you have learned a lot about CI/CD,
    testing and automation, and using Jenkins CI, CircleCI, and Travis CI.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是书的结尾，我希望您已经学到了很多关于CI/CD、测试和自动化以及使用Jenkins CI、CircleCI和Travis CI的知识。
- en: Questions
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is it important to separate integration tests from unit tests?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么将集成测试与单元测试分开很重要？
- en: What is a commit stage?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交阶段是什么？
- en: Name a type of system test.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提到一种系统测试类型。
- en: What was the name of the password management tool that we used?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用的密码管理工具的名称是什么？
- en: Why should you be careful with execution tracing in a shell script?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在shell脚本中要小心执行跟踪？
- en: Name one item that we mentioned in the deployment checklist.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提到部署清单中的一项内容。
- en: What was the name of the deployment tool that we mentioned for Golang?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们提到的Golang的部署工具的名称是什么？
- en: Further reading
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: You should check out the book called *Continuous Integration, Delivery, and
    Deployment* ([https://www.packtpub.com/application-development/continuous-integration-delivery-and-deployment](https://www.packtpub.com/application-development/continuous-integration-delivery-and-deployment))
    by Packt Publishing to learn more about best practices with CI/CD.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看Packt Publishing出版的书籍*Continuous Integration, Delivery, and Deployment*（[https://www.packtpub.com/application-development/continuous-integration-delivery-and-deployment](https://www.packtpub.com/application-development/continuous-integration-delivery-and-deployment)）了解更多有关CI/CD最佳实践的知识。
