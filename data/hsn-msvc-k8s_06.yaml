- en: Securing Microservices on Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes上保护微服务
- en: In this chapter, we will examine how to secure your microservices on Kubernetes
    in depth. This is a broad topic and we will focus on the aspects that are most
    relevant to developers who are building and deploying microservices in a Kubernetes
    cluster. You must be very rigorous with security because your adversaries will
    actively try to find cracks, infiltrate your system, access sensitive information,
    run botnets, steal your data, corrupt your data, destroy your data, and make your
    system unavailable. Security should be designed into the system and not sprinkled
    on top as an afterthought. We will address this by covering general security principles
    and best practices before delving into the security mechanisms that Kubernetes
    puts at your disposal.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究如何在Kubernetes上保护您的微服务。这是一个广泛的主题，我们将专注于对于在Kubernetes集群中构建和部署微服务的开发人员最相关的方面。您必须非常严格地处理安全问题，因为您的对手将积极尝试找到漏洞，渗透您的系统，访问敏感信息，运行僵尸网络，窃取您的数据，破坏您的数据，销毁您的数据，并使您的系统不可用。安全性应该设计到系统中，而不是作为事后的附加物。我们将通过涵盖一般安全原则和最佳实践来解决这个问题，然后深入探讨Kubernetes提供的安全机制。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Applying sound security principles
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用健全的安全原则
- en: Differentiating between user accounts and service accounts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户帐户和服务帐户之间的区分
- en: Managing secrets with Kubernetes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes管理机密
- en: Managing permissions with RBAC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RBAC管理权限
- en: Controlling access with authentication, authorization, and admission
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过身份验证、授权和准入控制访问
- en: Hardening Kubernetes by using security best practices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用安全最佳实践来加固Kubernetes
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will look at a lot of Kubernetes manifests, and make Delinkcious
    more secure. There is no need to install anything new.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看许多Kubernetes清单，并使Delinkcious更安全。没有必要安装任何新内容。
- en: The code
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码
- en: 'The code is split between two Git repositories:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分为两个Git存储库：
- en: You can find the code samples here: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter06)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在此处找到代码示例：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter06)
- en: You can find the updated Delinkcious application here: [https://github.com/the-gigi/delinkcious/releases/tag/v0.4](https://github.com/the-gigi/delinkcious/releases/tag/v0.4)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在此处找到更新的Delinkcious应用程序：[https://github.com/the-gigi/delinkcious/releases/tag/v0.4](https://github.com/the-gigi/delinkcious/releases/tag/v0.4)
- en: Applying sound security principles
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用健全的安全原则
- en: 'There are many universal principles. Let''s review the most important principles
    and understand how they assist in preventing attacks and making attacks more difficult,
    thus minimizing the damage caused by any attack and assisting in recovering from
    these attacks:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多通用原则。让我们回顾最重要的原则，并了解它们如何帮助防止攻击，使攻击变得更加困难，从而最小化任何攻击造成的损害，并帮助从这些攻击中恢复：
- en: '**Defense in depth**: Defense in depth means multiple and redundant layers
    of security. The purpose is to make it difficult for an attacker to compromise
    your system. Multi-factor authentication is a great example. You have a username
    and password, but you must also type in a one-time code that''s sent to your phone.
    If an attacker discovers your credentials, but doesn''t have access to your phone,
    they won''t be able to log in to the system and wreak havoc. There are multiple
    benefits to defense in depth, such as the following:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度防御**：深度防御意味着多层和冗余的安全层。其目的是使攻击者难以破坏您的系统。多因素身份验证是一个很好的例子。您有用户名和密码，但您还必须输入发送到您手机的一次性代码。如果攻击者发现了您的凭据，但无法访问您的手机，他们将无法登录系统并造成破坏。深度防御有多个好处，例如：'
- en: Make your system more secure
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使您的系统更安全
- en: Make the cost of breaking your security too high for an attacker to even try
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使攻破您的安全成本过高，以至于攻击者甚至不会尝试
- en: Better protection from non-malicious mistakes
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好地保护免受非恶意错误
- en: '**Principle of least privilege**: The principle of least privilege is similar
    to the famous *need to know basis* from the spy world. You can''t divulge what
    you don''t know. You can''t compromise what you have no access to. Any agent can
    be compromised. Limiting privileges just to the necessary ones will minimize damage
    if a breach occurs and will help in the auditing, mitigation, and analysis of
    incidents.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小权限原则**：最小权限原则类似于间谍世界中著名的“需要知道基础”。您不能泄露您不知道的东西。您无法破坏您无权访问的东西。任何代理都可能被破坏。仅限制到必要的权限将在违规发生时最小化损害，并有助于审计、缓解和分析事件。'
- en: '**Minimize the attack surface**: This principle is very clear. The smaller
    your attack surface is, the easier it is to protect it. Please keep the following
    things in mind:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化攻击面**：这个原则非常明确。您的攻击面越小，保护起来就越容易。请记住以下几点：'
- en: Don't expose APIs that you don't need
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要暴露您不需要的API
- en: Don't keep data that you don't use
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要保留您不使用的数据
- en: Don't provide different ways to perform the same task
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要提供执行相同任务的不同方式
- en: The most secure code is code that's not written. It's also the most efficient
    and bug-free code. Consider the business value of each new feature you want to
    add very carefully. When migrating to some new technology or system, make sure
    not to leave legacy items behind. In addition to preventing many attack vectors,
    when a breach does occur the smaller attack surface will help a lot in terms of
    focusing the investigation and finding the root cause.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最安全的代码是根本不写代码。这也是最高效和无bug的代码。非常谨慎地考虑要添加的每个新功能的业务价值。在迁移到一些新技术或系统时，请确保不要留下遗留物品。除了防止许多攻击向量外，当发生违规时，较小的攻击面将有助于集中调查并找到根本原因。
- en: '**Minimize the blast radius**: Take it as a given that your system will be
    compromised or may have already been compromised. However, there are different
    levels of threat. Minimizing the blast radius means that compromised components
    can''t easily reach out to other components and spread throughout our system.
    It also means that the resources that are available to those compromised components
    don''t exceed the needs of the legitimate workload that is supposed to run there.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化爆炸半径**：假设您的系统将被破坏或可能已经被破坏。然而，威胁的级别是不同的。最小化爆炸半径意味着受损组件不能轻易接触其他组件并在系统中传播。这也意味着对这些受损组件可用的资源不超过应该在那里运行的合法工作负载的需求。'
- en: '**Trust no one**: Here is a partial list of entities you shouldn''t trust:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要相信任何人**：以下是您不应该信任的实体的部分列表：'
- en: Your users
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的用户
- en: Your partners
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的合作伙伴
- en: Vendors
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商
- en: Your cloud provider
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的云服务提供商
- en: Open source developers
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开源开发人员
- en: Your developers
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的开发人员
- en: Your admins
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的管理员
- en: Yourself
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你自己
- en: Your security
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的安全
- en: When we say *don't trust*, we don't mean that necessarily in a malicious way.
    Everyone is fallible and honest mistakes can be just as detrimental as targeted
    attacks. The great thing about the *Trust no one* principle is that you don't
    have to make a judgement call. The same approach of minimal trust will help you
    prevent and mitigate mistakes and attacks.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说*不要相信*时，我们并不是恶意的。每个人都是可犯错误的，诚实的错误可能会和有针对性的攻击一样有害。*不要相信任何人*原则的伟大之处在于你不必做出判断。最小信任的相同方法将帮助你预防和减轻错误和攻击。
- en: '**Be conservative**: The Lindy effect says that for some non-perishable things,
    the longer they exist, the longer you can expect them to exist. For example, if
    a restaurant exists for 20 years, you can expect it to exist for many more years,
    whereas a brand new restaurant that has just opened is much more likely to shut
    down within a short period of time. This is very true for software and technology.
    The latest JavaScript framework may have the lifetime expectancy of a fruit fly,
    but something like jQuery will be around for a while. From a security standpoint,
    there are other benefits from using more mature and battle-hardened software whose
    security has undergone a baptism of fire. It''s often better to learn from other
    people''s experiences. Take the following things into account:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保守一点**：林迪效应表明，对于一些不易腐烂的东西，它们存在的时间越长，你就可以期待它们存在的时间越长。例如，如果一家餐厅存在了20年，你可以期待它还会存在很多年，而一个刚刚开业的全新餐厅更有可能在短时间内关闭。这对软件和技术来说非常真实。最新的JavaScript框架可能只有短暂的寿命，但像jQuery这样的东西会存在很长时间。从安全的角度来看，使用更成熟和经过严峻考验的软件会有其他好处，其安全性经受了严峻考验。从别人的经验中学习往往更好。考虑以下事项：'
- en: Don't upgrade to the latest and greatest (unless explicitly fixing a security
    vulnerability).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要升级到最新和最好的（除非明确修复了安全漏洞）。
- en: Prefer stability over ability.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更看重稳定性而不是能力。
- en: Prefer simplicity over power.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更看重简单性而不是强大性。
- en: This goes hand in hand with the *trust no one* principle. Don't trust new shiny
    stuff and don't trust newer versions of your current dependencies. Of course,
    microservices and Kubernetes are relatively new technologies and the ecosystem
    is evolving fast. In this case, I assume that you've made a decision that the
    overall benefits of these innovations and their current status are mature enough
    to build on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这与*不要相信任何人*原则相辅相成。不要相信新的闪亮东西，也不要相信你当前依赖的新版本。当然，微服务和Kubernetes是相对较新的技术，生态系统正在快速发展。在这种情况下，我假设你已经做出了决定，认为这些创新的整体好处和它们当前的状态已经足够成熟，可以进行建设。
- en: '**Be vigilant**: Security is not a one-shot thing. You have to actively keep
    working on it. The following are globally some ongoing activities you should perform
    and processes you should follow:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持警惕**：安全不是一劳永逸的事情。你必须积极地继续努力。以下是一些你应该执行的全球性持续活动和流程：'
- en: Patch your systems regularly.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期打补丁。
- en: Rotate your secrets.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转你的秘密。
- en: Use short-lived keys, tokens, and certificates.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用短寿命的密钥、令牌和证书。
- en: Follow up on CVEs.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟进CVEs。
- en: Audit everything.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计一切。
- en: Test the security of your systems.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你系统的安全性。
- en: '**Be ready**: When the inevitable breach happens, be ready and ensure you do
    or have done the following:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**做好准备**：当不可避免的违规发生时，做好准备并确保你已经或正在做以下事情：'
- en: Set up an incident management protocol.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立一个事件管理协议。
- en: Follow your protocol.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循你的协议。
- en: Plug the holes.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堵住漏洞。
- en: Restore system security.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复系统安全。
- en: Perform post-mortem for security incidents.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行安全事件的事后分析。
- en: Evaluate and learn.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估和学习。
- en: Update your process, tools, and security to improve your security posture.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新你的流程、工具和安全性以提高你的安全姿态。
- en: '**Do not write your own crypto**: A lot of people are excited about crypto
    and/or are disappointed when a strong crypto impacts performance. Contain your
    excitement and/or disappointment. Let the experts do crypto. It''s much harder
    than it seems and the stakes are too high.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要编写自己的加密算法**：很多人对加密算法感到兴奋和/或失望，当强加密影响性能时。控制你的兴奋和/或失望。让专家来做加密。这比看起来要困难得多，风险也太高了。'
- en: Now that we're clear about the general principles of good security, let's look
    at what Kubernetes offers in terms of security.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们清楚了良好安全性的一般原则，让我们来看看Kubernetes在安全方面提供了什么。
- en: Differentiating between user accounts and service accounts
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分用户账户和服务账户
- en: 'Accounts are a central concept in Kubernetes. Every request to the Kubernetes
    API server must originate from a particular account that the API server will authenticate,
    authorize, and admit before going through with it. There are two types of account:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 账户是Kubernetes中的一个核心概念。对Kubernetes API服务器的每个请求都必须来自一个特定的账户，API服务器将在进行操作之前对其进行身份验证、授权和准入。有两种类型的账户：
- en: User accounts
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户账户
- en: Service accounts
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务账户
- en: Let's examine both account types and understand the differences and when it's
    appropriate to use each one.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查两种账户类型，并了解它们之间的区别以及在何时适合使用每种类型。
- en: User accounts
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户账户
- en: User accounts are for humans (cluster administrators or developers) who typically
    operate Kubernetes from the outside via kubectl or programmatically. End users
    shouldn't have Kubernetes user accounts, only application-level user accounts.
    This is unrelated to Kubernetes. Remember, Kubernetes manages your containers
    for you – it has no idea what's going on inside and what your application is actually
    doing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 用户账户是为人类（集群管理员或开发人员）设计的，他们通常通过kubectl或以编程方式从外部操作Kubernetes。最终用户不应该拥有Kubernetes用户账户，只能拥有应用级别的用户账户。这与Kubernetes无关。请记住，Kubernetes会为您管理容器-它不知道容器内部发生了什么，也不知道您的应用实际在做什么。
- en: 'Your user credentials are stored in the `~/.kube/config` file. If you are working
    with multiple clusters, then you may have multiple clusters, users, and contexts
    in your `~/.kube/config` file. Some people prefer to have a separate config file
    for each cluster and switch between them using the `KUBECONFIG` environment variable.
    This is up to you. The following is my config file for a local Minikube cluster:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您的用户凭据存储在`~/.kube/config`文件中。如果您正在使用多个集群，则您的`~/.kube/config`文件中可能有多个集群、用户和上下文。有些人喜欢为每个集群单独创建一个配置文件，并使用`KUBECONFIG`环境变量在它们之间切换。这取决于您。以下是我本地Minikube集群的配置文件：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see in the preceding code block, this is a YAML file that follows
    the conventions of typical Kubernetes resources, although it''s not an object
    you can create in your cluster. Note that everything is plural: clusters, contexts,
    users. In this case, there is just one cluster and one user. However, you can
    create multiple contexts that are a combination of clusters and users so that
    you have multiple users with different privileges in the same cluster, or even
    multiple clusters in the same Minikube configuration file. `current-context` determines
    the target of each operation of `kubectl` (which cluster to access with what user
    credentials). User accounts have cluster-scope, which means that we can access
    resources in any namespace.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上面的代码块中所看到的，这是一个遵循典型Kubernetes资源约定的YAML文件，尽管它不是您可以在集群中创建的对象。请注意，一切都是复数形式：集群、上下文、用户。在这种情况下，只有一个集群和一个用户。但是，您可以创建多个上下文，这些上下文是集群和用户的组合，这样您就可以在同一个集群中拥有不同权限的多个用户，甚至在同一个Minikube配置文件中拥有多个集群。`current-context`确定了`kubectl`的每个操作的目标（使用哪个用户凭据访问哪个集群）。用户账户具有集群范围，这意味着我们可以访问任何命名空间中的资源。
- en: Service accounts
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务账户
- en: Service accounts are a different story. Each pod has a service account associated
    with it, and all the workloads running in this pod use that service account as
    their identity. Service accounts are scoped to a namespace. When you create a
    pod (directly or via a deployment), you may specify a service account. If you
    create a pod without specifying a service account, then the namespace's default
    service account is used. Each service account has a secret associated with it
    for talking to the API server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 服务帐户是另一回事。每个pod都有一个与之关联的服务帐户，并且在该pod中运行的所有工作负载都使用该服务帐户作为其身份。服务帐户的范围限定为命名空间。当您创建一个pod（直接或通过部署）时，可以指定一个服务帐户。如果创建pod而没有指定服务帐户，则使用命名空间的默认服务帐户。每个服务帐户都有一个与之关联的秘密，用于与API服务器通信。
- en: 'The following block shows the default service account in the default namespace:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块显示了默认命名空间中的默认服务帐户：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The service account can have more than one secret. We will talk about secrets
    very soon. The service account allows the code running in the pod to talk to the
    API server.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 服务帐户可以有多个秘密。我们很快将讨论秘密。服务帐户允许在pod中运行的代码与API服务器通信。
- en: 'You can fetch a token and CA certificate from: `/var/run/secrets/kubernetes.io/serviceaccount`
    and then construct a `REST HTTP` request by passing these credentials via an authorization
    header. For example, the following code block shows a request to list pods in
    the default namespace:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`/var/run/secrets/kubernetes.io/serviceaccount`获取令牌和CA证书，然后通过授权标头传递这些凭据来构造`REST
    HTTP`请求。例如，以下代码块显示了在默认命名空间中列出pod的请求：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The result is 403 forbidden. The default service account is not allowed to list
    the pods, and actually it's not allowed to do anything. In the `Authorization`
    section, we will see how to grant privileges to service accounts.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是403禁止。默认服务帐户不允许列出pod，实际上它不允许做任何事情。在`授权`部分，我们将看到如何授予服务帐户权限。
- en: If you don't feel comfortable with manually constructing curl requests, you
    can also do it programmatically via the client library. I created a Python-based
    Docker image that includes the official Python client ([https://github.com/kubernetes-client/python](https://github.com/kubernetes-client/python))
    library for Kubernetes and a few other goodies, such as vim, IPython, and HTTPie.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不喜欢手动构造curl请求，也可以通过客户端库以编程方式执行。我创建了一个基于Python的Docker镜像，其中包括Kubernetes的官方Python客户端库（[https://github.com/kubernetes-client/python](https://github.com/kubernetes-client/python)）以及一些其他好东西，如vim、IPython和HTTPie。
- en: 'Here is the Dockerfile that builds the image:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建镜像的Dockerfile：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'I uploaded it to DockerHub as `g1g1/py-kube:0.2`. Now, we can run it as a pod
    in the cluster and have a nice troubleshooting or interactive exploration session:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我将其上传到DockerHub作为`g1g1/py-kube:0.2`。现在，我们可以在集群中将其作为一个pod运行，并进行良好的故障排除或交互式探索会话：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Executing the preceding command will drop you into a command-line prompt where
    you can do whatever you want with Python, IPython, HTTPie, and of course the Kubernetes
    Python client package that''s available. Here is how we can list the pods in the
    default namespace from Python:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述命令将使您进入一个命令行提示符，您可以在其中使用Python、IPython、HTTPie以及可用的Kubernetes Python客户端包做任何您想做的事情。以下是我们如何从Python中列出默认命名空间中的pod：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result will be similar – a Python exception – because the default account
    is forbidden to list pods. Note that, if your pod doesn''t need to access the
    API server (very common), you can make it explicit by setting `automountServiceAccountToken:
    false`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '结果将类似 - 一个Python异常 - 因为默认帐户被禁止列出pod。请注意，如果您的pod不需要访问API服务器（非常常见），您可以通过设置`automountServiceAccountToken:
    false`来明确表示。'
- en: This can be done at the service account level or in the pod spec. This way,
    even if something or someone outside your control adds permissions to the service
    account at a later date, since there is no token mounted, the pod will fail to
    authenticate to the API server and will not get unintended access. Delinkcious
    services currently have no need to access the API server, so by following the
    principle of least privilege, we can add this to their spec in the deployment.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在服务账户级别或pod规范中完成。这样，即使在以后有人或某物在您的控制之外添加了对服务账户的权限，由于没有挂载令牌，pod将无法对API服务器进行身份验证，并且不会获得意外访问。Delinkcious服务目前不需要访问API服务器，因此通过遵循最小权限原则，我们可以将其添加到部署中的规范中。
- en: 'Here is how you can create a service account for the LinkManager (without access
    to the API server)  and add it to the deployment:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何为LinkManager创建服务账户（无法访问API服务器）并将其添加到部署中：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Before granting our service account super powers using RBAC, let's review how
    Kubernetes manages secrets. Kubernetes stores secrets in etcd by default. It is
    possible to integrate etcd with third-party solutions, but in this section we
    will focus on vanilla Kubernetes. Secrets should be encrypted at rest and in transit,
    and etcd has supported this since version 3.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用RBAC授予我们的服务账户超级权限之前，让我们回顾一下Kubernetes如何管理秘密。Kubernetes默认情况下将秘密存储在etcd中。可以将etcd与第三方解决方案集成，但在本节中，我们将专注于原始的Kubernetes。秘密应该在静止和传输中进行加密，etcd自版本3以来就支持了这一点。
- en: Now that we understand how accounts work in Kubernetes, let's see how to manage
    secrets.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了Kubernetes中账户如何工作，让我们看看如何管理秘密。
- en: Managing secrets with Kubernetes
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes管理秘密
- en: Before granting our service account super powers using RBAC, let's review how
    Kubernetes manages secrets. Kubernetes stores secrets in etcd ([https://coreos.com/etcd/](https://coreos.com/etcd/))
    by default. There are different types of secret Kubernetes can manage. Let's look
    at the various secret types and then create our own secrets and pass them to containers.
    Finally, we'll build a secure pod together.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用RBAC授予我们的服务账户超级权限之前，让我们回顾一下Kubernetes如何管理秘密。Kubernetes默认情况下将秘密存储在etcd ([https://coreos.com/etcd/](https://coreos.com/etcd/))中。Kubernetes可以管理不同类型的秘密。让我们看看各种秘密类型，然后创建我们自己的秘密并将它们传递给容器。最后，我们将一起构建一个安全的pod。
- en: Understanding the three types of Kubernetes secret
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Kubernetes秘密的三种类型
- en: 'There are three distinct types of secret:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种不同类型的秘密：
- en: Service account API token (credentials for talking to the API server)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务账户API令牌（用于与API服务器通信的凭据）
- en: Registry secret (credentials for pulling images from private registries)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册表秘密（用于从私有注册表中拉取图像的凭据）
- en: Opaque secret (your secrets that Kubernetes knows nothing about)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不透明秘密（Kubernetes一无所知的您的秘密）
- en: 'The service account API token is built-in for each service account (unless
    you specified `automountServiceAccountToken: false` ). Here is the secret for
    the service account API token for the `link-manager`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '服务账户API令牌是每个服务账户内置的（除非您指定了`automountServiceAccountToken: false`）。这是`link-manager`的服务账户API令牌的秘密：'
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `pull secrets` image is a little more complicated. Different private registries
    behave differently and require different secrets. Also, some private registries
    require that you refresh your tokens often. Let''s look at an example with DockerHub.
    DockerHub lets you have a single private repository by default. I converted `py-kube` into
    a private repository, as shown in the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`pull secrets`图像稍微复杂一些。不同的私有注册表行为不同，并且需要不同的秘密。此外，一些私有注册表要求您经常刷新令牌。让我们以DockerHub为例。DockerHub默认情况下允许您拥有单个私有存储库。我将`py-kube`转换为私有存储库，如下截图所示：'
- en: '![](assets/bf7fadd6-8d83-4238-9652-66c89f6bd039.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/bf7fadd6-8d83-4238-9652-66c89f6bd039.png)
- en: 'I deleted the local Docker image. To pull it, I need to create a registry secret:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我删除了本地Docker镜像。要拉取它，我需要创建一个注册表机密：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The last type of secret is `Opaque` and is the most interesting type of secret.
    You store your sensitive information in opaque secrets that Kubernetes doesn''t
    touch. It just provides you with a robust and secure store for your secrets and
    an API for creating, reading, and updating those secrets. You can create opaque
    secrets in many ways, such as the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种类型的机密是`Opaque`，是最有趣的机密类型。您可以将敏感信息存储在Kubernetes不会触及的不透明机密中。它只为您提供了一个强大且安全的机密存储库，并提供了一个用于创建、读取和更新这些机密的API。您可以通过许多方式创建不透明机密，例如以下方式：
- en: From literal values
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文字值
- en: From a file or directory
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件或目录
- en: From an `env` file (key-value pairs in separate lines)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`env`文件（单独行中的键值对）
- en: Create a YAML manifest with `kind`
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`kind`创建一个YAML清单
- en: This is very similar to ConfigMaps. Now, let's create some secrets.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这与ConfigMaps非常相似。现在，让我们创建一些机密。
- en: Creating your own secrets
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您自己的机密
- en: 'One of the simplest and most useful ways to create secrets is via a simple
    `env` file that contains key-value pairs:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 创建机密的最简单和最有用的方法之一是通过包含键值对的简单`env`文件：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can create a secret by using the `-o yaml` flag (YAML output format) to
    see what was created:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-o yaml`标志（YAML输出格式）来创建一个机密，以查看创建了什么：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The type is `Opaque` and the returned values are base64-encoded. To fetch the
    values and decode them, you can use the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是`Opaque`，返回的值是base64编码的。要获取这些值并解码它们，您可以使用以下命令：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `jsonpath` output format lets you drill-down into specific parts of the
    object. You can also use `jq` ([https://stedolan.github.io/jq/](https://stedolan.github.io/jq/))
    if you prefer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsonpath`输出格式允许您深入到对象的特定部分。如果您喜欢，您也可以使用`jq`（[https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)）。'
- en: Note that secrets are not stored or transmitted; they are just encrypted or
    encoded in base-64, which anyone can decode. When you create a secret using your
    user account (or get secrets), you get back the base-64 encoded representation
    of the decrypted secret. However, it is encrypted at rest on disk and also encrypted
    in transit since you communicate with the Kubernetes API server over HTTPS.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，机密不会被存储或传输；它们只是以base-64进行加密或编码，任何人都可以解码。当您使用您的用户帐户创建机密（或获取机密）时，您会得到解密后机密的base-64编码表示。但是，它在磁盘上是加密的，并且在传输过程中也是加密的，因为您是通过HTTPS与Kubernetes
    API服务器通信的。
- en: Now that we have understood how to create secrets, we will make them available
    to workloads that are running in containers.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何创建机密，我们将使它们可用于在容器中运行的工作负载。
- en: Passing secrets to containers
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将机密传递给容器
- en: 'There are many ways to pass secrets to containers, such as the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以将机密传递给容器，例如以下方法：
- en: You can bake secrets into the container image.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将机密嵌入到容器镜像中。
- en: You can pass them into environment variables.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将它们传递到环境变量中。
- en: You can mount them as files.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将它们挂载为文件。
- en: The most secure way is to mount your secrets as files. When you bake your secret
    into the image, anyone with access to the image can retrieve your secrets. When
    you pass your secrets as environment variables, they can be viewed via `docker
    inspect`, `kubectl describe pod`, and by child processes if you don't clean up
    the environment. In addition, it is common to log your entire environment when
    reporting an error, which takes discipline from all your developers to sanitize
    and redact secrets. Mounted files don't suffer from these weaknesses, but note
    that anyone who can `kubectl exec` into your container can examine any mounted
    files, including secrets, if you don't manage permissions carefully.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最安全的方式是将你的秘密作为文件挂载。当你将你的秘密嵌入到镜像中时，任何有权访问镜像的人都可以检索你的秘密。当你将你的秘密作为环境变量传递时，它们可以通过`docker
    inspect`、`kubectl describe pod`以及如果你不清理环境的话，子进程也可以查看。此外，通常在报告错误时记录整个环境，这需要所有开发人员的纪律来清理和编辑秘密。挂载的文件不会受到这些弱点的影响，但请注意，任何可以`kubectl
    exec`进入你的容器的人都可以检查任何挂载的文件，包括秘密，如果你不仔细管理权限的话。
- en: 'Let''s create a secret from a YAML manifest. When choosing this method, it''s
    your responsibility to base64-encode the values:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个YAML清单中创建一个秘密。选择这种方法时，你有责任对值进行base64编码：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s create the new secrets and verify that they were created successfully
    by getting them using `kubectl get secret`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建新的秘密，并通过使用`kubectl get secret`来验证它们是否成功创建：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we know how to create opaque/generic secrets and pass them to containers,
    let's connect all the dots and build a secure pod.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何创建不透明/通用的秘密并将它们传递给容器，让我们把所有的点连接起来，构建一个安全的pod。
- en: Building a secure pod
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个安全的pod
- en: The pod has a custom service that doesn't need to talk to the API server (so
    there's no need to auto-mount a service account token); instead, the pod offers `imagePullSecret`
    to pull our private repository and also has some generic secrets mounted as a
    file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该pod有一个自定义服务，不需要与API服务器通信（因此不需要自动挂载服务账户令牌）；相反，该pod提供`imagePullSecret`来拉取我们的私有仓库，并且还挂载了一些通用秘密作为文件。
- en: 'Let''s get started and learn how to build a secure pod:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始学习如何构建一个安全的pod：
- en: 'The first step is the custom service account. Here is the YAML manifest:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是自定义服务账户。以下是YAML清单：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s create it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建它：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we''ll attach it to our pod and also set the `imagePullSecret` we created
    earlier. There''s a lot going on here. I attached a custom service account, created
    a secret volume that references the `generic-secrets2` secret, then a volume mount
    that mounts it into `/etc/generic-secrets2`; finally, I set `imagePullSecrets`
    to the `private-dockerhub` secret:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将把它附加到我们的pod上，并设置之前创建的`imagePullSecret`。这里有很多事情要做。我附加了一个自定义服务账户，创建了一个引用`generic-secrets2`秘密的秘密卷，然后挂载到`/etc/generic-secrets2`；最后，我将`imagePullSecrets`设置为`private-dockerhub`秘密：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we can create our pod and start playing around:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建我们的pod并开始玩耍：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Kubernetes was able to pull the image from the private repository. We expect
    no API server token (there shouldn''t be `/var/run/secrets/kubernetes.io/serviceaccount/`),
    and our secrets should be mounted as files in `/etc/generic-secrets2`. Let''s
    verify this by starting an interactive shell using `kubectl exec -it` and check
    that the service account file doesn''t exist, but that the generic secrets `c`
    and `d` do:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes能够从私有仓库中拉取镜像。我们不希望有API服务器令牌（`/var/run/secrets/kubernetes.io/serviceaccount/`不应该存在），我们的秘密应该作为文件挂载在`/etc/generic-secrets2`中。让我们通过使用`kubectl
    exec -it`启动一个交互式shell来验证这一点，并检查服务账户文件是否存在，但通用秘密`c`和`d`存在：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Yay, it works!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，它起作用了！
- en: Here, we focused a lot on managing custom secrets and built a secure pod that
    can't access the Kubernetes API server, but often you need to carefully manage
    the access of different entities have to the Kubernetes API server. Kubernetes
    has a well-defined **role-based access control model** (also known as **RBAC**).
    Let's see it in action.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们着重于管理自定义密钥并构建一个无法访问Kubernetes API服务器的安全Pod，但通常您需要仔细管理不同实体对Kubernetes API服务器的访问权限。Kubernetes具有明确定义的**基于角色的访问控制模型**（也称为**RBAC**）。让我们看看它的运作方式。
- en: Managing permissions with RBAC
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RBAC管理权限
- en: 'RBAC is a mechanism that''s used to manage access to Kubernetes resources.
    With effect from Kubernetes 1.8, RBAC is considered stable. Start the API server
    with `--authorization-mode=RBAC` to enable it. RBAC works as follows when a request
    to the API server comes in:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC是用于管理对Kubernetes资源的访问的机制。从Kubernetes 1.8开始，RBAC被认为是稳定的。使用`--authorization-mode=RBAC`启动API服务器以启用它。当请求发送到API服务器时，RBAC的工作原理如下：
- en: First, it authenticates the request via the user credentials or service account
    credentials of the caller (returns 401 unauthorized if it fails).
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它通过调用者的用户凭据或服务账户凭据对请求进行身份验证（如果失败，则返回401未经授权）。
- en: Next, it checks the RBAC policies to verify whether the requester is authorized
    to perform the operation on the target resource (returns 403 forbidden if it fails).
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它检查RBAC策略，以验证请求者是否被授权对目标资源执行操作（如果失败，则返回403禁止）。
- en: Finally, it runs through an admission controller that may reject or modify the
    request for various reasons.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它通过一个准入控制器运行，该控制器可能因各种原因拒绝或修改请求。
- en: The RBAC model consists of identities (user and service accounts), resources
    (Kubernetes objects), verbs (standard actions such as `get`, `list`, and `create`),
    roles, and role bindings. Delinkcious services don't need to access the API server,
    so they don't need access. However, Argo CD, the continuous delivery solution,
    definitely needs access as it deploys our services and all related objects.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC模型由身份（用户和服务账户）、资源（Kubernetes对象）、动词（标准操作，如`get`、`list`和`create`）、角色和角色绑定组成。Delinkcious服务不需要访问API服务器，因此它们不需要访问权限。但是，持续交付解决方案Argo
    CD绝对需要访问权限，因为它部署我们的服务和所有相关对象。
- en: 'Let''s look at the following snippet from a role and understand it in detail.
    You can find the source here: [https://github.com/argoproj/argo-cd/blob/master/manifests/install.yaml#L116](https://github.com/argoproj/argo-cd/blob/master/manifests/install.yaml#L116):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下角色中的以下片段，并详细了解它。您可以在这里找到源代码：[https://github.com/argoproj/argo-cd/blob/master/manifests/install.yaml#L116](https://github.com/argoproj/argo-cd/blob/master/manifests/install.yaml#L116)：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A role has rules. Each rule assigns a list of allowed verbs to each API group
    and resources within that API group. For example, for the empty API group (indicates
    the core API group) and the `configmaps` and `secrets` resources, the Argo CD
    server can apply all of these verbs:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 角色有规则。每个规则将允许的动词列表分配给每个API组和该API组内的资源。例如，对于空的API组（表示核心API组）和`configmaps`和`secrets`资源，Argo
    CD服务器可以应用所有这些动词：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `argoproj.io` API group and the `applications` and `appprojects` resources
    (both are CRDs defined by Argo CD) have another list of verbs. Finally, for the
    `events` resource of the core group, it can only use the `create` or `list` verb:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`argoproj.io` API组和`applications`和`appprojects`资源（都是由Argo CD定义的CRD）有另一个动词列表。最后，对于核心组的`events`资源，它只能使用`create`或`list`动词：'
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: An RBAC role applies only to the namespace it was created in. This means that
    the fact that Argo CD can do anything with `configmaps` and `secrets` is not too
    scary if it's created in a dedicated namespace. As you may recall, I installed
    Argo CD on the cluster in a namespace called `argocd`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC角色仅适用于创建它的命名空间。这意味着Argo CD可以对`configmaps`和`secrets`做任何事情并不太可怕，如果它是在专用命名空间中创建的。您可能还记得，我在名为`argocd`的命名空间中在集群上安装了Argo
    CD。
- en: 'However, similar to a role, RBAC also has a `ClusterRole` where the permissions
    that are listed are allowed across the cluster. Argo CD has cluster roles too.
    For example, `argocd-application-controller` has the following cluster role:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类似于角色，RBAC还有一个`ClusterRole`，其中列出的权限在整个集群中都是允许的。Argo CD也有集群角色。例如，`argocd-application-controller`具有以下集群角色：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This pretty much gives access to anything on the cluster. It is equivalent to
    not having RBAC at all. I'm not sure why the Argo CD application controller needs
    such global access. My guess is that it's just easier to get access to anything
    than explicitly list everything if it's a big list. However, this is not the best
    practice from a security standpoint.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎可以访问集群中的任何内容。这相当于根本没有RBAC。我不确定为什么Argo CD应用程序控制器需要这样的全局访问权限。我猜想这只是为了更容易地访问任何内容，而不是明确列出所有内容，如果是一个很长的列表。然而，从安全的角度来看，这并不是最佳做法。
- en: 'Roles and cluster roles are just a list of permissions. To make it all work,
    you need to bind a role to a set of accounts. That''s where role bindings and
    cluster role bindings come into play. Role bindings only work in their namespace.
    You can role-bind both a role and a cluster role (in which case the cluster role
    will be active in the target namespace only). Here is an example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 角色和集群角色只是一系列权限列表。为了使其正常工作，您需要将角色绑定到一组帐户。这就是角色绑定和集群角色绑定发挥作用的地方。角色绑定仅在其命名空间中起作用。您可以将角色绑定到角色和集群角色（在这种情况下，集群角色仅在目标命名空间中处于活动状态）。这是一个例子：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A cluster role binding applies across the cluster and can bind a cluster role
    only (because a role is restricted to its namespace).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 集群角色绑定适用于整个集群，只能绑定集群角色（因为角色受限于其命名空间）。
- en: Now that we understand how to control access to Kubernetes resources using RBAC,
    let's move on to controlling access to our own microservices.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了如何使用RBAC控制对Kubernetes资源的访问权限，让我们继续控制对我们自己的微服务的访问权限。
- en: Controlling access with authentication, authorization, and admission
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过身份验证、授权和准入来控制访问
- en: Kubernetes has an interesting access control model that goes above and beyond
    standard access control. For your microservices, it provides the troika of authentication,
    authorization, and admission. You're probably familiar with authentication (who
    is calling?) and authorization (what is the caller allowed to do?). Admission
    is not as common. It can be used for a more dynamic situation where a request
    may be rejected, even if the caller is properly authenticated and authorized.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes具有一个有趣的访问控制模型，超出了标准的访问控制。对于您的微服务，它提供了身份验证、授权和准入的三重保证。您可能熟悉身份验证（谁在调用？）和授权（调用者被允许做什么？）。准入并不常见。它可以用于更动态的情况，即使调用者经过了正确的身份验证和授权，也可能被拒绝请求。
- en: Authenticating microservices
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务认证
- en: Service accounts and RBAC are a good solution to manage identity and access
    for Kubernetes objects. However, in a microservice architecture, there will be
    a lot of communication between microservices. This communication happens inside
    the cluster and may be considered less prone to attacks. But the defense in depth
    principle guides us to encrypt, authenticate, and manage this communication as
    well. There are several approaches here. The most robust approach requires your
    own **private key infrastructure** (**PKI**) and **certificate authority** (**CA**)
    that can deal with issuing, revoking, and updating certificates as service instances
    come and go. This is pretty complicated (if you use a cloud provider, they may
    provide it for you). A somewhat simpler approach is to utilize Kubernetes secrets
    and create shared secrets between each of the two services that can talk to each
    other. Then, when a request comes in, we can check whether the calling service
    passed the correct secret, which authenticates it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户和RBAC是管理Kubernetes对象的身份和访问的良好解决方案。然而，在微服务架构中，微服务之间会有大量的通信。这种通信发生在集群内部，可能被认为不太容易受到攻击。但是，深度防御原则指导我们也要加密、认证和管理这种通信。这里有几种方法。最健壮的方法需要你自己的**私钥基础设施**（**PKI**）和**证书颁发机构**（**CA**），可以处理证书的发布、吊销和更新，因为服务实例的出现和消失。这相当复杂（如果你使用云提供商，他们可能会为你提供）。一个相对简单的方法是利用Kubernetes
    secrets，并在每两个可以相互通信的服务之间创建共享的密钥。然后，当请求到来时，我们可以检查调用服务是否传递了正确的密钥，从而对其进行认证。
- en: 'Let''s create a mutual secret for `link-manager` and `graph-manager` (remember
    that it must be base64-encoded):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`link-manager`和`graph-manager`创建一个共享密钥（记住它必须是base64编码的）：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we will create a secret for `link-manager`, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将为`link-manager`创建一个密钥，如下所示：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Never commit secrets to source control. I have done it here for educational
    purposes only.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要将密钥提交到源代码控制。我在这里只是为了教育目的而这样做。
- en: 'To see the value of the secret using `kubectl` and the `jsonpath` format, you
    need to escape the dot in `mutual-auth.yaml`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`kubectl`和`jsonpath`格式查看密钥的值，您需要转义`mutual-auth.yaml`中的点：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We''ll repeat the process for `social-graph-manager`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重复这个过程为`social-graph-manager`：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we will create a secret for `social-graph-manager`, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将为`social-graph-manager`创建一个密钥，如下所示：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'At this point, `link-manager` and `social-graph-manager` have a shared secret
    that we can mount to the respective pods. Here is the pod spec in the `link-manager`
    deployment that mounts the secret from a volume into `/etc/delinkcious`. The secret
    will show up as the `mutual-auth.yaml` file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`link-manager`和`social-graph-manager`有一个共享的密钥，我们可以将其挂载到各自的pod上。这是`link-manager`部署中的pod规范，它将密钥从一个卷挂载到`/etc/delinkcious`。密钥将显示为`mutual-auth.yaml`文件：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can apply the same convention to all services. The result is that each pod
    will have a file called `/etc/delinkcious/mutual-auth.yaml` with the tokens of
    all the services it needs to talk to. Based on this convention, we created a little
    package called `auth_util` that reads the file, populates a couple of maps, and
    exposes a couple of functions for mapping and matching callers and tokens. The
    `auth_util` package expects the file itself to be a YAML file with key-value pairs
    in the format of  `<caller>: <token>`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以将相同的约定应用于所有服务。结果是每个pod都将有一个名为`/etc/delinkcious/mutual-auth.yaml`的文件，其中包含它需要通信的所有服务的令牌。基于这个约定，我们创建了一个叫做`auth_util`的小包，它读取文件，填充了一些映射，并暴露了一些用于映射和匹配调用方和令牌的函数。`auth_util`包期望文件本身是一个YAML文件，格式为`<caller>:
    <token>`的键值对。'
- en: 'Here are the declarations and maps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是声明和映射：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `init()` function reads the file (unless the `env` variable, `DELINKCIOUS_MUTUAL_AUTH`,
    is set to `false`), unmarshals it into the `callersByName` map, and then iterates
    over it and populates the reverse `callersByToken` map, where the tokens are the
    keys and the callers are the values (with possible duplicates):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()`函数读取文件（除非`env`变量`DELINKCIOUS_MUTUAL_AUTH`设置为`false`），将其解组为`callersByName`映射，然后遍历它并填充反向`callersByToken`映射，其中令牌是键，调用者是值（可能重复）：'
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, the `GetToken()` and `HasCaller()` functions provide the external
    interface to the package that''s used by services and clients that communicate
    with each other:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`GetToken()`和`HasCaller()`函数提供了被服务和客户端用来相互通信的包的外部接口：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s see how the link service calls the `GetFollowers()` method of the social
    graph service. The `GetFollowers()` method extracts the authentication token from
    the environment and compares it to the token that''s provided in the headers (this
    is only known to the link service) to verify that the caller is really the link
    service. As usual, the core logic doesn''t change. The entire authentication scheme
    is isolated to the transport and client layers. Since the social graph service
    uses the HTTP transport, the client stores the token in a header called `Delinkcious-Caller-Service`.
    It gets the token from the `auth_util` package via the `GetToken()` function without
    knowing anything about where the secret is coming from (in our case, the Kubernetes
    secret is mounted as a file):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看链接服务如何调用社交图服务的`GetFollowers()`方法。`GetFollowers()`方法从环境中提取认证令牌，并将其与标头中提供的令牌进行比较（这仅为链接服务所知），以验证调用者是否真的是链接服务。与往常一样，核心逻辑不会改变。整个身份验证方案都隔离在传输和客户端层。由于社交图服务使用HTTP传输，客户端将令牌存储在名为`Delinkcious-Caller-Service`的标头中。它通过`auth_util`包的`GetToken()`函数获取令牌，而不知道秘密来自何处（在我们的情况下，Kubernetes秘密被挂载为文件）：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'On the service side, the social graph service transport layer ensures that
    `Delinkcious-Caller-Token` exists and that it contains the token of a valid caller:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务端，社交图服务传输层确保`Delinkcious-Caller-Token`存在，并且包含有效调用者的令牌：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The beauty of this mechanism is that we keep all the gnarly plumbing stuff of
    parsing files and extracting headers from HTTP requests in the transport layer
    and keep the core logic pristine.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制的美妙之处在于，我们将解析文件和从HTTP请求中提取标头等繁琐的管道工作都保留在传输层，并保持核心逻辑原始。
- en: In [Chapter 13](b39834c8-859c-42a5-846a-e48b76dfd6cc.xhtml), *Service Mesh –
    Working with Istio*, we will look at another solution for authenticating microservices
    using a service mesh. Now, let's move on to authorizing microservices.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](b39834c8-859c-42a5-846a-e48b76dfd6cc.xhtml)中，*服务网格-使用Istio工作*，我们将看到使用服务网格对微服务进行身份验证的另一种解决方案。现在，让我们继续授权微服务。
- en: Authorizing microservices
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权微服务
- en: Authorizing microservices can be very simple or very complicated. In the simplest
    case, if a calling microservice is authenticated, then it is authorized to perform
    any operation. However, sometimes, this is not enough and you need very sophisticated
    and fine-grained authorization, depending on other request parameters. For example,
    in a company I used to work at, I developed an authorization scheme for a sensor
    network with both spatial and temporal dimensions. Users could query the data,
    but they might be limited to certain cities, buildings, floors, or rooms.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 授权微服务可能非常简单，也可能非常复杂。在最简单的情况下，如果调用微服务经过身份验证，则被授权执行任何操作。然而，有时这是不够的，您需要根据其他请求参数进行非常复杂和细粒度的授权。例如，在我曾经工作过的一家公司，我为具有空间和时间维度的传感器网络开发了授权方案。用户可以查询数据，但他们可能仅限于特定的城市、建筑物、楼层或房间。
- en: If they requested data from a location they were not authorized to query, their
    request was rejected. They were also limited by time range and couldn't query
    outside their designated time range.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们从未经授权的位置请求数据，他们的请求将被拒绝。他们还受到时间范围的限制，不能在指定的时间范围之外查询。
- en: For Delinkcious, you can imagine that users may be limited to viewing their
    own links and the links of users they follow (if approved).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Delinkcious，您可以想象用户可能只能查看自己的链接和他们关注的用户的链接（如果获得批准）。
- en: Admitting microservices
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 承认微服务
- en: Authentication and authorization are very well-known and familiar mechanisms
    for access control (although not easy to implement robustly). Admission is yet
    another step that follows authorization. Even if a request is authenticated and
    authorized, it may not be possible to satisfy the request at the moment. This
    could be due to a rate limit or some other intermittent issue on the server side.
    Kubernetes implements additional capabilities, such as mutating requests as part
    of admission. For your own microservices, it may not be needed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证和授权是非常著名和熟悉的访问控制机制（尽管难以强大地实施）。准入是跟随授权的另一步。即使请求经过身份验证和授权，也可能无法立即满足请求。这可能是由于服务器端的速率限制或其他间歇性问题。Kubernetes实现了额外的功能，例如作为准入的一部分改变请求。对于您自己的微服务，可能并不需要这样做。
- en: So far, we have discussed accounts, secrets, and access control. However, there's
    still a lot of work to be done in order to get closer to a secure and hardened
    cluster.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了帐户、秘密和访问控制。然而，为了更接近一个安全和加固的集群，还有很多工作要做。
- en: Hardening your Kubernetes cluster using security best practices
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用安全最佳实践加固您的Kubernetes集群
- en: In this section, we will cover various best practices and we'll see how close
    Delinkcious gets to getting it right.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍各种最佳实践，并看看Delinkcious离正确的方式有多近。
- en: Securing your images
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护您的镜像
- en: One of the top priorities is making sure that the images that you deploy to
    the cluster are secure. There are several good guidelines to follow here.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的之一是确保您部署到集群的镜像是安全的。这里有几个很好的指导方针要遵循。
- en: Always pull images
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 始终拉取镜像
- en: 'In the container spec, there is an optional key called `ImagePullPolicy`. The
    default is `IfNotPresent`. There are a few problems with this default, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器规范中，有一个名为`ImagePullPolicy`的可选键。默认值是`IfNotPresent`。这个默认值有一些问题，如下所示：
- en: If you use tags such as *latest* (you shouldn't), then you will not pick up
    updated images.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用*latest*等标签（您不应该这样做），那么您将无法获取更新的镜像。
- en: You may have conflicts with other tenants on the same node.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能会与同一节点上的其他租户发生冲突。
- en: Other tenants on the same node can run your images.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一节点上的其他租户可以运行您的镜像。
- en: Kubernetes has an admission controller called `AlwaysPullImages` that sets the
    `ImagePullPolicy` of every pod to `AlwaysPullImages`. This prevents all the issues
    at the expense of pulling images, even if they are present and you had the right
    to use them. You turn on this admission controller by adding it to the list of
    enabled admission controllers that are passed to `kube-apiserver` via the `--enable-admission-controllers` flag.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes有一个名为`AlwaysPullImages`的准入控制器，它将每个pod的`ImagePullPolicy`设置为`AlwaysPullImages`。这可以防止所有问题，但会拉取镜像，即使它们已经存在并且您有权使用它们。您可以通过将其添加到传递给`kube-apiserver`的启用准入控制器列表中的`--enable-admission-controllers`标志来启用此准入控制器。
- en: Scan for vulnerabilities
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描漏洞
- en: Vulnerabilities in your code or dependencies allow attackers to get access to
    your system. The national vulnerability database ([https://nvd.nist.gov/](https://nvd.nist.gov/))
    is a good place to learn about new vulnerabilities and processes for managing
    them, such as the **Security Content Automation Protocol** (**SCAP**).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 代码或依赖项中的漏洞会使攻击者能够访问你的系统。国家漏洞数据库（[https://nvd.nist.gov/](https://nvd.nist.gov/)）是了解新漏洞和管理漏洞的流程的好地方，比如**安全内容自动化协议**（**SCAP**）。
- en: Open-source solutions such as Claire ([https://github.com/coreos/clair](https://github.com/coreos/clair))
    and Anchore ([https://anchore.com/kubernetes/](https://anchore.com/kubernetes/))
    are available, as well as commercial solutions. Many image registries provide
    scanning services too.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 开源解决方案，如Claire（[https://github.com/coreos/clair](https://github.com/coreos/clair)）和Anchore（[https://anchore.com/kubernetes/](https://anchore.com/kubernetes/)）可用，还有商业解决方案。许多镜像注册表也提供扫描服务。
- en: Update your dependencies
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新你的依赖项
- en: Keep your dependencies up-to-date, especially if they fix known vulnerabilities.
    This is where you need to find the right balance between being vigilant and being
    conservative.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 保持依赖项的最新状态，特别是如果它们修复了已知的漏洞。在这里，你需要在警惕和保守之间找到合适的平衡。
- en: Pinning the versions of your base images
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固定基础镜像的版本
- en: Pinning versions of base images is critical for ensuring repeatable builds.
    If your base image version is not specified, you will pick up the latest version,
    which may or may not be what you want.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 基础镜像的版本固定对于确保可重复构建至关重要。如果未指定基础镜像的版本，将会获取最新版本，这可能并非你想要的。
- en: Using minimal base images
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用最小的基础镜像
- en: The principle of minimizing the attack surface exhorts you to use as many minimal
    base images as possible; the smaller and more restricted, the better. In addition
    to these security benefits, you also enjoy faster pulling and pushing (although
    layers should make it relevant only when upgrading your base image). Alpine is
    a very popular base image. Delinkcious services take this approach to the extreme
    and use the `SCRATCH` image as a base image.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化攻击面的原则敦促你尽可能使用最小的基础镜像；越小越受限制，越好。除了这些安全好处，你还可以享受更快的拉取和推送（尽管层只有在升级基础镜像时才会使其相关）。Alpine是一个非常受欢迎的基础镜像。Delinkcious服务采用了极端的方法，使用`SCRATCH`镜像作为基础镜像。
- en: Pretty much the entire service is just the Go executable, and that's it. It's
    small, fast, and secure, but you pay for it when you need to troubleshoot issues
    and there are no tools to help you.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎整个服务只是一个Go可执行文件，就是这样。它小巧、快速、安全，但当你需要解决问题时，你会为此付出代价，因为没有工具可以帮助你。
- en: If we follow all of these guidelines, our images will be secure, but we should
    still apply the basic principles of least privilege and zero trust, and minimize
    the blast radius at the network level. If a container, pod, or node somehow gets
    compromised, they shouldn't be allowed to reach another part of the network except
    what's needed by the workloads running on these components. This is where namespaces
    and network policies come into the picture.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遵循所有这些准则，我们的镜像将是安全的，但我们仍应用最小权限和零信任的基本原则，并在网络层面最小化影响范围。如果容器、Pod或节点某种方式被 compromise，它们不应该被允许访问网络的其他部分，除非是工作负载运行所需的。这就是命名空间和网络策略发挥作用的地方。
- en: Dividing and conquering your network
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 划分和征服你的网络
- en: In addition to authentication as part of defense in depth, you can ensure that
    services talk to each other only if they're supposed to by utilizing namespaces
    and network policies.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 除了身份验证作为深度防御的一部分，你还可以通过使用命名空间和网络策略来确保服务只有在必要时才能相互通信。
- en: Namespaces are a very intuitive yet powerful concept. However, on their own,
    they don't prevent pods in the same cluster from communicating with each other.
    In Kubernetes, all the pods in a cluster share the same flat networking address
    space. This is one of the great simplifications of the Kubernetes networking module.
    Your pods can be on the same nodes or a different node – it doesn't matter.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是一个非常直观但强大的概念。然而，它们本身并不能阻止同一集群中的pod相互通信。在Kubernetes中，集群中的所有pod共享相同的平面网络地址空间。这是Kubernetes网络模块的一个很大的简化之一。你的pod可以在同一节点上，也可以在不同的节点上
    - 这并不重要。
- en: Each pod will have its own IP address (even if multiple pods run on the same
    physical node or VM with a single IP address). This is where network policies
    come into the picture. A network policy is basically a set of rules that specify
    both intra-cluster communication between pods (east-west traffic), as well as
    communication between services in the cluster and the outside world (north-south
    traffic). If no network policy is specified, all incoming traffic (ingress) is
    allowed by default on all the ports of every pod. From a security perspective,
    this is unacceptable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每个pod都有自己的IP地址（即使多个pod在同一物理节点或VM上运行，只有一个IP地址）。这就是网络策略的作用。网络策略基本上是一组规则，指定了pod之间的集群内通信（东西流量），以及集群中服务与外部世界之间的通信（南北流量）。如果没有指定网络策略，所有传入流量（入口）默认情况下都允许访问每个pod的所有端口。从安全的角度来看，这是不可接受的。
- en: 'Let''s start by blocking all ingress and later open up selectively as needed:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先阻止所有的入口流量，然后根据需要逐渐开放：
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that network policies work at the pod level. You specify pods with labels,
    which is one of the primary reasons why you should properly group your pods using
    meaningful labels.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，网络策略是在pod级别工作的。您可以使用有意义的标签正确地对pod进行分组，这是您应该这样做的主要原因之一。
- en: 'Before applying this policy, it''s good to know that it works from the troubleshooting
    pod, as shown in the following code block:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用此策略之前，最好知道它是否可以从故障排除的pod中工作，如下面的代码块所示：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, after applying the `deny-all` policy, we get a timeout error, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在应用了`deny-all`策略之后，我们得到了一个超时错误，如下所示：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now that all the pods are isolated, let''s allow `social-graph-manager` to
    talk to its database. Here is a network policy that allows only `social-graph-manager`
    to access `social-graph-db` on port `5432`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的pod都被隔离了，让我们允许`social-graph-manager`访问它的数据库。这是一个网络策略，只允许`social-graph-manager`访问端口`5432`上的`social-graph-db`：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And the following additional policy allows ingress to `social-graph-manager`
    on port `9090` from the `link-manager`, as shown in the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下附加策略允许从`link-manager`对`social-graph-manager`的端口`9090`进行入口，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In addition to the security benefits, the network policies serve as live documentation
    to the flow of information across the system. You can tell exactly which services
    talk to which other services, as well as external services.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安全性的好处之外，网络策略还作为系统中信息流动的实时文档。您可以准确地知道哪些服务与其他服务通信，以及外部服务。
- en: We have gotten our network under control. Now, it's time to turn our attention
    to our image registry. After all, this is where we get our images, which we give
    a lot of permissions to.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经控制了我们的网络。现在，是时候把注意力转向我们的镜像注册表了。毕竟，这是我们获取镜像的地方，我们给予了很多权限。
- en: Safeguarding your image registry
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护您的镜像注册表
- en: It is highly recommended to use private image registries. If you have proprietary
    code, then you must not publish your containers with public access because reverse-engineering
    your images will grant attackers access. However, there are other reasons for
    this too. You get better control over (and auditing of) pulling and pushing images
    from the registry.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议使用私有图像注册表。如果您拥有专有代码，那么您不得以公共访问方式发布您的容器，因为对您的图像进行逆向工程将授予攻击者访问权限。但是，这也有其他原因。您可以更好地控制（和审计）从注册表中拉取和推送图像。
- en: 'There are two options here:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个选择：
- en: Use a private registry managed by a third party like AWS, Google, Microsoft,
    or Quay.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用由AWS、Google、Microsoft或Quay等第三方管理的私有注册表。
- en: Use your own private registry.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您自己的私有注册表。
- en: The first option makes sense if you deploy your system on a cloud platform that
    has good integration with its own image registry or if you don't manage your own
    registry in the sprint of cloud-native computing and you prefer to let a third
    party such as Quay do it for you.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在云平台上部署系统，并且该平台与其自己的图像注册表有良好的集成，或者如果您在云原生计算的精神中不管理自己的注册表，并且更喜欢让Quay等第三方为您完成，那么第一个选项是有意义的。
- en: The second option (running your own container registry) may be best if you need
    extra control over all the images, including base images and dependencies.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项（运行自己的容器注册表）可能是最佳选择，如果您需要对所有图像（包括基本图像和依赖项）进行额外控制。
- en: Granting access to Kubernetes resources as needed
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据需要授予对Kubernetes资源的访问权限
- en: 'The principle of least privilege directs you to grant access to Kubernetes
    resources only to services that actually need it (for example, Argo CD). RBAC
    is a great option here since everything is locked down by default and you can
    explicitly add privileges. However, beware of falling into the trap of giving
    wildcard access to everything just to get over difficulties with RBAC configuration.
    For example, let''s take a look at a cluster role with the following rule:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最小特权原则指导您仅向实际需要访问Kubernetes资源的服务授予权限（例如，Argo CD）。RBAC在这里是一个很好的选择，因为默认情况下所有内容都被锁定，您可以明确添加权限。但是，要注意不要陷入给予通配符访问所有内容的陷阱，只是为了克服RBAC配置的困难。例如，让我们看一个具有以下规则的集群角色：
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is worse than disabling RBAC because it gives you a false sense of security.
    Another option for a more dynamic situation is dynamic authentication, authorization,
    and admission control via webhooks and external servers. Those give you the ultimate
    flexibility.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这比禁用RBAC更糟糕，因为它会给您一种虚假的安全感。另一个更动态的选择是通过Webhook和外部服务器进行动态身份验证、授权和准入控制。这些给您提供了最大的灵活性。
- en: Using quotas to minimize the blast radius
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用配额来最小化爆炸半径
- en: 'Limits and quotas are a Kubernetes mechanism where you can control various
    limited resources such as CPU and memory which are allocated to clusters, pods,
    and containers. They are very useful for multiple reasons:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 限制和配额是Kubernetes的机制，您可以控制分配给集群、Pod和容器的各种有限资源，如CPU和内存。它们非常有用，有多种原因：
- en: Performance.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能。
- en: Capacity planning.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容量规划。
- en: Cost management.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成本管理。
- en: They help Kubernetes schedule pods based on resource utilization.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们帮助Kubernetes根据资源利用率安排Pod。
- en: When your workloads operate within a budget, everything becomes more predictable
    and easier to reason about, although you have to do the leg work of figuring out
    how many resources are actually needed and adjust this as time goes by. This is
    not as bad as it sounds since, with horizontal pod autoscaling, you can let Kubernetes
    dynamically adjust the number of pods for a service, even if each pod has a very
    strict quota.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的工作负载在预算内运行时，一切都变得更可预测和更容易推理，尽管您必须做出努力来弄清楚实际需要多少资源，并随着时间的推移进行调整。这并不像听起来那么糟糕，因为通过水平pod自动缩放，您可以让Kubernetes动态调整服务的pod数量，即使每个pod都有非常严格的配额。
- en: From a security perspective, if an attacker gains access to a workload running
    on your cluster, it limits the amount of physical resources it can use. One of
    the most common attacks these days is just saturating targets with crypto currency
    mining. Similar types of attacks are fork bombs, which just consume all the available
    resources by having a rogue process replicate itself uncontrollably. Network policies
    limit the blast radius of compromised workloads by limiting access to other pods
    on the network. Resource quotas minimize the blast radius from utilizing the resources
    on the hosting node of the compromised pod.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全的角度来看，如果攻击者获得对集群上运行的工作负载的访问权限，它将限制它可以使用的物理资源的数量。如今最常见的攻击之一就是用加密货币挖矿来饱和目标。类似的攻击类型是fork炸弹，它通过使一个恶意进程无法控制地复制自己来消耗所有可用资源。网络策略通过限制对网络上其他pod的访问来限制受损工作负载的爆炸半径。资源配额最小化了受损pod的主机节点上利用资源的爆炸半径。
- en: 'There are several types of quota, such as the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类型的配额，例如以下内容：
- en: Compute quota (CPU and memory)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算配额（CPU和内存）
- en: Storage quota (disks and external storage)
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储配额（磁盘和外部存储）
- en: Objects (Kubernetes object)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象（Kubernetes对象）
- en: Extended resources (non-Kubernetes resources like GPUs)
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展资源（非Kubernetes资源，如GPU）
- en: 'Resource quotas are quite nuanced. There are several concepts you need to understand,
    such as units and scopes, as well as the difference between requests and limits.
    I''ll explain the basics and demonstrate them by adding resource quotas for the
    Delinkcious user service. A resource quota is allocated for container, so you
    add it to the container spec as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 资源配额非常微妙。您需要理解几个概念，例如单位和范围，以及请求和限制之间的区别。我将解释基础知识，并通过为Delinkcious用户服务添加资源配额来演示它们。为容器分配资源配额，因此您可以将其添加到容器规范中，如下所示：
- en: '[PRE41]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There are two sections under resources:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 资源下有两个部分：
- en: '**Requests**: Requests are what the container requests in order to start. If
    Kubernetes can''t satisfy a request for a particular resource, it will not start
    the pod. Your workload can be sure that it will have that much CPU and memory
    allocated to it throughout its life, and you can take it to the bank.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：请求是容器为了启动而请求的资源。如果Kubernetes无法满足特定资源的请求，它将不会启动pod。您的工作负载可以确保在其整个生命周期中分配了这么多CPU和内存，并且您可以将其存入银行。'
- en: In the preceding block, I specified a request of `64Mi` of memory and `250m`
    units of CPU (see the following section for an explanation of these units).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的块中，我指定了`64Mi`内存和`250m` CPU单位的请求（有关这些单位的解释，请参见下一节）。
- en: '**Limits**: Limits are the ceiling for resources a workload may have access
    to. A container that exceeds its memory limits might be killed and the entire
    pod may be evicted from the node. Kubernetes will restart the container if killed
    and reschedule the pod if evicted, like it does with any type of failure. If a
    container exceeds its CPU limits, it will not be killed and may even get away
    with it for a while but, since the CPU is much easier to control, it will probably
    just not get all the CPU it requests and will sleep a lot to remain within its
    limits.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制**：限制是工作负载可能访问的资源的上限。超出其内存限制的容器可能会被杀死，并且整个pod可能会从节点中被驱逐。如果被杀死，Kubernetes将重新启动容器，并在被驱逐时重新调度pod，就像它对任何类型的故障一样。如果容器超出其CPU限制，它将不会被杀死，甚至可能会在一段时间内逃脱，但是由于CPU更容易控制，它可能只是得不到它请求的所有CPU，并且会经常休眠以保持在其限制范围内。'
- en: It is often the best approach to specify requests as limits, like I did for
    the user manager. The workload knows that it already has all the resources it
    will ever need and doesn't have to worry about trying to get closer to the limit
    in the presence of other hungry neighbors on the same node who may all compete
    for the same resource pool.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最好的方法是将请求指定为限制，就像我为用户管理器所做的那样。工作负载知道它已经拥有了它将来需要的所有资源，不必担心在同一节点上有其他饥饿的邻居竞争相同资源池的情况下试图接近限制。
- en: While resources are specified per container, when pods have multiple containers,
    it's important to consider the total resource requests of the entire pod (the
    sum of all the container requests). The reason for this is that pods are always
    scheduled as one unit. If you have a pod that has 10 containers, with each one
    asking for 2 Gib of memory, then it means that your pod requires a node with 20
    Gib of free memory.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然资源是针对每个容器指定的，但是当pod具有多个容器时，重要的是考虑整个pod的总资源请求（所有容器请求的总和）。这是因为pod总是作为一个单元进行调度。如果您有一个具有10个容器的pod，每个容器都要求2
    Gib的内存，那么这意味着您的pod需要一个具有20 Gib空闲内存的节点。
- en: Units for requests and limits
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求和限制的单位
- en: 'You can use the following suffixes for memory requests and limits: E, P, T,
    G, M, and K. You can also use the power of two suffixes (which are always a little
    larger), that is, Ei, Pi, Ti, Gi, Mi, and Ki. You can also just use integers,
    including the exponent notation for bytes.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下后缀来请求和限制内存：E、P、T、G、M和K。您还可以使用2的幂后缀（它们总是稍微大一些），即Ei、Pi、Ti、Gi、Mi和Ki。您还可以只使用整数，包括字节的指数表示法。
- en: 'The following are approximately the same: 257,988,979, 258e6, 258M, and 246Mi. CPU
    units are relative to the hosting environment, as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下大致相同：257,988,979, 258e6, 258M和246Mi。CPU单位相对于托管环境如下：
- en: 1 AWS vCPU
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个AWS vCPU
- en: 1 GCP Core
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个GCP Core
- en: 1 Azure vCore
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个Azure vCore
- en: 1 IBM vCPU
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个IBM vCPU
- en: 1 hyperthread on a bare-metal Intel processor with hyperthreading
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在具有超线程的裸机英特尔处理器上的1个超线程
- en: You can request CPU in fractions of resolutions of 0.001\. A more convenient
    method is to use milliCPU and just integers with the `m` suffix; for example,
    100 m is 0.1 CPU.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以请求CPU的分辨率为0.001的分数。更方便的方法是使用milliCPU和带有`m`后缀的整数；例如，100 m是0.1 CPU。
- en: Implementing security contexts
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施安全上下文
- en: Sometimes, pods and containers need escalated privileges or access to the node.
    This will be very rare for your application workloads. However, when necessary,
    Kubernetes has the concept of a security context that encapsulates and allows
    you to configure multiple Linux security concepts and mechanisms. This is critical
    from a security perspective because you open up a tunnel out of the container
    world into the host machine.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，Pod和容器需要提升的特权或访问节点。这对于您的应用工作负载来说将是非常罕见的。但是，在必要时，Kubernetes具有一个安全上下文的概念，它封装并允许您配置多个Linux安全概念和机制。从安全的角度来看，这是至关重要的，因为它打开了一个从容器世界到主机机器的隧道。
- en: 'Here is a list of some mechanisms that are covered by security contexts:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些安全上下文涵盖的一些机制的列表：
- en: Allowing (or forbidding) privilege escalation
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许（或禁止）特权升级
- en: Access control via user IDs and group IDs (`runAsUser`, `runAsGroup`)
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过用户ID和组ID进行访问控制（`runAsUser`，`runAsGroup`）
- en: Capabilities as opposed to unrestricted root access
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能力与无限制的根访问相对
- en: Using AppArmor and seccomp profiles
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AppArmor和seccomp配置文件
- en: SELinux configuration
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux配置
- en: 'There are many details and interactions that are beyond the scope of this book.
    I''ll just share an example of `SecurityContext`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多细节和交互超出了本书的范围。我只分享一个`SecurityContext`的例子：
- en: '[PRE42]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The security policy does different things, such as setting the user ID inside
    the container to `2000` and not allowing privilege escalation (getting root),
    as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 安全策略执行不同的操作，比如将容器内的用户ID设置为`2000`，并且不允许特权升级（获取root），如下所示：
- en: '[PRE43]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Security contexts are a very good way to centralize the security aspects of
    a pod or container, but in a large cluster where you potentially install third-party
    packages such as helm charts, it's difficult to ensure that every pod and container
    gets the right security context. That's where pod security policies come into
    the picture.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 安全上下文是集中化Pod或容器的安全方面的一个很好的方式，但在一个大型集群中，您可能安装第三方软件包（如helm charts），很难确保每个Pod和容器都获得正确的安全上下文。这就是Pod安全策略出现的地方。
- en: Hardening your pods with security policies
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用安全策略加固您的Pod
- en: 'A pod security policy allows you set a global policy that applies to all newly
    created pods. It is enforced as part of the admission stage of access control.
    The pod security policy can create a security context for pods with no security
    context or reject pod creation and updating if they have a security context that
    doesn''t match the policy. Here is a security policy that will prevent pods from
    getting a privileged status that allows access to host devices:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Pod安全策略允许您设置一个适用于所有新创建的Pod的全局策略。它作为访问控制的准入阶段的一部分执行。Pod安全策略可以为没有安全上下文的Pod创建安全上下文，或者拒绝创建和更新具有不符合策略的安全上下文的Pod。以下是一个安全策略，它将阻止Pod获取允许访问主机设备的特权状态：
- en: '[PRE44]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here are some good policies to enforce (if you don''t need the capabilities):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些很好的策略要执行（如果您不需要这些能力）：
- en: Read-only root filesystem
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读根文件系统
- en: Control mounting host volumes
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制挂载主机卷
- en: Prevent privileged access and escalation
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止特权访问和升级
- en: Last but not least, let's make sure that the tools we will use to work with
    our Kubernetes cluster are secure as well.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们确保我们将用于与Kubernetes集群一起工作的工具也是安全的。
- en: Hardening your toolchain
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加固您的工具链
- en: 'Delinkcious is pretty well-contained. The main tool it uses is Argo CD. Argo
    CD, which can potentially cause a lot of damage, is running inside the cluster
    and pulls from GitHub. However, it has a lot of permissions. Before I decided
    to use Argo CD as the continuous delivery solution for Delinkcious, I reviewed
    it seriously from a security perspective. The Argo CD developers did a great job
    of thinking how to make Argo CD secure. They made sensible choices, implemented
    them, and documented how to run Argo CD securely. Here are the security features
    that Argo CD provides:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Delinkcious相当完善。它使用的主要工具是Argo CD。Argo CD可能会造成很大的损害，它在集群内运行并从GitHub拉取。然而，它有很多权限。在我决定将Argo
    CD作为Delinkcious的持续交付解决方案之前，我从安全的角度认真审查了它。Argo CD的开发人员在考虑如何使Argo CD安全方面做得很好。他们做出了明智的选择，实施了这些选择，并记录了如何安全地运行Argo
    CD。以下是Argo CD提供的安全功能：
- en: Authentication of the admin user via JWT tokens
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过JWT令牌对管理员用户进行身份验证
- en: Authorization via RBAC
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过RBAC进行授权
- en: Secure communication over HTTPS
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过HTTPS进行安全通信
- en: Secret and credential management
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密和凭证管理
- en: Audits
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计
- en: Cluster RBAC
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群RBAC
- en: Let's take a look at them briefly.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看一下它们。
- en: Authentication of admin user via JWT tokens
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过JWT令牌对管理员用户进行身份验证
- en: Argo CD has a built-in admin user. All other users must use **Single-Sign on**
    (**SSO**). Authentication to the Argo CD server always uses **JSON Web Token**
    (**JWT**). Admin user credentials are converted into JWT too.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD具有内置的管理员用户。所有其他用户必须使用**单点登录**（**SSO**）。对Argo CD服务器的身份验证始终使用**JSON Web
    Token**（**JWT**）。管理员用户的凭据也会转换为JWT。
- en: It also supports automation via the `/api/v1/projects/{project}/roles/{role}/token`
    endpoint, which generates automation tokens that are issued and signed by Argo
    CD itself. These tokens are limited in scope and expire pretty fast.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 它还支持通过`/api/v1/projects/{project}/roles/{role}/token`端点进行自动化，生成由Argo CD本身签发的自动化令牌。这些令牌的范围有限，并且过期得很快。
- en: Authorization via RBAC
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过RBAC进行授权
- en: Argo CD authorizes requests by mapping the user's JWT group claims to RBAC roles.
    This is a very nice combination of industry-standard authentication with the Kubernetes
    authorization model via RBAC.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD通过将用户的JWT组声明映射到RBAC角色来授权请求。这是行业标准认证与Kubernetes授权模型RBAC的非常好的结合。
- en: Secure communication over HTTPS
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过HTTPS进行安全通信
- en: All communication to/from Argo CD, as well as between its own components, is
    done over HTTPS/TLS.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD的所有通信，以及其自身组件之间的通信，都是通过HTTPS/TLS完成的。
- en: Secret and credentials management
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 秘密和凭证管理
- en: 'Argo CD needs to manage a lot of sensitive information, such as the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD需要管理许多敏感信息，例如：
- en: Kubernetes secrets
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes秘密
- en: Git credentials
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git凭证
- en: OAuth2 client credentials
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth2客户端凭证
- en: Credentials to external clusters (when not installed in the cluster)
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对外部集群的凭证（当未安装在集群中时）
- en: Argo CD makes sure to keep all of these secrets to itself. It never leaks them
    by returning them in responses or logging them. All API responses and logs are
    scrubbed and redacted.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD确保将所有这些秘密保留给自己。它永远不会通过在响应中返回它们或记录它们来泄露它们。所有API响应和日志都经过清理和编辑。
- en: Audits
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审计
- en: You can audit most of the activity just by looking at git commit logs, which
    triggers everything in Argo CD. However, Argo CD also sends various events to
    capture in-cluster activity for additional visibility. This combination is powerful.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看git提交日志来审计大部分活动，这会触发Argo CD中的所有内容。但是，Argo CD还发送各种事件以捕获集群内的活动，以提供额外的可见性。这种组合很强大。
- en: Cluster RBAC
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群RBAC
- en: By default, Argo CD uses a cluster-wide admin role. This isn't necessary. The recommendation is
    to restrict its write privileges only to the namespaces it needs to manage.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Argo CD使用集群范围的管理员角色。这并不是必要的。建议将其写权限限制在需要管理的命名空间中。
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a serious look at a serious topic: security. Microservice-based
    architectures and Kubernetes make the most sense to large-scale enterprise-distributed
    systems that support mission-critical objectives and often manage sensitive information.
    On top of the challenges of developing and evolving such complex systems, we must
    be aware that such systems present very enticing targets to attackers.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们认真看待了一个严肃的话题：安全。基于微服务的架构和Kubernetes对于支持关键任务目标并经常管理敏感信息的大规模企业分布式系统是最有意义的。除了开发和演进这样复杂系统的挑战之外，我们必须意识到这样的系统对攻击者非常诱人。
- en: We must use a rigorous process and best practices to protect the system, the
    users, and the data. From here, we covered security principles and best practices,
    and we also saw how they support each other and how Kubernetes dedicates a lot
    of effort to allowing them to develop and operate our system securely.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用严格的流程和最佳实践来保护系统、用户和数据。从这里开始，我们涵盖了安全原则和最佳实践，我们也看到它们如何相互支持，以及Kubernetes如何致力于允许它们安全地开发和操作我们的系统。
- en: We also discussed the pillars that act as the foundation of microservice security
    on Kubernetes: the triple A of authentication/authorization/admission, secure
    communication inside and outside the cluster, strong secret management (encrypted
    at rest and in transit), and layered security policies.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了作为Kubernetes微服务安全基础的支柱：认证/授权/准入的三重A，集群内外的安全通信，强大的密钥管理（静态和传输加密），以及分层安全策略。
- en: At this point, you should have a clear understanding of the security mechanisms
    that are at your disposal and enough information to decide how to integrate them
    into your system. Security is never complete, but utilizing best practices will
    allow you to find the right balance between security and the other requirements
    of your system at each point in time.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您应该清楚地了解了您可以使用的安全机制，并且有足够的信息来决定如何将它们整合到您的系统中。安全永远不会完成，但利用最佳实践将使您能够在每个时间点上找到安全和系统其他要求之间的正确平衡。
- en: In the next chapter, we will finally open Delinkcious to the World! We will
    look at public APIs, load balancers, and the important considerations for performance
    and security that we need to be aware of.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将最终向世界开放Delinkcious！我们将研究公共API、负载均衡器以及我们需要注意的性能和安全性重要考虑因素。
- en: Further reading
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'There are many good resources for Kubernetes security. I''ve collected some
    very good external resources that will aid you in your journey:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多关于Kubernetes安全性的良好资源。我收集了一些非常好的外部资源，这些资源将帮助您在您的旅程中：
- en: '**Kubernetes security**: [https://kubernetes-security.info/](https://kubernetes-security.info/)'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes安全性：[https://kubernetes-security.info/](https://kubernetes-security.info/)
- en: '**Microsoft SDL practices**: [https://www.microsoft.com/en-us/securityengineering/sdl/practices](https://www.microsoft.com/en-us/securityengineering/sdl/practices)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软SDL实践：[https://www.microsoft.com/en-us/securityengineering/sdl/practices](https://www.microsoft.com/en-us/securityengineering/sdl/practices)
- en: 'The following Kubernetes documentation pages expand on a lot of the topics
    we have covered in this chapter:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Kubernetes文档页面扩展了本章涵盖的许多主题：
- en: '**Network Policies**: [https://kubernetes.io/docs/concepts/services-networking/network-policies/](https://kubernetes.io/docs/concepts/services-networking/network-policies/)'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络策略：[https://kubernetes.io/docs/concepts/services-networking/network-policies/](https://kubernetes.io/docs/concepts/services-networking/network-policies/)
- en: '**Resource Quotas**: [https://kubernetes.io/docs/concepts/policy/resource-quotas/](https://kubernetes.io/docs/concepts/policy/resource-quotas/)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源配额：[https://kubernetes.io/docs/concepts/policy/resource-quotas/](https://kubernetes.io/docs/concepts/policy/resource-quotas/)
- en: '**Configure a Security Context for a Pod or Container**: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Pod或容器配置安全上下文：[https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
