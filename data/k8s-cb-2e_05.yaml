- en: Building Continuous Delivery Pipelines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建持续交付流水线
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Moving monolithic to microservices
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从单片转移到微服务
- en: Working with the private Docker registry
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用私有Docker注册表
- en: Integrating with Jenkins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Jenkins集成
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Kubernetes is a perfect match for applications featuring the microservices architecture.
    However, most of the old applications are built in the monolithic style. We will
    give you an idea about how to move from the monolithic to the microservices world.
    As for microservices, deployment will become a burden if you are doing it manually.
    We will learn how to build up our own continuous delivery pipeline by coordinating
    Jenkins, the Docker registry, and Kubernetes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是微服务架构应用程序的完美匹配。然而，大多数旧应用程序都是以单片样式构建的。我们将为您介绍如何从单片转移到微服务世界。对于微服务，如果您手动进行部署，将会变得很麻烦。我们将学习如何通过协调Jenkins、Docker注册表和Kubernetes来构建我们自己的持续交付流水线。
- en: Moving monolithic to microservices
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从单片转移到微服务
- en: Typically, application architecture is the monolithic design that contains a
    **Model-View- Controller** (**MVC**) and every component within a single, big
    binary. A monolithic design has some benefits, such as less latency within components,
    being all in one straightforward package, and being easy to deploy and test.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用程序架构是包含**模型-视图-控制器**（**MVC**）的单片设计，每个组件都在一个单一的大二进制文件中。单片设计有一些好处，比如组件之间的延迟较小，都在一个简单的包中，易于部署和测试。
- en: However, a monolithic design has some downsides because the binary will be getting
    bigger and bigger. You always need to take care of the side effects when adding
    or modifying the code, therefore making release cycles longer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，单片设计也有一些缺点，因为二进制文件会变得越来越大。在添加或修改代码时，您总是需要注意副作用，因此发布周期会变得更长。
- en: 'Containers and Kubernetes give more flexibility when using microservices for
    your application. The microservices architecture is very simple and can be divided
    into some modules or some service classes together with MVC:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和Kubernetes在使用微服务时提供了更大的灵活性。微服务架构非常简单，可以分为一些模块或一些服务类以及MVC一起：
- en: '![](assets/9459422c-7fe8-4107-9f7c-2d0718edd145.png)Monolithic and microservices
    design'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/9459422c-7fe8-4107-9f7c-2d0718edd145.png)单片和微服务设计'
- en: Each microservice provides a **Remote Procedure Call** (**RPC**) using RESTful
    or some standard network APIs to other microservices. The benefit is that each
    microservice is independent. There are minimal side effects when adding or modifying
    the code. Release the cycle independently, so it perfectly ties in with the Agile
    software development methodology and allows for the reuse of these microservices
    to construct another application that builds the microservices ecosystem.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都使用RESTful或一些标准网络API提供**远程过程调用**（**RPC**）给其他微服务。好处是每个微服务都是独立的。在添加或修改代码时副作用很小。独立发布周期，因此它完全符合敏捷软件开发方法论，并允许重用这些微服务来构建另一个构建微服务生态系统的应用程序。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Prepare the simple microservices program. In order to push and pull your microservices,
    please register to Docker hub ([https://hub.docker.com/](https://hub.docker.com/))
    to create your free Docker ID in advance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 准备简单的微服务程序。为了推送和拉取您的微服务，请提前注册Docker hub（[https://hub.docker.com/](https://hub.docker.com/)）以创建您的免费Docker
    ID。
- en: If you push the Docker image to Docker hub, it will be public; anyone can pull
    your image. Therefore, don't put any confidential information into the image.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将Docker镜像推送到Docker hub，它将是公开的；任何人都可以拉取您的镜像。因此，请不要将任何机密信息放入镜像中。
- en: 'Once you successfully log in to your Docker ID, you will be redirected to your
    Dashboard page as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功登录到您的Docker ID，您将被重定向到您的仪表板页面如下：
- en: '![](assets/2fa69dc3-7110-456f-9da3-b049acaa6b28.png)After logging in to Docker
    hub'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2fa69dc3-7110-456f-9da3-b049acaa6b28.png)登录到Docker hub后'
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Prepare both microservices and the frontend WebUI as a Docker image. Then, deploy
    them using the Kubernetes replication controller and service.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 准备微服务和前端WebUI作为Docker镜像。然后，使用Kubernetes复制控制器和服务部署它们。
- en: Microservices
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: 'Build a microservice which provides a simple math function by using following
    steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤构建一个提供简单数学函数的微服务：
- en: 'Here is the simple microservice using Python `Flask` ([http://flask.pocoo.org/](http://flask.pocoo.org/)):'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是使用Python `Flask` ([http://flask.pocoo.org/](http://flask.pocoo.org/))的简单微服务：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Prepare a `Dockerfile` as follows in order to build the Docker image:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个`Dockerfile`如下以构建Docker镜像：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, use the `docker build` command to build the Docker image as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`docker build`命令构建Docker镜像如下：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, use the `docker login` command to log in to Docker hub:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`docker login`命令登录到Docker hub：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, use the `docker push` command to register to your Docker hub repository
    as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`docker push`命令注册到您的Docker hub存储库如下：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Upon access to Docker hub, you can see your microservice in the repository:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问Docker hub后，您可以在存储库中看到您的微服务：
- en: '![](assets/0126d63d-fb96-4007-aacc-43f4518fb247.png)Your microservice Docker
    image on Docker hub'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/0126d63d-fb96-4007-aacc-43f4518fb247.png)您的微服务Docker镜像在Docker hub上'
- en: Frontend WebUI
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端WebUI
- en: 'Build WebUI that uses preceding microservice by following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 构建使用前述微服务的WebUI的步骤：
- en: 'Here is the simple frontend WebUI that also uses Python `Flask`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个简单的前端WebUI，也使用Python `Flask`：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Kubernetes service generates the Kubernetes service name and port number as
    an environment variable to the other pods. Therefore, the environment variable's
    name and the Kubernetes service name must be consistent. In this scenario, the
    `my-calc` service name must be `my-calc-service`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes服务会将Kubernetes服务名称和端口号作为环境变量提供给其他pod。因此，环境变量的名称和Kubernetes服务名称必须一致。在这种情况下，`my-calc`服务名称必须是`my-calc-service`。
- en: 'The frontend WebUI uses the `Flask` HTML template; it is similar to PHP and
    JSP in that `entry.py` will pass the parameter to the template (`index.html`)
    to render the HTML:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前端WebUI使用`Flask` HTML模板；它类似于PHP和JSP，`entry.py`将参数传递给模板(`index.html`)以渲染HTML：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Dockerfile` is exactly the same as the microservice `my-calc`. So, eventually,
    the file structure will be as follows. Note that `index.html` is a jinja2 template
    file; therefore, put it under the `/templates` directory:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Dockerfile`与微服务`my-calc`完全相同。因此，最终的文件结构将如下所示。请注意，`index.html`是一个jinja2模板文件；因此，将其放在`/templates`目录下：'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, build a Docker image and push to Docker hub as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按以下方式构建Docker镜像并推送到Docker hub：
- en: In order to push your image to Docker hub, you need to log in using the Docker
    login command. It is needed only once; the system checks `~/.docker/config.json`
    to read from there.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将您的镜像推送到Docker hub，您需要使用`Docker login`命令登录。这只需要一次；系统会检查`~/.docker/config.json`从那里读取。
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Upon access to Docker hub, you can see your WebUI application in the repository:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问Docker hub后，您可以在存储库中看到您的WebUI应用程序：
- en: '![](assets/0c2579a3-2e7c-470e-a056-0ecec6d0a1ca.png)Microservices and frontend
    WebUI image on Docker Hub'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/0c2579a3-2e7c-470e-a056-0ecec6d0a1ca.png)Docker Hub上的微服务和前端WebUI镜像'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's prepare two YAML configurations to launch a microservice container and
    frontend WebUI container using Kubernetes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备两个YAML配置，使用Kubernetes启动微服务容器和前端WebUI容器。
- en: Microservices
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: 'Microservices (`my-calc`) uses the Kubernetes deployment and service, but it
    needs to communicate to other pods only. In other words, there''s no need to expose
    it to the outside Kubernetes network. Therefore, the service type is set as `ClusterIP`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务（`my-calc`）使用Kubernetes部署和服务，但它只需要与其他pod通信。换句话说，无需将其暴露给外部Kubernetes网络。因此，服务类型设置为`ClusterIP`：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use the `kubectl` command to load the `my-calc` pods as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl`命令加载`my-calc` pod如下：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Frontend WebUI
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端WebUI
- en: 'Frontend WebUI also uses the deployment and service, but it exposes the port
    (TCP port `30080`) in order to access it from an external web browser:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前端WebUI也使用部署和服务，但它暴露端口（TCP端口`30080`）以便从外部Web浏览器访问：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s try to access `my-frontend-service` using a web browser. You can access
    any Kubernetes node''s IP address; specify the port number 30080\. If you are
    using minikube, simply type `minikube service my-frontend-service` to access.
    Then you can see the `my-frontend `application as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用Web浏览器访问`my-frontend-service`。您可以访问任何Kubernetes节点的IP地址；指定端口号30080。如果您使用minikube，只需键入`minikube
    service my-frontend-service`即可访问。然后您可以看到`my-frontend`应用程序如下：
- en: '![](assets/c7aed4df-0a7b-4e57-812a-91e75552352e.png)Access to the frontend
    WebUI'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c7aed4df-0a7b-4e57-812a-91e75552352e.png)访问前端WebUI'
- en: 'When you click on the addition button, it will forward a parameter to microservices
    (`my-calc`). Microservices compute the addition (yes, just an addition!) and then
    return the result back to the frontend WebUI as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当您单击添加按钮时，它将向微服务（`my-calc`）转发一个参数。微服务计算加法（是的，只是加法！），然后将结果返回给前端WebUI如下：
- en: '![](assets/75836636-1a08-480c-8683-294f03a36740.png)Getting a result from microservices
    and rendering the HTML'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/75836636-1a08-480c-8683-294f03a36740.png)从微服务获取结果并呈现HTML'
- en: 'So now, it is easy to scale the pod for the frontend WebUI and microservices
    independently. For example, scale WebUI pod from `2` to `8` and microservice pod
    from `2` to `16`, as shown:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以轻松地独立扩展前端WebUI和微服务的pod。例如，将WebUI pod从`2`扩展到`8`，将微服务pod从`2`扩展到`16`，如下所示：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Also, if there's a need to fix some bugs, for example, if there's a frontend
    need to validate
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果需要修复一些错误，例如，如果前端需要验证
- en: the input parameter to check whether it is numeric or a string (yes, if you
    type string and
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输入参数以检查它是数字还是字符串（是的，如果您输入字符串并提交，它将显示一个错误！），这不会影响构建和部署周期。
- en: then submit, it will show an error!), it will not affect the build and deploy
    the cycle against
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后提交，它将显示一个错误！），这不会影响构建和部署周期
- en: 'microservices:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务：
- en: '![](assets/085ae157-527d-4a9f-b15d-174e0acfe8b0.png)Frontend and microservice
    pods and services'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/085ae157-527d-4a9f-b15d-174e0acfe8b0.png)前端和微服务pod和服务'
- en: In addition, if you want to add another microservice, for example, subtraction
    microservices, you may need to create another Docker image and deploy with another
    deployments and service, so it will be independent from the current microservices. Then,
    you can keep accumulating your own microservice ecosystem to reuse in another
    application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您想添加另一个微服务，例如减法微服务，您可能需要创建另一个Docker映像，并与另一个部署和服务一起部署，以便它独立于当前的微服务。然后，您可以不断积累自己的微服务生态系统以便在另一个应用程序中重用。
- en: Working with the private Docker registry
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用私有Docker注册表
- en: Once you start to build your microservice application via Docker, you'll need
    to have a Docker registry to put your container image in. Docker hub offers you
    free public repositories, however, in some cases you might want to make your image
    private due to business needs or organization policy.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您开始通过Docker构建微服务应用程序，您将需要一个Docker注册表来存放您的容器映像。Docker hub为您提供免费的公共存储库，但在某些情况下，您可能希望由于业务需求或组织政策而将您的映像设为私有。
- en: 'Docker hub offers the **private repository**, which only allows authenticated
    users to push and pull your images, and is not visible to other users. However,
    there is only one quota (repository) for a free plan. You may pay to increase
    the number of private repositories, but if you adopt the microservices architecture,
    you will need a large number of private repositories:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Docker hub提供**私有存储库**，只允许经过身份验证的用户推送和拉取您的图像，并且对其他用户不可见。但是，免费计划只有一个配额（存储库）。您可以支付以增加私有存储库的数量，但是如果您采用微服务架构，您将需要大量的私有存储库：
- en: '![](assets/f17ae140-cc38-4932-95b1-cfadf4a27a26.png)Docker hub private repositories
    price list'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/f17ae140-cc38-4932-95b1-cfadf4a27a26.png)Docker hub私有存储库价格表'
- en: Docker hub with a paid plan is the easiest way to set up your private registry,
    but there are some other ways to set up your own private Docker registry, which
    the unlimited Docker image quota locates inside your network. In addition, you
    can also use other cloud-provided registry services to manage your private registry.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Docker hub的付费计划是设置私有注册表的最简单方法，但是还有其他一些方法可以在您的网络内设置无限的Docker镜像配额的私有Docker注册表。此外，您还可以使用其他云提供的注册表服务来管理您的私有注册表。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will show you three different ways to set up your own private
    registries:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将向您展示三种不同的方法来设置您自己的私有注册表：
- en: Using Kubernetes to run a private registry image ([https://hub.docker.com/_/registry/](https://hub.docker.com/_/registry/))
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes运行私有注册表镜像（[https://hub.docker.com/_/registry/](https://hub.docker.com/_/registry/)）
- en: Using Amazon elastic container registry ([https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/))
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Amazon弹性容器注册表（[https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)）
- en: Using Google container registry ([https://cloud.google.com/container-registry/](https://cloud.google.com/container-registry/))
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google容器注册表（[https://cloud.google.com/container-registry/](https://cloud.google.com/container-registry/)）
- en: When using a Kubernetes to set up a private registry, you may use your own Kubernetes
    cluster on the private or public cloud, which allows you to have full control
    and utilize most of your physical resources.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Kubernetes设置私有注册表时，您可以在私有或公共云上使用自己的Kubernetes集群，这样您就可以完全控制并充分利用您的物理资源。
- en: On the other hand, when using a public cloud-provided service, such as AWS or
    GCP, you can be relieved of the management of servers and storage. Whatever you
    need, those public clouds provide you with elastic resources. We'll just have
    to set the credentials to Kubernetes and let the nodes know. The following recipes
    will go through these three different options.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当使用公共云提供的服务，如AWS或GCP时，您可以摆脱服务器和存储的管理。无论您需要什么，这些公共云都为您提供弹性资源。我们只需要设置Kubernetes的凭据并让节点知道。以下配方将介绍这三种不同的选项。
- en: Using Kubernetes to run a Docker registry server
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes运行Docker注册表服务器
- en: If you want to launch a private registry server using Kubernetes, you need your
    own Kubernetes cluster. You will have set up your own Kubernetes while exploring
    this book. If you haven't done yet, please read [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml),
    *Building Your Own Kubernetes Cluster*, to choose the easiest way.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用Kubernetes启动一个私有注册表服务器，您需要自己的Kubernetes集群。在探索本书时，您将设置自己的Kubernetes。如果您还没有这样做，请阅读[第1章](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml)，*构建您自己的Kubernetes集群*，选择最简单的方法。
- en: Please note that Docker registry will store some of your Docker images. You
    must have a `PersistentVolume` to manage your storage via Kubernetes. In addition,
    we should expect that multiple pods will read and write to the same `PersistentVolume`
    due to scalability. Therefore, you must have the **ReadWriteMany** (**RWX**)access
    mode of `PersistentVolume`, such as GlusterFS or NFS.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Docker注册表将存储一些Docker镜像。您必须有一个`PersistentVolume`通过Kubernetes管理您的存储。此外，我们应该期望多个pod将读取和写入相同的`PersistentVolume`，因为可扩展性。因此，您必须具有`PersistentVolume`的**ReadWriteMany**（**RWX**）访问模式，例如GlusterFS或NFS。
- en: 'Details of `PersistentVolume` are described in the *Working with volumes* section
    in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking through Kubernetes
    Concepts*. Let''s create a `PersistentVolume` that uses NFS and the name `pvnfs01`
    to allocate `100` GB:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`PersistentVolume`的详细信息在[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)的*使用卷*部分中有描述，*深入了解Kubernetes概念*。让我们创建一个使用NFS和名称`pvnfs01`来分配`100`GB的`PersistentVolume`：'
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you can''t prepare RWX `PersistentVolume`, you may still be able to set
    up Docker registry by Kubernetes, but you can launch only one pod (replicas: one).
    As an alternative, you may use AWS S3 or GCP PD as private registry backend storage;
    please visit [https://docs.docker.com/registry/configuration/](https://docs.docker.com/registry/configuration/)
    to learn how to configure backend storage for your registry.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法准备RWX `PersistentVolume`，您仍然可以通过Kubernetes设置Docker注册表，但只能启动一个pod（副本：一个）。或者，您可以使用AWS
    S3或GCP PD作为私有注册表后端存储；请访问[https://docs.docker.com/registry/configuration/](https://docs.docker.com/registry/configuration/)了解如何为您的注册表配置后端存储。
- en: 'Next, create `PersistentVolumeClaim` that decouples NFS `PersistentVolume`
    and pod configuration. Let''s create one `PersistentVolumeClaim` named `pvc-1`. Make
    sure `accessModes` is `ReadWriteMany` and that `STATUS` became `Bound` after creation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`PersistentVolumeClaim`，将NFS`PersistentVolume`和pod配置解耦。让我们创建一个名为`pvc-1`的`PersistentVolumeClaim`。确保`accessModes`是`ReadWriteMany`，并且创建后`STATUS`变为`Bound`：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is enough to set up your private registry. It has some prerequisites; alternatively,
    using the public cloud is much simpler.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经足够设置您的私有注册表。它有一些先决条件；或者，使用公共云要简单得多。
- en: Using Amazon elastic container registry
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Amazon弹性容器注册表
- en: Amazon **elastic container registry** (**ECR**) was introduced as a part of
    Amazon **elastic container service** (**ECS**). This recipe won't touch on ECS
    itself; instead, just use ECR as a private registry.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon **弹性容器注册表**（**ECR**）是Amazon **弹性容器服务**（**ECS**）的一部分。这个教程不会涉及ECS本身；而是只使用ECR作为私有注册表。
- en: 'In order to use Amazon ECR, you have to have an AWS account and install AWS
    CLI on your machine. It will be described in more detail in [Chapter 6](b7e1d803-52d0-493b-9123-5848da3fa9ec.xhtml),
    *Building Kubernetes on AWS. *You''ll have to create an IAM user with `ACCESS
    KEY ID` and `SECRET ACCESS KEY`, and associated `AmazonEC2ContainerRegistryFullAccess` policies,
    which allow full administrator access to Amazon ECR:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Amazon ECR，您必须拥有AWS账户并在您的机器上安装AWS CLI。这将在[第6章](b7e1d803-52d0-493b-9123-5848da3fa9ec.xhtml)中更详细地描述，*在AWS上构建Kubernetes*。您将需要创建一个带有`ACCESS
    KEY ID`和`SECRET ACCESS KEY`的IAM用户，并关联`AmazonEC2ContainerRegistryFullAccess`策略，该策略允许对Amazon
    ECR进行完全管理员访问：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then configure the default settings in AWS CLI via the `aws configure` command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过`aws configure`命令配置AWS CLI的默认设置：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then we can start to play with Amazon ECR.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以开始使用Amazon ECR。
- en: Using Google cloud registry
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Google云注册表
- en: '**Google container registry** ([https://cloud.google.com/container-registry/](https://cloud.google.com/container-registry/))
    is a part of the GCP. Similar to AWS, having a GCP account is required, as well
    as Cloud SDK ([https://cloud.google.com/sdk/](https://cloud.google.com/sdk/)),
    which is the command-line interface in GCP. More details about GCP will be described
    in [Chapter 7](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml), *Building Kubernetes
    on GCP*.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google容器注册表**（[https://cloud.google.com/container-registry/](https://cloud.google.com/container-registry/)）是GCP的一部分。与AWS类似，需要拥有GCP帐户，以及Cloud
    SDK（[https://cloud.google.com/sdk/](https://cloud.google.com/sdk/)），这是GCP中的命令行界面。有关GCP的更多详细信息将在[第7章](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml)中描述，*在GCP上构建Kubernetes*。'
- en: 'On GCP, we''ll just need to create a project and enable billing and the container
    registry API for our project. Otherwise, any operation in `gcloud` will display
    an error:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在GCP上，我们只需要创建一个项目并为我们的项目启用计费和容器注册表API。否则，`gcloud`中的任何操作都会显示错误：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In order to enable billing and container registry API, visit the GCP web console
    ([https://console.cloud.google.com](https://console.cloud.google.com)), navigate
    to the billing page and container registry page, then just enable those. Once
    activation is done, you can use the `gcloud container` command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用计费和容器注册表API，请访问GCP Web控制台（[https://console.cloud.google.com](https://console.cloud.google.com)），转到计费页面和容器注册表页面，然后启用它们。激活完成后，您可以使用`gcloud
    container`命令：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now we can start to use Google container registry.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始使用Google容器注册表。
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: We have set up the preparation steps. Let's see how to configure your private
    registry step by step.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了准备工作。让我们逐步看看如何配置您的私有注册表。
- en: Launching a private registry server using Kubernetes
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes启动私有注册表服务器
- en: 'In order to launch a private registry, it is necessary to configure these files
    in order to configure a private registry with appropriate security settings:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动私有注册表，需要配置这些文件以配置具有适当安全设置的私有注册表：
- en: SSL certificate
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSL证书
- en: HTTP secret
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP密钥
- en: HTTP basic authentication file
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP基本身份验证文件
- en: Creating a self-signed SSL certificate
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自签名SSL证书
- en: There is a pitfall—people tend to set up a plain HTTP (disable TLS) registry
    without authentication in the beginning. Then it also needs to configure a Docker
    client (Kubernetes node) to allow an insecure registry and so on. It is a bad
    practice that requires many steps to set up an insecure environment.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个陷阱——人们倾向于在开始时设置一个纯HTTP（禁用TLS）注册表而不进行身份验证。然后还需要配置Docker客户端（Kubernetes节点）以允许不安全的注册表等。这是一个不好的做法，需要许多步骤来设置不安全的环境。
- en: 'The best practice is always using the official SSL certificate that is issued
    by the certificate authority. However, a self-signed certificate is always handy,
    especially in the testing phase. An official certificate can wait until we have
    FQDN defined. Therefore, this recipe will show you how to use OpenSSL to create
    a self-signed SSL certificate via the following steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳做法始终使用由证书颁发机构颁发的官方SSL证书。但是，自签名证书在测试阶段特别方便。官方证书可以等到我们定义了FQDN。因此，本教程将向您展示如何使用OpenSSL通过以下步骤创建自签名SSL证书：
- en: 'Create a `secrets` directory:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`secrets`目录：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the `openssl` command to specify the options to generate a certificate
    (`domain.crt`) and a private key (`domain.key`) under the secrets directory. Note
    that you may type `.` to skip to input location and email info:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`openssl`命令指定选项在`secrets`目录下生成证书（`domain.crt`）和私钥（`domain.key`）。请注意，您可以输入`.`跳过输入位置和电子邮件信息：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Check whether both certificate and private keys are generated under the `secrets`
    directory:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查证书和私钥是否都生成在`secrets`目录下：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating HTTP secret
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HTTP密钥
- en: 'Regarding HTTP secret, it will be randomly generated by the private registry
    instance upon startup by default. However, it is a problem if you run multiple
    pods, because each pod may have a different HTTP secret that occur an error when
    Docker client push or pull the image. So we explicitly state that all pods will
    use the same HTTP secret, via the following steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 关于HTTP秘钥，私有注册表实例在启动时默认会随机生成。然而，如果运行多个pod，则可能会出现每个pod具有不同HTTP秘钥的问题，这会导致Docker客户端推送或拉取镜像时出错。因此，我们明确声明所有pod将使用相同的HTTP秘钥，通过以下步骤：
- en: 'Use the `openssl` command to create a `http.secret` file under the `secrets`
    directory:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`openssl`命令在`secrets`目录下创建一个`http.secret`文件：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Check the `secrets` directory, which has three files now:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`secrets`目录，现在有三个文件：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Creating the HTTP basic authentication file
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HTTP基本身份验证文件
- en: 'Finally, regarding the HTTP basic authentication file, if you set up a private
    registry, authentication is needed when you interact with the Docker registry.
    You''ll have to do `docker login` to get a token when pushing and pulling images.
    In order to create an HTTP basic authentication file, use the `htpasswd` command
    that is provided by Apache2 as this is easiest. Let''s create a HTTP basic authentication
    file via the following steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于HTTP基本身份验证文件，如果您设置了私有注册表，则在与Docker注册表交互时需要进行身份验证。在推送和拉取镜像时，您将需要执行`docker
    login`以获取令牌。为了创建一个HTTP基本身份验证文件，使用Apache2提供的`htpasswd`命令是最简单的。通过以下步骤创建HTTP基本身份验证文件：
- en: 'Run Docker with Apache2 Docker image (`httpd`) to run the `htpasswd` command
    with the `bcrypt` (`-B`) option and generate a basic authentication file (`registry_passwd`)
    under the `secrets` directory:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Apache2 Docker镜像（`httpd`）运行`htpasswd`命令，并带有`bcrypt`（`-B`）选项，在`secrets`目录下生成一个基本身份验证文件（`registry_passwd`）：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Check the `secrets` directory so that now you have four files:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`secrets`目录，现在有四个文件：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Creating a Kubernetes secret to store security files
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个用于存储安全文件的Kubernetes秘钥
- en: 'There are four files. We use **Kubernetes Secret** so that all pods can access
    it via an environment variable or mount a volume and access as a file. For more
    details about secrets, please refer to the *Working with secrets* section in [Chapter
    2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking through Kubernetes Concepts*.
    You can use the `kubectl` command to load these four files to store to the Kubernetes
    secret via the following steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个文件。我们使用**Kubernetes Secret**，以便所有pod可以通过环境变量或挂载卷访问它并作为文件访问。有关秘钥的更多细节，请参阅[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中的*使用秘钥*部分，*深入了解Kubernetes概念*。您可以使用`kubectl`命令通过以下步骤加载这四个文件并存储到Kubernetes秘钥中：
- en: 'Run the `kubectl create` command with the `--from-file` parameter to specify
    the secrets directory:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl create`命令并带有`--from-file`参数来指定secrets目录：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Check the status via the `kubectl describe` command:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`kubectl describe`命令检查状态：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Configuring a private registry to load a Kubernetes secret
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置私有注册表以加载Kubernetes秘钥
- en: 'On the other hand, the private registry itself supports reading the HTTP secret
    as an environment variable in string format. It also can support specifying the
    file path for the SSL certificate and HTTP basic authentication file as environment
    variables:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，私有注册表本身支持将HTTP秘钥作为字符串格式的环境变量进行读取。它还可以支持指定SSL证书和HTTP基本身份验证文件的文件路径作为环境变量：
- en: '| **Environment variable name** | **Description** | **Sample value** |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| **环境变量名称** | **描述** | **示例值** |'
- en: '| `REGISTRY_HTTP_SECRET` | HTTP secret string | `valueFrom`:    `secretKeyRef:`` 
          name: registry-secrets``        key: http.secret` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `REGISTRY_HTTP_SECRET` | HTTP秘钥字符串 | `valueFrom`:    `secretKeyRef:``   
        name: registry-secrets``        key: http.secret` |'
- en: '| `REGISTRY_HTTP_TLS_CERTIFICATE` | File path for certificate  (`domain.crt`)
    | `/mnt/domain.crt` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `REGISTRY_HTTP_TLS_CERTIFICATE` | 证书的文件路径（`domain.crt`） | `/mnt/domain.crt`
    |'
- en: '| `REGISTRY_HTTP_TLS_KEY` | File path for private key (`domain.key`) | `/mnt/domain.key`
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `REGISTRY_HTTP_TLS_KEY` | 私钥的文件路径（`domain.key`） | `/mnt/domain.key` |'
- en: '| `REGISTRY_AUTH_HTPASSWD_REALM` | The realm in which the registry server authenticates
    | `basic-realm` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `REGISTRY_AUTH_HTPASSWD_REALM` | 注册服务器进行身份验证的领域 | `basic-realm` |'
- en: '| `REGISTRY_AUTH_HTPASSWD_PATH` | File path for `htpasswd` file (`registry_passwd`)
    | `/mnt/registry_passwd` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `REGISTRY_AUTH_HTPASSWD_PATH` | `htpasswd`文件（`registry_passwd`）的文件路径 | `/mnt/registry_passwd`
    |'
- en: '| `REGISTRY_HTTP_HOST` | Specify one of Kubernetes node IP and `nodePort` |
    `10.138.0.3:30500` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `REGISTRY_HTTP_HOST` | 指定Kubernetes节点IP和`nodePort`之一 | `10.138.0.3:30500`
    |'
- en: Ideally, you should have a load balancer and set up a Kubernetes Service type
    as `LoadBalancer`. And then `REGISTRY_HTTP_HOST` could be the load balancer IP
    and port number. For simplicity, we'll just use `NodePort` in this recipe. For
    more information about `LoadBalancer`, refer to the *Working with services* section
    in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking through Kubernetes
    Concepts*, and the *Forwarding container ports* section in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您应该有一个负载均衡器，并设置一个Kubernetes服务类型为`LoadBalancer`。然后`REGISTRY_HTTP_HOST`可以是负载均衡器的IP和端口号。为简单起见，我们将在这个示例中只使用`NodePort`。有关`LoadBalancer`的更多信息，请参阅[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中的*与服务一起工作*部分，以及[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)中的*转发容器端口*部分，*玩转容器*。
- en: 'We''ll conduct a deployment to a Kubernetes YAML file for creating a registry,
    and include the preceding variables inside it, so the registry pods can use them. Now
    we have `PersistentVolumeClaim` as `pvc-1` that supplies the container image store,
    and mounts SSL certificate files (`domain.crt` and `domain.key`) and an HTTP basic
    authentication file (`registry_passwd`) via Secret `registry-secrets`. As well
    as reading the HTTP Secret string as an environment variable by Secret `registry-secrets`.
     The entire YAML configuration is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对一个Kubernetes YAML文件进行部署，用于创建一个注册表，并在其中包含前述变量，以便注册表pod可以使用它们。现在我们有`PersistentVolumeClaim`作为`pvc-1`，它提供容器映像存储，并通过Secret
    `registry-secrets`挂载SSL证书文件（`domain.crt`和`domain.key`）和HTTP基本认证文件（`registry_passwd`）。以及通过Secret
    `registry-secrets`将HTTP Secret字符串读取为环境变量。整个YAML配置如下：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now your own private registry is ready to use!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您自己的私有注册表已经准备好使用了！
- en: Create a repository on the AWS elastic container registry
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS弹性容器注册表上创建存储库
- en: 'In order to push a container image to Amazon ECR, you need to create a repository
    beforehand. Unlike Docker hub or private registry, Amazon ECR doesn''t create
    a repository automatically when it is the first time to push the image. Therefore,
    if you want to push three container images, you have to create three repositories
    in advance:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将容器映像推送到Amazon ECR，您需要事先创建一个存储库。与Docker hub或私有注册表不同，当第一次推送映像时，Amazon ECR不会自动创建存储库。因此，如果您想推送三个容器映像，您必须事先创建三个存储库：
- en: 'It is simple to type the `aws ecr create-repository` command to specify the
    repository name:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`aws ecr create-repository`命令指定存储库名称很简单：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That's it! You need to remember the `repositoryUri` (in the previous case, `************.dkr.ecr.us-east-1.amazonaws.com/my-nginx`) that
    will be used as the private image URL.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！您需要记住`repositoryUri`（在前面的情况下，`************.dkr.ecr.us-east-1.amazonaws.com/my-nginx`），这将被用作私有映像URL。
- en: The previous URL is masked as an ID as `************`. It is tied with your
    AWS account ID.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的URL被掩盖为`************`作为ID，它与您的AWS账户ID绑定。
- en: 'On the other hand, if you see something like the following error message, your
    IAM user doesn''t have the permission of the `CreateRepository` operation. In
    this case, you need to attach an IAM policy from `AmazonEC2ContainerRegistryFullAccess`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您看到以下错误消息，表示您的IAM用户没有`CreateRepository`操作的权限。在这种情况下，您需要附加一个来自`AmazonEC2ContainerRegistryFullAccess`的IAM策略：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Determining your repository URL on Google container registry
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定Google容器注册表上的存储库URL
- en: 'In order to push a container image to Google container registry, there is an
    important consideration regarding the repository URL. First of all, there are
    several Google container registry region hosts available:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将容器映像推送到Google容器注册表，有一个关于存储库URL的重要考虑因素。首先，有几个Google容器注册表区域主机可用：
- en: '`gcr.io` (currently USA region)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcr.io`（目前是美国地区）'
- en: '`us.gcr.io` (USA region)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`us.gcr.io`（美国地区）'
- en: '`eu.gcr.io` (Europe region)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eu.gcr.io`（欧洲地区）'
- en: '`asia.gcr.io` (Asia region)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asia.gcr.io`（亚洲地区）'
- en: Note that these region hosts are network latency purpose, doesn't mean to restrict
    to a particular region. They are still accessible worldwide.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些区域主机是出于网络延迟目的，并不意味着限制在特定区域。它们仍然可以在全球范围内访问。
- en: 'Second of all, while you tag the container image, you also need to specify
    your `project-id` on which you''ve enabled billing and API. Therefore, the entire
    repository URL could be:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，当您标记容器映像时，还需要在启用计费和API的`project-id`上指定。因此，整个存储库URL可以是：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In my case, I used the region USA default, the project ID is `kubernetes-cookbook`,
    and the image name is `my-nginx`; therefore, my repository URL is:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，我使用了默认的美国地区，项目ID是`kubernetes-cookbook`，映像名称是`my-nginx`；因此，我的存储库URL是：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Other than that, Google container registry is ready to use now!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Google容器注册表现在已经准备好使用！
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you start to use private registry with Kubernetes, you must configure a
    credential properly. Amazon ECR and Google cloud registry need special consideration.
    Let's configure a credential for private registry, Amazon ECR and Google cloud
    registry.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始使用Kubernetes的私有注册表时，必须正确配置凭据。Amazon ECR和Google云注册表需要特别考虑。让我们为私有注册表、Amazon
    ECR和Google云注册表配置凭据。
- en: Push and pull an image from your private registry
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从您的私有注册表中推送和拉取映像
- en: 'Now you can push your container image to your private registry. Because we
    have set up an HTTP basic authentication, you need to do `docker login` first.
    Otherwise you get a `no basic auth credentials` error:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以将容器映像推送到您的私有注册表。因为我们已经设置了HTTP基本身份验证，您需要先执行`docker login`。否则，您会收到`no basic
    auth credentials`错误：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Therefore, you need `docker login` to specify the username and password, which
    you set onto the `registry_passwd` file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您需要使用`docker login`来指定用户名和密码，这些用户名和密码设置在`registry_passwd`文件上：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: On the other hand, as for pulling an image from a private registry, Kubernetes
    nodes also needs to have a credential for your private registry. But using the `docker
    login` command on every node is not realistic. Instead, Kubernetes supports storing
    this credential as a Kubernetes secret and each node will use this credential
    while pulling an image.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于从私有注册表中拉取映像，Kubernetes节点还需要为您的私有注册表配置凭据。但是在每个节点上使用`docker login`命令是不现实的。相反，Kubernetes支持将这些凭据存储为Kubernetes秘密，并且每个节点在拉取映像时将使用这些凭据。
- en: 'To do that, we need to create a `docker-registry` resource that needs to specify:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要创建一个需要指定的`docker-registry`资源：
- en: '`--docker-server`: In this example, `10.138.0.3:30500`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--docker-server`：在这个例子中，`10.138.0.3:30500`'
- en: '`--docker-username`: In this example, `user01`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--docker-username`：在这个例子中，`user01`'
- en: '`--docker-password`: In this example, `my-super-secure-password`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--docker-password`：在这个例子中，`my-super-secure-password`'
- en: '`--docker-email`: Your email address'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--docker-email`：您的电子邮件地址'
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, you can pull your private image from the private registry that is
    specifying the `my-private-credential` secret. To do that, set `spec.imagePullSecrets`
    as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以从指定了`my-private-credential`秘钥的私有注册表中拉取您的私有图像。为此，请将`spec.imagePullSecrets`设置如下：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Congratulations! Now you can feel free to push your private images to your private
    registry run by Kubernetes. Also, pull an image from Kubernetes too. At any time,
    you can scale out based on client traffic.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在您可以随意将私有图像推送到由Kubernetes运行的私有注册表中。还可以从Kubernetes中拉取图像。随时可以根据客户流量进行扩展。
- en: Push and pull an image from Amazon ECR
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Amazon ECR推送和拉取图像
- en: 'Amazon ECR has an authentication mechanism to provide access to your private
    repositories. AWS CLI has a functionality to generate an access token using the `aws
    ecr get-login` command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon ECR具有身份验证机制，可提供对私有存储库的访问权限。 AWS CLI具有使用`aws ecr get-login`命令生成访问令牌的功能：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It outputs the `docker login` command with the ID and password:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 它输出带有ID和密码的`docker login`命令：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Therefore, just copy and paste to your terminal to acquire a token from AWS.
    Then try `docker push` to upload your Docker image to ECR:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只需复制并粘贴到您的终端以从AWS获取令牌。然后尝试`docker push`将您的Docker图像上传到ECR：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On the other hand, pulling an image from ECR to Kubernetes follows exactly
    the same steps as the private registry that uses a Kubernetes secret to store
    the token:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，从ECR到Kubernetes拉取图像的步骤与使用Kubernetes秘钥存储令牌的私有注册表完全相同：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, `spec.imagePullSecrets` needs to specify `my-ecr-secret`. As well as the
    image URL, it also specifies the ECR repository:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`spec.imagePullSecrets`需要指定`my-ecr-secret`。除了图像URL之外，它还指定了ECR存储库：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Note that this token is short-lived: it''s valid up to 12 hours. So, 12 hours
    later, you need to run `aws ecr get-login` again to acquire a new token, then
    update the secret `my-ecr-secret`. It is absolutely not ideal to do this.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此令牌的生命周期很短：有效期为12小时。因此，12小时后，您需要再次运行`aws ecr get-login`来获取新的令牌，然后更新秘钥`my-ecr-secret`。这绝对不是理想的做法。
- en: The good news is that Kubernetes supports the updating of the ECR token automatically
    via `CloudProvider`. However, it requires that your Kubernetes runs on an AWS
    environment such as EC2\. In addition, the EC2 instance has to have an IAM role
    that is equivalent or higher than the `AmazonEC2ContainerRegistryReadOnly` policy.
    It will be described in [Chapter 6](b7e1d803-52d0-493b-9123-5848da3fa9ec.xhtml),
    *Building Kubernetes on AWS*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，Kubernetes支持通过`CloudProvider`自动更新ECR令牌。但是，这要求您的Kubernetes在AWS环境上运行，例如EC2。此外，EC2实例必须具有等同或高于`AmazonEC2ContainerRegistryReadOnly`策略的IAM角色。这将在[第6章](b7e1d803-52d0-493b-9123-5848da3fa9ec.xhtml)中描述，*在AWS上构建Kubernetes*。
- en: If you really want to use your Kubernetes cluster outside of AWS by pulling
    an image from the ECR repository, there is a challenge in that you need to update
    the ECR token every 12 hours. Maybe you can do this using a cron job or by adopting
    some automation tools.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的想要通过从ECR存储库中拉取图像来使用Kubernetes集群，那么需要面临的挑战是您需要每12小时更新一次ECR令牌。也许您可以使用定时作业或采用一些自动化工具来完成这项工作。
- en: For more detail, please visit the AWS online document at [https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请访问AWS在线文档[https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html)。
- en: Push and pull an image from Google cloud registry
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Google云注册表推送和拉取图像
- en: According to GCP documentation ([https://cloud.google.com/container-registry/docs/advanced-authentication](https://cloud.google.com/container-registry/docs/advanced-authentication)),
    there are several way to push/pull to a container registry.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 根据GCP文档（[https://cloud.google.com/container-registry/docs/advanced-authentication](https://cloud.google.com/container-registry/docs/advanced-authentication)），有几种方式可以推送/拉取到容器注册表。
- en: Using gcloud to wrap the Docker command
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用gcloud来包装Docker命令
- en: 'The `gcloud` command has a wrapper function to run a `docker` command to push
    and pull. For example, if you want to push the image `gcr.io/kubernetes-cookbook/my-nginx`,
    use the `gcloud` command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcloud`命令有一个包装函数来运行`docker`命令来推送和拉取。例如，如果你想推送镜像`gcr.io/kubernetes-cookbook/my-nginx`，使用`gcloud`命令：'
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It is sufficient to push the image from your machine, however, it is not ideal
    if you integrate with Kubernetes. This is because it is not easy to wrap the `gcloud`
    command on the Kubernetes node.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的机器推送镜像就足够了，但是如果你要与Kubernetes集成，这并不理想。这是因为在Kubernetes节点上不容易包装`gcloud`命令。
- en: Fortunately, there is a solution that creates a GCP service account and grants
    a permission (role) to it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个解决方案可以创建一个GCP服务账号并授予其权限（角色）。
- en: Using the GCP service account to grant a long-lived credential
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GCP服务账号授予长期有效的凭据
- en: 'We need to integrate to pull an image from the Kubernetes node, which requires
    a long-lived credential that can be stored to the Kubernetes secret. To do that,
    perform the following steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要集成以从Kubernetes节点中拉取镜像，这需要一个长期有效的凭据，可以存储到Kubernetes秘钥中。为此，请执行以下步骤：
- en: 'Create a GCP service account (`container-sa`):'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个GCP服务账号（`container-sa`）：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Assign `container-sa` (use full name) to the `roles/storage.admin` role:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`container-sa`（使用全名）分配给`roles/storage.admin`角色：
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Generate a key file (`container-sa.json`) for `container-sa`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`container-sa`生成一个密钥文件（`container-sa.json`）：
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Use `docker login` to check whether the key file is working or not:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker login`来检查密钥文件是否有效：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Use `docker pull` to check whether you can pull from container registry or
    not:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker pull`来检查是否可以从容器注册表中拉取：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Looks all fine! Now you can use the Kubernetes secret the exact same way with
    the private registry or AWS ECR.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来一切都很好！现在你可以像使用私有注册表或AWS ECR一样使用Kubernetes秘钥。
- en: 'Create a Kubernetes secret (`my-gcr-secret`) to specify `_json_key` and `container-sa.json`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Kubernetes秘钥（`my-gcr-secret`）来指定`_json_key`和`container-sa.json`：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Specify `my-gcr-secret` to `imagePullSecrets` to launch a pod:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`my-gcr-secret`指定为`imagePullSecrets`以启动一个pod：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Congratulations! Now you can use Google container registry for your private
    registry that is fully managed by GCP. And Kubernetes can pull your private image
    from there.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在你可以使用由GCP完全管理的Google容器注册表作为你的私有注册表。Kubernetes可以从那里拉取你的私有镜像。
- en: Integrating with Jenkins
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Jenkins集成
- en: In software engineering, **continuous integration** (**CI**) ([https://en.wikipedia.org/wiki/Continuous_integration](https://en.wikipedia.org/wiki/Continuous_integration))
    and **continuous delivery** (**CD**) ([https://en.wikipedia.org/wiki/Continuous_delivery](https://en.wikipedia.org/wiki/Continuous_delivery)),
    abbreviated as CI/CD, have the ability to simplify the procedure of the traditional
    development process with continuous developing, testing, and delivering mechanisms
    in order to reduce the panic of serious conflict, namely, to deliver small changes
    one at a time and to narrow down the problems immediately, if any. Furthermore,
    through automatic tools, a product delivered by the CI/CD system can achieve better
    efficiency and shorten time-to-market.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，**持续集成**（**CI**）（[https://en.wikipedia.org/wiki/Continuous_integration](https://en.wikipedia.org/wiki/Continuous_integration)）和**持续交付**（**CD**）（[https://en.wikipedia.org/wiki/Continuous_delivery](https://en.wikipedia.org/wiki/Continuous_delivery)）简称为CI/CD，具有简化传统开发过程的能力，通过持续开发、测试和交付机制来减少严重冲突的恐慌，即一次交付小的变更并立即缩小问题范围。此外，通过自动化工具，CI/CD系统交付的产品可以实现更高的效率并缩短上市时间。
- en: Jenkins is one of the well-known CI systems, which can be configured as a continuous
    delivery system. Jenkins can pull your project codes from the source code control
    system, run the tests, and then deploy based on your configuration. In this recipe,
    we will show you how to integrate Jenkins to Kubernetes to achieve continuous
    delivery.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是众所周知的CI系统之一，可以配置为持续交付系统。Jenkins可以从源代码控制系统中拉取项目代码，运行测试，然后根据您的配置进行部署。在这个教程中，我们将向您展示如何将Jenkins集成到Kubernetes以实现持续交付。
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you start this recipe, prepare a Docker hub account ([https://hub.docker.com](https://hub.docker.com))
    or you may use your private registry that is described in the previous section.
    But the important part is you must have a credential to pull and push to the registry.
    If you use Docker hub, make sure `docker login` with your credentials works.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本教程之前，准备一个Docker hub账户（[https://hub.docker.com](https://hub.docker.com)）或者您可以使用前一节中描述的私有注册表。但重要的是您必须有凭据来拉取和推送到注册表。如果您使用Docker
    hub，请确保`docker login`与您的凭据正常工作。
- en: 'Next, make sure your Kubernetes is ready. But we will use RBAC authentication
    for access from the Jenkins pod to the Kubernetes master API. If you use `minikube`,
    you need to add the `--extra-config=apiserver.Authorization.Mode=RBAC` option
    when starting a minikube:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，确保您的Kubernetes已准备就绪。但我们将使用RBAC身份验证从Jenkins pod访问Kubernetes主API。如果您使用`minikube`，则需要在启动minikube时添加`--extra-config=apiserver.Authorization.Mode=RBAC`选项：
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Then, you can set up your own Jenkins server through Kubernetes as well; the
    details are in this section.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您也可以通过Kubernetes设置自己的Jenkins服务器；具体细节在本节中。
- en: 'Some minikube versions have a `kube-dns` issue that can''t resolve the external
    domain name, such as [https://github.com/](https://github.com/) and [https://jenkins.io/](https://jenkins.io/), that
    can''t process this recipe. Replacing the `kube-dns` add-on with the `coredns`
    add-on could resolve the issue after launching `minikube` with the following command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一些minikube版本存在`kube-dns`问题，无法解析外部域名，例如[https://github.com/](https://github.com/)和[https://jenkins.io/](https://jenkins.io/)，无法处理此教程。在启动`minikube`后，用`coredns`插件替换`kube-dns`插件可能会解决此问题：
- en: '`$ minikube addons disable kube-dns`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ minikube addons disable kube-dns`'
- en: '`$ minikube addons enable coredns`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ minikube addons enable coredns`'
- en: How to do it...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'There are two important parts to go through in the Jenkins setup:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jenkins设置中有两个重要的部分要经历：
- en: Jenkins needs to run a `docker` command to build your application to compose
    your container image
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins需要运行`docker`命令来构建您的应用程序以组成容器镜像
- en: Jenkins need to communicate with the Kubernetes master to control deployment
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins需要与Kubernetes主节点通信以控制部署
- en: To achieve step 1, there is a tricky part that needs something like a **Docker-in-Docker**
    (**dind**). This is because Jenkins is run by Kubernetes as a pod (Docker container),
    and Jenkins also needs to invoke a `docker` command to build your application.
    It can be achieved by mounting `/var/run/docker.sock` from the Kubernetes node
    to the Jenkins pod that can communicate with Jenkins, the Kubernetes node, and
    the Docker daemon.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现第1步，有一个需要类似**Docker-in-Docker**（dind）的棘手部分。这是因为Jenkins是由Kubernetes作为一个pod（Docker容器）运行的，而且Jenkins还需要调用`docker`命令来构建您的应用程序。可以通过将Kubernetes节点上的`/var/run/docker.sock`挂载到可以与Jenkins、Kubernetes节点和Docker守护程序通信的Jenkins
    pod来实现。
- en: Docker-in-Docker and mounting `/var/run/docker.sock` have been described at
    [https://blog.docker.com/2013/09/docker-can-now-run-within-docker/](https://blog.docker.com/2013/09/docker-can-now-run-within-docker/) and [http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/.](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Docker-in-Docker和挂载`/var/run/docker.sock`已在[https://blog.docker.com/2013/09/docker-can-now-run-within-docker/](https://blog.docker.com/2013/09/docker-can-now-run-within-docker/)和[http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/.](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)中有描述。
- en: In order to achieve step 2, we will set up a Kubernetes service account and
    assign one `ClusterRole` so that the Jenkins service account can have a necessary privilege.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现第2步，我们将设置一个Kubernetes服务账户并分配一个`ClusterRole`，以便Jenkins服务账户可以拥有必要的特权。
- en: Let's do it step by step.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步来做。
- en: Setting up a custom Jenkins image
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置自定义的Jenkins镜像
- en: 'Run Jenkins by Kubernetes, we use an official image ([https://hub.docker.com/u/jenkins/](https://hub.docker.com/u/jenkins/))
    but customize it to install the following applications on it:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Kubernetes运行Jenkins，我们使用官方镜像（[https://hub.docker.com/u/jenkins/](https://hub.docker.com/u/jenkins/)），但自定义安装以下应用程序：
- en: Docker CE
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker CE
- en: kubectl binary
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl二进制文件
- en: Jenkins Docker plugin
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins Docker插件
- en: 'To do that, prepare `Dockerfile `to maintain your own Jenkins image:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，准备`Dockerfile`来维护您自己的Jenkins镜像：
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Use `docker build` to build your Jenkins image and then  `docker push` command
    to upload to your own registry in Docker hub, as shown:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker build`来构建您的Jenkins镜像，然后使用`docker push`命令将其上传到Docker Hub中的您自己的注册表，如下所示：
- en: '[PRE52]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Or, alternatively, you could upload that to your private registry or any other
    cloud-provided registry.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以将其上传到您的私有注册表或任何其他云提供的注册表。
- en: Hurray! We have our build system image ready now.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们现在已经准备好了我们的构建系统镜像。
- en: Setting up Kubernetes service account and ClusterRole
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Kubernetes服务账户和ClusterRole
- en: Imagine that after using Jenkins successfully to build your application container,
    you then use `kubectl` to update deployment to roll out a new binary. To do that,
    invoke a `kubectl` command from the inside of a Jenkins pod. In this scenario,
    we need a credential to communicate to the Kubernetes master.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，成功使用Jenkins构建您的应用程序容器后，然后使用`kubectl`更新部署以推出新的二进制文件。为此，从Jenkins pod内部调用`kubectl`命令。在这种情况下，我们需要凭据与Kubernetes主节点通信。
- en: Fortunately, Kubernetes supports this kind of scenario, which uses a service
    account. It is described in detail in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*. So, this recipe will use the simplest way,
    which uses the `default` namespace and `cluster-admin ClusterRole`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Kubernetes支持这种情景，使用服务账户进行描述。这在[第8章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)中有详细描述，*高级集群管理*。因此，这个步骤将使用最简单的方式，即使用`default`命名空间和`cluster-admin
    ClusterRole`。
- en: 'To check whether RBAC is enabled and also if the `cluster-admin ClusterRole`
    exists or not, type the `kubectl get clusterrole` command:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查RBAC是否启用，以及`cluster-admin ClusterRole`是否存在，输入`kubectl get clusterrole`命令：
- en: '[PRE53]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, create a service account, `jenkins-sa`, which will be used by a Jenkins
    pod. Prepare the following YAML configuration, and type the `kubectl create` command
    to create it:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个服务账户`jenkins-sa`，它将被Jenkins pod使用。准备以下YAML配置，并输入`kubectl create`命令来创建它：
- en: '[PRE54]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now we can associate the `jenkins-sa` service account with a `cluster-admin`
    `ClusterRole`. Prepare a `ClusterRoleBinding` configuration and run the `kubectl
    create` command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`jenkins-sa`服务账户与`cluster-admin ClusterRole`关联起来。准备一个`ClusterRoleBinding`配置，并运行`kubectl
    create`命令：
- en: '[PRE55]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the result, if a pod is launched with the service account `jenkins-sa`, this
    Pod has the privilege to control a Kubernetes cluster because of the `cluster-admin
    ClusterRole`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，如果一个pod使用`jenkins-sa`服务账户启动，这个pod有权限控制Kubernetes集群，因为有`cluster-admin ClusterRole`。
- en: It should create a custom `ClusterRole` that has minimal privilege for Jenkins
    usage. But this recipe is to focus on the Jenkins setup itself. If you want to
    create a custom `ClusterRole`, please go to [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该创建一个具有Jenkins使用最小权限的自定义`ClusterRole`。但这个配方是专注于Jenkins设置本身。如果你想创建一个自定义的`ClusterRole`，请转到[第8章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)，*高级集群管理*。
- en: Launching the Jenkins server via Kubernetes deployment
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Kubernetes部署启动Jenkins服务器
- en: 'Based on the previous recipes, now you have:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 基于之前的配方，现在你有了：
- en: A custom Jenkins container image
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个自定义的Jenkins容器镜像
- en: A service account
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个服务账户
- en: Finally, you can launch your custom Jenkins server on your Kubernetes cluster.
    Remember that we need to run a `docker` command in the Docker environment, which
    needs to mount `/var/run/docker.sock` from the local Kubernetes node.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在你的Kubernetes集群上启动你的自定义Jenkins服务器。记住，我们需要在Docker环境中运行`docker`命令，需要从本地Kubernetes节点挂载`/var/run/docker.sock`。
- en: 'In addition, we need to use a `jenkins-sa `service account to launch a Jenkins
    pod. It needs to specify `spec.template.spec.serviceAccountName: jenkins-sa` in
    the deployment configuration.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，我们需要使用`jenkins-sa`服务账户来启动一个Jenkins pod。需要在部署配置中指定`spec.template.spec.serviceAccountName:
    jenkins-sa`。'
- en: It is also recommended to have a `PersistentVolume` to preserve Jenkins home
    (`/var/jenkins_home`), in case a pod is restarted. We just simply use the `hostPath
    /data/jenkins-data` directory (assuming you use minikube). You may change to another
    path or other types of `PersistentVolume` to fit with your environment.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 还建议使用`PersistentVolume`来保存Jenkins主目录(`/var/jenkins_home`)，以防pod重新启动。我们只需简单地使用`hostPath
    /data/jenkins-data`目录（假设您使用minikube）。您可以更改为另一个路径或其他类型的`PersistentVolume`以适应您的环境。
- en: 'Overall, the deployments YAML configuration for Jenkins is as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，Jenkins的部署YAML配置如下：
- en: '[PRE56]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After a few minutes, Kubernetes pulls your custom Jenkins image and runs a
    Jenkins pod which is capable of running a `docker` command and a `kubectl` command
    without any configuration due to mounting the `/var/run/docker.sock` and `jenkins-sa` service
    account:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，Kubernetes拉取您的自定义Jenkins镜像并运行一个Jenkins pod，该pod能够运行`docker`命令和`kubectl`命令，无需任何配置，因为挂载了`/var/run/docker.sock`和`jenkins-sa`服务账户：
- en: '[PRE57]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You are all set! Now you can configure a Jenkins job to build your application,
    build a container, and deploy to Kubernetes.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好了！现在你可以配置一个Jenkins任务来构建你的应用程序，构建一个容器，并部署到Kubernetes。
- en: How it works...
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now we start to configure Jenkins to build your application. However, to access
    the WebUI of your custom Jenkins, you need to access the Kubernetes service that
    binds to your Jenkins pod. It is easier to use `kubectl port-forward` to access
    remotely to configure Jenkins:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始配置 Jenkins 来构建您的应用程序。但是，要访问自定义 Jenkins 的 WebUI，您需要访问绑定到 Jenkins pod 的
    Kubernetes 服务。使用 `kubectl port-forward` 更容易远程访问配置 Jenkins：
- en: '[PRE58]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The initial configuration of Jenkins is done via the following steps:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤完成 Jenkins 的初始配置：
- en: Access the `http://127.0.0.1:58080` Jenkins WebUI; it asks you to input `initialAdminPassword`.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 `http://127.0.0.1:58080` 的 Jenkins WebUI；它会要求您输入 `initialAdminPassword`。
- en: 'Use `kubectl exec` to acquire the `initialAdminPassword`. Then copy and paste
    to the Jenkins WebUI to proceed with the initial configuration to install the
    suggested plugin and create an admin user:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `kubectl exec` 获取 `initialAdminPassword`。然后将其复制粘贴到 Jenkins WebUI 中，以进行初始配置以安装建议的插件并创建管理员用户：
- en: '[PRE59]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You will see a Jenkins top page. Then click Manage Jenkins, then Configure
    System:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到 Jenkins 的顶部页面。然后点击管理 Jenkins，然后配置系统：
- en: '![](assets/7ba133a9-48d4-4227-a747-9eeeb386699e.png)Navigate to Jenkins configuration'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到 Jenkins 配置
- en: 'Scroll to the bottom and find a Cloud section. Click Add a new cloud to select
    Docker:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到底部，找到云部分。点击“添加新的云”以选择 Docker：
- en: '![](assets/7ee5f4ab-dbfb-4e9c-a3ad-cf7b4f5c1ef2.png)Adding a Docker setting'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 Docker 设置
- en: 'Put Name as your desired name (example: `my-docker`) and specify the Docker
    Host URI and Docker domain socket as `unix:///var/run/docker.sock`:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名称设置为您想要的名称（例如：`my-docker`），并指定 Docker 主机 URI 和 Docker 域套接字为 `unix:///var/run/docker.sock`：
- en: '![](assets/53073463-06d0-4b8c-8e2e-7f27070df8c2.png)Configure Docker on Jenkins'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jenkins 上配置 Docker
- en: Using Jenkins to build a Docker image
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jenkins 构建 Docker 镜像
- en: 'Let''s configure a Jenkins job to build a sample microservice application,
    which was introduced in the previous recipe (`my-calc`). Perform the following
    steps to configure and build a Docker image:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置一个 Jenkins 作业来构建一个示例微服务应用程序，该应用程序在上一个配方中介绍过（`my-calc`）。执行以下步骤来配置和构建 Docker
    镜像：
- en: 'On the left navigation, click New Item:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧导航中，点击新项目：
- en: '![](assets/7eafbe4f-c882-454c-8ff4-994766bc6922.png)Navigating to create a
    new item'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到创建新项目
- en: 'Put your in desired item name (example: `my-calc`), select Freestyle project,
    then click OK:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入所需的项目名称（例如：`my-calc`），选择自由风格项目，然后点击确定：
- en: '![](assets/911c131b-08a8-48e4-a814-5971bd062314.png)Creating a new Jenkins
    Job'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Jenkins 作业
- en: 'In the Source Code Management tab, select Git and set the Repository URL as [https://github.com/kubernetes-cookbook/my-calc.git](https://github.com/kubernetes-cookbook/my-calc.git),
    or you may use your own repository which has a `Dockerfile`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“源代码管理”选项卡中，选择 Git，并将“存储库 URL”设置为 [https://github.com/kubernetes-cookbook/my-calc.git](https://github.com/kubernetes-cookbook/my-calc.git)，或者您可以使用自己的具有
    `Dockerfile` 的存储库：
- en: '![](assets/a9dbdb04-69e8-428c-98ee-6e5682bab7c7.png)Source Code Management
    settings'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码管理设置
- en: 'On the Build Environment tab, click Add build step to add Build / Publish Docker
    Image:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“构建环境”选项卡中，点击“添加构建步骤”以添加“构建/发布 Docker 镜像”：
- en: '![](assets/680b49b0-db5f-4d42-95fe-77730fdef7ad.png)Build Environment settings'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 构建环境设置
- en: 'In the Build / Publish Docker Image panel:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“构建/发布 Docker 镜像”面板中：
- en: Directory for `Dockerfile` as current (`.`)
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Dockerfile` 的目录为当前目录（`.`）'
- en: Choose my-docker in the Cloud that we've set up
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们设置的云中选择 my-docker
- en: 'Put image as your Docker repository, but append `:${BUILD_NUMBER}` (example:
    `hidetosaito/my-calc:${BUILD_NUMBER}`)'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将镜像设置为您的 Docker 存储库，但附加 `:${BUILD_NUMBER}`（例如：`hidetosaito/my-calc:${BUILD_NUMBER}`）
- en: Enable Push image
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用推送镜像
- en: Click Add to add your Docker hub ID credential
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“添加”以添加您的Docker hub ID凭据
- en: 'Then, click Save:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击保存：
- en: '![](assets/ba62d487-3f1e-44b8-ab7e-f6aa82789d55.png)Docker build/publish settings'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/ba62d487-3f1e-44b8-ab7e-f6aa82789d55.png)Docker构建/发布设置'
- en: 'Finally, you can click Build Now to trigger a build; for testing purposes you
    can click five times to see how it works:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以点击“立即构建”来触发构建；为了测试目的，您可以点击五次来看看它是如何工作的：
- en: '![](assets/fcf5a03d-8960-48c0-91f2-20dc0cec5646.png)Trigger a build'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/fcf5a03d-8960-48c0-91f2-20dc0cec5646.png)触发构建'
- en: 'Note that you can see a Console that knows it performs a Docker build and push:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，您可以看到一个控制台，它知道执行Docker构建和推送：
- en: '![](assets/b4447718-f02a-4986-8ed3-6588a887ebc0.png)Showing a build log'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/b4447718-f02a-4986-8ed3-6588a887ebc0.png)显示构建日志'
- en: 'Access your Docker hub repository; it has been pushed five times (because of
    clicking on build five times):'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问您的Docker hub存储库；它已被推送了五次（因为点击了五次构建）：
- en: '![](assets/277bd7dc-f403-4ab2-a8b6-8fd847de4e6a.png)Docker hub repository'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/277bd7dc-f403-4ab2-a8b6-8fd847de4e6a.png)Docker hub存储库'
- en: That's it! You can achieve continuous integration to build a Docker image so
    that when you update a source in GitHub, you can continuously build and push the
    latest image to your Docker hub repository by Jenkins.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！您可以实现持续集成来构建Docker镜像，这样当您在GitHub中更新源代码时，您可以持续构建并将最新的镜像推送到Jenkins的Docker
    hub存储库中。
- en: Deploying the latest container image to Kubernetes
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署最新的容器镜像到Kubernetes
- en: 'After each build, Jenkins keeps pushing your container image on your Docker
    hub repository at the end of the CI process. Next, update the Jenkins job configuration
    to use the latest image to deploy to Kubernetes, via the following steps:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 每次构建后，Jenkins都会在CI过程结束时将您的容器镜像推送到Docker hub存储库。接下来，更新Jenkins作业配置以使用最新的镜像部署到Kubernetes，具体步骤如下：
- en: 'The first time, we pre-deploy microservice application manually via `kubectl
    deploy --record`. Note that you may change `spec.template.spec.containers.image:
    hidetosaito/my-calc` to your repository:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '第一次，我们通过`kubectl deploy --record`手动预部署微服务应用程序。请注意，您可以将`spec.template.spec.containers.image:
    hidetosaito/my-calc`更改为您的存储库：'
- en: '[PRE60]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Open Jenkins Job configuration; on the Build tab, right after the Docker build
    settings, click Add build step and choose Execute shell:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Jenkins作业配置；在“构建”选项卡上，在Docker构建设置之后，点击“添加构建步骤”，然后选择“执行shell”：
- en: '![](assets/c473e1c8-40ee-4416-bb22-facf3f7438e8.png)Adding a build step'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c473e1c8-40ee-4416-bb22-facf3f7438e8.png)添加构建步骤'
- en: 'Add this shell script and click Save:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此shell脚本添加并点击保存：
- en: '[PRE61]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Trigger a new build; you can see that after Docker push, it runs the preceding
    script:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发新的构建；您可以看到在Docker推送之后，它运行了前面的脚本：
- en: '![](assets/7b881532-d1b1-4322-b3ef-d27217f4b377.png)Kubernetes rollout result'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/7b881532-d1b1-4322-b3ef-d27217f4b377.png)Kubernetes滚动结果'
- en: Now you can extend continuous integration to continuous delivery! You may extend
    to add a unit test or integration test and roll back mechanisms onto the above
    script to make your CI/CD work stronger.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以将持续集成扩展到持续交付！您可以扩展以添加单元测试或集成测试，并将回滚机制添加到上述脚本中，以使您的CI/CD工作更加强大。
