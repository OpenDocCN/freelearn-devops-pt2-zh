- en: Scaling to Multiple Hosts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展到多个主机
- en: In the previous chapters, we have specified the hosts in the command line. This
    worked well while having a single host to work on, but it will not work very well
    when managing multiple servers. In this chapter, we will see exactly how to leverage
    inventories to manage multiple servers. Also, we will introduce topics such as
    host variables and group variables to make it possible to easily and quickly set
    up similar but different hosts. We will speak about loops in **Ansible**, which
    allows you to reduce the amount of code you write and at the same time make it
    more readable as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们在命令行中指定了主机。在只有一个主机要处理时，这样做效果很好，但是当管理多个服务器时，效果就不太好了。在本章中，我们将看到如何利用库存来管理多个服务器。此外，我们还将介绍主机变量和组变量等主题，以便轻松快速地设置类似但不同的主机。我们将讨论**Ansible**中的循环，它允许您减少编写的代码量，同时使代码更易读。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Working with inventory files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用库存文件
- en: Working with variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can  download all the files from this book's GitHub repository at [https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter03](https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter03)[.](https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter03)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本书的 GitHub 仓库下载所有文件，网址为[https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter03](https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter03)。
- en: Working with inventory files
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用库存文件
- en: An **inventory file** is the source of truth for Ansible (there is also an advanced
    concept called **dynamic inventory**, which we will cover later). It follows the
    **Initialization** (**INI**) format and tells Ansible whether the remote host
    or hosts provided by the user are genuine.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**库存文件**是 Ansible 的真相之源（还有一个名为**动态库存**的高级概念，我们稍后会介绍）。它遵循 **INI** 格式，并告诉 Ansible
    用户提供的远程主机是否真实。'
- en: Ansible can run its tasks against multiple hosts in parallel. To do this, you
    can directly pass the list of hosts to Ansible using an inventory file. For such
    parallel execution, Ansible allows you to group your hosts in the inventory file;
    the file passes the group's name to Ansible. Ansible will search for that group
    in the inventory file and run its tasks against all the hosts listed in that group.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 可以并行运行其任务对多个主机进行操作。为了做到这一点，您可以直接将主机列表传递给 Ansible，使用库存文件。对于这样的并行执行，Ansible
    允许您在库存文件中对主机进行分组；文件将组的名称传递给 Ansible。Ansible 将在库存文件中搜索该组，并对该组中列出的所有主机运行其任务。
- en: You can pass the inventory file to Ansible using the `-i` or `--inventory-file`
    option followed by the path to the file. If you do not explicitly specify any
    inventory file to Ansible, it will take the default path from the `host_file`
    parameter of `ansible.cfg`, which defaults to `/etc/ansible/hosts`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `-i` 或 `--inventory-file` 选项将库存文件传递给 Ansible，后跟文件路径。如果您未明确指定任何库存文件给 Ansible，则
    Ansible 将从 `ansible.cfg` 的 `host_file` 参数的默认路径获取，默认路径为 `/etc/ansible/hosts`。
- en: When using the `-i` parameter, if the value is a list (it contains at least
    one comma), it will be used as the inventory list, while if the variable is a
    string, it will be used as the inventory file path.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-i` 参数时，如果值是一个列表（至少包含一个逗号），它将被用作库存列表，而如果变量是字符串，则将其用作库存文件路径。
- en: The basic inventory file
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本库存文件
- en: 'Before diving into the concept, let''s first look at a basic inventory file
    called `hosts` that we can use instead of the list we used in the previous examples:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入概念之前，让我们先看一下一个称为`hosts`的基本库存文件，我们可以在这个文件中使用，而不是在之前的示例中使用的列表：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Ansible can take either an FQDN or an IP address within the inventory file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 可以在库存文件中使用 FQDN 或 IP 地址。
- en: We can now perform the same operations that we did in the previous chapter,
    tweaking the Ansible command parameters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以执行与上一章相同的操作，调整 Ansible 命令参数。
- en: 'For instance, to install the web server, we used this command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要安装 Web 服务器，我们使用了这个命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Instead, we can use the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用以下内容：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we have substituted the list of hosts with the inventory filename.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已经用库存文件名替换了主机列表。
- en: Groups in an inventory file
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库存文件中的组
- en: The advantages of inventory files are noticeable when we have more complex situations.
    Let's say our website is getting more complicated and we now need a more complex
    environment. In our example, our website will require a MySQL database. Also,
    we will decide to have two web servers. In this scenario, it makes sense to group
    different machines based on their role in our infrastructure.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到更复杂的情况时，清单文件的优势就会显现出来。假设我们的网站变得更加复杂，现在我们需要一个更复杂的环境。在我们的示例中，我们的网站将需要一个 MySQL
    数据库。此外，我们决定有两台 web 服务器。在这种情况下，根据我们的基础设施中的角色对不同的机器进行分组是有意义的。
- en: 'Ansible allows us to create an INI-like file with groups (INI sections) and
    hosts. Here''s what our hosts file would change to:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 允许我们创建一个类似 INI 文件的文件，其中包含组（INI 部分）和主机。这是我们的主机文件将要更改为的内容：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we can instruct playbooks to run only on hosts in a certain group. In the
    previous chapter, we have created three different playbooks for our website example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以指示播放书只在某个组中的主机上运行。在上一章中，我们为我们的网站示例创建了三个不同的播放书：
- en: '`firstrun.yaml` is generic and will have to be run on every machine.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firstrun.yaml` 是通用的，必须在每台机器上运行。'
- en: '`common_tasks.yaml` is generic and will have to be run on every machine.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`common_tasks.yaml` 是通用的，必须在每台机器上运行。'
- en: '`webserver.yaml` is specific for web servers and therefore should not be run
    on any other machines.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webserver.yaml` 是特定于 web 服务器的，因此不应在任何其他机器上运行。'
- en: 'Since the only file that is specific for a group of the servers is the `webserver.yaml`
    one, we only need to change it. To do so, let''s open the `webserver.yaml` file
    and change content from **`- hosts: all` **to `- hosts: webserver`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '由于唯一特定于服务器组的文件是 `webserver.yaml`，所以我们只需要更改它。为此，让我们打开 `webserver.yaml` 文件并将内容从
    **`- hosts: all`** 更改为 `- hosts: webserver`。'
- en: With only those three playbooks, we cannot proceed with creating our environment
    with three servers. Since we don't have a playbook to set up the database yet
    (we will see it in the next chapter), we will provision the two web servers (`ws01.fale.io`
    and `ws02.fale.io`) completely, and, for the database server, we will only provision
    the base system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 只有这三个播放书，我们无法继续创建我们的环境，有三个服务器。因为我们还没有一个设置数据库的播放书（我们将在下一章中看到），我们将完全为两台 web 服务器（`ws01.fale.io`
    和 `ws02.fale.io`）提供服务，并且，对于数据库服务器，我们只提供基本系统。
- en: 'Before running the Ansible playbooks, we will need to provision the environment.
    To do so, create the following vagrant file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 Ansible 播放书之前，我们需要为环境提供支持。为此，请创建以下 vagrant 文件：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Simply by running `vagrant up`, Vagrant will generate the whole environment
    for us. After a while of Vagrant outputting stuff in the shell, it should give
    you back the Command Prompt. When this happens, check that in the last few lines
    there were no errors, to be sure that everything went as expected.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `vagrant up`，Vagrant 将为我们生成整个环境。在一段时间后，Vagrant 在 shell 中输出一些内容后，应该会还给你命令提示符。当这种情况发生时，请检查最后几行是否有错误，以确保一切如预期般进行。
- en: 'Now that we have provisioned the environment, we can proceed by executing the
    `firstrun` playbook, which will ensure that our Ansible user is present and has
    the right SSH-key set up. To do so, we can run it with the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为环境提供了支持，我们可以继续执行 `firstrun` 播放书，这将确保我们的 Ansible 用户存在并且具有正确的 SSH 密钥设置。为此，我们可以使用以下命令运行它：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following would be the result. Full output file is available on GitHub:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是结果。完整的输出文件可在 GitHub 上找到：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the output is very similar to what we received with a single
    host, but with one line per host at each step. In this case, all the machines
    were in the same state and the same steps have been performed, so we see that
    they all acted the same, but with more complex scenarios, you can have different
    machines returning different states on the same step. We can also execute the
    other two playbooks with similar results.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，输出与我们收到的单个主机非常相似，但在每个步骤中每个主机都有一行。在这种情况下，所有机器处于相同的状态，并且执行了相同的步骤，所以我们看到它们都表现得一样，但是在更复杂的场景中，你可以看到不同的机器在同一步骤上返回不同的状态。我们也可以执行另外两个播放书，结果类似。
- en: Regular expressions in the inventory file
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清单文件中的正则表达式
- en: 'When you have a large number of servers, it is common and helpful to give them
    predictable names, for instance, call all web servers `wsXY` or `webXY`, or call
    the database servers `dbXY`. If you do so, you can reduce the number of lines
    in your hosts file, increasing its readability. For instance, our hosts file can
    be simplified as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有大量服务器时，给它们起一个可预测的名字是常见和有用的，例如，将所有网络服务器命名为`wsXY`或`webXY`，或者将数据库服务器命名为`dbXY`。如果你这样做，你可以减少主机文件中的行数，增加其可读性。例如，我们的主机文件可以简化如下：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we have used `[01:02]` that will match for all occurrences
    between the first number (`01` in our case) and the last (`02` in our case). In
    our case, the gain is not huge, but if you have 40 web servers, you can cut 39
    lines from your hosts file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`[01:02]`，它将匹配第一个数字（在我们的例子中是`01`）和最后一个数字（在我们的例子中是`02`）之间的所有出现。在我们的案例中，收益并不巨大，但如果你有40台网络服务器，你可以从主机文件中减少39行。
- en: In this section, we have seen how to create an inventory file, how to add groups
    to an Ansible inventory, how to leverage ranges to speed up the process of the
    creation of inventories, and how to run an Ansible playbook against an inventory.
    We will now see how to set variables in inventories and how to use them in our
    playbooks.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们已经看到了如何创建清单文件，如何向Ansible清单添加组，如何利用范围来加快清单创建过程，并如何针对清单运行Ansible playbook。现在我们将看到如何在清单中设置变量以及如何在我们的playbooks中使用它们。
- en: Working with variables
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变量
- en: Ansible allows you to define variables in many ways, from a variable file within
    a playbook, by passing it from the Ansible command using the `-e` / `--extra-vars`
    option. You can also do it by passing it to an inventory file. You can define
    variables in an inventory file either on a per-host basis, for an entire group,
    or by creating a variable file in the directory where your inventory file exists.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible允许你以多种方式定义变量，从playbook中的变量文件，通过使用`-e`/`--extra-vars`选项从Ansible命令传递它。你也可以通过将其传递给清单文件来定义变量。你可以在清单文件中的每个主机，整个组或在清单文件所在目录中创建一个变量文件来定义变量。
- en: Host variables
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机变量
- en: 'It''s possible to declare variables for a specific host, declaring them in
    the hosts file. For instance, we may want to specify different engines for our
    web servers. Let''s suppose that one needs to reply to a specific domain, while
    the other needs to reply to a different domain name. In this case, we would do
    it with the following hosts file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为特定主机声明变量，在主机文件中声明它们。例如，我们可能希望为我们的网络服务器指定不同的引擎。假设一个需要回复到一个特定的域，而另一个需要回复到不同的域名。在这种情况下，我们会在以下主机文件中执行：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Every time we execute a playbook with this inventory, Ansible will first read
    the inventory file, and it will assign, on a per-host basis, the value of the
    `domainname` variable. In this way, all playbooks running on web servers will
    be able to refer to the `domainname` variable.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们使用此清单执行playbook时，Ansible将首先读取清单文件，并将根据每个主机分配`domainname`变量的值。这样，所有在网络服务器上运行的playbook将能够引用`domainname`变量。
- en: Group variables
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组变量
- en: 'There are other cases where you want to set a variable that is valid for the
    whole group. Let''s suppose that we want to declare the variable `https_enabled`
    to `True` and its value has to be equal for all web servers. In this case, we
    can create a `[webserver:vars]` section, so we will use the following hosts file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，你可能想要设置一个整个组都有效的变量。假设我们想要声明变量`https_enabled`为`True`，并且其值必须对所有网络服务器都相等。在这种情况下，我们可以创建一个`[webserver:vars]`部分，因此我们将使用以下主机文件：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember that host variables will override group variables if the same variable
    is declared in both spaces.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果相同的变量在两个空间中都声明了，主机变量将覆盖组变量。
- en: Variable files
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量文件
- en: Sometimes, you have a lot of variables to declare for each host and group, and
    the hosts file gets hard to read. In those cases, you can move the variables to
    specific files. For host-level variables, you'll need to create a file named the
    same as your host in the `host_vars` folder, while for group variables you'll
    have to use the group name for the file name and place them in the `group_vars`
    folder.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要为每个主机和组声明大量的变量，主机文件变得难以阅读。在这些情况下，你可以将变量移动到特定的文件中。对于主机级别的变量，你需要在`host_vars`文件夹中创建一个与你的主机同名的文件，而对于组变量，你需要使用组名作为文件名，并将它们放置在`group_vars`文件夹中。
- en: 'So, if we want to replicate the previous example of host-based variables using
    files, we will need to create the `host_vars/ws01.fale.io` file with the following
    content:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想要复制先前基于主机变量使用文件的示例，我们需要创建 `host_vars/ws01.fale.io` 文件，内容如下：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we create the `host_vars/ws02.fale.io` file with the following content:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建 `host_vars/ws02.fale.io` 文件，内容如下：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'While if we want to replicate the group-based variables example, we will need
    to have the `group_vars/webserver` file with the following content:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 而如果我们想要复制基于组变量的示例，我们将需要具有以下内容的 `group_vars/webserver` 文件：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Inventory variables follow a hierarchy; at the top of this is the common variable
    file (we discussed this in the previous section, *Working with inventory files*)
    that will override any of the host variables, group variables, and inventory variable
    files. After this come the host variables, which will override group variables;
    lastly, group variables will override inventory variable files.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 清单变量遵循一种层次结构；在其顶部是公共变量文件（我们在上一节 *使用清单文件* 中讨论过），它将覆盖任何主机变量、组变量和清单变量文件。接下来是主机变量，它将覆盖组变量；最后，组变量将覆盖清单变量文件。
- en: Overriding configuration parameters with an inventory file
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用清单文件覆盖配置参数
- en: You can override some of Ansible's configuration parameters directly through
    the inventory file. These configuration parameters will override all the other
    parameters that are set either through `ansible.cfg`, environment variables, or
    set in the playbooks themselves. Variables passed to the `ansible-playbook/ansible`
    command have priority over any other variable, including the ones set in the inventory
    file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接通过清单文件覆盖一些 Ansible 的配置参数。这些配置参数将覆盖所有其他通过 `ansible.cfg`、环境变量或在 playbooks
    中设置的参数。传递给 `ansible-playbook/ansible` 命令的变量优先级高于清单文件中设置的任何其他变量。
- en: 'The following is the list of some parameters you can override from an inventory
    file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可以从清单文件覆盖的参数列表：
- en: '`ansible_user`: This parameter is used to override the user that is used for
    communicating with the remote host. Sometimes, a certain machine needs a different
    user; in those cases, this variable will help you. For instance, if you are running
    Ansible from the *ansible* user but on the remote machine you need to connect
    to the *automation* user, setting `ansible_user=automation` will make it happen.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_user`：该参数用于覆盖与远程主机通信所使用的用户。有时，某台机器需要不同的用户；在这种情况下，这个变量会帮助你。例如，如果你是从
    *ansible* 用户运行 Ansible，但在远程机器上需要连接到 *automation* 用户，设置 `ansible_user=automation`
    就会实现这一点。'
- en: '`ansible_port`: This parameter will override the default SSH port with the
    user-specified port. Sometimes, sysadmin chooses to run SSH on a non-standard
    port. In this case, you''ll need to instruct Ansible about the change. If in your
    environment the SSH port is 22022 instead of 22, you will need to use `ansible_port=22022`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_port`：该参数将用用户指定的端口覆盖默认的 SSH 端口。有时，系统管理员选择在非标准端口上运行 SSH。在这种情况下，你需要通知
    Ansible 进行更改。如果在你的环境中 SSH 端口是 22022 而不是 22，你将需要使用 `ansible_port=22022`。'
- en: '`ansible_host`: This parameter is used to override the host for an alias. If
    you want to connect by the DNS name (that is: `ws01.fale.io`) to the `10.0.0.3`
    machine, but for some reason the DNS would not resolve the host properly, you
    can force Ansible to use this IP instead of what the DNS would resolve, by setting
    the `ansible_host=10.0.0.3` variable.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_host`：该参数用于覆盖别名的主机。如果你想通过 DNS 名称（即：`ws01.fale.io`）连接到 `10.0.0.3` 机器，但由于某些原因
    DNS 未能正确解析主机，你可以通过设置 `ansible_host=10.0.0.3` 变量，强制 Ansible 使用该 IP 而不是 DNS 解析出的
    IP。'
- en: '`ansible_connection`: This specifies the connection type to the remote host.
    The values are SSH, Paramiko, or local. Even though Ansible could connect to the
    local machine using its SSH daemon, this wastes lots of resources. In those cases,
    you can specify `ansible_connection=local` so that Ansible will open a standard
    shell instead of SSH.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_connection`：这指定了到远程主机的连接类型。值可以是 SSH、Paramiko 或本地。即使 Ansible 可以使用其
    SSH 守护程序连接到本地机器，但这会浪费大量资源。在这些情况下，你可以指定 `ansible_connection=local`，这样 Ansible 将打开一个标准
    shell 而不是 SSH。'
- en: '`ansible_private_key_file`: This parameter will override the private key used
    for SSH; this will be useful if you want to use specific keys for a specific host.
    A common use case is if you have hosts spread across multiple data centers, multiple
    AWS regions, or different kinds of applications. Private keys can potentially
    be different in such scenarios.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_private_key_file`：此参数将覆盖用于 SSH 的私钥；如果您想为特定主机使用特定密钥，则这将非常有用。常见的用例是，如果您的主机分布在多个数据中心、多个
    AWS 区域或不同类型的应用程序中。在这种情况下，私钥可能不同。'
- en: '`ansible__type`: By default, Ansible uses the `sh` shell; you can override
    this using the `ansible_shell_type` parameter. Changing this to `csh`, `ksh`,
    and so on will make Ansible use the commands of that shell. This can be useful
    if you need to execute some `csh` or `ksh` scripts you have and it would be too
    costly to deal with them right away.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible__type`：默认情况下，Ansible 使用 `sh` shell；您可以使用 `ansible_shell_type` 参数覆盖此行为。将其更改为
    `csh`、`ksh` 等将使 Ansible 使用该 shell 的命令。如果您需要执行一些 `csh` 或 `ksh` 脚本，并且立即处理它们会很昂贵，那么这可能会有所帮助。'
- en: Working with dynamic inventories
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态清单
- en: There are environments where you have a system that creates and destroys machines
    automatically. We will see how to do this with Ansible in [Chapter 5](9bd9ae64-df2b-4dd0-b43e-da6da4553943.xhtml),
    *Going Cloud.* In such environments, the list of machines changes very quickly
    and keeping the hosts file becomes complicated. In this case, we can use dynamic
    inventories to solve the problem.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有些环境中，你有一个系统可以自动创建和销毁机器。我们将在[第五章](9bd9ae64-df2b-4dd0-b43e-da6da4553943.xhtml)，*云之旅*中看到如何使用
    Ansible 完成这个任务。在这种环境中，机器列表变化非常快，维护主机文件变得复杂。在这种情况下，我们可以使用动态清单来解决这个问题。
- en: The idea behind dynamic inventories is that Ansible will not read the hosts
    file but instead execute a script that will return the list of hosts to Ansible
    in JSON format. This allows you, for instance, to query your cloud provider and
    ask it directly about the machines in your entire infrastructure that are running
    at any given moment.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 动态清单背后的想法是 Ansible 不会读取主机文件，而是执行一个返回主机列表的脚本，并以 JSON 格式返回给 Ansible。这允许您直接查询您的云提供商，询问在任何给定时刻运行的整个基础设施中的机器列表。
- en: Many scripts for the most common cloud providers are already available through
    Ansible at [https://github.com/ansible/ansible/tree/devel/contrib/inventory](https://github.com/ansible/ansible/tree/devel/contrib/inventory),
    but you can create a custom script if you have different needs. The Ansible inventory
    scripts can be written in any language but, for consistency reasons, dynamic inventory
    scripts should be written in Python. Remember that these scripts need to be executable
    directly, so please remember to set them with the executable flag (`chmod + x
    inventory.py`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Ansible，已经提供了大多数常见云提供商的许多脚本，可以在[https://github.com/ansible/ansible/tree/devel/contrib/inventory](https://github.com/ansible/ansible/tree/devel/contrib/inventory)找到，但如果您有不同的需求，也可以创建自定义脚本。Ansible
    清单脚本可以用任何语言编写，但出于一致性考虑，动态清单脚本应使用 Python 编写。请记住，这些脚本需要直接可执行，因此请记得为它们设置可执行标志（`chmod
    + x inventory.py`）。
- en: Next, we will take a look at Amazon Web Services and DigitalOcean scripts that
    can be downloaded from the official Ansible repository.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看可以从官方 Ansible 仓库下载的 Amazon Web Services 和 DigitalOcean 脚本。
- en: Amazon Web Services
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Amazon Web Services
- en: 'To allow Ansible to gather data from **Amazon Web Services** (**AWS**) about
    your EC2 instances, you need to download the following two files from Ansible''s
    GitHub repository at [https://github.com/ansible/ansible](https://github.com/ansible/ansible):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许 Ansible 从**Amazon Web Services**（**AWS**）收集关于您的 EC2 实例的数据，您需要从 Ansible 的
    GitHub 仓库下载以下两个文件：[https://github.com/ansible/ansible](https://github.com/ansible/ansible)。
- en: The `ec2.py` inventory script
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ec2.py` 清单脚本'
- en: The `ec2.ini` file, which contains the configuration for your EC2 inventory
    script
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ec2.ini` 文件包含了您的 EC2 清单脚本的配置。'
- en: Ansible uses **Boto**, the AWS Python SDK, to communicate with AWS using APIs.
    To allow this communication, you need to export the `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`
    variables.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 使用**Boto**，AWS Python SDK，通过 API 与 AWS 进行通信。为了允许此通信，您需要导出 `AWS_ACCESS_KEY_ID`
    和 `AWS_SECRET_ACCESS_KEY` 变量。
- en: 'You can use the inventory in two ways:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以两种方式使用清单：
- en: Pass it directly to an `ansible-playbook` command using the `-i` option and
    copy the `ec2.ini` file to your current directory where you are running the Ansible
    commands.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `-i` 选项将其直接传递给 `ansible-playbook` 命令，并将 `ec2.ini` 文件复制到您运行 Ansible 命令的当前目录。
- en: Copy the `ec2.py` file to `/etc/ansible/hosts`, and make it executable using
    `chmod +x`, and copy the `ec2.ini` file to `/etc/ansible/ec2.ini`.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`ec2.py`文件复制到`/etc/ansible/hosts`，并使用`chmod +x`使其可执行，然后将`ec2.ini`文件复制到`/etc/ansible/ec2.ini`。
- en: The `ec2.py` file will create multiple groups based on the region, availability
    zone, tags, and so on. You can check the contents of the inventory file by running
    `./ec2.py --list`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ec2.py`文件将根据地区、可用区、标签等创建多个组。您可以通过运行`./ec2.py --list`来检查清单文件的内容。'
- en: 'Let''s see an example playbook with the EC2 dynamic inventory, which will simply
    ping all machines in my account:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用EC2动态清单的示例playbook，它将简单地ping我的帐户中的所有机器：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since we executed the ping module, we expect the machines available in the
    configured account to reply to us. Since I have just one EC2 machine with the
    IP address 52.28.138.231 currently in my account, we can expect it to reply, and
    in fact the EC2 I have on my account responded with the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们执行了ping模块，我们期望配置的帐户中可用的机器会回复我们。由于我当前帐户中只有一台带有IP地址52.28.138.231的EC2机器，我们可以期望它会回复，实际上我的帐户上的EC2回复如下：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding example, we're using the `ec2.py` script instead of a static
    inventory file with the `-i` option and the ping command.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们使用`ec2.py`脚本而不是静态清单文件，并使用`-i`选项和ping命令。
- en: Similarly, you can use these inventory scripts to perform various types of operations.
    For example, you can integrate them with your deployment script to figure out
    all the nodes in a single zone and deploy to them if you're performing your deployment
    zone-wise (a zone represents a data center) in AWS.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以使用这些清单脚本执行各种类型的操作。例如，您可以将它们与您的部署脚本集成，以找出单个区域中的所有节点，并在执行区域部署时部署到这些节点（一个区域表示一个数据中心）在AWS中。
- en: If you simply want to know what the web servers in the cloud are and you've
    tagged them using a certain convention, you can do that by using the dynamic inventory
    script by filtering out the tags. Furthermore, if you have special scenarios that
    are not covered by your present script, you can enhance it to provide the required
    set of nodes in JSON format and then act on those nodes from the playbooks. If
    you're using a database to manage your inventory, your inventory script can query
    the database and dump a JSON. It could even sync with your cloud and update your
    database on a regular basis.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想知道云中的web服务器是什么，并且您已经使用某种约定对它们进行了标记，您可以通过使用动态清单脚本来过滤掉标记来实现。此外，如果您有未涵盖的特殊情况，您可以增强它以提供所需的节点集以JSON格式，并从playbooks中对这些节点进行操作。如果您正在使用数据库来管理您的清单，您的清单脚本可以查询数据库并转储JSON。它甚至可以与您的云同步，并定期更新您的数据库。
- en: DigitalOcean
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DigitalOcean
- en: As we used the EC2 files in [https://github.com/ansible/ansible/tree/devel/contrib/inventory](https://github.com/ansible/ansible/tree/devel/contrib/inventory)
    to pull data from AWS, we can do the same for DigitalOcean. The only difference
    will be that we have to fetch the `digital_ocean.ini` and the `digital_ocean.py`
    files.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[https://github.com/ansible/ansible/tree/devel/contrib/inventory](https://github.com/ansible/ansible/tree/devel/contrib/inventory)中使用EC2文件从AWS中提取数据一样，我们可以对DigitalOcean执行相同的操作。唯一的区别是我们必须获取`digital_ocean.ini`和`digital_ocean.py`文件。
- en: As before, we will need to tweak the `digital_ocean.ini` options, if needed,
    and to make the Python file executable. The only option that you'll probably need
    to change is `api_token`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，如果需要，我们需要调整`digital_ocean.ini`选项，并将Python文件设置为可执行。你唯一可能需要更改的选项是`api_token`。
- en: 'Now we can try to ping the two machines I''ve provisioned on DigitalOcean with
    the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试ping我在DigitalOcean上预配的两台机器，如下所示：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As expected, the two droplets I have on my account respond with the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我帐户中的两个droplets响应如下：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have now seen how easy it is to retrieve data from many different cloud providers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到从许多不同的云提供商检索数据是多么容易。
- en: Working with iterates in Ansible
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Ansible中使用迭代器
- en: You may have noticed that up to now we have never used cycles, so every time
    we had to do multiple, similar operations, we wrote the code multiple times. An
    example of this is the `webserver.yaml` code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，到目前为止，我们从未使用过循环，因此每次我们必须执行多个相似的操作时，我们都会多次编写代码。其中一个示例是`webserver.yaml`代码。
- en: 'In fact, this is the last part of the `webserver.yaml` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是`webserver.yaml`文件的最后一部分：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, the last two blocks of the `webserver.yaml` code do very similar
    operations: ensure that a certain port of the firewall is open.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`webserver.yaml`代码的最后两个块执行的操作非常相似：确保防火墙的某个端口是打开的。
- en: Using standard iteration – with_items
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准迭代 - with_items
- en: Repeating code is not a problem per se, but it does not scale.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 重复的代码本身并非问题，但它不具备可扩展性。
- en: Ansible allows us to use iteration to improve the code both as clarity and maintainability.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible允许我们使用迭代来提高代码的清晰度和可维护性。
- en: 'To improve the preceding code, we can use a simple iteration: `with_items`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进上述代码，我们可以使用简单的迭代：`with_items`。
- en: This allows us to iterate in a list of items. At every iteration, the designated
    item of the list will be available to us in the item variable. This allows us
    to perform multiple similar operations in a single block.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够对项目列表进行迭代。在每次迭代中，列表的指定项目将在item变量中可用。这使我们能够在单个块中执行多个类似的操作。
- en: 'We can therefore change the last part of the `webserver.yaml` code to the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将`webserver.yaml`代码的最后一部分更改为以下内容：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can execute it as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式执行它：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We receive the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下内容：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the output is slightly different than the previous execution.
    In fact, on the lines for operations with loops, we can see the `item` that was
    processed in that specific iteration of the `Ensure HTTP and HTTPS can pass the
    firewall` block.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，输出与先前执行略有不同。事实上，在具有循环操作的行上，我们可以看到在`Ensure HTTP and HTTPS can pass the firewall`块的特定迭代中处理的`item`。
- en: We have now seen that we can iterate on a list of items, but Ansible allows
    us other kinds of iterations as well.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到我们可以对项目列表进行迭代，但是Ansible还允许我们进行其他类型的迭代。
- en: Using nested loops – with_nested
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用嵌套循环 - with_nested
- en: There are cases where you have to iterate all elements of a list with all items
    from other lists (Cartesian product). One case that is very common is when you
    have to create multiple folders in multiple paths. In our example, we will create
    the folders `mail` and `public_html` in the home folders of the users `alice`
    and `bob`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，您必须对列表中的所有元素与其他列表中的所有项进行迭代（笛卡尔积）。一个非常常见的情况是当您必须在多个路径中创建多个文件夹时。在我们的例子中，我们将在用户`alice`和`bob`的主目录中创建文件夹`mail`和`public_html`。
- en: 'We can do so with the following code snippet from the `with_nested.yaml` file;
    the full code is available on GitHub:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`with_nested.yaml`文件中的以下代码片段来实现；完整的代码可在 GitHub 上找到：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run this with the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方式运行此命令：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We receive the following result. Full output file is available on GitHub:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下结果。完整的输出文件可在 GitHub 上找到：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see from the output, Ansible created the users alice and bob on all
    target machines, and it also created the folders `$HOME/mail` and `$HOME/public_html`
    for both users on all machines.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Ansible在所有目标机器上创建了用户alice和bob，并且还为这两个用户在所有机器上的文件夹`$HOME/mail`和`$HOME/public_html`。
- en: Fileglobs loop – with_fileglobs
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件通配符循环 - with_fileglobs
- en: 'Sometimes, we want to perform an action on every file present in a certain
    folder. This could be handy if you want to copy multiple files with similar names
    from one folder to another. To do so, you can create a file called `with_fileglobs.yaml`
    with the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望对某个特定文件夹中的每个文件执行操作。如果你想要从一个文件夹复制多个文件到另一个文件夹中，这可能会很方便。为此，你可以创建一个名为`with_fileglobs.yaml`的文件，其中包含以下代码：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can execute it with the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式执行它：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This results in the following output. Full output file is available on GitHub.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下输出。完整的输出文件可在 GitHub 上找到。
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As for our goal, we have created the /tmp/iproute2 folder and populated with
    a copy of the files in the `/etc/iproute2` folder. This pattern is often used
    to create backups of configurations.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 至于我们的目标，我们已经创建了`/tmp/iproute2`文件夹，并用`/etc/iproute2`文件夹中文件的副本填充了它。这种模式经常用于创建配置的备份。
- en: Using an integer loop – with_sequence
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用整数循环 - with_sequence
- en: 'Many times, you''ll need to iterate over the integer numbers. An example could
    be to create ten folders called `fileXY`, where `X` and `Y` are sequential numbers
    from `1` to `10`. To do so, we can create a file called `with_sequence.yaml` with
    the following code in it:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，你需要对整数进行迭代。一个例子是创建十个名为`fileXY`的文件夹，其中`X`和`Y`是从`1`到`10`的连续数字。为此，我们可以创建一个名为`with_sequence.yaml`的文件，其中包含以下代码：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Unlike the majority of Ansible commands, where we can use the single-line notation
    for objects and the standard YAML multi-line notation, `with_sequence` only supports
    the single line notation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数 Ansible 命令不同，我们可以在对象上使用单行符号和标准 YAML 多行符号，`with_sequence` 只支持单行符号。
- en: 'We can then execute it with the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令执行它：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will receive this output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到以下输出：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Ansible supports many more types of loop, but since they are used far less,
    you can refer directly to the official documentation about loops at: [http://docs.ansible.com/ansible/playbooks_loops.html](http://docs.ansible.com/ansible/playbooks_loops.html).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 支持更多类型的循环，但由于它们的使用要少得多，你可以直接参考官方文档了解循环：[http://docs.ansible.com/ansible/playbooks_loops.html](http://docs.ansible.com/ansible/playbooks_loops.html)。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored a large number of concepts that will help
    scale your infrastructure beyond the single node. We started with inventory files
    used to instruct Ansible about our machines, and then we covered how to have host-specific
    and group-specific variables while running the same command on multiple heterogeneous
    hosts. We then moved on to dynamic inventories that are populated directly by
    some other system (usually a cloud provider). Finally, we analyzed multiple kinds
    of iteration in the Ansible playbooks.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了大量的概念，将帮助您将基础设施扩展到单个节点之外。我们从用于指示 Ansible 关于我们机器的清单文件开始，然后我们介绍了如何在运行相同命令的多个异构主机上拥有主机特定和组特定的变量。然后，我们转向由某些其他系统（通常是云提供商）直接填充的动态清单。最后，我们分析了
    Ansible playbook 中的多种迭代方式。
- en: In the next chapter, we will structure our Ansible files in a saner way to ensure
    maximum readability. To do this, we introduce roles that simplify the management
    of complex environments even more.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将以更合理的方式结构化我们的 Ansible 文件，以确保最大的可读性。为此，我们引入了角色，进一步简化了复杂环境的管理。
