- en: Automating Juniper Devices in the Service Providers Using Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible自动化Juniper设备的服务提供商
- en: 'In this chapter, we will outline how to automate Juniper devices running the
    Junos OS software in a typical **service provider** (**SP**) environment. We will
    explore how to interact with Juniper devices using Ansible, and how to provision
    different services and protocols on Juniper devices using various Ansible modules.
    We will base our illustration on the following sample network diagram of a basic
    SP network:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将概述如何在典型的**服务提供商**（**SP**）环境中自动化运行Junos OS软件的Juniper设备。我们将探讨如何使用Ansible与Juniper设备交互，以及如何使用各种Ansible模块在Juniper设备上配置不同的服务和协议。我们将以以下示例网络图为基础进行说明，该示例网络图显示了基本SP网络的拓扑：
- en: '![](assets/13923e95-73e7-4fb8-b34e-cc346f018842.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/13923e95-73e7-4fb8-b34e-cc346f018842.png)'
- en: 'The following table outlines the devices in our sample topology and their respective
    management **Internet Protocols** (**IPs**):'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格概述了我们示例拓扑中的设备及其各自的管理**Internet Protocols**（**IPs**）：
- en: '| **Device** | **Role** | **Vendor** | **Management (MGMT) Port** | **MGMT
    IP** |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| **设备** | **角色** | **供应商** | **管理（MGMT）端口** | **MGMT IP** |'
- en: '| `mxp01` | P Router | Juniper vMX 14.1 | `fxp0` | `172.20.1.2` |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| `mxp01` | P路由器 | Juniper vMX 14.1 | `fxp0` | `172.20.1.2` |'
- en: '| `mxp02` | P Router | Juniper vMX 14.1 | `fxp0` | `172.20.1.3` |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| `mxp02` | P路由器 | Juniper vMX 14.1 | `fxp0` | `172.20.1.3` |'
- en: '| `mxpe01` | PE Router | Juniper vMX 14.1 | `fxp0` | `172.20.1.4` |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| `mxpe01` | PE路由器 | Juniper vMX 14.1 | `fxp0` | `172.20.1.4` |'
- en: '| `mxpe02` | PE Router | Juniper vMX 17.1 | `fxp0` | `172.20.1.5` |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| `mxpe02` | PE路由器 | Juniper vMX 17.1 | `fxp0` | `172.20.1.5` |'
- en: 'The main recipes covered in this chapter are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要操作如下：
- en: Building the network inventory
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建网络清单
- en: Connecting and authenticating to Juniper devices
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接并对Juniper设备进行身份验证
- en: Enabling the **Network Configuration Protocol** (**NETCONF**) on Junos OS devices
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Junos OS设备上启用**网络配置协议**（**NETCONF**）
- en: Configuring generic system options on Juniper devices
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Juniper设备上配置通用系统选项
- en: Configuring interfaces on Juniper devices
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Juniper设备上配置接口
- en: Configuring **Open Shortest Path First** (**OSPF**) on Juniper devices
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Juniper设备上配置**开放最短路径优先**（**OSPF**）
- en: Configuring **Multiprotocol Label Switching** (**MPLS**) on Juniper devices
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Juniper设备上配置**多协议标签交换**（**MPLS**）
- en: Configuring the **Border Gate Protocol** (**BGP**) on Juniper devices
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Juniper设备上配置**边界网关协议**（**BGP**）
- en: Deploying configuration on Juniper devices
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Juniper设备上部署配置
- en: Configuring the **Layer 3 virtual private network** (**L3VPN**) service on Juniper
    devices
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Juniper设备上配置**第3层虚拟专用网络**（**L3VPN**）服务
- en: Gathering Juniper device facts using Ansible
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible收集Juniper设备信息
- en: Validating network reachability on Juniper devices
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证Juniper设备的网络可达性
- en: Retrieving operational data from Juniper devices
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Juniper设备检索操作数据
- en: Validating the network state using PyEZ operational tables
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PyEZ操作表验证网络状态
- en: Technical requirements
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch3_junos](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch3_junos).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在此处找到：[https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch3_junos](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch3_junos)。
- en: 'The following are the software releases on which this chapter is based:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于以下软件版本：
- en: Ansible machine running CentOS 7
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行CentOS 7的Ansible机器
- en: Ansible 2.9
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 2.9
- en: Juniper **Virtual MX** (**vMX**) running Junos OS 14.1R8 and Junos OS 17.1R1
    release
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Juniper **Virtual MX** (**vMX**)运行Junos OS 14.1R8和Junos OS 17.1R1版本
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：
- en: '[https://bit.ly/3ajF4Mp](https://bit.ly/3ajF4Mp)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/3ajF4Mp](https://bit.ly/3ajF4Mp)'
- en: Building the network inventory
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建网络清单
- en: In this recipe, we will outline how to build and structure the Ansible inventory
    to describe the sample SP network setup outlined previously. The Ansible inventory
    is a pivotal part in Ansible, as it defines and groups devices that should be
    managed by Ansible.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本操作中，我们将概述如何构建和组织Ansible清单，以描述先前概述的示例SP网络设置。Ansible清单是Ansible的关键部分，因为它定义并分组应由Ansible管理的设备。
- en: Getting ready
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We create a new folder that will host all the files that we will create in this
    chapter. The new folder is named `ch3_junos`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新文件夹，用于存放本章中创建的所有文件。新文件夹名为`ch3_junos`。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Inside the new folder, `ch3_junos`, we create a `hosts` file with the following
    content:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹`ch3_junos`中，我们创建一个`hosts`文件，内容如下：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create an `Ansible.cfg` file, as shown in the following code:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Ansible.cfg`文件，如下所示：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We build the Ansible inventory using the `hosts` file and we define multiple
    groups in order to group the different devices in our network infrastructure,
    as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`hosts`文件构建Ansible清单，并定义多个组，以便对网络基础设施中的不同设备进行分组。
- en: We create the `PE` group, which references all the MPLS **Provider Edge** (**PE**)
    nodes in our topology.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建`PE`组，引用拓扑中所有MPLS **Provider Edge** (**PE**)节点。
- en: We create the `P` group, which references all the MPLS **Provider** (**P**)
    nodes in our topology.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建`P`组，引用拓扑中所有MPLS **Provider** (**P**)节点。
- en: We create the `junos` group, which references all the devices running Junos
    OS as the OS.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建`junos`组，引用所有运行Junos OS的设备。
- en: We create the `core parent` group, which references both the `PE` and `P` groups.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建`core parent`组，引用`PE`和`P`组。
- en: Finally, we create the `Ansible.cfg` file and configure it to point to our `hosts`
    file, to be used as the Ansible inventory file. We set the `gathering` to `explicit` in
    order to disable the setup module, which runs by default to discover facts for
    the managed hosts. Disabling the setup module is mandatory since the setup module
    will fail when run against network devices.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建`Ansible.cfg`文件并配置它指向我们的`hosts`文件，用作Ansible清单文件。我们将`gathering`设置为`explicit`，以禁用默认运行的setup模块，该模块用于发现受管主机的事实。禁用setup模块是强制性的，因为针对网络设备运行setup模块时会失败。
- en: 'We can validate that our Ansible inventory is structured and written correctly
    by typing the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过输入以下命令来验证我们的Ansible清单是否结构良好并正确编写：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Connecting and authenticating to Juniper devices
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接和身份验证Juniper设备
- en: In this recipe, we will outline how to connect and authenticate to Juniper devices
    from Ansible via **Secure Shell** (**SSH**), in order to start managing the Juniper
    devices. We are going to outline how to use SSH keys as the authentication method
    to establish communication between Ansible and the Juniper devices.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将概述如何通过**Secure Shell**（**SSH**）从Ansible连接和身份验证Juniper设备，以开始管理Juniper设备。我们将概述如何使用SSH密钥作为身份验证方法来建立Ansible和Juniper设备之间的通信。
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to follow along with this recipe, an Ansible inventory file should
    be constructed as per the previous recipe. IP reachability between the Ansible
    control machine and all the devices in the network must be configured.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按照这个示例操作，应该按照上一个示例构建一个Ansible清单文件。Ansible控制机器和网络中所有设备之间的IP可达性必须配置好。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'On the Ansible machine, create the private and public SSH keys in our `ch3_junos` working
    directory, as shown in the following code:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Ansible机器上，在我们的`ch3_junos`工作目录中创建私钥和公钥，如下所示：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Capture the public key that was created in the previous step, as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获在上一步创建的公钥，如下所示：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On the Juniper devices, add a new user called `admin` and designate that we
    will use SSH keys for authentication for this user. Copy the public SSH key that
    was created on the Ansible machine to the device, as shown in the following code:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Juniper设备上，添加一个名为`admin`的新用户，并指定我们将使用SSH密钥对对该用户进行身份验证。将在Ansible机器上创建的公钥复制到设备上，如下所示：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We start by creating the public and private SSH keys on the Ansible control
    machine, using the `SSH-keygen` command and specifying the following options:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在Ansible控制机器上使用`SSH-keygen`命令创建公钥和私钥，并指定以下选项：
- en: We specify the encryption algorithm with the `-t` option, and we set it to `rsa`.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`-t`选项指定加密算法，并将其设置为`rsa`。
- en: We specify the size of the encryption key using the `-b` option, and we set
    the size to `2048` bits.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`-b`选项指定加密密钥的大小，并将大小设置为`2048`位。
- en: We specify the location to save the private and public keys using the `-f` option,
    and we specify the name for the public and private key that will be generated,
    which will be `Ansible_SSH_key`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`-f`选项指定保存私钥和公钥的位置，并指定将生成的公钥和私钥的名称，即`Ansible_SSH_key`。
- en: 'Once we run the command, we will see that the following two files (the private
    and public SSH keys) are generated, as shown here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行命令，我们将看到生成了以下两个文件（私钥和公钥），如下所示：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: On all the Juniper devices in our inventory, we create the `admin` user and
    we specify that we will use SSH keys for authentication. We paste the contents
    of the public key that we have created on the Ansible control machine under the
    `authentication` stanza for this new user. With this configuration, any host who
    has the corresponding private key can authenticate and log in to the Juniper devices
    as the `admin` user.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的清单中的所有Juniper设备上，我们创建`admin`用户，并指定我们将使用SSH密钥进行身份验证。我们将在这个新用户的`authentication`部分下粘贴在Ansible控制机器上创建的公钥的内容。通过这个配置，任何拥有相应私钥的主机都可以作为`admin`用户进行身份验证并登录到Juniper设备。
- en: 'In order to test and validate that we have successfully logged in to the Junos
    OS devices from the compute nodes, we can test this using the Ansible command
    shown in the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试和验证我们是否成功从计算节点登录到Junos OS设备，我们可以使用下面代码中显示的Ansible命令进行测试：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We specify the username to connect to the devices using the `-u` option and
    we specify the private SSH key using the `–private-key` option. Finally, we use
    the `-c` option in order to specify the connection plugin used to connect to the
    managed devices, and, in this case, we use the `network_cli` connection plugin
    to open an SSH session with the managed Juniper devices.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`-u`选项指定连接设备的用户名，并使用`–private-key`选项指定私钥。最后，我们使用`-c`选项来指定用于连接到受管设备的连接插件，这种情况下，我们使用`network_cli`连接插件来与受管Juniper设备建立SSH会话。
- en: There's more...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In order to use the SSH keys that we have generated in our playbooks, we can
    specify the username and the SSH private key file that we will use to authenticate
    to our Juniper devices as host or group variables in Ansible. In our case, we
    will set these variables as group variables for the `junos` group. We create the
    `group_vars` directory, and we create the `junos.yml` file, and we specify the
    variables as shown in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的playbooks中使用生成的SSH密钥，我们可以在Ansible中的主机或组变量中指定用户名和SSH私钥文件，以便对Juniper设备进行身份验证。在我们的情况下，我们将这些变量设置为`junos`组的组变量。我们创建`group_vars`目录，并创建`junos.yml`文件，并按照下面的代码指定变量：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We test the connection between Ansible and our devices again using the `Ansible`
    command; however, this time, without specifying any parameters, as shown in the
    following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`Ansible`命令测试Ansible与我们的设备之间的连接；但是这次不指定任何参数，如下所示：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Enabling NETCONF on Junos OS devices
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Junos OS设备上启用NETCONF
- en: In this recipe, we will outline how to enable the NETCONF protocol on Junos
    OS devices. This task is critical since we will use the NETCONF API in all the
    future recipes to manage the Juniper devices. The NETCONF API provides several
    advantages compared to the traditional SSH access method, and that is why we will
    use it in all our interactions with the Junos OS devices.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将概述如何在Junos OS设备上启用NETCONF协议。这个任务非常关键，因为我们将在以后的所有示例中使用NETCONF API来管理Juniper设备。与传统的SSH访问方法相比，NETCONF
    API提供了几个优势，这就是为什么我们将在与Junos OS设备的所有交互中使用它的原因。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As a prerequisite for this recipe, an Ansible inventory file must be present,
    as well as the SSH authentication being deployed and working, as per the previous
    recipe.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个配方的先决条件，必须存在一个Ansible清单文件，并且必须部署和工作SSH认证，就像之前的配方一样。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new playbook called `pb_jnpr_net_build.yml`, as shown in the following
    code:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pb_jnpr_net_build.yml`的新playbook，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Update the `group_vars/junos.yml` file with the connection details, as shown
    in the following code:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新`group_vars/junos.yml`文件中的连接详情：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to start interacting with the Junos OS devices via NETCONF, we need
    to enable it first, therefore we need to SSH into the device initially and enable
    NETCONF. That is why we are using the `network_cli` Ansible connection in order
    to connect with the Junos OS devices via traditional SSH. In order to use the
    `network_cli` connection plugin, we need to set `Ansible_network_os` as `junos`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始通过NETCONF与Junos OS设备进行交互，我们首先需要启用它，因此我们需要最初通过SSH连接到设备并启用NETCONF。这就是为什么我们使用`network_cli`
    Ansible连接来通过传统SSH连接到Junos OS设备。为了使用`network_cli`连接插件，我们需要将`Ansible_network_os`设置为`junos`。
- en: Since we are going to use the NETCONF API in all interactions with Juniper devices
    in all coming recipes, we enabled the `network_cli` plugin only for the `junos_netconf`
    task in this playbook via the `vars` attribute. However, for all future tasks
    that we will add in this playbook, we will use the `netconf` connection specified
    in the `Ansible_connection` attribute in the `group_vars/junos.yml` file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在所有接下来的配方中使用NETCONF API与Juniper设备进行所有交互，因此我们只为此playbook中的`junos_netconf`任务启用了`network_cli`插件，通过`vars`属性。然而，对于我们将在此playbook中添加的所有未来任务，我们将使用`group_vars/junos.yml`文件中`Ansible_connection`属性中指定的`netconf`连接。
- en: 'We create a new playbook called `pb_jnpr_net_build.yml`, and in the first task,
    we use the `junos_netconf` module to enable the NETCONF protocol on the remote
    Junos OS devices. We state the NETCONF port that will be used (by default, it
    is `830`), and we outline that this configuration must be present on the remote
    devices via the `state: present` directive.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '我们创建一个名为`pb_jnpr_net_build.yml`的新playbook，在第一个任务中，我们使用`junos_netconf`模块在远程Junos
    OS设备上启用NETCONF协议。我们指定将使用的NETCONF端口（默认情况下为`830`），并且我们概述了这个配置必须通过`state: present`指令存在于远程设备上。'
- en: 'Once we run the playbook, we will see that all the Junos OS devices are configured
    with NETCONF, as shown in the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行playbook，我们将看到所有的Junos OS设备都配置了NETCONF，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Configuring generic system options on Juniper devices
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Juniper设备上配置通用系统选项
- en: In this recipe, we will outline how to configure some generic system options
    such as hostname and **Domain Name System** (**DNS**) servers, and provision users
    on Juniper devices.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将概述如何在Juniper设备上配置一些通用的系统选项，比如主机名和**域名系统**（**DNS**）服务器，并为用户进行配置。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow along with this recipe, an Ansible inventory is assumed to be already
    set up, and NETCONF is enabled on all Juniper devices, as per the previous recipe.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循这个配方，假设已经设置了一个Ansible清单，并且根据之前的配方，在所有Juniper设备上都启用了NETCONF。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Update the `group_vars/all.yml` file with the following parameters to define
    the various system-level parameters such as `dns` and system users, as shown in
    the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下参数更新`group_vars/all.yml`文件，以定义各种系统级参数，如`dns`和系统用户，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a new playbook called `pb_jnpr_basic_config.yml` with the following
    tasks, to set up `dns`, `hostname` and system users on Juniper devices:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pb_jnpr_basic_config.yml`的新playbook，其中包含以下任务，用于在Juniper设备上设置`dns`、`hostname`和系统用户：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Ansible provides declarative modules to configure various system-level parameters
    on Juniper devices. The `junos_system` Ansible module enables us to set up the
    hostname and the DNS servers on the Juniper devices. The `junos_user` module provides
    us with the ability to set up the basic parameters for the system users on a Juniper
    device. In this example, we set up all the users who have SSH keys as their authentication
    method, and we loop over the `users` data structure and select only the users
    with the `SSH_key` option defined.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible提供了声明性模块来配置Juniper设备上的各种系统级参数。`junos_system` Ansible模块使我们能够设置Juniper设备上的主机名和DNS服务器。`junos_user`模块为我们提供了在Juniper设备上设置系统用户的基本参数的能力。在这个例子中，我们设置了所有使用SSH密钥作为他们的认证方法的用户，并且我们循环遍历`users`数据结构，并且只选择定义了`SSH_key`选项的用户。
- en: 'Once we run this playbook, we can see that the configuration on the devices
    is updated, as shown in the following code block:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行这个playbook，我们可以看到设备上的配置已经更新，如下面的代码块所示：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There's more...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The declarative Ansible modules that we have outlined in this section provide
    a simple way to configure the basic system-level parameters for Juniper devices.
    However, they might not cover all the parameters that we need to set up on a Juniper
    device. In order to have more control and flexibility to configure the system-level
    parameters on a Juniper device, we can use Jinja2 templates along with the Ansible
    `template` module to generate the specific system-level configuration needed for
    our deployment. In this section, we will outline this method in order to achieve
    this goal, and this is the method that we will use in subsequent recipes to generate
    the configuration for the other devices.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中概述的声明性Ansible模块提供了一种简单的方法来配置Juniper设备的基本系统级参数。然而，它们可能不涵盖我们需要在Juniper设备上设置的所有参数。为了更好地控制和灵活地配置Juniper设备的系统级参数，我们可以使用Jinja2模板以及Ansible的`template`模块来生成我们部署所需的特定系统级配置。在本节中，我们将概述这种方法以实现这个目标，并且这是我们将在后续的配方中使用的方法来为其他设备生成配置。
- en: 'We are going to reuse this method to generate the configuration for our Juniper
    devices for different sections, such as system, interfaces, OSPF, and MPLS. We
    are going to create an Ansible role in order to include all the Jinja2 templates
    and tasks required to generate the final configuration that we will push to our
    devices. The following procedures outline the steps needed to create the role
    and to use this role to generate the configuration:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用这种方法为Juniper设备的不同部分（如系统、接口、OSPF和MPLS）生成配置。我们将创建一个Ansible角色，以包含生成最终配置所需的所有Jinja2模板和任务。以下步骤概述了创建角色以及使用该角色生成配置所需的步骤：
- en: 'Create a new `roles` directory and add a new role called `build_router_config`
    with the following directory structure:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`roles`目录，并添加一个名为`build_router_config`的新角色，目录结构如下：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Under the `tasks` folder, create a `build_config_dir.yml` YAML file to create
    the required folders to store the configuration that will be generated, as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tasks`文件夹下，创建一个名为`build_config_dir.yml`的YAML文件，以创建存储将生成的配置的所需文件夹，如下所示：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Under the `templates` folder, create a new folder called `junos`, and within
    this folder, create a new Jinja2 template called `mgmt.j2`, with the following
    content:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates`文件夹下，创建一个名为`junos`的新文件夹，在该文件夹中创建一个名为`mgmt.j2`的新Jinja2模板，内容如下：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Under the `tasks` folder, create a new YAML file called `build_device_config.yml`,
    with the following task to create the system configuration:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tasks`文件夹下，创建一个名为`build_device_config.yml`的新的YAML文件，其中包含以下任务来创建系统配置：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a `main.yml` file under the `tasks` folder, with the following tasks:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tasks`文件夹下创建一个名为`main.yml`的文件，其中包含以下任务：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Update the `pb_jnpr_net_build.yml` playbook with the following task to generate
    the configuration for all Juniper devices in our inventory:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下任务更新`pb_jnpr_net_build.yml`播放手册，以为我们清单中的所有Juniper设备生成配置：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this method, we create a role called `build_router_config` and we create
    a new Jinja2 template called `mgmt.j2`, which includes the template for Junos
    OS system-level configuration. We use the Ansible `template` module in order to
    render the Jinja2 template with the Ansible variables defined under the `group_vars/all.yml`
    file. In order to save the configuration for each device, we create the `configs`
    folder directory, which stores the final configuration for each device.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们创建一个名为`build_router_config`的角色，并创建一个名为`mgmt.j2`的新Jinja2模板，其中包含Junos
    OS系统级配置的模板。我们使用Ansible `template`模块来使用`group_vars/all.yml`文件中定义的Ansible变量渲染Jinja2模板。为了保存每个设备的配置，我们创建`configs`文件夹目录，其中存储每个设备的最终配置。
- en: Since we will use this approach in order to generate the configuration for each
    section (MGMT, OSPF, MPLS, and so on), we will segment each section into a separate
    Jinja2 template, and we will generate each section in a separate file. We use
    the `assemble` module in order to group all these different sections into a single
    configuration file, which we will store in the `configs` directory. This is the
    `final` and `assembled` configuration file for each device. We store the temporary
    configuration snippets for each section in a temporary folder for each device,
    and we delete this temporary folder at the end of the playbook run. This is because
    we assembled the final configuration for the device, and we don't require these
    configuration snippets anymore.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用这种方法为每个部分（MGMT、OSPF、MPLS等）生成配置，我们将每个部分分割为单独的Jinja2模板，并将每个部分生成为单独的文件。我们使用`assemble`模块将所有这些不同部分组合成单个配置文件，并将其存储在`configs`目录中。这是每个设备的`final`和`assembled`配置文件。我们将每个部分的临时配置片段存储在每个设备的临时文件夹中，并在播放手册运行结束时删除此临时文件夹。这是因为我们已经为设备组装了最终配置，不再需要这些配置片段。
- en: In this playbook, we set the `Ansible_connection` to `local` as we don't need
    to connect to the devices in order to run any of the tasks within our role. We
    are only generating the configuration on the Ansible control machine, therefore
    all the tasks need to run locally on the Ansible control machine. Therefore, there
    is no need to connect to the remotely managed nodes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个手册中，我们将`Ansible_connection`设置为`local`，因为我们不需要连接到设备来运行角色中的任何任务。我们只在Ansible控制机上生成配置，因此所有任务都需要在Ansible控制机上本地运行。因此，无需连接到远程管理节点。
- en: 'Once we run the playbook, we can see that the following configuration files
    are created inside the `configs` directory:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运行播放手册后，我们可以看到`configs`目录中创建了以下配置文件：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can see the configuration generated for the `mxpe01` device as an example,
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到为`mxpe01`设备生成的配置，如下所示：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In subsequent recipes, we will outline how to push the generated configuration
    into the Juniper devices using another Ansible module.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的步骤中，我们将概述如何使用另一个Ansible模块将生成的配置推送到Juniper设备。
- en: See also...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: For more information regarding the Ansible `template` module and the different
    parameters supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/template_module.html](https://docs.ansible.com/ansible/latest/modules/template_module.html).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Ansible `template`模块和该模块支持的不同参数的更多信息，请参考以下网址：[https://docs.ansible.com/ansible/latest/modules/template_module.html](https://docs.ansible.com/ansible/latest/modules/template_module.html)。
- en: For more information regarding the Ansible `assemble` module and the different
    parameters supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/assemble_module.html](https://docs.ansible.com/ansible/latest/modules/assemble_module.html).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Ansible `assemble`模块和该模块支持的不同参数的更多信息，请参考以下网址：[https://docs.ansible.com/ansible/latest/modules/assemble_module.html](https://docs.ansible.com/ansible/latest/modules/assemble_module.html)。
- en: Configuring interfaces on Juniper devices
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Juniper设备上的接口
- en: In this recipe, we will outline how to manage interfaces on a Juniper device.
    This allows us to set different parameters for our interfaces, such as the **maximum
    transition unit** (**MTU**) and the IP addresses on Juniper devices.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将概述如何管理Juniper设备上的接口。这使我们能够为我们的接口设置不同的参数，如**最大传输单元**（**MTU**）和Juniper设备上的IP地址。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow along with this recipe, an Ansible inventory is assumed to be already
    set up, and NETCONF is enabled on all Juniper devices, as per the previous recipe.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按照这个步骤进行操作，假设已经设置了Ansible清单，并且在所有Juniper设备上启用了NETCONF，就像之前的步骤一样。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Update the `group_vars/all.yml` YAML file to include the following data for
    all the **point-to-point** (**P2P**) and loopback interfaces in our sample network
    topology:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`group_vars/all.yml` YAML文件，包括我们示例网络拓扑中所有**点对点**（**P2P**）和环回接口的以下数据：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Update the `pb_jnpr_basic_config.yml` playbook with the following tasks to
    set up the interfaces on our Juniper devices:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pb_jnpr_basic_config.yml` playbook中更新以下任务，以在我们的Juniper设备上设置接口：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We define all the data for all the interfaces in our sample network topology
    under two main data structures in the `group_vars/all.yml` file. We use the `p2p_ip`
    dictionary to model all the P2P IP addresses in our sample network, and we use
    the `lo_ip` dictionary to specify the loopback IP addresses for our nodes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`group_vars/all.yml`文件中的两个主要数据结构中定义了示例网络拓扑中所有接口的所有数据。我们使用`p2p_ip`字典来模拟示例网络中所有P2P
    IP地址，并使用`lo_ip`字典来指定节点的环回IP地址。
- en: We use the `junos_interface` Ansible module to enable the interfaces and set
    the basic parameters for the interfaces, such as MTU and description. We loop
    over the `p2p_ip` data structure for each device, and we set the correct parameters
    for each interface on all the devices in our network inventory. We use the `junos_l3_interface`
    Ansible module to set the correct IPv4 address on all the interfaces in our sample
    network topology across all the devices.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`junos_interface` Ansible模块来启用接口并为接口设置基本参数，如MTU和描述。我们循环遍历每个设备的`p2p_ip`数据结构，并为网络清单中的所有设备上的每个接口设置正确的参数。我们使用`junos_l3_interface`
    Ansible模块在示例网络拓扑中的所有设备上设置正确的IPv4地址。
- en: 'Once we run the playbook, we can see that the interfaces are configured as
    required, as shown on the `mxpe01` device:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行了playbook，我们可以看到接口已经按照要求配置，就像在`mxpe01`设备上显示的那样：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's more...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In case we need to have more control over the interface configuration, and to
    set parameters that are not covered by the declarative Ansible modules that we
    have outlined in this section, we can use Jinja2 templates to achieve this goal.
    Using the exact same approach that we outlined in the previous recipe for system
    configuration, we can generate the interface configuration needed for our Juniper
    devices.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要对接口配置有更多的控制，并设置声明式Ansible模块中未涵盖的参数，我们可以使用Jinja2模板来实现这个目标。使用与我们在上一步骤中概述的完全相同的方法，我们可以为我们的Juniper设备生成所需的接口配置。
- en: 'Using the same Ansible role that we have created in the previous recipe, we
    can extend it to generate the interface configuration for our Juniper devices.
    We use the following steps in order to accomplish this task:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在上一步骤中创建的相同的Ansible角色，我们可以扩展它以为我们的Juniper设备生成接口配置。我们使用以下步骤来完成这个任务：
- en: 'Create a new Jinja2 template file called `intf.j2` in the `templates` folder,
    with the following data:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates`文件夹中创建一个名为`intf.j2`的新的Jinja2模板文件，包含以下数据：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Update the `build_device_config.yml` file under the `tasks` directory with
    the new task to generate the interface configuration, as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tasks`目录下更新`build_device_config.yml`文件，添加新任务以生成接口配置，如下所示：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is the generated interface configuration for the `mxp02` device after
    running the playbook:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在运行playbook后为`mxp02`设备生成的接口配置：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Configuring OSPF on Juniper devices
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Juniper设备上配置OSPF
- en: In this recipe, we will outline how to configure OSPF on Juniper devices as
    the **interior gateway protocol** (**IGP**) in our sample network topology, along
    with different OSPF parameters such as OSPF link type and OSPF interface cost.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将概述如何在Juniper设备上配置OSPF作为我们示例网络拓扑中的**内部网关协议**（**IGP**），以及不同的OSPF参数，如OSPF链路类型和OSPF接口成本。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create a new Jinja2 file, `ospf.j2`, in the `templates/junos` directory, with
    the following data:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates/junos`目录中创建一个名为`ospf.j2`的新的Jinja2文件，包含以下数据：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `junos_build_config.yml` file inside the `tasks` folder, add the following
    task:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tasks`文件夹中的`junos_build_config.yml`文件中，添加以下任务：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We use the same interface data that was declared in the `p2p_ip` data structure
    in the `all.yml` file, in order to provision the OSPF configuration on the network
    devices in our sample network. We use a new Jinja2 template defined in the `ospf.j2`
    file under the `templates/junos` directory to capture the OSPF configuration parameters
    (OSPF cost, OSPF interface type, and so on) that need to be implemented on the
    Juniper devices.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用在`all.yml`文件中声明的`p2p_ip`数据结构中声明的相同接口数据，以便在我们的示例网络中的网络设备上配置OSPF。我们使用在`templates/junos`目录下定义的新的Jinja2模板来捕获需要在Juniper设备上实现的OSPF配置参数（OSPF成本、OSPF接口类型等）。
- en: Under the `tasks/Juniper_build_config.yml` file, we add a new task that uses
    the `ospf.j2` Jinja2 template to render the Jinja2 template, and output the OSPF
    configuration section for each device outlined in our Ansible inventory.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tasks/Juniper_build_config.yml`文件中，添加一个使用`ospf.j2` Jinja2模板来渲染Jinja2模板，并输出我们Ansible清单中每个设备的OSPF配置部分的新任务。
- en: 'The following snippet outlines the OSPF configuration generated for the `mxpe01`
    device after running the playbook with the new task:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行带有新任务的playbook后，以下片段概述了为`mxpe01`设备生成的OSPF配置：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Configuring MPLS on Juniper devices
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Juniper设备上配置MPLS
- en: In this recipe, we will outline how to configure MPLS and some of the related
    protocols such as the **Label Distribution Protocol** (**LDP**) and the **Resource
    Reservation Protocol** (**RSVP**) on Juniper devices. We will outline how to generate
    the required MPLS configuration using Ansible and Jinja2 templates.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将概述如何在Juniper设备上配置MPLS和一些相关协议，如**标签分发协议**（**LDP**）和**资源预留协议**（**RSVP**）。我们将概述如何使用Ansible和Jinja2模板生成所需的MPLS配置。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new Jinja2 file, `mpls.j2`, under the `templates/junos` directory
    with the following data:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates/junos`目录下创建一个名为`mpls.j2`的新的Jinja2文件，包含以下数据：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `build_device_config.yml` file inside the `tasks` folder, add the following
    task:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tasks`文件夹中的`build_device_config.yml`文件中，添加以下任务：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We use the same methodology as used to configure the interfaces and OSPF, by
    using a Jinja2 template to generate the needed MPLS configuration for the Juniper
    devices in our inventory, and the following is a sample of the MPLS configuration
    for the `mxpe02` router:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与配置接口和OSPF相同的方法，通过使用Jinja2模板为我们库存中的Juniper设备生成所需的MPLS配置，以下是`mxpe02`路由器的MPLS配置示例：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Configuring BGP on Juniper devices
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Juniper设备上配置BGP
- en: In this recipe, we will outline how to configure BGP on Juniper devices. We
    will outline how to set up BGP and BGP **Route Reflectors** (**RR**) as part of
    our sample topology, along with all the required BGP address families to support
    **virtual private network** (**VPN**) services.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将概述如何在Juniper设备上配置BGP。我们将概述如何设置BGP和BGP**路由反射器**（**RR**）作为我们示例拓扑的一部分，以及支持**虚拟专用网络**（**VPN**）服务所需的所有BGP地址族。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Update the `group_vars/all.yml` file with the following BGP information:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`group_vars/all.yml`文件，包含以下BGP信息：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For each node within our Ansible inventory, we create a file called `bgp.yml`
    under the `host_vars` directory. This file holds the BGP information and BGP peers
    for each node. This is the example for the `mxpe01` device:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Ansible库存中的每个节点，我们在`host_vars`目录下创建一个名为`bgp.yml`的文件。该文件保存每个节点的BGP信息和BGP对等方。这是`mxpe01`设备的示例：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a new Jinja2 file, `bgp.j2`, under the `templates/junos` directory,
    with the following data:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates/junos`目录下创建一个名为`bgp.j2`的新的Jinja2文件，包含以下数据：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the `build_device_config.yml` file inside the `tasks` folder, add the following
    highlighted task:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tasks`文件夹中的`build_device_config.yml`文件中，添加以下突出显示的任务：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using a similar approach to all the previous recipes, we use a Jinja2 template
    to generate the BGP configuration for the Juniper devices. However, in this section,
    we declare the BGP parameters in two different places, which are the `group_vars`
    and `host_vars` directories. In the `group_vars/all.yml` file, we declare the
    overall parameters for our BGP topology, such as the RR that we will use, and
    which address families we will configure. For each node in our inventory, we create
    a directory in the `host_vars` directory, and inside this directory, we create
    a `bgp.yml` file. This new YAML file holds the BGP peers for each node in our
    inventory. We use the data defined in these two locations to render the BGP configuration
    for each device.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的方法类似，我们使用Jinja2模板为Juniper设备生成BGP配置。然而，在本节中，我们在两个不同的位置声明BGP参数，即`group_vars`和`host_vars`目录。在`group_vars/all.yml`文件中，我们声明了BGP拓扑的整体参数，例如我们将使用的RR以及我们将配置哪些地址族。对于库存中的每个节点，我们在`host_vars`目录中创建一个目录，并在该目录中创建一个`bgp.yml`文件。这个新的YAML文件保存了我们库存中每个节点的BGP对等方。我们使用这两个位置定义的数据来为每个设备渲染BGP配置。
- en: 'This is a sample of the BGP configuration for the `mxp01` router, which is
    the RR in our topology:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`mxp01`路由器的BGP配置示例，它是我们拓扑中的RR：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Deploying configuration on Juniper devices
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Juniper设备上部署配置
- en: In this recipe, we will outline how to push the configuration that we have generated
    via Jinja2 templates in all the previous sections on Juniper devices using Ansible.
    This provides us with the capability to push any custom configuration that we
    create to our Juniper devices.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将概述如何使用Ansible在Juniper设备上推送我们通过Jinja2模板在所有先前部分生成的配置。这使我们能够将我们创建的任何自定义配置推送到Juniper设备。
- en: Getting ready
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires NETCONF to be enabled on the Juniper devices.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法要求Juniper设备上启用NETCONF。
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the `pb_junos_push_con` file, add the following task:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pb_junos_push_con`文件中，添加以下任务：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the previous recipe, we generated different sections of the configuration
    for Juniper devices such as interfaces, OSPF, MPLS, and BGP. We have used the
    `assemble` module in order to group all these sections per each node in a single
    configuration file. This file is stored in the `configs` folder for each device.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的方法中，我们使用`assemble`模块来将Juniper设备的不同部分的配置（如接口、OSPF、MPLS和BGP）分组到单个配置文件中。该文件存储在每个设备的`configs`文件夹中。
- en: 'We use the `junos_config` module in order to push this configuration file that
    we have generated to each device in our network inventory. We can use the `update`
    parameter in order to control how the configuration that we want to push will
    be merged with the existing configuration on the device. It supports the following
    options:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`junos_config`模块来将我们生成的配置文件推送到网络库存中的每个设备。我们可以使用`update`参数来控制我们要推送的配置如何与设备上的现有配置合并。它支持以下选项：
- en: '`merge`: This causes the configuration from our file to be merged with the
    configuration on the device (the candidate configuration). This option is the
    default option that is used.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`合并`：这会导致我们文件中的配置与设备上的配置（候选配置）合并。这是默认选项。'
- en: '`Override/update`: This causes the configuration from our file to override
    the complete configuration on the managed device.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`覆盖/更新`：这会导致我们文件中的配置覆盖受管设备上的完整配置。'
- en: 'We can use the `check` mode to run our playbook in dry-run mode. In this case,
    we will push the configuration to the devices without committing to the configuration.
    This enables us to check the changes that will be pushed to the devices. This
    can be accomplished as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`check`模式以干运行模式运行我们的playbook。在这种情况下，我们将推送配置到设备，而不提交配置。这使我们能够检查将推送到设备的更改。可以按以下方式完成：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We use the `–check` option to run the playbook in check mode (dry-run), and
    the `–diff` option in order to output the changes that will be pushed to our devices.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`-check`选项以检查模式（干运行）运行playbook，并使用`-diff`选项以输出将推送到我们设备的更改。
- en: There's more...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `junos_config` module also supports the rollback feature supported by Junos
    OS, therefore we can add another task to roll back the configuration and control
    how it is run, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`junos_config`模块还支持Junos OS支持的回滚功能，因此我们可以添加另一个任务来回滚配置并控制其运行，如下所示：'
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the preceding playbook, we roll back to the last version of the configuration.
    However, by changing the number in the `rollback` attribute, we can control the
    version of the configuration to which we want to roll back. Also, we are using
    the tags in order to only execute this task when we specify the `rollback` tag
    during the playbook run, as shown in the following code snippet:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的playbook中，我们回滚到配置的上一个版本。但是，通过更改`rollback`属性中的数字，我们可以控制要回滚到的配置版本。此外，我们使用标签来仅在playbook运行期间指定`rollback`标签时执行此任务，如下面的代码片段所示：
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can specify another rollback point, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定另一个回滚点，如下所示：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: See also...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: For more information regarding the `junos_config` module and the different parameters
    supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/junos_config_module.html](https://docs.ansible.com/ansible/latest/modules/junos_config_module.html)[.](https://docs.ansible.com/ansible/latest/modules/junos_config_module.html)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`junos_config`模块和此模块支持的不同参数的更多信息，请参阅以下网址：[https://docs.ansible.com/ansible/latest/modules/junos_config_module.html](https://docs.ansible.com/ansible/latest/modules/junos_config_module.html)[.](https://docs.ansible.com/ansible/latest/modules/junos_config_module.html)
- en: Configuring the L3VPN service on Juniper devices
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Juniper设备上配置L3VPN服务
- en: In this recipe, we will outline how to model and configure L3VPNs on Juniper
    devices using various Ansible modules. This enables us to model our services using
    **Infrastructure as Code** (**IaC**) practices, and utilize Ansible to deploy
    and push the required configuration to have the L3VPN deployed on Juniper devices.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将概述如何使用各种Ansible模块在Juniper设备上建模和配置L3VPN。这使我们能够使用**基础设施即代码**（**IaC**）实践来建模我们的服务，并利用Ansible来部署和推送所需的配置，以在Juniper设备上部署L3VPN。
- en: Getting ready
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: NETCONF must be enabled on the Juniper devices so as to use the Ansible modules
    in this recipe.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Juniper设备上必须启用NETCONF才能在本教程中使用Ansible模块。
- en: How to do it...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new file called `l3vpn.yml` with the following content:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`l3vpn.yml`的新文件，内容如下：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a new playbook called `pb_junos_l3vpn.yml` with the following tasks
    to configure the PE-**Customer Edge** (**CE**) links:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pb_junos_l3vpn.yml`的新playbook，其中包含以下任务，以配置PE-**客户边缘**（**CE**）链路：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add the following tasks in `pb_junos_l3vpn.yml` to set up the P2P IP address
    on the PE-CE links:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pb_junos_l3vpn.yml`中添加以下任务以设置PE-CE链路上的P2P IP地址：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add the following task in `pb_junos_l3vpn.yml` to configure the **virtual routings
    and forwardings** (**VRFs**) on the PE nodes:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pb_junos_l3vpn.yml`中添加以下任务以在PE节点上配置**虚拟路由和转发**（**VRFs**）：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We create a new YAML file called `l3vpn.yml` that describes and models the L3VPN
    topology and data that we want to implement on all the Juniper devices on our
    topology. We include this file in the new playbook that we create in order to
    provision the L3VPNs on our network devices.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个名为`l3vpn.yml`的新的YAML文件，描述和建模我们想要在拓扑上的所有Juniper设备上实现的L3VPN拓扑和数据。我们在新的playbook中包含这个文件，以便在我们的网络设备上配置L3VPN。
- en: In the `pb_junos_l3vpn.yml` playbook, we use the data from the `l3vpn.yml` file
    to capture the data required to provision the L3VPN.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pb_junos_l3vpn.yml` playbook中，我们使用`l3vpn.yml`文件中的数据来捕获所需的数据以配置L3VPN。
- en: 'In the first task within our playbook, we create a new variable called `l3vpn_intfs` that
    captures all the L3VPN interfaces on each PE device, across all the VPNs that
    we have defined in our `l3vpn.yml` file. We loop over all the L3VPNs in this file,
    and we create a new list data structure for all the interfaces that belong to
    a specific node. The following snippet outlines the new data structure `l3vpn_intfs`
    for `mxpe01`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的playbook中的第一个任务中，我们创建一个名为`l3vpn_intfs`的新变量，该变量捕获我们在`l3vpn.yml`文件中定义的所有VPN的每个PE设备上的所有L3VPN接口。我们在此文件中循环遍历所有L3VPN，并为属于特定节点的所有接口创建一个新的列表数据结构。以下代码片段概述了`mxpe01`的`l3vpn_intfs`的新数据结构：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, in our playbook, we divide the provisioning of our L3VPN service to multiple
    tasks:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的playbook中，我们将我们的L3VPN服务的配置分为多个任务：
- en: We use the `junos_config` module to configure all the interfaces that are part
    of the L3VPNs to be ready to configure **virtual LANs** (**VLANs**) on these interfaces.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`junos_config`模块配置所有属于L3VPN的接口，以便在这些接口上配置**虚拟局域网**（**VLANs**）。
- en: We use the `junos_l3_interface` module to apply the IPv4 addresses on all these
    interfaces that are part of our L3VPN model.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`junos_l3_interface`模块在所有属于我们的L3VPN模型的接口上应用IPv4地址。
- en: We use the `junos_vrf` module to configure the correct routing instances on
    the nodes, as per our L3VPN data model.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`junos_vrf`模块根据我们的L3VPN数据模型在节点上配置正确的路由实例。
- en: 'The following outlines the L3VPN configuration that is applied on `mxpe01`
    after running this playbook:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此playbook后，以下概述了应用在`mxpe01`上的L3VPN配置：
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: See also...
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: For more information regarding the `junos_vrf` module and the different parameters
    supported by this module to provision L3VPNs on Juniper devices, please consult
    the following URL: [https://docs.ansible.com/ansible/latest/modules/junos_vrf_module.html#junos-vrf-module](https://docs.ansible.com/ansible/latest/modules/junos_vrf_module.html#junos-vrf-module)[. ](https://docs.ansible.com/ansible/latest/modules/junos_vrf_module.html#junos-vrf-module)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`junos_vrf`模块和该模块支持的不同参数以在Juniper设备上配置L3VPN的更多信息，请参考以下网址：[https://docs.ansible.com/ansible/latest/modules/junos_vrf_module.html#junos-vrf-module](https://docs.ansible.com/ansible/latest/modules/junos_vrf_module.html#junos-vrf-module)[. ](https://docs.ansible.com/ansible/latest/modules/junos_vrf_module.html#junos-vrf-module)
- en: Gathering Juniper device facts using Ansible
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible收集Juniper设备信息
- en: In this recipe, we will retrieve the basis system facts collected by Ansible
    for a Juniper device. These basic system facts provide us with a basic health
    check regarding our Juniper devices, which we can use to validate its operational
    state.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将检索Ansible为Juniper设备收集的基本系统信息。这些基本系统信息为我们提供了有关Juniper设备的基本健康检查，我们可以用来验证其操作状态。
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: NETCONF must be enabled on the Juniper devices so as to use the Ansible modules
    in this recipe.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Juniper设备上必须启用NETCONF才能在此配方中使用Ansible模块。
- en: How to do it...
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new playbook, `pb_jnpr_facts.yml`, with the following task to collect
    the facts:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的playbook，`pb_jnpr_facts.yml`，使用以下任务来收集信息：
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Update the `pb_jnpr_facts.yml` playbook with the following tasks to create
    a facts report for each node in our inventory:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下任务更新`pb_jnpr_facts.yml` playbook，为清单中的每个节点创建一个信息报告：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Update the playbook with the following task to validate the operational state
    for the core interfaces:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下任务更新playbook以验证核心接口的操作状态：
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Ansible provides a fact-gathering module to collect the basic system properties
    for Juniper devices and returns these facts in a consistent and structured data
    structure. We can use the facts collected by this module in order to validate
    the basic properties and operational state of our devices, and we can use this
    data to build simple reports that capture the state of our devices.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible提供了一个信息收集模块，用于收集Juniper设备的基本系统属性，并以一致和结构化的数据结构返回这些信息。我们可以使用该模块收集的信息来验证设备的基本属性和操作状态，并可以使用这些数据生成捕获设备状态的简单报告。
- en: 'In this recipe, we use the `junos_facts` module to collect the device facts
    for all our Juniper devices. This module returns the basic facts collected by
    Ansible for each device in multiple variables, as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用`junos_facts`模块来收集所有Juniper设备的设备信息。该模块返回Ansible为每个设备收集的基本信息，并存储在多个变量中，如下所示：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We use this data in order to build a fact report for each device using the `blockinfile`
    module, and we use this data to validate the operational state of the core interfaces
    of each device using the `assert` module.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这些数据来使用`blockinfile`模块为每个设备构建信息报告，并使用这些数据来验证每个设备的核心接口的操作状态。
- en: 'Once we run our playbook, we can see that a facts report for each device is
    generated, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行了playbook，我们就可以看到为每个设备生成了一个信息报告，如下所示：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the final task, we use the `assert` module in order to validate that all
    the core interfaces on all the Juniper devices are operational. Ansible stores
    all the interfaces' operational status for the device under `Ansible_net_interfaces`.
    We use the data in this data structure to validate that the operational state
    is up. In the case that all the core interfaces are operational, the task will
    succeed—otherwise, the task will fail.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个任务中，我们使用`assert`模块来验证所有Juniper设备上的所有核心接口是否都处于操作状态。Ansible将设备的所有接口的操作状态存储在`Ansible_net_interfaces`下。我们使用这个数据结构中的数据来验证操作状态是否正常。如果所有核心接口都处于操作状态，任务将成功，否则任务将失败。
- en: See also...
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: For more information regarding the `junos_facts` module and the different parameters
    supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/junos_facts_module.html](https://docs.ansible.com/ansible/latest/modules/junos_facts_module.html)[.](https://docs.ansible.com/ansible/latest/modules/junos_facts_module.html)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`junos_facts`模块和该模块支持的不同参数的更多信息，请参考以下网址：[https://docs.ansible.com/ansible/latest/modules/junos_facts_module.html](https://docs.ansible.com/ansible/latest/modules/junos_facts_module.html)[.](https://docs.ansible.com/ansible/latest/modules/junos_facts_module.html)
- en: Validating network reachability on Juniper devices
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证Juniper设备的网络可达性
- en: In this recipe, we will outline how to validate network reachability via `ping`,
    using Ansible on Juniper devices. This will enable us to validate network reachability
    and traffic forwarding across our sample network topology.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将概述如何使用Ansible在Juniper设备上验证通过`ping`进行网络可达性。这将使我们能够验证样本网络拓扑中的网络可达性和流量转发。
- en: Getting ready
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that the network is already built and configured, as outlined
    in all the previous recipes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方假设网络已经建立和配置，就像在所有先前的配方中所概述的那样。
- en: How to do it...
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new playbook called `pb_junos_ping.yml` with the following task, to
    ping all core loopbacks within our sample network:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pb_junos_ping.yml`的新playbook，使用以下任务来ping样本网络中的所有核心loopback：
- en: '[PRE57]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Update the `pb_junos_ping.yml` playbook with the following task to create a
    custom report to capture the ping results:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下任务更新`pb_junos_ping.yml` playbook，创建一个自定义报告来捕获ping的结果：
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works...
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We use the `junos_ping` module in order to ping from all the nodes in our network
    inventory to all the loopback interfaces defined in the `lo_ip` data structure,
    which is defined in the `group_vars/all.yml` file. This module connects to each
    device and executes ping to all the destinations, and validates that ping packets
    are reaching their intended destination. This module requires the use of the `network_cli`
    connection plugin, therefore we supply this parameter as a task variable in order
    to override the group-level NETCONF connection plugin defined at the group level.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`junos_ping`模块从网络清单中的所有节点向`group_vars/all.yml`文件中定义的`lo_ip`数据结构中定义的所有环回接口执行ping。此模块连接到每个设备并对所有目的地执行ping，并验证ping数据包是否到达其预期目的地。此模块需要使用`network_cli`连接插件，因此我们将此参数作为任务变量提供，以覆盖组级别在组级别定义的NETCONF连接插件。
- en: We register the output of the module in order to use this data to generate the
    ping report. Finally, we set `ignore_errors` to `yes` in order to ignore any failed
    ping task that we might encounter, and ensure that we will run the subsequent
    tasks to create the report.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注册模块的输出，以便使用这些数据生成ping报告。最后，我们将`ignore_errors`设置为`yes`，以忽略可能遇到的任何ping任务失败，并确保我们将运行后续任务以创建报告。
- en: 'We use the `blockinfile` module in order to create a custom report in Markdown.
    We use a table layout in order to capture the ping results and display a table
    that captures these ping results. The following snippet captures the table generated
    for the `mxpe01` ping test report:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`blockinfile`模块创建Markdown中的自定义报告。我们使用表格布局来捕获ping结果并显示捕获这些ping结果的表格。以下片段捕获了为`mxpe01`
    ping测试报告生成的表格：
- en: '[PRE59]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here is the rendered Markdown table for the ping result:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是ping结果的渲染Markdown表格：
- en: '![](assets/8dd7c8e4-61f2-4c27-bf5d-7a5ffd391dd3.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8dd7c8e4-61f2-4c27-bf5d-7a5ffd391dd3.png)'
- en: See also...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: For more information regarding the `junos_ping` module and the different parameters
    supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/junos_ping_module.html](https://docs.ansible.com/ansible/latest/modules/junos_ping_module.html)[.](https://docs.ansible.com/ansible/latest/modules/junos_ping_module.html)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`junos_ping`模块和此模块支持的不同参数的更多信息，请参阅以下网址：[https://docs.ansible.com/ansible/latest/modules/junos_ping_module.html](https://docs.ansible.com/ansible/latest/modules/junos_ping_module.html)[.](https://docs.ansible.com/ansible/latest/modules/junos_ping_module.html)
- en: Retrieving operational data from Juniper devices
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Juniper设备检索操作数据
- en: In this recipe, we will outline how to execute operational commands on Juniper
    devices and store these outputs in text files for further processing.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤中，我们将概述如何在Juniper设备上执行操作命令并将这些输出存储为文本文件以进行进一步处理。
- en: Getting ready
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: NETCONF must be enabled on the Juniper devices in order to follow along with
    this recipe.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: NETCONF必须在Juniper设备上启用，以便按照此步骤进行操作。
- en: How to do it...
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Install the `jxmlease` Python package, as follows:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`jxmlease` Python包，如下所示：
- en: '[PRE60]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Create a new playbook called `pb_get_ospf_peers.yml` and populate it with the
    following task to extract OSPF peering information:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pb_get_ospf_peers.yml`的新剧本，并填充以下任务以提取OSPF对等信息：
- en: '[PRE61]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Update the `pb_get_ospf_peers.yml` playbook with the following task to validate
    that all OSPF peerings across all nodes are in a `Full` state:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`pb_get_ospf_peers.yml`剧本，使用以下任务验证所有节点上的所有OSPF对等关系是否处于`Full`状态：
- en: '[PRE62]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works...
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: One of the advantages of using the NETCONF API to interact with Juniper devices
    is that we can get a structured output for all the operational commands that we
    execute on the Juniper devices. The output that the device returns to us over
    the NETCONF session is in XML, and Ansible uses a Python library called `jxmlease`
    to decode this XML and transform it to JSON for better representation. That is
    why our first task was to install the `jxmlease` Python package.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NETCONF API与Juniper设备交互的一个优势是，我们可以获取我们在Juniper设备上执行的所有操作命令的结构化输出。设备通过NETCONF会话返回给我们的输出是XML格式的，Ansible使用名为`jxmlease`的Python库来解码此XML并将其转换为JSON以进行更好的表示。这就是为什么我们的第一个任务是安装`jxmlease`
    Python包。
- en: 'We use the `junos_command` module to send operational commands to a Juniper
    device, and we specify that we need XML as the output format that gets returned
    from the node. This XML data structure is transformed to JSON using the `jxmlease`
    package by Ansible. We save this data using the `register` keyword to a new variable
    called `ospf_output.` Here is a sample of the JSON data that is returned from
    this command:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`junos_command`模块向Juniper设备发送操作命令，并指定我们需要XML作为从节点返回的输出格式。Ansible使用`jxmlease`包将此XML数据结构转换为JSON。我们使用`register`关键字将此数据保存到名为`ospf_output`的新变量中。以下是从此命令返回的JSON数据的示例：
- en: '[PRE63]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: All this data structure is contained in the `ospf_output.output[0]` variable,
    and we use the `set_fact` module to capture the `ospf-neigbour` data. After that,
    we use the `assert` module to loop through all the OSPF peers in this data structure
    and validate that the OSPF neighbor state is equal to `Full`. If all the OSPF
    peers are in a `Full` state, the task will succeed. However, if the OSPF state
    is in any other state, the task will fail.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数据结构都包含在`ospf_output.output[0]`变量中，我们使用`set_fact`模块来捕获`ospf-neigbour`数据。之后，我们使用`assert`模块循环遍历此数据结构中的所有OSPF对等关系，并验证OSPF邻居状态是否等于`Full`。如果所有OSPF对等关系都处于`Full`状态，则任务将成功。但是，如果OSPF状态处于任何其他状态，则任务将失败。
- en: There's more...
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we need to get the operational data from Juniper devices in text format
    for log collection, we can use the `junos_command` module without the `xml` display
    option, as shown in this new playbook:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要以文本格式从Juniper设备获取操作数据以进行日志收集，我们可以使用`junos_command`模块，而不使用`xml`显示选项，如下所示在此新剧本中：
- en: '[PRE64]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This playbook will collect the `show ospf neigbor` command from all the devices,
    and store them in a new folder called `logs`. Here is the content of the `logs`
    folder after running the playbook:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这个playbook将从所有设备收集`show ospf neigbor`命令，并将它们存储在一个名为`logs`的新文件夹中。运行playbook后，这是`logs`文件夹的内容：
- en: '[PRE65]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can check the content of one of the files to confirm that the required output
    is captured:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查其中一个文件的内容，以确认已捕获所需的输出：
- en: '[PRE66]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Validating the network state using PyEZ operational tables
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PyEZ操作表验证网络状态
- en: In this recipe, we will outline how to use Juniper custom Ansible modules to
    validate the network state. We are going to use the Juniper PyEZ Python library
    and PyEZ operational tables and views to validate the operational state for Junos
    OS devices.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将概述如何使用Juniper自定义Ansible模块来验证网络状态。我们将使用Juniper PyEZ Python库和PyEZ操作表和视图来验证Junos
    OS设备的操作状态。
- en: Getting ready
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: NETCONF must be enabled on the Juniper devices in order to follow along with
    this recipe.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循本配方时，Juniper设备上必须启用NETCONF。
- en: How to do it...
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Install the `junos-eznc` Python package, as follows:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`junos-eznc` Python包，如下所示：
- en: '[PRE67]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Install the `Juniper.junos` Ansible role using `Ansible-galaxy`, as follows:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Ansible-galaxy`安装`Juniper.junos` Ansible角色，如下所示：
- en: '[PRE68]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Create a new playbook called `pb_jnpr_pyez_table.yml`, and populate it with
    the following task to extract BGP peering information using PyEZ tables:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pb_jnpr_pyez_table.yml`的新playbook，并填充以下任务以使用PyEZ表提取BGP对等信息：
- en: '[PRE69]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Update the playbook with the following task to validate that all BGP peering
    across all nodes is operational:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下任务更新playbook以验证所有节点上的所有BGP对等体是否正常运行：
- en: '[PRE70]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How it works...
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In addition to the built-in Juniper modules that come pre-installed with Ansible
    that we have outlined in all our previous recipes, there are additional Ansible
    modules that are maintained by Juniper and are not part of the Ansible release.
    These modules are packaged in an Ansible role that is maintained in Ansible Galaxy,
    and all these modules are based on the Juniper PyEZ Python library that is also
    developed and maintained by Juniper.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在所有先前的配方中概述的预安装在Ansible中的内置Juniper模块之外，Juniper还维护并不是Ansible发布的一部分的其他Ansible模块。这些模块打包在Ansible
    Galaxy中维护的Ansible角色中，所有这些模块都基于Juniper PyEZ Python库，该库也由Juniper开发和维护。
- en: The Juniper PyEZ Python library provides a simple and robust API in order to
    interact with Juniper devices and simplifies how to manage Juniper devices using
    Python. The Ansible modules maintained by Juniper are all dependent on the PyEZ
    Python library, and therefore the first task we need to perform is to ensure that
    PyEZ (`junos-eznc`) is installed on our Ansible control machine.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Juniper PyEZ Python库提供了一个简单而强大的API，以便与Juniper设备进行交互，并简化了使用Python管理Juniper设备的方法。由Juniper维护的Ansible模块都依赖于PyEZ
    Python库，因此我们需要执行的第一个任务是确保PyEZ（`junos-eznc`）已安装在我们的Ansible控制机上。
- en: 'The Ansible modules maintained and developed by Juniper are packaged as an
    Ansible role, and they provide multiple modules with extra capabilities compared
    to the built-in Juniper modules that come as part of the Ansible release. We install
    this role using Ansible Galaxy in order to start to utilize these extra modules.
    The following snippet outlines the extra modules that are part of this role:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 由Juniper维护和开发的Ansible模块打包为Ansible角色，并且它们提供了多个具有额外功能的模块，与作为Ansible发布的一部分的内置Juniper模块相比。我们使用Ansible
    Galaxy安装此角色，以开始利用这些额外的模块。以下片段概述了此角色的额外模块：
- en: '[PRE71]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In this recipe, we outline how to use the `Juniper_junos_table` Ansible module,
    which uses the PyEZ tables and views to execute operational commands on Juniper
    devices and extract specific information from the Juniper device. It also parses
    this information into a consistent data structure, which we can utilize in our
    automation scripts. In our playbook, our first task is to use the `Juniper_junos_table`
    module using the `bgp.yml` table definition (which is present as part of the `junos-eznc`
    installation). We do this to get the BGP peers on a device and return the relevant
    information in a consistent data structure. The following snippet outlines the
    BGP data returned by the `Juniper_junos_table` for the BGP information on `mxpe01`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们概述了如何使用`Juniper_junos_table` Ansible模块，该模块使用PyEZ表和视图来执行Juniper设备上的操作命令，并从Juniper设备中提取特定信息。它还将这些信息解析为一致的数据结构，我们可以在自动化脚本中利用。在我们的playbook中，我们的第一个任务是使用`Juniper_junos_table`模块，使用`bgp.yml`表定义（作为`junos-eznc`安装的一部分）来获取设备上的BGP对等体，并以一致的数据结构返回相关信息。以下片段概述了`Juniper_junos_table`返回的BGP数据，用于`mxpe01`上的BGP信息：
- en: '[PRE72]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The last task in our playbook is using the `assert` module in order to validate
    that all our BGP peers (defined under the `host_vars)` directory) are present
    in the returned data structure in the BGP table, which indicates that all the
    BGP peers are operational.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们playbook中的最后一个任务是使用`assert`模块来验证我们所有的BGP对等体（在`host_vars`目录下定义）是否存在于BGP表中返回的数据结构中，这表明所有的BGP对等体都是正常运行的。
- en: See also...
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: For more information regarding the Juniper Ansible modules maintained by Juniper,
    please consult the following URL: [https://www.juniper.net/documentation/en_US/junos-ansible/topics/reference/general/junos-ansible-modules-overview.html](https://www.juniper.net/documentation/en_US/junos-ansible/topics/reference/general/junos-ansible-modules-overview.html)[.](https://www.juniper.net/documentation/en_US/junos-ansible/topics/reference/general/junos-ansible-modules-overview.html)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 有关由Juniper维护的Juniper Ansible模块的更多信息，请参阅以下网址：[https://www.juniper.net/documentation/en_US/junos-ansible/topics/reference/general/junos-ansible-modules-overview.html](https://www.juniper.net/documentation/en_US/junos-ansible/topics/reference/general/junos-ansible-modules-overview.html)[.](https://www.juniper.net/documentation/en_US/junos-ansible/topics/reference/general/junos-ansible-modules-overview.html)
- en: For more information regarding PyEZ tables and views, please consult the following
    URL: [https://www.Juniper.net/documentation/en_US/junos-pyez/topics/concept/junos-pyez-tables-and-views-overview.html](https://www.Juniper.net/documentation/en_US/junos-pyez/topics/concept/junos-pyez-tables-and-views-overview.html).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PyEZ表和视图的更多信息，请参考以下网址：[https://www.Juniper.net/documentation/en_US/junos-pyez/topics/concept/junos-pyez-tables-and-views-overview.html](https://www.Juniper.net/documentation/en_US/junos-pyez/topics/concept/junos-pyez-tables-and-views-overview.html)。
