- en: 8\. Introduction to Apache OpenWhisk
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8\. Apache OpenWhisk简介
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Run OpenWhisk with IBM Cloud Functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在IBM Cloud Functions中运行OpenWhisk
- en: Create, list, invoke, update, and delete OpenWhisk actions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、列出、调用、更新和删除OpenWhisk操作
- en: Utilize and invoke OpenWhisk web actions and sequences
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用和调用OpenWhisk web操作和序列
- en: Automate OpenWhisk action invocation with feeds, triggers, and rules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用feeds、触发器和规则自动化OpenWhisk操作调用
- en: This chapter covers Apache OpenWhisk and how to work with its actions, triggers,
    and packages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了Apache OpenWhisk以及如何处理其操作、触发器和包。
- en: Introduction to OpenWhisk
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenWhisk简介
- en: Until now in this book, we have learned about the **Kubeless** framework, which
    is an open source Kubernetes-native serverless framework. We discussed the **Kubeless**
    architecture, and created and worked with the **Kubeless** functions and triggers.
    In this chapter, we shall be learning about **OpenWhisk**, which is another open
    source serverless framework that can be deployed on top of Kubernetes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经了解了**Kubeless**框架，这是一个开源的基于Kubernetes的无服务器框架。我们讨论了**Kubeless**架构，并创建并使用了**Kubeless**函数和触发器。在本章中，我们将学习**OpenWhisk**，这是另一个可以部署在Kubernetes之上的开源无服务器框架。
- en: '**OpenWhisk** is an open source serverless framework that is part of the Apache
    Software Foundation. This was originally developed at IBM with the project code
    name of Whisk, and later branded as **OpenWhisk** once the source code was open
    sourced. **Apache OpenWhisk** supports many programming languages, including Ballerina,
    Go, Java, JavaScript, PHP, Python, Ruby, Swift, and .NET Core. It allows us to
    invoke functions written in these programming languages in response to events.
    OpenWhisk supports many deployment options, such as on-premises and cloud infrastructure.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenWhisk**是Apache软件基金会的一部分的开源无服务器框架。最初在IBM开发，项目代号为Whisk，后来在源代码开源后更名为**OpenWhisk**。**Apache
    OpenWhisk**支持许多编程语言，包括Ballerina、Go、Java、JavaScript、PHP、Python、Ruby、Swift和.NET
    Core。它允许我们调用用这些编程语言编写的函数来响应事件。OpenWhisk支持许多部署选项，例如本地部署和云基础设施。'
- en: 'There are four core components of OpenWhisk:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWhisk有四个核心组件：
- en: '**Actions**: These contain application logic written in one of the supported
    languages that will be executed in response to events.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Actions**：这些包含用支持的语言编写的应用程序逻辑，将在响应事件时执行。'
- en: '**Sequences**: These link multiple actions together to create more complex
    processing pipelines.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列**：这些将多个操作链接在一起，以创建更复杂的处理流水线。'
- en: '**Triggers and rules**: These automate the invocation of actions by binding
    them to external event sources.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发器和规则**：这些通过将它们绑定到外部事件源来自动调用操作。'
- en: '**Packages**: These combine related actions together for distribution.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Packages**：这些将相关的操作组合在一起进行分发。'
- en: 'The following diagram illustrates how these components interact with each other:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了这些组件如何相互交互：
- en: '![Figure 8.1: OpenWhisk core components'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1：OpenWhisk核心组件'
- en: '](image/C12607_08_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_01.jpg)'
- en: 'Figure 8.1: OpenWhisk core components'
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.1：OpenWhisk核心组件
- en: In the next section, we will learn how to run Apache OpenWhisk with IBM Cloud
    Functions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在IBM Cloud Functions中运行Apache OpenWhisk。
- en: Running OpenWhisk with IBM Cloud Functions
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在IBM Cloud Functions中运行OpenWhisk
- en: OpenWhisk is a framework that can be deployed on-premises or in a cloud infrastructure.
    However, OpenWhisk is also available as a managed service from IBM, the creator
    of the OpenWhisk project. **IBM Cloud Functions** is the name for the managed
    OpenWhisk implementation on the IBM Cloud infrastructure. This book will use this
    service to deploy our serverless functions because IBM Cloud Functions is the
    easiest way to start working with OpenWhisk. We will first begin by setting up
    an IBM Cloud account.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWhisk是一个可以部署在本地或云基础设施上的框架。然而，OpenWhisk也可以作为IBM的托管服务提供，IBM是OpenWhisk项目的创建者。**IBM
    Cloud Functions**是IBM Cloud基础设施上托管OpenWhisk实现的名称。本书将使用此服务来部署我们的无服务器函数，因为IBM Cloud
    Functions是开始使用OpenWhisk的最简单方式。我们首先要设置一个IBM Cloud账户。
- en: 'Exercise 24: Setting Up an IBM Cloud Account'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习24：设置IBM Cloud账户
- en: In this exercise, we are going to set up an account on IBM Cloud.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在IBM Cloud上设置一个账户。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A credit card is not required to register with IBM Cloud.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注册IBM Cloud不需要信用卡。
- en: 'The following steps will help you complete the exercise:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成练习：
- en: First, we need to register on IBM Cloud at [https://cloud.ibm.com/registration](https://cloud.ibm.com/registration).
    Then, fill in the required data and submit the form. It should look similar to
    the following screenshot:![](image/C12607_08_02.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在IBM Cloud上注册[https://cloud.ibm.com/registration](https://cloud.ibm.com/registration)。然后，填写必需的数据并提交表单。它应该类似于以下截图：![](image/C12607_08_02.jpg)
- en: 'Figure 8.2: IBM Cloud registration page'
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.2：IBM Cloud注册页面
- en: 'Once the registration is complete, you should see the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注册完成后，您应该会看到以下内容：
- en: '![](image/C12607_08_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](image/C12607_08_03.jpg)'
- en: 'Figure 8.3: IBM Cloud registration completion page'
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.3：IBM Cloud注册完成页面
- en: At this point, we will receive an email with an activation link. Click on the
    **Confirm account** button to activate your account, as shown in the following
    figure:![](image/C12607_08_04.jpg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，我们将收到一封带有激活链接的电子邮件。点击**确认账户**按钮来激活您的账户，如下图所示：![](image/C12607_08_04.jpg)
- en: 'Figure 8.4: IBM Cloud Activation Email'
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.4：IBM Cloud激活邮件
- en: When you click on the **Confirm account** button in the email, we will be taken
    to the IBM Cloud welcome screen. Click on the **Log in** button to log in with
    the credentials used to register with **IBM Cloud**, as shown in the following
    figure:![](image/C12607_08_05..jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您点击邮件中的**确认账户**按钮时，我们将被带到IBM Cloud欢迎页面。点击**登录**按钮，使用注册IBM Cloud时使用的凭据登录，如下图所示：![](image/C12607_08_05..jpg)
- en: 'Figure 8.5: IBM Cloud welcome page'
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.5：IBM Cloud欢迎页面
- en: 'Acknowledge the privacy data by clicking on the **Proceed** button, as shown
    in the following figure:![Figure 8.6: IBM Cloud privacy policy'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**继续**按钮来确认隐私数据，如下图所示：![图8.6：IBM Cloud隐私政策
- en: '](image/C12607_08_06..jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_06..jpg)'
- en: 'Figure 8.6: IBM Cloud privacy policy'
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.6：IBM Cloud隐私政策
- en: You can skip the introduction video and proceed to the home page. Now you can
    click the **hamburger** icon (![](image/C12607_08_icon.png)) in the top-left corner
    of the screen and select **Functions** from the menu, as shown in the following
    figure:![](image/C12607_08_07.jpg)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以跳过介绍视频，然后转到首页。现在，您可以点击屏幕左上角的**汉堡包**图标（![](image/C12607_08_icon.png)），然后从菜单中选择**函数**，如下图所示：![](image/C12607_08_07.jpg)
- en: 'Figure 8.7: IBM Cloud home page'
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.7：IBM Cloud首页
- en: 'This will take you to the **IBM Cloud** functions page (https://cloud.ibm.com/functions/),
    as shown in the following figure:![Figure 8.8: IBM Cloud Functions page'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带您到**IBM Cloud**函数页面（https://cloud.ibm.com/functions/），如下图所示：![图8.8：IBM Cloud函数页面
- en: '](image/C12607_08_08.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_08.jpg)'
- en: 'Figure 8.8: IBM Cloud Functions page'
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.8：IBM Cloud函数页面
- en: OpenWhisk offers a CLI named `wsk` to create and manage OpenWhisk entities.
    Next, we will install the **OpenWhisk CLI**, which will be used to interact with
    the OpenWhisk platform.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWhisk提供了一个名为`wsk`的CLI来创建和管理OpenWhisk实体。接下来，我们将安装**OpenWhisk CLI**，它将用于与OpenWhisk平台交互。
- en: 'Exercise 25: Installing the IBM Cloud CLI'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习25：安装IBM Cloud CLI
- en: 'In this exercise, we are going to install the IBM Cloud CLI with the Cloud
    Functions plugin, which supports OpenWhisk:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将安装带有Cloud Functions插件的IBM Cloud CLI，该插件支持OpenWhisk：
- en: 'First, we need to download the compressed IBM Cloud CLI file. Use the `curl`
    command with the `-Lo` flag to download the CLI, as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要下载压缩的IBM Cloud CLI文件。使用`curl`命令和`-Lo`标志下载CLI，如下所示：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output should be as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.9: Downloading the IBM Cloud CLI'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：下载IBM Cloud CLI
- en: '](image/C12607_08_09.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_09.jpg)'
- en: 'Figure 8.9: Downloading the IBM Cloud CLI'
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.9：下载IBM Cloud CLI
- en: 'Next, we will extract the `tar.gz` file using the `tar` command as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`tar`命令提取`tar.gz`文件，如下所示：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output should be as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.10: Extracting the IBM Cloud CLI'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：提取IBM Cloud CLI
- en: '](image/C12607_08_10.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_10.jpg)'
- en: 'Figure 8.10: Extracting the IBM Cloud CLI'
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.10：提取IBM Cloud CLI
- en: 'Then move the `ibmcloud` executable file to the `/usr/local/bin/` path, as
    shown in the following command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将`ibmcloud`可执行文件移动到`/usr/local/bin/`路径，如下命令所示：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output should be as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.11: Moving ibmcloud to /usr/local/bin'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：将ibmcloud移动到/usr/local/bin
- en: '](image/C12607_08_11.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_11.jpg)'
- en: 'Figure 8.11: Moving ibmcloud to /usr/local/bin'
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.11：将ibmcloud移动到/usr/local/bin
- en: 'Now we will log in to IBM Cloud using the IBM Cloud CLI. Execute the following
    command, replacing `<YOUR_EMAIL>` with the email address used when registering
    to IBM Cloud. Provide the email and password used during the registration phase
    when prompted and set the region number as **5** (**us-south**), as you can see
    in the following command:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将使用IBM Cloud CLI登录IBM Cloud。执行以下命令，将`<YOUR_EMAIL>`替换为注册IBM Cloud时使用的电子邮件地址。在提示时提供注册阶段使用的电子邮件和密码，并将区域号设置为**5**（**us-south**），如下命令所示：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output should be as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.12: Logging in to IBM Cloud'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：登录IBM Cloud
- en: '](image/C12607_08_12.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_12.jpg)'
- en: 'Figure 8.12: Logging in to IBM Cloud'
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.12：登录IBM Cloud
- en: 'Now we will install the Cloud Functions plugin using the `ibmcloud` CLI, as
    shown in the following command. This plugin will be used when we work with OpenWhisk
    entities:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将使用`ibmcloud` CLI安装Cloud Functions插件，如下命令所示。在处理OpenWhisk实体时，将使用此插件：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output should be as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.13: Installing Cloud Functions'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：安装Cloud Functions
- en: '](image/C12607_08_13.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_13.jpg)'
- en: 'Figure 8.13: Installing Cloud Functions'
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.13：安装Cloud Functions
- en: 'Next, we will provide the target organization (the organization name is your
    email address) and the space (which defaults to `dev`) using the following command:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用以下命令提供目标组织（组织名称为您的电子邮件地址）和空间（默认为`dev`）：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output should be as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.14: Setting the target organization and space'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：设置目标组织和空间
- en: '](image/C12607_08_14.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_14.jpg)'
- en: 'Figure 8.14: Setting the target organization and space'
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.14：设置目标组织和空间
- en: 'Now the configurations are done. We can use `ibmcloud wsk` to interact with
    OpenWhisk entities, as shown in the following command:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在配置完成了。我们可以使用`ibmcloud wsk`与OpenWhisk实体交互，如下命令所示：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output should be as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.15: Listing OpenWhisk actions'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15：列出OpenWhisk操作'
- en: '](image/C12607_08_15.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_15.jpg)'
- en: 'Figure 8.15: Listing OpenWhisk actions'
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.15：列出OpenWhisk操作
- en: Note
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, we will be using the `wsk` command to manage OpenWhisk entities
    instead of the `ibmcloud wsk` command provided by IBM Cloud Functions. Both of
    them provide the same functionality. The only difference is that `wsk` is the
    standard CLI for OpenWhisk and `ibmcloud fn` is from the IBM Cloud Functions plugin.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用`wsk`命令来管理OpenWhisk实体，而不是IBM Cloud Functions提供的`ibmcloud wsk`命令。它们两者提供相同的功能。唯一的区别是`wsk`是OpenWhisk的标准CLI，而`ibmcloud
    fn`来自IBM Cloud Functions插件。
- en: 'Let''s create a Linux alias, `wsk="ibmcloud wsk"`. First, open the `~/.bashrc`
    file with your favorite text editor. In the following command, we will be using
    the `vim` text editor to open the file:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个Linux别名，`wsk="ibmcloud wsk"`。首先，用您喜欢的文本编辑器打开`~/.bashrc`文件。在下面的命令中，我们将使用`vim`文本编辑器打开文件：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following line at the end of the file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾添加以下行：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Source the `~/.bashrc` file to apply the changes, as shown in the following
    command:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源`~/.bashrc`文件以应用更改，如下命令所示：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output should be as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.16: Sourcing the bashrc file'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.16：获取bashrc文件'
- en: '](image/C12607_08_16.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_16.jpg)'
- en: 'Figure 8.16: Sourcing the bashrc file'
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.16：获取bashrc文件
- en: 'Now we should be able to invoke OpenWhisk with the `wsk` command. Execute the
    following command to verify the installation:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们应该能够使用`wsk`命令调用OpenWhisk。执行以下命令以验证安装：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will print the help page of the `wsk` command, as shown in the following
    figure:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印`wsk`命令的帮助页面，如下图所示：
- en: '![Figure 8.17: Output for wsk command'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17：wsk命令的输出'
- en: '](image/C12607_08_17.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_17.jpg)'
- en: 'Figure 8.17: Output for wsk command'
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.17：wsk命令的输出
- en: Now, let's proceed to the next section on OpenWhisk actions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行下一节关于OpenWhisk动作的部分。
- en: OpenWhisk Actions
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenWhisk动作
- en: 'In OpenWhisk, actions are code snippets written by developers that will be
    executed in response to events. These actions can be written in any programming
    language supported by OpenWhisk:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenWhisk中，动作是由开发人员编写的代码片段，将在响应事件时执行。这些动作可以用OpenWhisk支持的任何编程语言编写：
- en: Ballerina
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ballerina
- en: Go
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go
- en: Java
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java
- en: JavaScript
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: PHP
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP
- en: Python
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: Ruby
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby
- en: Swift
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift
- en: .NET Core
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core
- en: Also, we can use a custom Docker image if our preferred language runtime is
    not supported by OpenWhisk yet. These actions will receive a JSON object as input,
    then perform the necessary processing within the action, and finally return a
    JSON object with the processed results. In the following sections, we will focus
    on how to write, create, list, invoke, update, and delete OpenWhisk actions using
    the `wsk` CLI.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们喜欢的语言运行时尚未得到OpenWhisk的支持，我们可以使用自定义的Docker镜像。这些动作将接收一个JSON对象作为输入，然后在动作内执行必要的处理，最后返回一个包含处理结果的JSON对象。在接下来的章节中，我们将重点介续如何使用`wsk`
    CLI编写、创建、列出、调用、更新和删除OpenWhisk动作。
- en: Writing Actions for OpenWhisk
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为OpenWhisk编写动作
- en: 'When writing OpenWhisk actions with your preferred language, there are few
    standards that you must follow. They are as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用您喜欢的语言编写OpenWhisk动作时，有一些标准必须遵循。它们如下：
- en: Each action should have a function named `main`, which is the entry point of
    the action. The source code can have additional functions, but the `main` function
    will be executed once the action is triggered.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个动作应该有一个名为`main`的函数，这是动作的入口点。源代码可以有额外的函数，但一旦触发动作，`main`函数将被执行。
- en: The function must return a JSON object as the response.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数必须返回一个JSON对象作为响应。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, we will be mainly using JavaScript to create the function code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要使用JavaScript来创建函数代码。
- en: 'Let''s look at an example in which we create a JavaScript code (`random-number.js`)
    that conforms to the rules we''ve just mentioned. This is a simple function that
    generates a random number between 0 to 1 and returns the generated number as the
    function''s response:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，我们创建一个符合我们刚才提到的规则的JavaScript代码（`random-number.js`）。这是一个简单的函数，它生成0到1之间的随机数，并将生成的数字作为函数的响应返回：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is a PHP function that conforms to the rules:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个符合规则的PHP函数：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating Actions on the OpenWhisk Framework
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在OpenWhisk框架上创建操作
- en: 'Now it''s time to create an action on the OpenWhisk framework by using the
    action code written in the previous section. We will be using the `wsk action
    create` command, which has the following format:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用在上一节中编写的操作代码在OpenWhisk框架上创建一个操作了。我们将使用`wsk action create`命令，其格式如下：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`<action-name>` is the identifier of the action. It should be unique to prevent
    naming conflicts. `<action-file-name>` is the file that contains the source code
    of the action. Let''s execute the following command to create an OpenWhisk action
    named `randomNumber` using the action source code in the `random-number.js` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`<action-name>`是操作的标识符。它应该是唯一的，以防止命名冲突。`<action-file-name>`是包含操作源代码的文件。让我们执行以下命令，使用`random-number.js`文件中的操作源代码创建一个名为`randomNumber`的OpenWhisk操作：'
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output we receive from this command looks like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个命令接收到的输出如下所示：
- en: '![Figure 8.18: Creating a randomNumber action'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.18：创建一个randomNumber操作'
- en: '](image/C12607_08_18.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_18.jpg)'
- en: 'Figure 8.18: Creating a randomNumber action'
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.18：创建一个randomNumber操作
- en: As we can see in the output, whenever an action is successfully created, the
    CLI prompt appropriately informs the reader of the status of the action.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在输出中看到的，每当成功创建一个操作时，CLI提示都会适当地通知读者操作的状态。
- en: 'The OpenWhisk framework will determine the runtime to execute the action based
    on the extension of the source code file. In the preceding scenario, the Node.js
    `10` runtime will be selected for the provided `.js` file. You can use the `--kind`
    flag with the `wsk action create` command if you want to override the default
    runtime selected by the OpenWhisk framework:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWhisk框架将根据源代码文件的扩展名确定执行操作的运行时。在前面的场景中，将为提供的`.js`文件选择Node.js `10`运行时。如果要覆盖OpenWhisk框架选择的默认运行时，可以在`wsk
    action create`命令中使用`--kind`标志：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output should be as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.19: Creating a randomNumber action with the nodejs:8 runtime'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19：使用nodejs:8运行时创建一个randomNumber操作'
- en: '](image/C12607_08_19.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_19.jpg)'
- en: 'Figure 8.19: Creating a randomNumber action with the nodejs:8 runtime'
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.19：使用nodejs:8运行时创建一个randomNumber操作
- en: The preceding output indicates that `secondRandomNumber` was created successfully.
    At the end of this section, we have deployed two OpenWhisk actions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出表明`secondRandomNumber`已成功创建。在本节结束时，我们已部署了两个OpenWhisk操作。
- en: Having learned how to create actions on the OpenWhisk framework, next we shall
    work on listing OpenWhisk actions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 学会了如何在OpenWhisk框架上创建操作后，接下来我们将继续列出OpenWhisk操作。
- en: Listing OpenWhisk Actions
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出OpenWhisk操作
- en: 'In this section, we are going to list the OpenWhisk actions in our environment
    with the `wsk` CLI using the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用以下命令在我们的环境中使用`wsk` CLI列出OpenWhisk操作：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output should be as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.20: Listing all actions'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.20：列出所有操作'
- en: '](image/C12607_08_20.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_20.jpg)'
- en: 'Figure 8.20: Listing all actions'
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.20：列出所有操作
- en: 'From the preceding output, we can see the two actions we created earlier with
    the names `randomNumber` and `secondRandomNumber`. The `wsk action list` command
    lists the actions and the runtime of these actions, such as `nodejs:8` or `nodejs:10`.
    By default, the action list will be sorted based on the last update time, so the
    most recently updated action will be at the top of the list. If we want the list
    to be sorted alphabetically, we can use the `--name-sort` (or `-n`) flag, as shown
    in the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述输出中，我们可以看到我们之前创建的两个操作，名称分别为`randomNumber`和`secondRandomNumber`。`wsk action
    list`命令列出操作及其运行时，如`nodejs:8`或`nodejs:10`。默认情况下，操作列表将根据最后更新时间进行排序，因此最近更新的操作将位于列表顶部。如果我们希望列表按字母顺序排序，可以使用`--name-sort`（或`-n`）标志，如下所示：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output should be as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.21: Listing all actions sorted by name in ascending order'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21：按名称升序列出所有操作'
- en: '](image/C12607_08_21.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_21.jpg)'
- en: 'Figure 8.21: Listing all actions sorted by name in ascending order'
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.21：按名称升序列出所有操作
- en: Invoking OpenWhisk Actions
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用OpenWhisk操作
- en: 'Now our actions are ready to be invoked. OpenWhisk actions can be invoked in
    two ways using the `wsk` CLI:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的操作已经准备好被调用了。OpenWhisk操作可以通过`wsk` CLI以两种方式被调用：
- en: Request-response
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求-响应
- en: Fire-and-forget
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发-忘记
- en: The **request-response** method is synchronous; the action invocation will wait
    until the results are available. On the other hand, the **fire-and-forget** method
    is asynchronous. This will return an ID called the activation ID, which can be
    used later to get the results.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求-响应**方法是同步的；操作调用将等待结果可用。另一方面，**触发-忘记**方法是异步的。这将返回一个称为激活ID的ID，稍后可以用来获取结果。'
- en: 'Here is the standard format of the `wsk` command to invoke the action:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是调用操作的`wsk`命令的标准格式：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Request-Response Invocation Method**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求-响应调用方法**'
- en: 'In the **request-response** method, the `wsk action invoke` command is used
    with the `--blocking` (or `-b`) flag, which asks the `wsk` CLI to wait for the
    invocation results:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在**请求-响应**方法中，`wsk action invoke`命令与`--blocking`（或`-b`）标志一起使用，该标志要求`wsk` CLI等待调用结果：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding command will return the following output in the terminal, which
    contains the result returned from the method with other metadata about the method
    invocation:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在终端中返回以下输出，其中包含从方法返回的结果以及有关方法调用的其他元数据：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can see the output (`"number": 0.6488215545330562`) returned by the main
    function within the `response` section of the returned JSON object. This is the
    random number generated by the JavaScript function that we wrote previously. The
    returned JSON object contains an activation ID (`"activationId": "002738b1acee4abba738b1aceedabb60")`,
    which we can use to get the results later. This output includes other important
    values, such as the action invocation status (`"status": "success"`), the start
    time (`"start": 156482976619`), the end time (`"end": 1564829766237`), and the
    execution duration (`"duration": 46`) of this action.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以在返回的JSON对象的`response`部分中看到输出(`"number": 0.6488215545330562`)，这是我们之前编写的JavaScript函数生成的随机数。返回的JSON对象包含一个激活ID(`"activationId":
    "002738b1acee4abba738b1aceedabb60")`，我们可以稍后用来获取结果。此输出包括其他重要值，如操作调用状态(`"status":
    "success"`)，开始时间(`"start": 156482976619`)，结束时间(`"end": 1564829766237`)和执行持续时间(`"duration":
    46`)。'
- en: Note
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We will discuss how to get the activation results using `activationId` in the
    **Fire-and-Forget Invocation Method** section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论如何在**触发-忘记调用方法**部分使用`activationId`获取激活结果。
- en: 'We can use the `--result` (or `-r`) flag if we need to get the result of the
    action without the other metadata, as shown in the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要获取动作的结果而不包括其他元数据，可以使用`--result`（或`-r`）标志，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output should be as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.22: Invoking the randomNumber action using the request-and-response
    method'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22：使用请求和响应方法调用randomNumber动作'
- en: '](image/C12607_08_22.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_22.jpg)'
- en: 'Figure 8.22: Invoking the randomNumber action using the request-and-response
    method'
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.22：使用请求和响应方法调用randomNumber动作
- en: '**Fire-and-Forget Invocation Method**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**点火和忘记调用方法**'
- en: 'Action invocations with the **fire-and-forget** method do not wait for the
    result of the action. Instead, they return an activation ID that we can use to
    get the results of the action. This invocation method uses a similar command to
    the request-response method but without the `--blocking` (or `-b`) flag:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**点火和忘记**方法的动作调用不会等待动作的结果。相反，它们返回一个激活ID，我们可以使用它来获取动作的结果。这种调用方法使用类似的命令来请求响应方法，但没有`--blocking`（或`-b`）标志：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output should be as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.23: Invoking the randomNumber action using the fire-and-forget method'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.23：使用点火和忘记方法调用randomNumber动作'
- en: '](image/C12607_08_23.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_23.jpg)'
- en: 'Figure 8.23: Invoking the randomNumber action using the fire-and-forget method'
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.23：使用点火和忘记方法调用randomNumber动作
- en: In the preceding result, we can see the returned activation ID of `2b90ade473e443bc90ade473e4b3bcff`
    (please note that your activation ID will be different).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述结果中，我们可以看到返回的激活ID为`2b90ade473e443bc90ade473e4b3bcff`（请注意，您的激活ID将不同）。
- en: 'Now we can use the `wsk activation get` command to get the results for a given
    activation ID:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`wsk activation get`命令获取给定激活ID的结果：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You need to replace `<activation_id>` with the value returned when you invoked
    the function using the `wsk action invoke` command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要用`wsk action invoke`命令调用函数时返回的值替换`<activation_id>`：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you would prefer to retrieve only a summary of the activation, the `--summary`
    (or `-s`) flag should be provided with the `wsk activation get` command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望仅检索激活的摘要，应该在`wsk activation get`命令中提供`--summary`（或`-s`）标志：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output from the preceding command will print a summary of the activation
    details, as shown in the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出将打印激活详细信息的摘要，如下面的截图所示：
- en: '![Figure 8.24: The activation summary'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.24：激活摘要'
- en: '](image/C12607_08_24.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_24.jpg)'
- en: 'Figure 8.24: The activation summary'
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.24：激活摘要
- en: 'The `wsk activation result` command returns only the results of the action,
    omitting any metadata:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`wsk activation result`命令仅返回动作的结果，省略任何元数据：'
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output should be as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.25: The activation result'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.25：激活结果'
- en: '](image/C12607_08_25.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_25.jpg)'
- en: 'Figure 8.25: The activation result'
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.25：激活结果
- en: 'The `wsk activation list` command can be used to list all the activations:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`wsk activation list`命令可用于列出所有激活：'
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output should be as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.26: Listing activations'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.26：列出激活'
- en: '](image/C12607_08_26.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_26.jpg)'
- en: 'Figure 8.26: Listing activations'
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.26：列出激活
- en: 'The preceding command returns a list of activations sorted by the **datetime**
    of the activation''s invocation. The following table describes the information
    provided by each column:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令返回按激活的**日期时间**排序的激活列表。以下表格描述了每列提供的信息：
- en: '![Figure 8.27: Column description'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.27：列描述'
- en: '](image/C12607_08_27.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_27.jpg)'
- en: 'Figure 8.27: Column description'
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.27：列描述
- en: Updating OpenWhisk Actions
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新OpenWhisk操作
- en: 'In this section, we will learn how to update the source code of an action once
    it has been created on the OpenWhisk platform. We might want to update the action
    for several reasons. There could be a bug in the code, or we may simply want to
    enhance the code. The `wsk action update` command can be used to update an OpenWhisk
    action using the `wsk` CLI:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在OpenWhisk平台上创建操作后更新操作的源代码。我们可能希望出于几个原因更新操作。代码中可能存在错误，或者我们可能只是想增强代码。可以使用`wsk
    action update`命令使用`wsk` CLI来更新OpenWhisk操作：
- en: '[PRE28]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We already have an action that prints a random number, which is defined in
    the `random-number.js` function. This function prints a value between 0 and 1,
    but what if we want to print a random number between 1 and 100? This can now be
    done using the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个打印随机数的操作，它在`random-number.js`函数中定义。这个函数打印一个0到1之间的值，但是如果我们想要打印一个1到100之间的随机数呢？现在可以使用以下代码来实现：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we can execute the `wsk action update` command to update the `randomNumber`
    action:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以执行`wsk action update`命令来更新`randomNumber`操作：
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output should be as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![](image/C12607_08_28.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](image/C12607_08_28.jpg)'
- en: 'Figure 8.28: Updating the randomNumber action'
  id: totrans-226
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.28：更新randomNumber操作
- en: 'Now we can verify the result of the updated action by executing the following
    command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过执行以下命令来验证更新后操作的结果：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Figure 8.29: Invoking the randomNumber action'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.29：调用randomNumber操作'
- en: '](image/C12607_08_29.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_29.jpg)'
- en: 'Figure 8.29: Invoking the randomNumber action'
  id: totrans-231
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.29：调用randomNumber操作
- en: As we can see, the `randomNumber` action has returned a number between 1 to
    100\. We can invoke the `randomNumber` function number multiple times to verify
    that it returns an output number between 1 and 100.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`randomNumber`操作返回了1到100之间的数字。我们可以多次调用`randomNumber`函数来验证它是否返回1到100之间的输出数字。
- en: Deleting OpenWhisk Actions
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除OpenWhisk操作
- en: 'In this section, we will discuss how to delete an OpenWhisk action. The `wsk
    action delete` command is used to delete OpenWhisk actions:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何删除OpenWhisk操作。使用`wsk action delete`命令来删除OpenWhisk操作：
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s execute the `wsk action delete` command to delete the `randomNumber`
    and `secondRandomNumber` actions we created in the preceding sections:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行`wsk action delete`命令来删除我们在前面部分创建的`randomNumber`和`secondRandomNumber`操作：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output should be as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![](image/C12607_08_30.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](image/C12607_08_30.jpg)'
- en: 'Figure 8.30: Deleting the randomNumber and secondRandomNumber actions'
  id: totrans-240
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.30：删除randomNumber和secondRandomNumber操作
- en: Now we have learned how to write, create, list, invoke, update, and delete OpenWhisk
    actions. Let's move on to an exercise in which you will create your first OpenWhisk
    action.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何编写、创建、列出、调用、更新和删除OpenWhisk操作。让我们继续进行一个练习，在这个练习中，您将创建您的第一个OpenWhisk操作。
- en: 'Exercise 26: Creating Your First OpenWhisk Action'
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习26：创建您的第一个OpenWhisk操作
- en: 'In this exercise, we will first create a JavaScript function that receives
    exam marks as input and returns the exam results using the following criteria:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将首先创建一个JavaScript函数，该函数接收考试分数作为输入，并根据以下标准返回考试结果：
- en: Return `Pass` if marks are equal to or above 60.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果分数等于或高于60，则返回`Pass`。
- en: Return `Fail` if marks are below 60.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果分数低于60，则返回`Fail`。
- en: 'Next, we will create an action named `examResults` in the OpenWhisk framework
    with the previously mentioned JavaScript function code. Then, we will invoke the
    action to verify that it returns the results as expected. Once the action response
    is verified, we will update the action to return the exam grade with the results
    based on the following criteria:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在OpenWhisk框架中创建一个名为`examResults`的操作，使用先前提到的JavaScript函数代码。然后，我们将调用该操作以验证它是否按预期返回结果。一旦验证了操作的响应，我们将根据以下标准更新操作以返回考试成绩与结果：
- en: Return `Pass with grade A` if marks are equal to or above 80.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果分数等于或高于80，则返回“Pass with grade A”。
- en: Return `Pass with grade B` if marks are equal to or above 70.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果分数等于或高于70，则返回“Pass with grade B”。
- en: Return `Pass with grade C` if marks are equal to or above 60.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果分数等于或高于60，则返回“Pass with grade C”。
- en: Return `Fail` if marks are below 60.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果分数低于60，则返回“Fail”。
- en: Again, we will invoke the action to verify the results and finally delete the
    action.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将调用该动作以验证结果，最后删除该动作。
- en: Note
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this exercise can be found at [https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson08/Exercise26](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson08/Exercise26).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码文件可以在[https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson08/Exercise26](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson08/Exercise26)找到。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'First, let''s create a JavaScript function in the `exam-result.js` file that
    will return the exam results based on the provided exam marks:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`exam-result.js`文件中创建一个JavaScript函数，根据提供的考试分数返回考试结果：
- en: '[PRE34]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s create the OpenWhisk action named `examResult` from the `exam-result.js`
    file created in *step 1*:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们从*步骤1*中创建的`exam-result.js`文件中创建名为`examResult`的OpenWhisk动作：
- en: '[PRE35]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output should be as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.31: Creating the examResult action'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.31：创建examResult动作'
- en: '](image/C12607_08_31.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_31.jpg)'
- en: 'Figure 8.31: Creating the examResult action'
  id: totrans-262
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.31：创建examResult动作
- en: 'Once the action creation is successful, we can invoke the `examResult` action
    by sending a value between 0 to 100 to the `examMarks` parameter:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦动作创建成功，我们可以通过将值发送到`examMarks`参数来调用`examResult`动作，值的范围在0到100之间：
- en: '[PRE36]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output should be as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.32: Invoking the examResult action'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.32：调用examResult动作'
- en: '](image/C12607_08_32.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_32.jpg)'
- en: 'Figure 8.32: Invoking the examResult action'
  id: totrans-268
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.32：调用examResult动作
- en: 'At this step, we are going to create a new JavaScript function in `exam-result-02.js`
    to return the exam results with the `grade` parameter:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步，我们将在`exam-result-02.js`中创建一个新的JavaScript函数，以`grade`参数返回考试结果：
- en: '[PRE37]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s update the OpenWhisk action with the previously updated `exam-result-02.js`
    file:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用先前更新的`exam-result-02.js`文件更新OpenWhisk动作：
- en: '[PRE38]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output should be as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.33: Updating the examResult action'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.33：更新examResult动作'
- en: '](image/C12607_08_33.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_33.jpg)'
- en: 'Figure 8.33: Updating the examResult action'
  id: totrans-276
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.33：更新examResult动作
- en: 'Once the action is updated, we can invoke the action multiple times with different
    exam marks as parameters to verify the functionality:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦动作更新完成，我们可以多次调用该动作，并使用不同的考试分数作为参数来验证功能：
- en: '[PRE39]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output should be as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.34: Invoking the examResult action with different parameter values'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.34：使用不同的参数值调用examResult动作'
- en: '](image/C12607_08_34.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_34.jpg)'
- en: 'Figure 8.34: Invoking the examResult action with different parameter values'
  id: totrans-282
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.34：使用不同的参数值调用examResult动作
- en: 'Finally, we will delete the `examResult` action:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将删除`examResult`动作：
- en: '[PRE40]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output should be as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.35: Deleting the examResult action'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.35：删除examResult动作'
- en: '](image/C12607_08_35.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_35.jpg)'
- en: 'Figure 8.35: Deleting the examResult action'
  id: totrans-288
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.35：删除examResult动作
- en: In this exercise, we learned how to create a JavaScript function that follows
    the standards for OpenWhisk actions. Then we created the action and invoked it
    with the `wsk` CLI. After that, we changed the logic of the function code and
    updated the action with the latest function code. Finally, we performed a cleanup
    by deleting the action.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何创建一个遵循OpenWhisk操作标准的JavaScript函数。然后我们创建了这个操作并使用`wsk` CLI调用了它。之后，我们改变了函数代码的逻辑，并用最新的函数代码更新了操作。最后，我们通过删除操作来进行清理。
- en: OpenWhisk Sequences
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenWhisk序列
- en: In OpenWhisk, and in general with programming, functions (known as actions in
    OpenWhisk) are expected to perform a single focused task. This will help to reduce
    code duplication by reusing the same function code. But creating complex applications
    requires connecting multiple actions together to achieve the desired result. OpenWhisk
    sequences are used to chain multiple OpenWhisk actions (which can be in different
    programming language runtimes) together and create more complex processing pipelines.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenWhisk中，以及一般的编程中，函数（在OpenWhisk中称为操作）被期望执行单一的专注任务。这将有助于通过重用相同的函数代码来减少代码重复。但创建复杂的应用程序需要连接多个操作以实现期望的结果。OpenWhisk序列用于链接多个OpenWhisk操作（可以是不同编程语言运行时）并创建更复杂的处理流水线。
- en: 'The following diagram illustrates how a sequence can be constructed by chaining
    multiple actions:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了如何通过链接多个操作来构建序列：
- en: '![Figure 8.36: OpenWhisk sequence'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.36：OpenWhisk序列'
- en: '](image/C12607_08_36.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_36.jpg)'
- en: 'Figure 8.36: OpenWhisk sequence'
  id: totrans-295
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.36：OpenWhisk序列
- en: We can pass parameters (if any) to the sequence, which will be used as the input
    for the first action. Then, the output of each action will be the input for the
    next action, and the final action of the sequence will return its result as the
    output of the sequence. Actions written in different programming languages can
    also be chained together with sequences.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向序列传递参数（如果有的话），这些参数将被用作第一个操作的输入。然后，每个操作的输出将作为下一个操作的输入，序列的最终操作将返回其结果作为序列的输出。不同编程语言编写的操作也可以通过序列链接在一起。
- en: 'Sequences can be created using the `wsk action create` command with the `--sequence`
    flag to provide a comma-separated list of actions to invoke:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`wsk action create`命令创建序列，并使用`--sequence`标志提供一个逗号分隔的操作列表来调用：
- en: '[PRE41]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In order to demonstrate the concept of OpenWhisk sequences, we will be creating
    a sequence named `login` in the following section, which consists of two actions,
    named **authentication** and **authorization**. The `login` action will be invoked
    when a user tries to log in to the application. If the user provides correct credentials
    at login, they can view all the content on the system. But if the user fails to
    provide the correct login credentials, they can only view the public content of
    the system.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示OpenWhisk序列的概念，我们将在下一节中创建一个名为`login`的序列，其中包括两个操作，名为**authentication**和**authorization**。当用户尝试登录应用程序时，将调用`login`操作。如果用户在登录时提供了正确的凭据，他们可以查看系统上的所有内容。但如果用户未能提供正确的登录凭据，他们只能查看系统的公共内容。
- en: Note
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Authentication is verifying the user's identity, and authorization is granting
    the required level of access to the system.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是验证用户的身份，授权是授予系统所需级别的访问权限。
- en: 'First, let''s create the `authentication.js` function. This function will receive
    two parameters, named `username` and `password`. If the username and password
    match the hardcoded values of `admin` (for the `username` parameter) and `openwhisk`
    (for the `password` parameter), the function will return `authenticationResult`
    as `true`. Otherwise, `authenticationResult` will be `false`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建 `authentication.js` 函数。这个函数将接收两个参数，名为 `username` 和 `password`。如果用户名和密码与
    `admin`（对于 `username` 参数）和 `openwhisk`（对于 `password` 参数）的硬编码值匹配，函数将返回 `authenticationResult`
    为 `true`。否则，`authenticationResult` 将为 `false`：
- en: '[PRE42]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The next function is `authorization.js`, which takes the `authenticationSuccess`
    value as input and displays appropriate content to the users. If the user is successfully
    authenticated (`authenticationSuccess = true`), the `''Authentication Success!
    You can view all content''` message will be displayed. If authentication failed
    (`authenticationSuccess != true`), the `''Authentication Failed! You can view
    only public content''` message will be displayed:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的函数是 `authorization.js`，它以 `authenticationSuccess` 值作为输入，并向用户显示适当的内容。如果用户成功通过认证（`authenticationSuccess
    = true`），将显示 `'Authentication Success! You can view all content'` 消息。如果认证失败（`authenticationSuccess
    != true`），将显示 `'Authentication Failed! You can view only public content'` 消息：
- en: '[PRE43]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let''s deploy both actions with the `wsk action create` command:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `wsk action create` 命令部署这两个操作：
- en: '[PRE44]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output should be as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.37: Creating authentication and authorization actions'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.37：创建认证和授权操作'
- en: '](image/C12607_08_37.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_37.jpg)'
- en: 'Figure 8.37: Creating authentication and authorization actions'
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.37：创建认证和授权操作
- en: 'Now both authentication and authorization actions are ready. Let''s create
    a sequence named `login` by combining `authentication` and `authorization` actions:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在认证和授权操作都准备好了。让我们通过组合 `authentication` 和 `authorization` 操作来创建一个名为 `login`
    的序列：
- en: '[PRE45]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output should be as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![](image/C12607_08_38.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](image/C12607_08_38.jpg)'
- en: 'Figure 8.38: Creating a login sequence'
  id: totrans-316
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.38：创建登录序列
- en: 'Now it''s time to test the login sequence. First, we will invoke the login
    sequence by sending the correct credentials (`username` = `admin` and `password`
    = `openwhisk`):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是测试登录序列的时候了。首先，我们将通过发送正确的凭据（`username` = `admin` 和 `password` = `openwhisk`）来调用登录序列：
- en: '[PRE46]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output should be as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![](image/C12607_08_39.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](image/C12607_08_39.jpg)'
- en: 'Figure 8.39: Invoking the login sequence with valid credentials'
  id: totrans-321
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.39：使用有效凭据调用登录序列
- en: 'The expected result for a successful login is shown in the preceding screenshot.
    Now, let''s invoke the login sequence by sending incorrect credentials (`username`
    = `hacker` and `password` = `hacker`). This time we expect to receive an authentication
    failure message:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 成功登录的预期结果显示在上面的截图中。现在，让我们通过发送不正确的凭据（`username` = `hacker` 和 `password` = `hacker`）来调用登录序列。这次我们期望收到一个认证失败的消息：
- en: '[PRE47]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output should be as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.40: Invoking the login sequence with invalid credentials'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.40：使用无效凭据调用登录序列'
- en: '](image/C12607_08_40.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_40.jpg)'
- en: 'Figure 8.40: Invoking the login sequence with invalid credentials'
  id: totrans-327
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.40：使用无效凭据调用登录序列
- en: In this section, we learned about OpenWhisk sequences. We created multiple actions,
    linked them together using a sequence, and invoked the sequence by sending the
    required parameters.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了关于OpenWhisk序列的知识。我们创建了多个操作，使用序列将它们链接在一起，并通过发送所需的参数来调用序列。
- en: 'Exercise 27: Creating OpenWhisk Sequences'
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习27：创建OpenWhisk序列
- en: In this exercise, we will create a sequence with two actions written in different
    languages. The first action, written in Python, receives the marks for two exams
    and returns the average marks. The second action, written in JavaScript, receives
    the average marks and returns either pass or fail.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个包含两种不同语言编写的操作的序列。第一个操作用Python编写，接收两次考试的分数并返回平均分。第二个操作用JavaScript编写，接收平均分并返回通过或失败。
- en: Note
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this exercise can be found at [https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson08/Exercise27](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson08/Exercise27).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码文件可以在[https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson08/Exercise27](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson08/Exercise27)找到。
- en: 'The following steps will help you complete the exercise:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成练习：
- en: 'Write the first function (`calculate-average.py`), which calculates the average
    marks. This function will receive the marks for two exams as the input:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写第一个函数（`calculate-average.py`），计算平均分。此函数将接收两次考试的分数作为输入：
- en: '[PRE48]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create an OpenWhisk action named `calculateAverage` from `calculate-average.py`:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`calculate-average.py`创建一个名为`calculateAverage`的OpenWhisk操作：
- en: '[PRE49]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output should be as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.41: Creating the calculateAverage action'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.41：创建calculateAverage操作'
- en: '](image/C12607_08_41.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_41.jpg)'
- en: 'Figure 8.41: Creating the calculateAverage action'
  id: totrans-341
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.41：创建calculateAverage操作
- en: 'Check that the `calculateAverage` action is working as expected by invoking
    it:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用检查`calculateAverage`操作是否按预期工作：
- en: '[PRE50]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output should be as follows:![Figure 8.42: Invoking the calculateAverage
    action'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出应如下所示：![图8.42：调用calculateAverage操作
- en: '](image/C12607_08_42.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_42.jpg)'
- en: 'Figure 8.42: Invoking the calculateAverage action'
  id: totrans-346
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.42：调用calculateAverage操作
- en: Create the second function (`show-result.js`), which returns the exam result
    (`Pass` or `Fail`) based on the average marks. The exam results will be based
    on the logic as marks less than 0 or greater than 100 will return an `Error`;
    marks greater than or equal to 60 will return `Pass`; else it will return `Fail`.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个函数（`show-result.js`），根据平均分返回考试结果（`通过`或`失败`）。考试结果将基于逻辑，即分数小于0或大于100将返回`错误`；分数大于或等于60将返回`通过`；否则将返回`失败`。
- en: 'The code would be as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE51]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create an OpenWhisk action named `showResult` from `show-result.js`:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`show-result.js`创建一个名为`showResult`的OpenWhisk操作：
- en: '[PRE52]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output should be as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.43: Creating the showResult action'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.43：创建showResult操作'
- en: '](image/C12607_08_43.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_43.jpg)'
- en: 'Figure 8.43: Creating the showResult action'
  id: totrans-355
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.43：创建showResult操作
- en: 'Check that the `showResult` action is working as expected by invoking it:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`showResult`操作是否按预期工作，通过调用它来验证：
- en: '[PRE53]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output should be as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.44: Invoking the showResult action'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.44：调用showResult操作'
- en: '](image/C12607_08_44.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_44.jpg)'
- en: 'Figure 8.44: Invoking the showResult action'
  id: totrans-361
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.44：调用showResult操作
- en: 'Create the `getExamResults` sequence with the `calculateAverage` and `showResult`
    actions:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`getExamResults`序列，其中包括`calculateAverage`和`showResult`操作：
- en: '[PRE54]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output should be as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.45: Creating the getExamResults sequence'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.45：创建getExamResults序列'
- en: '](image/C12607_08_45.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_45.jpg)'
- en: 'Figure 8.45: Creating the getExamResults sequence'
  id: totrans-367
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.45：创建getExamResults序列
- en: 'Invoke the `getExamResults` sequence and verify the result:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`getExamResults`序列并验证结果：
- en: '[PRE55]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output should be as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.46: Invoking the getExamResults sequence'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.46：调用getExamResults序列'
- en: '](image/C12607_08_46.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_46.jpg)'
- en: 'Figure 8.46: Invoking the getExamResults sequence'
  id: totrans-373
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.46：调用getExamResults序列
- en: OpenWhisk Web Actions
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenWhisk Web动作
- en: So far, we have invoked our OpenWhisk actions through the `wsk` CLI with the
    `wsk action invoke` command. Even though this invocation method is very simple
    and suits us well during the development stage, the `wsk` CLI cannot be used by
    external parties, such as external applications or users, to invoke our actions.
    As a solution, we can use OpenWhisk web actions, which will allow actions to be
    invoked through HTTP requests with a publicly available URL.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过`wsk` CLI和`wsk action invoke`命令调用了我们的OpenWhisk动作。尽管这种调用方法非常简单，并且在开发阶段非常适合我们，但`wsk`
    CLI不能被外部方使用，比如外部应用程序或用户，来调用我们的动作。作为解决方案，我们可以使用OpenWhisk web动作，这将允许通过公开可用的URL通过HTTP请求调用动作。
- en: OpenWhisk standard actions require authentication when invoking the action (this
    is handled internally by the **wsk** CLI) and must return a JSON payload as the
    response. In contrast, web actions can be invoked without authentication and can
    return additional information, such as HTTP headers and non-JSON payloads such
    as HTML and binary data.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用动作时，OpenWhisk标准动作需要身份验证（这由**wsk** CLI在内部处理），并且必须将JSON有效负载作为响应。相比之下，web动作可以在没有身份验证的情况下被调用，并且可以返回额外的信息，比如HTTP头和非JSON有效负载，比如HTML和二进制数据。
- en: An OpenWhisk standard action can be converted to a web action by sending the
    `--web true` (or `--web yes`) flag when creating (`wsk action create`) or updating
    (`wsk action update`) actions with the `wsk` CLI.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在创建（`wsk action create`）或更新（`wsk action update`）动作时发送`--web true`（或`--web
    yes`）标志，可以将OpenWhisk标准动作转换为web动作。
- en: 'Let''s create a JavaScript function (`web-action.js`) to be invoked as a web
    action. This function will return **Hello, Stranger** if we did not pass a value
    for the name parameter and returns `Hello` with the name when we pass a value
    for the `name` parameter with the web action URL:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个JavaScript函数（`web-action.js`）作为web动作被调用。如果我们没有为名称参数传递值，这个函数将返回**Hello,
    Stranger**，当我们通过web动作URL为`name`参数传递值时，它将返回`Hello`与名称：
- en: '[PRE56]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now we can create a web action by sending the `--web true` flag with the `wsk
    action create` command:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过发送`--web true`标志和`wsk action create`命令来创建一个web动作：
- en: '[PRE57]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output should be as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.47: Creating myWebAction as a web action'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.47：将myWebAction创建为web动作'
- en: '](image/C12607_08_47.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_47.jpg)'
- en: 'Figure 8.47: Creating myWebAction as a web action'
  id: totrans-385
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.47：将myWebAction创建为web动作
- en: 'Then, we can invoke the created web action using the web action URL. The general
    format of a web action URL is as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用web动作URL来调用创建的web动作。web动作URL的一般格式如下：
- en: '[PRE58]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s discuss each component of this URL:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下这个URL的每个组件：
- en: '`APIHOST`: The `APIHOST` value for IBM Cloud Functions is `openwhisk.ng.bluemix.net`.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APIHOST`：IBM Cloud Functions的`APIHOST`值为`openwhisk.ng.bluemix.net`。'
- en: '`QUALIFIED_ACTION_NAME`: The fully qualified name of the web action in `<namespace>/<package-name>/<action-name>`
    format. If the action is not in a named `package`, use `default` as the value
    of `<package-name>`.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QUALIFIED_ACTION_NAME`：web动作的完全限定名称，格式为`<namespace>/<package-name>/<action-name>`。如果动作不在命名的`package`中，请使用`default`作为`<package-name>`的值。'
- en: '`EXT`: The extension that represents the expected response type of the web
    action.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXT`：代表web动作预期响应类型的扩展。'
- en: 'We can use the `--url` flag with the `wsk action get` command to retrieve the
    URL of a web action:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`wsk action get`命令的`--url`标志来检索web动作的URL：
- en: '[PRE59]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output should be as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.48: Retrieving the public URL of myWebAction'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.48：检索myWebAction的公共URL'
- en: '](image/C12607_08_48.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_48.jpg)'
- en: 'Figure 8.48: Retrieving the public URL of myWebAction'
  id: totrans-397
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.48：检索myWebAction的公共URL
- en: We need to append `.json` as an extension to the preceding URL since our web
    action is responding with a JSON payload. Now we can either open this URL in a
    web browser or use the `curl` command to retrieve the output.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的web action正在响应JSON有效负载，我们需要在前面的URL中附加`.json`作为扩展名。现在我们可以在网页浏览器中打开此URL，或者使用`curl`命令检索输出。
- en: 'Let''s invoke in the preceding URL using a web browser:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在前面的URL中使用网页浏览器调用：
- en: '![Figure 8.49: Invoking myWebAction from a web browser without the name parameter'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.49：从网页浏览器中调用myWebAction而没有name参数'
- en: '](image/C12607_08_49.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_49.jpg)'
- en: 'Figure 8.49: Invoking myWebAction from a web browser without the name parameter'
  id: totrans-402
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.49：从网页浏览器中调用myWebAction而没有name参数
- en: '**Hello, Stranger** is the expected response because we did not pass a value
    for the `name` parameter in the query.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**你好，陌生人**是预期的响应，因为我们没有在查询中为`name`参数传递值。'
- en: 'Now, let''s invoke the same URL by appending `?name=OpenWhisk` at the end of
    the URL:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过在URL末尾附加`?name=OpenWhisk`来调用相同的URL：
- en: '[https://us-south.functions.cloud.ibm.com/api/v1/web/sathsara89%40gmail.com_dev/default/myWebAction.json?name=OpenWhisk](https://us-south.functions.cloud.ibm.com/api/v1/web/sathsara89%40gmail.com_dev/default/myWebAction.json?name=OpenWhisk)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://us-south.functions.cloud.ibm.com/api/v1/web/sathsara89%40gmail.com_dev/default/myWebAction.json?name=OpenWhisk](https://us-south.functions.cloud.ibm.com/api/v1/web/sathsara89%40gmail.com_dev/default/myWebAction.json?name=OpenWhisk)'
- en: 'The output should be as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.50: Invoking myWebAction from a web browser with the name parameter'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.50：从网页浏览器中调用myWebAction而有name参数'
- en: '](image/C12607_08_50.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_50.jpg)'
- en: 'Figure 8.50: Invoking myWebAction from a web browser with the name parameter'
  id: totrans-409
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.50：从网页浏览器中调用myWebAction而有name参数
- en: 'We can invoke the same URL as a `curl` request with the following command:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令将相同的URL作为`curl`请求调用：
- en: '[PRE60]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output should be as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.51: Invoking myWebAction as a curl command with the name parameter'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.51：使用name参数作为curl命令调用myWebAction'
- en: '](image/C12607_08_51.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_51.jpg)'
- en: 'Figure 8.51: Invoking myWebAction as a curl command with the name parameter'
  id: totrans-415
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.51：使用name参数作为curl命令调用myWebAction
- en: This command will produce the same output as we saw in the web browser.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将产生与我们在网页浏览器中看到的相同的输出。
- en: 'As we discussed previously, OpenWhisk web actions can be configured to return
    additional information including HTTP headers, HTTP status codes, and body content
    of different types using one or more of the following fields in the JSON response:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，OpenWhisk web actions可以配置为返回附加信息，包括HTTP标头、HTTP状态码和使用JSON响应中的一个或多个字段的不同类型的主体内容：
- en: '`headers`: This field is used to send HTTP headers in the response. An example
    would be to send `Content-Type` as `text/html`.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`：此字段用于在响应中发送HTTP标头。一个示例是将`Content-Type`发送为`text/html`。'
- en: '`statusCode`: This will send a valid HTTP response code. The status code of
    **200 OK** will be sent unless specified explicitly.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statusCode`：这将发送一个有效的HTTP响应代码。除非明确指定，否则将发送**200 OK**的状态代码。'
- en: '`body`: This contains the response content, which is either plain text, a JSON
    object or array, or a base64-encoded string for binary data.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`：这包含响应内容，可以是纯文本、JSON对象或数组，或者是用于二进制数据的base64编码字符串。'
- en: 'Now we will update the `web-action.js` function to send the response in the
    format we discussed earlier:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更新`web-action.js`函数以按照我们之前讨论的格式发送响应：
- en: '[PRE61]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we will update the `myWebAction` action with the latest function code:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用最新的函数代码更新`myWebAction`动作：
- en: '[PRE62]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output should be as follows:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.52: Updating myWebAction'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.52：更新myWebAction'
- en: '](image/C12607_08_52.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_52.jpg)'
- en: 'Figure 8.52: Updating myWebAction'
  id: totrans-428
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.52：更新myWebAction
- en: 'Let''s invoke the updated action with the following `curl` command. We will
    provide `name=OpenWhisk` as a query parameter in the URL. Also, the `-v` option
    is used to print verbose output, which will help us to verify the fields we added
    to the response:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下`curl`命令调用更新后的动作。我们将在URL中提供`name=OpenWhisk`作为查询参数。此外，使用`-v`选项打印详细输出，这将帮助我们验证我们添加到响应中的字段：
- en: '[PRE63]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here is the response we received after the preceding `curl` command:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在前述`curl`命令之后收到的响应：
- en: '[PRE64]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As expected, we have received `HTTP/1.1 200 OK` as the HTTP response code,
    `Content-Type: text/html` as a header, a cookie, and `<html><body><h3>Hello, OpenWhisk</h3></body></html>`
    as the body of the response.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '如预期的那样，我们收到了`HTTP/1.1 200 OK`作为HTTP响应代码，`Content-Type: text/html`作为头部，一个cookie，以及`<html><body><h3>Hello,
    OpenWhisk</h3></body></html>`作为响应的主体。'
- en: 'Now, let''s invoke the same `curl` request without the `name=OpenWhisk` query
    parameter. This time, the expected response code is `HTTP/1.1 400 Bad Request`
    because we did not pass a value for the query parameter. Also, the `curl` command
    will respond with `<html><body><h3>Hello, Stranger</h3></body></html>` as the
    HTTP response body code:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在不带`name=OpenWhisk`查询参数的情况下调用相同的`curl`请求。这次，预期的响应代码是`HTTP/1.1 400 Bad
    Request`，因为我们没有为查询参数传递值。此外，`curl`命令将以`<html><body><h3>Hello, Stranger</h3></body></html>`作为HTTP响应体代码做出响应：
- en: '[PRE65]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Here is the response from the preceding `curl` command:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在前述`curl`命令之后收到的响应：
- en: '[PRE66]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this section, we introduced OpenWhisk web actions and discussed the differences
    between standard actions and web actions. Then, we created a web action using
    the `wsk` CLI. Next, we learned about the format of the URL exposed by web actions.
    We invoked the web action with both web browser and `curl` commands. Then, we
    discussed the additional information that can be returned with web actions. Finally,
    we updated our web action to include headers, **statusCode**, and the body in
    the response and invoked the web action using the `curl` command to verify the
    response.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了OpenWhisk web动作，并讨论了标准动作和web动作之间的区别。然后，我们使用`wsk` CLI创建了一个web动作。接下来，我们了解了web动作暴露的URL的格式。我们使用web浏览器和`curl`命令调用了web动作。然后，我们讨论了web动作可以返回的附加信息。最后，我们更新了我们的web动作以包括响应中的头部、**statusCode**和主体，并使用`curl`命令调用了web动作以验证响应。
- en: OpenWhisk Feeds, Triggers, and Rules
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenWhisk Feeds、触发器和规则
- en: 'In the previous sections, we learned how to invoke actions either with the
    **wsk** CLI or with HTTP requests using web actions. In this section, we are going
    to learn how to automate action invocation with OpenWhisk feeds, triggers, and
    rules. The following diagram illustrates how actions are invoked with events from
    external event sources using feeds, triggers, and rules:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中，我们学习了如何使用**wsk** CLI或使用web动作的HTTP请求来调用动作。在本节中，我们将学习如何使用OpenWhisk feeds、触发器和规则自动调用动作。以下图解说明了如何使用feeds、触发器和规则从外部事件源的事件调用动作：
- en: '![Figure 8.53: OpenWhisk Feeds, triggers, and rules'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.53：OpenWhisk Feeds、触发器和规则'
- en: '](image/C12607_08_53.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_53.jpg)'
- en: 'Figure 8.53: OpenWhisk Feeds, triggers, and rules'
  id: totrans-443
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.53：OpenWhisk Feeds、触发器和规则
- en: 'Triggers are different types of events sent from event sources. These triggers
    can be fired either manually with the `wsk` CLI or automatically from events occurring
    in external event sources. Some examples of an event source are a Git repository,
    an email account, or a Slack channel. As illustrated in the preceding diagram,
    feeds are used to connect the triggers to external event sources. Examples for
    feeds are as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器是从事件源发送的不同类型的事件。这些触发器可以通过`wsk` CLI手动触发，也可以自动从外部事件源发生的事件中触发。事件源的一些例子包括Git存储库、电子邮件帐户或Slack频道。如前图所示，feeds用于将触发器连接到外部事件源。feeds的示例如下：
- en: A commit is made to a Git repository.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Git存储库提交。
- en: Incoming email messages to a particular account.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到特定帐户的传入电子邮件消息。
- en: Message received by a Slack channel.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Slack频道收到的消息。
- en: 'As illustrated, the rule is the component that connects triggers with actions.
    A rule will connect one trigger with one action. Once this link is created, every
    invocation of the trigger will execute the associated action. The following scenarios
    are also possible by creating an appropriate set of rules:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，规则是连接触发器和动作的组件。规则将一个触发器连接到一个动作。创建此链接后，触发器的每次调用都将执行关联的动作。通过创建适当的规则集，还可以实现以下情景：
- en: A single trigger to execute multiple actions
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行多个动作的单个触发器
- en: A single action to be executed in response to multiple triggers
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个动作以响应多个触发器
- en: 'Let''s start by creating a simple action to be invoked with triggers and rules.
    Create a file named `triggers-rules.js` and add the following JavaScript function:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个简单的动作开始，以便与触发器和规则一起调用。创建一个名为`triggers-rules.js`的文件，并添加以下JavaScript函数：
- en: '[PRE67]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then we will create the action:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将创建动作：
- en: '[PRE68]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now it''s time to create our first trigger. We will use the `wsk trigger create`
    command to create the trigger using the `wsk` CLI:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是创建我们的第一个触发器的时候了。我们将使用`wsk trigger create`命令使用`wsk` CLI创建触发器：
- en: '[PRE69]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let''s create a trigger called `myTrigger`:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`myTrigger`的触发器：
- en: '[PRE70]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The output should be as follows:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.54: Creating myTrigger'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.54：创建myTrigger'
- en: '](image/C12607_08_54.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_54.jpg)'
- en: 'Figure 8.54: Creating myTrigger'
  id: totrans-462
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.54：创建myTrigger
- en: 'We can list the available triggers to make sure that `myTrigger` has been created
    successfully:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以列出可用的触发器，以确保`myTrigger`已成功创建：
- en: '[PRE71]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The output should be as follows:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.55: Listing all triggers'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.55：列出所有触发器'
- en: '](image/C12607_08_55.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_55.jpg)'
- en: 'Figure 8.55: Listing all triggers'
  id: totrans-468
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.55：列出所有触发器
- en: 'Triggers are useless until we connect them with actions through a rule. Now
    we will be creating an OpenWhisk rule with the `wsk rule create` command, which
    has the following format:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器在通过规则连接到动作之前是无用的。现在我们将使用`wsk rule create`命令创建一个OpenWhisk规则，其格式如下：
- en: '[PRE72]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s create a rule named `myRule` to connect the `myTrigger` and `triggerAndRules`
    actions together:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`myRule`的规则，将`myTrigger`和`triggerAndRules`动作连接在一起：
- en: '[PRE73]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output should be as follows:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.56: Creating myRule to connect myTrigger with the triggersAndRules
    action'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.56：创建myRule以连接myTrigger与triggersAndRules动作'
- en: '](image/C12607_08_56.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_56.jpg)'
- en: 'Figure 8.56: Creating myRule to connect myTrigger with the triggersAndRules
    action'
  id: totrans-476
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.56：创建myRule以连接myTrigger与triggersAndRules动作
- en: 'We can get the details about `myRule`, which shows the trigger and action associated
    with the rule:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取有关`myRule`的详细信息，其中显示了与规则关联的触发器和动作：
- en: '[PRE74]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This command will print detailed output about `myRule` as shown in the following
    screenshot, which includes the **namespace**, **version**, **status**, and associated
    **triggers** and **actions** of **rule**.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将打印有关`myRule`的详细输出，如下面的屏幕截图所示，其中包括**命名空间**、**版本**、**状态**以及**规则**的关联**触发器**和**动作**。
- en: 'The output should be as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.57: Getting the details of myRule'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.57：获取myRule的详细信息'
- en: '](image/C12607_08_57.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_57.jpg)'
- en: 'Figure 8.57: Getting the details of myRule'
  id: totrans-483
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.57：获取myRule的详细信息
- en: 'It''s time to see triggers in action once the **action**, **trigger**, and
    **rule** are ready. Let''s fire the trigger using the `wsk trigger fire` command:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦**动作**、**触发器**和**规则**准备就绪，就是时候看到触发器的作用了。使用`wsk trigger fire`命令触发触发器：
- en: '[PRE75]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The output should be as follows:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.58: Firing myTrigger'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.58：触发myTrigger'
- en: '](image/C12607_08_58.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_58.jpg)'
- en: 'Figure 8.58: Firing myTrigger'
  id: totrans-489
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.58：触发myTrigger
- en: This will print the ID of the activation for the trigger.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印触发器的激活ID。
- en: 'Let''s execute the following command to list the last two activations:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下命令来列出最后两次激活：
- en: '[PRE76]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The output should be as follows:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.59: Listing the last two activations'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.59：列出最后两次激活'
- en: '](image/C12607_08_59.jpg)'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_59.jpg)'
- en: 'Figure 8.59: Listing the last two activations'
  id: totrans-496
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.59：列出最后两次激活
- en: In the preceding screenshot, we can see that the `myTrigger` trigger activation
    is recorded, followed by the `triggersAndRules` action activation.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，我们可以看到`myTrigger`触发器激活被记录，然后是`triggersAndRules`动作激活。
- en: 'We can print the result of the `triggersAndRules` action activation to make
    sure that the action was invoked properly by the trigger:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印`triggersAndRules`动作激活的结果，以确保触发器正确调用了该动作：
- en: '[PRE77]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The output should be as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.60: Printing the result of the activation'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.60：打印激活的结果'
- en: '](image/C12607_08_60.jpg)'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_60.jpg)'
- en: 'Figure 8.60: Printing the result of the activation'
  id: totrans-503
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.60：打印激活的结果
- en: In this section, we discussed how to automate action invocation with feeds,
    triggers, and rules. We created an action, a trigger, and then a rule to connect
    them. Finally, we invoked the action by firing the trigger.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何使用提要、触发器和规则自动调用动作。我们创建了一个动作，一个触发器，然后创建了一个规则来连接它们。最后，我们通过触发器来调用动作。
- en: OpenWhisk CronJob Triggers
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenWhisk CronJob触发器
- en: In the preceding section, we discussed how to fire a trigger with the `wsk trigger
    fire` command. However, there are situations in which we need to automate the
    firing of triggers. An example would be performing a periodic task, such as running
    system backups, log archiving, or database purging. OpenWhisk provides cron-based
    triggers for invoking serverless functions at fixed intervals. The `/whisk.system/alarms`
    package provided by OpenWhisk can be used to fire triggers at scheduled intervals.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们讨论了如何使用`wsk trigger fire`命令触发触发器。然而，有些情况下我们需要自动触发触发器。一个例子是执行定期任务，比如运行系统备份、日志归档或数据库清理。OpenWhisk提供了基于cron的触发器，可以在固定间隔调用无服务器函数。OpenWhisk提供的`/whisk.system/alarms`软件包可以用来在预定的间隔触发触发器。
- en: 'This package includes the following feeds:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 此软件包包括以下提要：
- en: '![Figure 8.61: Feeds available in alarms package'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.61：警报软件包中可用的提要'
- en: '](image/C12607_08_61.jpg)'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_61.jpg)'
- en: 'Figure 8.61: Feeds available in alarms package'
  id: totrans-510
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.61：警报软件包中可用的提要
- en: In the following exercise, let's learn how to create a cron job-based trigger.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，让我们学习如何创建基于cron作业的触发器。
- en: 'Exercise 28: Creating CronJob Triggers'
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习28：创建CronJob触发器
- en: In this exercise, we are going to create an OpenWhisk action that will be invoked
    every minute using feeds, triggers, and rules. The function code will print the
    current date and time as the output so we can verify that the cron job trigger
    has correctly invoked the action.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将创建一个OpenWhisk动作，该动作将使用提要、触发器和规则每分钟被调用。函数代码将打印当前日期和时间作为输出，以便我们可以验证cron作业触发器是否正确调用了该动作。
- en: Note
  id: totrans-514
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this exercise can be found at [https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson08/Exercise28](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson08/Exercise28).
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码文件可以在[https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson08/Exercise28](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson08/Exercise28)找到。
- en: 'The following steps will help you to complete the exercise:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成本练习：
- en: 'Let''s start by creating the function code. This function will return the current
    date and time. Create a `date-time.js` file with the following code and create
    an action called `dateTimeAction`:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建函数代码开始。此函数将返回当前日期和时间。创建一个名为`date-time.js`的文件，其中包含以下代码，并创建一个名为`dateTimeAction`的动作：
- en: '[PRE78]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The output should be as follows:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.62: Creating dateTimeAction'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.62：创建dateTimeAction'
- en: '](image/C12607_08_62.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_62.jpg)'
- en: 'Figure 8.62: Creating dateTimeAction'
  id: totrans-522
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.62：创建dateTimeAction
- en: 'The next step is to create a trigger with the `/whisk.system/alarms/alarm`
    feed. The cron value is provided as `"* * * * *"`, which aims to trigger this
    action every minute:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用`/whisk.system/alarms/alarm` feed创建一个触发器。 cron值为`"* * * * *"`，旨在每分钟触发此动作：
- en: '[PRE79]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Here is the response for the `wsk trigger create` command. Make sure there
    is `ok: created trigger dateTimeCronTrigger` at the end of the output, which indicates
    the successful creation of `dateTimeCronTrigger`:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是`wsk trigger create`命令的响应。确保输出的末尾有`ok: created trigger dateTimeCronTrigger`，这表示成功创建了`dateTimeCronTrigger`：'
- en: '[PRE80]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create the rule (`dateTimeRule`) to connect the action (`dateTimeAction`) with
    the trigger (`dateTimeCronTrigger`):'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建规则（`dateTimeRule`）以将动作（`dateTimeAction`）与触发器（`dateTimeCronTrigger`）连接起来：
- en: '[PRE81]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The output should be as follows:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.63: Creating dateTimeRule to connect dateTimeCronTrigger with dateTimeAction'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.63：创建dateTimeRule以连接dateTimeCronTrigger和dateTimeAction'
- en: '](image/C12607_08_63.jpg)'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_63.jpg)'
- en: 'Figure 8.63: Creating dateTimeRule to connect dateTimeCronTrigger with dateTimeAction'
  id: totrans-532
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.63：创建dateTimeRule以连接dateTimeCronTrigger和dateTimeAction
- en: 'This action will now be triggered every minute. Allow the cron job trigger
    to run for around 5 minutes. We can list the last 6 activations with the following
    command:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该动作现在将每分钟被触发。让cron作业触发器运行大约5分钟。我们可以使用以下命令列出最近6次激活：
- en: '[PRE82]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The output should be as follows:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.64: Listing the last six activations'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.64：列出最近六次激活'
- en: '](image/C12607_08_64.jpg)'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_64.jpg)'
- en: 'Figure 8.64: Listing the last six activations'
  id: totrans-538
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.64：列出最近六次激活
- en: 'List the summary of the activations of `dateTimeAction` to make sure it has
    printed the current datetime every minute:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出`dateTimeAction`的激活摘要，以确保它已经每分钟打印了当前日期时间：
- en: '[PRE83]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The output should be as follows:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.65: Printing the summary of dateTimeAction activations'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.65：打印dateTimeAction激活的摘要'
- en: '](image/C12607_08_65.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_65.jpg)'
- en: 'Figure 8.65: Printing the summary of dateTimeAction activations'
  id: totrans-544
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.65：打印dateTimeAction激活的摘要
- en: Check the value of the `currentDateTime` field, printed for each invocation
    to verify that this action was invoked every minute as scheduled. In the preceding
    screenshot, we can see that the action was invoked at **09:37:02**, then again
    at **09:38:03**, and finally at **09:39:03**.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`currentDateTime`字段的值，打印每次调用以验证该动作是否按计划每分钟被调用。在前面的截图中，我们可以看到该动作在**09:37:02**被调用，然后在**09:38:03**再次被调用，最后在**09:39:03**被调用。
- en: In this activity, we created a simple function that prints the current date
    and time. Then, we created a cron job trigger to invoke this action every minute.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们创建了一个简单的函数，用于打印当前日期和时间。然后，我们创建了一个cron作业触发器，以便每分钟调用此动作。
- en: OpenWhisk Packages
  id: totrans-547
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenWhisk Packages
- en: OpenWhisk packages allow us to organize our actions by bundling the related
    actions together. As an example, consider that we have multiple actions, such
    as `createOrder`, `processOrder`, `dispatchOrder`, and `refundOrder`. These actions
    will perform the relevant application logic when an application user creates an
    order, processes an order, dispatches an order, and refunds an order respectively.
    In this case, we can create a package named `order` to group all order-related
    actions together.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWhisk包允许我们通过将相关动作捆绑在一起来组织我们的动作。举个例子，假设我们有多个动作，比如`createOrder`、`processOrder`、`dispatchOrder`和`refundOrder`。当应用用户创建订单、处理订单、派送订单和退款订单时，这些动作将执行相关的应用逻辑。在这种情况下，我们可以创建一个名为`order`的包来将所有与订单相关的动作分组在一起。
- en: As we learned previously, action names should be unique. Packages help to prevent
    naming conflicts because we can create multiple actions with the same name by
    placing them in different packages. As an example, the `retrieveInfo` action from
    the `order` package may retrieve information about an order, but the `retrieveInfo`
    action from the customer package can retrieve information about a customer.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前学到的，动作名称应该是唯一的。包有助于防止命名冲突，因为我们可以通过将它们放入不同的包中来创建具有相同名称的多个动作。举个例子，来自`order`包的`retrieveInfo`动作可能会检索有关订单的信息，但来自customer包的`retrieveInfo`动作可以检索有关客户的信息。
- en: So far, we have created many actions without bothering about packages. How was
    this possible? This is because OpenWhisk places actions into default packages
    if we do not mention any specific package during action creation.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了许多动作，而不用担心包。这是如何可能的？这是因为如果我们在创建动作时没有提及任何特定的包，OpenWhisk会将动作放入默认包中。
- en: 'There are two types of packages in OpenWhisk:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWhisk有两种类型的包：
- en: Built-in packages (packages come with OpenWhisk)
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置包（OpenWhisk自带的包）
- en: User-defined packages (other packages created by users)
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的包（用户创建的其他包）
- en: All the packages available in a namespace can be retrieved with the `wsk package
    list <namespace>` command.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`wsk package list <namespace>`命令检索命名空间中的所有包。
- en: 'The output should be as follows:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.66: Listing the packages in the /whisk.system namespace'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.66：列出/whisk.system命名空间中的包'
- en: '](image/C12607_08_66.jpg)'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_66.jpg)'
- en: 'Figure 8.66: Listing the packages in the /whisk.system namespace'
  id: totrans-558
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.66：列出/whisk.system命名空间中的包
- en: 'Packages can be created with the `wsk package create` command:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`wsk package create`命令可以创建包：
- en: '[PRE84]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In this section, we introduced the concept of packages and discussed the built-in
    packages and user-defined packages of OpenWhisk. In the next exercise, we will
    create a package and add an action to the newly created package.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了包的概念，并讨论了OpenWhisk的内置包和用户定义的包。在下一个练习中，我们将创建一个包并将一个动作添加到新创建的包中。
- en: 'Exercise 29: Creating OpenWhisk Packages'
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习29：创建OpenWhisk包
- en: 'In this exercise, we will create a package named `arithmetic` that contains
    all arithmetic-related actions, such as add, subtract, multiply, and divide. We
    will create a function that receives two numbers as input and returns the result
    by adding the numbers. Then, we will create this action within the `arithmetic`
    package:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将创建一个名为`arithmetic`的包，其中包含所有与算术相关的动作，如加法、减法、乘法和除法。我们将创建一个接收两个数字作为输入并通过将数字相加返回结果的函数。然后，我们将在`arithmetic`包中创建此动作：
- en: 'Let''s start by creating a package named `arithmetic`:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`arithmetic`的包开始：
- en: '[PRE85]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The output should be as follows:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.67: Creating the arithmetic package'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.67：创建算术包'
- en: '](image/C12607_08_67.jpg)'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_67.jpg)'
- en: 'Figure 8.67: Creating the arithmetic package'
  id: totrans-569
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.67：创建算术包
- en: 'Now we are going to create an action that will be added to our `arithmetic`
    package. Create a file named `add.js` with the following content:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个操作，将其添加到我们的`arithmetic`包中。创建一个名为`add.js`的文件，内容如下：
- en: '[PRE86]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We can create the action and add it to the `arithmetic` package simultaneously
    with the `wsk action create` command. This will only require us to prefix the
    action name with the package name. Execute the following command:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`wsk action create`命令同时创建操作并将其添加到`arithmetic`包中。这只需要我们在操作名称前加上包名称。执行以下命令：
- en: '[PRE87]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In the output, we can see that the action has been successfully created in the
    `arithmetic` package.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到操作已成功创建在`arithmetic`包中。
- en: 'The output should be as follows:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.68: Adding an add action to the arithmetic package'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.68：向算术包添加add操作'
- en: '](image/C12607_08_68.jpg)'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_68.jpg)'
- en: 'Figure 8.68: Adding an add action to the arithmetic package'
  id: totrans-578
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.68：向算术包添加add操作
- en: Now we can verify that our `add` action has been placed in the arithmetic package
    using the `wsk action list` command.
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`wsk action list`命令来验证我们的`add`操作是否已放置在算术包中。
- en: '[PRE88]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output should be as follows:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.69: Listing the actions'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.69：列出操作'
- en: '](image/C12607_08_69.jpg)'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_69.jpg)'
- en: 'Figure 8.69: Listing the actions'
  id: totrans-584
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.69：列出操作
- en: 'The `wsk package get` command will return JSON output that describes the package:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`wsk package get`命令将返回描述包的JSON输出：'
- en: '[PRE89]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The output should be as follows:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.70: Getting a detailed description of the arithmetic package'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.70：获取算术包的详细描述'
- en: '](image/C12607_08_70.jpg)'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_70.jpg)'
- en: 'Figure 8.70: Getting a detailed description of the arithmetic package'
  id: totrans-590
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.70：获取算术包的详细描述
- en: 'We can use the `--summary` flag if we want to see a summary of the package
    description, which lists the actions within the package:'
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要查看包描述的摘要，列出包内的操作，我们可以使用`--summary`标志：
- en: '[PRE90]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The output should be as follows:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.71: Getting the summary description of the arithmetic package'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.71：获取算术包的摘要描述'
- en: '](image/C12607_08_71.jpg)'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_08_71.jpg)'
- en: 'Figure 8.71: Getting the summary description of the arithmetic package'
  id: totrans-596
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.71：获取算术包的摘要描述
- en: 'Activity 8: Receive Daily Weather Updates via Email'
  id: totrans-597
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动8：通过电子邮件接收每日天气更新
- en: Imagine that you are working for a disaster management center and need to be
    updated with weather information. You have decided to create an application that
    can send you weather updates via email at specified intervals. To achieve this,
    you have decided to deploy an application that can retrieve the current weather
    in a specific city and send a daily email at 8.00 AM with the current weather
    information to a specified email address. In this activity, we will be using external
    services to retrieve weather information (**OpenWeather**) and send emails (**SendGrid**).
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在为灾害管理中心工作，需要及时了解天气信息。你决定创建一个应用程序，可以在指定的时间间隔通过电子邮件向你发送天气更新。为了实现这一目标，你决定部署一个应用程序，可以获取特定城市的当前天气，并在每天上午8点向指定的电子邮件地址发送当前天气信息。在这个活动中，我们将使用外部服务来检索天气信息（OpenWeather）并发送电子邮件（SendGrid）。
- en: 'We need to have the following before we start this activity:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这个活动之前，我们需要准备以下内容：
- en: An **OpenWeather** account (to retrieve current weather information)
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个OpenWeather账户（用于检索当前天气信息）
- en: A **SendGrid** account (to send emails)
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个SendGrid账户（用于发送电子邮件）
- en: '`npm` installed'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm`已安装'
- en: '`zip` installed'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip`已安装'
- en: 'Execute the following steps to create an **OpenWeather** account and a SendGrid
    account:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来创建一个OpenWeather账户和一个SendGrid账户：
- en: Create an **OpenWeather** ([https://openweathermap.org/](https://openweathermap.org/))
    account to retrieve current weather information and save the API key. Create an
    **OpenWeather** account at [https://home.openweathermap.org/users/sign_up](https://home.openweathermap.org/users/sign_up).
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**OpenWeather**（[https://openweathermap.org/](https://openweathermap.org/)）账户以检索当前天气信息并保存API密钥。在[https://home.openweathermap.org/users/sign_up](https://home.openweathermap.org/users/sign_up)创建一个**OpenWeather**账户。
- en: Go to the **API keys** tab ([https://home.openweathermap.org/api_keys](https://home.openweathermap.org/api_keys))
    and save the API key as this API key is required to fetch the data from the OpenWeather
    API.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 转到**API密钥**选项卡（[https://home.openweathermap.org/api_keys](https://home.openweathermap.org/api_keys)）并保存API密钥，因为这个API密钥是从OpenWeather
    API获取数据所必需的。
- en: Test the OpenWeather API using `https://api.openweathermap.org/data/2.5/weather?q=London&appid=<YOUR-API-KEY>`
    in a web browser. Please note that you need to replace **<YOUR-API-KEY>** with
    your API key from *step 1*.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web浏览器中使用`https://api.openweathermap.org/data/2.5/weather?q=London&appid=<YOUR-API-KEY>`来测试OpenWeather
    API。请注意，您需要用*步骤1*中的API密钥替换**<YOUR-API-KEY>**。
- en: Create a SendGrid ([https://sendgrid.com](https://sendgrid.com)) account and
    save the API key. This is used to send emails. Create a SendGrid account at [https://signup.sendgrid.com/](https://signup.sendgrid.com/).
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个SendGrid（[https://sendgrid.com](https://sendgrid.com)）账户并保存API密钥。这用于发送电子邮件。在[https://signup.sendgrid.com/](https://signup.sendgrid.com/)创建一个SendGrid账户。
- en: Go to **Settings > API Keys** and click on the **Create API Key** button.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 转到**设置 > API密钥**，然后单击**创建API密钥**按钮。
- en: Provide a name in the **API Key Name** field, select the **Full Access** radio
    button, and click on the **Create & View** button to create an API key with full
    access.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在**API密钥名称**字段中提供一个名称，选择**完全访问**单选按钮，然后单击**创建和查看**按钮以创建具有完全访问权限的API密钥。
- en: Once the key is generated, copy the API key and save it somewhere safe as you
    will see this key only once.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 生成密钥后，复制API密钥并将其保存在安全的地方，因为您只能看到这个密钥一次。
- en: Note
  id: totrans-612
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Detailed steps on creating an **OpenWeather** account and a SendGrid account
    are available in the *Appendix* section on page 432.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 有关创建**OpenWeather**账户和SendGrid账户的详细步骤，请参阅第432页的*附录*部分。
- en: 'Now we are ready to start the activity. Execute the following steps to complete
    this activity:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备开始这项活动。执行以下步骤以完成这项活动：
- en: Create a function in any language that you are familiar with (and supported
    by the OpenWhisk framework) that will take the city name as a parameter and return
    a JSON object with weather information retrieved from the OpenWeather API.
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您熟悉的任何语言中创建一个函数（并且受OpenWhisk框架支持），该函数将以城市名称作为参数，并从OpenWeather API中检索的天气信息返回一个JSON对象。
- en: Note
  id: totrans-616
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For this solution, we will be using functions written in JavaScript. However,
    you can use any language that you are familiar with to write the functions.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个解决方案，我们将使用JavaScript编写的函数。但是，您可以使用任何您熟悉的语言来编写这些函数。
- en: 'Here is an example function written in JavaScript:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个用JavaScript编写的示例函数：
- en: '[PRE91]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Create a second function (in any language that you are familiar with and is
    supported by the OpenWhisk framework) that will take a message as input and send
    the input message to a specified email address using the SendGrid service.
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个函数（在您熟悉的任何语言中，并且受OpenWhisk框架支持），该函数将以消息作为输入，并使用SendGrid服务将输入消息发送到指定的电子邮件地址。
- en: 'Here is an example function written in JavaScript:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个用JavaScript编写的示例函数：
- en: '[PRE92]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Create a third function (in any language that you are familiar with and is supported
    by the OpenWhisk framework) that will take the JSON object with the weather data
    and format it as a string message to be sent as the email body.
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第三个函数（在您熟悉的任何语言中，并且受OpenWhisk框架支持），该函数将以天气数据的JSON对象，并将其格式化为字符串消息，以便作为电子邮件正文发送。
- en: 'Here is an example function written in JavaScript:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个用JavaScript编写的示例函数：
- en: '[PRE93]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Next, create a sequence connecting all three actions.
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个连接所有三个动作的序列。
- en: Finally, create the trigger and rule to invoke the sequence daily at 8.00 AM.
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建触发器和规则，在每天上午8点调用序列。
- en: Note
  id: totrans-628
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to the activity can be found on page 432.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 活动的解决方案可以在第432页找到。
- en: Summary
  id: totrans-630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first learned about the history and the core concepts of
    Apache OpenWhisk. Then, we learned how to set up IBM Cloud Functions with CLI
    to run our serverless functions. After that, OpenWhisk actions were introduced,
    which are the code snippets written in one of the languages supported by OpenWhisk.
    We discussed how to write, create, list, invoke, update, and delete OpenWhisk
    actions using the `wsk` CLI. Next, we went over OpenWhisk sequences, which are
    used to combine multiple actions together to create a more complex processing
    pipeline. Going forward, we learned how to expose actions publicly using a URL
    with web actions. We discussed how web actions allow us to return additional information
    from the action, such as HTTP headers and non-JSON payloads, including HTML and
    binary data. The next section was on feeds, triggers, and rules that automate
    action invocation using events from external event sources. Finally, OpenWhisk
    packages were discussed, which are used to organize related actions by bundling
    them together.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先了解了Apache OpenWhisk的历史和核心概念。然后，我们学习了如何使用CLI设置IBM Cloud Functions来运行我们的无服务器函数。之后，介绍了OpenWhisk动作，这些是用OpenWhisk支持的语言之一编写的代码片段。我们讨论了如何使用`wsk`
    CLI编写、创建、列出、调用、更新和删除OpenWhisk动作。接下来，我们介绍了OpenWhisk序列，用于将多个动作组合在一起，创建更复杂的处理流水线。接下来，我们学习了如何使用Web动作公开动作，通过URL返回动作的附加信息，如HTTP标头和非JSON有效载荷，包括HTML和二进制数据。下一部分是关于饲料、触发器和规则，它们使用来自外部事件源的事件自动化动作调用。最后，我们讨论了OpenWhisk包，它们用于通过捆绑它们来组织相关动作。
- en: In the next and final chapter, we shall learn about OpenFaaS and work with an
    OpenFaaS function.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于OpenFaaS，并使用OpenFaaS函数。
