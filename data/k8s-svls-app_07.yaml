- en: Apache OpenWhisk and Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache OpenWhisk和Kubernetes
- en: In this chapter, we are going to look at Apache OpenWhisk. While not strictly
    a Kubernetes-only project, like, say, Kubeless and Fission (which are covered
    in the next chapter), it can be deployed on, and take advantage of, Kubernetes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看Apache OpenWhisk。虽然不严格是一个仅限于Kubernetes的项目，比如Kubeless和Fission（这些将在下一章中介绍），但它可以部署并利用Kubernetes。
- en: 'We are going to be looking at three main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看三个主要主题：
- en: An overview of Apache OpenWhisk
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache OpenWhisk概述
- en: Running Apache OpenWhisk locally using Vagrant
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vagrant在本地运行Apache OpenWhisk
- en: Running Apache OpenWhisk on Kubernetes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes上运行Apache OpenWhisk
- en: Let's start by finding out more about OpenWhisk.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解更多关于OpenWhisk。
- en: Apache OpenWhisk overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache OpenWhisk概述
- en: Apache OpenWhisk is an open source, serverless cloud computing platform, designed
    to work in a similar way to all the tools we have been covering in other chapters
    of this book. Apache OpenWhisk started off life as, and continues to be, Functions
    as a Service part of IBM's public cloud offering, Bluemix.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Apache OpenWhisk是一个开源的无服务器云计算平台，旨在以与本书其他章节中涵盖的所有工具类似的方式工作。Apache OpenWhisk最初是IBM公共云服务Bluemix的Functions
    as a Service部分，现在仍然是。
- en: 'It had its general availability release in December 2016\. The press release
    that accompanied the announcement had a quote from Luis Enriquez who is the Head
    of Platform Engineering and Architecture at Santander Group, one of the customers
    who had been using IBM Cloud Functions while it was in closed beta, Luis said:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 它在2016年12月发布了普遍可用版本。随着宣布的新闻稿中有一句来自Santander集团平台工程和架构负责人Luis Enriquez的引用，他是IBM
    Cloud Functions的一位客户，Luis说：
- en: “Microservices and containers are changing the way we build apps, but because
    of serverless, we can take that transformation even further, OpenWhisk provides
    the instant infrastructure we need for intense tasks and unexpected peaks in workload,
    and is a key building block as we move to a real-time and event-driven architecture.”
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: “微服务和容器正在改变我们构建应用程序的方式，但由于无服务器，我们可以进一步推动这种转变，OpenWhisk为我们提供了处理强烈任务和工作负载意外高峰的即时基础设施，并且是我们转向实时和事件驱动架构的关键构建块。”
- en: As you may have noticed, this sounds a lot like Lambda from AWS and Microsoft
    Azure Functions—what sets IBM's service apart from its competitors is that IBM
    has submitted OpenWhisk to the Apache Incubator, this is the entry point for all
    externally developed projects to become part of The Apache Software Foundation
    efforts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这听起来很像AWS和Microsoft Azure Functions的Lambda——IBM的服务与竞争对手的区别在于IBM已经将OpenWhisk提交给了Apache孵化器，这是所有外部开发项目成为Apache软件基金会努力的一部分的入口。
- en: The Apache Software Foundation was founded in 1999 as a charitable organization
    that oversees the development and management of well over 350 open source software
    projects, which it does for the public good.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Apache软件基金会成立于1999年，是一个慈善组织，负责监督和管理超过350个开源软件项目的开发和管理，这是为了公共利益。
- en: So why would IBM do this? Well, not only is IBM a gold sponsor of The Apache
    Software Foundation, it makes sense for them to open-source their Functions as
    a Service offering as it makes it the only public cloud offering where you can
    avoid vendor lock-in, as you can run Apache OpenWhisk locally or on your own hardware
    or virtual machines.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么IBM要这样做呢？嗯，IBM不仅是Apache软件基金会的金牌赞助商，将其Functions as a Service提供开源化对他们来说是有意义的，因为它是唯一一个可以避免供应商锁定的公共云提供商，因为你可以在本地或自己的硬件或虚拟机上运行Apache
    OpenWhisk。
- en: This gives you the freedom to run and deploy Apache OpenWhisk anywhere you like.
    However, if you would like to run it to scale like the Santander Group is, then
    you have the option of running it on an enterprise-class public cloud supported
    by IBM.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这使您可以自由地在任何地方运行和部署Apache OpenWhisk。但是，如果您想像Santander集团一样进行规模化运行，那么您可以选择在IBM支持的企业级公共云上运行它。
- en: Running Apache OpenWhisk locally
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地运行Apache OpenWhisk
- en: We are going to be looking at running Apache OpenWhisk locally first. We will
    do this by using a combination of VirtualBox, which we installed in [Chapter 3](7836cfd9-bce3-4d77-9331-f8dda5a31999.xhtml),
    *Installing Kubernetes Locally*, and Vagrant.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将研究在本地运行Apache OpenWhisk。我们将通过使用VirtualBox和Vagrant来实现这一点。
- en: Installing Vagrant
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Vagrant
- en: Before we launch our local Apache OpenWhisk server we need to install Vagrant,
    which is developed by HashiCorp. The best way I can describe Vagrant is as an
    open source, virtual machine manager, where your machine configuration is written
    using an easy-to-follow text configuration file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动本地Apache OpenWhisk服务器之前，我们需要安装由HashiCorp开发的Vagrant。我能描述Vagrant的最好方式是作为一个开源的虚拟机管理器，您可以使用易于遵循的文本配置文件编写机器配置。
- en: 'Installing Vagrant is quite simple. On macOS 10.13 High Sierra we can use Homebrew
    and Cask:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Vagrant非常简单。在macOS 10.13 High Sierra上，我们可以使用Homebrew和Cask：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you are running Windows 10 Professional you can use Chocolatey and run the
    following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行Windows 10专业版，您可以使用Chocolatey并运行以下命令：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, if you are running Ubuntu 17.04 you can install Vagrant directly from
    the core Ubuntu repositories by running:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您正在运行Ubuntu 17.04，您可以通过运行以下命令直接从Ubuntu核心存储库安装Vagrant：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Please note, the version supplied by Ubuntu may be a little behind the versions
    installed using Homebrew and Chocolatey; however for our purposes, this should
    not present any problems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Ubuntu提供的版本可能会比使用Homebrew和Chocolatey安装的版本稍微滞后；但是对于我们的目的，这不应该造成任何问题。
- en: 'You can test your Vagrant installation by running the following commands:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令测试Vagrant安装：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These commands will create a basic Vagrantfile in the `vagrant-test` folder,
    which uses the official 64-bit Ubuntu 16.04 LTS (Xenial) image from the Vagrant
    website ([https://app.vagrantup.com/ubuntu/boxes/xenial64/](https://app.vagrantup.com/ubuntu/boxes/xenial64/)),
    downloads the image, launches a virtual machine using VirtualBox, configures networking,
    and exchanges keys with the server before finally mounting the current folder
    within the virtual machine at `/vagrant`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将在`vagrant-test`文件夹中创建一个基本的Vagrantfile，该文件夹使用来自Vagrant网站（[https://app.vagrantup.com/ubuntu/boxes/xenial64/](https://app.vagrantup.com/ubuntu/boxes/xenial64/)）的官方64位Ubuntu
    16.04 LTS（Xenial）镜像，下载该镜像，使用VirtualBox启动虚拟机，配置网络，并在最终将当前文件夹挂载到虚拟机的`/vagrant`：
- en: '![](assets/706d484d-29b9-4a27-821a-34156e2e7a80.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/706d484d-29b9-4a27-821a-34156e2e7a80.png)
- en: 'All of this is defined using the following configuration:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是使用以下配置定义的：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you open the Vagrantfile you will notice that there are quite a few configuration
    options, such as the RAM and CPU allocations, networking, and scripts, which are
    executed once the virtual machine has successfully launched. You can run the following
    command to SSH into your Vagrant virtual machine:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开Vagrantfile，您会注意到有很多配置选项，比如RAM和CPU分配，网络和脚本，这些脚本在虚拟机成功启动后执行。您可以运行以下命令以SSH连接到Vagrant虚拟机：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you are running Windows 10 Professional you are going to have to install
    an SSH client. Vagrant will give you some options on how to do this when you execute
    the preceding command.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行Windows 10专业版，则需要安装SSH客户端。当您执行上述命令时，Vagrant将为您提供一些选项。
- en: 'Running the following command will power down your virtual machine and remove
    it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令将关闭您的虚拟机并将其删除：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](assets/2ec7c6d5-556c-4acb-a9c1-ff59c3b362c6.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2ec7c6d5-556c-4acb-a9c1-ff59c3b362c6.png)'
- en: 'I would also recommend clearing your working folder by running:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我还建议通过运行清除您的工作文件夹：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have Vagrant installed, and have quickly looked at how we can launch
    and interact with a virtual machine, we can now look at using it to launch our
    own local installation of Apache OpenWhisk.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了Vagrant，并且快速查看了如何启动和与虚拟机交互，我们现在可以使用它来启动我们自己的本地安装Apache OpenWhisk。
- en: Downloading and configuring Apache OpenWhisk
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载和配置Apache OpenWhisk
- en: 'As we have already mentioned, Apache OpenWhisk ships with a Vagrantfile that
    contains all of the commands to deploy a local Apache OpenWhisk installation from
    scratch. To download the Apache OpenWhisk repository and deploy the virtual machine,
    run the following commands:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，Apache OpenWhisk附带一个Vagrantfile，其中包含从头开始部署本地Apache OpenWhisk安装的所有命令。要下载Apache
    OpenWhisk存储库并部署虚拟机，请运行以下命令：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This process will take anywhere up to 30 minutes depending on the speed of
    your internet connectivity; you can find a copy of the Vagrantfile at the following
    URL: [https://github.com/apache/incubator-openwhisk/blob/master/tools/vagrant/Vagrantfile](https://github.com/apache/incubator-openwhisk/blob/master/tools/vagrant/Vagrantfile).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程将花费最多30分钟，具体取决于您的互联网连接速度；您可以在以下URL找到Vagrantfile的副本：[https://github.com/apache/incubator-openwhisk/blob/master/tools/vagrant/Vagrantfile](https://github.com/apache/incubator-openwhisk/blob/master/tools/vagrant/Vagrantfile)。
- en: As you can see, it is just short of 200 lines long, which is a lot different
    from the three lines in our test Vagrantfile from the last section. The Vagrantfile
    uses a combination of bash scripts and Ansible to launch, install, and configure
    our Apache OpenWhisk virtual machine.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它只有将近200行，这与上一节中我们测试Vagrantfile的三行有很大不同。Vagrantfile使用bash脚本和Ansible的组合来启动、安装和配置我们的Apache
    OpenWhisk虚拟机。
- en: Ansible is is an orchestration/configuration tool from Red Hat. It allows you
    to easily define your deployments in human-readable code, be it interacting with
    APIs to launch your infrastructure or logging in to servers and executing tasks
    against them to install and configure your software stack.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是来自Red Hat的编排/配置工具。它允许您轻松地用人类可读的代码定义部署，无论是与API交互以启动基础设施，还是登录到服务器并执行任务来安装和配置软件堆栈。
- en: 'At the end of the process, it will execute a basic hello world check as seen
    in the following console output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程结束时，它将执行一个基本的hello world检查，如下控制台输出所示：
- en: '![](assets/4ea18a54-5a0d-417d-8a2b-b5a55316388b.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4ea18a54-5a0d-417d-8a2b-b5a55316388b.png)'
- en: Before we move on, make a note of the output, which starts with the `wsk property
    set` command. We will need this to configure the local client, which we are going
    to look at installing next.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，请注意以`wsk property set`命令开头的输出。我们将需要这个来配置本地客户端，接下来我们将看到如何安装。
- en: Installing the Apache OpenWhisk client
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Apache OpenWhisk客户端
- en: 'Each Apache OpenWhisk comes with a download page for the macOS, Windows, and
    Linux versions of the Apache OpenWhisk client. You can access this from your local
    installation at the following URL: [https://192.168.33.13/cli/go/download/](https://192.168.33.13/cli/go/download/)
    or IBM at: [https://openwhisk.ng.bluemix.net/cli/go/download/](https://openwhisk.ng.bluemix.net/cli/go/download/).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Apache OpenWhisk都有一个用于macOS、Windows和Linux版本的Apache OpenWhisk客户端的下载页面。您可以从以下URL访问本地安装：[https://192.168.33.13/cli/go/download/](https://192.168.33.13/cli/go/download/)
    或IBM：[https://openwhisk.ng.bluemix.net/cli/go/download/](https://openwhisk.ng.bluemix.net/cli/go/download/)。
- en: As your local installation is using a self-signed SSL certificate, you may receive
    warnings when opening it in your browser. You will need to accept these warnings
    to proceed to the site. This process varies depending on your browser so you will
    need to follow the on-screen prompts to progress.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的本地安装使用自签名SSL证书，当在浏览器中打开时，您可能会收到警告。您需要接受这些警告才能继续访问该网站。此过程因浏览器而异，因此您需要按照屏幕上的提示进行操作。
- en: 'To install the client on macOS 10.13 High Sierra we simply need to run the
    following commands:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要在macOS 10.13 High Sierra上安装客户端，我们只需要运行以下命令：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will download the binary using `curl` and ignore the self-signed certificate.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用`curl`下载二进制文件并忽略自签名证书。
- en: 'To download on Windows 10 Professional, run the following. I would recommend
    downloading from IBM to avoid problems with the self-signed SSL certificate and
    PowerShell. To do this, first of all open a PowerShell window as an admin user.
    You can do this by selecting Run as Administrator from the PowerShell menu in
    the taskbar. Once open, you should see that you are in the `C:\WINDOWS\system32`
    folder; if you aren''t then run the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Windows 10专业版上下载，请运行以下命令。我建议从IBM下载，以避免自签名SSL证书和PowerShell的问题。为此，首先以管理员用户身份打开PowerShell窗口。您可以通过从任务栏中的PowerShell菜单中选择以管理员身份运行来执行此操作。打开后，您应该看到您在`C:\WINDOWS\system32`文件夹中；如果不是，则运行以下命令：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Like the macOS version, you can check that the client is installed by running
    the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与macOS版本一样，您可以通过运行以下命令来检查客户端是否已安装：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, on Ubuntu 17.04 you need to run the following commands:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在Ubuntu 17.04上，您需要运行以下命令：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once downloaded and made executable you should be able to run:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦下载并设置为可执行，您应该能够运行：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we have the client installed we need to authenticate against our installation.
    To do this, run the command you made a note of at the end of the last section,
    minus the `--namespace guest` part. For me, this command was as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了客户端，我们需要对我们的安装进行身份验证。为此，请运行您在上一节末尾做的笔记中的命令，减去`--namespace guest`部分。对我来说，这个命令是这样的：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you didn''t make a note, then you can dynamically pass the authorization
    token by running the following command from the folder you launch the Vagrant
    virtual machine from, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有做笔记，那么您可以通过从启动Vagrant虚拟机的文件夹运行以下命令来动态传递授权令牌，如下所示：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you don''t run it from the folder you launched the machine from, the `vagrant
    ssh` command will fail, as it will not be able to find your machine configuration.
    Now that your local client is authenticated against your local installation of
    Apache OpenWhisk, we can execute the same hello world command that was run by
    the automation installation by running the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不是从启动机器的文件夹运行`vagrant ssh`命令，该命令将失败，因为它将无法找到您的机器配置。现在，您的本地客户端已对本地安装的Apache
    OpenWhisk进行了身份验证，我们可以通过运行以下命令执行与自动安装相同的hello world命令：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This should return the message `hello` as per the following Terminal output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回以下终端输出的消息“hello”：
- en: '![](assets/0a257e48-106c-4f26-9d5f-5e4a2dc1d523.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0a257e48-106c-4f26-9d5f-5e4a2dc1d523.png)'
- en: Now that we have our local client, we can look at downloading and executing
    another example.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了本地客户端，我们可以尝试下载和执行另一个示例。
- en: Hello world
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好世界
- en: We can now deploy a more complex solution rather than just using the inbuilt
    `echo` utility to return a message. In a similar way to the previous hello world
    scripts we used, we are going to deploy a function, written in Node.js, that takes
    an input and displays it back to us.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以部署一个更复杂的解决方案，而不仅仅是使用内置的`echo`实用程序返回消息。与我们之前使用的hello world脚本类似，我们将部署一个使用Node.js编写的函数，该函数接受输入并将其显示回给我们。
- en: 'First of all, let''s create a working directory:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个工作目录：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we have a working directory, create a file that contains the following
    code and call it `hello.js`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个工作目录，创建一个包含以下代码的文件，并将其命名为`hello.js`：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have the function that we are going to deploy, we first of all
    need to create a package, and then create the action that is exposed to the web:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了要部署的函数，首先我们需要创建一个包，然后创建一个暴露给Web的操作：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have created the package and action, your Terminal should look
    something like the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了包和操作，您的终端应该看起来像以下内容：
- en: '![](assets/a8650b61-bd51-42d4-b5b3-d28e9c717fbd.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a8650b61-bd51-42d4-b5b3-d28e9c717fbd.png)'
- en: 'This means that your function can be called using your browser at the following
    URL:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可以使用浏览器在以下URL调用您的函数：
- en: '[https://192.168.33.13/api/v1/web/guest/demo/hello.http?name=Kubernetes%20for%20Serverless%20Applications](https://192.168.33.13/api/v1/web/guest/demo/hello.http?name=Kubernetes%20for%20Serverless%20Applications)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://192.168.33.13/api/v1/web/guest/demo/hello.http?name=Kubernetes%20for%20Serverless%20Applications](https://192.168.33.13/api/v1/web/guest/demo/hello.http?name=Kubernetes%20for%20Serverless%20Applications)'
- en: 'You should see the following page:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下页面：
- en: '![](assets/ef84888e-ce81-46cd-8bf5-cb91efbfe399.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ef84888e-ce81-46cd-8bf5-cb91efbfe399.png)'
- en: 'You can see more information using HTTPie on macOS or Ubuntu by running the
    following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在macOS或Ubuntu上使用HTTPie来查看更多信息，方法是运行以下命令：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will return the headers and also the output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回标头和输出：
- en: '![](assets/950b8f7d-cf0d-44fd-8d66-e9151b0d01dc.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/950b8f7d-cf0d-44fd-8d66-e9151b0d01dc.png)'
- en: 'You can list packages and actions, and remove them by running the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令列出软件包和操作，并删除它们：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](assets/186756db-fc2d-4231-a590-d8e4b7de57a5.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/186756db-fc2d-4231-a590-d8e4b7de57a5.png)'
- en: 'Feel free to have a play with your local installation of Apache OpenWhisk;
    there are more examples at the Awesome OpenWhisk page, which you can find at:
    [https://github.com/apache/incubator-openwhisk-external-resources/](https://github.com/apache/incubator-openwhisk-external-resources/).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 随意在本地安装Apache OpenWhisk上玩耍；您可以在Awesome OpenWhisk页面找到更多示例，网址为：[https://github.com/apache/incubator-openwhisk-external-resources/](https://github.com/apache/incubator-openwhisk-external-resources/)。
- en: 'Once you have finished with your local installation, you can run the following
    command to stop and destroy the virtual machine:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本地安装后，您可以运行以下命令来停止和销毁虚拟机：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Remember, you must be in the `openwhisk/tools/vagrant/` folder to run this command
    otherwise Vagrant will not be able to find your virtual machine configuration.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您必须在`openwhisk/tools/vagrant/`文件夹中运行此命令，否则Vagrant将无法找到您的虚拟机配置。
- en: Now that we have installed and interacted with Apache OpenWhisk locally, let's
    look at deploying it on Kubernetes in a public cloud.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地安装并与Apache OpenWhisk进行了交互，让我们看看如何在公共云中的Kubernetes上部署它。
- en: Running Apache OpenWhisk on Kubernetes
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes上运行Apache OpenWhisk
- en: 'Now that we have an idea of how to interact with Apache OpenWhisk and the basic
    concepts behind it, we can look at deploying a copy on top of a Kubernetes cluster.
    To do this, I am going to launch a three-node cluster in Google Cloud by running
    the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何与Apache OpenWhisk进行交互以及其基本概念，我们可以考虑在Kubernetes集群之上部署一个副本。为此，我将通过运行以下命令在Google
    Cloud中启动一个三节点集群：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the cluster is up-and-running, you can check that you can see three nodes
    by running the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦集群运行起来，您可以通过运行以下命令来检查是否可以看到三个节点：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](assets/75a05a0d-c6bb-492a-a686-963bb127ca3d.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/75a05a0d-c6bb-492a-a686-963bb127ca3d.png)'
- en: Now we have our Kubernetes, we can progress with the Apache OpenWhisk deployment.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的Kubernetes，我们可以继续进行Apache OpenWhisk的部署。
- en: Deploying OpenWhisk
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署OpenWhisk
- en: 'All of the configuration needed to deploy Apache OpenWhisk on Kubernetes is
    available on GitHub, so before we start our deployment we should clone the repository
    by running the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始部署之前，所有在Kubernetes上部署Apache OpenWhisk所需的配置都可以在GitHub上找到，因此我们应该通过运行以下命令克隆存储库。
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have a copy of the repository, we can make a start on deploying
    the individual components needed to run Apache OpenWhisk. To start with, we need
    to create a namespace called `openwhisk`. To do this, run the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了存储库的副本，我们可以开始部署运行Apache OpenWhisk所需的各个组件。首先，我们需要创建一个名为`openwhisk`的命名空间。要做到这一点，请运行以下命令：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now we can start our deployment by launching CouchDB.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过启动CouchDB来开始我们的部署。
- en: CouchDB
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CouchDB
- en: 'To deploy CouchDB, run the following command from within the `openwhisk-kube`
    folder:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署CouchDB，请从`openwhisk-kube`文件夹内运行以下命令：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will launch a pod running CouchDB using the parameters defined in the
    `couchdb.yml` file. You can check that everything is OK with the deployment by
    getting the name of the pod. You can do this by running the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个使用`couchdb.yml`文件中定义的参数运行CouchDB的pod。您可以通过获取pod的名称来检查部署是否正常。您可以通过运行以下命令来执行此操作：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once you have the name, which for me was `couchdb-1146267775-v0sdm`, you can
    then run the following, making sure to update the name of the pod with your own:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得了名称，对我来说是`couchdb-1146267775-v0sdm`，然后您可以运行以下命令，确保更新pod的名称为您自己的：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Towards the end of the log output you should see the following message:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志输出的最后，您应该看到以下消息：
- en: '![](assets/ed49833e-2e94-4ae7-929c-872715c616ee.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/ed49833e-2e94-4ae7-929c-872715c616ee.png)
- en: Now that our CouchDB pod is running we can move on to the next one, which is
    Redis.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的CouchDB pod正在运行，我们可以继续下一个，即Redis。
- en: Redis
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redis
- en: 'To launch the Redis pod, we just need to run the following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动Redis pod，我们只需要运行以下命令：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: API Gateway
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API网关
- en: 'Next up we have the API Gateway; this is launched by running the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们有API网关；通过运行以下命令来启动它：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ZooKeeper
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ZooKeeper
- en: 'Now we can launch Apache ZooKeeper using the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下命令启动Apache ZooKeeper：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Kafka
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卡夫卡
- en: 'Now it is time to launch another Apache project, Kafka:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候启动另一个Apache项目，Kafka了：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At this point we should double-check that all of the pods we have launched
    are running. To do this, run the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们应该仔细检查我们启动的所有pod是否正在运行。要做到这一点，请运行以下命令：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should see pods for `couchdb`, `redis`, `apigateway`, `zookeeper`, and
    `kafka`, all running with no restarts logged and `1/1` in the `READY` column:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到`couchdb`，`redis`，`apigateway`，`zookeeper`和`kafka`的pod，所有这些pod都在没有记录重启并且`READY`列中为`1/1`运行：
- en: '![](assets/7fabbba6-2215-4fe1-b633-5967d8fdcc12.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/7fabbba6-2215-4fe1-b633-5967d8fdcc12.png)
- en: Controller
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: 'Next, we have the controller. This is slightly different from the other pods
    we have deployed, in that it is being deployed in a stateful state:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是控制器。这与我们部署的其他pod略有不同，因为它是以有状态的方式部署的：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You should see that a StatefulSet has been created rather than a deployment.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到已创建了一个StatefulSet而不是一个部署。
- en: Invoker
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用者
- en: Again, the next pod we are deploying is going to be a StatefulSet rather than
    a deployment. Before we deploy the pod we need to make a slight change to the
    `kubernetes/invoker/invoker.yml` file. This is because, by default, OpenWhisk
    assumes you are running Ubuntu as your base operating system, which Google Cloud
    isn't.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 再次部署的下一个pod将是一个StatefulSet而不是一个部署。在部署pod之前，我们需要对`kubernetes/invoker/invoker.yml`文件进行轻微更改。这是因为，默认情况下，OpenWhisk假定您正在运行Ubuntu作为基本操作系统，而Google
    Cloud不是。
- en: 'To do this, open `kubernetes/invoker/invoker.yml` in your text editor of choice
    and remove the following block of code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请在您选择的文本编辑器中打开`kubernetes/invoker/invoker.yml`并删除以下代码块：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'There is also another reference to `apparmor` we need to remove. This time
    it is towards the bottom of the file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个关于`apparmor`的参考资料需要删除。这次是在文件底部：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once the two code blocks that reference `apparmor` have been removed, you can
    deploy the `invoker` by running the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦删除了引用`apparmor`的两个代码块，您可以通过运行以下命令部署`invoker`：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It may take a few minutes to deploy.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 部署可能需要几分钟时间。
- en: NGINX
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NGINX
- en: 'The final part of the deployment is the NGINX container. We need to do a little
    more work on this one as we need to generate certificates for our cluster. To
    generate the certificates, we will need to use OpenSSL. This is not installed
    by default on Windows machines so you can use the following command to install
    OpenSSL using Chocolatey:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 部署的最后一部分是NGINX容器。对于这个容器，我们需要做更多的工作，因为我们需要为我们的集群生成证书。为了生成证书，我们需要使用OpenSSL。这在Windows机器上默认情况下不安装，因此您可以使用以下命令使用Chocolatey安装OpenSSL：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once you have OpenSSL installed, you can generate the certificates by running:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了OpenSSL，您可以通过运行以下命令生成证书：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once we have the certificates, we need to create a `configmap` using the `nginx.conf`
    file in `kubernetes/nginx`. To do this, run the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了证书，我们需要使用`kubernetes/nginx`中的`nginx.conf`文件创建一个`configmap`。为此，请运行以下命令：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we need to upload the certificate and key we generated as a `secret`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要上传生成的证书和密钥作为`secret`：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once they have been uploaded, we can launch the NGINX pod by running the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它们被上传，我们可以通过运行以下命令启动NGINX pod：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![](assets/96c0b0fe-1916-4676-b3e6-50bd5caa9f7f.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/96c0b0fe-1916-4676-b3e6-50bd5caa9f7f.png)'
- en: 'Now that we have all of the pods deployed, you should double-check that they
    are all running using the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经部署了所有的pod，您应该使用以下命令再次检查它们是否都在运行：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![](assets/b3e76e58-0976-400e-8282-d164eb3adf24.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b3e76e58-0976-400e-8282-d164eb3adf24.png)'
- en: As you can see, everything is running. You can ignore any restarts just so long
    as the number is not increasing.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，一切都在运行。只要数量不增加，您可以忽略任何重启。
- en: Configuring OpenWhisk
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置OpenWhisk
- en: 'Now we have all of the pods deployed, we can start interacting with our deployment.
    To start with, we need to find out the external IP address of the NGINX pod. You
    can find information about the pod by running the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经部署了所有的pod，我们可以开始与我们的部署进行交互。首先，我们需要找出NGINX pod的外部IP地址。您可以通过运行以下命令找到有关pod的信息：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This is the output:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '![](assets/37646d9e-670d-443a-b63a-2b6fa13e9bb9.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/37646d9e-670d-443a-b63a-2b6fa13e9bb9.png)'
- en: 'As you can see, while the ports are exposed they are only exposed on the nodes
    themselves. As the nodes are on private addresses, we will not be able to access
    them from our local client. To expose the ports externally we need to create a
    load-balanced service, to do this run the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，虽然端口是暴露的，但它们只在节点本身上暴露。由于节点位于私有地址上，我们将无法从本地客户端访问它们。要在外部暴露端口，我们需要创建一个负载均衡服务，运行以下命令来执行此操作：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will launch a Load Balancer and expose the three ports: `80`, `443`, and
    `8443`. You can find out the details on the external IP address by running the
    following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个负载均衡器并暴露三个端口：`80`、`443`和`8443`。您可以通过运行以下命令找到外部IP地址的详细信息：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the output, you will find a line that says Load Balancer Ingress followed
    by an IP address:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，您会找到一行，上面写着Load Balancer Ingress，后面跟着一个IP地址：
- en: '![](assets/99c8f054-4ab7-4f0e-8799-31cf597501dc.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/99c8f054-4ab7-4f0e-8799-31cf597501dc.png)'
- en: As you can see from the example output shown previously, I have an IP address
    of `35.188.204.73`. This will be used as the API endpoint I interact with.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从先前显示的示例输出中看到的，我有一个IP地址`35.188.204.73`。这将被用作我与之交互的API端点。
- en: 'Now that we have the IP address of our installation, we can go ahead and configure
    the authentication token by running the following command, making sure you update
    the IP address with that of your own installation:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了安装的IP地址，我们可以继续通过运行以下命令来配置认证令牌，确保您使用自己安装的IP地址进行更新：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Once configured we can then run our hello-world test.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完成后，我们可以运行我们的hello-world测试。
- en: Hello world
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你好，世界
- en: 'This is exactly the same as the hello world in the previous section, so I won''t
    go into too much detail. Simply change to the folder where you have the `hello.js`
    file and run the following commands:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这与前一节中的hello world完全相同，所以我不会详细介绍。只需切换到您拥有`hello.js`文件的文件夹，并运行以下命令：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Once you have run the commands creating the package and action, you will be
    able to access the URL. For me, it was the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您运行了创建包和操作的命令，您将能够访问URL。对我来说，它是以下内容：
- en: '`https://35.188.204.73/api/v1/web/guest/demo/hello.http?name=Kubernetes%20for%20Serverless%20Applications`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://35.188.204.73/api/v1/web/guest/demo/hello.http?name=Kubernetes%20for%20Serverless%20Applications`'
- en: 'This showed the page we expected to see:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了我们期望看到的页面：
- en: '![](assets/de235e08-b560-4d22-b3b5-c7b02f0709ad.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/de235e08-b560-4d22-b3b5-c7b02f0709ad.png)'
- en: 'Again, we can see a little more by running HTTPie:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以通过运行HTTPie来看到更多：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This shows the following information:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了以下信息：
- en: '![](assets/ae2ac2d9-2bdc-4a7e-ae6e-4638c1193f3a.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ae2ac2d9-2bdc-4a7e-ae6e-4638c1193f3a.png)'
- en: As you can see, once you have deployed Apache OpenWhisk using the provided files,
    using it is a pretty consistent experience.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，一旦您使用提供的文件部署了Apache OpenWhisk，使用它是一个非常一致的体验。
- en: 'Before we finish this chapter we should remove our Kubernetes cluster. To do
    this run the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章之前，我们应该删除我们的Kubernetes集群。要做到这一点，请运行以下命令：
- en: '[PRE51]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Once deleted, be sure to check your Google Cloud control panel at [https://console.cloud.google.com/](https://console.cloud.google.com/)
    to make sure there are no leftover resources, which could be incurring unexpected
    costs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 删除后，请务必检查您的Google Cloud控制面板[https://console.cloud.google.com/](https://console.cloud.google.com/)，以确保没有剩余的资源，这可能会产生意外的成本。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have taken a slight diversion to look at Apache OpenWhisk.
    We have deployed a copy locally using a standard virtual machine and then we moved
    onto deploying it to a Kubernetes cluster running on Google Cloud.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们稍微偏离了目标，看了一下Apache OpenWhisk。我们使用标准虚拟机部署了一个本地副本，然后我们转向部署到在Google Cloud上运行的Kubernetes集群。
- en: As you saw, once the deployment was complete, interacting with Apache OpenWhisk
    was a consistent experience and we were able to deploy our simple hello-world
    application with no modifications to both of our installations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，一旦部署完成，与Apache OpenWhisk的交互是一致的体验，我们能够在两个安装中部署我们简单的hello-world应用程序，而无需进行任何修改。
- en: While Kubernetes support for Apache OpenWhisk is still in its infancy, our diversion
    has shown that it isn't just frameworks that have been designed with Kubernetes
    in mind, like the tools we have looked at in the previous chapters, which will
    run on top of a Kubernetes and provide a consistent experience without having
    to lock you into a single vendor or technology.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Kubernetes对Apache OpenWhisk的支持仍处于起步阶段，但我们的偏离表明，不仅是为Kubernetes设计的框架，就像我们在前几章中看到的工具一样，它们将在Kubernetes之上运行，并提供一致的体验，而无需将您锁定在单一供应商或技术中。
- en: 'In the next chapter, we are going to be looking at probably the most mature
    Kubernetes Function as a Service offering: Fission.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到可能是最成熟的Kubernetes函数作为服务提供：Fission。
