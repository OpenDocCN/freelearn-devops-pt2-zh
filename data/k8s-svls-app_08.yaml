- en: Launching Applications Using Fission
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Fission启动应用程序
- en: 'Next up we are going to look at Fission. Fission is a fast-growing, serverless
    framework for Kubernetes and, of the technologies that we have seen in previous
    chapters, is probably the most versatile. In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看一下Fission。Fission是一个快速增长的，基于Kubernetes的无服务器框架，而且在我们之前章节中看到的技术中，可能是最多才多艺的。在本章中，我们将涵盖：
- en: Who built Fission?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁构建了Fission？
- en: Installing the prerequisites
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装先决条件
- en: Installing, configuring, and running Fission locally
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地安装、配置和运行Fission
- en: Command overview
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令概述
- en: Installing, configuring, and running Fission in the cloud
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云中安装、配置和运行Fission
- en: Deploying a few example Fission applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署一些示例Fission应用程序
- en: By the end of this chapter, we will have worked on installing Fission in two
    different target environments, and also worked through launching several applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将在两个不同的目标环境中安装Fission，并且还将启动多个应用程序。
- en: Fission overview
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fission概述
- en: Fission is an open source serverless application developed by Platform9\. It
    was designed to run on top of Kubernetes as well as take advantage of some core
    Kubernetes functionality. Platform9 are a managed service provider whose core
    business is the deployment, management, and support of open source clouds specializing
    in OpenStack and Kubernetes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Fission是由Platform9开发的开源无服务器应用程序。它旨在在Kubernetes之上运行，并利用一些核心的Kubernetes功能。Platform9是一家托管服务提供商，其核心业务是部署、管理和支持专门从事OpenStack和Kubernetes的开源云。
- en: OpenStack is a collection of open source components that make up a fully functional
    Infrastructure as a Service offering. It provides compute, networking, block storage,
    object storage, orchestration, and even container service, to name but a few.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: OpenStack是一组开源组件，构成了一个完全功能的基础设施即服务产品。它提供计算、网络、块存储、对象存储、编排，甚至容器服务等功能。
- en: The project's goal is to provide support for a number of different hardware
    vendors, from vanilla x86 hardware to specialized storage solutions, allowing
    end users to build out their own AWS and Microsoft Azure style offering.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的目标是为多个不同的硬件供应商提供支持，从普通的x86硬件到专门的存储解决方案，使最终用户能够构建自己的AWS和Microsoft Azure风格的产品。
- en: With services such as AWS Lambda and Azure Functions maturing to the point where
    they are now commonplace in most enterprises, Platform9 saw an opportunity to
    provide their own Functions as a Service offering.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随着AWS Lambda和Azure Functions等服务成熟到现在几乎在大多数企业中都很普遍，Platform9看到了提供自己的函数即服务的机会。
- en: Being a company who specialize in complex open source solutions, it made sense
    for them to contribute their work back to the community, and so they released
    Fission under the Apache License.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一家专门从事复杂开源解决方案的公司，他们为他们向社区贡献自己的工作是有意义的，因此他们以Apache许可证发布了Fission。
- en: The Apache 2.0 License by The Apache Software Foundation allows developers to
    release their software for free, giving the end user permission to use that software
    for any purpose, and modify/redistribute it without the end user having to worry
    about royalties. To ensure that the License is not breached, the end user must
    preserve the original copyright notice and disclaimer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Apache软件基金会的Apache 2.0许可证允许开发人员免费发布他们的软件，允许最终用户以任何目的使用该软件，并在不必担心版税的情况下修改/重新分发它。为了确保许可证不被违反，最终用户必须保留原始的版权声明和免责声明。
- en: This may seem like a strange decision. However, like OpenWhisk, which we covered
    in the previous chapter, Platform9 have given their customers, and anyone else
    who wants to start deploying **Function as a Service** (**FaaS**), a solid foundation
    to build their applications on top of. Not only are they giving people the freedom
    to deploy their workloads wherever they want, they are also able to offer support
    services for installation and the Fission platform.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像一个奇怪的决定。然而，就像我们在上一章中介绍的OpenWhisk一样，Platform9为他们的客户以及任何想要开始部署**函数即服务**（**FaaS**）的人提供了一个坚实的基础来构建他们的应用程序。他们不仅给了人们在任何地方部署他们的工作负载的自由，还能够为安装和Fission平台提供支持服务。
- en: Installing the prerequisites
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装先决条件
- en: 'Before we install Fission either locally or in a public cloud we need a few
    supporting tools. The first tool we have already installed and that is the Kubernetes
    command-line interface, `kubectl`. The second tool needed to run Fission, we have
    not installed yet: Helm ([http://helm.sh/](http://helm.sh)).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们本地或公共云中安装Fission之前，我们需要一些支持工具。第一个工具我们已经安装了，那就是Kubernetes命令行接口`kubectl`。我们还没有安装运行Fission所需的第二个工具：Helm
    ([http://helm.sh/](http://helm.sh))。
- en: Installing Helm
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Helm
- en: Helm is a package manager for Kubernetes and is part of the Cloud Native Computing
    Foundation, where Bitnami, Google, Microsoft, and the Helm community all contribute
    to its development.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Helm是Kubernetes的一个包管理器，是Cloud Native Computing Foundation的一部分，Bitnami、Google、Microsoft和Helm社区都为其开发做出了贡献。
- en: 'To install Helm on macOS High Sierra we can use Homebrew; simply run:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要在macOS High Sierra上安装Helm，我们可以使用Homebrew；只需运行：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you are running Ubuntu Linux then you can download and install Helm using
    the installation script:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行Ubuntu Linux，则可以使用安装脚本下载并安装Helm：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Finally, Windows 10 Professional users can download an experimental build of
    Helm from the canary repository. The direct download link for this build is [https://kubernetes-helm.storage.googleapis.com/helm-canary-windows-amd64.zip](https://kubernetes-helm.storage.googleapis.com/helm-canary-windows-amd64.zip).
    As this is an experimental build, I recommend running it directly and not putting
    it in the system folder.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Windows 10专业版用户可以从canary存储库下载Helm的实验版本。该版本的直接下载链接为[https://kubernetes-helm.storage.googleapis.com/helm-canary-windows-amd64.zip](https://kubernetes-helm.storage.googleapis.com/helm-canary-windows-amd64.zip)。由于这是一个实验版本，我建议直接运行它，而不要将其放在系统文件夹中。
- en: The next step in installing Helm requires you to have a running Kubernetes cluster,
    as that is where it is launched. I will include the instructions for installing
    Tiller, the server component of Helm, later in the chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Helm的下一步需要您拥有一个运行中的Kubernetes集群，因为这是它的启动位置。我将在本章后面包括安装Helm的服务器组件Tiller的说明。
- en: Installing the Fission CLI
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Fission CLI
- en: 'The final command-line tool we need to install is the one for Fission itself.
    You can install this by running the following on macOS High Sierra:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要安装的最后一个命令行工具是Fission本身的工具。您可以通过在macOS High Sierra上运行以下命令来安装它：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For Ubuntu 17.04 you can run:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Ubuntu 17.04，您可以运行：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, the Windows executable can be downloaded from [https://github.com/fission/fission/releases/download/0.3.0/fission-cli-windows.exe](https://github.com/fission/fission/releases/download/0.3.0/fission-cli-windows.exe).
    I would recommend using it alongside the executable for Helm rather than installing
    it in your `System32` folder.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Windows可执行文件可以从[https://github.com/fission/fission/releases/download/0.3.0/fission-cli-windows.exe](https://github.com/fission/fission/releases/download/0.3.0/fission-cli-windows.exe)下载。我建议与Helm的可执行文件一起使用，而不是将其安装在`System32`文件夹中。
- en: 'Running the following commands should show you the currently installed versions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令应该显示当前安装的版本：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](assets/b4a654f6-8c00-4220-b565-f18d42b40e98.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b4a654f6-8c00-4220-b565-f18d42b40e98.png)'
- en: As already mentioned, we have not installed Tiller yet so we can safely ignore
    the error about not being able to connect to it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们还没有安装 Tiller，因此我们可以安全地忽略关于无法连接到它的错误。
- en: Running Fission locally
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地运行 Fission
- en: 'Now that we have the prerequisites installed we can look at creating our first
    function. To do this we are going to use Minikube. To launch the single node cluster
    we simply need to run the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了先决条件，我们可以开始创建我们的第一个函数。为此，我们将使用 Minikube。要启动单节点集群，我们只需要运行以下命令：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This should launch your Minikube cluster and also confirm that your local version
    has been reconfigured to communicate with it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该启动您的 Minikube 集群，并确认您的本地版本已重新配置以与其通信：
- en: '![](assets/14b2aeba-7121-49c2-a883-32651ffb3353.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/14b2aeba-7121-49c2-a883-32651ffb3353.png)'
- en: 'Once we have our cluster running and accessible we need to complete the Helm
    installation by installing Tiller. To do this we need to run the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的集群运行并且可访问，我们需要通过安装 Tiller 来完成 Helm 安装。要做到这一点，我们需要运行以下命令：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should see something like the following message:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到类似以下消息：
- en: '![](assets/6407f211-02d3-41ab-8863-ba045b51a6e6.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6407f211-02d3-41ab-8863-ba045b51a6e6.png)'
- en: Launching Fission using Helm
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Helm 启动 Fission
- en: 'Helm is now configured and we can use it to deploy the remote components of
    Fission. This can be done by running the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 现在已配置好，我们可以使用它来部署 Fission 的远程组件。可以通过运行以下命令来完成：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After a minute or two, you should receive confirmation that Fission has launched.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一两分钟后，您应该会收到 Fission 已启动的确认信息。
- en: Working through the output
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过输出进行工作
- en: Helm is quite verbose with its output. It will give you an overview of everything
    it has created along with any additional notes the developers have included.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 的输出非常详细。它将为您提供它创建的所有内容的概述，以及开发人员包含的任何附加说明。
- en: 'This part of the output contains the basic details of the deployment:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的这部分包含了部署的基本细节：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next up, we get information on what has been deployed within Kubernetes, starting
    with the service accounts. These provide identity services that run a pod. These
    allow the various components of Fission to interface with Kubernetes:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们会得到有关在 Kubernetes 中部署了什么的信息，从服务账户开始。这些提供运行 pod 的身份服务。这些允许 Fission 的各个组件与
    Kubernetes 进行接口交互：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then come the bindings. These provide role-based authentication (RBAC) for
    the cluster:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是绑定。这些为集群提供基于角色的身份验证（RBAC）：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next up are the services themselves:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是服务本身：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we have the deployment details. You will probably notice that, as in the
    following, some of the pods are still launching, which is why they are showing
    zero available:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了部署详情。您可能会注意到，如下所示，一些 pod 仍在启动，这就是为什么它们显示为零可用的原因：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next up, we have the pods for the deployments and services:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有了部署和服务的 pod：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then we have the namespaces:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有了命名空间：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we have the secrets. These are just for the database being used:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了秘密。这些只是用于正在使用的数据库：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We are nearing the end: the persistent storage claims. You can see, as we have
    launched locally, it is just using a folder on the VM rather than creating external
    storage:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接近尾声了：持久存储索赔。您可以看到，由于我们在本地启动，它只是使用 VM 上的一个文件夹，而不是创建外部存储：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we have the role bindings:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了角色绑定：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we have the daemon sets:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有了守护进程集：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we have seen an overview of all the Kubernetes elements of our Fission
    installation, we get notes on how to interact with the installation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了我们的 Fission 安装的所有 Kubernetes 元素的概述，我们得到了如何与安装进行交互的说明。
- en: Launching our first function
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动我们的第一个函数
- en: The notes are split into three sections; the first section gives instructions
    on how to install the Fission command-line client. As we have already covered
    this in the previous section of the chapter we can ignore this step.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记分为三个部分；第一部分提供了如何安装Fission命令行客户端的说明。由于我们已经在本章的前一部分中涵盖了这一点，我们可以忽略这一步。
- en: 'Next up, in the second section we are given instructions on environment variables
    we need to set so that our local Fission client can interact with our Fission
    installation. To set these variables run the following commands:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第二部分中，我们得到了关于需要设置的环境变量的说明，以便我们的本地Fission客户端可以与我们的Fission安装进行交互。要设置这些变量，请运行以下命令：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `export` command only works with macOS High Sierra and Ubuntu 17.04\. Windows
    10 Professional users will have to run the following commands:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`export`命令仅适用于macOS High Sierra和Ubuntu 17.04。Windows 10专业版用户将不得不运行以下命令：'
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see from the commands, our Fission installation is aware that it
    is running on a Minikube installation and has provided us with commands to dynamically
    generate the IP address of our Minikube installation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些命令中可以看出，我们的Fission安装知道它正在运行在Minikube安装上，并为我们提供了动态生成Minikube安装的IP地址的命令。
- en: The third section contains step by step instructions on how to run a hello world
    function; let's look at running these steps now.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包含了一步一步的说明，说明如何运行一个hello world函数；让我们现在来运行这些步骤。
- en: 'First of all, we need to create an environment. To do this we use the following
    command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个环境。为此，我们使用以下命令：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This command creates an environment called `nodejs` and then instructs Fission
    to use the Docker image `fission/node-env`from the Docker Hub—you can find this
    image at: [https://hub.docker.com/r/fission/node-env/](https://hub.docker.com/r/fission/node-env/).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令创建了一个名为`nodejs`的环境，然后指示Fission使用来自Docker Hub的Docker镜像`fission/node-env`——您可以在[https://hub.docker.com/r/fission/node-env/](https://hub.docker.com/r/fission/node-env/)找到这个镜像。
- en: 'Now that we have the environment created, we need a function to deploy. Run
    the following command (macOS and Linux only) to download the hello world example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了环境，我们需要一个要部署的函数。运行以下命令（仅适用于macOS和Linux）来下载hello world示例：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will download the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载以下代码：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, it is not dissimilar to the previous examples we have been
    running in earlier chapters. Now that we have a function downloaded, we can deploy
    it using the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这与我们在早期章节中运行的示例并没有太大不同。现在我们已经下载了一个函数，我们可以使用以下命令部署它：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are almost there; the final step is to create a route to our function. To
    do this, use the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快要完成了；最后一步是创建一个到我们函数的路由。要做到这一点，使用以下命令：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We should now be able to call our function by making an HTTP request. You can
    use either of the following commands to trigger our function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够通过发出HTTP请求来调用我们的函数。您可以使用以下命令中的任一个来触发我们的函数：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For Windows 10 Professional, use the following command to open the example
    in IE:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows 10专业版，请使用以下命令在IE中打开示例：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'HTTPie will give you the headers, as well as the following output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPie将为您提供标头，以及以下输出：
- en: '![](assets/79722f78-5815-45eb-801c-40cd7b7abb1e.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/79722f78-5815-45eb-801c-40cd7b7abb1e.png)'
- en: A guestbook
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个留言板
- en: Now that we have a basic application up and running, let's look at creating
    something more complex. Fission ships with a demo application that acts as a guestbook.
    You can find the files we are going to be deploying in the `/Chapter08/guestbook/`
    folder in the GitHub repository that accompanies this book.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个基本的应用程序在运行，让我们来创建一些更复杂的东西。Fission附带了一个演示应用程序，充当留言板。您可以在伴随本书的GitHub存储库中的`/Chapter08/guestbook/`文件夹中找到我们将要部署的文件。
- en: 'The first step in launching the application is to launch a Redis deployment;
    this will be used to store the comments being written to the guestbook. To create
    the deployment, run the following command from within the `/Chapter08/guestbook/`
    folder:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序的第一步是启动Redis部署；这将用于存储写入留言板的评论。要创建部署，请在`/Chapter08/guestbook/`文件夹中运行以下命令：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can see from the following screenshot this has created a `namespace`, `deployment`,
    and `service`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下截图中看到，这创建了一个`namespace`、`deployment`和`service`。
- en: '![](assets/c999a786-2b0b-42b6-a941-a1bfaf9f659e.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c999a786-2b0b-42b6-a941-a1bfaf9f659e.png)'
- en: 'Now we need to create an environment to launch our functions into. As the application
    is written in Python, let''s run the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个环境来启动我们的函数。由于应用程序是用Python编写的，让我们运行以下命令：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output of the previous command is shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出显示在以下截图中：
- en: '![](assets/37069961-48b9-4fef-8ac8-6be14d231f3c.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/37069961-48b9-4fef-8ac8-6be14d231f3c.png)'
- en: 'Now we have created two functions, one for displaying the comments and one
    for writing the comments. To add these, run the following commands:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了两个函数，一个用于显示评论，一个用于写评论。要添加这些，请运行以下命令：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of the preceding commands can be seen in the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出可以在以下截图中看到：
- en: '![](assets/79183e9b-e337-4a2e-ab96-8967a67d41b9.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/79183e9b-e337-4a2e-ab96-8967a67d41b9.png)'
- en: You will notice that the command to add the functions is a little different
    from the one we used to launch the hello world example in the previous section.
    In the previous examples, we are both adding the function and creating the route.
    You might also have noticed that while we have created two functions, they are
    bound to the same route of `/guestbook`. Rather than discuss this now, let's launch
    the application and interact with it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，用于添加函数的命令与我们在上一节中用于启动hello world示例的命令有些不同。在之前的示例中，我们既添加了函数，又创建了路由。您可能还注意到，虽然我们创建了两个函数，但它们都绑定到了相同的路由`/guestbook`。现在不讨论这个问题，让我们启动应用程序并与之交互。
- en: 'To open the guestbook, run the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开留言板，请运行以下命令：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For Windows 10 Professional, use:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows 10专业版，请使用：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will open your browser at a blank guestbook page, as in the following
    screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在浏览器中打开一个空的留言板页面，如下截图所示：
- en: '![](assets/b699b897-d8f4-4ef6-b4ce-88019c11b36b.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b699b897-d8f4-4ef6-b4ce-88019c11b36b.png)'
- en: 'Let''s now add a comment by entering some text—say `Testing Fission`—and then
    click Add. Upon refreshing, you should see your comment has been added:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过输入一些文本（比如`Testing Fission`）来添加评论，然后单击添加。刷新后，您应该看到您的评论已添加：
- en: '![](assets/9d18d10b-b9a8-4b97-858f-1d4dc284f2fd.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9d18d10b-b9a8-4b97-858f-1d4dc284f2fd.png)'
- en: 'If you receive an internal server error, don''t worry—just refresh the page
    and submit again. Taking a look at the HTML source of the page, you may notice
    that the form action is configured to `POST` to `/guestbook`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到内部服务器错误，请不要担心，只需刷新页面并重新提交。查看页面的HTML源代码，您可能会注意到表单操作配置为将`POST`提交到`/guestbook`：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you look at the command we used to create the two functions, both had a
    method attached. The `guestbook-add` one, which runs the `add.py`, used the `POST`
    method, as you can see from the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看我们用于创建两个函数的命令，您会注意到两者都附有一个方法。`guestbook-add`，运行`add.py`，使用了`POST`方法，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The function reads the data posted by the form, pushes the comment to the Redis
    database, and then takes us back to `/guestbook`. The `303` code is the status
    code used to redirect after a `POST`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数读取表单提交的数据，将评论推送到Redis数据库，然后将我们带回`/guestbook`。`303`代码是在`POST`后重定向使用的状态代码。
- en: 'Whenever your browser requests a page it is sending a `GET` request. In our
    case, all of the `GET` requests to `/guestbook` are being routed to the `guestbook-get`
    function, which is the `get.py` code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您的浏览器请求页面时，它都会发送一个`GET`请求。在我们的情况下，所有对`/guestbook`的`GET`请求都被路由到`guestbook-get`函数，这是`get.py`代码：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see from the preceding code, this connects to the Redis database,
    reads each entry, formats the results as an unordered HTML list, and then inserts
    the list below the horizontal rule (`<hr/>`).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的代码中可以看出，这会连接到Redis数据库，读取每个条目，将结果格式化为无序的HTML列表，然后将列表插入到水平线下方（`<hr/>`）。
- en: Fission commands
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fission命令
- en: Before we look at moving our Fission installation to a public cloud, we should
    look at the command client a little more. There are several top-level commands
    available that we can use to manage our functions and routes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将Fission安装移到公共云之前，我们应该更多地了解一下命令客户端。有几个顶级命令可用于管理我们的函数和路由。
- en: The fission function command
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fission function命令
- en: This is pretty much where you will spend most of your time when using Fission.
    The function command is how you create, manage, and delete your functions. You
    can use either `fission function <command>` or `fission fn <command>`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是您在使用Fission时将花费大部分时间的地方。函数命令是您创建、管理和删除函数的方式。您可以使用`fission function <command>`或`fission
    fn <command>`。
- en: The create command
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: create命令
- en: 'We have already used this command so we don''t need to go into too much detail.
    The `fission function create` command takes several options; the most common ones
    are:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用过这个命令，所以不需要详细介绍。`fission function create` 命令有几个选项；最常见的是：
- en: '`--name`: This indicates what we want to call our function.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name`：这表示我们想要给我们的函数取什么名字。'
- en: '`--env`: This indicates the environment we want to deploy our function in.
    More on environments in the next section.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--env`：这表示我们想要在哪个环境中部署我们的函数。更多关于环境的内容请参见下一节。'
- en: '`--code`: The path or URL to the code we wish to deploy.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--code`：我们希望部署的代码的路径或URL。'
- en: '`--url`: The URL we want our function to be available at.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--url`：我们希望我们的函数在哪个URL上可用。'
- en: '`--method`: How we access our function on the preceding URL; the options here
    are `GET`, `POST`, `PUT`, `DELETE`, `HEAD`—if you don''t use `--method` but do
    use `--url` it will always default to `GET`.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--method`：我们在前面URL上访问我们的函数的方式；这里的选项有`GET`、`POST`、`PUT`、`DELETE`、`HEAD`—如果您不使用`--method`但使用`--url`，它将始终默认为`GET`。'
- en: 'As we have already seen in the guestbook example, a `fission function create`
    command would look something like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在留言板示例中已经看到的，`fission function create` 命令看起来会像下面这样：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The get option
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取选项
- en: 'This option is a quite a simple one; running `fission function get` will display
    the source code for your chosen function. It accepts one input: `--name`. This
    is the name of the function you wish to display the source code for.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项相当简单；运行`fission function get`将显示您选择的函数的源代码。它接受一个输入：`--name`。这是您希望显示源代码的函数的名称。
- en: 'Running the following command will display the source code for the hello world
    function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令将显示hello world函数的源代码：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![](assets/136c1f31-a283-4f3b-a893-9e95fedadf5d.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/136c1f31-a283-4f3b-a893-9e95fedadf5d.png)'
- en: The list and getmeta commands
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出和获取元数据命令
- en: 'The following two commands kind of do the same thing:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个命令有点类似：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This command will list the functions that are currently installed. In that
    list is the name of the function, its unique ID, and which environment the function
    is deployed into:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将列出当前安装的函数。列表中包括函数的名称、唯一ID以及函数部署的环境：
- en: '![](assets/de079f74-35db-4cea-a0c8-ce19c6b2f9dd.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/de079f74-35db-4cea-a0c8-ce19c6b2f9dd.png)'
- en: 'If we already know the name of the function and we want to remind ourselves
    of the environment it is running in, or need its UID, then we can use the `fission
    function getmeta` command and pass it the name of the function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经知道函数的名称，并且想要提醒自己它正在运行的环境，或者需要它的 UID，那么我们可以使用 `fission function getmeta`
    命令，并传递函数的名称：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![](assets/30ec7ff7-1556-445e-ad25-d077acc4ffde.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/30ec7ff7-1556-445e-ad25-d077acc4ffde.png)'
- en: The logs command
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志命令
- en: 'Although there are not any views at the moment, you can view the logs for your
    function by using the `fission function logs` command. There are a few different
    options you can pass:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然目前没有任何视图，但您可以使用 `fission function logs` 命令查看函数的日志。您可以传递一些不同的选项：
- en: '`--name`: This is the name of the function you wish to view the logs for, and
    this is always required'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name`：这是您希望查看日志的函数的名称，这总是必需的'
- en: '`--follow`: Keeps the stream open and logs are displayed in real time'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--follow`：保持流打开，日志实时显示'
- en: '`--detail`: Adds more verbose output'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--detail`：添加更多详细输出'
- en: 'Using the preceding options, the command will look something like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述选项，命令将看起来像下面这样：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: However, as mentioned, there is not a lot to see at the moment.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如前面提到的，目前没有太多可看的。
- en: The update command
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新命令
- en: 'The `fission function update` command deploys an updated version of a function.
    It uses the same options as the `fission function create` command. For example,
    if we wanted to update our hello world function to use a different source, we
    would run the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`fission function update` 命令部署函数的更新版本。它使用与 `fission function create` 命令相同的选项。例如，如果我们想要更新我们的
    hello world 函数以使用不同的源，我们将运行以下命令：'
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The delete command
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除命令
- en: The final command we are going to look at is `fission function delete`. This
    command is pretty self-explanatory. It deletes the function and only accepts a
    single argument, and that is `--name`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要看的最后一个命令是 `fission function delete`。这个命令相当不言自明。它删除函数，只接受一个参数，那就是 `--name`。
- en: Please be careful when using `fission function delete`; it does not prompt you
    in any way, and when you hit *Enter* your function will be deleted.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `fission function delete` 时请小心；它不会以任何方式提示您，当您按下 *Enter* 时，您的函数将被删除。
- en: 'To delete the hello world function, for example, we should just run the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除 hello world 函数，例如，我们只需运行以下命令：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![](assets/fa8b8ea6-3c38-4779-b118-282ede814f46.png)As you can see, and as
    mentioned, there are no *Are you sure?* prompts so be careful when using the command.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/fa8b8ea6-3c38-4779-b118-282ede814f46.png)如您所见，并且正如前面提到的，没有 *您确定吗？*
    的提示，因此在使用命令时请小心。'
- en: The fission environment command
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fission environment 命令
- en: The next top-level command is environment. As we have already seen, environments
    are where our functions run and they also define what language our functions are
    executed in. At the time of writing, Fission supports Node.js, Go, Python, PHP,
    Ruby, Perl, and .NET C#.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个顶级命令是 environment。正如我们已经看到的，环境是我们的函数运行的地方，它们还定义了我们的函数在哪种语言中执行。在撰写本文时，Fission
    支持 Node.js、Go、Python、PHP、Ruby、Perl 和 .NET C#。
- en: The create command
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建命令
- en: 'The `fission environment create` command is one we have already used. For example,
    when we created the guestbook application we needed a Python environment to run
    our application on, so we ran the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`fission environment create` 命令是我们已经使用过的一个命令。例如，当我们创建 guestbook 应用程序时，我们需要一个
    Python 环境来运行我们的应用程序，所以我们运行了以下命令：'
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A full list of the images, the URLs to use, and the Dockerfiles used to create
    the images are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的完整列表、要使用的 URL 和用于创建图像的 Dockerfile 如下：
- en: '| **Language** | **Image name** | **Source URL** |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **语言** | **图像名称** | **源 URL** |'
- en: '| Python 2.7 | `fission/python-env` | [https://github.com/fission/fission/tree/master/environments/python](https://github.com/fission/fission/tree/master/environments/python)
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| Python 2.7 | `fission/python-env` | [https://github.com/fission/fission/tree/master/environments/python](https://github.com/fission/fission/tree/master/environments/python)
    |'
- en: '| Python 3.5 | `fission/python3-env` | [https://github.com/fission/fission/tree/master/environments/python](https://github.com/fission/fission/tree/master/environments/python)
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| Python 3.5 | `fission/python3-env` | [https://github.com/fission/fission/tree/master/environments/python](https://github.com/fission/fission/tree/master/environments/python)
    |'
- en: '| Node.js | `fission/nodejs-env` | [https://github.com/fission/fission/tree/master/environments/nodejs](https://github.com/fission/fission/tree/master/environments/nodejs)
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| Node.js | `fission/nodejs-env` | [https://github.com/fission/fission/tree/master/environments/nodejs](https://github.com/fission/fission/tree/master/environments/nodejs)
    |'
- en: '| .NET C# | `fission/dotnet-env` | [https://github.com/fission/fission/tree/master/environments/dotnet](https://github.com/fission/fission/tree/master/environments/dotnet)
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| .NET C# | `fission/dotnet-env` | [https://github.com/fission/fission/tree/master/environments/dotnet](https://github.com/fission/fission/tree/master/environments/dotnet)
    |'
- en: '| .NET 2.0 C# | `fission/dotnet20-env` | [https://github.com/fission/fission/tree/master/environments/dotnet20](https://github.com/fission/fission/tree/master/environments/dotnet20)
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| .NET 2.0 C# | `fission/dotnet20-env` | [https://github.com/fission/fission/tree/master/environments/dotnet20](https://github.com/fission/fission/tree/master/environments/dotnet20)
    |'
- en: '| Go | `fission/go-runtime` | [https://github.com/fission/fission/tree/master/environments/go](https://github.com/fission/fission/tree/master/environments/go)
    |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| Go | `fission/go-runtime` | [https://github.com/fission/fission/tree/master/environments/go](https://github.com/fission/fission/tree/master/environments/go)
    |'
- en: '| PHP | `fission/php7-env` | [https://github.com/fission/fission/tree/master/environments/php7](https://github.com/fission/fission/tree/master/environments/php7)
    |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| PHP | `fission/php7-env` | [https://github.com/fission/fission/tree/master/environments/php7](https://github.com/fission/fission/tree/master/environments/php7)
    |'
- en: '| Ruby | `fission/ruby-env` | [https://github.com/fission/fission/tree/master/environments/ruby](https://github.com/fission/fission/tree/master/environments/ruby)
    |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| Ruby | `fission/ruby-env` | [https://github.com/fission/fission/tree/master/environments/ruby](https://github.com/fission/fission/tree/master/environments/ruby)
    |'
- en: '| Perl | `fission/perl-env` | [https://github.com/fission/fission/tree/master/environments/perl](https://github.com/fission/fission/tree/master/environments/perl)
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| Perl | `fission/perl-env` | [https://github.com/fission/fission/tree/master/environments/perl](https://github.com/fission/fission/tree/master/environments/perl)
    |'
- en: The list and get command
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出和获取命令
- en: Like the function command, environment also has a `list` and `get` command,
    and they work in the same way.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数命令一样，环境也有`list`和`get`命令，它们的工作方式也相同。
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Running the previous command will list all of the configured environments.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上一个命令将列出所有配置的环境。
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Running the previous command will get the details of the named environment.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上一个命令将获取命名环境的详细信息。
- en: '![](assets/0e86e3f1-0777-4fe1-b51e-2417d7382cf4.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0e86e3f1-0777-4fe1-b51e-2417d7382cf4.png)'
- en: The delete command
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除命令
- en: 'The `delete` command, again, works as you would expect it to (remember it will
    delete without warning):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`命令再次按预期工作（请记住它会在没有警告的情况下删除）：'
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Also, if you have functions within your environment, it will also delete with
    no warning. However, your functions will remain until you manually delete them.
    Any attempt to call a function that does not have an environment will result in
    an internal server error.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您的环境中有函数，它也将在没有警告的情况下被删除。但是，您的函数将保留，直到您手动删除它们。任何尝试调用没有环境的函数都将导致内部服务器错误。
- en: Running Fission in the cloud
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云中运行Fission
- en: Now we have an idea of what is involved in launching and interacting with Fission
    when it is running locally, let's look at launching Kubernetes in the cloud and
    then configuring Fission to run there.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了在本地运行Fission时启动和交互所涉及的内容，让我们看看在云中启动Kubernetes，然后配置Fission在那里运行。
- en: For the remainder of this section, I will be only providing instructions for
    macOS High Sierra and Ubuntu 17.04 hosts as this these have a greater level of
    compatibility with the commands we will be running.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我将仅提供macOS High Sierra和Ubuntu 17.04主机的说明，因为它们与我们将要运行的命令具有更高的兼容性。
- en: Launching the Kubernetes cluster
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动Kubernetes集群
- en: 'I am going to be launching my Kubernetes in Google Cloud using the following
    command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用以下命令在Google Cloud中启动我的Kubernetes：
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令的输出可以在以下截图中看到：
- en: '![](assets/a9396fbc-ab7c-42f1-91b1-0622bee37be9.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a9396fbc-ab7c-42f1-91b1-0622bee37be9.png)'
- en: 'Once launched, which should take about 5 minutes at the most, you can check
    that your cluster is up and running as expected by using the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，最多需要大约5分钟，您可以使用以下方法检查您的集群是否按预期运行：
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令的输出可以在以下截图中看到：
- en: '![](assets/1493cd89-dfb1-41cb-8dce-23131d8674ab.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1493cd89-dfb1-41cb-8dce-23131d8674ab.png)'
- en: 'Now that we have our three-node cluster up and running, and our local Kubernetes
    client interacting with it, we can deploy the Kubernetes end of Helm by running
    the following command again:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的三节点集群已经运行起来了，并且我们的本地Kubernetes客户端正在与之交互，我们可以再次运行以下命令来部署Helm的Kubernetes端：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will return the following message:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下消息：
- en: '![](assets/e235d7be-a745-4516-8149-9345b8f5317d.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e235d7be-a745-4516-8149-9345b8f5317d.png)'
- en: Now that we have Helm ready, we can go ahead and launch Fission.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了Helm，我们可以继续启动Fission。
- en: Installing Fission
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Fission
- en: 'As before, we will be using Helm to install Fission. The only difference between
    installing Fission locally and on a public cloud such as Google Cloud, Microsoft
    Azure, or AWS is that we will not be using the `--set serviceType=NodePort` option
    and instead just run the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们将使用Helm来安装Fission。在本地安装Fission和在Google Cloud、Microsoft Azure或AWS等公共云上安装Fission之间唯一的区别是，我们不会使用`--set
    serviceType=NodePort`选项，而是直接运行以下命令：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You may notice that it's a lot quicker to run this time, and that the information
    returned is quite similar to when we launched Fission on our local single node
    cluster.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到这次运行速度要快得多，并且返回的信息与我们在本地单节点集群上启动Fission时非常相似。
- en: 'You may notice, this time your installation has a different name:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，这次您的安装有一个不同的名称：
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This name is used to reference the installation throughout, as you can see
    from the following screen, which is taken from the Workloads page of the Google
    Cloud web console:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此名称用于在整个过程中引用安装，如您从Google Cloud Web控制台的工作负载页面中看到的屏幕截图所示：
- en: '![](assets/eea42255-91b3-4c26-9e15-bd86210b99e4.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/eea42255-91b3-4c26-9e15-bd86210b99e4.png)'
- en: 'While still in the console, clicking on Discovery & load balancing will show
    you all of the external IP addresses that have been assigned to your installation.
    As we passed the `NodePort` option, external load balancers have been created:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中，点击“发现和负载均衡”将显示分配给您的安装的所有外部IP地址。由于我们传递了`NodePort`选项，因此已创建了外部负载均衡器：
- en: '![](assets/de0020bb-b6fb-4bed-b6f2-6c714b115af1.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/de0020bb-b6fb-4bed-b6f2-6c714b115af1.png)'
- en: 'The final thing to look at while in the console is the Storage page. As you
    can see, external block storage has been created and attached to your installation.
    This is different to when we launched it locally, as the storage was actually
    that of our single machine:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中查看的最后一件事是存储页面。如您所见，外部块存储已创建并附加到您的安装中。这与我们在本地启动时不同，因为存储实际上是我们单台机器的存储：
- en: '![](assets/e81c1074-edd4-49ba-9341-dcee15b2f08d.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e81c1074-edd4-49ba-9341-dcee15b2f08d.png)'
- en: Returning to the command line, you will notice that, again, Helm has given us
    instructions on how to finish off the configuration of our local Fission client.
    However, as we were not using Minikube, the instructions are slightly different
    this time.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 回到命令行，你会注意到，Helm再次给了我们关于如何完成本地Fission客户端配置的指令。然而，由于我们没有使用Minikube，这次的指令略有不同。
- en: 'The commands to set the `FISSION_URL` and `FISSION_ROUTER` variables this time
    use `kubectl` to query our installation to find out the external IP address of
    our load balancers:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这次设置`FISSION_URL`和`FISSION_ROUTER`变量的命令使用`kubectl`来查询我们的安装，以找出负载均衡器的外部IP地址：
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can check the URLs by running the following commands:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来检查URL：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This should give you something like the following output:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给你类似以下的输出：
- en: '![](assets/27b2dd66-4b9b-4a2a-a8ee-20857a4d0816.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/27b2dd66-4b9b-4a2a-a8ee-20857a4d0816.png)'
- en: 'Now that we have Fission installed, and our local command-line client configured
    to interact with our cloud-based installation, we can quickly re-run the hello
    world example by running the following commands:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了Fission，并且我们的本地命令行客户端已配置为与我们的基于云的安装进行交互，我们可以通过运行以下命令快速重新运行hello world示例：
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This should give you something like the following output:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给你类似以下的输出：
- en: '![](assets/e039c924-6268-4b50-a00d-98c7707193a4.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e039c924-6268-4b50-a00d-98c7707193a4.png)'
- en: 'Once launched, you can use either of the following commands to call the function:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，你可以使用以下命令之一来调用该函数：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This should give you something like the following output:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给你类似以下的输出：
- en: '![](assets/9395a699-b5b0-467e-926f-ced6004eb30c.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9395a699-b5b0-467e-926f-ced6004eb30c.png)'
- en: As you can already see, like all of the technologies we have looked at, once
    installed, interacting and using Fission in a public cloud is no different to
    how you would interact and use it when running locally. You really don't have
    to care too much about external access and so on, as Fission and Kubernetes are
    both sorting this out for you.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经看到的，就像我们所看到的所有技术一样，一旦安装，与公共云中的Fission交互和使用与在本地运行时并无不同。你真的不需要太在意外部访问等等，因为Fission和Kubernetes都已经为你解决了这个问题。
- en: The guestbook
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: guestbook
- en: 'Before we move on to a more advanced example, let''s quickly launch our guestbook
    application again. To do this, change to the `/Chapter08/guestbook/` folder in
    the repository and then run the following commands:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续更高级的示例之前，让我们快速再次启动我们的guestbook应用程序。要做到这一点，切换到存储库中的`/Chapter08/guestbook/`文件夹，然后运行以下命令：
- en: '[PRE56]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This should give you something like the following output:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给你类似以下的输出：
- en: '![](assets/87759a92-2586-497c-bf0a-32689b6c97e8.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/87759a92-2586-497c-bf0a-32689b6c97e8.png)'
- en: 'This will launch the application and also take you to it in your browser, where
    you can add a comment:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动应用程序，并且还会在浏览器中打开，你可以在其中添加评论：
- en: '![](assets/0abac7c0-97e9-4abe-beb4-bd6d120aa78b.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0abac7c0-97e9-4abe-beb4-bd6d120aa78b.png)'
- en: Some more examples
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多示例
- en: Before we finish off the chapter, let's look at some more example code running
    in Fission, starting with a weather checker.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，让我们看一些在Fission中运行的示例代码，首先是一个天气检查器。
- en: Weather
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 天气
- en: 'In the `/Chapter08/weather/` folder of the repository, you will find `weather.js`.
    This is a simple Node.js function that queries the Yahoo weather API to return
    the current weather for a given location:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库的`/Chapter08/weather/`文件夹中，你会找到`weather.js`。这是一个简单的Node.js函数，用于查询Yahoo天气API以返回给定位置的当前天气：
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As you can see from the preceding code, the function accepts JSON encoded data,
    which must contain a valid location. Because of this, we will need to deploy the
    function with a `POST` route, and as it gives an error if no location data is
    passed, we should also deploy a `GET` route. To do this, simple run the following
    commands from within the  `/Chapter08/weather/` folder:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从前面的代码中看到的，该函数接受JSON编码的数据，其中必须包含一个有效的位置。因此，我们需要使用`POST`路由部署该函数，并且如果没有传递位置数据，它会报错，所以我们还应该部署一个`GET`路由。要做到这一点，只需在`/Chapter08/weather/`文件夹中运行以下命令：
- en: '[PRE58]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The first command may result in an error if you already have the environment
    we originally created for the hello world example up and running, as seen in the
    following Terminal output:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在终端输出中看到了我们最初为hello world示例创建并运行的环境，那么第一个命令可能会导致错误：
- en: '![](assets/81dd0f50-1acc-4c96-a450-df575172498e.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/81dd0f50-1acc-4c96-a450-df575172498e.png)'
- en: 'Now that we have our function deployed we can quickly test it by running one
    of the following two commands:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经部署了我们的函数，可以通过运行以下两个命令之一来快速测试它：
- en: '[PRE59]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Because we haven''t supplied the location, you should see the following message:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有提供位置，所以你应该会看到以下消息：
- en: '![](assets/a0fdce7d-d631-4a8c-a887-dcb6246727bc.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a0fdce7d-d631-4a8c-a887-dcb6246727bc.png)'
- en: 'This is exactly what the code has been programmed to do. As you can see, it
    has returned a `400` error with the message we expected. Providing a location
    (I used `Nottingham, England`) by running one of the following commands should
    tell you what the weather is:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是代码的预期行为。正如你所看到的，它返回了一个`400`错误和我们预期的消息。通过运行以下命令之一提供位置（我使用了`英格兰诺丁汉`）应该会告诉你天气情况：
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can see from the following Terminal output, it has confirmed that the weather
    is currently not that great where I am:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从下面的终端输出中看到，它已经确认了我所在的地方目前天气并不是很好：
- en: '![](assets/2a20414b-ca48-4dfc-9068-f4c4c69d2a39.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2a20414b-ca48-4dfc-9068-f4c4c69d2a39.png)'
- en: Slack
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Slack
- en: In this example, we are going to be posting a message each time a service is
    created or deleted in the default namespace of our current Kubernetes installation.
    The messages will be posted to a group messaging service called Slack using a
    Webhook.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将在当前Kubernetes安装的默认命名空间中每次创建或删除服务时发布一条消息。这些消息将通过名为Slack的Webhook发布到一个名为Slack的群组消息服务中。
- en: Slack is an online collaboration tool that allows teams to use an environment
    to interact with chatbots and each other. It offers free and paid tiers as well
    as an exhaustive API for your applications to hook into your chat rooms.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Slack是一个在线协作工具，允许团队在其中与聊天机器人和其他人进行交互。它提供免费和付费的服务，以及一个详尽的API供你的应用程序连接到你的聊天室。
- en: I am going to assume that you already have access to a Slack workspace and have
    permissions to add applications to it. If you don't, then you can configure a
    new workspace at [https://slack.com/](https://slack.com).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我将假设你已经可以访问Slack工作空间，并且有权限向其添加应用程序。如果没有，那么你可以在[https://slack.com/](https://slack.com)配置一个新的工作空间。
- en: Once you have access to your workspace, click on the name of the workspace in
    the top-left of the screen and from the drop-down list of options, select Manage
    Apps. This will take you to the Slack **App Directory**. Here, in the search field
    at the top of the page, enter `Incoming WebHooks`, select the result, and then
    click on the Add Configuration button.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进入了你的工作空间，点击屏幕左上角的工作空间名称，然后从下拉列表中选择“管理应用程序”。这将带你进入Slack的**应用程序目录**。在这里，在页面顶部的搜索框中输入`Incoming
    WebHooks`，选择结果，然后点击“添加配置”按钮。
- en: Follow the on-screen instructions to create a Webhook for the channel of your
    choice. I choose to post my updates in the random channel and I also customized
    the icon. On this page you will also find a Webhook URL. Mine (which has now been
    removed) was `https://hooks.slack.com/services/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`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 按照屏幕上的说明创建你选择的频道的 Webhook。我选择在随机频道发布我的更新，我还自定义了图标。在这个页面上，你还会找到一个 Webhook URL。我的（现在已被删除）是
    `https://hooks.slack.com/services/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`。
- en: 'Make a note of this, as we will need to update the code with it. As you can
    see in the following code, which you can also find in the repository at `/Chapter08/slack/`,
    the third line needs to be updated with your Webhook details:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 记下这一点，因为我们需要用它来更新代码。正如你在下面的代码中所看到的，你也可以在 `/Chapter08/slack/` 仓库中找到，第三行需要用你的
    Webhook 详细信息进行更新：
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: To do this, paste everything after `https://hooks.slack.com`, including the
    slash (`/`). For me this was `/services/T8F3CR4GG/B8FNRR3PC/wmLSDgS0fl5SGOcAgNjwr6pC`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，粘贴`https://hooks.slack.com`后面的所有内容，包括斜杠(`/`)。对我来说，这是`/services/T8F3CR4GG/B8FNRR3PC/wmLSDgS0fl5SGOcAgNjwr6pC`。
- en: 'The line should read something like the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 该行应该类似于以下内容：
- en: '[PRE62]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Make sure the file is called `kubeEventsSlack.js` and once your Webhook details
    are in the code, we can create and launch the function using the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 确保文件名为 `kubeEventsSlack.js`，一旦你的 Webhook 详细信息在代码中，我们可以使用以下命令创建和启动函数：
- en: '[PRE63]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Once the function has been created, we need to create something to trigger it.
    Previously, we have been calling the functions using HTTP calls. This time, though,
    we want to trigger the function each time something happens within our Kubernetes
    cluster. To do this, we need to create a watch.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 函数创建后，我们需要创建一些东西来触发它。以前，我们一直在使用 HTTP 调用来调用函数。不过这一次，我们希望在我们的 Kubernetes 集群中发生某些事情时触发函数。为此，我们需要创建一个观察。
- en: 'To do this, run the following command:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，运行以下命令：
- en: '[PRE64]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `fission watch` command is something we have not yet discussed, so let's
    take a minute to find out a little more about it.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`fission watch` 命令是我们尚未讨论过的内容，所以让我们花点时间了解一下更多关于它的信息。'
- en: 'As part of our Fission deployment there is a service called `kubewatcher`.
    By default, this service is used by Fission to help manage itself by watching
    the Kubernetes API, but is also exposed to end users. The command used to create
    the previous watch creates a watcher, which calls our function (`--function kubeslack`)
    each time changes to a service (`--type service`) are made in the default namespace
    (`--ns default`). We could also set up a watch that looks for changes to pods,
    deployments, and so on by changing the type:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们 Fission 部署的一部分，有一个名为 `kubewatcher` 的服务。默认情况下，Fission 使用这个服务来通过观察 Kubernetes
    API 来帮助管理自身，但也向最终用户公开。用于创建之前观察的命令创建了一个观察者，它每次在默认命名空间中对服务进行更改时调用我们的函数(`--function
    kubeslack`)。我们还可以设置一个观察，以查找对 pods、deployments 等的更改，通过更改类型：
- en: '![](assets/90b42045-f5c6-46a0-b78f-2d663350d73c.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/90b42045-f5c6-46a0-b78f-2d663350d73c.png)'
- en: 'Now we need to launch a service in the default namespace. To do this, change
    to the `/Chapter03/` folder and run the following commands:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在默认命名空间中启动一个服务。为此，切换到 `/Chapter03/` 文件夹并运行以下命令：
- en: '[PRE65]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, delete the service by running the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过运行以下命令删除服务：
- en: '[PRE66]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '![](assets/8eef86e2-c090-45d1-8966-a81edfa74be6.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8eef86e2-c090-45d1-8966-a81edfa74be6.png)'
- en: 'If you check Slack, you should see two messages confirming that a service called
    `cli-hello-world` has been added and deleted:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查 Slack，你应该会看到两条消息，确认一个名为 `cli-hello-world` 的服务已被添加和删除：
- en: '![](assets/c9bcd145-2011-4126-9bbe-079d7e684278.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c9bcd145-2011-4126-9bbe-079d7e684278.png)'
- en: You should see this happen in almost real time, and you might also see messages
    about other services being started within the default namespace within your cluster.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该几乎实时地看到这种情况发生，你可能还会看到有关在默认命名空间内启动其他服务的消息。
- en: Whales
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鲸鱼
- en: 'The next, and also the last, example we are going to look at is a binary environment.
    This environment is different to the ones we have been looking at, as it does
    not contain a programming language as such. Instead, we will be deploying a bash
    script that installs and configures a Unix tool called `cowsay`. The code for
    this looks like the following and is available in the `/Chapter08/whale/` folder:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，也是最后一个例子，我们要看的是一个二进制环境。这个环境与我们一直在看的环境不同，因为它不包含编程语言。相反，我们将部署一个安装和配置名为`cowsay`的Unix工具的bash脚本。代码如下，并且位于`/Chapter08/whale/`文件夹中：
- en: '[PRE67]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, there are two sections to the bash script. The first part runs
    the `cowsay` command and if it errors, which it will do to start with, it uses
    `apk` to install `curl` and `perl`. Once installed, it downloads a copy of the
    code, and configures the default behavior. Then it runs the `cowsay` command after
    it is installed.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，bash脚本有两个部分。第一部分运行`cowsay`命令，如果出错，它将使用`apk`来安装`curl`和`perl`。安装完成后，它会下载代码副本，并配置默认行为。然后在安装后运行`cowsay`命令。
- en: You may be thinking to yourself, what is APK and what is `cowsay`? As the containers
    that are being deployed to run the Fission environments run Alpine Linux, we need
    to use **Alpines package manager** (**APK**) to install the required packages
    needed for our code to run.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想，APK是什么，`cowsay`又是什么？由于部署到Fission环境中的容器运行的是Alpine Linux，我们需要使用**Alpine软件包管理器**（**APK**）来安装我们代码运行所需的必要软件包。
- en: Alpine Linux is a Linux distribution, which over the last two years has started
    to gain a lot of traction over the more traditional Ubuntu/CentOS installations—this
    is because of its size. It is possible to have a base installation of Alpine Linux
    that uses only 8 MB of space. However, although it is small, it remains just as
    functional and powerful as other Linux distributions. Its small size coupled with
    its power makes it the perfect operating system for building containers with.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Alpine Linux是一个Linux发行版，在过去的两年里开始在更传统的Ubuntu/CentOS安装中获得了很多关注，这是因为它的体积。Alpine
    Linux的基本安装只需8MB的空间。然而，尽管它很小，但它仍然和其他Linux发行版一样功能强大。它小巧的体积加上强大的功能，使其成为构建容器的完美操作系统。
- en: '`cowsay` is a Unix command that repeats whatever input you give it in a speech
    bubble, coming from a cow, hence the name `cowsay`. We will be installing Docker''s
    own version of `cowsay`, which uses a whale instead of a cow. To deploy the binary
    function we first need to create the environment:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`cowsay`是一个Unix命令，它会在一个来自牛的对话气泡中重复你给它的任何输入，因此得名`cowsay`。我们将安装Docker自己的版本`cowsay`，它使用的是鲸鱼而不是牛。要部署二进制函数，我们首先需要创建环境：'
- en: '[PRE68]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now we can deploy the function and create the `POST` and `GET` routes so that
    we can access it:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以部署函数并创建`POST`和`GET`路由，以便我们可以访问它：
- en: '[PRE69]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下截图所示：
- en: '![](assets/d956143c-5c1e-4c68-a677-67e5aba546a7.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d956143c-5c1e-4c68-a677-67e5aba546a7.png)'
- en: 'Now that we have our function deployed, we can access it using one of the following:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经部署了我们的函数，我们可以使用以下之一来访问它：
- en: '[PRE70]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This will return an ASCII whale as seen in the following Terminal output:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个ASCII鲸鱼，如下终端输出所示：
- en: '![](assets/28566bb9-7ffc-483d-8579-f670243cb692.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/28566bb9-7ffc-483d-8579-f670243cb692.png)'
- en: 'You might notice that there is nothing in the speech bubble; that is because
    we need to `POST` something. Unlike the previous post examples, the function we
    have launched will simply repeat whatever we post. So, if we were to `POST` a
    JSON object, it will return the JSON object. Because of this, we will be posting
    only plain text:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到对话框中没有任何内容；那是因为我们需要“POST”一些东西。与之前的示例不同，我们启动的函数将简单地重复我们发布的任何内容。因此，如果我们“POST”一个JSON对象，它将返回JSON对象。因此，我们将只发布纯文本：
- en: '[PRE71]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'As you can see from the following Terminal output, this returns the message
    we have posted:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以从以下终端输出中看到的那样，这将返回我们发布的消息：
- en: '![](assets/9e37db66-c2f4-43b5-9be1-6296c995ce70.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9e37db66-c2f4-43b5-9be1-6296c995ce70.png)'
- en: Now, you maybe thinking to yourself that this seems like a pretty silly example.
    However, what we have done here is taken the content of an HTTP request and posted
    it to a Linux binary, which was executed with the content we have posted. We then
    had the output of the command running returned via an HTTP request.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会认为这似乎是一个相当愚蠢的例子。然而，我们在这里所做的是获取HTTP请求的内容，并将其发布到Linux二进制文件中，然后使用我们发布的内容执行它。然后，我们通过HTTP请求返回运行命令的输出。
- en: At this point you may want to terminate/power down any Kubernetes clusters you
    have launched to test Fission with.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能希望终止/关闭您已经启动以测试Fission的任何Kubernetes集群。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have looked at Fission. We have installed it using Helm
    and deployed it both locally and in Google Cloud. We have also launched several
    test applications, some basic and some that call out to third-party services to
    both post and return information. During the installation and configuration of
    the example applications, I hope that you started to see the usefulness of Fission
    and how it, and other serverless technologies, can be integrated into your own
    applications.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经研究了Fission。我们使用Helm进行了安装，并在本地和Google Cloud上部署了它。我们还启动了几个测试应用程序，一些基本的，一些调用第三方服务来发布和返回信息。在安装和配置示例应用程序的过程中，我希望您开始看到Fission的用处以及它和其他无服务器技术如何集成到您自己的应用程序中。
- en: When I started writing the chapter, I hoped to include some sections on Fission
    workflows, and also the Fission UI. However, at the time of writing, both those
    add-ons failed to work. Now, don't get me wrong, Fission is a powerful and simple
    to use technology; however, it is very new and is still in development, as is
    Kubernetes—this means that until the code bases get more established, there will
    be feature breaking updates in new releases.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始写这一章时，我希望包括一些关于Fission工作流和Fission UI的部分。然而，在写作时，这两个附加组件都无法正常工作。现在，不要误会，Fission是一种强大且易于使用的技术；然而，它非常新，并且仍在开发中，就像Kubernetes一样——这意味着在代码基础变得更加稳定之前，新版本中会有破坏性的更新。
- en: For example, the version of Fission we installed, version 0.4.0, was released
    because the latest version of Kubernetes, version 1.8 at the time of writing,
    removed the `ThirdPartyResources` functionality and replaced it with `CustomResourceDefinitions`,
    which means that older versions of Fission will not work on current versions of
    Kubernetes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们安装的Fission版本0.4.0是因为在写作时，最新版本的Kubernetes 1.8删除了“ThirdPartyResources”功能，并用“CustomResourceDefinitions”替换，这意味着旧版本的Fission将无法在当前版本的Kubernetes上运行。
- en: We are going to be looking at the Kubernetes release cycle and how this may
    impact you in the remaining chapters.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在剩下的章节中研究Kubernetes的发布周期以及这可能对您产生的影响。
