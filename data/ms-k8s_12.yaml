- en: Customizing Kubernetes – API and Plugins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义Kubernetes - API和插件
- en: In this chapter, we will dig deep into the guts of Kubernetes. We will start
    with the Kubernetes API and learn how to work with Kubernetes programmatically
    via direct access to the API, the Python client, and then we will automate Kubectl.
    Then, we'll look into extending the Kubernetes API with custom resources. The
    last part is all about the various plugins Kubernetes supports. Many aspects of
    the Kubernetes operation are modular and designed for extension. We will examine
    several types of plugins, such as custom schedulers, authorization, admission
    control, custom metrics, and volumes. Finally, we'll look into extending Kubectl
    and adding your own commands.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究Kubernetes的内部。我们将从Kubernetes API开始，学习如何通过直接访问API、Python客户端来以编程方式使用Kubernetes，然后我们将自动化Kubectl。然后，我们将研究如何使用自定义资源扩展Kubernetes
    API。最后一部分是关于Kubernetes支持的各种插件。Kubernetes操作的许多方面都是模块化的，并且设计用于扩展。我们将研究几种类型的插件，如自定义调度程序、授权、准入控制、自定义指标和卷。最后，我们将研究如何扩展Kubectl并添加自己的命令。
- en: 'The topics we cover are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们涵盖的主题如下：
- en: Working with the Kubernetes API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes API
- en: Extending the Kubernetes API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展Kubernetes API
- en: Writing Kubernetes and Kubectl plugins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Kubernetes和Kubectl插件
- en: Writing webhooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写webhooks
- en: Working with the Kubernetes API
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes API
- en: The Kubernetes API is comprehensive and encompasses the entire functionality
    of Kubernetes. As you may expect, it is huge. But it is designed very well using
    best practices, and it is consistent. If you understand the basic principles,
    you can discover everything you need to know.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API是全面的，涵盖了Kubernetes的全部功能。正如您所期望的那样，它是庞大的。但它采用了最佳实践进行了良好设计，并且是一致的。如果您了解基本原则，您可以发现您需要了解的一切。
- en: Understanding OpenAPI
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解OpenAPI
- en: OpenAPI allows API providers to define their operations and models, and enables
    developers to automate their tools and generate their favorite language's client
    to talk to that API server. Kubernetes has supported Swagger 1.2 (an older version
    of the OpenAPI spec) for a while, but the spec was incomplete and invalid, making
    it hard to generate tools/clients based on it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI允许API提供者定义其操作和模型，并使开发人员能够自动化其工具并生成其喜爱的语言客户端以与该API服务器通信。Kubernetes已经支持Swagger
    1.2（OpenAPI规范的旧版本）一段时间了，但规范是不完整和无效的，这使得基于它生成工具/客户端变得困难。
- en: In Kubernetes 1.4, alpha support was added for the OpenAPI spec (formerly known
    as **Swagger 2.0** before it was donated to the OpenAPI Initiative) and current
    models and operations were updated. In Kubernetes 1.5, support for the OpenAPI
    spec has been completed by auto-generating the spec directly from the Kubernetes
    source, which keeps the spec and documentation completely in sync with future
    changes in operations/models.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes 1.4中，为OpenAPI规范（在捐赠给OpenAPI倡议之前被称为Swagger 2.0）添加了alpha支持，并更新了当前的模型和操作。在Kubernetes
    1.5中，通过直接从Kubernetes源自动生成规范来完成了对OpenAPI规范的支持，这使得规范和文档与操作/模型的未来变化完全同步。
- en: The new spec enables better API documentation and an auto-generated Python client
    that we will explore later.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 新规范使API文档更好，并且我们将在以后探索自动生成的Python客户端。
- en: The spec is modular and divided by group version. This is future-proof. You
    can run multiple API servers that support different versions. Applications can
    transition gradually to newer versions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 该规范是模块化的，并按组版本划分。这是未来的保证。您可以运行支持不同版本的多个API服务器。应用程序可以逐渐过渡到更新的版本。
- en: The structure of the spec is explained in detail in the OpenAPI spec definition.
    The Kubernetes team used the operation's tags to separate each group version and
    fill in as much information as possible about paths/operations and models. For
    a specific operation, all parameters, calling methods, and responses are documented.
    The result is impressive.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 规范的结构在OpenAPI规范定义中有详细解释。Kubernetes团队使用操作标签来分隔每个组版本，并尽可能填写有关路径/操作和模型的信息。对于特定操作，所有参数、调用方法和响应都有文档记录。结果令人印象深刻。
- en: Setting up a proxy
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置代理
- en: 'To simplify access, you can use Kubectl to set up a proxy:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化访问，您可以使用Kubectl设置代理：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, you can access the API server at `http://localhost:8080` and it will reach
    the same Kubernetes API server that Kubectl is configured for.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以访问`http://localhost:8080`的API服务器，并且它将到达与Kubectl配置相同的Kubernetes API服务器。
- en: Exploring the Kubernetes API directly
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接探索Kubernetes API
- en: The Kubernetes API is easy to find out about. You can just browse to the URL
    of the API server at `http://localhost:8080` and get a nice JSON document that
    describes all the available operations under the paths key.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API很容易找到。您只需浏览到API服务器的URL`http://localhost:8080`，就可以获得一个描述路径键下所有可用操作的漂亮JSON文档。
- en: 'Here is a partial list due to space constraints:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空间限制，这里是部分列表：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can drill down any one of the paths. For example, here is the response
    from the `/api/v1/namespaces/default` endpoint:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以深入了解任何一个路径。例如，这是来自`/api/v1/namespaces/default`端点的响应：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I discovered this endpoint by going first to `/api`, then discovered `/api/v1`,
    which told me there is `/api/v1/namespaces`, which pointed me to `/api/v1/namespaces/default`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先通过访问`/api`，然后发现了`/api/v1`，告诉我有`/api/v1/namespaces`，指引我到`/api/v1/namespaces/default`。
- en: Using Postman to explore the Kubernetes API
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Postman探索Kubernetes API
- en: Postman ([https://www.getpostman.com](https://www.getpostman.com)) is a very
    polished application for working with RESTful APIs. If you lean more to the GUI
    side, you may find it extremely useful.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Postman ([https://www.getpostman.com](https://www.getpostman.com))是一个非常成熟的用于处理RESTful
    API的应用程序。如果您更倾向于GUI界面，您可能会发现它非常有用。
- en: 'The following screenshot shows the available endpoints under the batch `V1`
    API group:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了批处理`V1` API组下可用的端点：
- en: '![](Images/7fc19510-4e98-41c9-8439-f449c6bed88b.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7fc19510-4e98-41c9-8439-f449c6bed88b.png)'
- en: Postman has a lot of options, and it organizes the information in a very pleasing
    way. Give it a try.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Postman有很多选项，并且以非常令人愉悦的方式组织信息。试试看吧。
- en: Filtering the output with httpie and jq
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用httpie和jq过滤输出
- en: 'The output from the API can be too verbose sometimes. Often, you''re interested
    just in one value out of a huge chunk of JSON responses. For example, if you want
    to get the names of all running services, you can hit the `/api/v1/services` endpoint.
    The response, however, includes a lot of additional information that is irrelevant.
    Here is a very partial subset of the output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: API的输出有时可能太冗长。通常，您只对大量JSON响应中的一个值感兴趣。例如，如果您想获取所有运行服务的名称，可以访问`/api/v1/services`端点。然而，响应中包含许多无关的附加信息。这里是输出的一个非常部分子集：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The complete output is 121 lines long! Let's see how to use `httpie` and `jq`
    to gain full control over the output and show only the names of the services.
    I prefer ([https://httpie.org/](https://httpie.org/)) over CURL for interacting
    with REST APIs on the command line. The `jq` ([https://stedolan.github.io/jq/](https://stedolan.github.io/jq/))
    command-line JSON processor is great for slicing and dicing JSON.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的输出有121行长！让我们看看如何使用`httpie`和`jq`来完全控制输出，并仅显示服务的名称。我更喜欢([https://httpie.org/](https://httpie.org/))而不是CURL来与命令行上的REST
    API进行交互。`jq` ([https://stedolan.github.io/jq/](https://stedolan.github.io/jq/))命令行JSON处理器非常适合切割和处理JSON。
- en: 'Examining the full output, you can see that the service names are in the metadata
    sections of each item in the items array. The `jq` expression that will select
    just the `name` is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 检查完整的输出，您会看到服务名称在items数组中每个项目的metadata部分。将选择`name`的`jq`表达式如下：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the full command and output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的命令和输出：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating a pod via the Kubernetes API
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Kubernetes API创建一个pod
- en: 'The API can be used for creating, updating, and deleting resources too, given
    the following pod manifest in `nginx-pod.json`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: API也可以用于创建、更新和删除资源，只要提供`nginx-pod.json`中的pod清单：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following command will create the pod through the API:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将通过API创建pod：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To verify that it worked, let''s extract the name and status of the current
    pods. The endpoint is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 验证它是否有效，让我们提取当前pod的名称和状态。端点如下：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `jq` expression is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`jq`表达式如下：'
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is the full command and output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的命令和输出：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Accessing the Kubernetes API via the Python client
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Python客户端访问Kubernetes API
- en: Exploring the API interactively using `httpie` and `jq` is great, but the real
    power of API comes when you consume and integrate it with other software. The
    Kubernetes incubator project provides a full-fledged and very well-documented
    Python `client` library. It is available at `https://github.com/kubernetes-incubator/client-python`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`httpie`和`jq`交互地探索API非常棒，但当您将其与其他软件消耗和集成时，API的真正力量就会显现出来。Kubernetes孵化器项目提供了一个功能齐全且文档非常完善的Python`client`库。它可以在`https://github.com/kubernetes-incubator/client-python`上找到。
- en: 'First, make sure you have Python installed (either 2.7 or 3.5+). Then install
    the Kubernetes package:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先确保已安装Python（2.7或3.5+）。然后安装Kubernetes包：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To start talking to a Kubernetes cluster, you need to connect to it. Start
    an interactive Python session:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始与Kubernetes集群通信，您需要连接到它。启动一个交互式的Python会话：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The Python client can read your Kubectl config:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Python客户端可以读取您的Kubectl配置：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Or it can connect directly to an already running proxy:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它可以直接连接到已经运行的代理：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that the client module provides methods to get access to different group
    versions, such as `CoreV1API`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，客户端模块提供了访问不同组版本的方法，例如`CoreV1API`。
- en: Dissecting the CoreV1API group
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解剖CoreV1API组
- en: 'Let''s dive in and understand the `CoreV1API` group. The Python object has
    `481 public attributes`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解`CoreV1API`组。Python对象有`481个公共属性`：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Ignore the `attributes` that starts with double underscores because those are
    special `class/instance` methods unrelated to Kubernetes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略以双下划线开头的`属性`，因为它们是与Kubernetes无关的特殊`class/instance`方法。
- en: 'Let''s pick ten random methods and see what they look like:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们随机挑选十个方法，看看它们是什么样子的：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Very interesting. The `attributes` begin with a verb such as list, patch, or
    read. Many of them have this notion of a `namespace`, and many have a `with_http_info`
    suffix. To understand the better, let''s count how many verbs exist and how many
    `attributes` use each verb (where the verb is the first token before the underscore):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 非常有趣。`属性`以动词开头，比如list、patch或read。其中许多都有`namespace`的概念，许多都有`with_http_info`后缀。为了更好地理解，让我们统计有多少动词存在，以及每个动词使用了多少`属性`（其中动词是下划线之前的第一个标记）：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can drill further and look at the interactive help for a specific `attribute`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步深入，查看特定`属性`的交互式帮助：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can poke around yourself and learn more about the API. Let's look at some
    common operations, such as listing, creating, watching, and deleting objects.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自己查看并了解有关API的更多信息。让我们看一些常见操作，如列出、创建、观察和删除对象。
- en: Listing objects
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出对象
- en: 'You can list different kinds of object. The method names start with `list_`.
    Here is an example listing all namespaces:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以列出不同类型的对象。方法名称以`list_`开头。以下是列出所有命名空间的示例：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Creating objects
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对象
- en: 'To create an object, you need to pass a body parameter to the create method.
    The body must be a Python dictionary that is equivalent to a YAML configuration
    file you would use with Kubectl. The easiest way to do it is to actually use a
    YAML and then use the Python YAML module (this is not part of the standard library
    and must be installed separately) to read the YAML file and load it into a dictionary.
    For example, to create an `nginx-deployment` with `3` replicas, we can use this
    YAML configuration file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个对象，您需要将一个body参数传递给create方法。body必须是一个等同于您在Kubectl中使用的YAML配置文件的Python字典。最简单的方法是实际使用YAML，然后使用Python
    YAML模块（这不是标准库的一部分，必须单独安装）来读取YAML文件并将其加载到字典中。例如，要创建一个带有`3`个副本的`nginx-deployment`，我们可以使用这个YAML配置文件：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To install the `yaml` Python module, type this command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`yaml` Python模块，请输入以下命令：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then the following Python program will create the deployment:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后以下Python程序将创建部署：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Watching objects
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察对象
- en: 'Watching objects is an advanced capability. It is implemented using a separate
    watch module. Here is an example to watch for `10` namespace events and print
    them to the screen:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 观察对象是一种高级功能。它是使用单独的观察模块实现的。以下是一个示例，用于观察`10`个命名空间事件并将它们打印到屏幕上：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Invoking Kubectl programmatically
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以编程方式调用Kubectl
- en: 'If you''re not a Python developer and don''t want to deal with the REST API
    directly, you have another option. Kubectl is used mostly as an interactive command-line
    tool, but nothing is stopping you from automating it and invoking it through scripts
    and programs. Here are some of the benefits of using Kubectl as your Kubernetes
    API client:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不是Python开发人员，也不想直接处理REST API，那么您还有另一种选择。Kubectl主要用作交互式命令行工具，但没有任何阻止您自动化它并通过脚本和程序调用它。使用Kubectl作为Kubernetes
    API客户端的一些好处包括：
- en: Easy to find examples for any usage
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于找到任何用法的示例
- en: Easy to experiment on the command line to find the right combination of commands
    and arguments
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行上轻松实验，找到正确的命令和参数组合
- en: Kubectl supports output in JSON or YAML for quick parsing
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubectl支持以JSON或YAML格式输出，以便快速解析。
- en: Authentication is built-in via Kubectl configuration
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证是通过Kubectl配置内置的
- en: Using Python subprocess to run Kubectl
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python子进程运行Kubectl
- en: 'I''ll use Python again, so you can compare using the official Python client
    with rolling your own. Python has a module called `subprocess` that can run external
    processes such as Kubectl and capture the output. Here is a Python 3 example running
    Kubectl on its own and displaying the beginning of the usage output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我将再次使用Python，这样您可以比较使用官方Python客户端和自己编写的客户端。Python有一个名为`subprocess`的模块，可以运行Kubectl等外部进程并捕获输出。以下是一个Python
    3示例，独立运行Kubectl并显示用法输出的开头：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Kubectl controls the Kubernetes cluster manager. Find more information at [https://github.com/kubernetes/kubernetes](https://github.com/kubernetes/kubernetes).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl控制Kubernetes集群管理器。在[https://github.com/kubernetes/kubernetes](https://github.com/kubernetes/kubernetes)找到更多信息。
- en: '**Here are some basic commands for beginners**:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些初学者的基本命令：
- en: '`create`: Create a resource using the filename or `stdin`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`：使用文件名或`stdin`创建资源'
- en: '`expose`: Take a replication controller, service, deployment, or pod'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expose`：获取复制控制器、服务、部署或pod'
- en: 'The `check_checkout()` function captures the output as a bytes array that needs
    to be decoded to `utf-8` to display it properly. We can generalize it a little
    bit and create a convenience function called `k` that accepts parameters it feeds
    to Kubectl, and then decodes the output and returns it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`check_checkout()`函数将输出捕获为一个需要解码为`utf-8`以正确显示的字节数组。我们可以将其概括一点，并创建一个名为`k`的便利函数，它接受参数并将其传递给Kubectl，然后解码输出并返回它：'
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is nice for display, but Kubectl already does that. The real power comes
    when you use the structured output options with the `-o` flag. Then the result
    can be converted automatically to a Python object. Here is a modified version
    of the `k()` function that accepts a Boolean `use_json` keyword argument (default
    is `False`); if `True` adds `-o json` and then parses the JSON output to a Python
    object (dictionary):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于显示很好，但Kubectl已经做到了。当您使用带有`-o`标志的结构化输出选项时，真正的力量就会显现出来。然后结果可以自动转换为Python对象。这是`k()`函数的修改版本，它接受一个布尔值`use_json`关键字参数（默认为`False`）；如果为`True`，则添加`-o
    json`，然后将JSON输出解析为Python对象（字典）：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'That returns a full-fledged API object, which can be navigated and drilled
    down just like when accessing the REST API directly or using the official Python
    client:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个完整的API对象，可以像直接访问REST API或使用官方Python客户端一样进行导航和钻取：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s see how to delete the `deployment` and wait until all the pods are gone.
    The Kubectl delete command doesn''t accept the `-o json` option (although it has
    `-o` name), so let''s leave out `use_json`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何删除`deployment`并等待所有pod消失。Kubectl delete命令不接受`-o json`选项（尽管有`-o`名称），所以让我们不使用`use_json`：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Extending the Kubernetes API
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Kubernetes API
- en: Kubernetes is an extremely flexible platform. It allows you to extend its own
    API with new types of resources called custom resources. If that is not enough
    you can even provide your API server that integrates with the Kubernetes API server
    in a mechanism called API aggregation. What can you do with custom resources?
    Plenty. You can use them to manage the Kubernetes API resources that live outside
    the Kubernetes cluster, which your pods communicate with.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是一个非常灵活的平台。它允许您通过称为自定义资源的新类型资源扩展自己的API。如果这还不够，您甚至可以提供与Kubernetes API服务器集成的API聚合机制。您可以用自定义资源做什么？很多。您可以使用它们来管理Kubernetes集群外部的Kubernetes
    API资源，您的pod与之通信。
- en: 'By adding those external resources as custom resources, you get a full picture
    of your system and you benefit from many Kubernetes API features such as the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些外部资源添加为自定义资源，您可以全面了解系统，并从许多Kubernetes API功能中受益，例如以下功能：
- en: Custom CRUD REST endpoints
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义CRUD REST端点
- en: Versioning
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制
- en: Watches
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察
- en: Automatic integration with generic Kubernetes tooling
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与通用Kubernetes工具的自动集成
- en: Other use cases for custom resources are metadata for custom controllers and
    automation programs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义控制器和自动化程序的元数据
- en: Custom resources that were introduced in Kubernetes 1.7 are a significant improvement
    over the now deprecated third-party resources. Let's dive in and see what custom
    resources are all about.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes 1.7中引入的自定义资源是对现在已弃用的第三方资源的重大改进。让我们深入了解一下自定义资源的全部内容。
- en: Understanding the structure of a custom resource
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解自定义资源的结构
- en: 'In order to play nice with the Kubernetes API server, third-party resources
    must conform to some basic requirements. Similar to built-in API objects, they
    must have the following fields:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与Kubernetes API服务器协作，第三方资源必须符合一些基本要求。与内置API对象类似，它们必须具有以下字段：
- en: '`apiVersion`: `apiextensions.k8s.io`/`v1beta1`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiVersion`：`apiextensions.k8s.io`/`v1beta1`'
- en: '`metadata`: Standard Kubernetes object metadata'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`：标准Kubernetes对象元数据'
- en: '`kind`: `CustomResourceDefinition`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`：`CustomResourceDefinition`'
- en: '`spec`: Describes how the resource appears in the API and tools'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec`：描述资源在API和工具中的外观'
- en: '`status`: Indicates the current status of the CRD'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`：指示CRD的当前状态'
- en: The spec has an internal structure that includes fields like group, names, scope,
    validation, and version. The status includes the fields `acceptedNames` and `Conditions`.
    In the next section, I'll show you an example that clarifies the meaning of these
    fields.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 规范具有内部结构，包括组、名称、范围、验证和版本等字段。状态包括字段`acceptedNames`和`Conditions`。在下一节中，我将为您展示一个示例，以阐明这些字段的含义。
- en: Developing custom resource definitions
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发自定义资源定义
- en: 'You develop your custom resources using custom resource definitions, aslo known
    as CRD. The intention is for CRDs to integrate smoothly with Kubernetes, its API,
    and its tooling, so you need to provide a lot of information. Here is an example
    for a custom resource called `Candy`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用自定义资源定义（也称为CRD）开发自定义资源。CRD的目的是与Kubernetes、其API和其工具平稳集成，因此您需要提供大量信息。这是一个名为`Candy`的自定义资源的示例：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s create it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建它：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that the metadata name with the plural notation is returned. Now, let''s
    verify that we can access it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，返回的元数据名称带有复数标记。现在，让我们验证一下我们是否可以访问它：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There is also a new API endpoint for managing this new resource:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个新的API端点用于管理这种新资源：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s use our Python code to access it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们的Python代码来访问它：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Integrating custom resources
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成自定义资源
- en: 'Once the `CustomResourceDefinition` object has been created, you can create
    custom resources of that resource kind in particular, `Candy` in this case (`candy`
    becomes `CamelCase Candy`). `Candy` objects can contain arbitrary fields with
    arbitrary JSON. In the following example, a `flavor` custom field is set on the
    `Candy` object. The `apiVersion` field is derived from the CRD spec''s group and
    version fields:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`CustomResourceDefinition`对象后，您可以特定地创建该资源类型的自定义资源，例如，在这种情况下是`Candy`（`candy`变为`CamelCase
    Candy`）。`Candy`对象可以包含任意字段和任意JSON。在下面的示例中，`flavor`自定义字段设置在`Candy`对象上。`apiVersion`字段是从CRD规范的组和版本字段派生的：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can add arbitrary fields to your custom resources. The values can be any
    JSON values. Note that these fields are not defined in the CRD. Different objects
    can have different fields. Let''s create it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向自定义资源添加任意字段。这些值可以是任何JSON值。请注意，这些字段未在CRD中定义。不同的对象可以具有不同的字段。让我们创建它：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'At this point, `kubectl` can operate on `Candy` objects just like it works
    on built-in objects. Note that resource names are case-insensitive when using
    `kubectl`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`kubectl`可以像操作内置对象一样操作`Candy`对象。请注意，在使用`kubectl`时，资源名称不区分大小写：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can also view the raw JSON data using the standard `-o json` flag. I''ll
    use the short name `cn` this time:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用标准的`-o json`标志查看原始JSON数据。这次我会使用简称`cn`：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finalizing custom resources
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成自定义资源
- en: 'Custom resources support finalizers just like standard API objects. A finalizer
    is a mechanism where objects are not deleted immediately but have to wait for
    special controllers that run in the background and watch for deletion requests.
    The controller may perform any necessary cleanup options and then remove its finalizer
    from the target object. There may be multiple finalizers on an object. Kubenetes
    will wait until all finalizers have been removed and only then delete the object.
    The finalizers in the metadata are just arbitrary strings that their corresponding
    controller can identify. Here is an example with a `Candy` object that has two
    finalizers, `eat-me` and `drink-me`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资源支持与标准API对象一样的finalizers。finalizer是一种机制，对象不会立即被删除，而是必须等待后台运行并监视删除请求的特殊控制器。控制器可以执行任何必要的清理操作，然后从目标对象中删除其finalizer。对象上可能有多个finalizer。Kubenetes将等待直到所有finalizer都被删除，然后才删除对象。元数据中的finalizer只是它们对应的控制器可以识别的任意字符串。这里有一个示例，其中`Candy`对象有两个finalizer，`eat-me`和`drink-me`：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Validating custom resources
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证自定义资源
- en: 'You can add any field to a CRD. This may cause invalid definitions. Kubernetes
    1.9 introduced a validation mechanism for CRDs based on the OpenAPI V3 schema.
    It''s still in beta and can be disabled using a feature gate when starting the
    API server:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向CRD添加任何字段。这可能导致无效的定义。Kubernetes 1.9引入了基于OpenAPI V3模式的CRD验证机制。它仍处于测试阶段，并且可以在启动API服务器时使用功能开关进行禁用：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In your CRD, you add a validation section to the spec:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的CRD中，您可以在规范中添加一个验证部分：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you try to create objects that violate the validation in the spec, you''ll
    get an error message. You can read more about the OpenAPI schema here: `http://bit.ly/2FsBfWA`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试创建违反规范验证的对象，您将收到错误消息。您可以在此处阅读有关OpenAPI模式的更多信息：`http://bit.ly/2FsBfWA`。
- en: Understanding API server aggregation
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解API服务器聚合
- en: CRDs are great when all you need is some CRUD operations on your own types.
    You can just piggyback on the Kubernetes API server, which will store your objects
    and provide API support and integration with tooling such as Kubectl. You can
    run controllers that watch for your objects and perform some operations when they
    are created, updated, or deleted. But CRDs have limitations. If you need more
    advanced features and customization, you can use API server aggregation and write
    your own API server that the Kubernetes API server will delegate to.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当您只需要对自己的类型进行一些CRUD操作时，CRDs非常好。您可以直接在Kubernetes API服务器上运行，它将存储您的对象并提供API支持和与诸如Kubectl之类的工具集成。您可以运行控制器来监视您的对象，并在创建、更新或删除时执行一些操作。但CRDs有局限性。如果您需要更高级的功能和定制，您可以使用API服务器聚合并编写自己的API服务器，Kubernetes
    API服务器将委托给它。
- en: 'Your API server will use the same API machinery as the Kubernetes API server
    itself. Some of the advanced capabilities are as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您的API服务器将使用与Kubernetes API服务器本身相同的API机制。一些高级功能如下：
- en: Controlling the storage of your objects
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制对象的存储
- en: Multi-versioning
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多版本
- en: Custom operations beyond CRUD (such as exec or scale)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超出CRUD的自定义操作（如exec或scale）
- en: Using protocol buffer payloads
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协议缓冲区有效载荷
- en: 'Writing an extension API server is a non-trivial effort. If you decide you
    need all that power, I recommend using the API builder project:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 编写扩展API服务器是一项非常艰巨的工作。如果您决定需要所有这些功能，我建议使用API构建器项目：
- en: '[https://github.com/kubernetes-incubator/apiserver-builder](https://github.com/kubernetes-incubator/apiserver-builder)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/kubernetes-incubator/apiserver-builder](https://github.com/kubernetes-incubator/apiserver-builder)'
- en: 'It is a young project, but it takes care of a lot of the necessary boilerplate
    code. The API builder provides the following capabilities:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个年轻的项目，但它处理了许多必要的样板代码。API构建器提供以下功能：
- en: Bootstrap complete type definitions, controllers, and tests, as well as documentation
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导完整的类型定义、控制器和测试，以及文档
- en: You can run the extension control plane locally, inside Minikube, or on an actual
    remote cluster
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在Minikube内部本地运行扩展控制平面，也可以在实际的远程集群上运行
- en: Your generated controllers will be able to watch and update API objects
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您生成的控制器将能够监视和更新API对象
- en: Adding resources (including sub-resources)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加资源（包括子资源）
- en: Default values you can override if needed
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，您可以覆盖默认值
- en: Utilizing the service catalog
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用服务目录
- en: 'The Kubernetes service catalog project allows you to integrate smoothly and
    painlessly any external service that support the Open Service Broker API specification:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes服务目录项目允许您平滑且无痛地集成任何支持Open Service Broker API规范的外部服务：
- en: '[https://github.com/openservicebrokerapi/servicebroker](https://github.com/openservicebrokerapi/servicebroker)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/openservicebrokerapi/servicebroker](https://github.com/openservicebrokerapi/servicebroker)'
- en: The intention of the open service broker API is to expose external services
    to any cloud environment through a standard specification with supporting documentation
    and a comprehensive test suite. That lets providers implement a single specification
    and supports multiple cloud environments. The current environments include Kubernetes
    and CloudFoundry. The project works towards broad industry adoption.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 开放服务经纪人API的目的是通过支持文档和全面的测试套件，通过标准规范将外部服务暴露给任何云环境。这使提供商可以实现单一规范，并支持多个云环境。当前的环境包括Kubernetes和CloudFoundry。该项目致力于广泛的行业采用。
- en: 'The service catalog is particularly useful for integrating the services of
    cloud platform providers. Here are some examples of such services:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 服务目录对于集成云平台提供商的服务特别有用。以下是一些此类服务的示例：
- en: Microsoft Azure Cloud Queue
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Azure Cloud Queue
- en: Amazon Simple Queue Service
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon Simple Queue Service
- en: Google Cloud Pub/Sub
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud Pub/Sub
- en: This capability is a boon for organizations that are committed to the cloud.
    You get to build your system on Kubernetes, but you don't have to deploy, manage,
    and maintain every service in your cluster yourself. You can offload that to your
    cloud provider, enjoy deep integration, and focus on your application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种能力对于致力于云计算的组织来说是一个福音。您可以在Kubernetes上构建系统，但不必自己部署、管理和维护集群中的每个服务。您可以将这些工作外包给您的云提供商，享受深度集成，并专注于您的应用程序。
- en: The service catalog can potentially make your Kubernetes cluster fully autonomous
    by allowing you to provision cloud resources through service brokers. We're not
    there yet, but the direction is very promising.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 服务目录有可能使您的Kubernetes集群完全自主，因为它允许您通过服务经纪人来配置云资源。我们还没有达到那一步，但这个方向非常有前途。
- en: This concludes our discussion of accessing and extending Kubernetes from the
    outside. In the next section, we will direct our gaze inward and look into customizing
    the inner workings of Kubernetes itself via plugins.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对从外部访问和扩展Kubernetes的讨论。在下一节中，我们将把目光投向内部，并研究通过插件自定义Kubernetes内部工作的方法。
- en: Writing Kubernetes plugins
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Kubernetes插件
- en: In this section, we will dive into the guts of Kubernetes and learn how to take
    advantage of its famous flexibility and extensibility. We will learn about the
    different aspects that can be customized via plugins, and how to implement such
    plugins and integrate them with Kubernetes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入研究Kubernetes的内部，并学习如何利用其著名的灵活性和可扩展性。我们将了解可以通过插件自定义的不同方面，以及如何实现这些插件并将其与Kubernetes集成。
- en: Writing a custom scheduler plugin
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义调度程序插件
- en: 'Kubernetes defines itself as a container scheduling and management system.
    As such, the scheduler is the most important component of Kubernetes. Kubernetes
    comes with a default scheduler, but allows for writing additional schedulers.
    To write your own custom scheduler, you need to understand what the scheduler
    does, how it is packaged, how to deploy your custom scheduler, and how to integrate
    your scheduler. The scheduler source code is available here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes将自己定义为容器调度和管理系统。因此，调度程序是Kubernetes最重要的组件。Kubernetes带有默认调度程序，但允许编写额外的调度程序。要编写自己的自定义调度程序，您需要了解调度程序的功能，它是如何打包的，如何部署您的自定义调度程序以及如何集成您的调度程序。调度程序源代码在这里可用：
- en: '[https://github.com/kubernetes/kubernetes/tree/master/pkg/scheduler](https://github.com/kubernetes/kubernetes/tree/master/pkg/scheduler)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/kubernetes/kubernetes/tree/master/pkg/scheduler](https://github.com/kubernetes/kubernetes/tree/master/pkg/scheduler)'
- en: In the rest of this section, we will dive deep into the source and examine data
    types, algorithms, and code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们将深入研究源代码，并检查数据类型、算法和代码。
- en: Understanding the design of the Kubernetes scheduler
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Kubernetes调度程序的设计
- en: The job of the scheduler is to find a node for newly created or restarted pods,
    and create a binding in the API server and run it there. If the scheduler can't
    find a suitable node for the pod, it will remain in pending state.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 调度程序的工作是为新创建或重新启动的pod找到一个节点，并在API服务器中创建一个绑定并在那里运行它。如果调度程序找不到适合pod的节点，它将保持在挂起状态。
- en: The scheduler
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度程序
- en: Most of the work of the scheduler is pretty generic—it figures out which pods
    need to be scheduled, updates their state, and runs them on the selected node.
    The custom part is how to map pods to nodes. The Kubernetes team recognized the
    need for custom scheduling, and the generic scheduler can be configured with different
    scheduling algorithms.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 调度程序的大部分工作都是相当通用的——它会找出哪些pod需要被调度，更新它们的状态，并在选定的节点上运行它们。定制部分是如何将pod映射到节点。Kubernetes团队意识到了需要定制调度的需求，通用调度程序可以配置不同的调度算法。
- en: 'The main data type is the Scheduler `struct` that contains a `Config struct`
    with lots of properties (this will soon be replaced by a `configurator` interface):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 主要数据类型是包含许多属性的调度程序`struct`，其中包含一个`Config struct`（这很快将被`configurator`接口替换）：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here is the `Config struct`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Config struct`：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Most of these are interfaces, so you can configure the scheduler with custom
    functionality. In particular, the scheduler algorithm is relevant if you want
    to customize pod scheduling.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 其中大多数是接口，因此您可以使用自定义功能配置调度程序。特别是，如果您想要自定义pod调度，则调度程序算法是相关的。
- en: Registering an algorithm provider
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册算法提供程序
- en: The scheduler has the concept of an algorithm provider and an algorithm. Together,
    they let you use the substantial functionality of the built-in scheduler in order
    to replace the core scheduling algorithm.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 调度程序具有算法提供程序和算法的概念。它们一起让您使用内置调度程序的重要功能，以替换核心调度算法。
- en: 'The algorithm provider lets you register new algorithm providers with the factory.
    There is already one custom provider registered, called `ClusterAutoScalerProvider`.
    We will see later how the scheduler knows which algorithm provider to use. The
    key file is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 算法提供程序允许您使用工厂注册新的算法提供程序。已经注册了一个名为`ClusterAutoScalerProvider`的自定义提供程序。稍后我们将看到调度程序如何知道使用哪个算法提供程序。关键文件如下：
- en: '[https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/algorithmprovider/defaults/defaults.go](https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/algorithmprovider/defaults/defaults.go)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/algorithmprovider/defaults/defaults.go](https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/algorithmprovider/defaults/defaults.go)'
- en: 'The `init()` function calls the `registerAlgorithmProvider()`, which you should
    extend to include your algorithm provider in addition to the default and `autoscaler`
    providers:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()`函数调用`registerAlgorithmProvider()`，您应该扩展它以包括您的算法提供程序以及默认和`autoscaler`提供程序：'
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In addition to registering the provider, you also need to register a fit predicate
    and a priority function, which are used to actually perform the scheduling.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了注册提供程序，您还需要注册适合谓词和优先级函数，这些函数用于实际执行调度。
- en: You can use the factory's `RegisterFitPredicate()` and `RegisterPriorityFunction2()`
    functions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用工厂的`RegisterFitPredicate()`和`RegisterPriorityFunction2()`函数。
- en: Configuring the scheduler
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置调度程序
- en: 'The scheduler algorithm is provided as part of the configuration. Custom schedulers
    can implement the `ScheduleAlgorithm` interface:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 调度程序算法作为配置的一部分提供。自定义调度程序可以实现`ScheduleAlgorithm`接口：
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When you run the scheduler, you can provide the name of the custom scheduler
    or a custom algorithm provider as a command-line argument. If none are provided,
    the default algorithm provider will be used. The command-line arguments to the
    scheduler are `--algorithm-provider` and `--scheduler-name`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行调度程序时，您可以提供自定义调度程序的名称或自定义算法提供程序作为命令行参数。如果没有提供，则将使用默认的算法提供程序。调度程序的命令行参数是`--algorithm-provider`和`--scheduler-name`。
- en: Packaging the scheduler
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包调度程序
- en: 'The custom scheduler runs as a pod inside the same Kubernetes cluster it oversees.
    It needs to be packaged as a container image. Let''s use a copy of the standard
    Kubernetes scheduler for demonstration purposes. We can build Kubernetes from
    the source to get a scheduler image:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义调度程序作为一个pod在同一个Kubernetes集群中运行。它需要被打包为一个容器镜像。让我们使用标准Kubernetes调度程序的副本进行演示。我们可以从源代码构建Kubernetes以获取调度程序镜像：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create the following Dockerfile:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下Dockerfile：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Use it to `build` a Docker image type:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它来`构建`一个Docker镜像类型：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, push the image to a container registry. I''ll use DockerHub here.
    You''ll need to create an account on DockerHub and log in before pushing your
    image:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将镜像推送到容器注册表。我会在这里使用DockerHub。您需要在DockerHub上创建一个帐户并登录，然后再推送您的镜像。
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that I built the scheduler locally, and in the Dockerfile I just copy it
    from the host into the image. That works when you deploy on the same OS that you
    build with. If this is not the case, then it may be better to insert the build
    commands into the Dockerfile. The price you pay is that you need to pull all of
    Kubernetes into the image.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在本地构建了调度程序，并且在Dockerfile中，我只是将它从主机复制到镜像中。当您在与构建相同的操作系统上部署时，这种方法是有效的。如果不是这种情况，那么最好将构建命令插入Dockerfile中。你需要付出的代价是需要将所有Kubernetes内容都拉入镜像中。
- en: Deploying the custom scheduler
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署自定义调度程序
- en: 'Now that the scheduler image is built and available in the registry, we need
    to create a Kubernetes deployment for it. The scheduler is, of course, critical,
    so we can use Kubernetes itself to ensure that it is always running. The following
    YAML file defines a deployment with a single replica and a few other bells and
    whistles, such as liveness and readiness probes:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调度程序镜像已构建并在注册表中可用，我们需要为其创建一个Kubernetes部署。调度程序当然是关键的，所以我们可以使用Kubernetes本身来确保它始终在运行。以下YAML文件定义了一个部署，其中包含一个单一副本和一些其他功能，如活跃和就绪探针：
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The name of the scheduler (`custom-scheduler` here) is important and must be
    unique. It will be used later to associate pods with the scheduler to schedule
    them. Note that the custom scheduler belongs in the `kube-system` namespace.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 调度程序的名称（这里是`custom-scheduler`）很重要，必须是唯一的。稍后将用它来将pod与调度程序关联起来进行调度。请注意，自定义调度程序属于`kube-system`命名空间。
- en: Running another custom scheduler in the cluster
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集群中运行另一个自定义调度程序
- en: 'Running another custom scheduler is as simple as creating the deployment. This
    is the beauty of this encapsulated approach. Kubernetes is going to run a second
    scheduler, which is a big deal, but Kubernetes is unaware of what''s going on.
    It just deploys a pod like any other pod, except this pod happens to be a custom
    scheduler:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 运行另一个自定义调度程序就像创建部署一样简单。这就是这种封装方法的美妙之处。Kubernetes将运行第二个调度程序，这是一件大事，但Kubernetes并不知道发生了什么。它只是部署一个pod，就像部署任何其他pod一样，只是这个pod碰巧是一个自定义调度程序：
- en: '[PRE50]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s verify that the scheduler pod is running:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证调度程序pod是否在运行：
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Our custom scheduler is running.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义调度程序正在运行。
- en: Assigning pods to the custom scheduler
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将pod分配给自定义调度程序
- en: 'OK. The custom scheduler is running alongside the default scheduler. But how
    does Kubernetes choose which scheduler to use when a pod needs scheduling? The
    answer is that the pod decides and not Kubernetes. The pod spec has an optional
    scheduler name field. If it''s missing, the default scheduler is used; otherwise,
    the specified scheduler is used. This is the reason the custom scheduler names
    must be unique. The name of the default scheduler is `default-scheduler`, in case
    you want to be explicit in your pod spec. Here is a pod definition that will be
    scheduled using the default scheduler:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。自定义调度程序正在与默认调度程序一起运行。但是当pod需要调度时，Kubernetes如何选择要使用的调度程序呢？答案是pod决定而不是Kubernetes。pod规范具有一个可选的调度程序名称字段。如果缺少，将使用默认调度程序；否则，将使用指定的调度程序。这就是自定义调度程序名称必须是唯一的原因。默认调度程序的名称是`default-scheduler`，如果您想在pod规范中明确表示。以下是将使用默认调度程序安排的pod定义：
- en: '[PRE52]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To have the `custom-scheduler` schedule this pod, change the pod spec to the
    following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要让`custom-scheduler`安排此pod，请将pod规范更改为以下内容：
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Verifying that the pods were scheduled using the custom scheduler
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证使用自定义调度程序安排了pod
- en: There are two primary ways to verify pods get scheduled by the correct scheduler.
    First, you can create pods that need to be scheduled by the custom scheduler before
    deploying the custom scheduler. The pods will remain in the pending state. Then,
    deploy the custom scheduler and the pending pods will be scheduled and start running.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要方法可以验证pod是否由正确的调度程序安排。首先，您可以创建需要由自定义调度程序安排的pod，然后部署自定义调度程序。这些pod将保持在挂起状态。然后，部署自定义调度程序，挂起的pod将被安排并开始运行。
- en: 'The other method is to check the event logs and look for scheduled events using
    this command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是检查事件日志，并使用以下命令查找已安排的事件：
- en: '[PRE54]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Employing access control webhooks
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用访问控制webhooks
- en: 'Kubernetes always provided ways for you to customize access control. In Kubernetes
    access control can be denoted as triple-A: Authentication, Authorization, and
    Admission control. In early versions, it was done through plugins that required
    Go programming, installing into your cluster, registration, and other invasive
    procedures. Now, Kubernetes lets you customize authentication, authorization,
    and admission control webhooks.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes始终为您提供自定义访问控制的方法。在Kubernetes中，访问控制可以表示为三A：认证、授权和准入控制。在早期版本中，通过需要Go编程的插件来完成，安装到您的集群中，注册和其他侵入性程序。现在，Kubernetes允许您自定义认证、授权和准入控制webhooks。
- en: Using an authentication webhook
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用认证webhook
- en: 'Kubernetes lets you extend the authentication process by injecting a webhook
    for bearer tokens. It requires two pieces of information: how to access the remote
    authentication service and the duration of the authentication decision (it defaults
    to two minutes).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes允许您通过注入用于bearer tokens的webhook来扩展认证过程。它需要两个信息：如何访问远程认证服务以及认证决定的持续时间（默认为两分钟）。
- en: 'To provide this information and enable authentication webhooks, start the API
    server with the following command-line arguments:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要提供这些信息并启用认证webhooks，请使用以下命令行参数启动API服务器：
- en: '`--runtime-config=authentication.k8s.io/v1beta1=true`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--runtime-config=authentication.k8s.io/v1beta1=true`'
- en: '`--authentication-token-webhook-config-file`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--authentication-token-webhook-config-file`'
- en: '`--authentication-token-webhook-cache-ttl`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--authentication-token-webhook-cache-ttl`'
- en: 'The configuration file uses the `kubeconfig` file format. Here is an example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件使用`kubeconfig`文件格式。以下是一个例子：
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note that a client certificate and key must be provided to Kubernetes for mutual
    authentication against the remote authentication service.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，必须向Kubernetes提供客户端证书和密钥，以进行与远程认证服务的相互认证。
- en: The cache TTL is useful because often users will make multiple consecutive requests
    to Kubernetes. Having the authentication decision cached can save a lot of round
    trips to the remote authentication service.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '缓存TTL很有用，因为通常用户会对Kubernetes进行多次连续请求。缓存认证决策可以节省大量与远程认证服务的往返。 '
- en: 'When an API HTTP request comes in, Kubernetes extracts the bearer token from
    its headers and posts a `TokenReview` JSON request to the remote authentication
    service through the webhook:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当API HTTP请求到来时，Kubernetes会从其标头中提取持有者令牌，并通过Webhook将`TokenReview` JSON请求发送到远程认证服务：
- en: '[PRE56]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The remote authentication service will respond with a decision. The status
    authentication will either be true or false. Here is an example of a successful
    authentication:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 远程认证服务将做出响应。认证状态将是true或false。以下是成功认证的示例：
- en: '[PRE57]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A rejected response is much more concise:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 拒绝的响应要简洁得多：
- en: '[PRE58]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Using an authorization webhook
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用授权Webhook
- en: The authorization webhook is very similar to the authentication webhook. It
    just requires a configuration file that is in the same format as the authentication
    webhook configuration file. There is no authorization caching because unlike authentication,
    the same user may make lots of requests to different API endpoints with different
    parameters and authorization decisions may be different, so caching is not a viable
    option.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 授权Webhook与认证Webhook非常相似。它只需要一个与认证Webhook配置文件格式相同的配置文件。由于与认证不同，同一用户可能会对不同参数的不同API端点进行大量请求，并且授权决策可能不同，因此缓存不是一个可行的选项。
- en: 'You configure the webhook by passing the following command-line arguments to
    the API server:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过向API服务器传递以下命令行参数来配置Webhook：
- en: '`--runtime-config=authorization.k8s.io/v1beta1=true`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--runtime-config=authorization.k8s.io/v1beta1=true`'
- en: '`--authorization-webhook-config-file=<configuration filename>`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--authorization-webhook-config-file=<configuration filename>`'
- en: 'When a request passes authentication, Kubernetes will send a `SubjectAccessReview`
    JSON object to the remote authorization service. It will contain the request user
    as well as requested resource and other request attributes:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求经过认证时，Kubernetes将向远程授权服务发送`SubjectAccessReview` JSON对象。它将包含请求用户以及请求的资源和其他请求属性：
- en: '[PRE59]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The request will be allowed:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请求将被允许：
- en: '[PRE60]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Or it will be disallowed (with a reason):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 否则将被拒绝（并附带原因）：
- en: '[PRE61]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: A user may be authorized to access a resource, but not non-resource attributes
    such as /`api`, /`apis`, /`metrics`, /`resetMetrics`, /`logs`, /`debug`, /`healthz`,
    `/swagger-ui/`, `/swaggerapi/`, `/ui`, and `/version`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可能被授权访问资源，但不能访问非资源属性，如/`api`、/`apis`、/`metrics`、/`resetMetrics`、/`logs`、/`debug`、/`healthz`、`/swagger-ui/`、`/swaggerapi/`、`/ui`和`/version`。
- en: 'Here is how to request access to the logs:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何请求访问日志：
- en: '[PRE62]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Using an admission control webhook
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用准入控制Webhook
- en: 'Dynamic admission control supports webhooks too. It is still in alpha. You
    need to enable the generic admission webhook by passing the following command-line
    arguments to the API server:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 动态准入控制也支持Webhook。它仍处于alpha阶段。您需要通过向API服务器传递以下命令行参数来启用通用准入Webhook：
- en: '`--admission-control=GenericAdmissionWebhook`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--admission-control=GenericAdmissionWebhook`'
- en: '`--runtime-config=admissionregistration.k8s.io/v1alpha1`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--runtime-config=admissionregistration.k8s.io/v1alpha1`'
- en: Configuring webhook admission controller on the fly
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态配置Webhook准入控制器
- en: 'The authentication and authorization webhooks must be configured when you start
    the API server. The admission control webhooks can be configured dynamically by
    creating `externaladmissionhookconfiguration` objects:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动API服务器时，必须配置认证和授权Webhook。可以通过创建`externaladmissionhookconfiguration`对象来动态配置准入控制Webhook：
- en: '[PRE63]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Providing custom metrics for horizontal pod autoscaling
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为水平Pod自动缩放提供自定义指标
- en: 'Prior to Kubernetes 1.6, custom metrics were implemented as a Heapster model.
    In Kubernetes 1.6, a new custom metrics API landed and matured gradually. As of
    Kubernetes 1.9, they are enabled by default. Custom metrics rely on API aggregation.
    The recommended path is to start with the custom metrics API server boilerplate
    available here:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes 1.6之前，自定义指标是作为Heapster模型实现的。在Kubernetes 1.6中，引入了一个新的自定义指标API，并逐渐成熟。截至Kubernetes
    1.9，它们已默认启用。自定义指标依赖于API聚合。推荐的路径是从这里开始使用自定义指标API服务器样板：
- en: '[https://github.com/kubernetes-incubator/custom-metrics-apiserver](https://github.com/kubernetes-incubator/custom-metrics-apiserver)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/kubernetes-incubator/custom-metrics-apiserver](https://github.com/kubernetes-incubator/custom-metrics-apiserver)'
- en: 'Then, you implement the `CustomMetricsProvider` interface:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您实现`CustomMetricsProvider`接口：
- en: '[PRE64]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Extending Kubernetes with custom storage
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义存储扩展Kubernetes
- en: Volume plugins are yet another type of plugin. Prior to Kubernetes 1.8, you
    had to write a Kublet plugin that required implementing, registration with Kubernetes,
    and linking with the Kubelet. Kubernetes 1.8 introduced the FlexVolume, which
    is much more versatile. Kubernetes 1.9 took it to the next level with the **Container
    Storage Interface** (**CSI**).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 卷插件是另一种类型的插件。在Kubernetes 1.8之前，您必须编写一个需要实现、注册到Kubernetes并与Kubelet链接的Kublet插件。Kubernetes
    1.8引入了FlexVolume，这是更加灵活的。Kubernetes 1.9通过**容器存储接口**（**CSI**）将其提升到了下一个级别。
- en: Taking advantage of FlexVolume
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用FlexVolume
- en: Kubernetes volume plugins are designed to support a particular type of storage
    or storage provider. There are numerous volume plugins, which we covered in [Chapter
    7](2651f39a-2cf8-4562-9729-bc8927b07e66.xhtml), *Handling Kubernetes Storage*.
    The existing volume plugins are more than enough for most users, but if you need
    to integrate with a storage solution that is not supported you must implement
    your own volume plugin, which is not trivial. If you want it to get accepted as
    an official Kubernetes plugin then you have to get through a rigorous approval
    process. But `FlexVolume` provides another path. It is a generic plugin that allows
    you to hook up your unsupported storage backend without deep integration with
    Kubernetes itself.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes卷插件旨在支持特定类型的存储或存储提供程序。有许多卷插件，我们在[第7章](2651f39a-2cf8-4562-9729-bc8927b07e66.xhtml)中介绍了这些内容，*处理Kubernetes存储*。现有的卷插件对于大多数用户来说已经足够了，但是如果您需要集成一个不受支持的存储解决方案，您必须实现自己的卷插件，这并不是微不足道的。如果您希望它被接受为官方的Kubernetes插件，那么您必须经过严格的批准流程。但是`FlexVolume`提供了另一条路径。它是一个通用插件，允许您连接不受支持的存储后端，而无需与Kubernetes本身进行深度集成。
- en: '`FlexVolume` lets you add arbitrary attributes to the spec, and it communicates
    with your backend via a callout interface that includes the following operations:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlexVolume`允许您向规范添加任意属性，并通过调用接口与您的后端通信，该接口包括以下操作：'
- en: '**Attach**: Attaches a volume to the Kubernetes Kubelet node'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**附加**：将卷附加到Kubernetes Kubelet节点'
- en: '**Detach**: Detaches the volume from the Kubernetes Kubelet node'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分离**：从Kubernetes Kubelet节点分离卷'
- en: '**Mount**: Mounts the attached volume'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂载**：挂载附加的卷'
- en: '**Unmount**: Unmounts the attached volume'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卸载**：卸载附加的卷'
- en: Each operation is implemented by the backend driver as a binary that the FlexVolume
    invokes at the right time. The driver must be installed in `/usr/libexec/kubernetes/kubelet-plugins/volume/exec/<vendor>~<driver>/<driver>`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作都由后端驱动程序作为二进制实现，FlexVolume在正确的时间调用。驱动程序必须安装在`/usr/libexec/kubernetes/kubelet-plugins/volume/exec/<vendor>~<driver>/<driver>`中。
- en: Benefitting from CSI
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受益于CSI
- en: FlexVolume provides out-of-tree plugin capability, but it still requires the
    FlexVolume plugin itself and a somewhat cumbersome installation and invocation
    model. The CSI will improve on it significantly by having the vendor implement
    it directly. The best thing about it is that you, as a developer, don't have to
    create and maintain those plugins. It is the responsibility of the storage solution
    provider to implement and maintain the CSI, and it's in their interest to make
    it as robust as possible so that people don't choose a different storage solution
    that works out of the box on Kubernetes (and other platforms that integrate with
    CSI).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: FlexVolume提供了超出树插件的能力，但仍需要FlexVolume插件本身和一种相当繁琐的安装和调用模型。CSI将通过让供应商直接实现它来显著改进。最好的是，作为开发人员，你不必创建和维护这些插件。实现和维护CSI是存储解决方案提供商的责任，他们有兴趣尽可能地使其稳健，以便人们不选择在Kubernetes（以及与CSI集成的其他平台）上直接使用的不同存储解决方案。
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we covered three major topics: working with the Kubernetes
    API, extending the Kubernetes API, and writing Kubernetes plugins. The Kubernetes
    API supports the OpenAPI spec and is a great example of REST API design that follows
    all current best practices. It is very consistent, well organized, and well documented,
    yet it is a big API and is not easy to understand. You can access the API directly
    via REST over HTTP, using client libraries including the official Python client,
    and even by invoking Kubectl.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了三个主要主题：使用Kubernetes API、扩展Kubernetes API和编写Kubernetes插件。Kubernetes
    API支持OpenAPI规范，是REST API设计的一个很好的例子，遵循了所有当前的最佳实践。它非常一致、组织良好、文档完善，但它是一个庞大的API，不容易理解。你可以通过REST
    over HTTP直接访问API，使用包括官方Python客户端在内的客户端库，甚至通过调用Kubectl。
- en: Extending the Kubernetes API involves defining your own custom resources and
    optionally extending the API server itself via API aggregation. Custom resources
    are most effective when you combine them with additional custom plugins or controllers
    when you query and update them externally.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展Kubernetes API涉及定义自己的自定义资源，并通过API聚合可选地扩展API服务器本身。当你外部查询和更新它们时，自定义资源在与额外的自定义插件或控制器相结合时最有效。
- en: Plugins and webhooks are the foundation of Kubernetes design. Kubernetes was
    always meant to be extended by users to accommodate any need. We looked at various
    plugins and webhooks you can write and how to register and integrate them seamlessly
    with Kubernetes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 插件和webhooks是Kubernetes设计的基础。Kubernetes始终旨在由用户扩展以适应任何需求。我们看了一些你可以编写的插件和webhooks，以及如何注册和无缝集成它们到Kubernetes中。
- en: We also looked at custom metrics and even how to extend Kubernetes with custom
    storage options.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了自定义指标，甚至如何通过自定义存储选项扩展Kubernetes。
- en: At this point, you should be well aware of all the major mechanisms to extend,
    customize, and control Kubernetes through API access, custom resources, and custom
    plugins. You are in a great position to take advantage of these capabilities to
    augment the existing functionality of Kubernetes and adapt it to your needs and
    your systems.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你应该很清楚通过API访问、自定义资源和自定义插件来扩展、定制和控制Kubernetes的所有主要机制。你处于一个很好的位置，可以利用这些能力来增强Kubernetes的现有功能，并使其适应你的需求和系统。
- en: In the next chapter, we'll look at Helm, the Kubernetes package manager, and
    its charts. As you may have realized, deploying and configuring complex systems
    on Kubernetes is far from simple. Helm allows the grouping together of a bunch
    of manifests into a chart, which can be installed as a single unit.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下Helm，Kubernetes包管理器，以及它的图表。正如你可能已经意识到的那样，在Kubernetes上部署和配置复杂系统远非简单。Helm允许将一堆清单组合成一个图表，可以作为单个单元安装。
