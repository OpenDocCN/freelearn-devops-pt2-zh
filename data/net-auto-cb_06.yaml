- en: Administering a Multi-Vendor Network with NAPALM and Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NAPALM和Ansible管理多供应商网络
- en: '**Network Automation and Programmability Abstraction Layer with Multivendor
    support** (**NAPALM**), as the name implies, is a multi-vendor Python library
    intended to interact with different vendor equipment, and it provides a consistent
    method to interact with all these devices, irrespective of the vendor equipment
    used.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Network Automation and Programmability Abstraction Layer with Multivendor
    support** (**NAPALM**)，顾名思义，是一个旨在与不同供应商设备交互的多供应商Python库，并且它提供了一种一致的方法来与所有这些设备进行交互，无论使用的是哪种供应商设备。'
- en: In previous chapters, we have seen how to interact with different network devices
    using Ansible. However, for each vendor OS, we had to use a different Ansible
    module to support that specific OS. Furthermore, we saw that the data returned
    from each vendor OS is completely different. Although writing a playbook for multi-vendor
    devices is still possible, it requires the use of multiple different modules,
    and we need to work with the different data structures returned by these devices.
    This is the main issue that NAPALM tries to address. NAPALM attempts to provide
    an abstracted and consistent API to interact with multiple vendor OSes, while
    the data returned by NAPALM from these different vendor OSes is normalized and
    consistent.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们已经看到如何使用Ansible与不同的网络设备进行交互。然而，对于每个供应商操作系统，我们都必须使用不同的Ansible模块来支持特定的操作系统。此外，我们看到从每个供应商操作系统返回的数据完全不同。虽然编写多供应商设备的playbook仍然是可能的，但它需要使用多个不同的模块，并且我们需要处理这些设备返回的不同数据结构。这是NAPALM试图解决的主要问题。NAPALM试图提供一个抽象和一致的API来与多个供应商操作系统进行交互，而NAPALM从这些不同的供应商操作系统返回的数据是规范化和一致的。
- en: 'NAPALM interacts with each device according to the most common API supported
    by this node, and the API that is widely adopted by the community. The following
    diagram outlines how NAPALM interacts with the most common network devices, as
    well as the libraries used in NAPALM to interact with the APIs on these devices:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: NAPALM根据此节点支持的最常见API与每个设备进行交互，并且这个API被社区广泛采用。以下图表概述了NAPALM如何与最常见的网络设备进行交互，以及NAPALM用于与这些设备上的API进行交互的库：
- en: '![](assets/5b2f5635-b0ce-4775-bbf9-ecfb6f8b6664.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5b2f5635-b0ce-4775-bbf9-ecfb6f8b6664.png)'
- en: Since NAPALM tries to provide a consistent method to interact with network equipment,
    it supports a specific set of vendor devices. NAPALM also supports the most common
    tasks that are carried out on these devices, such as device configuration, retrieving
    the operational state for interfaces, **Border Gate Protocol** (**BGP**) and **Link
    Layer Discovery Protocol** (**LLDP**), and many others. For more information regarding
    the supported devices, as well as the supported methods when interacting with
    these devices, please check the following link: [https://napalm.readthedocs.io/en/latest/support/index.html](https://napalm.readthedocs.io/en/latest/support/index.html).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NAPALM试图提供一种与网络设备交互的一致方法，它支持特定一组供应商设备。NAPALM还支持在这些设备上执行的最常见任务，例如设备配置，检索接口的操作状态，**Border
    Gate Protocol** (**BGP**)和**Link Layer Discovery Protocol** (**LLDP**)等。有关支持的设备以及与这些设备交互时支持的方法的更多信息，请查看以下链接：[https://napalm.readthedocs.io/en/latest/support/index.html](https://napalm.readthedocs.io/en/latest/support/index.html)。
- en: 'In this chapter, we will outline how to automate a multi-vendor network using
    NAPALM and Ansible. We will outline how to manage the configuration of these different
    vendor OSes, as well as how to retrieve the operational state from these devices.
    We will base our illustration on the following sample network diagram of a basic
    service provider network:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将概述如何使用NAPALM和Ansible自动化多供应商网络。我们将概述如何管理这些不同供应商操作系统的配置，以及如何从这些设备中检索操作状态。我们将以基本服务提供商网络的以下示例网络图为基础进行说明：
- en: '![](assets/15260437-25fd-4d1c-b43f-ff366996233c.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/15260437-25fd-4d1c-b43f-ff366996233c.png)'
- en: 'The following table outlines the devices in our sample topology and their respective
    management **Internet Protocols** (**IPs**):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格概述了我们示例拓扑中的设备及其各自的管理**Internet Protocols** (**IPs**)：
- en: '| **Device** | **Role** | **Vendor** | **Management (MGMT) Port** | **MGMT
    IP** |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| **设备** | **角色** | **供应商** | **管理（MGMT）端口** | **MGMT IP** |'
- en: '| `mxp01` | P Router | Juniper vMX 14.1 | `fxp0` | `172.20.1.2` |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `mxp01` | P路由器 | Juniper vMX 14.1 | `fxp0` | `172.20.1.2` |'
- en: '| `mxp02` | P Router | Juniper vMX 14.1 | `fxp0` | `172.20.1.3` |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `mxp02` | P路由器 | Juniper vMX 14.1 | `fxp0` | `172.20.1.3` |'
- en: '| `mxpe01` | PE Router | Juniper vMX 14.1 | `fxp0` | `172.20.1.4` |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `mxpe01` | PE路由器 | Juniper vMX 14.1 | `fxp0` | `172.20.1.4` |'
- en: '| `mxpe01` | PE Router | Juniper vMX 17.1 | `fxp0` | `172.20.1.5` |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `mxpe01` | PE路由器 | Juniper vMX 17.1 | `fxp0` | `172.20.1.5` |'
- en: '| `xrpe03` | PE Router | Cisco XRv 6.1.2 | `Mgmt0/0/CPU0/0` | `172.20.1.6`
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `xrpe03` | PE路由器 | Cisco XRv 6.1.2 | `Mgmt0/0/CPU0/0` | `172.20.1.6` |'
- en: 'The main recipes covered in this chapter are shown in the following list:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要内容如下：
- en: Installing NAPALM and integrating with Ansible
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装NAPALM并与Ansible集成
- en: Building an Ansible network inventory
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Ansible网络清单
- en: Connecting and authenticating to network devices using Ansible
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible连接和认证网络设备
- en: Building the device configuration
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建设备配置
- en: Deploying configuration on network devices using NAPALM
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NAPALM在网络设备上部署配置
- en: Collecting device facts with NAPALM
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NAPALM收集设备信息
- en: Validating network reachability using NAPALM
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NAPALM验证网络可达性
- en: Validating and auditing networks with NAPALM
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NAPALM验证和审计网络
- en: Technical requirements
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found here: [https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch6_napalm](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch6_napalm).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在此处找到：[https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch6_napalm](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch6_napalm)。
- en: 'The following software will be required in this chapter:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将需要以下软件：
- en: Ansible machine running CentOS 7
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行CentOS 7的Ansible机器
- en: Ansible 2.9
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 2.9
- en: Juniper **Virtual MX** (**vMX**) router running Junos OS 14.1R8 and Junos OS
    17.1R1 release
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Juniper **Virtual MX** (**vMX**) 路由器运行Junos OS 14.1R8和Junos OS 17.1R1版本
- en: Cisco XRv router running IOS XR 6.1.2
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行IOS XR 6.1.2的Cisco XRv路由器
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：
- en: '[https://bit.ly/2Veox8j](https://bit.ly/2Veox8j)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/2Veox8j](https://bit.ly/2Veox8j)'
- en: Installing NAPALM and integrating with Ansible
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装NAPALM并与Ansible集成
- en: In this recipe, we outline how to install NAPALM and integrate it to work with
    Ansible. This task is mandatory since NAPALM Ansible modules are not part of the
    core modules that are shipped with Ansible by default. So, in order to start working
    with these modules, we need to install NAPALM and all of its Ansible modules.
    Then, we need to inform Ansible of where to find it and start working with the
    specific modules developed by the NAPALM team for Ansible.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们概述了如何安装NAPALM并将其集成到与Ansible一起工作。这个任务是强制性的，因为NAPALM Ansible模块不是默认随Ansible一起提供的核心模块的一部分。因此，为了开始使用这些模块，我们需要安装NAPALM及其所有Ansible模块。然后，我们需要告诉Ansible在哪里找到它，并开始使用NAPALM团队为Ansible开发的特定模块。
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ansible and Python 3 need to be installed on the machine, along with the `python3-pip`
    package, which we will use to install NAPALM.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible和Python 3需要安装在机器上，还需要安装`python3-pip`包，我们将用它来安装NAPALM。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Install the `napalm-ansible` Python package, as shown in the following code
    snippet:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`napalm-ansible` Python包，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the `napalm-ansible` command, as shown in the following code block:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`napalm-ansible`命令，如下面的代码块所示：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To ensure Ansible can use the NAPALM modules you will have to add the following
    configurtion to your Ansible configuration file (`ansible.cfg`):'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保Ansible可以使用NAPALM模块，您必须将以下配置添加到您的Ansible配置文件（`ansible.cfg`）中：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For more details on Ansible's configuration file, visit [https://docs.ansible.com/ansible/latest/intro_configuration.html](https://docs.ansible.com/ansible/latest/intro_configuration.html).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Ansible配置文件的更多详细信息，请访问[https://docs.ansible.com/ansible/latest/intro_configuration.html](https://docs.ansible.com/ansible/latest/intro_configuration.html)。
- en: 'Create a new folder called `ch6_napalm` and create the `ansible.cfg` file,
    updating it as shown in the following code block:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ch6_napalm`的新文件夹，并创建`ansible.cfg`文件，更新如下代码块所示：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Since the NAPALM package and corresponding NAPALM Ansible modules are not part
    of the core modules shipped and installed by default with Ansible, we need to
    install it on the system in order to start working with the NAPALM Ansible modules.
    The NAPALM team has shipped a specific Python package to install NAPALM along
    with all the Ansible modules and all the dependencies, in order to start working
    with NAPALM from inside Ansible. This package is `napalm-ansible`. We will use
    the `pip3` program to install this package since we are using Python 3.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NAPALM包和相应的NAPALM Ansible模块不是默认随Ansible一起提供和安装的核心模块的一部分，我们需要在系统上安装它，以便开始使用NAPALM
    Ansible模块。NAPALM团队已经发布了一个特定的Python包来安装NAPALM以及所有Ansible模块和所有依赖项，以便从Ansible内部开始使用NAPALM。这个包是`napalm-ansible`。由于我们使用Python
    3，我们将使用`pip3`程序来安装这个包。
- en: In order to tell Ansible where the Ansible module is installed, we need to enter
    the path for these modules into Ansible. The NAPALM team also provides simple
    instruction on how to find the path where the NAPALM modules are installed, and
    how to integrate it with Ansible via the `napalm-ansible` program. We execute
    the `napalm-ansible` command, which outputs the required configuration that we
    need to include in the `ansible.cfg` file so that Ansible can find the NAPALM
    modules that we will be using.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告诉Ansible模块安装在哪里，我们需要将这些模块的路径输入到Ansible中。NAPALM团队还提供了如何找到NAPALM模块安装路径以及如何通过`napalm-ansible`程序将其集成到Ansible的简单说明。我们执行`napalm-ansible`命令，它输出了我们需要包含在`ansible.cfg`文件中的所需配置，以便Ansible可以找到我们将要使用的NAPALM模块。
- en: We update the `ansible.cfg` file with the output that we obtained from the `napalm-ansible`
    command. We then update the library and action plugin options, which tell Ansible
    to include these folders in its path when it is searching for modules or action
    plugins. In the `ansible.cfg` file, we include the normal configuration that we
    used before in the previous chapters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用从`napalm-ansible`命令获得的输出更新`ansible.cfg`文件。然后，我们更新库和动作插件选项，告诉Ansible在搜索模块或动作插件时将这些文件夹包括在其路径中。在`ansible.cfg`文件中，我们包括了我们在前几章中使用的正常配置。
- en: Building an Ansible network inventory
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Ansible网络清单
- en: In this recipe, we will outline how to build and structure our Ansible inventory
    to describe our sample service provider network setup outlined in this chapter.
    Building an Ansible inventory is a mandatory step, in order to tell Ansible how
    to connect to the managed devices. In the case of NAPALM, we need to sort the
    different nodes in our network into the correct vendor types supported by NAPALM.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将概述如何构建和组织我们的Ansible清单，以描述本章中概述的样本服务提供商网络设置。构建Ansible清单是一个强制性步骤，为了告诉Ansible如何连接到受管设备。在NAPALM的情况下，我们需要将网络中的不同节点分类到NAPALM支持的正确供应商类型中。
- en: How to do it…
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Inside the new folder (`ch6_napalm`), we create a `hosts` file with the following
    content:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹（`ch6_napalm`）中，我们创建一个包含以下内容的`hosts`文件：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works…
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We built the Ansible inventory using the `hosts` file, and we defined multiple
    groups in order to segment our infrastructure, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`hosts`文件构建了Ansible清单，并定义了多个组，以便对基础设施进行分段，如下所示：
- en: We created the `PE` group, which references all the **Multiprotocol Label Switching**
    (**MPLS**) **Provider Edge** (**PE**) nodes in our topology.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了`PE`组，它引用了我们拓扑中的所有**多协议标签交换**（**MPLS**）**提供者边缘**（**PE**）节点。
- en: We created the `P` group, which references all the MPLS **Provider** (**P**)
    nodes in our topology.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了`P`组，它引用了我们拓扑中的所有MPLS **提供者**（**P**）节点。
- en: We created the `junos` group to reference all the Juniper devices in our topology.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了`junos`组，以引用我们拓扑中的所有Juniper设备。
- en: We created the `iosxr` group to reference all the nodes running IOS-XR.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了`iosxr`组来引用所有运行IOS-XR的节点。
- en: Segmenting and defining groups per vendor or per OS is a best practice when
    working with NAPALM since we use these groups to specify the required parameters
    needed by NAPALM to identify the vendor of the remotely managed node, and how
    to establish network connectivity with this remote node. In the next recipe, we
    will outline how we will employ these groups (`junos` and `iosxr`), and which
    parameters we will include in order for NAPALM to establish a connection to the
    remotely managed nodes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用NAPALM时，根据供应商或操作系统对组进行分割和定义是一种最佳实践，因为我们使用这些组来指定NAPALM识别远程管理节点的供应商所需的参数，并建立与该远程节点的网络连接的方式。在下一个教程中，我们将概述我们将如何使用这些组（`junos`和`iosxr`），以及我们将包括哪些参数以便NAPALM能够与远程管理节点建立连接。
- en: Connecting and authenticating to network devices using Ansible
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible连接和认证网络设备
- en: In this recipe, we will outline how to connect to both Juniper and IOS-XR nodes
    using Ansible, in order to start interacting with the devices.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将概述如何使用Ansible连接到Juniper和IOS-XR节点，以便开始与设备进行交互。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to follow along with this recipe, an Ansible inventory file should
    be constructed as per the previous recipe. Also, IP reachability between the Ansible
    control machine and all the devices in the network must be configured.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按照这个教程进行操作，应该按照之前的教程构建一个Ansible清单文件。此外，必须配置Ansible控制机与网络中所有设备之间的IP可达性。
- en: How to do it…
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'On the Juniper devices, configure the username and password, as shown in the
    following code block:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Juniper设备上，配置用户名和密码，如下所示：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On the Cisco IOS-XR devices, configure the username and password, as shown
    in the following code block:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Cisco IOS-XR设备上，配置用户名和密码，如下所示：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Enable the **Network Configuration Protocol** (**NETCONF**) on the Juniper
    devices, as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Juniper设备上启用**网络配置协议**（**NETCONF**），如下所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On the IOS-XR devices, we need to enable **Secure Shell** (**SSH**), as well
    as enable `xml-agent`, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IOS-XR设备上，我们需要启用**安全外壳**（**SSH**），以及启用`xml-agent`，如下所示：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On the Ansible machine, create the `group_vars` directory in the `ch6_napalm` folder,
    and create the `junos.yml` and `iosxr.yml` files, as shown in the following code
    block:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Ansible机器上，在`ch6_napalm`文件夹中创建`group_vars`目录，并创建`junos.yml`和`iosxr.yml`文件，如下所示：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Under the `group_vars` folder, create the `all.yml` file with the following
    login details:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`group_vars`文件夹下，创建带有以下登录详细信息的`all.yml`文件：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: NAPALM uses a specific transport API for each vendor equipment supported by
    NAPALM. It uses this API in order to connect to the device, so in our sample topology,
    we need NETCONF to be enabled on the Juniper devices. For Cisco IOS-XR devices,
    we need to enable SSH, as well as enabling the XML agent on the IOS-XR devices.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: NAPALM为NAPALM支持的每个供应商设备使用特定的传输API。它使用这个API来连接设备，所以在我们的示例拓扑中，我们需要在Juniper设备上启用NETCONF。对于Cisco
    IOS-XR设备，我们需要启用SSH，并在IOS-XR设备上启用XML agent。
- en: The username/password used on the Ansible control machine to authenticate with
    the devices must be configured on the remote nodes. We perform all these steps
    on the devices in order to make them ready for NAPALM to communicate with them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程节点上配置用于在Ansible控制机上进行身份验证的用户名/密码。我们在设备上执行所有这些步骤，以使它们准备好与NAPALM进行通信。
- en: Using the legacy `xml agent` on the IOS-XR devices in production is not recommended
    and needs to be evaluated as per the Cisco documentation. For further details,
    refer to [https://www.cisco.com/c/en/us/td/docs/routers/asr9000/software/asr9k_r5-3/sysman/command/reference/b-sysman-cr53xasr/b-sysman-cr53xasr_chapter_01010.html](https://www.cisco.com/c/en/us/td/docs/routers/asr9000/software/asr9k_r5-3/sysman/command/reference/b-sysman-cr53xasr/b-sysman-cr53xasr_chapter_01010.html).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中使用IOS-XR设备上的传统`xml agent`不被推荐，并且需要根据Cisco文档进行评估。有关更多详细信息，请参阅[https://www.cisco.com/c/en/us/td/docs/routers/asr9000/software/asr9k_r5-3/sysman/command/reference/b-sysman-cr53xasr/b-sysman-cr53xasr_chapter_01010.html](https://www.cisco.com/c/en/us/td/docs/routers/asr9000/software/asr9k_r5-3/sysman/command/reference/b-sysman-cr53xasr/b-sysman-cr53xasr_chapter_01010.html)。
- en: On the Ansible machine, we set the `ansible_connection` parameter per each vendor
    ( `netconf` for `juniper` and `network_cli` for `iosxr`), and we specify the `ansible_network_os` parameter
    to designate the vendor OS. All these parameters are defined under the `group_vars`
    hierarchy in `junos.yml` and `iosxr.yml`, corresponding to the groups that we
    defined in our inventory for grouping the devices on vendor OS basics. Finally,
    we specify the username and password via `ansible_user` and `ansible_ssh_pass`
    in the `all.yml` file, since we are using the same user to authenticate to both
    Juniper and Cisco devices.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible机器上，我们根据每个供应商设置`ansible_connection`参数（`juniper`使用`netconf`，`iosxr`使用`network_cli`），并指定`ansible_network_os`参数来指定供应商操作系统。所有这些参数都在`junos.yml`和`iosxr.yml`的`group_vars`层次结构下定义，对应于我们在清单中定义的用于根据供应商操作系统对设备进行分组的组。最后，我们在`all.yml`文件中通过`ansible_user`和`ansible_ssh_pass`指定用户名和密码，因为我们使用相同的用户来对Juniper和Cisco设备进行身份验证。
- en: 'To test and validate that, we can communicate with the devices from the Ansible
    control machine using the Ansible `ping` module, as shown in the following code
    block:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试和验证，我们可以使用Ansible的`ping`模块从Ansible控制机与设备进行通信，如下所示：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Building the device configuration
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建设备配置
- en: NAPALM doesn't provide declarative modules to configure the various system parameters
    on the managed devices, such as interfaces' BGP, **Quality of Service** (**QoS**),
    and so on. However, it provides a common API to push text-based configuration
    to all the devices, so it requires the configuration for the devices to be present
    in text format in order to push the required configuration. In this recipe, we
    will create the configuration for all our devices. This is the configuration that
    we will push to our devices using NAPALM, in the next recipe.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: NAPALM不提供声明性模块来配置受管设备上的各种系统参数，比如接口的BGP，**服务质量**（**QoS**）等。但是，它提供了一个通用的API来将基于文本的配置推送到所有设备，因此需要以文本格式存在设备的配置，以便推送所需的配置。在这个配方中，我们将为所有设备创建配置。这是我们将在下一个配方中使用NAPALM推送到设备的配置。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As a prerequisite for this recipe, an Ansible inventory file must be present.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个配方的先决条件，必须存在一个Ansible清单文件。
- en: How to do it…
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create a `roles` folder, and inside this folder, create a new role called `build_router_config`,
    as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`roles`文件夹，并在此文件夹内创建一个名为`build_router_config`的新角色，如下所示：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Use the exact same contents (Jinja2 templates and tasks) for the `build_router_config`
    role that we developed for Juniper devices in [Chapter 3](5e423ab2-1c5d-430d-a02d-7838c39c931a.xhtml),
    *Automating Juniper Devices in the Service Providers Using Ansible*, to generate
    the configuration for the devices. The directory layout should be as shown in
    the following code block:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与我们在[第3章](5e423ab2-1c5d-430d-a02d-7838c39c931a.xhtml)《使用Ansible自动化Juniper设备的服务提供商》中为Juniper设备开发的`build_router_config`角色完全相同的内容（Jinja2模板和任务）来为设备生成配置。目录布局应如下代码块所示：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a new folder called `iosxr` under the `templates` folder and populate
    it with the Jinja2 templates for the different IOS-XR configuration sections,
    as shown in the following code block:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates`文件夹下创建一个名为`iosxr`的新文件夹，并使用Jinja2模板填充它，以用于不同的IOS-XR配置部分，如下代码块所示：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Update the `group_vars/all.yml` file with the required data to describe our
    network topology, as shown in the following code block:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`group_vars/all.yml`文件，填入描述我们网络拓扑所需的数据，如下代码块所示：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a specific directory for each host in the `host_vars` directory, and
    in each directory, create the `bgp.yml` file with the following BGP peering content:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`host_vars`目录中为每个主机创建一个特定的目录，并在每个目录中创建带有以下BGP对等内容的`bgp.yml`文件：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a new playbook called `pb_napalm_net_build.yml` that utilizes the `build_router_config`
    role in order to generate the device configuration, as shown in the following
    code block:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pb_napalm_net_build.yml`的新playbook，该playbook利用`build_router_config`角色来生成设备配置，如下代码块所示：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In this recipe, our main goal is to create the device configuration that we
    will deploy on the devices in our sample topology. We are using the same Ansible
    role that we used to generate the configuration for Juniper devices in [Chapter
    3](5e423ab2-1c5d-430d-a02d-7838c39c931a.xhtml), *Automating Juniper Devices in
    the Service Providers Using Ansible*. The only addition to this role is that we
    are adding the required Jinja2 templates for IOS XR.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们的主要目标是创建设备配置，我们将在示例拓扑中的设备上部署。我们使用了与我们在[第3章](5e423ab2-1c5d-430d-a02d-7838c39c931a.xhtml)《使用Ansible自动化Juniper设备的服务提供商》中用于生成Juniper设备配置的相同的Ansible角色。这个角色的唯一补充是我们为IOS
    XR添加了所需的Jinja2模板。
- en: 'Here is a quick explanation of the steps, as a quick review:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是步骤的快速解释，作为快速回顾：
- en: Modeling the network via Ansible variables
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Ansible变量对网络进行建模
- en: We describe the different aspects of our network topology, such as **Peer-to-Peer** (**P2P**)
    interface, loopback interfaces, and **Open Shortest Path First** (**OSPF**) parameters
    under different data structures in the `group_vars/all.yml` file. For any host-specific
    data, we use the `host_vars` directory to populate all variables/parameters that
    are specific to a specific node, and, in our case, we use this approach for BGP
    data to outline `bgp_peers` variable for each node. This provides us with all
    the required data to populate the Jinja2 templates needed to generate the final
    configuration for each device in our sample network.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`group_vars/all.yml`文件中描述了网络拓扑的不同方面，比如**点对点**（**P2P**）接口，环回接口和**开放最短路径优先**（**OSPF**）参数，这些都是在不同的数据结构下。对于任何特定主机的数据，我们使用`host_vars`目录来填充所有特定于特定节点的变量/参数，而在我们的情况下，我们使用这种方法来为每个节点的BGP数据概述`bgp_peers`变量。这为我们提供了填充Jinja2模板所需的所有必要数据，以生成我们示例网络中每个设备的最终配置。
- en: Building the Jinja2 templates
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Jinja2模板
- en: 'We place all our Jinja2 templates in the `templates` folder inside our role,
    and we segment our Jinja2 templates per the vendor OS, each in a separate folder.
    Next, we create a Jinja2 template for each section of the configuration. The following
    code snippet outlines the directory structure for the templates folder:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有的Jinja2模板放在我们的角色内的`templates`文件夹中，并且我们根据供应商OS对我们的Jinja2模板进行分段，每个都放在一个单独的文件夹中。接下来，我们为配置的每个部分创建一个Jinja2模板。以下代码片段概述了模板文件夹的目录结构：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For a detailed explanation of the different Jinja2 templates used in this recipe
    and how they use the defined Ansible variables to generate the final configuration,
    please refer to [Chapter 3](5e423ab2-1c5d-430d-a02d-7838c39c931a.xhtml) of this
    book, *Automating Juniper Devices in the Service Providers Using Ansible*, since
    we are using the exact same network topology and the same data structures for
    both JunOS and IOS-XR devices.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此配方中使用的不同Jinja2模板的详细解释以及它们如何使用定义的Ansible变量来生成最终配置，请参阅本书的[第3章](5e423ab2-1c5d-430d-a02d-7838c39c931a.xhtml)《使用Ansible自动化Juniper设备的服务提供商》，因为我们对JunOS和IOS-XR设备使用了完全相同的网络拓扑和相同的数据结构。
- en: 'Running this playbook will generate the configuration for all the devices in
    our Ansible inventory in the `configs` folder, as shown in the following code
    block:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此playbook将在`configs`文件夹中为我们Ansible清单中的所有设备生成配置，如下代码块所示：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Deploying configuration on network devices using NAPALM
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NAPALM在网络设备上部署配置
- en: In this recipe, we will outline how to push configurations on different vendor
    devices using Ansible and NAPALM. NAPALM provides a single Ansible module for
    configuration management, and this module allows us to use a single common method
    to push any configuration on any vendor equipment supported by NAPALM, greatly
    simplifying Ansible playbooks.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将概述如何使用Ansible和NAPALM在不同的供应商设备上推送配置。NAPALM提供了一个用于配置管理的单个Ansible模块，该模块允许我们使用单一的通用方法在NAPALM支持的任何供应商设备上推送任何配置，大大简化了Ansible
    playbooks。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow along with this recipe, you will need to have an Ansible inventory
    already set up, with network reachability between the Ansible controller and the
    network devices established. The configuration that we will be pushing to the
    devices is the one we generated in the previous recipe.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照本配方进行操作，您需要已经设置好一个Ansible清单，并且在Ansible控制器和网络设备之间建立了网络可达性。我们将要推送到设备的配置是我们在上一个配方中生成的配置。
- en: How to do it…
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Update the `pb_napalm_net_build.yml` playbook file, and add the tasks shown
    in the following code block:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`pb_napalm_net_build.yml` playbook文件，并添加以下代码块中显示的任务：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works…
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As previously outlined, NAPALM provides a single Ansible module to push configurations
    to the network devices. It requires the configuration to be present in a text
    file. When it connects to the network device, it pushes the configuration to the
    respective device.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，NAPALM提供了一个单一的Ansible模块，用于将配置推送到网络设备。它要求配置存在于一个文本文件中。当它连接到网络设备时，它会将配置推送到相应的设备上。
- en: Since we are using a single configuration module that can be used across all
    the vendor OS devices supported by NAPALM, and since NAPALM uses a different connection
    API to manage the device, we need to tell the module the vendor OS for the device.
    We also need to provide the other parameters, such as username/password, to log
    in and authenticate with the device.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了一个可以在NAPALM支持的所有供应商OS设备上使用的单个配置模块，并且NAPALM使用不同的连接API来管理设备，因此我们需要告诉模块设备的供应商OS。我们还需要提供其他参数，例如用户名/密码，以便登录并与设备进行身份验证。
- en: 'The `napalm_install_config` module requires the following mandatory parameters
    in order to correctly log in to the managed device and push the configuration
    to it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`napalm_install_config`模块需要以下强制参数，以便正确登录到受管设备并将配置推送到设备上：'
- en: '`hostname`: This is the IP address through which we can reach the device. We
    supply the value of `ansible_host` for this parameter.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hostname`：这是我们可以通过其到达设备的IP地址。我们为此参数提供`ansible_host`的值。'
- en: '`username/password`: This is the username and password to connect to the device.
    We need to supply the `ansible_user` and `ansible_ssh_pass` attributes.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username/password`：这是连接到设备的用户名和密码。我们需要提供`ansible_user`和`ansible_ssh_pass`属性。'
- en: '`dev_os`: This parameter provides the vendor OS name that NAPALM requires in
    order to choose the correct API and the correct library to communicate with the
    device. For this option, we provide the `ansible_network_os` parameter.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev_os`：此参数提供了NAPALM需要的供应商OS名称，以便选择与设备通信的正确API和正确库。对于此选项，我们提供`ansible_network_os`参数。'
- en: 'The `napalm_install_config` module uses the following parameters to manage
    the configuration on remote devices:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`napalm_install_config`模块使用以下参数来管理远程设备上的配置：'
- en: '`config_file`: This provides the path of the configuration file containing
    the device configuration that needs to be pushed to the managed device.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config_file`：这提供了包含需要推送到受管设备的设备配置的配置文件的路径。'
- en: '`commit_changes`: This tells the device whether or not to commit the configuration.
    NAPALM provides a consistent method for configuration commits, even for devices
    that don''t support it by default (for instance, Cisco IOS devices).'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commit_changes`：这告诉设备是否提交配置。NAPALM提供了一种一致的配置提交方法，即使对于默认不支持的设备（例如Cisco IOS设备）也是如此。'
- en: '`replace_config`: This parameter controls how to merge between the existing
    configuration on the device and the configuration in the `config_file` parameter.
    In our case, since we are generating the whole device configuration and all the
    configuration sections are managed under Ansible, we replace the entire configuration
    with the configuration that we generate. This will cause any configuration on
    the device not present in our configuration file to be removed.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace_config`：此参数控制如何在设备上的现有配置和`config_file`参数中的配置之间进行合并。在我们的情况下，由于我们生成了整个设备配置，并且所有配置部分都在Ansible下进行管理，我们用我们生成的配置替换整个配置。这将导致设备上任何不在我们配置文件中的配置被删除。'
- en: 'As per the configuration outlined in this recipe, when we run the playbook
    using the `deploy` tag, NAPALM will connect to the device and push the configuration.
    However, it will not commit the configuration on the remote device, since we have
    specified the default value for `commit_changes` to be `no`. In case we need to
    push and commit the configuration on the remote device, we can set the value for
    the `commit` parameter to `yes` when running the playbook, as shown in the following
    code snippet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本配方中概述的配置，当我们使用`deploy`标签运行playbook时，NAPALM将连接到设备并推送配置。但是，它不会在远程设备上提交配置，因为我们已经将`commit_changes`的默认值指定为`no`。如果我们需要在远程设备上推送和提交配置，可以在运行playbook时将`commit`参数的值设置为`yes`，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There's more…
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `napalm_install_config` module provides extra options to control how to
    manage the configuration on the remote devices, such as the configuration diff.
    With this option, we can collect the differences between the running configuration
    on the device and the configuration that we will push via NAPALM. This option
    can be enabled as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`napalm_install_config`模块提供了额外的选项来控制如何管理远程设备上的配置，例如配置差异。通过此选项，我们可以收集设备上运行配置与我们将通过NAPALM推送的配置之间的差异。可以通过以下方式启用此选项：'
- en: 'Create a folder called `config_diff` to store the configuration diff captured
    by NAPALM, as shown in the following code block:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`config_diff`的文件夹，用于存储NAPALM捕获的配置差异，如下面的代码块所示：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Update the `pb_napalm_net_build.yml` playbook, as shown in the following code
    block:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`pb_napalm_net_build.yml` playbook，如下面的代码块所示：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next, we create a new folder to house all the configuration diff files that
    we will generate for each device, and add the `diff_file` parameter to the `napalm_install_config`
    module. This will collect the configuration diff for each device and save it to
    the `config_diff` directory for each device.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的文件夹，用于存放我们为每个设备生成的所有配置差异文件，并将`diff_file`参数添加到`napalm_install_config`模块。这将为每个设备收集配置差异，并将其保存到每个设备的`config_diff`目录中。
- en: 'When we run the playbook again with a modified configuration on the devices,
    we can see that the `config_diff` files for each device are generated, as shown
    in the following code block:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在设备上运行具有修改配置的playbook时，我们可以看到为每个设备生成的`config_diff`文件，如下面的代码块所示：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Collecting device facts with NAPALM
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NAPALM收集设备事实
- en: In this recipe, we will outline how to collect the operational state from network
    devices using the NAPALM fact-gathering Ansible module. This can be used to validate
    the network state across multi-vendor equipment since NAPALM Ansible's fact-gathering
    module returns a consistent data structure across all vendor OSes supported by
    NAPALM.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将概述如何使用NAPALM fact-gathering Ansible模块从网络设备中收集操作状态。这可以用来验证跨多供应商设备的网络状态，因为NAPALM
    Ansible的事实收集模块在NAPALM支持的所有供应商操作系统中返回一致的数据结构。
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow along with this recipe, it is assumed that an Ansible inventory is
    already in place and network reachability between the Ansible controller and the
    network is already established. Finally, the network is configured as per the
    previous recipe.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随这个配方，假设Ansible清单已经就位，并且Ansible控制器与网络之间的网络可达性已经建立。最后，网络已根据以前的配方进行了配置。
- en: How to do it…
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create an Ansible playbook named `pb_napalm_get_facts.yml` with the following
    content:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pb_napalm_get_facts.yml`的Ansible playbook，内容如下：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Update the playbook with the following tasks to validate the data returned
    by the NAPALM facts module:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下任务更新playbook以验证NAPALM事实模块返回的数据：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: We use the `napalm_get_facts` Ansible module to retrieve the operational state
    from the network devices. We supply the same parameters (`hostname`, `username/password`,
    and `dev_os`) that we used with `napalm_install_config` to be able to connect
    to the devices and collect the required operational state from these devices.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`napalm_get_facts` Ansible模块从网络设备中检索操作状态。我们提供与`napalm_install_config`使用的相同参数（`主机名`、`用户名/密码`和`dev_os`），以便能够连接到设备并从这些设备收集所需的操作状态。
- en: In order to control which information we retrieve using NAPALM, we use the `filter`
    parameter and supply the required information that we need to retrieve. In this
    example, we are limiting the data retrieved to `bgp_neighbors`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制我们使用NAPALM检索的信息，我们使用`filter`参数并提供我们需要检索的必要信息。在这个例子中，我们将检索的数据限制为`bgp_neighbors`。
- en: The `napalm_get_facts` module returns the data retrieved from the nodes as Ansible
    facts. This data can be retrieved from the `napalm_bgp_neighbors` variable, which
    stores all the NAPALM BGP facts retrieved from the device.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`napalm_get_facts`模块返回从节点检索的数据作为Ansible事实。这些数据可以从`napalm_bgp_neighbors`变量中检索，该变量存储从设备检索到的所有NAPALM
    BGP事实。'
- en: 'The following snippet outlines the output from `napalm_bgp_neighbors`, retrieved
    from a Junos OS device:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段概述了从Junos OS设备检索到的`napalm_bgp_neighbors`的输出：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following snippet outlines the output from `napalm_bgp_neighbors`, retrieved
    from an IOS-XR device:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段概述了从IOS-XR设备检索到的`napalm_bgp_neighbors`的输出：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we can see, the data returned from NAPALM for the BGP information from different
    network vendors is consistent between different network vendors. This simplifies
    parsing this data and allows us to run much simpler playbooks to validate the
    network state.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，不同网络供应商的NAPALM返回的BGP信息数据在不同网络供应商之间是一致的。这简化了解析这些数据，并允许我们运行更简单的playbook来验证网络状态。
- en: 'We use the data returned by NAPALM to compare and validate the operational
    state of the network against our network design, which we defined using Ansible
    variables such as `bgp_peers`. We use the `assert` module to validate multiple
    BGP information, such as the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用NAPALM返回的数据来比较和验证网络的操作状态与我们使用Ansible变量（如`bgp_peers`）定义的网络设计。我们使用`assert`模块来验证多个BGP信息，例如以下内容：
- en: Correct number of BGP peers
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的BGP对数
- en: BGP router ID
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BGP路由器ID
- en: All BGP sessions are operational
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有BGP会话都是可操作的
- en: We use the `when` statement in the different `assert` modules in scenarios in
    which we have a router in our topology that doesn't run BGP (`mxp02` is an example).
    Consequently, we skip these checks on these nodes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的`assert`模块中使用`when`语句的情况下，我们的拓扑中有一个不运行BGP的路由器（`mxp02`是一个例子）。因此，我们跳过这些节点上的这些检查。
- en: See also…
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅…
- en: The `napalm_get_fact` module can retrieve a huge range of information from the
    network devices based on the vendor equipment supported and the level of facts
    supported by this vendor. For example, it supports the retrieval of interfaces,
    IP addresses, and LLDP peers for almost all the known networking vendors.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`napalm_get_fact`模块可以根据供应商设备支持的设备和供应商支持的事实级别检索网络设备的大量信息。例如，它支持几乎所有已知网络供应商的接口、IP地址和LLDP对等体的检索。'
- en: 'For the complete documentation for the `napalm_get_facts` module, please check
    the following URL:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`napalm_get_facts`模块的完整文档，请查看以下URL：
- en: '[https://napalm.readthedocs.io/en/latest/integrations/ansible/modules/napalm_get_facts/index.html](https://napalm.readthedocs.io/en/latest/integrations/ansible/modules/napalm_get_facts/index.html).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://napalm.readthedocs.io/en/latest/integrations/ansible/modules/napalm_get_facts/index.html](https://napalm.readthedocs.io/en/latest/integrations/ansible/modules/napalm_get_facts/index.html)。'
- en: 'For complete facts/getters supported by NAPALM and their support matrix against
    vendor equipment, please consult the following URL:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有关NAPALM支持的完整facts/getters及其针对供应商设备的支持矩阵，请参考以下URL：
- en: '[https://napalm.readthedocs.io/en/latest/support/](https://napalm.readthedocs.io/en/latest/support/).[ ](https://napalm.readthedocs.io/en/latest/support/)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://napalm.readthedocs.io/en/latest/support/](https://napalm.readthedocs.io/en/latest/support/).[ ](https://napalm.readthedocs.io/en/latest/support/)'
- en: Validating network reachability using NAPALM
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NAPALM验证网络可达性
- en: In this recipe, we will outline how to utilize NAPALM and its Ansible modules
    to validate network reachability across the network. This validation performs
    pings from the managed devices to the destination that we specify, in order to
    make sure that the forwarding path across the network is working as expected.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将概述如何利用NAPALM及其Ansible模块来验证网络在整个网络中的可达性。这个验证执行从受管设备到我们指定的目的地的ping，以确保网络中的转发路径按预期工作。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow along with this recipe, it is assumed that an Ansible inventory is
    already in place and network reachability between the Ansible controller and the
    network is established. The network in this recipe is assumed to be configured
    as per the relevant previous recipe.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个步骤进行，假设已经有一个Ansible清单，并且Ansible控制器与网络之间已建立网络可达性。在这个步骤中，假设网络已根据相关的先前步骤进行了配置。
- en: How to do it…
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create a new playbook called `pb_napalm_ping.yml` with the following content:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pb_napalm_ping.yml`的新playbook，内容如下：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Update the playbook with the validation tasks shown in the following code block:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新playbook，添加如下代码块中所示的验证任务：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works…
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: NAPALM provides another Ansible module, `napalm_ping`, which connects to the
    remote managed device and executes pings from the remote managed device toward
    a destination that we specify. Using this module, we are able to validate the
    forwarding path between the managed devices and the specified destination.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: NAPALM提供了另一个Ansible模块`napalm_ping`，它连接到远程受管设备，并从远程受管设备向我们指定的目的地执行ping。使用这个模块，我们能够验证受管设备与指定目的地之间的转发路径。
- en: This `napalm_ping` module does not currently support Cisco IOS-XR devices, which
    is why we only select all PE devices that are in the Junos OS group. In our playbook,
    we use the `junos:&pe` pattern in order to do this.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`napalm_ping`模块目前不支持Cisco IOS-XR设备，这就是为什么我们只选择Junos OS组中的所有PE设备。在我们的playbook中，我们使用`junos:&pe`模式来做到这一点。
- en: In our example, we create a new playbook and we specify the destination that
    we want to ping, along with the maximum delay for our ping packets within the
    playbook itself, using the `vars` parameter. Then, we use the `napalm_ping` module
    to connect to the MPLS PE devices (only Junos OS ones) in our topology to execute
    `ping` from all these PE nodes toward the destination that we specified (in our
    case, this is the loopback for our **route reflector** (**RR**) router). We store
    all this data in a variable called `rr_ping`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们创建了一个新的playbook，并在playbook本身中使用`vars`参数指定我们要ping的目的地以及我们ping数据包的最大延迟。然后，我们使用`napalm_ping`模块连接到我们拓扑中的MPLS
    PE设备（只有Junos OS设备），从所有这些PE节点向我们指定的目的地（在我们的情况下，这是我们的**路由反射器**（**RR**）路由器的环回）执行`ping`。我们将所有这些数据存储在一个名为`rr_ping`的变量中。
- en: 'The following snippet shows the output returned from `napalm_ping`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了从`napalm_ping`返回的输出：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finally, we use the `assert` module to validate and compare the results returned
    by NAPALM against our requirements (ping is successful, no packet loss, and delay
    less than `max_delay`).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`assert`模块来验证并比较NAPALM返回的结果与我们的要求（ping成功，没有丢包，延迟小于`max_delay`）。
- en: Validating and auditing networks with NAPALM
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NAPALM验证和审计网络
- en: In this recipe, we will outline how we can validate the operational state of
    the network by defining the intended state of the network and letting NAPALM validate
    that the actual/operational state of the network matches our intended state. This
    is useful in network auditing and compliance reports for our network infrastructure.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将概述如何通过定义网络的预期状态并让NAPALM验证网络的实际/操作状态是否与我们的预期状态匹配来验证网络的操作状态。这对于网络审计和网络基础设施的合规性报告非常有用。
- en: Getting ready
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow along with this recipe, it is assumed that an Ansible inventory is
    already in place and network reachability between the Ansible controller and the
    network is established. Finally, the network is configured as per the previously
    outlined recipe.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个步骤进行，假设已经有一个Ansible清单，并且Ansible控制器与网络之间已建立网络可达性。最后，网络已根据先前概述的步骤进行了配置。
- en: How to do it…
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create a new folder called `napalm_validate` and create a YAML file for each
    device. We will validate its state, as shown in the following code block:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`napalm_validate`的新文件夹，并为每个设备创建一个YAML文件。我们将验证其状态，如下面的代码块所示：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a new `pb_napalm_validation.yml` playbook with the following content:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pb_napalm_validation.yml`的新playbook，内容如下：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Update the playbook to create a folder that will store the compliance reports
    for each device, as shown in the following code block:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新playbook，创建一个文件夹，用于存储每个设备的合规性报告，内容如下代码块所示：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works…
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: NAPALM provides another module for network validation, which is the `napalm_validate`
    module. This module is mainly used to perform auditing and generate compliance
    reports for the network infrastructure. The main idea is to declare the intended
    state of the network and define it in a YAML document. This YAML file has a specific
    format, following the same structure with which the different NAPALM facts are
    generated. In this YAML file, we specify the NAPALM facts that we want to retrieve
    from the network, along with the network's expected output.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: NAPALM提供了另一个用于网络验证的模块，即`napalm_validate`模块。该模块主要用于执行审计并为网络基础设施生成合规性报告。主要思想是声明网络的预期状态，并在YAML文档中定义它。这个YAML文件有一个特定的格式，遵循不同NAPALM事实生成的相同结构。在这个YAML文件中，我们指定了我们想要从网络中检索的NAPALM事实，以及网络的预期输出。
- en: We supply these validation files to the `napalm_validate` module, and NAPALM
    will connect to the devices, retrieve the facts specified in these validation
    files, and compare the output retrieved from the network against the network state
    declared in these validation files.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些验证文件提供给`napalm_validate`模块，NAPALM将连接到设备，检索这些验证文件中指定的事实，并将从网络中检索的输出与这些验证文件中声明的网络状态进行比较。
- en: Next, NAPALM generates a `compliance_report` object, which has the result of
    the comparison and whether the network complies with these validation files or
    not. We also set the `ignore_errors` parameter in order to continue with the other
    tasks in this playbook in case the device doesn't comply, so we can capture this
    compliance problem in the compliance report that we will generate.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，NAPALM生成一个`compliance_report`对象，其中包含比较的结果以及网络是否符合这些验证文件。我们还设置了`ignore_errors`参数，以便在设备不符合时继续执行此playbook中的其他任务，这样我们就可以在生成的合规性报告中捕获这个合规性问题。
- en: Finally, we save the output in a separate folder called `compliance_folder`
    for each node, copy the contents of the `compliance_report` parameter, and format
    it using the `to_nice_yaml` filter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将输出保存在一个名为`compliance_folder`的单独文件夹中，为每个节点复制`compliance_report`参数的内容，并使用`to_nice_yaml`过滤器进行格式化。
- en: 'The code for a correct compliance report generated for a `mxpe01` device is
    shown in the following snippet:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为`mxpe01`设备生成的正确合规性报告的代码片段：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: See also…
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For further information on validating deployments and the other options available
    for `napalm_validate`, please check the following URLs:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有关验证部署和`napalm_validate`的其他选项的更多信息，请查看以下网址：
- en: '[https://napalm.readthedocs.io/en/latest/integrations/ansible/modules/napalm_validate/index.html](https://napalm.readthedocs.io/en/latest/integrations/ansible/modules/napalm_validate/index.html)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://napalm.readthedocs.io/en/latest/integrations/ansible/modules/napalm_validate/index.html](https://napalm.readthedocs.io/en/latest/integrations/ansible/modules/napalm_validate/index.html)'
- en: '[https://napalm.readthedocs.io/en/latest/validate/index.html](https://napalm.readthedocs.io/en/latest/validate/index.html)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://napalm.readthedocs.io/en/latest/validate/index.html](https://napalm.readthedocs.io/en/latest/validate/index.html)'
