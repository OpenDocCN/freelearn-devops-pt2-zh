- en: 10\. ConfigMaps and Secrets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. ConfigMaps和Secrets
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will learn how to decouple application configuration data
    from the application itself and the advantages of taking this approach. By the
    end of this chapter, you will be able to define Kubernetes ConfigMap and Secret
    objects, run a simple Pod that uses data from ConfigMaps and Secrets, describe
    the advantages of decoupling configuration data from applications, and use ConfigMaps
    and Secrets to decouple application configuration data from the application container.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何将应用程序配置数据与应用程序本身解耦，并采取这种方法的优势。在本章结束时，您将能够定义Kubernetes ConfigMap和Secret对象，运行一个使用来自ConfigMaps和Secrets的数据的简单Pod，描述将配置数据与应用程序解耦的优势，并使用ConfigMaps和Secrets将应用程序配置数据与应用程序容器解耦。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In *Chapter 5*, *Pods*, we learned that Pods are the minimal unit of deployment
    in Kubernetes. Pods can have multiple containers, and each container can have
    a container image associated with it. This container image generally packages
    the target application that you plan to run. Once the developers are satisfied
    that the code is running as expected, the next step is to promote the code to
    testing, integration, and production environments.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第5章*，*Pods*中，我们了解到Pods是Kubernetes中部署的最小单位。Pods可以有多个容器，每个容器可以有一个与之关联的容器镜像。这个容器镜像通常打包了您计划运行的目标应用程序。一旦开发人员确信代码按预期运行，下一步就是将代码推广到测试、集成和生产环境。
- en: Easy, right? One problem, however, is that as we move our packaged container
    from one environment to another, although the application remains the same, it
    needs environment-specific data, for example, the database URL to connect to.
    To overcome this problem, we can write our applications in such a way that the
    environment-specific data is provided to the application by the environment it
    is being deployed into.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 容易，对吧？然而，一个问题是，当我们将打包的容器从一个环境移动到另一个环境时，尽管应用程序保持不变，但它需要特定于环境的数据，例如连接到的数据库URL。为了解决这个问题，我们可以以这样的方式编写我们的应用程序，使得环境特定的数据由部署到的环境提供给应用程序。
- en: 'In this chapter, we will discover what Kubernetes provides to associate **environment-specific
    data** with our application containers without changing our container image. There
    are multiple ways to provide **environment-specific configuration** data to our
    application:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将发现Kubernetes提供了什么来将**特定于环境的数据**与我们的应用程序容器关联起来，而不改变我们的容器镜像。有多种方法可以为我们的应用程序提供**特定于环境的配置**数据：
- en: Provide command-line arguments to the Pods.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Pods提供命令行参数。
- en: Provide environment variables to the Pods.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Pods提供环境变量。
- en: Mount configuration files in the containers.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器中挂载配置文件。
- en: First, we need to define our configuration data using an object called **ConfigMap**.
    Once the data is defined and loaded into Kubernetes, the second step is to provide
    the defined data to your application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用一个叫做**ConfigMap**的对象来定义我们的配置数据。一旦数据被定义并加载到Kubernetes中，第二步就是将定义的数据提供给您的应用程序。
- en: However, what if you have sensitive data, such as database passwords, that you
    want to provide to your application container? Well, Kubernetes **Secret** provides
    a way to define sensitive data to an application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您有敏感数据，比如数据库密码，您想提供给应用程序容器怎么办？好吧，Kubernetes **Secret** 提供了一种定义敏感数据给应用程序的方法。
- en: ConfigMap and Secret objects both serve a similar purpose. Both provide a way
    to define data that can be injected into your applications so that the same container
    can be used across different environments. There is little difference between
    them, which we will learn in detail later on in this chapter. As a quick rule,
    Secrets are designed to hold confidential data (such as passwords, private keys,
    and more), while ConfigMaps are more suited for general configuration data such
    as a database location. ConfigMaps and Secrets reside in the specific namespace
    in which they are created. They can only be referenced by Pods residing in the
    same namespace.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap和Secret对象都具有类似的目的。两者都提供了一种定义数据的方式，可以将其注入到应用程序中，以便相同的容器可以在不同的环境中使用。它们之间的区别很小，我们将在本章后面详细学习。简单来说，Secrets旨在保存机密数据（例如密码、私钥等），而ConfigMaps更适用于一般配置数据，例如数据库位置。ConfigMaps和Secrets驻留在创建它们的特定命名空间中。它们只能被驻留在相同命名空间中的Pods引用。
- en: Kubernetes uses an internal key-value store called **etcd** as its database
    to store all the objects defined in Kubernetes. As ConfigMaps and Secrets are
    Kubernetes objects, they get stored in the internal key-value store.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用名为**etcd**的内部键值存储作为其数据库，用于存储在Kubernetes中定义的所有对象。由于ConfigMaps和Secrets是Kubernetes对象，它们被存储在内部键值存储中。
- en: Let's dig a bit deeper into ConfigMaps first.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先深入了解一下ConfigMaps。
- en: What Is a ConfigMap?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是ConfigMap？
- en: A ConfigMap allows us to define application-related data. A ConfigMap decouples
    the application data from the application so that the same application can be
    ported across different environments. It also provides a way to inject customized
    data into running services from the same container image.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap允许我们定义与应用程序相关的数据。ConfigMap将应用程序数据与应用程序解耦，以便相同的应用程序可以在不同的环境中移植。它还提供了一种从相同容器镜像中的运行服务中注入定制数据的方式。
- en: ConfigMaps can be created through a literal value or from a file or all the
    files in a directory. Note that the primary data we stored in ConfigMaps is for
    non-sensitive configuration, for example, config files or environment variables.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMaps可以通过文字值或来自文件或目录中的所有文件来创建。请注意，我们存储在ConfigMaps中的主要数据是用于非敏感配置，例如配置文件或环境变量。
- en: Once a ConfigMap is defined, it will be loaded to the application via an environment
    variable or a set of files. The application can then see the files as local files
    and can read from them. It is important to note that (from 1.9.6 version onward
    of Kubernetes), files loaded from ConfigMaps are read-only. ConfigMaps can also
    hold configuration data for system applications such as operators and controllers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了ConfigMap，它将通过环境变量或一组文件加载到应用程序中。然后，应用程序可以将文件视为本地文件并从中读取。需要注意的是（从Kubernetes的1.9.6版本开始），从ConfigMaps加载的文件是只读的。ConfigMaps还可以保存系统应用程序的配置数据，例如操作员和控制器。
- en: In the following exercises, you will see different ways of defining ConfigMaps
    and different ways to make the ConfigMap data available to the running Pods.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，您将看到定义ConfigMaps的不同方式以及使ConfigMap数据可用于运行的Pod的不同方式。
- en: 'Let''s see what Kubernetes offers us in terms of ConfigMap creation. Kubernetes
    help commands provide a good starting point:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Kubernetes在ConfigMap创建方面提供了什么。Kubernetes帮助命令提供了一个很好的起点：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should see the following response:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 10.1: Kubernetes built-in help for creating ConfigMap'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1：Kubernetes内置帮助创建ConfigMap'
- en: '](image/B14870_10_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_01.jpg)'
- en: 'Figure 10.1: Kubernetes built-in help for creating ConfigMap'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：Kubernetes内置帮助创建ConfigMap
- en: 'As you can see from the preceding output, ConfigMaps can be created for a single
    value, a list of values, or from an entire file or directory. We will learn exactly
    how to do each of these in the exercises in this chapter. Note that the command
    to create a ConfigMap has the following format:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看出，ConfigMaps 可以用于创建单个值、值列表，或者整个文件或目录。我们将在本章的练习中学习如何分别执行这些操作。请注意，创建
    ConfigMap 的命令格式如下：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `<map-name>` is the name you want to assign to the ConfigMap and `<data-source>`
    is the directory, file, or literal value to draw the data from.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<map-name>` 是您想要分配给 ConfigMap 的名称，`<data-source>` 是要从中提取数据的目录、文件或文字值。
- en: 'The data source corresponds to a key-value pair in the ConfigMap, where:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源对应于 ConfigMap 中的键值对，其中：
- en: '**Key** is the filename or the key you provided on the command line'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键**是您在命令行上提供的文件名或键'
- en: '**Value** is the file content or the literal value you provided on the command
    line'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**是您在命令行上提供的文件内容或文字值'
- en: Before we start with the exercises, let's make sure that you have Kubernetes
    running and that you can issue commands to it. We will use minikube to easily
    run a single-node cluster on your local computer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始练习之前，让我们确保您的 Kubernetes 正在运行，并且您可以向其发出命令。我们将使用 minikube 在您的本地计算机上轻松运行单节点集群。
- en: 'Start up minikube using the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动 minikube：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see the following response as minikube starts up:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当 minikube 启动时，您应该看到以下响应：
- en: '![Figure 10.2: Starting up minikube'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2：启动 minikube'
- en: '](image/B14870_10_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_02.jpg)'
- en: 'Figure 10.2: Starting up minikube'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2：启动 minikube
- en: For all of the exercises in this chapter, we recommend creating a new namespace.
    Recall from *Chapter 5*, *Pods*, that namespaces are Kubernetes' way to group
    components of the solution together. Namespaces can be used to apply policies,
    quotas, and could also be used to separate resources if the same Kubernetes resources
    are being used by different teams.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的所有练习，我们建议创建一个新的命名空间。回想一下*第5章*，*Pods*，命名空间是 Kubernetes 将解决方案组件分组在一起的方式。命名空间可以用于应用策略、配额，并且还可以用于分隔资源，如果相同的
    Kubernetes 资源被不同的团队使用。
- en: In the following exercise, we will create a ConfigMap from literal values using
    the kubectl CLI commands. The idea is that we have some configuration data (for
    example, the master database name) that we can inject into, for example, a MySQL
    Pod, and it will create the database as per the given environment variable. This
    set of commands can also be used in the automated code pipelines that are responsible
    for application deployments across multiple environments.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将使用 kubectl CLI 命令从文字值创建一个 ConfigMap。其思想是我们有一些配置数据（例如，主数据库名称），我们可以将其注入到
    MySQL Pod 中，并且它将根据给定的环境变量创建数据库。这组命令也可以用于负责在多个环境中进行应用部署的自动化代码流水线中。
- en: 'Exercise 10.01: Creating a ConfigMap from Literal Values and Mounting It on
    a Pod Using Environment Variables'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10.01：从文字值创建 ConfigMap 并将其挂载到 Pod 上使用环境变量
- en: 'In this exercise, we will create a ConfigMap in the Kubernetes cluster. This
    exercise shows how to create ConfigMaps using a key-value pattern. Please follow
    these steps to complete the exercise:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在 Kubernetes 集群中创建一个 ConfigMap。此练习展示了如何使用键值模式创建 ConfigMaps。请按照以下步骤完成练习：
- en: First, let's begin by creating a namespace for all of the exercises in this
    chapter.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们开始创建一个命名空间，用于本章中的所有练习。
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should see a response like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will use the `configmap-test` namespace for all the exercises in this chapter
    unless mentioned otherwise.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有说明，我们将在本章的所有练习中使用 `configmap-test` 命名空间。
- en: 'First, let''s create a ConfigMap that contains a single name-value pair. Use
    the command shown here:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个包含单个名称-值对的ConfigMap。使用此处显示的命令：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see the following output in the terminal:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端中看到以下输出：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once we create the ConfigMap, let''s confirm that it is created by issuing
    a command to get all the ConfigMaps in the namespace:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建ConfigMap后，让我们通过发出命令来获取命名空间中的所有ConfigMap来确认它是否已创建：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As `singlevalue-map` is the only ConfigMap in the `configmap-test` namespace,
    you should see an output that looks something like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`singlevalue-map`是`configmap-test`命名空间中唯一的ConfigMap，您应该看到类似以下内容的输出：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s see what the Kubernetes ConfigMap object looks like. Enter the Kubernetes
    `get` command as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看Kubernetes ConfigMap对象是什么样子的。输入以下Kubernetes `get`命令：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The full object should be described something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 完整对象应该描述为以下内容：
- en: '![Figure 10.3: Describing singlevalue-map'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3：描述singlevalue-map'
- en: '](image/B14870_10_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_03.jpg)'
- en: 'Figure 10.3: Describing singlevalue-map'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：描述singlevalue-map
- en: As you can see in the third line of the preceding output, the ConfigMap is created
    and the literal value we entered is available as a key-value pair in the `data`
    section of the ConfigMap.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前述输出的第三行中所看到的，ConfigMap已创建，并且我们输入的文字值作为键值对出现在ConfigMap的`data`部分中。
- en: 'Now, we will create a YAML file named `configmap-as-env.yaml` to create a Pod
    into which we will inject fields from our ConfigMap as an environment variable.
    Using your favorite text editor, create a YAML file with the following content:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个名为`configmap-as-env.yaml`的YAML文件，以创建一个Pod，我们将从我们的ConfigMap中注入字段作为环境变量。使用您喜欢的文本编辑器，创建一个包含以下内容的YAML文件：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can see that the `envFrom` section in the preceding file is loading the
    data from the ConfigMap.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到前述文件中的`envFrom`部分正在从ConfigMap加载数据。
- en: 'Let''s create a Pod from the preceding specification. This Pod is using the
    **busybox** container image, which runs the command specified in the `command`
    section of the YAML file mentioned in the previous step:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们根据前述规范创建一个Pod。此Pod使用**busybox**容器映像，该映像运行在前述步骤中提到的YAML文件的`command`部分中指定的命令：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see an output like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s check the logs for this Pod using the following command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下命令检查此Pod的日志：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should see the logs as shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到如下所示的日志：
- en: '![Figure 10.4: Getting logs for configmap-env-pod'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4：获取configmap-env-pod的日志'
- en: '](image/B14870_10_04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_04.jpg)'
- en: 'Figure 10.4: Getting logs for configmap-env-pod'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：获取configmap-env-pod的日志
- en: The `[ "/bin/sh", "-c", "env" ]` command will display all the environment variables
    loaded into the Pod. In the ConfigMap, we have defined the property name as `partner-url`,
    which is part of the output.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ "/bin/sh", "-c", "env" ]`命令将显示加载到Pod中的所有环境变量。在ConfigMap中，我们已将属性名称定义为`partner-url`，这是输出的一部分。'
- en: 'In this exercise, the name of the environment variable, `partner-url`, is the
    same as the key in our key-value pair. We can also make the name of the environment
    variable different from the key. For example, if we want to have `partner-server-location`
    as the name of our environment variable, we can replace the content of the YAML
    file in the exercise with the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，环境变量的名称`partner-url`与我们的键值对中的键相同。我们还可以使环境变量的名称与键不同。例如，如果我们想要将`partner-server-location`作为我们环境变量的名称，我们可以用以下内容替换练习中YAML文件的内容：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Pay special attention to the `env` section in the preceding YAML file. The first
    `name` field after `env` defines the name of the environment variable, and the
    `key` field under `configMapKeyRef` defines the name of the key in the ConfigMap.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意前面YAML文件中的`env`部分。`env`后的第一个`name`字段定义了环境变量的名称，`configMapKeyRef`下的`key`字段定义了ConfigMap中的键的名称。
- en: Defining a ConfigMap from a File and Loading It onto a Pod
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件定义一个ConfigMap并将其加载到Pod上
- en: In this section, we will create a ConfigMap from a file and then load the file
    onto the application Pod. As mentioned previously, this newly mounted file will
    be accessible as a local file to the application running inside the Pod.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将从文件创建一个ConfigMap，然后将文件加载到应用程序Pod上。如前所述，这个新挂载的文件将作为本地文件对Pod内运行的应用程序可访问。
- en: This is common when applications store their configuration data externally,
    allowing easier upgrades, as well as patches of the container image across different
    environments. We can have such a file in our source control repository, and we
    load the correct file in the correct container using a ConfigMap.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序将其配置数据存储在外部时，这是很常见的，这样可以更容易地在不同环境中进行升级和容器镜像的补丁。我们可以在源代码控制存储库中拥有这样一个文件，并且使用ConfigMap在正确的容器中加载正确的文件。
- en: Let's understand this through an example. Imagine that you have written a web
    application that connects to a database to store information. When you deploy
    the application in a development environment, you will want to connect to the
    development database. Once you are satisfied that the application is working correctly,
    you will want to deploy the application to a testing environment. Since the application
    is packaged in a container, you would not want to change the container to deploy
    the application to the testing environment. But to run the application in the
    testing environment, you need to connect to a different database. An easy solution
    to this is that you configure your application to read the database server URL
    from a file, and that file can be mounted through a ConfigMap. This way, the file
    is not packaged as part of the container, but injected from outside via Kubernetes;
    thus, you do not need to modify your containerized application. Another use case
    would be that external software vendors can provide a container image, and any
    specific configuration settings can be mounted on the image as per a specific
    client's requirements.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解这一点。想象一下，你编写了一个连接到数据库存储信息的Web应用程序。当你在开发环境部署应用程序时，你会想要连接到开发数据库。一旦你确信应用程序正常工作，你会想要将应用程序部署到测试环境。由于应用程序打包在一个容器中，你不希望改变容器来部署应用程序到测试环境。但是在测试环境中运行应用程序时，你需要连接到一个不同的数据库。一个简单的解决方案是配置你的应用程序从文件中读取数据库服务器的URL，并且该文件可以通过ConfigMap挂载。这样，文件不作为容器的一部分打包，而是通过Kubernetes从外部注入；因此，你不需要修改你的容器化应用程序。另一个用例是外部软件供应商可以提供一个容器镜像，并且可以根据特定客户的要求挂载任何特定的配置设置到镜像上。
- en: 'Exercise 10.02: Creating a ConfigMap from a File'
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.02：从文件创建一个ConfigMap
- en: 'In this exercise, we will create a ConfigMap from a file, which can be mounted
    onto any Pods later on:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将从文件创建一个ConfigMap，然后可以挂载到任何Pod上：
- en: 'First, create a file named `application.properties` containing the following
    configuration details. You may use your preferred text editor:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`application.properties`的文件，其中包含以下配置细节。你可以使用你喜欢的文本编辑器：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, create a ConfigMap from the file using the following command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令从文件创建一个ConfigMap：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should see the following output indicating that the ConfigMap has been created:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出，表明ConfigMap已经被创建：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Get the list of all ConfigMaps to confirm that our ConfigMap has been created:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有ConfigMaps的列表以确认我们的ConfigMap已经创建：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should see a list of all ConfigMaps, as shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到所有ConfigMaps的列表，如下所示：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can see that the names of the ConfigMaps are displayed alongside the number
    of keys they have.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到ConfigMaps的名称与它们拥有的键的数量一起显示。
- en: You might be wondering, why does this output show only one key, even though
    we have added two keys? Let's understand this in the next step.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道，为什么这个输出只显示一个键，即使我们添加了两个键？让我们在下一步中理解这一点。
- en: 'Let''s see how the ConfigMap is being stored by using the following command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看如何使用以下命令存储ConfigMap：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should see the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 10.5: Getting details of full-file-map'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.5：获取完整文件映射的详细信息'
- en: '](image/B14870_10_05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_05.jpg)'
- en: 'Figure 10.5: Getting details of full-file-map'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：获取完整文件映射的详细信息
- en: Note that the name of the file, `application.properties`, becomes the **key**
    under the `data` section, and the entire file payload is the **value** of the
    key.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，文件名`application.properties`成为`data`部分下的**key**，整个文件负载是key的**value**。
- en: 'Now that we have defined our ConfigMap, the next step is to mount it onto a
    container. Create a YAML file named `mount-configmap-as-volume.yaml` to be used
    as our Pod configuration using the following content:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的ConfigMap，下一步是将其挂载到容器上。创建一个名为`mount-configmap-as-volume.yaml`的YAML文件，用以下内容作为我们的Pod配置：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, let's focus on the `volumes` section in the preceding file. In this section,
    we are instructing Kubernetes to define a volume from our ConfigMap named `full-file-map`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们专注于前面文件中的`volumes`部分。在这个部分中，我们指示Kubernetes从名为`full-file-map`的ConfigMap中定义一个卷。
- en: Secondly, in the `volumeMounts` section, we are defining that Kubernetes should
    mount the volume in the `/etc/appconfig` directory.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在`volumeMounts`部分，我们定义Kubernetes应该在`/etc/appconfig`目录中挂载卷。
- en: Note that the `command` field in the container allows us to configure what command
    we want the container to execute when it starts. In this example, we are running
    the `ls` command, which is a Linux command to list the contents of a directory.
    This is similar to the Windows `dir` command. This will print the contents of
    directory `/etc/appconfig`, where we have mounted the ConfigMap.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意容器中的`command`字段允许我们配置容器在启动时要执行的命令。在这个例子中，我们运行`ls`命令，这是一个列出目录内容的Linux命令。这类似于Windows的`dir`命令。这将打印出我们挂载了ConfigMap的`/etc/appconfig`目录的内容。
- en: Note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `name` field under the `volume` and `volumeMounts` sections has to be the
    same so that Kubernetes can identify which `volume` is associated with which `volumeMounts`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`volume`和`volumeMounts`部分下的`name`字段必须相同，以便Kubernetes可以识别哪个`volume`与哪个`volumeMounts`相关联。'
- en: 'Now, use the following command to start a Pod using the YAML file we just created:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令使用我们刚刚创建的YAML文件启动一个Pod：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should get a response saying that the Pod has been created:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该收到一个回复，说Pod已经创建：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The YAML file we used specifies the name of the Pod as `configmap-test-pod`
    and configures it to just display the content of the folder. To verify this, just
    issue the following command to get the output logs of the Pod:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用的YAML文件指定了Pod的名称为`configmap-test-pod`，并配置它只显示文件夹的内容。要验证这一点，只需发出以下命令以获取Pod的输出日志：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This should print `application.properties`, which is the file we placed in
    the folder:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该打印出`application.properties`，这是我们放在文件夹中的文件：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, we get the contents of `/etc/appconfig`, which is the output
    of the `ls` command in the Pod.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们得到了`/etc/appconfig`的内容，这是Pod中`ls`命令的输出。
- en: You have just successfully defined a ConfigMap and mounted it as a file in a
    Pod that printed the name of the file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚成功定义了一个ConfigMap，并将其作为文件挂载到一个打印文件名的Pod中。
- en: 'Exercise 10.03: Creating a ConfigMap from a Folder'
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.03：从文件夹创建ConfigMap
- en: 'In this exercise, we will load all the files in a folder as a ConfigMap. Each
    filename becomes a key for the ConfigMap, and when you mount it, all the files
    will be mounted at the `volumeMounts` location (as defined in the YAML file for
    the container):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将所有文件加载到一个文件夹中作为ConfigMap。每个文件名都成为ConfigMap的一个键，当您挂载它时，所有文件都将挂载到`volumeMounts`位置（如在YAML文件中为容器定义的）：
- en: 'Create two files in a new folder. Name one of them `fileone.txt`, with its
    contents as `file one`, and name the other `filetwo.txt`, with its contents as
    `file two`. The folder name can be anything for this exercise. You can confirm
    that the files have been created using the `ls` command:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新文件夹中创建两个文件。将其中一个命名为`fileone.txt`，其内容为`file one`，将另一个命名为`filetwo.txt`，其内容为`file
    two`。此练习的文件夹名称可以是任意的。您可以使用`ls`命令确认已创建文件：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You will see the following list of files:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下文件列表：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use the following command to create ConfigMap from a folder. Note that instead
    of specifying the filename, we just mentioned the name of the folder:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从文件夹创建ConfigMap。请注意，我们只提到文件夹的名称，而不是指定文件名：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should see the following response:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s describe the ConfigMap to see what it contains:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们描述一下ConfigMap，看看它包含什么：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should see the following output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 10.6: Describing the map-from-folder ConfigMap'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.6：描述了从文件夹创建的ConfigMap'
- en: '](image/B14870_10_06.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_06.jpg)'
- en: 'Figure 10.6: Describing the map-from-folder ConfigMap'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：描述了从文件夹创建的ConfigMap
- en: Notice that there are two keys in the ConfigMap – one for each file, that is,
    `fileone.txt` and `filetwo.txt`. The values of the keys are the contents of the
    files. Thus, we can see that a ConfigMap can be created from all the files in
    a folder.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，ConfigMap中有两个键-每个文件一个，即`fileone.txt`和`filetwo.txt`。键的值是文件的内容。因此，我们可以看到可以从文件夹中的所有文件创建ConfigMap。
- en: What Is a Secret?
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是秘密？
- en: A ConfigMap provides a way to decouple application configuration data from the
    application itself. However, the problem with a ConfigMap is that it stores the
    data in plain text as a Kubernetes object. What if we want to store some **sensitive
    data** such as a database password? Kubernetes Secret provides a way to store
    sensitive data that can then be made available to the applications that require
    it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap提供了一种将应用程序配置数据与应用程序本身解耦的方法。但是，ConfigMap的问题在于它将数据以明文形式存储为Kubernetes对象。如果我们想要存储一些**敏感数据**，例如数据库密码，该怎么办？Kubernetes
    Secret提供了一种存储敏感数据的方式，然后可以将其提供给需要的应用程序。
- en: Secret versus ConfigMap
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 秘密与ConfigMap
- en: 'You can think of a Secret as the same as a ConfigMap with the following differences:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将秘密视为与ConfigMap相同，具有以下区别：
- en: Unlike a ConfigMap, a Secret is intended to store a small amount (1 MB for a
    Secret) of sensitive data. A Secret is **base64**-encoded, so we cannot treat
    it as secure. It can also store binary data such as a public or private key.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与ConfigMap不同，秘密旨在存储少量（秘密为1 MB）敏感数据。秘密是**base64**编码的，因此我们不能将其视为安全。它还可以存储二进制数据，例如公钥或私钥。
- en: Kubernetes ensures that Secrets are passed only to the nodes that are running
    the Pods that need the respective Secrets.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes确保只将秘密传递给运行需要相应秘密的Pod的节点。
- en: Note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Another way to store sensitive data is a vault solution, such as HashiCorp Vault.
    We have left such implementation out of the scope of the workshop.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 存储敏感数据的另一种方法是使用诸如HashiCorp Vault之类的保险库解决方案。我们已经将这样的实现超出了研讨会的范围。
- en: But wait; if the Kubernetes Secrets are not secure enough due to their base64
    encoding, then what is the solution for storing extremely sensitive data? One
    way is to encrypt it and then store it in Secrets. The data can be decrypted while
    it is being loaded to the Pod, though we are leaving this implementation out of
    the scope of this workshop.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等；如果Kubernetes Secrets由于它们的base64编码而不够安全，那么存储极其敏感的数据的解决方案是什么？一种方法是对其进行加密，然后将其存储在Secrets中。数据可以在加载到Pod时进行解密，尽管我们将此实现范围之外的实现。
- en: Once we define our Secrets, we need to expose them to the applications Pods.
    The way we expose Secrets to the running application is the same as for ConfigMaps,
    that is, by mounting them as an environment variable or as a file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了我们的Secrets，我们需要将它们暴露给应用程序Pods。我们将Secrets暴露给运行的应用程序的方式与ConfigMaps相同，即通过将它们挂载为环境变量或文件。
- en: 'As for ConfigMaps, let''s use the built-in `help` command for `secret` to see
    what types of Secrets are offered by Kubernetes:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与ConfigMaps一样，让我们使用Kubernetes提供的`secret`的内置`help`命令来查看提供的Secrets的类型：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `help` command should show the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`help`命令应该显示如下内容：'
- en: '![Figure 10.7: Output of the built-in help command for Secret'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7：Secret的内置帮助命令的输出'
- en: '](image/B14870_10_07.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_07.jpg)'
- en: 'Figure 10.7: Output of the built-in help command for Secret'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：Secret的内置帮助命令的输出
- en: 'As you can see in the preceding output, the `Available Commands` section lists
    three types of Secrets:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的输出中所见，`Available Commands`部分列出了三种类型的Secrets：
- en: '`generic`: A generic Secret holds any custom-defined key-value pair.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generic`：通用Secret包含任何自定义键值对。'
- en: '`tls`: A TLS Secret is a special kind of Secret for holding a public-private
    key pair for communication using the TLS protocol.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tls`：TLS Secret是一种用于使用TLS协议进行通信的公钥-私钥对的特殊类型的Secret。'
- en: '`docker-registry`: This is a special kind of Secret that stores the username,
    password, and email address to access a Docker registry.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-registry`：这是一种特殊类型的Secret，用于存储访问Docker注册表的用户名、密码和电子邮件地址。'
- en: We will take a deeper dive into the implementation and uses of these Secrets
    in the following exercises.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的练习中深入探讨这些Secrets的实现和用途。
- en: 'Exercise 10.04: Defining a Secret from Literal Values and Loading the Values
    onto the Pod as an Environment Variable'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.04：从文字值定义一个Secret，并将值加载到Pod作为环境变量
- en: 'In this exercise, we will define a Secret from a literal value and load it
    as an environment variable in the running Pod on Kubernetes. This literal value
    maybe something like a password to your internal database. Since we are creating
    this Secret from a literal value, it would be categorized as a **generic** Secret.
    Follow these steps to perform the exercise:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将从文字值定义一个Secret，并将其作为环境变量加载到运行中的Kubernetes Pod中。这个文字值可能是您内部数据库的密码。由于我们从文字值创建这个Secret，它将被归类为**通用**
    Secret。按照以下步骤执行练习：
- en: 'First, create a Secret that will hold a simple password by using the following command:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令创建一个将保存简单密码的Secret：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should get a response as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下响应：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once we define our Secret, we can use the Kubernetes `describe` command to
    obtain more details about it:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们定义了我们的Secret，我们可以使用Kubernetes的`describe`命令获取更多关于它的详细信息：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![Figure 10.8: Describing test-secret'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8：描述test-secret'
- en: '](image/B14870_10_08.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_08.jpg)'
- en: 'Figure 10.8: Describing test-secret'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：描述test-secret
- en: 'You can see that it stored our value against the `password` key:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到它将我们的值存储在`password`键下：
- en: 'Now that our Secret is created, we will mount it as an environment variable
    in a Pod. To create a Pod, make a YAML file named `mount-secret-as-env.yaml` with
    the following content:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的Secret已创建，我们将在Pod中将其挂载为环境变量。要创建一个Pod，请创建一个名为`mount-secret-as-env.yaml`的YAML文件，内容如下：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Pay attention to the `envFrom` section, which mentions the Secret to load. In
    the `command` section for the container, we specify the `env` command, which will
    make the container display all the environment variables loaded into the Pod.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`envFrom`部分，其中提到要加载的秘密。在容器的`command`部分中，我们指定了`env`命令，这将使容器显示加载到Pod中的所有环境变量。
- en: 'Now, let''s use the YAML configuration to create a Pod and see it in action:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用YAML配置来创建一个Pod，并看它的运行情况：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You should see a response as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下类似的回应：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s get the logs for the Pod to see all the environment variables displayed
    by our container:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们获取Pod的日志，以查看容器显示的所有环境变量：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You should see the logs similar to the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到类似以下截图的日志：
- en: '![Figure 10.9: Getting logs from secret-env-pod'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.9：从secret-env-pod获取日志'
- en: '](image/B14870_10_09.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_09.jpg)'
- en: 'Figure 10.9: Getting logs from secret-env-pod'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：从secret-env-pod获取日志
- en: As you can see in the highlighted line of the preceding output, the `password`
    key is displayed with its value as `secretvalue`, which was what we had specified.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的输出的突出显示行中所看到的，`password`键显示为`secretvalue`，这就是我们指定的值。
- en: The following exercise demonstrates how to use a public-private key combination
    and mount the private key file into a Pod. The public key can then be made available
    to any other service connecting to this Pod, but that is not demonstrated in this
    exercise. Using a separate file as a Secret enables us to use any kind of file
    instead of simple key-value strings. This opens up the possibility of using binary
    files like private key stores.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习演示了如何使用公私钥组合，并将私钥文件挂载到Pod中。然后，公钥可以提供给连接到该Pod的任何其他服务，但本练习中没有演示。使用一个单独的文件作为秘密使我们能够使用任何类型的文件，而不仅仅是简单的键值字符串。这就打开了使用私钥存储等二进制文件的可能性。
- en: 'Exercise 10.05: Defining a Secret from a File and Loading the Values onto the
    Pod as a File'
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.05：从文件定义一个秘钥，并将值作为文件加载到Pod上
- en: 'In this exercise, we will create a private key, store it in a new Secret, and
    then load it onto a Pod as a file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个私钥，将其存储在一个新的秘密中，然后将其加载到一个Pod中作为一个文件：
- en: 'First, let''s create a private key. We will use a tool used to create SSH keys.
    Enter the following command in the terminal:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个私钥。我们将使用一个用于创建SSH密钥的工具。在终端中输入以下命令：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If prompted, do not provide any password for the key.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提示，请不要为密钥提供任何密码。
- en: Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you require more information about the SSH protocol and its uses, please
    refer to [https://www.ssh.com/ssh/protocol/](https://www.ssh.com/ssh/protocol/).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更多关于SSH协议及其用途的信息，请参考[https://www.ssh.com/ssh/protocol/](https://www.ssh.com/ssh/protocol/)。
- en: 'After this is executed successfully, you will see two files named `test_rsa`
    and `test_rsa.pub`. You should see an output similar to the one shown here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 执行成功后，您将看到两个名为`test_rsa`和`test_rsa.pub`的文件。您应该会看到类似于这里显示的输出：
- en: '![Figure 10.10: Creating SSH keys'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.10：创建SSH密钥'
- en: '](image/B14870_10_10.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_10.jpg)'
- en: 'Figure 10.10: Creating SSH keys'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：创建SSH密钥
- en: Your output may not be exactly the same as shown here because the keys are randomized.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出可能与此处显示的不完全相同，因为密钥是随机的。
- en: Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Most Linux distros include the `ssh-keygen` tool. However, if you don't have
    or cannot use `ssh-keygen`, you can use any other file instead of the private
    key to proceed with this exercise.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Linux发行版都包括`ssh-keygen`工具。但是，如果您没有或无法使用`ssh-keygen`，您可以使用任何其他文件代替私钥来进行此练习。
- en: 'Now, let''s load the newly created private key as a Secret. This time, we will
    use the `from-file` argument of the `create secret` command:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将新创建的私钥加载为一个秘密。这次，我们将使用`create secret`命令的`from-file`参数：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You should get a response like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到这样的回应：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once the Secret is created, we can get its details using the `describe` command:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了Secret之后，我们可以使用`describe`命令获取其详细信息：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The Secret should be described as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密应该描述如下：
- en: '![Figure 10.11: Describing test-key-secret'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.11：描述test-key-secret'
- en: '](image/B14870_10_11.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_11.jpg)'
- en: 'Figure 10.11: Describing test-key-secret'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：描述test-key-secret
- en: 'Now that our Secret is created, let''s mount it onto a Pod. The process is
    similar to mounting a ConfigMap. First, create a YAML file named `mount-secret-as-volume.yaml`
    with the following content:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的Secret已经创建，让我们将其挂载到一个Pod上。这个过程类似于挂载ConfigMap。首先，创建一个名为`mount-secret-as-volume.yaml`的YAML文件，内容如下：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding Pod specification, note that `volumes` are mounted the same
    way as we mounted the earlier ConfigMap. In the volumes section, we are instructing
    Kubernetes to define a volume from our Secret. In the `volumeMounts` section,
    we are defining the specific path on which Kubernetes should mount the volume.
    The `"/bin/sh", "-c", "ls /etc/appconfig/; cat /etc/appconfig/private-key"` command
    will print out the contents of the file loaded onto it as a Secret.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的Pod规范中，请注意`volumes`的挂载方式与我们之前挂载ConfigMap的方式相同。在`volumes`部分，我们指示Kubernetes从我们的Secret中定义一个卷。在`volumeMounts`部分，我们定义了Kubernetes应该将卷挂载到的特定路径。`"/bin/sh",
    "-c", "ls /etc/appconfig/; cat /etc/appconfig/private-key"`命令将打印出作为Secret加载到其中的文件的内容。
- en: Note
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `name` field in the `volume` and `volumeMounts` sections has to be the same
    so that Kubernetes can identify which `volume` is associated with which `volumeMounts`.
    For this example, we have used `secret-volume` as the name in both places.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`volume`和`volumeMounts`部分的`name`字段必须相同，这样Kubernetes才能识别哪个`volume`与哪个`volumeMounts`相关联。在本例中，我们在两个地方都使用了`secret-volume`作为名称。'
- en: 'Now, let''s create a Pod using the YAML file as the Pod definition using the
    following command:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令使用YAML文件作为Pod定义来创建一个Pod：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If the Pod is successfully created, you should see the following output:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Pod成功创建，您应该会看到以下输出：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To check whether our Pod has the Secret loaded, we can get its logs and examine
    them. Use the following command:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查我们的Pod是否加载了Secret，我们可以获取其日志并检查它们。使用以下命令：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The logs should show the contents of the private key, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 日志应该显示私钥的内容，如下所示：
- en: '![Figure 10.12: Getting logs of secret-test-pod'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.12：获取secret-test-pod的日志'
- en: '](image/B14870_10_12.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_12.jpg)'
- en: 'Figure 10.12: Getting logs of secret-test-pod'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：获取secret-test-pod的日志
- en: As you can see from the log, the container is displaying the contents of the
    Secret mounted onto the Pod.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从日志中可以看出，容器显示了挂载到Pod上的Secret的内容。
- en: Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since the SSH key is randomized, your output may not look exactly the same as
    the one shown here.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SSH密钥是随机的，您的输出可能与此处显示的内容不完全相同。
- en: 'The SSH key is randomized, so each time you will get a different output. You
    can try this exercise multiple times and see for yourself. Make sure to either
    delete the Pod or change the name every time. You can delete the Pod using the
    following command:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSH密钥是随机的，因此每次您都会得到不同的输出。您可以尝试多次进行此练习并自行查看。确保每次要么删除Pod，要么更改名称。您可以使用以下命令删除Pod：
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You will see the following output if the Pod is successfully deleted:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Pod成功删除，您将看到以下输出：
- en: '[PRE48]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this exercise, we created a key pair using another tool and loaded the private
    key onto our Pod by mounting it as a binary file. However, public-private key
    pairs are used for encryption in the TLS protocol, which is a cryptographic standard
    for securing web traffic.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用另一个工具创建了一个密钥对，并将私钥加载到我们的Pod中，将其作为二进制文件进行挂载。然而，在TLS协议中，公私钥对用于加密，这是一种用于保护网络流量的加密标准。
- en: Note
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about TLS, please refer to [https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/](https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关TLS的更多信息，请参考[https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/](https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/)。
- en: Kubernetes provides its own way of creating a key pair and storing keys for
    TLS. Let's see how to create a TLS Secret in the following exercise.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了自己的方式来创建密钥对并存储TLS密钥。让我们看看如何在以下练习中创建TLS Secret。
- en: 'Exercise 10.06: Creating a TLS Secret'
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.06：创建TLS密钥
- en: 'In this exercise, we will see how to create a Secret that can store a cryptographic
    key for TLS:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看到如何创建一个可以存储TLS加密密钥的Secret：
- en: 'Use the following command to create a pair of private-public keys:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一对私钥-公钥：
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This command creates the private key in the file named `tls.key`, and the public
    certificate in the file named `tls.crt`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在名为`tls.key`的文件中创建私钥，并在名为`tls.crt`的文件中创建公钥证书。
- en: Note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more details on how the **openssl** tool is used here, you can refer to
    [https://www.openssl.org/docs/manmaster/man1/req.html](https://www.openssl.org/docs/manmaster/man1/req.html).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此处如何使用**openssl**工具的更多详细信息，请参考[https://www.openssl.org/docs/manmaster/man1/req.html](https://www.openssl.org/docs/manmaster/man1/req.html)。
- en: 'If the key is successfully generated, you should see an output like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果密钥成功生成，您应该看到以下输出：
- en: '![Figure 10.13: Creating SSL keys'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.13：创建SSL密钥'
- en: '](image/B14870_10_13.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_13.jpg)'
- en: 'Figure 10.13: Creating SSL keys'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13：创建SSL密钥
- en: 'Once it is successful, we can create a Secret to hold the files using the following command:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦成功，我们可以使用以下命令创建一个Secret来保存文件：
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Once the Secret is successfully created, you will see the following output:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Secret成功创建，您将看到以下输出：
- en: '[PRE51]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Verify that our Secret is created by listing down all Secrets in the `configmap-test`
    namespace using the following command:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令列出`configmap-test`命名空间中的所有Secrets，以验证我们的Secret是否已创建：
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Our Secret must be listed in the following output:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Secret必须列在以下输出中：
- en: '![Figure 10.14: Listing down all secrets in configmap-test'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.14：列出configmap-test中的所有Secrets'
- en: '](image/B14870_10_14.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_14.jpg)'
- en: 'Figure 10.14: Listing down all secrets in configmap-test'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14：列出configmap-test中的所有Secrets
- en: 'If we issue the `describe` command for the newly created Secret, you can see
    that it stores the two parts, the public and the private key, as two different
    keys of the Secret:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们对新创建的Secret发出`describe`命令，您会看到它将两部分，即公钥和私钥，存储为Secret的两个不同键：
- en: '[PRE53]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You should see the following response:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 10.15: Describing test-tls'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.15：描述test-tls'
- en: '](image/B14870_10_15.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_15.jpg)'
- en: 'Figure 10.15: Describing test-tls'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15：描述test-tls
- en: Thus, we have created a set of public-private keys for TLS using a special set
    of commands provided by Kubernetes. This Secret can be mounted in a similar way
    as demonstrated in *Exercise 10.05*, *Defining a Secret from a File and Loading
    the Values onto the Pod as a File*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用Kubernetes提供的一组特殊命令创建了一组TLS的公钥-私钥。这个Secret可以以与*练习10.05*中演示的类似方式挂载，即*从文件定义Secret并将值加载到Pod中作为文件*。
- en: Another common task is to fetch Docker images from an external Docker registry.
    Many organizations use **enterprise container registries** (for example, Nexus)
    for their applications, which can then be fetched and deployed as needed. Kubernetes
    also provides a special type of Secret to store authentication information for
    accessing these Docker registries. Let's see how to implement it in the following exercise.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的任务是从外部Docker注册表中获取Docker镜像。许多组织使用企业容器注册表（例如Nexus）来存储其应用程序，然后根据需要获取和部署。Kubernetes还提供了一种特殊类型的Secret来存储访问这些Docker注册表的身份验证信息。让我们看看如何在以下练习中实现它。
- en: 'Exercise 10.07: Creating a docker-registry Secret'
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.07：创建一个docker-registry Secret
- en: 'In this exercise, we will create a **docker-registry** Secret that can be used
    for authentication while fetching a Docker image from a registry:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个**docker-registry** Secret，用于在从注册表获取Docker镜像时进行身份验证：
- en: 'We can create the Secret directly using the following command:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以直接使用以下命令创建Secret：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As you can see in the command arguments, we need to specify the username, password,
    and email address for the Docker account. Once the Secret is created, you should
    see the following response:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在命令参数中所看到的，我们需要指定Docker帐户的用户名、密码和电子邮件地址。一旦Secret被创建，你应该会看到以下响应：
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Verify that it is created by using this command:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用以下命令来验证它是否已创建：
- en: '[PRE56]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You should see `test-docker-registry-secret` as displayed in the following
    output:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到`test-docker-registry-secret`如下输出所示：
- en: '![Figure 10.16: Checking test-docker-registry-secret'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.16：检查test-docker-registry-secret'
- en: '](image/B14870_10_16.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_16.jpg)'
- en: 'Figure 10.16: Checking test-docker-registry-secret'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16：检查test-docker-registry-secret
- en: 'Let''s use the `describe` command and get more details about our Secret:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`describe`命令并获取有关我们的Secret的更多详细信息：
- en: '[PRE57]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The command should return the following details:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应返回以下详细信息：
- en: '![Figure 10.17: Describing test-docker-registry-secret'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.17：描述test-docker-registry-secret'
- en: '](image/B14870_10_17.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_17.jpg)'
- en: 'Figure 10.17: Describing test-docker-registry-secret'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17：描述test-docker-registry-secret
- en: As you can see under the `Data` section of the preceding output, a single key
    with the name `.dockerconfigjson` has been created.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的输出的`Data`部分中所看到的，已创建了一个名为`.dockerconfigjson`的单个键。
- en: Note
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This exercise is just an easy way to load a `.dockerconfigjson` file. You can
    create and load the file manually using other methods and achieve the same objective
    as we have in this exercise.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习只是一种加载`.dockerconfigjson`文件的简单方法。你可以使用其他方法手动创建和加载文件，并实现我们在这个练习中的相同目标。
- en: 'Activity 10.01: Using a ConfigMap and Secret to Promote an Application through
    Different Stages'
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动10.01：使用ConfigMap和Secret来推广应用程序通过不同阶段
- en: Let's assume that we have an application and we want to promote it to different
    environments. Your task is to promote the application from testing to production
    environments, and each environment has different configuration data.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个应用程序，我们想要将其推广到不同的环境。你的任务是将应用程序从测试环境推广到生产环境，每个环境都有不同的配置数据。
- en: In this activity, we will use the ConfigMap and Secret to easily reconfigure
    the application for different stages in its life cycle. It should also give you
    an idea of how the separation of ConfigMap data and Secret data from the application
    can help in the easier transition of an application through various stages of
    development and deployment.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将使用ConfigMap和Secret来轻松地为应用程序在其生命周期的不同阶段重新配置。这也应该让你了解到，将ConfigMap数据和Secret数据与应用程序分离可以帮助应用程序更容易地在开发和部署的各个阶段之间过渡。
- en: 'These guidelines should help you to complete the activity:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指南应该帮助你完成这个活动：
- en: Define a namespace called `my-app-test`.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`my-app-test`的命名空间。
- en: 'Define a ConfigMap named `my-app-data` in the `my-app-test` namespace with
    the following key values:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`my-app-test`命名空间中定义一个名为`my-app-data`的ConfigMap，并具有以下键值：
- en: '[PRE58]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Define a Secret named `my-app-secret` in the `my-app-test` namespace with the
    following key values:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`my-app-test`命名空间中定义一个名为`my-app-secret`的Secret，并具有以下键值：
- en: '[PRE59]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Define a Pod specification and deploy the ConfigMap in the `/etc/app-data` folder
    with the filename `application-data.properties`.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个Pod规范，并在`/etc/app-data`文件夹中部署ConfigMap，文件名为`application-data.properties`。
- en: Define a Pod specification and deploy the Secret in the `/etc/secure-data` folder
    with the filename `application-secure.properties`.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个Pod规范，并在`/etc/secure-data`文件夹中部署Secret，文件名为`application-secure.properties`。
- en: 'Run the Pod so that it displays all the contents from the ConfigMap and the
    Secret. You should see something like this:![Figure 10.18: Key values for the
    test environment'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Pod，以便它显示ConfigMap和Secret中的所有内容。你应该看到类似这样的东西：![图10.18：测试环境的键值
- en: '](image/B14870_10_18.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_18.jpg)'
- en: 'Figure 10.18: Key values for the test environment'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18：测试环境的键值
- en: Define another namespace called `my-app-production`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义另一个名为`my-app-production`的命名空间。
- en: 'Define a ConfigMap named `my-app-data` in `my-app-production` with the following
    key values:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`my-app-production`中定义一个名为`my-app-data`的ConfigMap，具有以下键值：
- en: '[PRE60]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Define a Secret named `my-app-secret` in `my-app-production` with the following
    key values:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`my-app-production`中定义一个名为`my-app-secret`的Secret，具有以下键值：
- en: '[PRE61]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Use the same Pod specification as defined in *step 5* and run the Pod in the
    `my-app-production` namespace.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与*步骤5*中定义的相同的Pod规范，并在`my-app-production`命名空间中运行Pod。
- en: 'Check whether the application running in `my-app-production` displays the correct
    data. You should see output like this:![Figure 10.19: Key values for the production
    environment'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查在`my-app-production`中运行的应用程序是否显示了正确的数据。你应该看到类似这样的输出：![图10.19：生产环境的键值
- en: '](image/B14870_10_19.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_10_19.jpg)'
- en: 'Figure 10.19: Key values for the production environment'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19：生产环境的键值
- en: Note
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).
    The GitHub repository also includes a Bash script for this activity, which will
    execute all these solution steps automatically. However, please take a look at
    the detailed steps provided in the solution to get a complete understanding of
    how to perform the activity.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在以下地址找到：[https://packt.live/304PEoD](https://packt.live/304PEoD)。GitHub存储库还包括了一个用于此活动的Bash脚本，它将自动执行所有这些解决方案步骤。但是，请查看解决方案中提供的详细步骤，以完全了解如何执行该活动。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen the different ways that Kubernetes provides to
    associate environment-specific data with our applications running as containers.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到Kubernetes提供的不同方式，用于将环境特定数据与作为容器运行的应用程序相关联。
- en: Kubernetes provides ways to store sensitive data as Secrets and normal application
    data as ConfigMaps. We have also seen how to create ConfigMaps and Secrets and
    associate them with our containers via CLI. Running everything via the command
    line will facilitate the automation of these steps and improve the overall agility
    of your application.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了将敏感数据存储为Secrets和将普通应用程序数据存储为ConfigMaps的方式。我们还看到了如何通过CLI创建ConfigMaps和Secrets，并将它们与我们的容器关联起来。通过命令行运行所有内容将有助于自动化这些步骤，并提高应用程序的整体灵活性。
- en: Associating data with containers enables us to use the same container across
    different environments in our IT systems (for example, in test and production).
    Using the same container across different environments provides a way for secure
    and trusted code promotion techniques for IT processes. Each team can use a container
    as a unit of deployment and sign the container so that other parties can trust
    the container. This also provides a trusted way of distributing code not only
    across the same IT organizations but also across multiple organizations. For example,
    a software vendor can just provide you with a container as packaged software.
    ConfigMaps and Secrets can then be used to provide specific configurations for
    using the packaged software in your organization.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据与容器关联使我们能够在IT系统的不同环境中使用相同的容器（例如，在测试和生产环境中）。在不同环境中使用相同的容器为IT流程提供了安全和可信的代码推广技术。每个团队都可以将容器作为部署单元，并对容器进行签名，以便其他方可以信任该容器。这也为分发代码提供了一种可信赖的方式，不仅可以在同一IT组织内部，还可以跨多个组织之间进行。例如，软件供应商可以直接向您提供打包软件的容器。然后可以使用ConfigMaps和Secrets来提供特定的配置，以在您的组织中使用打包软件。
- en: The next set of chapters is all about deploying Kubernetes and running it in
    high availability mode. These chapters will provide you with fundamental and practical
    knowledge regarding how to run stable clusters for Kubernetes.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节都是关于部署Kubernetes并在高可用模式下运行它。这些章节将为您提供关于如何运行稳定的Kubernetes集群的基本和实用知识。
