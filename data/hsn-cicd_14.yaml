- en: CircleCI UI Logging and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CircleCI UI日志记录和调试
- en: In the previous chapter, we covered CircleCI CLI commands in depth and showed
    you some techniques to automate tasks in CircleCI. In this chapter, we will cover
    the Job Log in depth and explain the run steps in more detail. We will explain
    the workflows concept and show you how to use the CircleCI API to find the most
    recent builds for a project. We will look at how to debug a slow job by implementing
    caching in a build, and will finish by using some troubleshooting techniques to
    run a build with a local config YML script.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们深入介绍了CircleCI CLI命令，并向您展示了一些自动化任务的技术。在本章中，我们将深入介绍作业日志，并更详细地解释运行步骤。我们将解释工作流程的概念，并向您展示如何使用CircleCI
    API查找项目的最新构建。我们将介绍如何通过在构建中实现缓存来调试慢作业，并最后使用一些故障排除技术来运行具有本地配置YML脚本的构建。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Job log overview
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作业日志概述
- en: Debugging slow builds in CircleCI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CircleCI中调试慢构建
- en: Logging and troubleshooting techniques
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录和故障排除技术
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we cover some concepts about using RESTful APIs and will use
    the `curl` utility to make REST calls, so it would be good to understand what
    an API is and how to use a REST client such as `curl`. It would also be helpful
    to have a rudimentary understanding of the Unix programming environment and it
    would be beneficial to understand what scripting is and what a Bash environment
    is.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些关于使用RESTful API的概念，并将使用`curl`实用程序进行REST调用，因此了解API是什么以及如何使用REST客户端（如`curl`）将是有益的。了解Unix编程环境的基本概念也会有所帮助，了解脚本编写和Bash环境是有益的。
- en: 'The code files for this chapter can be found at the following links:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下链接找到：
- en: '[https://github.com/packtci/circleci-jobs-example](https://github.com/packtci/circleci-jobs-example)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/packtci/circleci-jobs-example](https://github.com/packtci/circleci-jobs-example)'
- en: '[https://github.com/packtci/go-template-example-with-circle-ci](https://github.com/packtci/go-template-example-with-circle-ci)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/packtci/go-template-example-with-circle-ci](https://github.com/packtci/go-template-example-with-circle-ci)'
- en: Job log overview
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业日志概述
- en: The job log in CircleCI is different than in Travis CI, as each step in each
    job is run in a separate non-login shell and CircleCI sets some smart defaults
    for each step in the job.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI中的作业日志与Travis CI中的不同，因为每个作业中的每个步骤都在单独的非登录shell中运行，并且CircleCI为作业中的每个步骤设置了一些智能默认值。
- en: Run steps in job with a default build job
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认构建作业中的运行步骤
- en: We will create a new repository to demonstrate multiple jobs in the default
    build job. The repository will be called `circleci-jobs-example` ([https://github.com/packtci/circleci-jobs-example](https://github.com/packtci/circleci-jobs-example)) and
    will have multiple run declarations in the build job. We will be using Node.js
    as our programming language of choice for demonstration purposes. Remember that
    we need to add the new project to CircleCI so that it can become aware of our
    project. In the previous chapters, we added the projects using the CircleCI web
    UI, but let's use the CircleCI API to add our new project to CircleCI.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的存储库，以演示默认构建作业中的多个作业。该存储库将被称为`circleci-jobs-example`（[https://github.com/packtci/circleci-jobs-example](https://github.com/packtci/circleci-jobs-example)），并将在构建作业中有多个运行声明。我们将使用Node.js作为我们的首选编程语言进行演示。请记住，我们需要将新项目添加到CircleCI中，以便它能够了解我们的项目。在之前的章节中，我们使用CircleCI
    Web UI添加了项目，但让我们使用CircleCI API将新项目添加到CircleCI中。
- en: Adding a project to CircleCI via the API
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过API将项目添加到CircleCI
- en: We learned how to work with the CircleCI API in [Chapter 13](98200aa9-aa3f-40d8-9f9e-d675fc2c67b8.xhtml), *CircleCI
    CLI Commands and Automation*, so please read the *Working with the CircleCI API* section
    of that chapter for more details on working with the API. If you already read
    this, then you will already have an API token that you can use. The API endpoint
    to follow for new projects on CircleCI ([https://circleci.com/docs/api/v1-reference/#follow-project](https://circleci.com/docs/api/v1-reference/#follow-project))
    shows that you need to make a `POST HTTP` request and add your API token as a
    query string parameter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第13章](98200aa9-aa3f-40d8-9f9e-d675fc2c67b8.xhtml)中学习了如何使用CircleCI API，因此请阅读该章节的*使用CircleCI
    API*部分，以获取有关使用API的更多详细信息。如果您已经阅读过这部分内容，那么您已经有一个可以使用的API令牌。关于在CircleCI上关注新项目的API端点（[https://circleci.com/docs/api/v1-reference/#follow-project](https://circleci.com/docs/api/v1-reference/#follow-project)）显示您需要进行`POST
    HTTP`请求并将API令牌作为查询字符串参数添加。
- en: Using curl as a REST client
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用curl作为REST客户端
- en: 'We have already used `curl` as a REST client throughout the book, so you should
    be familiar with how to use it by now. We will be making a `POST` request to the
    following endpoint `https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/follow?circle-token=:token`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在整本书中使用`curl`作为REST客户端，所以您现在应该熟悉如何使用它。我们将向以下端点进行`POST`请求：`https://circleci.com/api/v1.1/project/:vcs-type/:username/:project/follow?circle-token=:token`：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here we use an environment variable called `CIRCLECI_API_TOKEN_GITHUB` that
    is set in our local environment, and we get the following response from the API:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个名为`CIRCLECI_API_TOKEN_GITHUB`的环境变量，该变量在我们的本地环境中设置，并且我们从API中获得了以下响应：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Parse build_url attribute from the JSON response
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从JSON响应中解析build_url属性
- en: 'Let''s save this response into a new file we call `circleci-jobs-example-follow.json`
    by using the cat utility in a Terminal shell session, like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用终端shell会话中的cat实用程序将此响应保存到一个名为`circleci-jobs-example-follow.json`的新文件中，就像这样：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now let''s use the `jq` ([https://stedolan.github.io/jq/manual/](https://stedolan.github.io/jq/manual/))
    and find the `build_url` attribute in the JSON payload:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用`jq`（[https://stedolan.github.io/jq/manual/](https://stedolan.github.io/jq/manual/)）并在JSON负载中找到`build_url`属性：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command returns the following build URL: `https://circleci.com/gh/packtci/circleci-jobs-example/1`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令返回以下构建URL：`https://circleci.com/gh/packtci/circleci-jobs-example/1`。
- en: 'Now you can either open a browser and paste this URL in or you can use a command-line
    utility available on your operating system. We will use the `open` utility in
    macOS like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以打开浏览器并粘贴此URL，或者你可以使用操作系统上可用的命令行实用程序。我们将在macOS中使用`open`实用程序，就像这样：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding command will open the default browser in macOS and use the URL
    that you provide. In Linux, you might be able to use `xdg-open`, `gnome-open`,
    or `kde-open` depending on the OS that you have installed. Either way you can
    simply open a browser and paste the entry for the build URL.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将在macOS中打开默认浏览器并使用您提供的URL。在Linux中，您可能可以使用`xdg-open`，`gnome-open`或`kde-open`，具体取决于您安装的操作系统。无论哪种方式，您都可以简单地打开浏览器并粘贴构建URL的条目。
- en: CircleCI Web UI job log analysis
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CircleCI Web UI作业日志分析
- en: 'When we open the URL for the new job that we triggered via the API, the first
    part of the UI looks like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开通过API触发的新工作的URL时，UI的第一部分看起来像这样：
- en: '![](assets/2cdea96c-0964-4ef7-8259-cff00e265fca.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2cdea96c-0964-4ef7-8259-cff00e265fca.png)'
- en: 'Notice here that the top part shows basic information such as the commit SHA
    hash, the contributor information, and other background information. If you scroll
    down further in the job log, you will see the steps run in each part of the job:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，顶部显示基本信息，例如提交SHA哈希、贡献者信息和其他背景信息。如果您在作业日志中进一步向下滚动，您将看到作业的每个部分中运行的步骤：
- en: '![](assets/fc15a2a7-11ff-4ded-a001-8c0a39c8480a.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fc15a2a7-11ff-4ded-a001-8c0a39c8480a.png)'
- en: The build took 9 seconds to complete and notice here that each step in the build
    has its own section that is conveniently collapsed. You simply click on each section
    to get the details of the step. The names of each step correspond to the `name`
    field in the config YML script.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成需要9秒，注意到每个构建步骤都有自己的部分，这些部分都很方便地折叠起来。您只需点击每个部分即可获取步骤的详细信息。每个步骤的名称对应于配置YML脚本中的`name`字段。
- en: Notice that the name of the multi-line command used the name of the full command
    as its name.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，多行命令的名称使用完整命令的名称作为其名称。
- en: 'This was the entry for the multi-line command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是多行命令的条目：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we expand one of the steps we will see the following entries common to each:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们展开一个步骤，我们将看到每个步骤都有以下共同的条目：
- en: '![](assets/f1f58407-568f-44d3-ad07-b4c9e05ccd51.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f1f58407-568f-44d3-ad07-b4c9e05ccd51.png)'
- en: The **Shebang** line `#!/bin/bash -eo pipefail` has set some sensible defaults
    for the non-login shell.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shebang**行`#!/bin/bash -eo pipefail`为非登录shell设置了一些明智的默认值。'
- en: 'The Bash option `-e` means that the script should exit if a statement returns
    a non-true value. The Bash option `-o  pipefail` means use the error status of
    the first failure, rather than that of the last item in a pipeline. Instead of
    adding these options in the Shebang line, you could do the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Bash选项`-e`表示如果语句返回非真值，则脚本应该退出。Bash选项`-o pipefail`表示使用第一个失败的错误状态，而不是管道中最后一项的错误状态。您可以不在Shebang行中添加这些选项，而是可以这样做：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we look at another step in the job, we see the same thing is done:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看工作中的另一个步骤，我们会看到相同的事情：
- en: '![](assets/9eea6aec-a651-45d8-b7d5-66c481852af3.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9eea6aec-a651-45d8-b7d5-66c481852af3.png)'
- en: CircleCI does this in each step of a job because it helps us troubleshoot issues
    that occur when writing shell scripts, and it helps promote best practices when
    writing shell scripts.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI在作业的每个步骤中都这样做，因为它有助于我们解决编写shell脚本时出现的问题，并有助于促进编写shell脚本的最佳实践。
- en: 'Here is an example of a command that can fail that will report errors in the
    wrong spot of a build when using a Unix pipeline:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可能失败的命令的示例，当使用Unix管道时，它将在构建的错误位置报告错误：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this pipeline, we list all the containers that are running, exited, or terminated
    for some reason and then pipe this into the `grep` utility and exclude any entries
    that have the text `busybox:latest` and then pipe this into the `awk` utility
    and only print the first column. We finally pipe this back into `grep` and exclude
    the text `CONTAINER`. This pipeline could fail at any chain of the pipeline but
    because we used the option `set -o pipefail` the script will fail on the first
    command that returns a non-true option. This is helpful because the default behavior
    is to report the last item in the pipeline.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个流水线中，我们列出了所有正在运行、退出或因某种原因终止的容器，然后将其传输到`grep`实用程序中，并排除任何具有文本`busybox:latest`的条目，然后将其传输到`awk`实用程序中，并仅打印第一列。最后，我们将其传输回`grep`并排除文本`CONTAINER`。这个流水线可能在任何一条流水线链中失败，但因为我们使用了选项`set
    -o pipefail`，脚本将在返回非真选项的第一个命令上失败。这很有帮助，因为默认行为是报告管道中的最后一项。
- en: Another aspect of the run declaration commands are that they are executed using
    non-login shells by default. This means that you must explicitly source any hidden
    files such as **dotfiles** as part of the command that is run, or else you risk
    not having environment variables ready to use as you might expect.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 运行声明命令的另一个方面是，默认情况下它们是使用非登录shell执行的。这意味着您必须显式地源化任何隐藏文件，例如**dotfiles**，作为运行的一部分，否则您可能没有准备好使用的环境变量。
- en: 'Here is an example to illustrate this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例来说明这一点：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, notice that the exit code is printed for each run declaration in the
    upper-right side:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，退出代码会打印在右上角的每个运行声明中：
- en: '![](assets/ab1f0883-87bf-4e05-bfa7-c5034ef1a511.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ab1f0883-87bf-4e05-bfa7-c5034ef1a511.png)'
- en: You can also see a helpful button in the top-right corner, which will scroll
    you further down into the particular run step you are interested in seeing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在右上角看到一个有用的按钮，它将使您进一步滚动到您感兴趣的特定运行步骤中。
- en: Best practices for environment variable safe usage
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境变量安全使用的最佳实践
- en: It is important that you do not add secrets inside of the `.circleci/config`
    YML script file. If you do, you may leak secret information on the job log that
    may be publicly accessible. The full text of the `config.yml` is visible to developers
    with access to your project on CircleCI, so instead store your secrets and/or
    keys in Project or Context settings in the CircleCI app. Running scripts within
    configuration may expose secret environment variables so be careful when using
    the `set -o xtrace / set -x` in your run steps as they might expose environment
    variables.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，不要在`.circleci/config` YML脚本文件中添加机密信息。如果这样做，可能会在作业日志中泄露机密信息，这些信息可能是公开可访问的。`config.yml`的完整文本对于在CircleCI上访问您的项目的开发人员是可见的，因此请将您的机密信息和/或密钥存储在CircleCI应用程序中的项目或上下文设置中。在配置中运行脚本可能会暴露机密环境变量，因此在运行步骤中使用`set
    -o xtrace / set -x`时要小心，因为它们可能会暴露环境变量。
- en: One thing to note is that all environment variables are encrypted using Hashicorp
    Vault ([https://www.vaultproject.io/](https://www.vaultproject.io/)) and environment
    variables are encrypted using AES256-GCM96 and are unavailable to any CircleCI
    employees.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，所有环境变量都使用Hashicorp Vault ([https://www.vaultproject.io/](https://www.vaultproject.io/))进行加密，环境变量使用AES256-GCM96进行加密，并且对任何CircleCI员工都不可用。
- en: Run steps in job with workflows
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工作流在作业中运行步骤
- en: According to the Circle CI Documentation on **workflows** ([https://circleci.com/docs/2.0/workflows/](https://circleci.com/docs/2.0/workflows/)),
    a workflow is a set of rules for defining a collection of jobs and their run order.
    Workflows support complex job orchestration using a simple set of configuration
    keys to help you resolve failures sooner.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Circle CI文档关于**工作流**（[https://circleci.com/docs/2.0/workflows/](https://circleci.com/docs/2.0/workflows/)），一个工作流是一组规则，用于定义一组作业及其运行顺序。工作流支持使用一组简单的配置键进行复杂的作业编排，以帮助您更早地解决故障。
- en: We will use workflows in order to separate our jobs into more appropriate sections
    and then also to take advantage of the fact that some scripts are independent
    of each other and can be run separately. We can speed up our build process by
    using workflows in CircleCI.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用工作流来将我们的作业分成更合适的部分，然后利用一些脚本彼此独立并可以分开运行的事实。通过在CircleCI中使用工作流，我们可以加快构建过程。
- en: 'Now let''s think of the parts of the job that can be broken into separate steps
    in our build process. We can break the dependency step into a separate part of
    the build and then we can just collapse the individual steps we ran for the three
    tests into one step called test. Remember that the steps look like this in the
    config YML script:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑作业的哪些部分可以在我们的构建过程中分解为单独的步骤。我们可以将依赖步骤分解为构建的一个单独部分，然后我们可以将为三个测试运行的各个步骤合并为一个名为测试的步骤。请记住，配置YML脚本中的步骤如下所示：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the last step, we have the command `npm test` and this command references
    the following command specified in the `package.json` file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们有命令`npm test`，这个命令引用了`package.json`文件中指定的以下命令：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice that this command runs all the tests already and then reports coverage
    using the NYC code coverage utility. The last command generates a Cobertura XML
    report that we will use later in the chapter. We will now rewrite the series of
    steps into their own field called `test`, and it will look like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此命令已经运行了所有测试，然后使用NYC代码覆盖率实用程序报告覆盖率。最后一个命令生成了一个Cobertura XML报告，我们将在本章后面使用。现在，我们将把一系列步骤重写为它们自己的字段，称为`test`，它将如下所示：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice here that I gave a more appropriate name to the collapsed command and
    also notice that we can use a multi-line command in the `command` field itself
    using the pipe (`|`) operator.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我给折叠命令一个更合适的名称，并且请注意，我们可以在`command`字段本身使用管道(`|`)运算符使用多行命令。
- en: We will add a deploy section like we did in [Chapter 13](98200aa9-aa3f-40d8-9f9e-d675fc2c67b8.xhtml),
    *CircleCI CLI Commands and Automation*, which will deploy our application into
    **Heroku** ([https://dashboard.heroku.com/apps](https://dashboard.heroku.com/apps)).
    If you don't understand what Heroku is then please read [Chapter 11](f2319c39-b2e4-40cb-b1bb-53daa589776b.xhtml),* Travis
    CI UI Logging and Debugging*, and read the *Travis CI deployment overview and
    debugging* section for more details.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个部署部分，就像我们在[第13章](98200aa9-aa3f-40d8-9f9e-d675fc2c67b8.xhtml)中所做的那样，*CircleCI
    CLI命令和自动化*，这将把我们的应用程序部署到**Heroku** ([https://dashboard.heroku.com/apps](https://dashboard.heroku.com/apps))。如果您不了解Heroku是什么，请阅读[第11章](f2319c39-b2e4-40cb-b1bb-53daa589776b.xhtml)，*Travis
    CI UI日志和调试*，并阅读*Travis CI部署概述和调试*部分以获取更多详细信息。
- en: Adding a workflows section to the config YML script
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向配置YML脚本添加工作流部分
- en: 'We will add the `workflows` section to the bottom of our config YML script,
    but we could also add it to the beginning of our config YML script. Here is the
    updated config YML script:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的配置YML脚本底部添加`workflows`部分，但我们也可以将其添加到配置YML脚本的开头。更新后的配置YML脚本如下：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once we finish updating the config YML script, we should ensure that our config
    YML script is still valid by using CircleCI CLI, like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 完成更新配置YML脚本后，我们应该使用CircleCI CLI确保我们的配置YML脚本仍然有效，就像这样：
- en: '![](assets/172ae51b-27ce-4f50-87c0-b7d5ba3c636f.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/172ae51b-27ce-4f50-87c0-b7d5ba3c636f.png)'
- en: 'It looks like we have an issue in our config YML script in line 19:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们在第19行的配置YML脚本中有问题：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is actually a subtle bug in our config YML script because we did not properly
    indent the multi-line command and so CircleCI does not know where our multi-line
    command starts. Here is the updated config YML script section now:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是我们配置YML脚本中的一个细微错误，因为我们没有正确缩进多行命令，所以CircleCI不知道我们的多行命令从哪里开始。现在更新的配置YML脚本部分如下：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now let''s run the CircleCI CLI validation again:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再次运行CircleCI CLI验证：
- en: '![](assets/d30bf085-04b1-480d-95c6-d9cd715105b1.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d30bf085-04b1-480d-95c6-d9cd715105b1.png)'
- en: 'Our config YML script is valid, so now let''s commit this into source control
    by issuing the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的配置YML脚本是有效的，现在让我们通过发出以下命令将其提交到源代码控制中：
- en: '![](assets/02d14c9b-c808-4609-8163-a271dfac267a.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/02d14c9b-c808-4609-8163-a271dfac267a.png)'
- en: 'Notice here that we gave a descriptive commit message which is good practice
    to do in version control if anything you are working with has a particular tag,
    such as JIRA for instance; you could add it like this for example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里给出了一个描述性的提交消息，在版本控制中这是一个很好的做法，如果你正在处理的任何东西有一个特定的标签，比如JIRA；你可以像这样添加它，例如：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using the CircleCI API to find the most recent build URL
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CircleCI API查找最近的构建URL
- en: We can certainly use the CircleCI web app and click the `workflows` section
    and find our most recent build, but let's use the CircleCI API instead and use
    `jq` to parse the JSON response payload as we have done before for other API endpoints.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以使用CircleCI Web应用程序，点击`工作流`部分，找到我们最近的构建，但让我们改用CircleCI API，使用`jq`来解析JSON响应有效负载，就像我们以前对其他API端点所做的那样。
- en: 'Here is a command that will pipe output from the `/recent-builds` API endpoint to
    `jq` and return the first `build_url` from the array of objects, which will be
    the most recent build, and then pipe that into the system clipboard. We can see
    the shape of the JSON in the recent build project in the [https://circleci.com/docs/api/v1-reference/#recent-builds-project](https://circleci.com/docs/api/v1-reference/#recent-builds-project) documentation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个命令，它将从`/recent-builds` API端点的输出传输到`jq`，并从对象数组中返回第一个`build_url`，这将是最近的构建，然后将其传输到系统剪贴板。我们可以在[https://circleci.com/docs/api/v1-reference/#recent-builds-project](https://circleci.com/docs/api/v1-reference/#recent-builds-project)文档中看到最近构建项目中JSON的形状：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This returns the following URL to the Terminal: [https://circleci.com/gh/packtci/circleci-jobs-example/6](https://circleci.com/gh/packtci/circleci-jobs-example/6).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在终端返回以下URL：[https://circleci.com/gh/packtci/circleci-jobs-example/6](https://circleci.com/gh/packtci/circleci-jobs-example/6)。
- en: 'Now let''s go to this URL and look at the recent build; we will notice that
    the build failed:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到这个URL并查看最近的构建；我们会注意到构建失败了：
- en: '![](assets/5f71ae09-eeff-457c-af70-1d010502b50d.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5f71ae09-eeff-457c-af70-1d010502b50d.png)'
- en: 'The build failed because we didn''t set the necessary environment variables
    that our config YML script is referencing, namely `HEROKU_API_KEY` and `HEROKU_APP_NAME`.
    We covered how to set project-level environment variables in [Chapter 13](98200aa9-aa3f-40d8-9f9e-d675fc2c67b8.xhtml),
    *CircleCI CLI Commands and Automation*, but we only need to copy over the project
    environment-level variables. CircleCI has an easy way to do that if the environment
    variables are the same:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 构建失败是因为我们没有设置配置YML脚本引用的必要的环境变量，即`HEROKU_API_KEY`和`HEROKU_APP_NAME`。我们在[第13章](98200aa9-aa3f-40d8-9f9e-d675fc2c67b8.xhtml)中介绍了如何设置项目级别的环境变量，*CircleCI
    CLI命令和自动化*，但我们只需要复制项目环境级别的变量。如果环境变量相同，CircleCI有一种简单的方法可以做到这一点：
- en: '![](assets/23f2ea2c-3ec2-430c-ae93-6776446ea6ce.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/23f2ea2c-3ec2-430c-ae93-6776446ea6ce.png)'
- en: 'Click the Import Variables button and then enter the project you want to copy,
    like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 点击导入变量按钮，然后输入要复制的项目，就像这样：
- en: '![](assets/4fdd3ecd-aff0-4bd4-8998-fa4fc861d325.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4fdd3ecd-aff0-4bd4-8998-fa4fc861d325.png)'
- en: 'Notice here that I only checked the `HEROKU_API_KEY` environment variable,
    and I will manually set the `HEROKU_APP_NAME` as it will be different for the
    `circleci-jobs-example` ([https://github.com/packtci/circleci-jobs-example](https://github.com/packtci/circleci-jobs-example))
    project:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我只检查了`HEROKU_API_KEY`环境变量，并且我将手动设置`HEROKU_APP_NAME`，因为它对于`circleci-jobs-example`（[https://github.com/packtci/circleci-jobs-example](https://github.com/packtci/circleci-jobs-example)）项目来说是不同的：
- en: '![](assets/65efefb3-627d-43a0-ada8-b3c12adf66e1.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/65efefb3-627d-43a0-ada8-b3c12adf66e1.png)'
- en: 'Now, with these environment variables set, let''s retry the same build using
    the Retries the build, returns a summary of the new build [https://circleci.com/docs/api/v1-reference/#retry-build](https://circleci.com/docs/api/v1-reference/#retry-build)
    API endpoint. We will use `curl` to make a call to the endpoint like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，设置了这些环境变量，让我们使用重试构建，使用[https://circleci.com/docs/api/v1-reference/#retry-build](https://circleci.com/docs/api/v1-reference/#retry-build)
    API端点。我们将使用`curl`来调用端点，就像这样：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can verify that the build was fixed by copying the `build_url` value
    that is returned to standard output, which is [https://circleci.com/gh/packtci/circleci-jobs-example/7](https://circleci.com/gh/packtci/circleci-jobs-example/7):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过复制返回到标准输出的`build_url`值来验证构建是否已修复，即[https://circleci.com/gh/packtci/circleci-jobs-example/7](https://circleci.com/gh/packtci/circleci-jobs-example/7)：
- en: '![](assets/9cef3f2d-bb60-4bbb-aef6-60d263a034fd.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9cef3f2d-bb60-4bbb-aef6-60d263a034fd.png)'
- en: Debugging slow builds in CircleCI
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CircleCI中调试慢构建
- en: 'A build may be slow in CircleCI due to a myriad of reasons. Let''s look at
    a workflow example for `go-template-example-with-circleci` ([https://circleci.com/workflow-run/533ee47a-a990-4679-826b-7b24221df2ca](https://circleci.com/workflow-run/533ee47a-a990-4679-826b-7b24221df2ca)):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在CircleCI中构建可能会因为多种原因而变慢。让我们看一个`go-template-example-with-circleci`（[https://circleci.com/workflow-run/533ee47a-a990-4679-826b-7b24221df2ca](https://circleci.com/workflow-run/533ee47a-a990-4679-826b-7b24221df2ca)）的工作流示例：
- en: '![](assets/981fe466-033f-40b6-b96e-5f0c36cab983.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/981fe466-033f-40b6-b96e-5f0c36cab983.png)'
- en: 'In particular, notice that the integration job took over a minute to finish
    and the deploy job took over a minute to finish as well, which is making the build
    take 3 minutes and 20 seconds to complete. If we click on the integration job,
    we see the following steps in the job:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 特别要注意的是，集成作业花了一分钟多的时间才完成，部署作业也花了一分钟多的时间，这使得构建需要3分钟20秒才能完成。如果我们点击集成作业，我们会看到作业中的以下步骤：
- en: '![](assets/483ce70d-5733-4a96-b693-88ad8ebf0fd2.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/483ce70d-5733-4a96-b693-88ad8ebf0fd2.png)'
- en: 'Notice here that the `npm install` took 1 minute and 3 seconds to finish. Let''s
    open up the run step call `npm install` for further details:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`npm install`花了1分钟3秒才完成。让我们打开运行步骤调用`npm install`以获取更多细节：
- en: '![](assets/61089a41-181b-4d56-984c-dacca67144b4.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/61089a41-181b-4d56-984c-dacca67144b4.png)'
- en: 'The only dependency we have is for `cypress.io`, but we are not caching this
    dependency so it will run this step every time. CircleCI has a way for us to cache
    our node dependencies by utilizing two field declarations called `save_cache`
    ([https://circleci.com/docs/2.0/configuration-reference/#save_cache](https://circleci.com/docs/2.0/configuration-reference/#save_cache))
    and `restore_cache` ([https://circleci.com/docs/2.0/configuration-reference/#restore_cache](https://circleci.com/docs/2.0/configuration-reference/#restore_cache))
    respectively. Let''s update the config YML script to use this caching strategy
    for the integration build:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一的依赖是`cypress.io`，但我们没有缓存这个依赖，所以它将每次运行这个步骤。CircleCI有一种方法让我们通过利用称为`save_cache`（[https://circleci.com/docs/2.0/configuration-reference/#save_cache](https://circleci.com/docs/2.0/configuration-reference/#save_cache)）和`restore_cache`（[https://circleci.com/docs/2.0/configuration-reference/#restore_cache](https://circleci.com/docs/2.0/configuration-reference/#restore_cache)）的两个字段声明来缓存我们的节点依赖。让我们更新配置YML脚本以使用这种缓存策略进行集成构建：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Notice here that we have placed the `restore_cache` step before the `npm install`
    and then placed the `save_cache` step after the `npm install` step. We also use
    a key field in both fields. The key value is immutable and we are using a prefix
    of `v2` as a way to version our cache key values and then getting the checksum
    for the `package.json` file. If we want to invalidate the cache for any changes,
    we can simply increment the cache value value by one, `v3` for example. Also notice
    that we have a paths field and we specify the paths to be the `~/.npm` and `~/.cache` directories.
    The cypress test runner expects the binary to be saved into a directory like this,
    or else it will throw an error. Let''s push this change up to source control and
    trigger a new build and look at the job log. Now let''s use a call to the recent
    builds API endpoint and copy the URL and see how the build went:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们在`npm install`之前放置了`restore_cache`步骤，然后在`npm install`步骤之后放置了`save_cache`步骤。我们还在两个字段中使用了一个关键字段。关键值是不可变的，我们使用`v2`作为缓存关键值的版本，并获取`package.json`文件的校验和。如果我们想要使任何更改无效缓存，我们可以简单地将缓存值增加一，例如`v3`。还要注意，我们有一个路径字段，并且我们指定路径为`~/.npm`和`~/.cache`目录。Cypress测试运行程序期望将二进制文件保存到这样的目录中，否则它将抛出错误。让我们将这个更改推送到源代码控制，并触发新的构建并查看作业日志。现在让我们使用对最近构建API端点的调用，并复制URL并查看构建的情况：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will need to copy the `build_url` entry that gets printed onto standard
    output and paste the URL into a browser. The `build_url` will open the current
    build, and from this page we can easily navigate to the workflow for that particular
    job by clicking a link that looks like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要复制打印到标准输出的`build_url`条目，并将URL粘贴到浏览器中。`build_url`将打开当前构建，从这个页面我们可以轻松地通过点击一个类似这样的链接来导航到该特定作业的工作流程：
- en: '![](assets/16b0eb39-214c-4e20-883c-3194eaf44328.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/16b0eb39-214c-4e20-883c-3194eaf44328.png)'
- en: 'We can click on the `build_integration_and_deploy` link under the Workflow
    label to get to the workflow. We now have the following steps in the integration
    build:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以点击工作流标签下的`build_integration_and_deploy`链接来到工作流。现在我们在集成构建中有以下步骤：
- en: '![](assets/484d1a04-bfb7-4def-a4c4-2b2f884f2ede.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/484d1a04-bfb7-4def-a4c4-2b2f884f2ede.png)'
- en: 'If we expand the Restoring Cache dropdown we can see the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们展开恢复缓存下拉菜单，我们会看到以下内容：
- en: '![](assets/6bcfdf16-3ead-403c-ba75-cb4eaeb4c0c9.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6bcfdf16-3ead-403c-ba75-cb4eaeb4c0c9.png)'
- en: Notice here that no cache was found, which is expected since this is the first
    run of the build with this step added.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这里没有找到缓存，这是预期的，因为这是添加了这个步骤的构建的第一次运行。
- en: 'If we expand the Saving Cache button we can see the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们展开保存缓存按钮，我们会看到以下内容：
- en: '![](assets/9ce4f386-d53e-4f5f-9c3b-b986d6a32341.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9ce4f386-d53e-4f5f-9c3b-b986d6a32341.png)'
- en: Notice here that a cache archive was created and stored in the `node_modules`
    path as we specified the paths field in the config YML script.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这里创建了一个缓存存档，并存储在配置YML脚本中指定的`node_modules`路径中。
- en: 'Let''s make a simple text change in the `README.md` file and commit the change
    to trigger a new build. We will find the latest build using the API as we have
    been doing. Now let''s look at the new job log for the integration job:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`README.md`文件中进行一个简单的文本更改，并提交更改以触发新的构建。我们将使用API找到最新的构建，就像我们一直在做的那样。现在让我们看一下集成作业的新作业日志：
- en: '![](assets/494a1dac-4c9c-4710-aa41-8f50406f766c.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/494a1dac-4c9c-4710-aa41-8f50406f766c.png)'
- en: 'Notice that the build went from 1 minute 20 seconds to 33 seconds. If we open
    the Restoring Cache dropdown, we see the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到构建时间从1分20秒减少到33秒。如果我们展开恢复缓存下拉菜单，我们会看到以下内容：
- en: '![](assets/c63045ce-4cb1-47e1-a851-643647b5ba9c.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c63045ce-4cb1-47e1-a851-643647b5ba9c.png)'
- en: 'Now let''s look at the Saving Cache step:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下保存缓存的步骤：
- en: '![](assets/28cf1c30-fdd9-4363-b4c9-ce237f4839c7.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/28cf1c30-fdd9-4363-b4c9-ce237f4839c7.png)'
- en: Notice here that it skipped the cache generation as it was able to find the
    cache that we saved from the previous build.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到它跳过了缓存生成，因为它能够找到我们从上一次构建中保存的缓存。
- en: Logging and troubleshooting techniques
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录和故障排除技术
- en: We can troubleshoot a problematic config YML script without having to make Git
    commits by using the CircleCI API. One technique that we can do is to create another
    folder and place a duplicate of our config YML script into it and then use this
    YML script as our debugging script. Once we can verify that the YML script is
    working correctly we can update the original YML script. This is useful since
    we won't be clogging up the Git history with troubleshooting commits but instead
    we will hit the CircleCI API directly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用CircleCI API来排除有问题的配置YML脚本，而无需进行Git提交。我们可以做的一个技巧是创建另一个文件夹，并将我们的配置YML脚本的副本放入其中，然后使用这个YML脚本作为我们的调试脚本。一旦我们可以验证YML脚本工作正常，我们可以更新原始的YML脚本。这很有用，因为我们不会用故障排除提交来堵塞Git历史，而是直接使用CircleCI
    API。
- en: Running a build using a local config YML script to troubleshoot
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用本地配置YML脚本运行构建进行故障排除
- en: Let's say that we want to experiment with storing build artifacts, such as code
    coverage on a project. At the moment we are generating a coverage report but it
    is not being saved during the builds for us to view a coverage report. This is
    a good use case of creating a separate config YML script to test this new functionality.
    Let's store the coverage artifacts from the `circleci-jobs-example` ([https://github.com/packtci/circleci-jobs-example](https://github.com/packtci/circleci-jobs-example))
    project and let's also update the test job to cache the node dependencies, as
    we learned how to do in the previous section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要尝试存储构建产物，比如项目的代码覆盖率。目前我们正在生成一个覆盖率报告，但在构建过程中没有保存下来供我们查看。这是一个很好的用例，可以创建一个单独的配置YML脚本来测试这个新功能。让我们存储`circleci-jobs-example`（[https://github.com/packtci/circleci-jobs-example](https://github.com/packtci/circleci-jobs-example)）项目的覆盖率产物，并且还要更新测试任务以缓存节点依赖，就像我们在前一节中学到的那样。
- en: 'Run this command to copy the contents of the `.circleci` directory and create
    a new directory in the shell:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将复制`.circleci`目录的内容并在shell中创建一个新目录：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we will use the `store_and_cache_experiment` folder to run our local config
    YML script experiments. Here are the changes that we are going to make for the
    config YML script in the `store_and_cache_experiment` folder:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用`store_and_cache_experiment`文件夹来运行我们的本地配置YML脚本实验。这是我们将要对`store_and_cache_experiment`文件夹中的配置YML脚本进行的更改：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We added the `save_cache` and `restore_cache` declaration changes and also
    added the `store_artifacts` declaration changes. Let''s verify that the config
    YML script is still valid with the `circleci config validate` command. Now, in
    order to test these changes in our local configuration without having to make
    a Git commit, we can use the CircleCI API and provide our local config YML script
    in the body of our request and reference a recent Git commit. We can get the latest
    Git commit by running this command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`save_cache`和`restore_cache`声明更改，还添加了`store_artifacts`声明更改。让我们使用`circleci
    config validate`命令验证配置YML脚本是否仍然有效。现在，为了在本地配置中测试这些更改，而不必进行Git提交，我们可以使用CircleCI
    API，并在我们的请求正文中提供我们的本地配置YML脚本，并引用最近的Git提交。我们可以通过运行此命令获取最新的Git提交：
- en: '![](assets/7e31760b-a7e9-492f-bab4-01f49c6b1e28.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7e31760b-a7e9-492f-bab4-01f49c6b1e28.png)'
- en: 'So now we have a revision number that we can use for the API call that we are
    going to make. Here is the command that we will use to debug the changes in our
    new config YML script:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个修订号，可以用于我们将要进行的API调用。这是我们将用于调试新配置YML脚本更改的命令：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first option, `--user`, takes our API token that is saved in an environment
    variable and then the `:` after it means that there is no password that follows.
    The next option, `--request`, is the `HTTP POST` verb that we are specifying.
    The next option of `--form` revision is where we put the Git revision number that
    we got earlier and then in the next option we specify the `config.yml` script.
    We specify a form value of false for notify and then we provide the URL. Here
    we specify the version control system provider of GitHub and then our `packtci`
    username, followed by the project name, and then tree and then finally our branch
    name. Then we pipe this into the `jq` utility and parse out the `build_url`. Here
    is the API endpoint for clarity:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项`--user`接受我们保存在环境变量中的API令牌，然后后面的`:`表示后面没有密码。下一个选项`--request`是我们指定的`HTTP
    POST`动词。`--form`修订是我们放置之前得到的Git修订号的地方，然后在下一个选项中我们指定`config.yml`脚本。我们为通知指定了一个false的表单值，然后提供URL。在这里，我们指定了GitHub的版本控制系统提供者，然后是我们的`packtci`用户名，接着是项目名称，然后是树，最后是我们的分支名称。然后我们将其传输到`jq`实用程序中，并解析出`build_url`。这是API端点的清晰表示：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After we make the REST call, we should get a JSON response that gives us a
    build URL for us to look at, and here is the build URL that we get: [https://circleci.com/gh/packtci/circleci-jobs-example/8](https://circleci.com/gh/packtci/circleci-jobs-example/8).
    If we look at this new build in the CircleCI Web UI, we see that it passed:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们发出REST调用之后，我们应该收到一个JSON响应，其中包含一个构建URL供我们查看，这是我们得到的构建URL：[https://circleci.com/gh/packtci/circleci-jobs-example/8](https://circleci.com/gh/packtci/circleci-jobs-example/8)。如果我们在CircleCI
    Web UI中查看这个新构建，我们会看到它已经通过了：
- en: '![](assets/da630c80-75f7-43a7-a17d-0af9bc4059b2.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/da630c80-75f7-43a7-a17d-0af9bc4059b2.png)'
- en: 'Let''s remove the troubleshooting directory and config YML script and shell
    script and copy over the config YML script into the `.circleci` directory, like
    this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除故障排除目录和配置YML脚本和shell脚本，并将配置YML脚本复制到`.circleci`目录中，就像这样：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now if we click on the current build and then go to the workflows link, we
    will see that the step Uploading artifacts was added to the job; this is what
    it looks like:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们点击当前构建，然后转到工作流链接，我们会看到上传产物步骤已添加到任务中；看起来是这样的：
- en: '![](assets/de859dc7-d5c8-4fe4-af22-1edec5341768.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/de859dc7-d5c8-4fe4-af22-1edec5341768.png)'
- en: 'We can now scroll up and click on the Artifacts tab and see that an artifact
    has been saved on the build, like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以向上滚动并点击Artifacts选项卡，看到构建中已保存了一个产物，就像这样：
- en: '![](assets/bf5c7d35-b257-405b-850b-bcc6cef5b3c3.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bf5c7d35-b257-405b-850b-bcc6cef5b3c3.png)'
- en: 'If we click on `index.html`, we will be redirected to a nice coverage report
    that looks like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击`index.html`，我们将被重定向到一个漂亮的覆盖率报告，看起来像这样：
- en: '![](assets/5c4b6870-944c-44cc-8f5e-3baa2ee7e5b3.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5c4b6870-944c-44cc-8f5e-3baa2ee7e5b3.png)'
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the job log in depth and showed you how to use the
    CircleCI API to add projects. We showed you how to analyze the job log and explained
    in more detail what a workflow is in CircleCI. We looked at how to use the CircleCI
    API to find the most recent build. We then looked at how to debug slow builds
    in Circle CI and wrapped up by showing you how to use a local config YML script
    to experiment with new changes to the CircleCI YML script.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入介绍了作业日志，并向您展示了如何使用CircleCI API添加项目。我们向您展示了如何分析作业日志，并更详细地解释了CircleCI中的工作流程。我们看了如何使用CircleCI
    API找到最近的构建。然后，我们看了如何在Circle CI中调试慢构建，并最后向您展示了如何使用本地配置YML脚本来尝试对CircleCI YML脚本进行新更改的实验。
- en: In the next chapter, we will look at some best practices with continuous integration/continuous
    delivery and look at some patterns of configuration management, in particular
    secrets management, and present some checklists when implementing CI/CD in software
    companies.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些持续集成/持续交付的最佳实践，并研究一些配置管理模式，特别是秘密管理，并在软件公司实施CI/CD时提供一些检查表。
- en: Questions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What was the API endpoint that we used to follow new projects in CircleCI?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在CircleCI中用于关注新项目的API端点是什么？
- en: Can the cat utility be used to create new files?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: cat实用程序可以用来创建新文件吗？
- en: How would you run a multi-line command in the CircleCI config YML script?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在CircleCI配置YML脚本中运行多行命令？
- en: Are there any security vulnerabilities when using the `set -x` or execution
    tracing in scripts in CircleCI?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CircleCI中使用`set -x`或脚本中的执行跟踪时是否存在安全漏洞？
- en: What was the CLI command we used to validate our config YML script?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用什么CLI命令来验证我们的配置YML脚本？
- en: Can environment variables be imported from other projects in CircleCI?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 环境变量可以从CircleCI中的其他项目导入吗？
- en: What declarations did we use to cache our dependencies in CircleCI?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在CircleCI中使用了哪些声明来缓存我们的依赖关系？
- en: Further reading
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To find out more about debugging and troubleshooting, and other useful information,
    please read the official CircleCI documentation: [https://circleci.com/docs/2.0/](https://circleci.com/docs/2.0/).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于调试和故障排除以及其他有用信息，请阅读官方的CircleCI文档：[https://circleci.com/docs/2.0/](https://circleci.com/docs/2.0/)。
