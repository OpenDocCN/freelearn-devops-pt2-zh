- en: '*Chapter 4*: Ansible and Windows – Not Just for Linux'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：Ansible和Windows-不仅仅适用于Linux'
- en: A great deal of the work on Ansible has been performed on Linux OSes; indeed,
    the first two editions of this book were based entirely around the use of Ansible
    in a Linux-centric environment. However, most environments are not like that,
    and, at the very least, are liable to have at least some Microsoft Windows server
    and desktop machines. Since the third edition of this book was published, much
    work has gone into Ansible to create a really robust cross-platform automation
    tool that is equally at home in both a Linux data center and a Windows one. There
    are fundamental differences in the way Windows and Linux hosts operate, of course,
    and so it should come as no surprise that there are some fundamental differences
    between how Ansible automates tasks on Linux, and how it automates tasks on Windows.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的工作都是在Linux操作系统上进行的；事实上，本书的前两版完全围绕在Linux中使用Ansible展开。然而，大多数环境并不是这样的，至少会有一些微软Windows服务器和桌面机器。自本书的第三版出版以来，Ansible已经进行了大量工作，创建了一个真正强大的跨平台自动化工具，它在Linux数据中心和Windows数据中心同样得心应手。当然，Windows和Linux主机的操作方式存在根本差异，因此并不奇怪，Ansible在Linux上自动化任务的方式与在Windows上自动化任务的方式之间存在一些根本差异。
- en: 'We will cover those fundamentals in this chapter, so as to give you a rock-solid
    foundation to begin automating your Windows tasks with Ansible, specifically covering
    the following areas:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中介绍这些基础知识，以便为您提供一个坚实的基础，开始使用Ansible自动化您的Windows任务，具体涵盖以下领域：
- en: Running Ansible from Windows
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上运行Ansible
- en: Setting up Windows hosts for Ansible control
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Ansible控制设置Windows主机
- en: Handling Windows authentication and encryption
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理Windows身份验证和加密
- en: Automating Windows tasks with Ansible
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible自动化Windows任务
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples presented in this chapter, you will need a Linux machine
    running Ansible 4.3 or newer. Almost any flavor of Linux should do; for those
    interested in specifics, all the code presented in this chapter was tested on
    Ubuntu Server 20.04 LTS unless stated otherwise, and on Ansible 4.3.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照本章介绍的示例，您需要一台运行Ansible 4.3或更新版本的Linux机器。几乎任何Linux的版本都可以；对于那些对细节感兴趣的人，本章中提供的所有代码都是在Ubuntu
    Server 20.04 LTS上测试的，除非另有说明，并且在Ansible 4.3上也进行了测试。
- en: Where Windows is used in this chapter, the example code was tested and run on
    Windows Server 2019, version 1809, build 17763.1817\. Screenshots of the Windows
    Store were taken from Windows 10 Pro, version 20H2, build 19042.906.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中使用Windows时，示例代码是在Windows Server 2019的1809版本、构建17763.1817上进行测试和运行的。Windows
    Store的屏幕截图是从Windows 10 Pro的20H2版本、构建19042.906中获取的。
- en: 'The example code that accompanies this chapter can be downloaded from GitHub
    at this URL: [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter04).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章附带的示例代码可以从GitHub的以下网址下载：[https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter04)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3B2zmvL](https://bit.ly/3B2zmvL).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[https://bit.ly/3B2zmvL](https://bit.ly/3B2zmvL)。
- en: Running Ansible from Windows
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上运行Ansible
- en: If you browse the official installation documentation for Ansible, you will
    find a variety of instructions for most mainstream Linux variants, Solaris, macOS,
    and FreeBSD. You will note, however, that there is no mention of Windows. There
    is a good reason for this – for those interested in the technical detail, Ansible
    makes extensive use of the POSIX `fork()` syscall in its operations, and no such
    call exists on Windows. POSIX compatibility projects, such as the venerable Cygwin,
    have attempted to implement `fork()` on Windows, but sometimes this does not work
    correctly even today. As a result, despite there being a viable Python implementation
    for Windows, Ansible cannot be run natively on this platform without the presence
    of this important syscall.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您浏览Ansible的官方安装文档，您会发现针对大多数主流Linux变体、Solaris、macOS和FreeBSD的各种说明。然而，您会注意到，没有提到Windows。这是有充分理由的
    - 对于那些对技术细节感兴趣的人来说，Ansible在其操作中广泛使用POSIX `fork()`系统调用，而Windows上并不存在这样的调用。POSIX兼容项目，如备受尊敬的Cygwin，曾试图在Windows上实现`fork()`，但即使在今天，有时这并不起作用。因此，尽管在Windows上有一个可行的Python实现，但没有这个重要的系统调用，Ansible无法在此平台上本地运行。
- en: The good news is that, if you are running recent versions of Windows 10, or
    Windows Server 2016 or 2019, installing and running Ansible is now incredibly
    easy thanks to **Windows Subsystem for Linux** (**WSL**). There are now two versions
    of this technology, the original WSL release (which was featured in the third
    edition of this book), and the newer **WSL2**. **WSL2** is, at the time of writing,
    only available on Windows 10, version 1903 (or higher) with build 18362 (or higher).
    Both of these technologies allow Windows users to run unmodified Linux distributions
    on top of Windows without the complications or overheads of a virtual machine
    (though peer under the hood and you'll see that **WSL2** runs on top of Hyper-V,
    albeit in a seamless manner). As such, these technologies lend themselves perfectly
    to running Ansible, as it can be installed and run with ease and with a reliable
    implementation of the `fork()` syscall.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，如果您正在运行最新版本的Windows 10，或Windows Server 2016或2019，由于**Windows子系统**（**WSL**），安装和运行Ansible现在变得非常容易。现在有两个版本的这项技术，原始的WSL发布版（在本书的第三版中有介绍），以及更新的**WSL2**。**WSL2**目前只在Windows
    10的1903版本（或更高版本）上，构建18362（或更高版本）上可用。这两项技术允许Windows用户在Windows之上运行未经修改的Linux发行版，而无需虚拟机的复杂性或开销（尽管在幕后，您会发现**WSL2**是在Hyper-V之上运行的，尽管以一种无缝的方式）。因此，这些技术非常适合运行Ansible，因为它可以轻松安装和运行，并且具有可靠的`fork()`系统调用的实现。
- en: Let's pause to take a look at two important points before we move on. First
    of all, WSL or WSL2 are only required to run Ansible from Windows to control other
    machines (running any OS) – they are not required to control a Windows machine
    with Ansible. We'll see more about this later in the chapter. Secondly, don't
    let the lack of an official build of WSL2 for Windows Server impede you – if you
    have Windows bastion hosts, and wish to run Ansible from them, it is as home on
    **WSL** as it is on **WSL2**. At the time of writing, there is talk of **WSL2**
    being available for the latest Insider Previews of Windows Server; however, as
    I anticipate most readers will be looking for a stable, production-ready solution,
    we will focus more on **WSL** than **WSL2** in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们暂停一下看两个重要的点。首先，只有在Windows上运行Ansible来控制其他机器（运行任何操作系统）时，才需要WSL或WSL2-不需要使用它们来控制Windows机器。我们将在本章后面更多地了解这一点。其次，不要让WSL2没有Windows
    Server的官方版本阻碍您-如果您有Windows堡垒主机，并希望从中运行Ansible，它在**WSL**上和**WSL2**上都可以。在撰写本文时，有关**WSL2**在Windows
    Server的最新预览版中可用的消息；但是，我预计大多数读者将寻找稳定的、可用于生产的解决方案，因此我们将在本章更多地关注**WSL**而不是**WSL2**。
- en: The official Ansible installation documentation can be found at [https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的Ansible安装文档可以在[https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html)找到。
- en: Checking your build
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查您的构建
- en: 'WSL is only available on specific builds of Windows, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: WSL仅在特定版本的Windows上可用，如下所示：
- en: 'Windows 10—version 1607 (build 14393) or later:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 10-版本1607（构建14393）或更高版本：
- en: Note that you will require build 16215 or later if you want to install Linux
    through the Microsoft Store.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，如果要通过Microsoft Store安装Linux，则需要构建16215或更高版本。
- en: If you do want to use WSL2, you will need version 1903 or later (build 18362
    or later) of Windows 10.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想要使用WSL2，则需要Windows 10的1903版本或更高版本（18362版本或更高版本）。
- en: Only 64-bit Intel and ARM versions of Windows 10 are supported.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅支持64位英特尔和ARM版本的Windows 10。
- en: Windows Server 2016 version 1803 (build 16215) or later
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows Server 2016版本1803（构建16215）或更高版本
- en: Windows Server 2019 version 1709 (build 16237) or later
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows Server 2019版本1709（构建16237）或更高版本
- en: 'You can easily check your build and version number in PowerShell by running
    the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在PowerShell中运行以下命令轻松检查您的构建和版本号：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you are running an earlier version of Windows, running Ansible is still possible,
    either through a virtual machine or via Cygwin. However, these methods are beyond
    the scope of this book.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是较早版本的Windows，仍然可以通过虚拟机或通过Cygwin运行Ansible。但是，这些方法超出了本书的范围。
- en: Enabling WSL
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用WSL
- en: 'Once you have verified your build, enabling WSL is easy. Simply open PowerShell
    as an administrator and run the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 验证了您的构建后，启用WSL很容易。只需以管理员身份打开PowerShell并运行以下命令：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once the installation completes successfully, you will be able to select and
    install your preferred Linux distribution. A number are available, but for running
    Ansible, it makes sense to choose one of those listed in the official Ansible
    installation instructions, such as Debian or Ubuntu.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您将能够选择并安装您喜欢的Linux发行版。有很多选择，但是为了运行Ansible，选择官方Ansible安装说明中列出的发行版之一是有意义的，比如Debian或Ubuntu。
- en: Installing Linux under WSL
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在WSL下安装Linux
- en: 'If you have a recent enough build of Windows 10, then installing your preferred
    Linux is as easy as opening the Microsoft Store and searching for it. For example,
    search for `Ubuntu` and you should find it easily. *Figure 4.1* shows the latest
    LTS build of Ubuntu available for download in the Microsoft Store on Windows 10:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Windows 10版本足够新，那么安装您喜欢的Linux就像打开Microsoft Store并搜索它一样简单。例如，搜索`Ubuntu`，您应该很容易找到。*图4.1*显示了在Windows
    10的Microsoft Store中可供下载的Ubuntu的最新LTS版本：
- en: '![Figure 4.1 – One of the Linux distributions available for WSL and WSL2 in
    the Microsoft Store app on Windows 10'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1-在Windows 10的Microsoft Store应用程序中可用的WSL和WSL2的Linux发行版之一'
- en: '](Images/B17462_04_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_04_01.jpg)'
- en: Figure 4.1 – One of the Linux distributions available for WSL and WSL2 in the
    Microsoft Store app on Windows 10
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1-在Windows 10的Microsoft Store应用程序中可用的WSL和WSL2的Linux发行版之一
- en: To install Ubuntu under WSL, simply click on the **Get** button and wait for
    the installation to complete.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要在WSL下安装Ubuntu，只需单击**获取**按钮，等待安装完成。
- en: 'If you are running Windows 10, but a supported build earlier than 16215, or
    indeed any supported build of Windows Server 2016/2019, then the installation
    of Linux is a slightly more manual process. First of all, download your preferred
    Linux distribution from Microsoft—for example, Ubuntu 20.04 can be downloaded
    using the following PowerShell command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Windows 10，但是支持的构建早于16215，或者确实是Windows Server 2016/2019的任何支持的构建，那么安装Linux就是一个稍微手动的过程。首先，从Microsoft下载您喜欢的Linux发行版，例如，可以使用以下PowerShell命令下载Ubuntu
    20.04：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once successfully downloaded, unzip the `Ubuntu.appx` file—this can be unzipped
    to any location provided that it is on the system (boot) drive, normally `C:`.
    If you want to keep your Linux distribution private, it can be unzipped somewhere
    within your profile directory, otherwise, you can unzip the file anywhere on the
    system drive. For example, the following PowerShell commands would unzip the archive
    into `C:\WSL\`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下载成功后，解压`Ubuntu.appx`文件-只要它在系统（引导）驱动器上，通常是`C:`上的任何位置即可。如果要保持Linux发行版的私密性，可以将其解压缩到个人资料目录中的某个位置，否则可以将文件解压缩到系统驱动器的任何位置。例如，以下PowerShell命令将解压缩存档到`C:\WSL\`：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once completed, you can launch your newly installed Linux distribution using
    the executable named after the distribution itself. In the case of our Ubuntu
    example, you would run the following through Explorer (or your preferred method):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您可以使用以所选发行版命名的可执行文件启动新安装的Linux发行版。以我们的Ubuntu示例为例，您可以通过资源管理器（或您喜欢的方法）运行以下命令：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first time you run your newly installed Linux distribution, whether it
    was installed through the Microsoft Store or installed manually, it will initialize
    itself. As part of this process, it will ask you to create a new user account.
    Please note that this account is independent of your Windows username and password,
    so be sure to remember the password you set here! You will need it every time
    you run commands through `sudo` (for example), although, as with any Linux distribution,
    you can customize this behavior through `/etc/sudoers` if you wish. This is demonstrated
    in *Figure 4.2*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行新安装的Linux发行版时，无论是通过Microsoft Store安装还是手动安装，它都会初始化自己。在此过程的一部分中，它将要求您创建一个新用户帐户。请注意，此帐户与您的Windows用户名和密码是独立的，因此请务必记住您在此设置的密码！每次通过`sudo`运行命令时都会需要它，尽管与任何Linux发行版一样，如果您愿意，可以通过`/etc/sudoers`自定义此行为。这在*图4.2*中有所示：
- en: '![Figure 4.2 – The WSL Ubuntu terminal output during its first run'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2-WSL Ubuntu终端在首次运行时的输出'
- en: '](Images/B17462_04_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_04_02.jpg)'
- en: Figure 4.2 – The WSL Ubuntu terminal output during its first run
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2-WSL Ubuntu终端在首次运行时的输出
- en: Congratulations! You now have Linux running under WSL. From here, you should
    follow the standard installation process for Ansible, and you can run it from
    your Linux subsystem just as you would on any other Linux box.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在您在WSL下运行Linux。从这里开始，您应该按照Ansible的标准安装过程进行操作，并且可以像在任何其他Linux系统上一样在Linux子系统上运行它。
- en: Setting up Windows hosts for Ansible control using WinRM
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WinRM为Ansible控制设置Windows主机
- en: So far, we have talked about running Ansible itself from Windows. This is helpful,
    especially in a corporate environment where perhaps Windows end user systems are
    the norm. However, what about actual automation tasks? The good news is that,
    as already stated, automation of Windows with Ansible does not require WSL. One
    of Ansible's core premises is to be agentless, and that remains just as true for
    Windows as for Linux. It is fair to assume that almost any modern Linux host will
    have SSH access enabled, and similarly, most modern Windows hosts have a remote
    management protocol built in, called WinRM. Ardent followers of Windows will know
    that Microsoft has, in a more recent edition, added both the OpenSSH client and
    server packages, and since the last edition of this book was published, experimental
    support for these has been added to Ansible. For security reasons, both of these
    technologies are disabled by default, and so, in this part of the book, we walk
    through the processes for enabling and securing WinRM for remote management with
    Ansible. We will also take a brief look at setting up and using OpenSSH Server
    on Windows – however, as support for this by Ansible is currently experimental
    and carries a number of warnings about stability and backward-incompatible changes
    in future releases, most users will wish to use WinRM, especially in stable production
    environments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了从Windows本身运行Ansible。这对于企业环境尤其有帮助，尤其是在那些Windows终端用户系统是主流的情况下。但是，实际的自动化任务呢？好消息是，正如已经提到的，使用Ansible自动化Windows不需要WSL。Ansible的一个核心前提是无需代理，这对于Windows和Linux同样适用。可以合理地假设几乎任何现代Linux主机都将启用SSH访问，同样，大多数现代Windows主机都内置了一个远程管理协议，称为WinRM。Windows的狂热追随者将知道，微软在最近的版本中添加了OpenSSH客户端和服务器包，并且自本书上一版出版以来，已经为Ansible添加了对这些的实验性支持。出于安全原因，这两种技术默认情况下都是禁用的，因此，在本书的这一部分中，我们将介绍启用和保护WinRM以进行远程管理的过程。我们还将简要介绍在Windows上设置和使用OpenSSH服务器-然而，由于Ansible对此的支持目前是实验性的，并且在未来的版本中可能会有稳定性和向后不兼容的变化，大多数用户将希望使用WinRM，尤其是在稳定的生产环境中。
- en: With this in mind, let's get started on looking at automating tasks on Windows
    hosts using WinRM in the next part of this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，让我们开始看一下如何在本章的下一部分中使用WinRM自动化Windows主机上的任务。
- en: System requirements for automation with Ansible using WinRM
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用WinRM进行Ansible自动化的系统要求
- en: 'The use of WinRM by Ansible means a wide array of support for Windows versions
    new and old—under the hood, just about any Windows version that supports the following
    will work:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible使用WinRM意味着对新旧Windows版本有广泛的支持-在幕后，几乎任何支持以下内容的Windows版本都可以使用：
- en: PowerShell 3.0
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 3.0
- en: .NET 4.0
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 4.0
- en: 'In practice, this means that the following Windows versions can be supported,
    provided the preceding requirements are met:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这意味着只要满足前面的要求，就可以支持以下Windows版本：
- en: '**Desktop**: Windows 7 SP1, 8.1, and 10'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桌面**：Windows 7 SP1，8.1和10'
- en: '**Server**: Windows Server 2008 SP2, 2008 R2 SP1, 2012, 2012 R2, 2016, and
    2019'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器**：Windows Server 2008 SP2，2008 R2 SP1，2012，2012 R2，2016和2019'
- en: Note that the older OSes listed previously (such as Windows 7 or Server 2008) did
    not ship with .NET 4.0 or PowerShell 3.0, and these will need to be installed
    before they can be used with Ansible. As you would expect, newer versions of PowerShell
    are supported, and, equally, there may be security patches for .NET 4.0\. As long
    as you can meet these minimum requirements, you should be fine to start automating
    Windows tasks with Ansible, even in business settings where older OSes are still
    dominant.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以前列出的旧操作系统（如Windows 7或Server 2008）未附带.NET 4.0或PowerShell 3.0，并且在使用Ansible之前需要安装它们。正如您所期望的那样，支持更新版本的PowerShell，并且对.NET
    4.0可能有安全补丁。只要满足这些最低要求，您就可以开始使用Ansible自动化Windows任务，即使在旧操作系统仍然占主导地位的商业环境中也是如此。
- en: If you are using an older (but supported) version of PowerShell such as 3.0,
    be aware that a bug exists in WinRM under PowerShell 3.0 that limits the memory
    available to the service, which, in turn, can cause some Ansible commands to fail.
    This is resolved by ensuring KB2842230 is applied to all hosts running PowerShell
    3.0, so do be sure to check your hotfixes and patches if you are automating tasks
    in Windows via PowerShell 3.0.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是较旧（但受支持的）PowerShell版本，例如3.0，请注意在PowerShell 3.0下存在一个WinRM错误，该错误限制了服务可用的内存，从而可能导致某些Ansible命令失败。这可以通过确保在运行PowerShell
    3.0的所有主机上应用KB2842230来解决，因此，如果您正在通过PowerShell 3.0自动化Windows任务，请务必检查您的热修复和补丁。
- en: Enabling the WinRM listener
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用WinRM监听器
- en: Once all the system requirements have been met, as detailed previously, the
    task that remains is to enable and secure the WinRM listener. With this achieved,
    we can actually run Ansible tasks against the Windows host itself! WinRM can run
    over both HTTP, and HTTPS protocols, and, while it is quickest and easiest to
    get up and running over plain HTTP, this leaves you vulnerable to packet sniffers
    and the potential for sensitive data to be revealed on the network. This is especially
    true if basic authentication is being used. By default, and perhaps unsurprisingly,
    Windows does not allow remote management with WinRM over HTTP or using basic authentication.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦满足了先前详细介绍的所有系统要求，剩下的任务就是启用和保护WinRM监听器。完成这一步后，我们实际上可以对Windows主机本身运行Ansible任务！WinRM可以在HTTP和HTTPS协议上运行，虽然通过纯HTTP快速且容易上手，但这会使您容易受到数据包嗅探器的攻击，并有可能在网络上泄露敏感数据。如果使用基本身份验证，情况尤其如此。默认情况下，也许并不奇怪，Windows不允许使用HTTP或基本身份验证通过WinRM进行远程管理。
- en: Sometimes, basic authentication is sufficient (for example, in a development
    environment), and if it is to be used, then we will definitely want to enable
    HTTPS as the transport for WinRM! However, later in the chapter, we will look
    at Kerberos authentication, which is preferable, and also enables the use of domain
    accounts. For now though, to demonstrate the process of connecting Ansible to
    a Windows host with a modicum of security, we will enable WinRM over HTTPS using
    a self-signed certificate, and enable basic authentication to allow us to work
    with the local `Administrator` account.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，基本身份验证就足够了（例如在开发环境中），如果要使用它，那么我们肯定希望启用HTTPS作为WinRM的传输！但是，在本章后面，我们将介绍Kerberos身份验证，这是更可取的，并且还可以使用域帐户。不过，为了演示将Ansible连接到具有一定安全性的Windows主机的过程，我们将使用自签名证书启用WinRM的HTTPS，并启用基本身份验证，以便我们可以使用本地的`Administrator`帐户进行工作。
- en: 'For WinRM to function over HTTPS, a certificate must exist that has the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要使WinRM在HTTPS上运行，必须存在具有以下内容的证书：
- en: A `CN` value matching the hostname
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与主机名匹配的“CN”值
- en: '`Server Authentication (1.3.6.1.5.5.7.3.1)` in the **Enhanced Key Usage** field'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**增强密钥用途**字段中的`服务器身份验证（1.3.6.1.5.5.7.3.1）`
- en: 'Ideally, this should be generated by a central **certificate authority** (**CA**)
    to prevent man-in-the-middle attacks and similar—more on this later. However,
    to provide all readers with an example they will be able to test out, we will
    generate a self-signed certificate. Run the following command in PowerShell to
    generate a suitable certificate:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，这应该由中央**证书颁发机构**（**CA**）生成，以防止中间人攻击等 - 更多内容稍后再讨论。但是，为了让所有读者都能够测试，我们将生成一个自签名证书作为示例。在PowerShell中运行以下命令以生成合适的证书：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `New-SelfSignedCertificate` command is only available on newer versions
    of Windows—if it is not available on your system, consider using the automated
    PowerShell script provided by Ansible available at [https://raw.githubusercontent.com/ansible/ansible/devel/examples/scripts/ConfigureRemotingForAnsible.ps1](https://raw.githubusercontent.com/ansible/ansible/devel/examples/scripts/ConfigureRemotingForAnsible.ps1).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`New-SelfSignedCertificate`命令仅在较新版本的Windows上可用 - 如果您的系统上没有该命令，请考虑使用Ansible提供的自动化PowerShell脚本，网址为[https://raw.githubusercontent.com/ansible/ansible/devel/examples/scripts/ConfigureRemotingForAnsible.ps1](https://raw.githubusercontent.com/ansible/ansible/devel/examples/scripts/ConfigureRemotingForAnsible.ps1)。'
- en: 'This should yield something like that shown in *Figure 4.3* —make a note of
    the certificate thumbprint, as you will need it later:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生类似于*图4.3*中显示的内容 - 请记下证书的指纹，稍后会用到：
- en: '![Figure 4.3 – Creating a self-signed certificate for the WinRM HTTPS listener
    using PowerShell'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 - 使用PowerShell为WinRM HTTPS监听器创建自签名证书'
- en: '](Images/B17462_04_03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_04_03.jpg)'
- en: Figure 4.3 – Creating a self-signed certificate for the WinRM HTTPS listener
    using PowerShell
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 - 使用PowerShell为WinRM HTTPS监听器创建自签名证书
- en: 'With the certificate in place, we can now set up a new WinRM listener with
    the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有了证书，我们现在可以使用以下命令设置新的WinRM监听器：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When successful, that command sets up a WinRM HTTPS listener on port `5986`
    with the self-signed certificate we generated earlier. To enable Ansible to automate
    this Windows host through WinRM, we need to perform two more steps—open up this
    port on the firewall and enable basic authentication so that we can test using
    the local `Administrator` account. This is achieved with the following two commands:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 成功后，该命令将在端口`5986`上设置一个带有我们之前生成的自签名证书的WinRM HTTPS监听器。为了使Ansible能够通过WinRM自动化此Windows主机，我们需要执行另外两个步骤
    - 在防火墙上打开此端口，并启用基本身份验证，以便我们可以使用本地的`Administrator`帐户进行测试。使用以下两个命令可以实现这一点：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see output from the previous commands similar to that shown in *Figure
    4.4*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到与*图4.4*中显示的类似的先前命令的输出：
- en: '![Figure 4.4 – Creating and enabling access to the WinRM HTTPS listener in
    PowerShell'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 - 在PowerShell中创建和启用对WinRM HTTPS监听器的访问'
- en: '](Images/B17462_04_04.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_04_04.jpg)'
- en: Figure 4.4 – Creating and enabling access to the WinRM HTTPS listener in PowerShell
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 - 在PowerShell中创建和启用对WinRM HTTPS监听器的访问
- en: 'These commands have been broken out individually to give you an idea of the
    process involved in setting up a Windows host for Ansible connectivity. For automated
    deployments and systems where `New-SelfSignedCertificate` isn''t available, consider
    using the `ConfigureRemotingForAnsible.ps1` script available on the official Ansible
    GitHub account, which we referenced earlier in this section. This script performs
    all the steps we completed previously (and more), and can be downloaded and run
    in PowerShell as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令已被单独拆分，以便让您了解为Ansible连接设置Windows主机所涉及的过程。对于自动化部署和系统，如果`New-SelfSignedCertificate`不可用，可以考虑使用官方Ansible
    GitHub帐户上提供的`ConfigureRemotingForAnsible.ps1`脚本，我们在本节前面已经提到过。该脚本执行了我们之前完成的所有步骤（以及更多），可以按照以下方式下载并在PowerShell中运行：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are many other ways to roll out the required configuration of WinRM for
    Ansible, including via Group Policy, which will almost certainly be preferable
    in corporate environments. The information provided in this section of the chapter
    should by now have provided you with all the fundamentals you need to set up WinRM
    in your environment, ready to enable Ansible management of your Windows hosts.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他方法可以为Ansible配置WinRM所需的配置，包括通过组策略，这在企业环境中几乎肯定更可取。本章节提供的信息现在应该已经为您提供了在您的环境中设置WinRM所需的所有基础知识，准备好启用Ansible管理您的Windows主机。
- en: Connecting Ansible to Windows using WinRM
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用WinRM连接Ansible到Windows
- en: Once WinRM is configured, getting Ansible talking to Windows is fairly straightforward,
    provided you bear two caveats in mind—it expects to use the SSH protocol, and
    if you don't specify a user account, it will attempt to use the same user account
    that Ansible is being run under to connect. This is almost certainly not going
    to work with a Windows username.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了WinRM，让Ansible与Windows通信就相当简单，只要记住两个注意事项——它期望使用SSH协议，如果您没有指定用户账户，它将尝试使用与Ansible运行的用户账户相同的用户账户进行连接。这几乎肯定不会与Windows用户名一起使用。
- en: 'Also, note that Ansible requires the `winrm` Python module installed to connect
    successfully. This is not always installed by default, so it is worth testing
    for it on your Ansible system before you start working with Windows hosts. If
    it is not present, you will see something like the error shown in *Figure 4.5*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，Ansible需要安装`winrm` Python模块才能成功连接。这并不总是默认安装的，因此在开始使用Windows主机之前，值得在Ansible系统上测试一下。如果不存在，您将看到类似于*图4.5*中显示的错误：
- en: '![Figure 4.5 – A simple test for the presence of the winrm Python module on
    Ubuntu Server 20.04'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 - 在Ubuntu Server 20.04上测试winrm Python模块的存在'
- en: '](Images/B17462_04_05.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_04_05.jpg)'
- en: Figure 4.5 – A simple test for the presence of the winrm Python module on Ubuntu
    Server 20.04
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 - 在Ubuntu Server 20.04上测试winrm Python模块的存在
- en: 'If you see this error, you will need to install the module before proceeding
    any further. There may be a prepackaged version available for your OS—for example,
    on Ubuntu Server 20.04, you can install it with the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到此错误，您需要在继续之前安装该模块。您的操作系统可能有预打包版本可用，例如，在Ubuntu Server 20.04上，您可以使用以下命令安装它：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If a packaged version is not available, install it directly from `pip` using
    the following command. Note that in [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047),
    *Migrating from an Earlier Ansible Versions*, we discussed the use of Python virtual
    environments for installing Ansible – if you have done this, you must be sure
    to activate your virtualenv, and then run the following command without `sudo`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有预打包版本可用，可以使用以下命令直接从`pip`安装。请注意，在[*第2章*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047)中，我们讨论了使用Python虚拟环境安装Ansible
    - 如果您已经这样做，您必须确保激活您的虚拟环境，然后在不使用`sudo`的情况下运行以下命令：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once this is complete, we can test to see whether our earlier WinRM configuration
    work was successful. For SSH-based connectivity, there is an Ansible module called
    `ansible.builtin.ping`, which performs a full end-to-end test to ensure connectivity,
    successful authentication, and a usable Python environment on the remote system.
    Similarly, there exists a module called `win_ping` (from the `ansible.windows`
    collection), which performs an analogous test on Windows.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以测试之前的WinRM配置是否成功。对于基于SSH的连接，有一个名为`ansible.builtin.ping`的Ansible模块，它执行完整的端到端测试，以确保连接、成功的身份验证和远程系统上可用的Python环境。类似地，还有一个名为`win_ping`的模块（来自`ansible.windows`集合），它在Windows上执行类似的测试。
- en: 'In my test environment, I would prepare an inventory as follows to connect
    to my newly configured Windows host:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的测试环境中，我将准备一个清单，以连接到我新配置的Windows主机：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note the connection-specific variables beginning `ansible_` that are being set
    in the `windows:vars` section of the playbook. At this stage, they should be fairly
    self-explanatory, as they were covered in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015),
    *The* *System Architecture and Design of Ansible*, but, in particular, note the
    `ansible_winrm_server_cert_validation` variable, which needs to be set to `ignore`
    when working with self-signed certificates. Obviously, in a real-world example,
    you would not leave the `ansible_password` parameter in clear text—it would either
    be placed in an Ansible vault or prompted for upon launch by using the `--ask-pass`
    parameter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在playbook的`windows:vars`部分设置的`ansible_`开头的连接特定变量。在这个阶段，它们应该是相当容易理解的，因为它们在[*第1章*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015)中已经涵盖了Ansible的*系统架构和设计*，但特别要注意`ansible_winrm_server_cert_validation`变量，当使用自签名证书时需要设置为`ignore`。显然，在实际示例中，您不会将`ansible_password`参数以明文形式留下，它要么放在Ansible
    vault中，要么在启动时使用`--ask-pass`参数提示输入。
- en: Certificate-based authentication is also possible with WinRM, which carries
    with it more or less the same benefits and risks as SSH key-based authentication.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 基于证书的身份验证也可以在WinRM上实现，它带来的好处和风险与基于SSH密钥的身份验证几乎相同。
- en: 'Using the previous inventory (with appropriate changes for your environment
    such as hostname/IP addresses and authentication details), we can run the following
    command to test connectivity:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用先前的清单（根据您的环境进行适当更改，如主机名/IP地址和身份验证详细信息），我们可以运行以下命令来测试连接：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If all goes well, you should see some output like that shown in *Figure 4.6*:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该会看到类似于*图4.6*中显示的输出：
- en: '![Figure 4.6 – Testing Windows host connectivity over WinRM using Ansible''s
    ansible.windows.win_ping module'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6 - 使用Ansible的ansible.windows.win_ping模块测试WinRM上的Windows主机连接'
- en: '](Images/B17462_04_06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_04_06.jpg)'
- en: Figure 4.6 – Testing Windows host connectivity over WinRM using Ansible's ansible.windows.win_ping
    module
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 - 使用Ansible的ansible.windows.win_ping模块测试WinRM上的Windows主机连接
- en: That completes a successful end-to-end setup of an Ansible host to a Windows
    one! From such a setup, you can author and run playbooks just as you would on
    any other system, except that you must work with Ansible modules that specifically
    support Windows. Next, we will work on improving the security of our connection
    between Ansible and Windows, before finally moving on to some examples of Windows
    playbooks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了将Ansible主机成功设置到Windows主机的端到端设置！通过这样的设置，您可以像在任何其他系统上一样编写和运行playbooks，只是您必须使用专门支持Windows的Ansible模块。接下来，我们将致力于改进Ansible与Windows之间连接的安全性，最后转向一些Windows
    playbook的示例。
- en: Handling Windows authentication and encryption when using WinRM
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理使用WinRM时的Windows认证和加密
- en: Now that we have established the basic level of connectivity required for Ansible
    to perform tasks on a Windows host using WinRM, let's dig deeper into the authentication
    and encryption side of things. In the earlier part of the chapter, we used the
    basic authentication mechanism with a local account. While this is fine in a testing
    scenario, what happens in a domain environment? Basic authentication only supports
    local accounts, so clearly we need something else here. We also chose not to validate
    the SSL certificate (as it was self-signed), which again, is fine for testing
    purposes, but is not best practice in a production environment. In this section,
    we will explore options for improving the security of our Ansible communications
    with Windows.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了Ansible在Windows主机上使用WinRM执行任务所需的基本连接级别，让我们更深入地了解认证和加密方面的内容。在本章的前部分，我们使用了基本的认证机制与本地账户。虽然这在测试场景中是可以的，但在域环境中会发生什么呢？基本认证只支持本地账户，所以显然我们在这里需要其他东西。我们还选择不验证SSL证书（因为它是自签名的），这在测试目的上是可以的，但在生产环境中并不是最佳实践。在本节中，我们将探讨改进Ansible与Windows通信安全性的选项。
- en: Authentication mechanisms
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证机制
- en: 'Ansible, in fact, supports five different Windows authentication mechanisms
    when WinRM is used, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当使用WinRM时，Ansible支持五种不同的Windows认证机制，如下所示：
- en: '**Basic**: Supports local accounts only'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本：仅支持本地账户
- en: '**Certificate**: Supports local accounts only, conceptually similar to SSH
    key-based authentication'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书：仅支持本地账户，概念上类似于基于SSH密钥的认证
- en: '**Kerberos**: Supports AD accounts'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kerberos：支持AD账户
- en: '**NTLM**: Supports both local and AD accounts'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NTLM：支持本地和AD账户
- en: '**CredSSP**: Supports both local and AD accounts'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CredSSP：支持本地和AD账户
- en: It is worth noting that Kerberos, NTLM, and CredSSP all provide message encryption
    over HTTP, which improves security. However, we have already seen how easy it
    is to set up WinRM over HTTPS, and WinRM management over plain HTTP is not enabled
    by default anyway, so we will assume that the communication channel is already
    encrypted. WinRM is a SOAP protocol, meaning it must run over a transport layer
    such as HTTP or HTTPS. To prevent remote management commands being intercepted
    on the network, it is best practice to ensure WinRM runs over the HTTPS protocol.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Kerberos、NTLM和CredSSP都提供了在HTTP上的消息加密，这提高了安全性。然而，我们已经看到了在HTTPS上设置WinRM有多么容易，而且WinRM管理在普通HTTP上默认情况下也是不启用的，所以我们将假设通信通道已经被加密。WinRM是一个SOAP协议，意味着它必须在HTTP或HTTPS等传输层上运行。为了防止远程管理命令在网络上被拦截，最佳实践是确保WinRM在HTTPS协议上运行。
- en: Of these authentication methods, the one that interests us most is Kerberos.
    Kerberos (for the purpose of this chapter) effectively supersedes NTLM for Ansible
    authentication against Active Directory accounts. CredSSP provides another mechanism,
    but there are also security risks relating to the interception of clear-text logons
    on the target host that are best understood before it is deployed—in fact, it
    is disabled by default.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些认证方法中，最让我们感兴趣的是Kerberos。Kerberos（在本章中）有效地取代了NTLM，用于Ansible对Active Directory账户的认证。CredSSP提供了另一种机制，但在部署之前最好了解与在目标主机上拦截明文登录相关的安全风险，事实上，它默认是禁用的。
- en: Before we move on to configuring Kerberos, a brief note about certificate authentication.
    Although initially, this might seem appealing, as it is effectively passwordless,
    current dependencies in Ansible mean that the private key for the certificate
    authentication must be unencrypted on the Ansible automation host. In this regard,
    it is actually more secure (and wiser) to place the password for either a basic
    or Kerberos authentication session in an Ansible vault. We have already covered
    basic authentication, and so we will focus our efforts on Kerberos here.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续配置Kerberos之前，简要说明一下证书认证。虽然最初这可能看起来很吸引人，因为它实际上是无密码的，但是Ansible中的当前依赖关系意味着证书认证的私钥必须在Ansible自动化主机上是未加密的。在这方面，将基本或Kerberos认证会话的密码放在Ansible
    vault中实际上更安全（更明智）。我们已经介绍了基本认证，所以我们将把精力集中在Kerberos上。
- en: As Kerberos authentication only supports Active Directory accounts, it is assumed
    that the Windows host to be controlled by Ansible is already joined to the domain.
    It is also assumed that WinRM over HTTPS has already been set up, as discussed
    earlier in the chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Kerberos认证只支持Active Directory账户，因此假定要由Ansible控制的Windows主机已经加入了域。还假定WinRM在HTTPS上已经设置好，就像本章前面讨论的那样。
- en: 'With these requirements in place, the first thing we have to do is install
    a handful of Kerberos-related packages on the Ansible host itself. The exact packages
    will depend upon your chosen OS, but on Red Hat Enterprise Linux/CentOS 8, it
    would look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些要求，我们首先要做的是在Ansible主机上安装一些与Kerberos相关的软件包。确切的软件包将取决于您选择的操作系统，但在Red Hat Enterprise
    Linux/CentOS 8上，它看起来会像这样：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'On Ubuntu 20.04, you would install the following packages:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu 20.04上，您需要安装以下软件包：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Information
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'Package requirements for Kerberos support on a wider range of OSes are available
    in the Ansible documentation for Windows Remote Management: [https://docs.ansible.com/ansible/latest/user_guide/windows_winrm.html](https://docs.ansible.com/ansible/latest/user_guide/windows_winrm.html).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更广泛的操作系统的Kerberos支持的软件包要求，请参阅Ansible文档中有关Windows远程管理的部分：[https://docs.ansible.com/ansible/latest/user_guide/windows_winrm.html](https://docs.ansible.com/ansible/latest/user_guide/windows_winrm.html)。
- en: 'In addition to these packages, we also need to install the `pywinrm[kerberos]`
    Python module. Availability of this will vary—on Red Hat Enterprise Linux/CentOS
    8, it is not available as an RPM, so we need to install it through `pip` as follows
    (again, if you have used a Python Virtual Environment, be sure to activate it
    and run the `pip3` command without `sudo`):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些软件包，我们还需要安装`pywinrm[kerberos]` Python模块。可用性会有所不同——在Red Hat Enterprise Linux/CentOS
    8上，它不作为RPM包提供，因此我们需要通过`pip`进行安装（同样，如果您使用了Python虚拟环境，请确保激活它，并且在没有`sudo`的情况下运行`pip3`命令）：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that `gcc` is needed by `pip3` to build the module—this can be removed
    afterward if no longer required.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`pip3`需要`gcc`来构建模块——如果不再需要，之后可以将其删除。
- en: Next, ensure that your Ansible server can resolve your AD-related DNS entries.
    The procedure for this will vary according to the OS and network architecture,
    but it is vital that your Ansible controller must be able to resolve the name
    of your domain controller and related entries for the rest of this procedure to
    work.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，确保您的Ansible服务器可以解析您的AD相关的DNS条目。这个过程根据操作系统和网络架构会有所不同，但是至关重要的是，您的Ansible控制器必须能够解析您的域控制器的名称和其他相关条目，以便本过程的其余部分能够正常工作。
- en: 'Once you have configured your DNS settings for your Ansible control host, next,
    add your domain to `/etc/krb5.conf`. For example, my test domain is `mastery.example.com`,
    and my domain controller is `DEMODEM-O5NVEP9.mastery.example.com`, so the bottom
    of my `/etc/krb5.conf` file looks like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您为Ansible控制主机配置了DNS设置，接下来，将您的域添加到`/etc/krb5.conf`。例如，我的测试域是`mastery.example.com`，我的域控制器是`DEMODEM-O5NVEP9.mastery.example.com`，所以我的`/etc/krb5.conf`文件底部看起来是这样的：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note the capitalization—this is important! Test your Kerberos integration using
    the `kinit` command with a known domain user account. For example, I will test
    the integration with my test domain using the following commands:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意大写——这很重要！使用`kinit`命令测试您的Kerberos集成，使用已知的域用户帐户。例如，我将使用以下命令测试我的测试域的集成：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A successful test should look like the one shown in *Figure 4.7*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的测试结果应该像*图4.7*中所示的那样：
- en: '![Figure 4.7 – Testing Kerberos integration between an Ubuntu Ansible control
    host and a Windows domain controller'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7 – 在Ubuntu Ansible控制主机和Windows域控制器之间测试Kerberos集成'
- en: '](Images/B17462_04_07.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_04_07.jpg)'
- en: Figure 4.7 – Testing Kerberos integration between an Ubuntu Ansible control
    host and a Windows domain controller
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 在Ubuntu Ansible控制主机和Windows域控制器之间测试Kerberos集成
- en: 'Finally, let''s create a Windows host inventory—note that it is almost identical
    to the one we used in our basic authentication example; only this time, we have
    specified the Kerberos domain after the username:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个Windows主机清单——请注意，它几乎与我们在基本身份验证示例中使用的清单相同；只是这一次，在用户名之后，我们指定了Kerberos域：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we can test connectivity just like before:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像以前一样测试连接：
- en: '![Figure 4.8 – An Ansible connectivity test using the ansible.windows.win_ping
    module'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8 – 使用ansible.windows.win_ping模块进行Ansible连接测试'
- en: and Kerberos authentication
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 和Kerberos身份验证
- en: '](Images/B17462_04_08.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_04_08.jpg)'
- en: Figure 4.8 – An Ansible connectivity test using the ansible.windows.win_ping
    module and Kerberos authentication
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – 使用ansible.windows.win_ping模块和Kerberos身份验证进行Ansible连接测试
- en: Success! The previous result shows successful end-to-end connectivity with Windows,
    including successful authentication with a domain account using Kerberos, and
    access to the WinRM subsystem.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！前面的结果显示了与Windows的成功端到端连接，包括使用Kerberos对域帐户进行成功认证，并访问WinRM子系统。
- en: A note on accounts
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于账户的说明
- en: 'By default, WinRM is configured to only allow management by members of the
    local `Administrators` group on a given Windows host. This does not have to be
    the administrator account itself—we have used this here for demonstration purposes.
    It is possible to enable the use of less privileged accounts for WinRM management,
    but their use is likely to prove limited, as most Ansible commands require a degree
    of privileged access. Should you wish to have a less privileged account available
    to Ansible via WinRM, run the following command on the host:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，WinRM配置为仅允许由给定Windows主机上的本地`Administrators`组的成员进行管理。这不一定是管理员帐户本身——我们在这里使用它仅用于演示目的。可以启用使用权限较低的帐户进行WinRM管理，但是它们的使用可能会受到限制，因为大多数Ansible命令需要一定程度的特权访问。如果您希望通过WinRM为Ansible提供一个权限较低的帐户，可以在主机上运行以下命令：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Running this command opens a Windows dialog box. Use this to add and grant (as
    a minimum) the `Read` and `Execute` privileges to any user or group you wish to
    have WinRM remote management capabilities.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令会打开一个Windows对话框。使用它来添加并授予（至少）`Read`和`Execute`权限给您希望具有WinRM远程管理能力的任何用户或组。
- en: Certificate validation over WinRM
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过WinRM进行证书验证
- en: So far, we have been ignoring the self-signed SSL certificates used in WinRM
    communication—obviously, this is less than ideal, and it is quite straightforward
    to get Ansible to validate SSL certificates if they are not self-signed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直忽略了WinRM通信中使用的自签名SSL证书——显然，这不是理想的情况，如果SSL证书不是自签名的，让Ansible验证SSL证书是非常简单的。
- en: The easiest way to do this if your Windows machines are members of a domain
    is to use **Active Directory Certificate Services** (**ADCS**)—however, most businesses
    will have their own certification process in place through ADCS, or another third-party
    service. It is assumed, in order to proceed with this section, that the Windows
    host in question has a certificate generated for remote management, and that the
    CA certificate is available in Base64 format.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Windows机器是域成员，最简单的方法是使用**Active Directory Certificate Services**（**ADCS**）-
    但是，大多数企业将通过ADCS或其他第三方服务拥有自己的认证流程。假设为了继续本节，所涉及的Windows主机已生成了用于远程管理的证书，并且CA证书以Base64格式可用。
- en: 'Just as we did earlier on the Windows host, you will need to set up an HTTPS
    listener, but this time using the certificate signed by your CA. You can do so
    (if not already completed) using a command such as the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前在Windows主机上所做的那样，您需要设置一个HTTPS监听器，但这次要使用您的CA签名的证书。您可以使用以下命令（如果尚未完成）来执行此操作：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Naturally, replace the `FilePath` certificate with the one that matches the
    location of your own certificate. If you need to, you can delete any previously
    created HTTPS WinRM listener with the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，将`FilePath`证书替换为与您自己证书位置匹配的证书。如果需要，您可以使用以下命令删除以前创建的任何HTTPS WinRM监听器：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, using the thumbprint from the imported certificate, create a new listener:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用导入证书的指纹创建一个新的监听器：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now to the Ansible controller. The first thing to do is to import the CA certificate
    for the WinRM listener into the CA bundle for your OS. The method and location
    for this will vary between OSes, but, on Ubuntu Server 20.04, you can place the
    Base64-encoded CA certificate in `/usr/share/ca-certificates/`. Note that in order
    to be recognized, the CA file must have the `.crt` extension.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在到Ansible控制器。首先要做的是将WinRM监听器的CA证书导入到操作系统的CA捆绑包中。这种方法和位置在不同的操作系统之间会有所不同，但是在Ubuntu
    Server 20.04上，您可以将Base64编码的CA证书放在`/usr/share/ca-certificates/`中。请注意，为了被识别，CA文件必须具有`.crt`扩展名。
- en: 'Once this has been done, run the following commands:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，运行以下命令：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Select `Yes` when asked if you want to trust certificates from new certificate
    authorities, and ensure that your new certificate filename is selected in the
    list presented on the next screen.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在被问及是否要信任新证书颁发机构的证书时选择“是”，并确保在下一个屏幕上呈现的列表中选择您的新证书文件名。
- en: 'Finally, we need to tell Ansible where to find the certificate. By default,
    Ansible uses the Python Certifi module and will use the default path for this
    unless we tell it otherwise. The above process updates the CA bundle, located
    in `/etc/ssl/certs/ca-certificates.crt`, and luckily, we can tell Ansible where
    to find this in the inventory file. Note the two further changes to the inventory
    file as shown in the following code—first of all, we have now specified the full
    hostname for the Windows host rather than the IP address, as the inventory hostname
    must match the `CN` value on the certificate for full validation to occur. Also,
    we have removed the `ansible_winrm_server_cert_validation` line, which means all
    SSL certificates are now implicitly validated:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要告诉Ansible在哪里找到证书。默认情况下，Ansible使用Python Certifi模块，并且除非我们告诉它否则，否则将使用默认路径。上述过程更新了CA捆绑包，位于`/etc/ssl/certs/ca-certificates.crt`，幸运的是，我们可以在清单文件中告诉Ansible在哪里找到它。请注意清单文件中所示的两个进一步更改，首先，我们现在已经指定了Windows主机的完整主机名，而不是IP地址，因为清单主机名必须与证书上的`CN`值匹配，以进行完整验证。此外，我们已经删除了`ansible_winrm_server_cert_validation`行，这意味着现在所有SSL证书都会被隐式验证：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we run our ping test again, we should now see `SUCCESS`, as shown in *Figure
    4.9*:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行ping测试，我们应该会看到`SUCCESS`，如*图4.9*所示：
- en: '![Figure 4.9 – Ansible ping test using Kerberos authentication and SSL validation
    to a Windows domain controller over WinRM'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9 - 使用Kerberos身份验证和SSL验证对Windows域控制器进行Ansible ping测试'
- en: '](Images/B17462_04_09.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_04_09.jpg)'
- en: Figure 4.9 – Ansible ping test using Kerberos authentication and SSL validation
    to a Windows domain controller over WinRM
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 - 使用Kerberos身份验证和SSL验证对Windows域控制器进行Ansible ping测试
- en: Obviously, we could improve our certificate generation to remove the `subjectAltName`
    warning, but for now, this demonstrates Ansible connectivity to Windows, with
    Kerberos authentication to a domain account and full SSL validation. This completes
    our look at setting up WinRM, and should provide you with all the fundamentals
    you need to set up Windows hosts in your infrastructure for automation with Ansible.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以改进我们的证书生成以消除`subjectAltName`警告，但目前，这演示了Ansible与Windows的连接，使用Kerberos身份验证连接到域帐户并进行完整的SSL验证。这完成了我们对设置WinRM的介绍，并应为您提供了在您的基础架构中为Ansible设置Windows主机所需的所有基础知识。
- en: In the next part of this chapter, we will take a look at setting up the newly
    supported OpenSSH server on Windows to enable Ansible automation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一部分中，我们将看一下在Windows上设置新支持的OpenSSH服务器，以启用Ansible自动化。
- en: Setting up Windows hosts for Ansible control using OpenSSH
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenSSH设置Windows主机以进行Ansible控制
- en: Microsoft has made great strides in supporting and embracing the open source
    community, and has added a number of popular open source packages to their OSes.
    One of the most notable as far as Ansible automation is concerned is the venerable
    and incredibly popular OpenSSH package, which comes in both client and server
    flavors.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 微软在支持和拥抱开源社区方面取得了巨大进展，并向其操作系统添加了许多流行的开源软件包。就Ansible自动化而言，最值得注意的是备受推崇和非常受欢迎的OpenSSH软件包，它有客户端和服务器两种版本。
- en: Support for automating tasks on Windows using SSH as the transport rather than
    WinRM was added in Ansible 2.8 – however, it should be noted that there are many
    warnings about this support in the official Ansible documentation – support is
    described as experimental, and users are warned that things might change in the
    future in a way that is not backward compatible. In addition, developers expect
    to uncover more bugs as they continue their testing.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible 2.8中添加了使用SSH而不是WinRM作为传输的Windows自动化任务的支持 - 但是，应该注意官方Ansible文档中对此支持有许多警告
    - 支持被描述为实验性，并且用户被警告未来可能会以不向后兼容的方式进行更改。此外，开发人员预计在继续测试时会发现更多的错误。
- en: For these reasons, we have put a lot of effort into describing the setup of
    WinRM for automating Windows hosts with Ansible. Nonetheless, this chapter would
    not be complete without a look at enabling Ansible automation for Windows using
    OpenSSH.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因，我们已经付出了很多努力来描述使用WinRM自动化Windows主机与Ansible。尽管如此，本章没有涉及使用OpenSSH为Windows启用Ansible自动化的内容将不完整。
- en: 'OpenSSH Server for Windows is supported on Windows 10 version 1809 and later,
    and also Windows Server 2019\. If you are running an older version of Windows,
    you have two choices – either stay with WinRM as your communication protocol (after
    all, it is built in and easy to configure once you know how), or manually install
    the Win32-OpenSSH package – this process is described in detail here, and should
    support anything from Windows 7 onward: [https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH](https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH).
    Given the active development of this package, readers are advised to refer to
    this documentation if they want to install OpenSSH Server on an older version
    of Windows as the instructions might have changed by the time the book gets to
    print.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Windows上的OpenSSH服务器支持Windows 10版本1809及更高版本，以及Windows Server 2019。如果您正在运行较旧版本的Windows，则有两种选择
    - 要么继续使用WinRM作为通信协议（毕竟，它是内置的，并且一旦您知道如何配置，就很容易），要么手动安装Win32-OpenSSH软件包 - 此过程在此处有详细描述，并且应该支持从Windows
    7开始的任何版本：[https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH](https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH)。鉴于该软件包的积极开发，读者被建议在想要在较旧版本的Windows上安装OpenSSH服务器时参考此文档，因为说明可能在书籍印刷时已经发生了变化。
- en: 'If, however, you are running one of the newer versions of Windows, installing
    the OpenSSH Server is a simple matter. Using a PowerShell session with Administrator
    privileges, first of all, use the following command to query the available `OpenSSH`
    options:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您正在运行较新版本的Windows，则安装OpenSSH服务器就很简单。首先，使用具有管理员权限的PowerShell会话，首先使用以下命令查询可用的`OpenSSH`选项：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output from this command should look something like that in *Figure 4.10*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出应该与*图4.10*中的内容类似：
- en: '![Figure 4.10 – Showing available OpenSSH installation options in PowerShell
    on Windows Server 2019'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.10 - 在Windows Server 2019上的PowerShell中显示可用的OpenSSH安装选项'
- en: '](Images/B17462_04_10.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: Figure 4.10 – Showing available OpenSSH installation options in PowerShell on
    Windows Server 2019
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 - 在Windows Server 2019上的PowerShell中显示可用的OpenSSH安装选项
- en: 'Using this output, run the following command to install the OpenSSH Server:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此输出，运行以下命令安装OpenSSH服务器：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, run the following commands to ensure the SSH server service starts at
    boot time, that it is started, and that a suitable firewall rule exists to allow
    SSH traffic to the server:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令以确保SSH服务器服务在启动时启动，已启动，并且存在适当的防火墙规则以允许SSH流量到服务器：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If an appropriate firewall rule isn''t present, you can add one in with a command
    such as the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在适当的防火墙规则，您可以使用以下命令添加一个：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, the OpenSSH server for Windows defaults to `cmd` for its shell. This
    is fine for interactive tasks, but most of the native Ansible modules for Windows
    are written to support PowerShell – you can change the default shell for the OpenSSH
    server by running the following command in PowerShell:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Windows的OpenSSH服务器默认为`cmd`。这对于交互式任务来说很好，但是大多数用于Windows的本机Ansible模块都是为了支持PowerShell而编写的
    - 您可以通过在PowerShell中运行以下命令来更改OpenSSH服务器的默认shell：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With all these tasks complete, we can finally test our `ansible.windows.win_ping`
    module just as we did before. Our inventory file will look a little different
    from the WinRM one – the following one should serve as a suitable example for
    your testing purposes:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些任务后，我们最终可以像以前一样测试我们的`ansible.windows.win_ping`模块。我们的清单文件将与WinRM的不同 - 以下内容应该作为您测试的一个合适的示例：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that we are no longer concerned with certificate validation or port numbers
    as we are using SSH over the default port, `22`. In fact, apart from the username
    and password (which you could easily specify as command-line arguments to the
    `ansible` command just as we did earlier in this book), the only inventory variable
    that needs setting is `ansible_shell_type`, which will default to a Bourne-compatible
    shell unless we tell it otherwise.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不再关心证书验证或端口号，因为我们正在使用默认端口`22`上的SSH。实际上，除了用户名和密码（您可以像我们在本书早期那样轻松地将其指定为`ansible`命令的命令行参数），唯一需要设置的清单变量是`ansible_shell_type`，除非我们另行告知，否则它将默认为Bourne兼容的shell。
- en: 'The `win_ping` module uses PowerShell when testing connectivity, enabling us
    to use our previous ad hoc command to test our new SSH connectivity to Windows.
    Simply run this command (which should look familiar by now!):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`win_ping`模块在测试连接时使用PowerShell，使我们能够使用先前的临时命令来测试我们新的SSH连接到Windows。只需运行此命令（现在应该看起来很熟悉！）：'
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Even though we have now used a completely different communication protocol,
    the output from this command is exactly the same, and should look like the following
    *Figure 4.11*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们现在使用了完全不同的通信协议，但是此命令的输出与之前完全相同，并且应该看起来像下面的*图4.11*：
- en: '![Figure 4.11 – Testing Ansible integration with Windows using SSH as the transport
    mechanism'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.11 - 使用SSH作为传输机制测试Windows上的Ansible集成'
- en: '](Images/B17462_04_11.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_04_11.jpg)'
- en: Figure 4.11 – Testing Ansible integration with Windows using SSH as the transport
    mechanism
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11——使用SSH作为传输机制测试Windows与Ansible集成
- en: Thus, integrating Ansible with Windows hosts is really quite simple to set up
    – just be sure to keep your eyes on the release notes and porting guides for newer
    Ansible releases in case things change in some non-compatible way. However, I
    think you'll agree that integrating Ansible with Windows using OpenSSH is simple
    to set up. Of course, you can set up SSH key authentication in a similar manner
    to that on any other SSH-based host to ensure you can run playbooks without the
    need for user interaction.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将Ansible与Windows主机集成起来真的非常简单——只需确保关注新版本的发布说明和迁移指南，以防某些不兼容的变化。然而，我认为您会同意，使用OpenSSH将Ansible与Windows集成起来也很简单。当然，您可以以类似的方式设置SSH密钥认证，就像在任何其他基于SSH的主机上一样，以确保您可以在无需用户交互的情况下运行playbooks。
- en: Now, in demonstrating aspects of Windows integration with Ansible through both
    WinRM and SSH, we have only used the Ansible `ansible.windows.win_ping` module
    to test connectivity. Let's build on this by wrapping up the chapter with some
    simple example playbooks to help you get started on creating your own Windows
    automation solutions with Ansible.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在通过WinRM和SSH演示与Ansible的Windows集成的方面，我们只使用了Ansible `ansible.windows.win_ping`模块来测试连接。让我们通过一些简单的示例playbooks结束本章，以帮助您开始创建自己的Windows自动化解决方案。
- en: Automating Windows tasks with Ansible
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible自动化Windows任务
- en: 'A list of the Windows modules included with Ansible 4.3 is available at the
    following link, and it must be noted that, although you can use all the familiar
    Ansible constructs with Windows hosts such as `vars`, `handlers`, and `blocks`,
    you must use Windows-specific modules when defining tasks. The introduction of
    collections means it is quite easy to locate them, and the `ansible.windows` collection
    is a great place to start. This contains all the Windows-specific modules you
    were used to using in Ansible 2.9 and earlier: https://docs.ansible.com/ansible/latest/collections/index_module.html#ansible-windows.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 4.3包含的Windows模块列表可在以下链接找到，需要注意的是，虽然您可以在Windows主机上使用所有熟悉的Ansible构造，如`vars`、`handlers`和`blocks`，但在定义任务时必须使用特定于Windows的模块。引入了集合意味着很容易找到它们，`ansible.windows`集合是一个很好的起点。其中包含了您在Ansible
    2.9及更早版本中使用的所有特定于Windows的模块：https://docs.ansible.com/ansible/latest/collections/index_module.html#ansible-windows。
- en: In this part of the chapter, we will run through a few simple examples of Windows
    playbooks to highlight a few of the things you need to know when writing playbooks
    for Windows.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分中，我们将运行一些简单的Windows playbook示例，以突出编写Windows playbook时需要了解的一些内容。
- en: Picking the right module
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的模块
- en: 'If you were running Ansible against a Linux server, and wanted to create a
    directory and then copy a file into it, you would use the `ansible.builtin.file`
    and `ansible.builtin.copy` Ansible modules, in a playbook that looks something
    like the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要针对Linux服务器运行Ansible，并且想要创建一个目录，然后将文件复制到其中，您将使用`ansible.builtin.file`和`ansible.builtin.copy`
    Ansible模块，playbook看起来类似于以下内容：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'However, on Windows, this playbook would fail to run, as the `ansible.builtin.file`
    and `ansible.builtin.copy` modules are not compatible with PowerShell or cmd,
    regardless of whether you use WinRM or SSH as your communication protocol with
    the Windows machine. As a result, an equivalent playbook to perform the same task,
    but on Windows, would look like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Windows上，此playbook将无法运行，因为`ansible.builtin.file`和`ansible.builtin.copy`模块与PowerShell或cmd不兼容，无论您使用WinRM还是SSH作为与Windows机器通信的协议。因此，执行相同任务的等效playbook在Windows上将如下所示：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note the following differences between the two playbooks:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下两个playbook之间的区别：
- en: '`ansible.windows.win_file` and `ansible.windows.win_copy` are used in place
    of the `ansible.builtin.file` and `ansible.builtin.copy` modules.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible.windows.win_file`和`ansible.windows.win_copy`用于替代`ansible.builtin.file`和`ansible.builtin.copy`模块。'
- en: It is recommended in the documentation for the `ansible.windows.win_file` and
    `ansible.windows.win_copy` modules to use a backslash (`\`) when dealing with
    remote (Windows paths).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ansible.windows.win_file`和`ansible.windows.win_copy`模块的文档中建议在处理远程（Windows路径）时使用反斜杠（`\`）。
- en: Continue to use forward slashes (`/`) on the Linux host.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续在Linux主机上使用正斜杠（`/`）。
- en: Use single quotes (not double quotes) to quote paths that contain spaces.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单引号（而不是双引号）引用包含空格的路径。
- en: It is always important to consult the documentation for the individual modules
    used in your playbooks. For example, reviewing the `ansible.windows.win_copy`
    module documentation, it recommends using the `ansible.windows.win_get_url` module
    for large file transfers because the WinRM transfer mechanism is not very efficient.
    Of course, if you are using the OpenSSH server in place of WinRM, this may not
    apply – at the time of writing, the documentation for this module has not been
    updated to take account of this.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 始终重要的是查阅playbooks中使用的各个模块的文档。例如，查看`ansible.windows.win_copy`模块的文档，它建议在进行大文件传输时使用`ansible.windows.win_get_url`模块，因为WinRM传输机制效率不高。当然，如果您使用OpenSSH服务器代替WinRM，则可能不适用——在撰写本文时，该模块的文档尚未更新以考虑这一点。
- en: Also note that, if a filename contains certain special characters (for example,
    square braces), they need to be escaped using the PowerShell escape character, [PRE34]
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，如果文件名包含某些特殊字符（例如方括号），则需要使用PowerShell转义字符`[PRE34]`进行转义。
- en: '- name: Install package'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '- 名称：安装软件包'
- en: 'win_package:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: win_package：
- en: 'path: ''c:\temp\setupdownloader_`[aaff`].exe'''
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 路径：'c:\temp\setupdownloader_`[aaff`].exe'
- en: 'product_id: {00000000-0000-0000-0000-000000000000}'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 产品ID：{00000000-0000-0000-0000-000000000000}
- en: 'arguments: /silent /unattended'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：/silent /unattended
- en: 'state: present'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 状态：存在
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '- name: Install Acrobat Reader'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '- 名称：安装Acrobat Reader'
- en: 'chocolatey.chocolatey.win_chocolatey:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: chocolatey.chocolatey.win_chocolatey：
- en: 'name: adobereader'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：adobereader
- en: 'state: present'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 状态：存在
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '- name: Create a directory using PowerShell'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '- 名称：使用PowerShell创建目录'
- en: 'ansible.windows.win_shell: New-Item -Path C:\Mastery -ItemType Directory'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 'ansible.windows.win_shell: New-Item -Path C:\Mastery -ItemType Directory'
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '- name: Create a directory using cmd.exe'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '- 名称：使用cmd.exe创建目录'
- en: 'ansible.windows.win_shell: mkdir C:\MasteryCMD'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'ansible.windows.win_shell: mkdir C:\MasteryCMD'
- en: 'args:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: 'executable: cmd'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件：cmd
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: c) `"`
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: c）`"`
- en: d) `/`
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: d）`/`
- en: 'Your Ansible playbooks must be changed depending on whether you are using WinRM
    or SSH communication:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的Ansible剧本必须根据您是使用WinRM还是SSH通信而进行更改：
- en: a) True
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: a）真
- en: b) False
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: b）假
