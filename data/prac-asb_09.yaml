- en: Coding Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码最佳实践
- en: Ansible can help you automate just about all of your daily IT tasks, from mundane
    tasks, such as applying patches or deploying configuration files, to deploying
    entirely new infrastructure as code. The use of, and engagement with, Ansible
    has been growing year by year as more and more people come to realize both its
    power and simplicity. You will find many example Ansible playbooks, roles, blog
    articles, and so on across the internet, and combined with resources such as this
    book, you will become proficient at writing your own Ansible playbooks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible可以帮助您自动化几乎所有日常IT任务，从单调的任务，如应用补丁或部署配置文件，到部署全新的基础设施作为代码。随着越来越多的人意识到其强大和简单，Ansible的使用和参与每年都在增长。您会在互联网上找到许多示例Ansible
    playbook、角色、博客文章等，再加上本书这样的资源，您将能够熟练地编写自己的Ansible playbook。
- en: Yet, how do you know what the best approaches for writing your automation code
    in Ansible are? How can you tell whether an example you found on the internet
    is actually a good way of doing things? In this chapter, we will take you through
    a practical guide of the best practices in Ansible, showing you what is currently
    considered good practice when it comes to directory structure and playbook layout,
    how to make effective use of inventories (especially on the cloud), and how best
    to differentiate your environments. By the end of this chapter, you should be
    able to proceed with confidence in writing everything from small single-task playbooks
    to large-scale playbooks for complex environments.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您如何知道在Ansible中编写自动化代码的最佳方法是什么？您如何判断在互联网上找到的示例是否实际上是一种好的做事方式？在本章中，我们将带您了解Ansible最佳实践的实际指南，向您展示目前被认为是关于目录结构和playbook布局的良好实践，如何有效地使用清单（特别是在云上），以及如何最好地区分您的环境。通过本章的学习，您应该能够自信地编写从小型单任务playbook到复杂环境的大规模playbook。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The preferred directory layout
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首选的目录布局
- en: The best approach to cloud inventories
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云清单的最佳方法
- en: Differentiating between different environment types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分不同的环境类型
- en: The proper approach to defining group and host variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义组和主机变量的正确方法
- en: Using top-level playbooks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用顶级playbook
- en: Leveraging version control tools
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用版本控制工具
- en: Setting OS and distribution variances
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置操作系统和分发差异
- en: Porting between Ansible versions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible版本之间的移植
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have set up your control host with Ansible, as
    in [Chapter 1](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml), *Getting Started with
    Ansible*, and that you are using the most recent version available; the examples
    in this chapter were tested on Ansible 2.9\. This chapter also assumes that you
    have at least one additional host to test against; ideally, this should be Linux-based.
    Although we will give specific examples of hostnames in this chapter, you are
    welcome to substitute them with your own hostname and/or IP addresses, and details
    of how to do this are provided in the appropriate places.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经按照[第1章](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml) *开始使用Ansible*中的方式设置了Ansible的控制主机，并且您正在使用最新版本；本章的示例是在Ansible
    2.9上测试的。本章还假设您至少有一个额外的主机进行测试；理想情况下，这应该是基于Linux的。尽管本章将给出主机名的具体示例，但欢迎您用自己的主机名和/或IP地址替换它们，如何做到这一点的详细信息将在适当的地方提供。
- en: The code bundle used in this chapter is available at [https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%207](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%207).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码包可以在[https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%207](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%207)找到。
- en: The preferred directory layout
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首选的目录布局
- en: As we have explored Ansible throughout this book, we have shown many times that
    the more your playbook grows in size and scale, the more likely you are to want
    to divide it up into multiple files and directories. A great example of this is
    roles, which we covered in [Chapter 4](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml),
    *Playbooks and Roles*, where we defined roles to not only enable us to reuse common
    automation code but also to split up what could potentially be a massive, single
    playbook into smaller, logically organized, manageable chunks. We also looked,
    in [Chapter 3](1bbd0c5e-1eb1-4521-b84d-16cc07083f64.xhtml), *Defining Your Inventory*,
    at the process of defining your inventory file and how you can also split this
    up across multiple files and directories. What we have not looked at, however,
    is how we can put all of this together. All of this is documented in the official
    Ansible documentation at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html#content-organization](https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html#content-organization).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书中探讨了Ansible一样，我们多次表明，随着playbook的规模和规模的增长，您越有可能希望将其分成多个文件和目录。这方面的一个很好的例子是角色，在[第4章](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml)
    *Playbooks and Roles*中，我们定义了角色，不仅使我们能够重用常见的自动化代码，还使我们能够将潜在的庞大的单个playbook分成更小、逻辑上组织得更好、更易管理的部分。我们还在[第3章](1bbd0c5e-1eb1-4521-b84d-16cc07083f64.xhtml)
    *Defining Your Inventory*中，探讨了定义清单文件的过程，以及如何将其分成多个文件和目录。然而，我们还没有探讨如何将所有这些放在一起。所有这些都在官方Ansible文档中有记录，网址是[https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html#content-organization](https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html#content-organization)。
- en: However, in this chapter, let's get started with a practical example of this
    to show you a great way of setting up your directory structure for a simple role-based
    playbook that has two different inventories—one for a development environment
    and one for a production environment (you would want to keep these separate in
    any real-world use case, although ideally, you should be able to execute the same
    plays on both for consistency and for testing purposes).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章中，让我们从一个实际的例子开始，向您展示一个设置简单基于角色的playbook的目录结构的好方法，其中有两个不同的清单——一个用于开发环境，一个用于生产环境（在任何真实的用例中，您都希望将它们分开，尽管理想情况下，您应该能够在两者上执行相同的操作以保持一致性和测试目的）。
- en: 'Let''s get started by building the directory structure:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建目录结构：
- en: 'Create a directory tree for your development inventory with the following commands:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令为您的开发清单创建目录树：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we''ll define an INI-formatted inventory file for our development inventory—in
    our example, we''ll keep this really simple with just two servers. The file to
    create is `inventories/development/hosts`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们的开发清单定义一个INI格式的清单文件——在我们的示例中，我们将保持非常简单，只有两台服务器。要创建的文件是`inventories/development/hosts`：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To further our example, we''ll add a group variable to our app group. As discussed
    in [Chapter 3](1bbd0c5e-1eb1-4521-b84d-16cc07083f64.xhtml), *Defining Your Inventory*,
    create a file called `app.yml` in the `group_vars` directory we created in the
    previous step:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进一步说明，我们将为我们的app组添加一个组变量。如[第3章](1bbd0c5e-1eb1-4521-b84d-16cc07083f64.xhtml)中所讨论的，创建一个名为`app.yml`的文件，放在我们在上一步中创建的`group_vars`目录中：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, create a `production` directory structure using the same method:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用相同的方法创建一个`production`目录结构：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create an inventory file called `hosts` in the newly created `production` directory
    with the following contents:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的`production`目录中创建名为`hosts`的清单文件，并包含以下内容：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we''ll define a different value to the `http_port` group variable for
    our production inventory. Add the following contents to `inventories/production/group_vars/app.yml`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为我们的生产清单的`http_port`组变量定义一个不同的值。将以下内容添加到`inventories/production/group_vars/app.yml`中：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That completes our inventory definition. Next, we will add in any custom modules
    or plugins that we might find useful for our playbook. Suppose we want to use
    the `remote_filecopy.py` module we created in [Chapter 5](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml),
    *Consuming and Creating Modules*. Just as we discussed in this chapter, we first
    create the directory for this module:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的清单定义。接下来，我们将添加任何我们可能发现对我们的playbook有用的自定义模块或插件。假设我们想要使用我们在[第5章](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml)中创建的`remote_filecopy.py`模块。就像我们在本章中讨论的那样，我们首先为这个模块创建目录：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, add the `remote_filecopy.py` module to this library. We won't relist the
    code here to save space, but you can copy it from the section called *Developing
    custom modules* from [Chapter 5](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml),
    *Consuming and Creating Modules*, or take advantage of the example code that accompanies
    this book on GitHub.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`remote_filecopy.py`模块添加到此库中。我们不会在这里重新列出代码以节省空间，但您可以从[第5章](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml)中名为*开发自定义模块*的部分复制它，或者利用本书在GitHub上附带的示例代码。
- en: 'The same can be done for the plugins; if we also want to use our `filter` plugin
    that we created in [Chapter 6](8a78c6c0-fc74-44eb-aa2b-f0d0c6c62cb4.xhtml), *Consuming
    and Creating Plugins*, we would create an appropriately named directory:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 插件也可以做同样的事情；如果我们还想使用我们在[第6章](8a78c6c0-fc74-44eb-aa2b-f0d0c6c62cb4.xhtml)中创建的`filter`插件，我们将创建一个适当命名的目录：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then, copy the `filter` plugin code into this directory.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`filter`插件代码复制到此目录中。
- en: 'Finally, we''ll create a role to use in our new playbook structure. Naturally,
    you will have many roles, but we''ll create one as an example and then you can
    repeat the process for each role. We''ll call our role `installapp` and use the
    `ansible-galaxy` command (covered in [Chapter 4](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml), *Playbooks
    and Roles*) to create the directory structure for us:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个角色来在我们的新playbook结构中使用。当然，您会有很多角色，但我们将创建一个作为示例，然后您可以为每个角色重复这个过程。我们将称我们的角色为`installapp`，并使用`ansible-galaxy`命令（在[第4章](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml)中介绍）为我们创建目录结构：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, in our `roles/installapp/tasks/main.yml` file, we''ll add the following
    contents:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的`roles/installapp/tasks/main.yml`文件中，我们将添加以下内容：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we've reused a number of examples from earlier chapters
    of this book. You can also define the handlers, variables, default values, and
    so on to the role, as discussed previously, but for our example, this will suffice.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们重用了本书前几章的许多示例。您还可以像之前讨论的那样为角色定义处理程序、变量、默认值等，但对于我们的示例来说，这就足够了。
- en: 'The final stage in creating our best practice directory structure is to add
    a top-level playbook to run. By convention, this will be called `site.yml` and
    it will have the following simple contents (note that the directory structure
    we have built takes care of many things, allowing the top-level playbook to be
    incredibly simple):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们最佳实践目录结构的最后阶段是添加一个顶层playbook来运行。按照惯例，这将被称为`site.yml`，并且它将具有以下简单内容（请注意，我们构建的目录结构处理了许多事情，使得顶层playbook非常简单）：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For the purpose of clarity, your resulting directory structure should look
    as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，您的最终目录结构应如下所示：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can simply run our playbook in the normal manner. For example, to run
    it on the development inventory, execute the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以以正常方式运行我们的playbook。例如，要在开发清单上运行它，请执行以下操作：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Similarly, run the following for the production inventory:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对生产清单运行以下命令：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice how the appropriate hosts and associated variables are picked up for
    each inventory and how tidy and well organized our directory structure is. This
    is the ideal way for you to lay out your playbooks and will ensure that they can
    be scaled up to whatever size you need them to be, without them becoming unwieldy
    and difficult to manage or troubleshoot. In the next section of this chapter,
    we will explore the best approaches for working with cloud inventories.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意适当的主机和相关变量是如何被每个清单捕捉到的，以及我们的目录结构是多么整洁和有条理。这是你布置playbooks的理想方式，将确保它们可以按需扩展到任何你需要的规模，而不会变得笨重和难以管理或排查故障。在本章的下一节中，我们将探讨处理云清单的最佳方法。
- en: The best approach to cloud inventories
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云清单的最佳方法
- en: In [Chapter 3](1bbd0c5e-1eb1-4521-b84d-16cc07083f64.xhtml), *Defining Your Inventory*,
    we looked at a simple example of how you can work with a dynamic inventory, and
    we walked you through a practical example using the Cobbler provisioning system.
    However, when it comes to working with cloud inventories (which are simply a form
    of dynamic inventory, but specifically focused on the cloud), they might, at first,
    seem somewhat confusing and you may find it difficult to get them up and running.
    If you follow the high-level procedure outlined in this section, this will become
    an easy and straightforward task.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章《定义清单》中，我们看了一个简单的例子，介绍了如何使用动态清单，并通过使用Cobbler provisioning系统的实际示例为你提供了指导。然而，当涉及到使用云清单（它们只是动态清单的一种形式，但专门针对云）时，一开始可能会感到有些困惑，你可能会发现很难让它们运行起来。如果你按照本节概述的高级程序，这将成为一个简单而直接的任务。
- en: As this is a practically focused book, we will choose an example to work with.
    Sadly, we don't have space to provide practical examples for all of the cloud
    providers, but if you follow the high-level process we will outline for Amazon
    EC2 and apply it to your desired cloud provider (for example, Microsoft Azure
    or Google Cloud Platform), you will find that the process of getting up and running
    is actually quite straightforward.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本实践性的书，我们将选择一个示例进行讨论。遗憾的是，我们没有空间为所有云提供商提供实际示例，但如果你按照我们将为亚马逊EC2概述的高级流程，并将其应用到你所需的云提供商（例如，Microsoft
    Azure或Google Cloud Platform），你会发现上手和运行的过程实际上非常简单。
- en: An important note before we start, however, is that in Ansible versions up to
    and including 2.8.x, the dynamic inventory scripts are part of the Ansible source
    code itself and can be obtained from the main Ansible repository that we examined
    and cloned previously in this book. With the ever-growing and expanding nature
    of Ansible, it has become necessary, in the version 2.9.x releases (and beyond),
    to separate the dynamic inventory scripts into a new distribution mechanism called
    Ansible collections, which will become mainstream in the 2.10 version (not yet
    released at the time of writing). You can learn more about Ansible collections
    and what they are at [https://www.ansible.com/blog/getting-started-with-ansible-collections](https://www.ansible.com/blog/getting-started-with-ansible-collections).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在开始之前需要注意的一点是，在包括2.8.x版本在内的Ansible版本中，动态清单脚本是Ansible源代码的一部分，并且可以从我们在本书中之前检查和克隆的主要Ansible存储库中获取。随着Ansible不断增长和扩展的性质，已经有必要在2.9.x版本（以及以后的版本）中将动态清单脚本分离到一个称为Ansible集合的新分发机制中，这将成为2.10版本的主流（在撰写本文时尚未发布）。你可以在[https://www.ansible.com/blog/getting-started-with-ansible-collections](https://www.ansible.com/blog/getting-started-with-ansible-collections)了解更多关于Ansible集合及其内容。
- en: The way you download and work with dynamic inventory scripts is likely to change
    radically with the 2.10 release of Ansible, yet sadly, very little has been revealed,
    at the time of writing, of what this will look like. As a result, we will guide
    you through the process of downloading your required dynamic inventory provider
    scripts for the current 2.9 release, and advise you to consult the Ansible documentation
    when the 2.10 release comes out for the download location of the relevant scripts.
    Once you have downloaded them, it is my understanding that you will be able to
    continue working with them as outlined in this chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着Ansible 2.10版本的发布，你下载和使用动态清单脚本的方式可能会发生根本性的变化，然而，遗憾的是，在撰写本文时，关于这将是什么样子，目前还没有透露太多。因此，我们将指导你下载当前2.9版本所需的动态清单提供商脚本，并建议你在2.10版本发布时查阅Ansible文档，以获取相关脚本的下载位置。一旦你下载了它们，我相信你将能够按照本章概述的方式继续使用它们。
- en: If you are working with the 2.9 release of Ansible, you can find and download
    all of the latest dynamic inventory scripts from the stable-2.9 branch on GitHub,
    at [https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory](https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Ansible 2.9版本，你可以在GitHub的stable-2.9分支上找到并下载所有最新的动态清单脚本，网址为[https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory](https://github.com/ansible/ansible/tree/stable-2.9/contrib/inventory)。
- en: 'Although the official Ansible documentation has been updated, most guides on
    the internet still reference the old GitHub locations of these scripts and you
    will find that they no longer work. Do bear this in mind when working with dynamic
    inventories! Let''s now proceed to cover at the process for working with a dynamic
    inventory script for a cloud provider; we will use the following Amazon EC2 dynamic
    inventory script as a working example, but the principles we apply here can equally
    be used with any other cloud inventory scripts:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管官方的Ansible文档已经更新，但互联网上的大多数指南仍然引用这些脚本的旧GitHub位置，你会发现它们已经不再起作用。在使用动态清单时，请记住这一点！现在让我们继续讨论使用云提供商的动态清单脚本的过程；我们将以亚马逊EC2动态清单脚本作为工作示例，但我们在这里应用的原则同样适用于任何其他云清单脚本：
- en: 'Having established that we are going to work with Amazon EC2, our first task
    is to obtain the dynamic inventory script and its associated configuration file.
    As cloud technologies move fast, it is probably safest to download the latest
    version of these files directly from the official Ansible project on GitHub. The
    following three commands will download the dynamic inventory script and make it
    executable, as well as downloading the template configuration file:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确定我们要使用Amazon EC2之后，我们的第一个任务是获取动态清单脚本及其相关的配置文件。由于云技术发展迅速，最安全的做法可能是直接从GitHub上的官方Ansible项目下载这些文件的最新版本。以下三个命令将下载动态清单脚本并使其可执行，以及下载模板配置文件：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the files successfully downloaded, let''s take a look inside them. Unfortunately,
    Ansible dynamic inventories do not have the same neat documentation system that
    we have seen in modules and plugins. Fortunately for us, however, the authors
    of these dynamic inventory scripts have put lots of helpful comments at the top
    of these files to get us started. Let''s take a look inside `ec2.py`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功下载文件后，让我们来看看它们的内容。不幸的是，Ansible动态清单没有与我们在模块和插件中看到的那样整洁的文档系统。然而，对我们来说幸运的是，这些动态清单脚本的作者在这些文件的顶部放置了许多有用的注释，以帮助我们入门。让我们来看看`ec2.py`的内容：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are pages of documentation to read, but some of the most pertinent information
    is contained within those first few lines. First of all, we need to ensure that
    the `Boto` library is installed. Secondly, we need to set the AWS access parameters
    for `Boto`. The author of this document has given us the quickest way to get started
    (indeed, it is not their job to replicate the `Boto` documentation).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多文档需要阅读，但其中一些最相关的信息包含在那些开头几行中。首先，我们需要确保`Boto`库已安装。其次，我们需要为`Boto`设置AWS访问参数。本文档的作者已经给了我们最快的入门方式（确实，他们的工作不是复制`Boto`文档）。
- en: However, if you refer to the official documentation for `Boto`, you'll see that
    there are lots of ways of configuring it with your AWS credentials—setting the
    environment variables is just one. You can read more about configuring the `Boto`
    authentication at [https://boto3.amazonaws.com/v1/documentation/api/latest/guide/configuration.html](https://boto3.amazonaws.com/v1/documentation/api/latest/guide/configuration.html).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您参考`Boto`的官方文档，您会发现有很多配置AWS凭据的方法——设置环境变量只是其中之一。您可以在[https://boto3.amazonaws.com/v1/documentation/api/latest/guide/configuration.html](https://boto3.amazonaws.com/v1/documentation/api/latest/guide/configuration.html)上阅读有关配置`Boto`身份验证的更多信息。
- en: 'Before we go ahead and install `Boto`, let''s take a look at the sample `ec2.ini`
    file:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续安装`Boto`之前，让我们来看看示例`ec2.ini`文件：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Again, you can see pages of well-documented options in this file, and if you
    scroll all the way to the bottom, you'll even see that you can specify your credentials
    in this file as an alternative to the methods discussed previously. The default
    settings for this file are, however, sufficient if you just want to get started.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以在此文件中看到大量经过良好记录的选项，并且如果您滚动到底部，甚至会发现您可以在此文件中指定您的凭据，作为先前讨论的方法的替代。然而，默认设置对于您只是想开始使用的情况已经足够了。
- en: 'Let''s now make sure the `Boto` library is installed; exactly how you do this
    will depend on your chosen OS and your version of Python. You might be able to
    install it through a package; on CentOS 7, you can do this as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在确保`Boto`库已安装；确切的安装方法将取决于您选择的操作系统和Python版本。您可能可以通过软件包安装它；在CentOS 7上，您可以按照以下步骤执行此操作：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Alternatively, you can use `pip` for this purpose. For example, to install
    it as part of your Python 3 environment, you can run the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`pip`来实现这一目的。例如，要将其安装为Python 3环境的一部分，您可以运行以下命令：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once you have `Boto` installed, let''s go ahead and set our AWS credentials
    using the environment variables suggested to us in the preceding documentation:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了`Boto`之后，让我们继续使用前面文档中建议给我们的环境变量来设置我们的AWS凭据：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With these steps complete, you can now use your dynamic inventory script in
    the usual way—you simply reference the executable inventory script with the `-i`
    parameter in the same way you do with static inventories. For example, if you
    want to run the Ansible `ping` module as an ad hoc command against all the hosts
    you have running in Amazon EC2, you would need to run the following command. Make
    sure you substitute the user account specified by the `-u` switch with the one
    you connect to your EC2 instances with. Also, reference your private SSH key file:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些步骤后，您现在可以像往常一样使用动态清单脚本——只需使用`-i`参数引用可执行的清单脚本，就像您在静态清单中所做的那样。例如，如果您想对在Amazon
    EC2上运行的所有主机运行Ansible `ping`模块作为临时命令，您需要运行以下命令。确保用`-u`开关指定的用户帐户替换连接到EC2实例的用户帐户。还要引用您的私有SSH密钥文件：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That's all there is to it—if you approach all dynamic inventory scripts in this
    same methodical manner, you will have no problem getting them up and running.
    Just remember that the documentation is normally embedded in both the script file
    and its accompanying configuration file, and make sure you read both before you
    attempt to use the scripts.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——如果您以同样的系统方法处理所有动态清单脚本，那么您将毫无问题地使它们运行起来。只需记住，文档通常嵌入在脚本文件和其附带的配置文件中，请确保在尝试使用脚本之前阅读两者。
- en: 'One thing to note is that many of the dynamic inventory scripts, `ec2.py` included,
    cache the results of their API calls to the cloud provider to speed up repeated
    runs and avoid excessive API calls. However, you might find that in a fast-moving
    development environment, changes to your cloud infrastructure are not picked up
    fast enough. For most scripts, there are two ways around this—most feature cache
    configuration parameters in their configuration file, such as the `cache_path`
    and `cache_max_age` parameters in  `ec2.ini`. If you don''t want to set these
    for every single run, you can also refresh the cache manually by calling the dynamic
    inventory script directly with a special switch—for example, in `ec2.py`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，许多动态清单脚本，包括`ec2.py`，会缓存其对云提供商的API调用结果，以加快重复运行的速度并避免过多的API调用。然而，在快速发展的开发环境中，你可能会发现云基础设施的更改没有被及时捕捉到。对于大多数脚本，有两种解决方法——大多数特性缓存配置参数在其配置文件中，比如`ec2.ini`中的`cache_path`和`cache_max_age`参数。如果你不想为每次运行都设置这些参数，你也可以通过直接调用动态清单脚本并使用特殊开关来手动刷新缓存，例如在`ec2.py`中：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That concludes our practical introduction to cloud inventory scripts. As we
    discussed, provided you consult the documentation (both on the internet and embedded
    within each dynamic inventory script) and follow the simple methodology we described,
    you should have no problems and should be able to get up and running with dynamic
    inventories in minutes. In the next section, we'll revert back to looking at static
    inventories and the best ways to differentiate your various technology environments.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对云清单脚本的实际介绍。正如我们讨论过的，只要你查阅文档（包括互联网上的文档和每个动态清单脚本中嵌入的文档），并遵循我们描述的简单方法，你应该不会遇到问题，并且应该能够在几分钟内开始使用动态清单。在下一节中，我们将回到静态清单，并探讨区分各种技术环境的最佳方法。
- en: Differentiating between different environment types
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分不同的环境类型
- en: In almost every business, you will need to split your technology environment
    by type. For example, you will almost certainly have a development environment,
    where all the testing and development work is performed, and a production environment,
    where all of the stable test code is run. The environments should (in a best-case
    scenario) make use of the same Ansible playbooks—after all, the logic is that
    if you can successfully deploy and test an application in your development environment,
    then you should be able to deploy it in the same way in a production environment
    and have it work just as well. However, there are always differences between the
    two environments, not just in the hostnames, but also sometimes in the parameters,
    the load balancer names, the port numbers, and so on—the list can seem endless.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎每个企业中，你都需要按类型划分你的技术环境。例如，你几乎肯定会有一个开发环境，在这里进行所有的测试和开发工作，并且有一个生产环境，在这里运行所有稳定的测试代码。这些环境（在最理想的情况下）应该使用相同的Ansible
    playbooks——毕竟，逻辑是，如果你能够在开发环境成功部署和测试一个应用程序，那么你应该能够以同样的方式在生产环境中部署它，并且它能够正常运行。然而，这两个环境之间总是存在差异，不仅仅是在主机名上，有时还包括参数、负载均衡器名称、端口号等等——这个列表似乎是无穷无尽的。
- en: 'In the *The preferred directory layout* section of this chapter, we covered
    a way of differentiating between a development and production environment using
    two separate inventory directory trees. This is how you should proceed when it
    comes to differentiating these environments; so, obviously, we won''t repeat the
    examples, but it''s important to note that when working with multiple environments,
    your goals should be as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的*首选目录布局*部分，我们介绍了使用两个单独的清单目录树来区分开发和生产环境的方法。当涉及到区分这些环境时，你应该按照这种方式进行；因此，显然，我们不会重复这些例子，但重要的是要注意，当处理多个环境时，你的目标应该是：
- en: Try and reuse the same playbooks for all of your environments that run the same
    code. For example, if you deploy a web app in your development environment, you
    should be confident that your playbooks will deploy the same app in the production
    environment (and your **Quality Assurance** (**QA**) environment, as well as any
    others that it might need to be deployed in).
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量重用相同的playbooks来运行相同代码的所有环境。例如，如果你在开发环境部署了一个web应用程序，你应该有信心你的playbooks也能在生产环境（以及你的**质量保证**（**QA**）环境，以及其他可能需要部署的环境）中部署相同的应用程序。
- en: This means that not only are you testing your application deployments and code,
    you are also testing your Ansible playbooks and roles as part of your overall
    testing process.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着你不仅在测试应用程序部署和代码，还在测试Ansible的playbooks和roles作为整个测试过程的一部分。
- en: Your inventories for each environment should be kept in separate directory trees
    (as we saw in the *The preferred directory layout *section of this chapter), but
    all roles, playbooks, plugins, and modules (if used) should be in the same directory
    structure (this should be the case for both environments).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个环境的清单应该保存在单独的目录树中（就像本章的*首选目录布局*部分所示），但所有的roles、playbooks、插件和模块（如果有的话）都应该在相同的目录结构中（这对于两个环境来说应该是一样的）。
- en: It is normal for different environments to require different authentication
    credentials; you should keep these separate not only for security but also to
    ensure that playbooks are not accidentally run in the wrong environment.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的环境通常需要不同的身份验证凭据；你应该将这些凭据分开保存，不仅是为了安全，还为了确保playbooks不会意外地在错误的环境中运行。
- en: Your playbooks should be in your version control system, just as your code is.
    This enables you to track changes over time and ensure that everyone is working
    from the same copy of the automation code.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的playbooks应该在你的版本控制系统中，就像你的代码一样。这样可以让你随着时间跟踪变化，并确保每个人都在使用相同的自动化代码副本。
- en: If you pay attention to these simple pointers, you will find that your automation
    workflow becomes a real asset to your business and ensures reliability and consistency
    across all of your deployments. Conversely, failure to follow these pointers puts
    you at risk of experiencing the dreaded, *it worked in development but it doesn't
    work in production* deployment failures that so often plague the technology industry.
    Let's now build on this discussion in the next section by looking at best practices
    when handling host and group variables, something that, as we saw in *The* *preferred
    directory layout* section, you need to apply, especially when working with multiple
    environments.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意这些简单的指针，您会发现您的自动化工作流程成为您业务的真正资产，并确保在所有部署中可靠性和一致性。相反，不遵循这些指针会使您面临在开发中运行正常但在生产中运行失败的可怕情况，这经常困扰着技术行业。现在，让我们在下一节中继续讨论，看看在处理主机和组变量时的最佳实践，正如我们在*首选目录布局*部分中所看到的，您需要应用这些实践，特别是在处理多个环境时。
- en: The proper approach to defining group and host variables
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义组和主机变量的正确方法
- en: 'When working with group and host variables, you can split them up using the
    directory-based approach we used in the *The preferred directory layout* section.
    However, there are a few additional pointers to managing this that you should
    be aware of. First and foremost, you should always pay attention to variable precedence.
    A detailed list of variable precedence order can be found at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable).
    However, the key takeaways for working with multiple environments are as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理组和主机变量时，您可以使用我们在*首选目录布局*部分中使用的基于目录的方法进行拆分。但是，有一些额外的指针可以帮助您管理这一点。首先，您应该始终注意变量的优先级。变量优先级顺序的详细列表可以在[https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable)找到。但是，处理多个环境的关键要点如下：
- en: Host variables are always of a higher order of precedence than group variables;
    so, you can override any group variable with a host variable. This behavior is
    useful if you take advantage of it in a controlled manner, but can yield unexpected
    results if you are not aware of it.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机变量始终比组变量的优先级高；因此，您可以使用主机变量覆盖任何组变量。如果您以受控的方式利用此行为，这种行为是有用的，但如果您不了解它，可能会产生意想不到的结果。
- en: There is a special group variables definition called `all`, which is applied
    to all inventory groups. This has a lower order of precedence than specifically
    defined group variables.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个名为`all`的特殊组变量定义，适用于所有清单组。这比特定定义的组变量的优先级低。
- en: What happens if you define the same variable twice in two groups? If this happens,
    both groups have the same order of precedence, so which one wins? To demonstrate
    this (and our earlier examples), we will create a simple practical example for
    you to follow.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在两个组中定义相同的变量会发生什么？如果发生这种情况，两个组具有相同的优先级，那么谁会获胜？为了演示这一点（以及我们之前的例子），我们将为您创建一个简单的实际示例。
- en: 'To get started, let''s create a directory structure for our inventories. To
    keep this example as concise as possible, we will only create a development environment.
    However, you are free to expand on these concepts by building on the more complete
    example we covered in the *The preferred directory layout* section of this chapter:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们为我们的清单创建一个目录结构。为了尽可能简洁，我们只会创建一个开发环境的例子。但是，您可以通过在本章的*首选目录布局*部分构建更完整的示例来扩展这些概念：
- en: 'Create an inventory directory structure with the following commands:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个清单目录结构：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a simple inventory file with two hosts in a single group in the `inventories/development/hosts`
    file; the contents should be as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`inventories/development/hosts`文件中创建一个包含两个主机的单个组的简单清单文件；内容应如下所示：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let''s create a special group variable file for all the groups in the
    inventory; this file will be called `inventories/development/group_vars/all.yml`
    and should contain the following content:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为清单中的所有组创建一个特殊的组变量文件；这个文件将被称为`inventories/development/group_vars/all.yml`，应包含以下内容：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, let''s create a simple playbook called `site.yml` to query and print
    the value of the variable we just created:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个名为`site.yml`的简单playbook，以查询和打印我们刚刚创建的变量的值：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, if we run this playbook, we''ll see that the variable (which we only defined
    in one place) takes the value we would expect:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们运行这个playbook，我们会看到变量（我们只在一个地方定义）取得了我们期望的值：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So far, so good! Now, let''s add a new file to our inventory directory structure,
    with the `all.yml` file remaining unchanged. Let''s also create a new file located
    in `inventories/development/group_vars/app.yml`, which will contain the following
    content:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！现在，让我们向我们的清单目录结构添加一个新文件，`all.yml`文件保持不变。我们还将创建一个位于`inventories/development/group_vars/app.yml`的新文件，其中将包含以下内容：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have now defined the same variable twice—once in a special group called
    `all` and once in the `app` group (which both servers in our development inventory
    belong to). So, what happens if we now run our playbook? The output should appear
    as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在在一个名为`all`的特殊组和`app`组中定义了相同的变量（我们的开发清单中的两个服务器都属于这个组）。那么，如果我们现在运行我们的playbook会发生什么？输出应如下所示：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As expected, the variable definition in the specific group won, which is in
    line with the order of precedence documented for Ansible. Now, let''s see what
    happens if we define the same variable twice in two specifically named groups.
    To complete this example, we''ll create a child group, called `centos`, and another
    group that could notionally contain hosts built to a new build standard, called
    `newcentos`, which both application servers will be a member of. This means modifying
    `inventories/development/hosts` so that it now looks as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如预期的那样，在特定组中的变量定义获胜，这符合Ansible文档中记录的优先顺序。现在，让我们看看如果我们在两个特定命名的组中定义相同的变量会发生什么。为了完成这个示例，我们将创建一个子组，称为`centos`，以及另一个可能包含按照新的构建标准构建的主机的组，称为`newcentos`，这两个应用服务器都将是其成员。这意味着修改`inventories/development/hosts`，使其看起来如下：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s redefine the `http_port` variable for the `centos` group by creating
    a file called `inventories/development/group_vars/centos.yml`, which contains
    the following content:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过创建一个名为`inventories/development/group_vars/centos.yml`的文件来重新定义`centos`组的`http_port`变量，其中包含以下内容：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Just to add to the confusion, let''s also define this variable for the `newcentos`
    group in `inventories/development/group_vars/newcentos.yml`, which will contain
    the following content:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了增加混乱，让我们也在`inventories/development/group_vars/newcentos.yml`中为`newcentos`组定义这个变量，其中包含以下内容：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We''ve now defined the same variable four times at the group level! Let''s
    rerun our playbook and see which value comes through:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在在组级别定义了相同的变量四次！让我们重新运行我们的playbook，看看哪个值会通过：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The value we entered in `newcentos.yml` won—but why? The Ansible documentation
    states that where identical variables are defined at the group level in the inventory
    (the one place you can do this), the one from the last-loaded group wins. Groups
    are processed in alphabetical order and `newcentos` is the group with the name
    beginning furthest down the alphabet—so, its value of `http_port` was the value
    that won.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`newcentos.yml`中输入的值赢了-但为什么？Ansible文档规定，在清单中（唯一可以这样做的地方）在组级别定义相同的变量时，最后加载的组中的变量获胜。组按字母顺序处理，`newcentos`是字母表中最后一个字母开头的组-因此，它的`http_port`值是获胜的值。
- en: 'Just for completeness, we can override all of this by leaving the `group_vars`
    directory untouched, but adding a file called `inventories/development/host_vars/app01.dev.example.com.yml`,
    which will contain the following content:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完整起见，我们可以通过不触及`group_vars`目录，但添加一个名为`inventories/development/host_vars/app01.dev.example.com.yml`的文件来覆盖所有这些，其中包含以下内容：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, if we run our playbook one final time, we will see that the value we defined
    at the host level completely overrides any value that we set at the group level
    for `app01.dev.example.com`. `app02.dev.example.com` is unaffected as we did not
    define a host variable for it, so the next highest level of precedence—the group
    variable from the `newcentos` group—won:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们最后再次运行我们的playbook，我们会看到我们在主机级别定义的值完全覆盖了我们为`app01.dev.example.com`设置的任何值。`app02.dev.example.com`不受影响，因为我们没有为它定义主机变量，所以优先级的下一个最高级别是`newcentos`组的组变量：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With this knowledge, you can now make advanced decisions about how to structure
    your variables within your inventory to make sure you achieve the desired results
    at both a host and group level. It's important to know about variable precedence
    ordering, as these examples have demonstrated, but following the documented order
    will also allow you to produce powerful, flexible playbook inventories that work
    well across multiple environments. Now, you may have noticed that, throughout
    this chapter, we have used a top-level playbook in our directory structure called
    `site.yml`. We will look at this playbook in greater detail in the next section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，你现在可以做出关于如何在清单中结构化你的变量以确保在主机和组级别都能达到期望结果的高级决策。了解变量优先级顺序是很重要的，因为这些示例已经证明了这一点，但遵循文档中的顺序也将使你能够创建功能强大、灵活的playbook清单，可以在多个环境中很好地工作。现在，你可能已经注意到，在本章中，我们在我们的目录结构中使用了一个名为`site.yml`的顶层playbook。我们将在下一节更详细地讨论这个playbook。
- en: Using top-level playbooks
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用顶层playbooks
- en: In all of the examples so far, we have built out using the best practice directory
    structure recommended by Ansible and continually referred to a top-level playbook,
    typically called `site.yml`. The idea behind this playbook, and, indeed, its common
    name across all of our directory structures, is so that it can be used across
    your entire server estate—that is to say, your **site**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的所有示例中，我们都是使用Ansible推荐的最佳实践目录结构构建的，并且不断地引用顶层playbook，通常称为`site.yml`。这个playbook的理念，实际上，是在我们所有的目录结构中都有一个共同的名字，这样它就可以在整个服务器环境中使用-也就是说，你的**site**。
- en: This, of course, is not to say that you have to use the same set of playbooks
    across every server in your infrastructure or for every single function; rather,
    it means only you can make the best decision as to what suits your environment
    best. However, the whole aim of Ansible automation is that the created solution
    is simple to run and operate. Imagine handing a playbook directory structure with
    100 different playbooks to a new system administrator—how would they know which
    ones to run and in which circumstances? The task of training someone to use the
    playbooks would be immense and would simply move complexity from one area to another.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是说你必须在基础设施的每台服务器或每个功能上使用相同的playbook集合；相反，这意味着只有你才能做出最适合你环境的最佳决定。然而，Ansible自动化的整个目标是所创建的解决方案简单易于运行和操作。想象一下，将一个包含100个不同playbook的playbook目录结构交给一个新的系统管理员-他们怎么知道应该在什么情况下运行哪些playbook？培训某人使用playbook的任务将是巨大的，只会将复杂性从一个领域转移到另一个领域。
- en: At the other the end of the spectrum, you could make use of the `when` clauses
    with facts and inventory grouping, such that your playbook knows exactly what
    to run on each server in every possible circumstance. This, of course, is unlikely
    to happen and the truth is that your automation solution will end up somewhere
    in the middle.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一端，您可以利用`when`子句与事实和清单分组，以便您的playbook确切地知道在每种可能的情况下在每台服务器上运行什么。当然，这是不太可能发生的，事实是您的自动化解决方案最终会处于中间位置。
- en: The most important thing is that, on receipt of a new playbook directory structure,
    a new operator at least knows what the starting point for both running the playbooks,
    and understanding the code is. If the top-level playbook they encounter is always
    `site.yml`, then at least everyone knows where to start. Through the clever use
    of roles and the `import_*` and `include_*` statements, you can split your playbook
    up into logical portions of reusable code, as we previously discussed, all from
    one playbook file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，当收到新的playbook目录结构时，新操作员至少知道运行playbook和理解代码的起点在哪里。如果他们遇到的顶级playbook总是`site.yml`，那么至少每个人都知道从哪里开始。通过巧妙地使用角色和`import_*`和`include_*`语句，您可以将playbook分割成可重用代码的逻辑部分，正如我们之前讨论的那样，所有这些都来自一个playbook文件。
- en: Now that you have learned about the importance of top-level playbooks, let's
    take a look, in the next section, at how to take advantage of version control
    tools to ensure good practices are adhered to when it comes to centralizing and
    maintaining your automation code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了顶级playbook的重要性，让我们在下一节中看看如何利用版本控制工具来确保在集中和维护自动化代码时遵循良好的实践。
- en: Leveraging version control tools
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用版本控制工具
- en: As we discussed earlier in this chapter, it is vital that you version control
    and test not only your code but also your Ansible automation code. This should
    include inventories (or dynamic inventory scripts), any custom modules, plugins,
    roles, and playbook code. The reason for this is simple—the ultimate goal of Ansible
    automation is likely to be to deploy an entire environment using a playbook (or
    set of playbooks). This might even involve deploying infrastructure as code, especially
    if you are deploying to a cloud environment.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面讨论的那样，对于您的Ansible自动化代码，版本控制和测试不仅仅是您的代码，还包括清单（或动态清单脚本）、任何自定义模块、插件、角色和playbook代码都至关重要。这是因为Ansible自动化的最终目标很可能是使用playbook（或一组playbook）部署整个环境。这甚至可能涉及部署基础设施作为代码，特别是如果您要部署到云环境中。
- en: Any changes to your Ansible code could mean big changes to your environment,
    and possibly even whether an important production service works or not. As a result,
    it is vital that you maintain a version history of your Ansible code and that
    everyone works from the same version. You are free to choose the version control
    system that suits you best; most corporate environments will already have some
    kind of version control system in place. However, if you haven't worked with version
    control systems before, we recommend that you sign up for a free account on somewhere
    such as GitHub or GitLab, which both offer version control repositories for free,
    along with more advanced paid-for plans.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对Ansible代码的任何更改可能意味着对您的环境的重大更改，甚至可能意味着重要的生产服务是否正常工作。因此，非常重要的是您保持Ansible代码的版本历史，并且每个人都使用相同的版本。您可以自由选择最适合您的版本控制系统；大多数公司环境已经有某种版本控制系统。但是，如果您以前没有使用过版本控制系统，我们建议您在GitHub或GitLab等地方注册免费帐户，这两者都提供免费的版本控制存储库，以及更高级的付费计划。
- en: A complete discussion of version control with Git is beyond the scope of this
    book; there are, indeed, entire books devoted to the subject. However, we will
    take you through the simplest possible use case. It is assumed, in the following
    examples, that you are using a free account on GitHub, but if you are using a
    different provider, simply change the URLs to match those given to you by your
    version control repository host.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Git的版本控制的完整讨论超出了本书的范围；事实上，整本书都致力于这个主题。但是，我们将带您了解最简单的用例。在以下示例中，假定您正在使用GitHub上的免费帐户，但如果您使用不同的提供商，只需更改URL以匹配您的版本控制存储库主机给您的URL。
- en: 'In addition to this, you will need to install the command-line Git tools on
    your Linux host. On CentOS, you would install these as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，您还需要在Linux主机上安装命令行Git工具。在CentOS上，您可以按照以下方式安装这些工具：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'On Ubuntu, the process is similarly straightforward:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu上，这个过程同样简单：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once the tools are installed and your account is set up, your next task is to
    clone a Git repository to your machine. If you want to start working with your
    own repository, you will need to set this up with your provider—excellent documentation
    is provided by both GitHub and GitLab and you should follow this to set up your
    first repository.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 工具安装完成并且您的帐户设置好之后，您的下一个任务是将Git存储库克隆到您的计算机。如果您想开始使用自己的存储库进行工作，您需要与提供商一起设置这一点——GitHub和GitLab都提供了出色的文档，您应该按照这些文档设置您的第一个存储库。
- en: 'Once it is set up and initialized, you can clone a copy to your local machine
    to make changes to your code. This local copy is called a working copy, and you
    can work through the process of cloning it and making changes as follows (note
    that these are purely hypothetical examples to give you an idea of the commands
    you will need to run; you should adapt them for your own use case):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置和初始化，您可以克隆一个副本到您的本地计算机以对代码进行更改。这个本地副本称为工作副本，您可以按照以下步骤进行克隆和更改的过程（请注意，这些纯属假设性的例子，只是为了让您了解需要运行的命令；您应该根据自己的用例进行调整）：
- en: 'Clone your `git` repository to your local machine to create a working copy
    using a command such as the following:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令将您的`git`存储库克隆到本地计算机以创建一个工作副本：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Change to the directory of the code you cloned (the working copy) and make
    any code changes you need to make:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到您克隆的代码目录（工作副本）并进行任何需要的代码更改：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Be sure to test your code and, when you are happy with it, add the changed
    files that are ready for committing a new version using a command such as the
    following:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保测试您的代码，并且当您对其满意时，添加已准备提交新版本的更改文件，使用以下命令：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The next step is to commit the changes you have made. A commit is basically
    a new version of code within the repository, so it should be accompanied by a
    meaningful `commit` message (specified in quotes after the `-m` switch), as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来要做的是提交您所做的更改。提交基本上是存储库中的新代码版本，因此应该附有有意义的`commit`消息（在`-m`开关后面用引号指定），如下所示：
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Right now, all of these changes live solely in the working copy on your local
    machine. This is good by itself, but it would be better if the code was available
    to everyone who needs to view it on the version control system. To push your updated
    commits back to (for example) GitHub, run the following command:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，所有这些更改都仅存在于您本地计算机上的工作副本中。这本身就很好，但如果代码可以供所有需要在版本控制系统上查看它的人使用，那将更好。要将更新的提交推送回（例如）GitHub，运行以下命令：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That's all there is to it!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！
- en: 'Now, other collaborators can clone your code just as we did in *step 1*. Alternatively,
    if they already have a working copy of your repository, they can update their
    working copy using the following command (you can also do this if you want to
    update your working copy to see changes made by someone else):'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，其他合作者可以克隆您的代码，就像我们在*步骤1*中所做的那样。或者，如果他们已经有您的存储库的工作副本，他们可以使用以下命令更新他们的工作副本（如果您想要更新您的工作副本以查看其他人所做的更改，也可以这样做）：
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There are some incredibly advanced topics and use cases for Git that are beyond
    the scope of this book. However, you will find that roughly 80% of the time, the
    preceding commands are all the Git command-line knowledge you need. There are
    also a number of graphical frontends to Git, as well as code editors and **Integrated
    Development Environments** (**IDEs**), that integrate with Git repositories and
    can assist you further in taking advantage of them. With that complete, let's
    take a look at how to ensure you can use the same playbook (or role) across multiple
    hosts, even though they might have different OSes and versions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Git还有一些非常高级的主题和用例超出了本书的范围。但是，您会发现大约80%的时间，前面的命令就是您需要的所有Git命令行知识。还有许多图形界面的Git前端，以及与Git存储库集成的代码编辑器和**集成开发环境**（**IDEs**），可以帮助您更好地利用它们。完成这些后，让我们看看如何确保您可以在多个主机上使用相同的playbook（或role），即使它们可能具有不同的操作系统和版本。
- en: Setting OS and distribution variances
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置OS和分发差异
- en: As stated earlier, our goal is to try to use the same automation code as widely
    as possible. However, as much as we try to standardize our technology environments,
    variants always creep in. For example, it is impossible to simultaneously perform
    a major upgrade on all your servers in one go, so when a major new OS version
    comes out, such as **Red Hat Enterprise Linux** (**RHEL**) 8 or Ubuntu Server
    20.04, it is inevitable that some machines will remain on older versions as others
    are upgraded. Similarly, an environment might be standardized on Ubuntu, but then
    an application is introduced that has only been certified to run on CentOS. In
    short, as important as standardization is, variances will always creep in.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的目标是尽可能广泛地使用相同的自动化代码。然而，尽管我们努力标准化我们的技术环境，变体总是会出现。例如，不可能同时对所有服务器进行主要升级，因此当出现主要的新操作系统版本时，例如**Red
    Hat Enterprise Linux**（**RHEL**）8或Ubuntu Server 20.04，一些机器将保持在旧版本上，而其他机器将进行升级。同样，一个环境可能标准化为Ubuntu，但随后引入了一个只在CentOS上获得认证的应用程序。简而言之，尽管标准化很重要，但变体总是会出现。
- en: When writing Ansible playbooks, especially roles, your goal should be for them
    to be as widely applicable as possible throughout your environment. A classic
    example of this is package management—let's say you are writing a role to install
    the Apache 2 web server. If you have to support both Ubuntu and CentOS with this
    role, not only do you have different package managers to deal with (`yum` and `apt`),
    you also have different package names (`httpd` and `apache2`).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Ansible playbook时，特别是role时，您的目标应该是使它们尽可能广泛地适用于您的环境。其中一个经典例子是软件包管理——假设您正在编写一个安装Apache
    2 Web服务器的role。如果您必须使用此role支持Ubuntu和CentOS，不仅要处理不同的软件包管理器（`yum`和`apt`），还要处理不同的软件包名称（`httpd`和`apache2`）。
- en: In [Chapter 4](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml), *Playbooks and Roles*,
    we looked at how to apply conditions to tasks using the `when` clause, along with
    facts gathered by Ansible, such as `ansible_distribution`. However, there is another
    way of running tasks on specific hosts that we haven't yet looked at. In the same
    chapter, we also looked at the concept of defining multiple plays in one playbook—there
    is a special module that can create inventory groups for us based on Ansible facts
    and we can leverage this along with multiple plays to create a playbook that runs
    the appropriate tasks on each host based on its type. This is best explained by
    a practical example, so let's get started.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml)中，*Playbooks and Roles*，我们看了如何使用`when`子句将条件应用于任务，以及Ansible收集的事实，如`ansible_distribution`。然而，还有另一种在特定主机上运行任务的方法，我们还没有看过。在同一章中，我们还看了如何在一个playbook中定义多个play的概念——有一个特殊的模块可以根据Ansible事实为我们创建清单组，我们可以利用这一点以及多个play来创建一个playbook，根据主机的类型在每个主机上运行适当的任务。最好通过一个实际的例子来解释这一点，所以让我们开始吧。
- en: 'Assume that we are using the following simple inventory file for this example,
    which has two hosts in a single group called `app`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在此示例中使用以下简单的清单文件，其中有两个主机在一个名为`app`的单个组中：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s now build a simple playbook that demonstrates how you can group differing
    plays using an Ansible fact so that the OS distribution determines which play
    in a playbook gets run. Follow these steps to create this playbook and observe
    it''s operation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建一个简单的playbook，演示如何使用Ansible事实对不同的play进行分组，以便操作系统分发确定playbook中运行哪个play。按照以下步骤创建此playbook并观察其运行：
- en: 'Start by creating a new playbook—we''ll call it `osvariants.yml`—with the following
    `Play` definition. It will also contain a single task, as shown:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个新的playbook——我们将其称为`osvariants.yml`——包含以下`Play`定义。它还将包含一个单独的任务，如下所示：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The playbook structure will be, by now, incredibly familiar to you. However,
    the use of the `group_by` module is new. It dynamically creates new inventory
    groups based on the key that we specify—in this example, we are creating groups
    based on a key comprised of the `os_` fixed string, followed by the OS distribution
    fact obtained from the `Gathering Facts` stage. The original inventory group structure
    is preserved and unmodified, but all the hosts are also added to the newly created
    groups according to their facts.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，playbook结构对您来说应该已经非常熟悉了。但是，使用`group_by`模块是新的。它根据我们指定的键动态创建新的清单组——在本例中，我们根据从`Gathering
    Facts`阶段获取的OS发行版事实创建组。原始清单组结构保留不变，但所有主机也根据其事实添加到新创建的组中。
- en: So, the two servers in our simple inventory remain in the `app` group, but if
    they are based on Ubuntu, they will be added to a newly created inventory group
    called `os_Ubuntu`. Similarly, if they are based on CentOS, they will be added
    to a group called `os_CentOS`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们简单清单中的两台服务器仍然在`app`组中，但如果它们基于Ubuntu，它们将被添加到一个名为`os_Ubuntu`的新创建的清单组中。同样，如果它们基于CentOS，它们将被添加到一个名为`os_CentOS`的组中。
- en: 'Armed with this information, we can go ahead and create additional plays based
    on the newly created groups. Let''s add the following `Play` definition to the
    same playbook file to install Apache on CentOS:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这些信息，我们可以继续根据新创建的组创建额外的play。让我们将以下`Play`定义添加到同一个playbook文件中，以在CentOS上安装Apache：
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is a perfectly normal `Play` definition that uses the `yum` module to install
    the `httpd` package (as required on CentOS). The only thing that differentiates
    it from our earlier work is the `hosts` definition at the top of the play. This
    uses the newly created inventory group created by the `group_by` module in the
    first play.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全正常的`Play`定义，它使用`yum`模块来安装`httpd`包（在CentOS上需要）。唯一与我们之前工作不同的是play顶部的`hosts`定义。这使用了第一个play中由`group_by`模块创建的新创建的清单组。
- en: 'We can, similarly, add a third `Play` definition, this time for installing
    the `apache2` package on Ubuntu using the `apt` module:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们可以添加第三个`Play`定义，这次是使用`apt`模块在Ubuntu上安装`apache2`包：
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If our environment is based on CentOS servers and we run this playbook, the
    results are as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的环境是基于CentOS服务器并运行此playbook，则结果如下：
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Notice how the task to install Apache on CentOS was run. It was run this way
    because the `group_by` module created a group called `os_CentOS` and our second
    play only runs on hosts in the group called `os_CentOS`. As there were no servers
    running on Ubuntu in the inventory, the `os_Ubuntu` group was never created and
    so the third play does not run. We receive a warning about the fact that there
    is no host pattern that matches `os_Ubuntu`, but the playbook does not fail—it
    simply skips this play.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意安装CentOS上的Apache的任务是如何运行的。它是这样运行的，因为`group_by`模块创建了一个名为`os_CentOS`的组，而我们的第二个play仅在名为`os_CentOS`的组中运行。由于清单中没有运行Ubuntu的服务器，因此`os_Ubuntu`组从未被创建，因此第三个play不会运行。我们会收到有关没有与`os_Ubuntu`匹配的主机模式的警告，但playbook不会失败——它只是跳过了这个play。
- en: We provided this example to show you another way of managing the inevitable
    variance in OS types that you will come across in your automation coding. At the
    end of the day, it is up to you to choose the coding style most appropriate to
    you. You can make use of the `group_by` module, as detailed here, or write your
    tasks in blocks and add a `when` clause to the blocks so that they only run when
    a certain fact-based condition is met (for example, the OS distribution is CentOS)—or
    perhaps even a combination of the two. The choice is ultimately yours and these
    different examples are provided to empower you with multiple options that you
    can choose between to create the best possible solution for your scenario.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了这个例子，以展示另一种管理自动化编码中不可避免的OS类型差异的方式。归根结底，选择最适合您的编码风格取决于您。您可以使用`group_by`模块，如此处所述，或者将任务编写成块，并向块添加`when`子句，以便仅在满足某个基于事实的条件时运行（例如，OS发行版是CentOS）——或者甚至两者的组合。选择最终取决于您，这些不同的示例旨在为您提供多种选择，以便您在其中选择最佳解决方案。
- en: Finally, let's round off this chapter with a look at porting your automation
    code between Ansible versions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过查看在Ansible版本之间移植自动化代码来结束本章。
- en: Porting between Ansible versions
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Ansible版本之间移植
- en: Ansible is a fast-moving project, and with releases and new features added,
    new modules (and module enhancements) are released and the inevitable bugs that
    come with the software are fixed. There is no doubt that you will end up writing
    your code against one version of Ansible only to need to run it on a newer version
    again at some point. By way of example, when we started writing this book, the
    current release of Ansible was 2.7\. As we are editing this book ready for publication,
    version 2.9.6 is the current stable version.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个快速发展的项目，随着发布和新功能的添加，新模块（和模块增强）被发布，软件中不可避免的错误也得到修复。毫无疑问，您最终会写出针对Ansible的一个版本的代码，然后在某个时候需要再次在更新的版本上运行它。举例来说，当我们开始写这本书时，当前的Ansible版本是2.7。当我们编辑这本书准备出版时，版本2.9.6是当前的稳定版本。
- en: Often, you will find that your code from an earlier version "just about works"
    when you upgrade it, but this isn't always a given. Modules are sometimes deprecated
    (although usually not without warning) and features do change. Several major changes
    are expected when Ansible 2.10 is released. So, the question remains—how can you
    ensure that your playbooks, roles, modules, and plugins still work when you update
    your Ansible installation?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当你升级时，你会发现你的早期版本的代码“差不多能用”，但这并不总是确定的。有时模块会被弃用（尽管通常不会没有警告地弃用），功能也会发生变化。预计
    Ansible 2.10 发布时会有一些重大变更。因此，问题是——当你更新你的 Ansible 安装时，如何确保你的剧本、角色、模块和插件仍然能够正常工作？
- en: 'The first part of the answer is to establish which version of Ansible you are
    starting from. For example, let''s say you are preparing for the release of Ansible
    2.10\. If you query the version of Ansible you already have installed and see
    something like the following, then you know you are starting from Ansible release
    2.9:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 回答的第一部分是确定你从哪个版本的 Ansible 开始。例如，假设你正在准备升级到 Ansible 2.10。如果你查询已安装的 Ansible 版本，看到类似以下的内容，那么你就知道你是从
    Ansible 2.9 版本开始的：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: So, your first port of call should be to review the porting guide for the Ansible
    2.10 release; a porting guide is normally written for every major release (such
    as 2.8, 2.9, and so on). The guide for 2.10 can be found at [https://docs.ansible.com/ansible/devel/porting_guides/porting_guide_2.10.html](https://docs.ansible.com/ansible/devel/porting_guides/porting_guide_2.10.html).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你首先需要查看 Ansible 2.10 版本的迁移指南；通常每个主要版本（比如 2.8、2.9 等）都会有一个迁移指南。2.10 版本的指南可以在
    [https://docs.ansible.com/ansible/devel/porting_guides/porting_guide_2.10.html](https://docs.ansible.com/ansible/devel/porting_guides/porting_guide_2.10.html)
    找到。
- en: If we review this document, we can see that there are a number of changes coming—whether
    they are significant to you really depends on the code you are running. For example,
    if we review the *Modules Removed* section of the guide, we can see that the `letsencrypt`
    module has been removed and it is suggested that you use the `acme_certificate`
    module instead. If you are generating free SSL certificates using the `letsencrypt`
    module in Ansible, then you would certainly need to update your playbooks and
    roles to accommodate this change.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看这份文档，我们会发现即将有一些变更——这些变更对你是否重要取决于你正在运行的代码。例如，如果我们查看指南中的 *Modules Removed*
    部分，我们会发现 `letsencrypt` 模块已被移除，并建议你使用 `acme_certificate` 模块代替。如果你在 Ansible 中使用
    `letsencrypt` 模块生成免费的 SSL 证书，那么你肯定需要更新你的剧本和角色以适应这一变更。
- en: 'As you can see in the preceding link, there are a great number of changes between
    the 2.9 and 2.10 releases of Ansible. To that end, it''s also important to note
    that the porting guides are written from the perspective of an upgrade from the
    previous major release. That is to say, if you query your Ansible version and
    it returns the following, you are porting from Ansible 2.8:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的链接中看到的，Ansible 2.9 和 2.10 版本之间有大量的变更。因此，重要的是要注意，迁移指南是从升级前一个主要版本的角度编写的。也就是说，如果你查询你的
    Ansible 版本并返回以下内容，那么你是从 Ansible 2.8 迁移过来的：
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If you move straight to Ansible 2.10 when it comes out, then you need to review
    the porting guides for both 2.9 (which covers the changes required to your code
    between releases 2.8 and 2.9) and 2.10 (which covers the changes required to upgrade
    from 2.9 to 2.10). An index of all the porting guides can be found on the official
    Ansible website at [https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.html](https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.html).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接升级到 Ansible 2.10，那么你需要查看 2.9（涵盖了从 2.8 到 2.9 的代码变更）和 2.10（涵盖了从 2.9 到 2.10
    的升级所需的变更）的迁移指南。所有迁移指南的索引可以在官方 Ansible 网站上找到，网址是 [https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.html](https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.html)。
- en: Another great source of information, especially more fine-grained information,
    on the changes between releases are the changelogs. These are released and updated
    for every minor release and can currently be found at the official Ansible GitHub
    repository on the `stable` branch for the release you wish to query. For example,
    if you wish to review all the changelogs for Ansible 2.9, you would need to go
    to [https://github.com/ansible/ansible/blob/stable-2.9/changelogs/CHANGELOG-v2.9.rst](https://github.com/ansible/ansible/blob/stable-2.9/changelogs/CHANGELOG-v2.9.rst).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个获取信息的好途径，尤其是更精细的信息，是变更日志。这些日志会在每个次要版本发布时发布和更新，目前可以在官方 Ansible GitHub 仓库的“stable”分支上找到，用于你想查询的版本。例如，如果你想查看
    Ansible 2.9 的所有变更日志，你需要前往 [https://github.com/ansible/ansible/blob/stable-2.9/changelogs/CHANGELOG-v2.9.rst](https://github.com/ansible/ansible/blob/stable-2.9/changelogs/CHANGELOG-v2.9.rst)。
- en: The trick to porting code between Ansible releases (if, indeed, you can call
    it a trick) is simply to read the excellent documentation released by the Ansible
    project team. A lot of effort goes into creating this documentation, so you are
    advised to make good use of it. That concludes our look at the best practices
    for working with Ansible. We hope you have found this chapter valuable.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码从 Ansible 版本迁移到另一个版本（如果你愿意这么称呼的话）的诀窍就是阅读 Ansible 项目团队发布的优秀文档。大量的工作投入到了创建这些文档中，因此建议你充分利用。这就结束了我们对使用
    Ansible 的最佳实践的介绍。希望你觉得这一章很有价值。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Ansible automation projects often start out small, but as people come to realize
    the power and simplicity of Ansible, both the code and the inventories tend to
    grow at an exponential pace (at least in my experience). It is important that
    in the push for greater automation, the Ansible automation code and infrastructure
    itself doesn't become another headache. By embedding a few good practices early
    on and applying them consistently throughout your automation journey with Ansible,
    you will find that managing your Ansible automation is simple and easy and is
    a true benefit to your technology infrastructure.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible自动化项目通常从小规模开始，但随着人们意识到Ansible的强大和简单，代码和清单往往呈指数增长（至少在我的经验中是这样）。在推动更大规模自动化的过程中，重要的是Ansible自动化代码和基础设施本身不会成为另一个头疼事。通过在早期嵌入一些良好的实践并在整个使用Ansible进行自动化的过程中始终如一地应用它们，您会发现管理Ansible自动化是简单易行的，并且对您的技术基础设施是真正有益的。
- en: In this chapter, you learned about the best practices for directory layout that
    you should adopt for your playbooks and the steps you should adopt when working
    with cloud inventories. You then learned new ways of differentiating environments
    by OS type, as well as more about variable precedence and how to leverage it when
    working with host and group variables. You then explored the importance of the
    top-level playbook, before looking at how to make use of version control tools
    to manage your automation code. Finally, you explored the new techniques for creating
    single playbooks that will manage servers of different OS versions and distributions,
    before finally looking at the important topic of porting your code to new Ansible
    versions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了应该为playbook采用的目录布局的最佳实践，以及在使用云清单时应采用的步骤。然后，您学习了通过OS类型区分环境的新方法，以及有关变量优先级以及在处理主机和组变量时如何利用它的更多信息。然后，您探索了顶级playbook的重要性，然后看了如何利用版本控制工具来管理您的自动化代码。最后，您探讨了创建单个playbook的新技术，该playbook将管理不同OS版本和发行版的服务器，最后看了将代码移植到新的Ansible版本的重要主题。
- en: In the next chapter, we will look at some of the more advanced ways that you
    can use Ansible to take care of some special cases that may arise on your automation
    journey.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨您可以使用Ansible来处理在自动化过程中可能出现的一些特殊情况的一些更高级的方法。
- en: Questions
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a safe and easy way to manage (that is, modify, fix, and create) code
    changes continuously and share them with others?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是一种安全且简单的方式来持续管理（即修改、修复和创建）代码更改并与他人共享？
- en: A) Playbook revision
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: A）Playbook修订
- en: B) Task history
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: B）任务历史
- en: C) Ad hoc creation
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: C）临时创建
- en: D) With a Git repository
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: D）使用Git存储库
- en: E) Log management
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: E）日志管理
- en: True or false – Ansible Galaxy supports sharing roles with other users from
    a central, community-supported repository.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Ansible Galaxy支持从中央、社区支持的存储库与其他用户共享角色。 '
- en: A) True
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: A）真
- en: B) False
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: B）假
- en: True or false – Ansible modules are guaranteed to be available in all future
    releases of Ansible.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假- Ansible模块保证在将来的所有版本中都可用。
- en: A) True
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: A）真
- en: B) False
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: B）假
- en: Further reading
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Manage multiple repositories, versions, or tasks by creating branches and tags
    to control multiple versions effectively. Refer to the following links for more
    details:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建分支和标签来管理多个存储库、版本或任务，以有效地控制多个版本。有关更多详细信息，请参考以下链接：
- en: 'How to use Git tagging: [https://git-scm.com/book/en/v2/Git-Basics-Tagging](https://git-scm.com/book/en/v2/Git-Basics-Tagging)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Git标记：[https://git-scm.com/book/en/v2/Git-Basics-Tagging](https://git-scm.com/book/en/v2/Git-Basics-Tagging)
- en: 'How to use Git branches: [https://git-scm.com/docs/git-branch](https://git-scm.com/docs/git-branch)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Git分支：[https://git-scm.com/docs/git-branch](https://git-scm.com/docs/git-branch)
