- en: Production Considerations for Running Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Kubernetes的生产考虑
- en: You have arrived at the last chapter of this book— well done! In this short
    chapter, we will provide you with various best practices and recommendations for
    running Kubernetes in production. There are always two worlds for every software
    engineering approach or tool—how you use it for development and how you use it
    in production. For Kubernetes, running in production requires more operations
    overheads as you want to run your workloads with high availability and reliability, often at
    a large scale. You have to consider how you are performing upgrades to the cluster
    itself and how you patch the underlying operating system, ensuring the continuity
    of your business. If you are running Kubernetes in an isolated network in your
    enterprise data center, you may need to wire in network proxy configuration in
    all components of Docker and Kubernetes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经到达本书的最后一章了——干得好！在这一简短的章节中，我们将为您提供运行Kubernetes在生产环境中的各种最佳实践和建议。对于每种软件工程方法或工具，总是有两个世界——您如何在开发中使用它以及您如何在生产中使用它。对于Kubernetes来说，在生产中运行需要更多的运维开销，因为您希望以高可用性和可靠性运行您的工作负载，通常规模较大。您必须考虑如何对集群本身进行升级，以及如何对底层操作系统进行补丁，确保业务的连续性。如果您在企业数据中心的隔离网络中运行Kubernetes，您可能需要在Docker和Kubernetes的所有组件中进行网络代理配置。
- en: Additionally, it is important to ensure that your clusters are provisioned reproducibly
    using *infrastructure as code* and *immutable infrastructure* approaches. But
    this is not everything—you definitely want to manage your cluster workloads declaratively
    (similar to your infrastructure) and for that, you can employ the GitOps approach.
    All of the concepts that we describe in this chapter can be applied to Linux-only
    clusters and hybrid Windows/Linux clusters as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，确保使用“基础设施即代码”和“不可变基础设施”方法可再生地配置您的集群非常重要。但这还不是全部——您肯定希望以声明方式管理您的集群工作负载（类似于您的基础设施），为此，您可以采用GitOps方法。我们在本章描述的所有概念也可以应用于仅Linux集群和混合Windows/Linux集群。
- en: 'This last chapter of this book will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的最后一章将涵盖以下主题：
- en: Provisioning clusters reproducibly
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可再生地配置集群
- en: Kubeadm limitations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubeadm的限制
- en: Upgrading clusters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级集群
- en: OS patching
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统补丁
- en: Configuring a network proxy for the Docker daemon and Kubernetes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Docker守护程序和Kubernetes配置网络代理
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您将需要以下内容：
- en: Windows 10 Pro, Enterprise, or Education (version 1903 or later, 64-bit) installed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装Windows 10专业版、企业版或教育版（1903版或更高版本，64位）
- en: An Azure account
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure帐户
- en: Helm installed
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装Helm
- en: A Windows/Linux Kubernetes cluster deployed using AKS Engine or an on-premises
    cluster
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AKS Engine或本地集群部署的Windows/Linux Kubernetes集群
- en: To follow along, you will need your own Azure account to create Azure resources
    for the Kubernetes cluster. If you haven't already created the account for the
    previous chapters, you can read more about how to obtain a limited free account
    for personal use here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟着做，您需要自己的Azure帐户来为Kubernetes集群创建Azure资源。如果您还没有为之前的章节创建帐户，您可以在这里阅读更多关于如何获得个人使用的有限免费帐户：[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)。
- en: Deploying a Kubernetes cluster using AKS Engine has been covered in [Chapter
    8](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml), *Deploying Hybrid Azure Kubernetes
    Service Engine Cluster*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AKS Engine部署Kubernetes集群已在[第8章](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml)中介绍过，*部署混合Azure
    Kubernetes服务引擎集群*。
- en: You can download the latest code samples for this chapter from the official
    GitHub repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter16](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter16).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从官方GitHub存储库下载本章的最新代码示例：[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter16](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter16)。
- en: Provisioning clusters reproducibly
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重现地配置集群
- en: First, let's take a look at how you can approach provisioning your clusters
    and the underlying infrastructure and how to declaratively manage your application
    workloads as part of your **Continuous Integration** or **Continuous Deployment**
    (**CI/CD**) pipelines. In all cases, setting up any *infrastructure as code* approach
    is a bit harder and more complex than just using the infrastructure but it pays
    off greatly in the end game. You gain configuration consistency, simplicity when
    introducing complex changes, testable/analyzable infrastructure changes, and reproducible
    environments for any stage of the development workflow.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看您如何处理配置您的集群和基础设施以及如何在**持续集成**或**持续部署**（**CI/CD**）管道中作为一部分声明性地管理您的应用程序工作负载。在所有情况下，设置任何*基础设施即代码*方法都比仅使用基础设施更加困难和复杂，但最终会有很大的回报。您可以获得配置一致性，在引入复杂更改时的简单性，可测试/可分析的基础设施更改以及开发工作流程的任何阶段的可重现环境。
- en: Infrastructure as code for clusters
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于集群的基础设施即代码
- en: '**Infrastructure as Code** (**IaC**) is, in short, the concept of managing
    your whole IT infrastructure using declarative configuration files only. What
    it means is that you aim to havie the state of your infrastructure captured in
    configuration files and apply changes to the environment using dedicated tools
    rather than performing physical hardware configuration using scripts or interactive
    tooling. For Azure, you can use **Azure Resource Manager** (**ARM**) templates ([https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-authoring-templates](https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-authoring-templates))
    to describe your infrastructure or use a generic IaC tool such as Terraform ([https://www.terraform.io/](https://www.terraform.io/)).
    In fact, you have already used ARM templates indirectly when deploying the AKS
    Engine cluster—you can think of AKS Engine tools as another layer of abstraction
    for creating complex ARM templates.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础设施即代码**（**IaC**）简而言之，是仅使用声明性配置文件管理整个IT基础设施的概念。这意味着您的基础设施状态被捕获在配置文件中，并且使用专用工具应用环境更改，而不是使用脚本或交互式工具进行物理硬件配置。对于Azure，您可以使用**Azure资源管理器**（**ARM**）模板（[https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-authoring-templates](https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-authoring-templates)）来描述您的基础设施，或者使用通用的IaC工具，如Terraform（[https://www.terraform.io/](https://www.terraform.io/)）。实际上，在部署AKS
    Engine集群时，您已间接使用了ARM模板，您可以将AKS Engine工具视为创建复杂ARM模板的另一层抽象。'
- en: 'You can take the IaC approach even further: **Immutable Infrastructure** (**IM**).
    In the case of IM, you never modify any configuration on the machines after they
    are deployed. If you need to perform a fix, you have to build a new machine from
    a base image with a fix and deprovision the old machines. This may sound extreme
    but it can be easily achieved both in the virtual machines world as well as bare-metal
    environments.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以进一步采用IaC方法：**不可变基础设施**（**IM**）。在IM的情况下，部署后从不修改任何机器上的任何配置。如果需要进行修复，您必须使用修复的基础镜像构建新的机器，并取消配置旧的机器。这听起来可能很极端，但在虚拟机世界和裸机环境中都可以轻松实现。
- en: Packer ([https://www.packer.io/](https://www.packer.io/)) is one of the best
    tools to help you to introduce this paradigm for virtual and bare-metal machines.
    But if you think about it carefully, we have already been using IaC and IM in
    this book a lot but at a different, higher level.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Packer ([https://www.packer.io/](https://www.packer.io/)) 是帮助您引入这种虚拟和裸机机器范式的最佳工具之一。但是如果您仔细考虑一下，我们在本书中已经大量使用了IaC和IM，但是在不同的、更高的级别上。
- en: Docker itself is a manifestation of *immutable infrastructure*, where you ship
    your software as immutable operating system container images, just as if they
    were VM images.Kubernetes can be seen as a platform for managing your immutable
    container infrastructure for your application workloads—whenever you create a
    new Docker image and roll out a new version of a Deployment, you are just creating
    new containers and throwing away the old ones. If you use a declarative approach
    to manage your Kubernetes objects (at least using `kubectl apply -f`), you end
    up with neat *infrastructure as code*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Docker本身就是*不可变基础设施*的体现，您可以将软件作为不可变的操作系统容器映像进行传送，就像它们是VM映像一样。Kubernetes可以被视为管理您的应用程序工作负载的不可变容器基础设施的平台——每当您创建一个新的Docker映像并部署新版本的部署时，您只是在创建新的容器并丢弃旧的容器。如果您使用声明性方法来管理您的Kubernetes对象（至少使用`kubectl
    apply -f`），您最终会得到整洁的*基础设施即代码*。
- en: 'This long introduction shows us a few things that can be treated as recommendations
    for provisioning infrastructure for Kubernetes and deploying your clusters, from
    the lowest to the highest level:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇长篇介绍向我们展示了一些可以被视为为Kubernetes提供基础设施和部署集群的建议，从最低到最高级别：
- en: Always provision your underlying infrastructure for clusters using the *infrastructure
    as code* or *immutable infrastructure* approach, using the right tools for the
    job. Terraform or ARM templates suit this task very well in both cases. AKS Engine ([https://github.com/Azure/aks-engine](https://github.com/Azure/aks-engine))
    is a perfect example of *immutable infrastructure* tooling built on top of ARM
    templating. If you want to roll out a new version of a VM image for your cluster
    nodes, you need to create a new node pool with a new image and decommission the
    old node pool. Avoid using tools that were not originally meant to do that, such
    as Ansible.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终使用*基础设施即代码*或*不可变基础设施*方法为集群提供底层基础设施，使用适合工作的正确工具。Terraform或ARM模板在这两种情况下都非常适合这项任务。AKS
    Engine ([https://github.com/Azure/aks-engine](https://github.com/Azure/aks-engine))
    是建立在ARM模板之上的*不可变基础设施*工具的完美示例。如果您想为集群节点部署新版本的VM映像，您需要创建一个新的节点池并使用新映像，然后停用旧的节点池。避免使用最初并非用于此目的的工具，比如Ansible。
- en: To create the Kubernetes cluster itself on your infrastructure, use the *infrastructure
    as code* concept. Tools such as Ansible ([https://www.ansible.com/](https://www.ansible.com/)),
    Powershell Desired State Configuration ([https://docs.microsoft.com/en-us/powershell/scripting/dsc/overview/overview?view=powershell-6](https://docs.microsoft.com/en-us/powershell/scripting/dsc/overview/overview?view=powershell-6)),
    or dedicated kubespray ([https://github.com/kubernetes-sigs/kubespray](https://github.com/kubernetes-sigs/kubespray))
    are perfect for this task. AKS Engine excellently combines both infrastructure
    provisioning and cluster Deployment into one tool. If you need a managed Kubernetes
    service, then again use Terraform or ARM templates. But do not use them for self-managed
    clusters to provision software—even if they are capable of doing that, they were
    not meant to do so in the first place.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的基础设施上创建Kubernetes集群本身时，请使用“基础设施即代码”概念。诸如Ansible（[https://www.ansible.com/](https://www.ansible.com/)）、Powershell
    Desired State Configuration（[https://docs.microsoft.com/en-us/powershell/scripting/dsc/overview/overview?view=powershell-6](https://docs.microsoft.com/en-us/powershell/scripting/dsc/overview/overview?view=powershell-6)）或专用的kubespray（[https://github.com/kubernetes-sigs/kubespray](https://github.com/kubernetes-sigs/kubespray)）等工具非常适合这项任务。AKS
    Engine将基础设施的提供和集群部署完美地结合在一个工具中。如果您需要托管的Kubernetes服务，那么再次使用Terraform或ARM模板。但是不要将它们用于自管理集群来提供软件，即使它们有能力这样做，它们最初也不是为此而设计的。
- en: Use Docker and Kubernetes clusters as an *immutable infrastructure* platform
    for your application workloads. Manage this platform using dedicated, declarative
    tools such as Kustomize ([https://kustomize.io/](https://kustomize.io/)) or Helm ([https://helm.sh/](https://helm.sh/)).
    Take Helm chart management to an even higher, also declarative, level—use Helmfile
    ([https://github.com/roboll/helmfile](https://github.com/roboll/helmfile)) or
    Flux ([https://github.com/fluxcd/flux](https://github.com/fluxcd/flux)). You will
    not have to worry about running the `helm upgrade` command again! But again, do
    not use tools that were not meant for this, such as Ansible or Terraform, even
    though they have modules or providers that are advertised as being capable of
    managing Kubernetes Objects or Helm Charts. You risk tying to a custom API that
    does not have all of Kubernetes features and quickly gets outdated.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker和Kubernetes集群作为应用工作负载的“不可变基础设施”平台。使用专用的声明性工具来管理这个平台，比如Kustomize（[https://kustomize.io/](https://kustomize.io/)）或Helm（[https://helm.sh/](https://helm.sh/)）。将Helm
    chart管理提升到一个更高的、也是声明性的水平——使用Helmfile（[https://github.com/roboll/helmfile](https://github.com/roboll/helmfile)）或Flux（[https://github.com/fluxcd/flux](https://github.com/fluxcd/flux)）。您将不必再担心运行“helm
    upgrade”命令！但是再次强调，不要使用那些本来不是为此而设计的工具，比如Ansible或Terraform，即使它们有被宣传为能够管理Kubernetes对象或Helm
    Charts的模块或提供者。您会冒着绑定到一个不具备所有Kubernetes功能并很快过时的自定义API的风险。
- en: If you want to manage multiple Kubernetes clusters declaratively, definitely
    keep an eye on the Kubernetes Cluster API ([https://cluster-api.sigs.k8s.io/introduction.html](https://cluster-api.sigs.k8s.io/introduction.html)),
    which is currently in alpha state. This Kubernetes project will allow you to create
    a special Kubernetes management cluster where you can operate on clusters or machines
    as Kubernetes custom resources.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想以声明性方式管理多个Kubernetes集群，一定要密切关注目前处于alpha状态的Kubernetes Cluster API（[https://cluster-api.sigs.k8s.io/introduction.html](https://cluster-api.sigs.k8s.io/introduction.html)）。这个Kubernetes项目将允许您创建一个特殊的Kubernetes管理集群，在那里您可以操作集群或机器作为Kubernetes自定义资源。
- en: So, in short, always use the right tool for the job! This is why we will now
    take a look at Flux and the GitOps approach.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，始终使用正确的工具来完成工作！这就是为什么我们现在将看一看Flux和GitOps方法。
- en: GitOps for application workloads
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用工作负载的GitOps
- en: 'Flux ([https://github.com/fluxcd/flux](https://github.com/fluxcd/flux)) is a
    tool that automatically ensures that the state of a Kubernetes cluster matches
    the configuration (manifests and Helm charts) in Git. This approach complies with
    GitOps, which is a way of managing Kubernetes clusters and your applications,
    proposed by Weaveworks ([https://www.weave.works/technologies/gitops/](https://www.weave.works/technologies/gitops/)),
    where the Git repository is the single source of truth for the declarative infrastructure
    and your application workloads. This approach fully complies with the *infrastructure
    as code* paradigm. Moreover, you have a good separation of concerns: the developers
    introduce the changes to the cluster state or application configuration, which
    are stored in a Git repository (through a full CI pipeline) and a dedicated GitOps
    component is responsible for applying the configuration to the Kubernetes cluster.
    You get this clear boundary and you can always be sure that what is in the repository
    reflects the actual cluster state.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Flux ([https://github.com/fluxcd/flux](https://github.com/fluxcd/flux)) 是一个工具，它可以自动确保
    Kubernetes 集群的状态与 Git 中的配置（清单和 Helm 图表）匹配。这种方法符合 GitOps 的理念，GitOps 是一种由 Weaveworks
    提出的管理 Kubernetes 集群和应用程序的方式，其中 Git 仓库是声明性基础设施和应用工作负载的唯一真相来源。这种方法完全符合“基础设施即代码”的范式。此外，你可以很好地分离关注点：开发人员对集群状态或应用程序配置进行更改，这些更改存储在
    Git 仓库中（通过完整的 CI 流水线），专用的 GitOps 组件负责将配置应用到 Kubernetes 集群。你可以得到清晰的边界，并且始终可以确保仓库中的内容反映了实际的集群状态。
- en: Let's take a look at how you can use Flux to manage a cluster that runs the
    Voting Application that we have implemented throughout this book. You will need
    an AKS Engine cluster for that purpose that has Linux nodes capable of handling
    more than 4 volume mounts per node—you can use the following cluster ApiModel: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter16/01_aks-engine-flux/kubernetes-windows-template.json](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter16/01_aks-engine-flux/kubernetes-windows-template.json).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 Flux 来管理运行我们在本书中实施的投票应用程序的集群。为此，您需要一个 AKS Engine 集群，该集群具有能够处理每个节点超过
    4 个卷挂载的 Linux 节点 - 您可以使用以下集群 ApiModel：[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter16/01_aks-engine-flux/kubernetes-windows-template.json](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter16/01_aks-engine-flux/kubernetes-windows-template.json)。
- en: Support for Helm 3 in Flux is currently in the development state. You can track
    progress here: [https://github.com/fluxcd/helm-operator/issues/8](https://github.com/fluxcd/helm-operator/issues/8).
    For this reason, we need to use custom images for Flux components, but by the
    time you read this, the support may already be in a stable state.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 中对 Helm 3 的支持目前处于开发状态。您可以在这里跟踪进展：[https://github.com/fluxcd/helm-operator/issues/8](https://github.com/fluxcd/helm-operator/issues/8)。因此，出于这个原因，我们需要为
    Flux 组件使用自定义镜像，但在您阅读本文时，支持可能已经处于稳定状态。
- en: 'First, let''s create our repository with the source of truth for the Kubernetes
    cluster. Please follow these steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建我们的仓库，作为 Kubernetes 集群的真相来源。请按照以下步骤操作：
- en: Create a new GitHub repository. We will be using [https://github.com/hands-on-kubernetes-on-windows/voting-application-flux](https://github.com/hands-on-kubernetes-on-windows/voting-application-flux)
    for demonstration purposes.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 GitHub 仓库。我们将使用 [https://github.com/hands-on-kubernetes-on-windows/voting-application-flux](https://github.com/hands-on-kubernetes-on-windows/voting-application-flux)
    进行演示。
- en: 'In the `charts/voting-application` directory, place the Voting Application
    Helm chart. You can find the latest one here (with a small workaround for the `post-install`
    hook and waiting not working correctly in this version of Flux): [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter16/02_voting-application-flux/charts/voting-application](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter16/02_voting-application-flux/charts/voting-application).'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`charts/voting-application`目录中，放置投票应用Helm图表。您可以在这里找到最新的版本（在此版本的Flux中，`post-install`钩子和等待功能不正确工作，需要进行小的变通）：[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter16/02_voting-application-flux/charts/voting-application](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter16/02_voting-application-flux/charts/voting-application)。
- en: 'In the `namespaces` directory, create the `demo.yaml` file with the namespace
    definition:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`namespaces`目录中，创建带有命名空间定义的`demo.yaml`文件：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `storageclasses` directory, create the `azure-disk.yaml` file with the
    `StorageClass` definition:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`storageclasses`目录中，创建带有`StorageClass`定义的`azure-disk.yaml`文件：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `releases` directory, create the `voting-application.yaml` file with the
    `HelmRelease` custom resource for our Voting Application. This custom resource
    is handled by the Flux Helm Operator:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`releases`目录中，创建`voting-application.yaml`文件，其中包含我们投票应用的`HelmRelease`自定义资源。这个自定义资源由Flux
    Helm Operator处理：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Push the changes to your GitHub repository.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更改推送到您的GitHub存储库。
- en: Flux does not follow any directory convention—it is up to you how you define
    the structure. All it does is search for YAML files in the repository.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Flux不遵循任何目录约定——如何定义结构取决于您。它所做的就是在存储库中搜索YAML文件。
- en: 'We have defined our repository with a source of truth. Now, let''s deploy Flux
    to our cluster, which is capable of handling Helm 3 charts. Execute the following
    steps (or you can use the PowerShell script: ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter16/03_DeployFlux.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter16/03_DeployFlux.ps1)):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了我们的存储库的真实来源。现在，让我们将Flux部署到我们的集群中，它能够处理Helm 3图表。执行以下步骤（或者您可以使用PowerShell脚本：([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter16/03_DeployFlux.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter16/03_DeployFlux.ps1)：
- en: Open a new PowerShell window as Administrator.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以管理员身份打开一个新的PowerShell窗口。
- en: 'Install `fluxctl` using Chocolatey:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Chocolatey安装`fluxctl`：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a dedicated `fluxcd` namespace for your Flux components:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Flux组件创建一个专用的`fluxcd`命名空间：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the Flux Helm repository:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Flux Helm存储库：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Install the Flux Helm chart. You need to ensure that all components have `nodeSelector`
    set to run on Linux nodes. Set the `git.url` value to your GitHub repository:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Flux Helm图表。您需要确保所有组件的`nodeSelector`设置为在Linux节点上运行。将`git.url`值设置为您的GitHub存储库：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Apply the official manifest for HelmRelease custom resource definition (here
    we use the development manifest from the `helm-v3-dev` branch):'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用HelmRelease自定义资源定义的官方清单（这里我们使用来自`helm-v3-dev`分支的开发清单）：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Install the Helm chart for the Flux Helm operator. This is a version of the
    operator that comes from the development branch with support for Helm 3\. Remember
    to ensure the Linux `nodeSelector`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Flux Helm操作员的Helm图表。这是来自开发分支的操作员版本，支持Helm 3。记得确保Linux的`nodeSelector`：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use `fluxctl` to retrieve the public SSH key that has to be added as a deploy
    key to your GitHub repository:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fluxctl`检索必须添加为部署密钥的公共SSH密钥：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Copy the key and open your GitHub repository in a web browser.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制密钥并在Web浏览器中打开您的GitHub存储库。
- en: Navigate to Settings and Deploy Keys.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到设置和部署密钥。
- en: Add your key with write access.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加具有写访问权限的密钥。
- en: 'Now, you can wait for a short while until the repository is automatically synchronized
    by Flux or force synchronization using this command:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以等待一小段时间，直到Flux自动同步存储库，或使用此命令强制同步：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Observe the creation of components using `kubectl get all -n demo`. You can
    also use the `kubectl logs` command to follow Helm operator logs, especially in
    the event of any problems with the process of installing the Helm release:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察使用`kubectl get all -n demo`命令创建组件。您还可以使用`kubectl logs`命令跟踪Helm操作员日志，特别是在安装Helm发布过程中出现任何问题时：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding steps, we used imperative commands, as in the official guides
    from Flux. You can, of course, use declarative manifests and YAML files with values
    for the Helm releases.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，我们使用了命令式命令，就像Flux的官方指南中一样。当然，您也可以使用声明性清单和带有Helm发布值的YAML文件。
- en: 'As you can see, the whole procedure is completely automatic. You define the
    state in the Git repository and Flux automatically takes care of applying the
    changes to the cluster. Now, let''s test how rolling out a change in the cluster
    state works. As an example, we will change the tag for the image that we use in
    the Voting Application, as if we were rolling out a new version of the application:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，整个过程是完全自动的。您在Git存储库中定义状态，Flux会自动处理将更改应用于集群。现在，让我们测试一下在集群状态中推出更改的工作原理。例如，我们将更改我们在Voting
    Application中使用的图像标记，就好像我们正在推出应用程序的新版本一样：
- en: In your repository with the cluster state, start editing `charts/voting-application/Chart.yaml`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的集群状态存储库中，开始编辑`charts/voting-application/Chart.yaml`。
- en: Change `version` to `0.4.1` to indicate that the chart version itself has changed.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`version`更改为`0.4.1`以指示图表版本本身已更改。
- en: Change `appVersion` to a different Voting Application image tag. We can use,
    for example, `1.5.0`, one of the previous versions.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`appVersion`更改为不同的Voting Application图像标记。例如，我们可以使用`1.5.0`中的一个先前版本。
- en: Save the changes, commit to the repository, and push to GitHub.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改，提交到存储库，并推送到GitHub。
- en: Wait for the changes to be synced automatically or force the sync using the `fluxctl
    sync --k8s-fwd-ns fluxcd` command.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待更改自动同步或使用`fluxctl sync --k8s-fwd-ns fluxcd`命令强制同步。
- en: 'Execute the `kubectl get pods -n demo` command to see that the resources are
    indeed recreating:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`kubectl get pods -n demo`命令以查看资源是否正在重新创建：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Describe one of the new pods to verify that it was created with the desired
    Docker image tag:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述其中一个新的pod以验证它是否使用了所需的Docker图像标记创建：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Congratulations! You have successfully set up a GitOps pipeline using Flux.
    In production, you can easily extend the pipeline by adding CI/CD components integrated
    with your Git repository, which will perform, for example,the validation of each
    pull request before it is merged to the cluster state repository. You can learn
    more about more complex pipelines in the following article: [https://www.weave.works/blog/what-is-gitops-really](https://www.weave.works/blog/what-is-gitops-really).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功使用Flux设置了GitOps管道。在生产环境中，您可以通过向您的Git存储库添加与CI/CD组件集成来轻松扩展管道，例如，在将每个拉取请求合并到集群状态存储库之前进行验证。您可以在以下文章中了解更复杂的管道：[https://www.weave.works/blog/what-is-gitops-really](https://www.weave.works/blog/what-is-gitops-really)。
- en: In the next section, we will take a look at kubeadm limitations for production
    use cases.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下kubeadm在生产用例中的限制。
- en: Kubeadm limitations
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubeadm限制
- en: Kubeadm ([https://github.com/kubernetes/kubeadm](https://github.com/kubernetes/kubeadm))
    is a command-line tool for provisioning Kubernetes clusters focused on performing
    actions necessary to get a minimum viable secure cluster up and running in a user-friendly
    way—we introduced this tool in [Chapter 4](118e3c89-786e-4718-ba67-6c38928e2a42.xhtml), *Kubernetes
    Concepts and Windows Support*, and later used it in [Chapter 7](165c2fcc-4ce8-4dbc-a19c-c7fd427b3379.xhtml), *Deploying
    Hybrid On-Premises Kubernetes Cluster*. This tool is scoped only to a given machine
    and Kubernetes API communication, so in general, it is intended to be a building
    block for other automation tools that manage the cluster as a whole. You will
    find that other complex automation tools such as kubespray are built on top of
    kubeadm.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Kubeadm（[https://github.com/kubernetes/kubeadm](https://github.com/kubernetes/kubeadm)）是一个命令行工具，用于提供Kubernetes集群，专注于以用户友好的方式执行必要的操作，使得最小可行的安全集群能够运行起来——我们在第4章《Kubernetes概念和Windows支持》中介绍了这个工具，并在第7章《部署混合本地Kubernetes集群》中使用了它。这个工具仅限于特定的机器和Kubernetes
    API通信，因此，它通常被设计为其他管理整个集群的自动化工具的构建块。你会发现，诸如kubespray之类的其他复杂自动化工具是建立在kubeadm之上的。
- en: 'Starting with Kubernetes 1.13, kubeadm is considered stable and ready for production
    use. But even though its current core feature set is in a stable state, you should
    take into account several limitations that may not make kubeadm the right tool
    for your production Kubernetes Deployment:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从Kubernetes 1.13开始，kubeadm被认为是稳定的，并且可以用于生产环境。但即使当前的核心功能集是稳定的，你也应该考虑一些限制，这些限制可能使kubeadm不适合你的生产Kubernetes部署：
- en: kubeadm has only initial support for Windows nodes and the API regarding this
    support is likely to change. This makes production Deployments of hybrid clusters
    a hard task—the only alternative at this point is manually configuring Kubernetes
    components on Windows nodes and joining them to an existing Linux cluster. Of
    course, if you are running on Azure you can use AKS or AKS Engine to run Windows
    container workloads in production.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubeadm对Windows节点仅有初始支持，并且关于此支持的API可能会发生变化。这使得混合集群的生产部署变得困难——目前唯一的选择是在Windows节点上手动配置Kubernetes组件，并将它们加入到现有的Linux集群中。当然，如果你在Azure上运行，你可以使用AKS或AKS
    Engine在生产环境中运行Windows容器工作负载。
- en: A highly available Kubernetes cluster setup (with stacked and internal etcd
    topology) is now possible with kubeadm but is still relatively complex. You can
    read more in the official documentation: [https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/).
    Additionally, there is no easy way to manage the etcd cluster afterward using
    kubeadm, which means that solutions such as kubespray give more flexibility. But
    of course, this comes at the cost of no support for Windows at this point.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用kubeadm现在可以实现高可用的Kubernetes集群设置（具有堆叠和内部etcd拓扑），但仍然相对复杂。你可以在官方文档中阅读更多信息：[https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/)。此外，目前没有简单的方法使用kubeadm之后管理etcd集群，这意味着诸如kubespray之类的解决方案提供了更多的灵活性。但当然，这是以目前不支持Windows为代价的。
- en: kubeadm cannot be used for joining new nodes to existing clusters that have
    been bootstrapped without kubeadm.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubeadm不能用于加入新节点到已经在没有kubeadm的情况下引导的现有集群中。
- en: In general, for hybrid Windows/Linux Kubernetes clusters there is no perfect
    way for provisioning production-ready clusters if you cannot use AKS or AKS Engine.
    Using kubeadm is still the only semi-automated way to set up such clusters.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，对于混合Windows/Linux Kubernetes集群，如果不能使用AKS或AKS Engine，那么没有完美的方式来提供生产就绪的集群。使用kubeadm仍然是设置这种集群的唯一半自动化方式。
- en: Now, let's take a look at how you can upgrade your Kubernetes cluster to a newer
    version.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何将您的Kubernetes集群升级到更新的版本。
- en: Upgrading clusters
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级集群
- en: 'Running a Kubernetes cluster in production will definitely require upgrading
    the Kubernetes components to newer versions at some point. How you perform the
    upgrade itself depends on the tools that you use to bootstrap and manage the cluster.
    But in general, the high-level procedure looks as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中运行Kubernetes集群肯定需要在某个时候将Kubernetes组件升级到更新的版本。您执行升级的方式取决于您用于引导和管理集群的工具。但总的来说，高层次的过程如下：
- en: Upgrade the components running on the primary master node.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 升级主节点上运行的组件。
- en: Upgrade the components running on the additional master nodes.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 升级额外的主节点上运行的组件。
- en: Upgrade the worker nodes.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 升级工作节点。
- en: 'There is an important rule that you have to follow to ensure safe upgrades:
    you can only upgrade the cluster  by one minor version at once. It means that,
    for example, a cluster that has version 1.16 can be only upgraded to 1.17—you
    cannot make a jump straight to 1.18\. The reason for this is the version skew
    policy for Kubernetes master components, which allows running one minor version
    difference at most only. The expected cadence for releases of minor versions of
    Kubernetes is three months, which means that you may need to run the upgrade procedure
    quite often, especially considering that each minor version will be maintained
    for approximately nine months. You can read about the policies for all components
    in the official documentation: [https://kubernetes.io/docs/setup/release/version-skew-policy/](https://kubernetes.io/docs/setup/release/version-skew-policy/).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的规则，您必须遵循以确保安全升级：您只能一次升级集群一个次要版本。这意味着，例如，版本为1.16的集群只能升级到1.17，您不能直接跳到1.18。这是因为Kubernetes主组件的版本差异策略，最多只允许运行一个次要版本的差异。Kubernetes次要版本发布的预期节奏是三个月一次，这意味着您可能需要经常运行升级过程，特别是考虑到每个次要版本将维护大约九个月。您可以在官方文档中阅读所有组件的政策：[https://kubernetes.io/docs/setup/release/version-skew-policy/](https://kubernetes.io/docs/setup/release/version-skew-policy/)。
- en: 'Depending on how you bootstrapped the cluster, the exact upgrade steps will
    be different. For example, for kubeadm clusters, the upgrade will be performed in
    place, on the same machines. But if you use AKS or AKS Engine, the procedure will
    be compliant with *immutable infrastructure* paradigm: master and worker VMs will
    be sequentially replaced with VMs running a newer version of Kubernetes components.
    In more detail, for master nodes, the automated upgrade procedure looks as follows
    under the hood:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 根据集群的引导方式，确切的升级步骤会有所不同。例如，对于kubeadm集群，升级将在同一台机器上进行。但是，如果您使用的是AKS或AKS Engine，该过程将符合*不可变基础设施*范式：主节点和工作节点将依次替换为运行较新版本Kubernetes组件的虚拟机。更详细地说，对于主节点，自动升级过程如下：
- en: '`Cordon` (mark the node as unschedulable) one of the master nodes and drain
    the existing pods.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将节点标记为不可调度，并排空现有的Pod。
- en: Delete the physical VM. Now, the size of the control plane is `N-1` nodes.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除物理虚拟机。现在，控制平面的大小为`N-1`个节点。
- en: Create a new VM with the new version of Kubernetes components.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的虚拟机，安装新版本的Kubernetes组件。
- en: Add the new VM to the cluster and apply any existing labels, annotations, or
    taints for the node. Now, the size of the data plane is again `N`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的虚拟机添加到集群，并应用任何现有的标签、注释或节点污点。现在，数据平面的大小再次为`N`。
- en: 'For worker nodes, the procedure is similar and has the following steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工作节点，该过程类似，并包括以下步骤：
- en: Create a new VM with the new version of Kubernetes components.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的虚拟机，安装新版本的Kubernetes组件。
- en: Add the new VM to the cluster. Now, the size of the data plane is `M+1`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的 VM 添加到集群中。现在，数据平面的大小为 `M+1`。
- en: If any pods have already been scheduled to the new node, evict them.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已经有任何 pod 被调度到新节点上，请将它们驱逐出去。
- en: Apply any existing labels, annotations, or taints to the new node.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任何现有的标签、注释或污点应用到新节点上。
- en: '`Cordon` the old node and drain the existing pods.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Cordon` 旧节点并排空现有的 pod。'
- en: Delete the old VM. Now, the size of the data plane is again `M`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除旧的 VM。现在，数据平面的大小再次为 `M`。
- en: 'The reason why worker nodes are upgraded by adding an extra node (instead of
    removing the existing node first) is to ensure that the cluster capacity for data
    plane workloads does not shrink. This ensures that the upgrade is entirely transparent
    for the users. You can read more about upgrade procedures for AKS at: [https://docs.microsoft.com/en-us/azure/aks/upgrade-cluster](https://docs.microsoft.com/en-us/azure/aks/upgrade-cluster)
    and for AKS Engine at: [https://github.com/Azure/aks-engine/blob/master/docs/topics/upgrade.md](https://github.com/Azure/aks-engine/blob/master/docs/topics/upgrade.md).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将工作节点升级为添加额外的节点（而不是首先删除现有节点）的原因是为了确保数据平面工作负载的集群容量不会缩小。这确保了升级对用户来说是完全透明的。您可以在以下链接中阅读有关
    AKS 升级程序的更多信息：[https://docs.microsoft.com/en-us/azure/aks/upgrade-cluster](https://docs.microsoft.com/en-us/azure/aks/upgrade-cluster)，以及有关
    AKS Engine 的信息：[https://github.com/Azure/aks-engine/blob/master/docs/topics/upgrade.md](https://github.com/Azure/aks-engine/blob/master/docs/topics/upgrade.md)。
- en: You can use the *immutable infrastructure* approach for upgrades used in AKS
    and AKS Engine to perform manual upgrades of clusters bootstrapped using different
    tools, as long as the toolset allows adding new master and worker nodes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 AKS 和 AKS Engine 中使用的 *不可变基础设施* 方法进行升级，以执行使用不同工具引导的集群的手动升级，只要工具集允许添加新的主节点和工作节点。
- en: 'Let''s now perform an upgrade of a Kubernetes cluster (with Windows nodes)
    that has been created using AKS Engine. For this demonstration, we are running
    a cluster with version 1.16.1, which we have created in the previous sections.
    You will need the cluster ApiModel, which you used for the initial Deployment.
    To perform the upgrade, please follow these steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们执行一个使用 AKS Engine 创建的 Kubernetes 集群（带有 Windows 节点）的升级。在本演示中，我们运行的是一个版本为
    1.16.1 的集群，这是我们在之前章节中创建的。您将需要集群 ApiModel，这是您用于初始部署的。要执行升级，请按照以下步骤进行：
- en: 'Open a PowerShell window. Determine what the available Kubernetes versions
    are that you can use for upgrading your AKS Engine cluster with Windows nodes.
    Run the following command:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 PowerShell 窗口。确定可用的 Kubernetes 版本，用于升级带有 Windows 节点的 AKS Engine 集群。运行以下命令：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s upgrade the cluster to the latest version, `1.17.0-beta.1`. If you do
    not have your AKS Engine Service Principal, you have to generate a new one because
    it is not possible to retrieve the password of an existing one. To do that, use
    the following command:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将集群升级到最新版本 `1.17.0-beta.1`。如果您没有 AKS Engine 服务主体，您必须生成一个新的，因为不可能检索现有主体的密码。要执行此操作，请使用以下命令：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Take note of `appId` and `password` to use it during the upgrade command.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `appId` 和 `password`，在升级命令中会用到它们。
- en: 'Execute the following command to perform the upgrade. You have to specify the generated
    cluster ApiModel:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令进行升级。您必须指定生成的集群 ApiModel：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The upgrade can take around 50 minutes (10 minutes per node), depending on
    the size of your cluster. If you are using a single-node control plane in your
    cluster, you won''t be able to access the Kubernetes API during the upgrade for
    some time. When the upgrade is finished, run the following command to verify that
    the nodes are running the desired version of Kubernetes:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 升级可能需要大约50分钟（每个节点10分钟），具体取决于您的集群大小。如果您的集群中使用单节点控制平面，则在升级期间将无法访问Kubernetes API一段时间。升级完成后，运行以下命令验证节点是否运行所需版本的Kubernetes。
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In production clusters, especially if you are running a customized cluster with
    extensions or dedicated VM images, it is recommended to test the upgrade in a
    separate staging cluster that was created using exactly the same specification.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产集群中，特别是如果您正在运行带有扩展或专用VM镜像的定制集群，则建议在使用完全相同规范创建的单独的分段集群中测试升级。
- en: Congratulations, you have successfully upgraded your AKS Engine cluster to version
    `1.17.0-beta.1`. In the next section, you will learn how to approach operating
    system patching in Kubernetes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您已成功将AKS Engine集群升级到版本`1.17.0-beta.1`。在下一节中，您将学习如何在Kubernetes中进行操作系统打补丁。
- en: OS patching
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OS打补丁
- en: 'To ensure the best security of your cluster and the underlying infrastructure,
    you must ensure that you are running an operating system with the latest patches
    on your nodes. Fortunately, Kubernetes is flexible when it comes to the maintenance
    of nodes. The general approach for any maintenance, including applying OS patches
    that require reboot, is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保集群和基础设施的最佳安全性，您必须确保在节点上运行具有最新补丁的操作系统。幸运的是，Kubernetes在节点维护方面非常灵活。任何维护的一般方法，包括需要重新启动的OS补丁，如下所示：
- en: '`Cordon` (mark the node as unschedulable) the node and drain the existing pods.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Cordon`（标记节点为不可调度）节点并排空现有的pod。'
- en: Apply the required updates and reboot the machine.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用所需的更新并重新启动机器。
- en: '`Uncordon` the node to make it schedulable again.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Uncordon`节点以使其再次可调度。'
- en: 'Alternatively, if you use an *immutable infrastructure* approach, the preceding
    steps have to be extended by the creation of a new patched machine and the deletion
    of the old machine. For example, in AKS Engine, this scenario could look as follows,
    providing that you use Virtual Machine Scale Sets (VMSS) with a custom VM image
    for your node pools:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您使用*不可变基础设施*方法，则必须通过创建新的打补丁机器并删除旧机器来扩展前面的步骤。例如，在AKS Engine中，如果您在节点池中使用自定义VM镜像，则此场景可能如下所示：
- en: Build a new version of the VM image.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建新版本的VM镜像。
- en: Update the VM image for your VMSS ([https://docs.microsoft.com/en-us/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-upgrade-scale-set#update-the-os-image-for-your-scale-set](https://docs.microsoft.com/en-us/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-upgrade-scale-set#update-the-os-image-for-your-scale-set)),
    possibly directly in the ARM template.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新VMSS的VM镜像（https://docs.microsoft.com/en-us/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-upgrade-scale-set#update-the-os-image-for-your-scale-set），可能直接在ARM模板中进行。
- en: 'For each VM in the VMSS, sequentially perform the following: `cordon` and drain
    the node, set the VM image to the latest version for the VMSS instance, and `uncordon`
    the node.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于VMSS中的每个VM，依次执行以下操作：`cordon`和排空节点，将VM镜像设置为VMSS实例的最新版本，并`uncordon`节点。
- en: If you are interested in creating your own custom VM images for AKS Engine Windows
    nodes, you can read the following description of the build process, which uses
    Packer and Azure DevOps: [https://github.com/Azure/aks-engine/blob/master/docs/topics/windows-vhd.md](https://github.com/Azure/aks-engine/blob/master/docs/topics/windows-vhd.md).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣为AKS Engine Windows节点创建自定义VM映像，您可以阅读以下构建过程的描述，该过程使用Packer和Azure DevOps：[https://github.com/Azure/aks-engine/blob/master/docs/topics/windows-vhd.md](https://github.com/Azure/aks-engine/blob/master/docs/topics/windows-vhd.md)。
- en: 'To exercise the manual procedure of maintenance for Windows nodes, please perform
    the following steps:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了维护Windows节点的手动程序，请执行以下步骤：
- en: Let's assume that we would like to patch the `1754k8s010` Windows node.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们想要打补丁`1754k8s010` Windows节点。
- en: 'Use the name to get the private IP address of the `1754k8s010` node:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用名称获取`1754k8s010`节点的私有IP地址：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use one of the private IPs to create an SSH tunnel from your local `5500` port
    via the master node to port `3389` (RDP) on the Windows node:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用其中一个私有IP从本地`5500`端口通过主节点到Windows节点上的端口`3389`（RDP）创建SSH隧道：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In a different PowerShell window, start the RDP session via the tunnel:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个PowerShell窗口中，通过隧道启动RDP会话：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Provide your Windows node credentials (as in ApiModel) and connect.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供您的Windows节点凭据（如ApiModel）并连接。
- en: Wait for the console to initialize.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待控制台初始化。
- en: 'Now, you are ready to perform the maintenance, but first, we need to drain
    the node (which also `cordons` the node first). In a new PowerShell window on
    your local machine, execute this command:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您已经准备好进行维护，但首先，我们需要排空节点（这也会首先使节点“cordons”）。在本地计算机上的新的PowerShell窗口中，执行以下命令：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the node is drained, you can start your maintenance procedure. For example,
    you can use the `sconfig.cmd` utility in the console to apply the updates manually:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当节点被排空时，您可以开始维护程序。例如，您可以使用控制台中的`sconfig.cmd`实用程序手动应用更新：
- en: '![](assets/f7f45280-f41d-4029-92d1-c21dc0d7e75d.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f7f45280-f41d-4029-92d1-c21dc0d7e75d.png)'
- en: 'Select option `6` and choose which updates you want to install:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择选项`6`并选择要安装的更新：
- en: '![](assets/85db4f35-ad84-4c6b-a407-d5d69e79f922.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/85db4f35-ad84-4c6b-a407-d5d69e79f922.png)'
- en: Wait for the installation to end and reboot the machine if needed.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待安装结束并重新启动机器（如果需要）。
- en: 'When the node is fully rebooted, you can `uncordon` the node to make it schedulable
    again:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当节点完全重新启动后，您可以`uncordon`节点以使其再次可调度：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Your node will be now fully functional in the cluster again.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您的节点现在将在集群中再次完全正常运行。
- en: Alternatively, you may consider using Azure Update Management to manage operating
    system updates and patching in your cluster. You can read more in the official
    documentation: [https://docs.microsoft.com/en-us/azure/automation/automation-update-management](https://docs.microsoft.com/en-us/azure/automation/automation-update-management).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以考虑使用Azure Update Management来管理集群中操作系统的更新和打补丁。您可以在官方文档中阅读更多信息：[https://docs.microsoft.com/en-us/azure/automation/automation-update-management](https://docs.microsoft.com/en-us/azure/automation/automation-update-management)。
- en: In the last section, we will show which components in Kubernetes require additional
    configuration if you are running your production cluster behind an HTTP(S) network
    proxy.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们将展示在Kubernetes中哪些组件需要额外配置，如果您的生产集群在HTTP(S)网络代理后运行。
- en: Configuring a network proxy for the Docker daemon and Kubernetes
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Docker守护程序和Kubernetes配置网络代理
- en: In enterprise environments, it is a common practice to use HTTP(S) network proxies
    for connections to external networks and especially the internet. This comes at
    an additional configuration cost of all components that are running behind a proxy—we
    are going to give a brief overview of what components in Kubernetes you need to
    make the proxy aware to use Docker images from external registries and propagate
    the proxy settings to the containers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业环境中，使用HTTP(S)网络代理连接到外部网络，特别是互联网，是一种常见做法。这需要对所有运行在代理后面的组件进行额外的配置成本-我们将简要概述Kubernetes中需要使代理意识到使用外部注册表的Docker镜像并将代理设置传播到容器的组件。
- en: 'Let''s assume that our proxy addresses are as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的代理地址如下：
- en: '`http://proxy.example.com:8080/` for HTTP proxy'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://proxy.example.com:8080/` 用于HTTP代理'
- en: '`http://proxy.example.com:9090/` for HTTPS proxy'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://proxy.example.com:9090/` 用于HTTPS代理'
- en: 'Configuration for other standard proxies, such as SFTP, can be done similarly.
    You may also need appropriate no-proxy variables to exclude the Kubernetes nodes
    and local network, otherwise, you will be not able to communicate between the
    nodes or the traffic to nodes, will be additionally routed through the proxy!
    Now, for Linux nodes and masters (assuming a Debian-based distribution, such as
    Ubuntu), you will need to ensure that the following settings are configured:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 其他标准代理的配置，例如SFTP，可以类似地完成。您可能还需要适当的no-proxy变量来排除Kubernetes节点和本地网络，否则，您将无法在节点之间通信，或者流量将通过代理额外路由！现在，对于Linux节点和主节点（假设是基于Debian的发行版，如Ubuntu），您需要确保配置以下设置：
- en: 'Define proxy settings for the default environment, `/etc/environment`. This
    will make tools such as APT honor the proxy settings:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为默认环境`/etc/environment`定义代理设置。这将使APT等工具遵守代理设置：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Proxies are set for the Docker daemon environment. This will ensure that the
    containers receive the proxy variables as well. You can define the `/etc/systemd/system/docker.service.d/http-proxy.conf`
    file with the following contents:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Docker守护程序环境设置代理。这将确保容器也接收代理变量。您可以使用以下内容定义`/etc/systemd/system/docker.service.d/http-proxy.conf`文件：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For building Docker images on machines behind a proxy, consider passing the
    proxy settings as arguments:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代理后面的机器上构建Docker镜像时，考虑将代理设置作为参数传递：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For your Windows worker nodes, you can take the following steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows工作节点，您可以采取以下步骤：
- en: 'Define global environment variables from PowerShell as an Administrator:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以管理员身份从PowerShell定义全局环境变量：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Additionally, ensure that any traffic that uses a web browser engine also respects
    the proxy settings:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外，确保使用Web浏览器引擎的任何流量也遵守代理设置：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These configuration steps should let you pull Docker images, bootstrap the cluster,
    and later make pod containers aware of these settings when connecting to an external
    network.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置步骤应该让您拉取Docker镜像，引导集群，并在连接到外部网络时使pod容器意识到这些设置。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we focused on common operational best practices for Kubernetes
    clusters running in production. First, we covered the approaches for provisioning
    infrastructure for Kubernetes and deploying the clusters reproducibly—we introduced
    the concepts of *infrastructure as code* and *immutable infrastructure* and have
    showed how they fit into the Kubernetes landscape. Additionally, we provided a
    recommendation on the best tools for provisioning infrastructure and cluster Deployments.
    Next, you learned what GitOps is and how to apply this philosophy using Flux and
    Git repositories. We focused on the operational aspects of upgrades and the patching
    of both the underlying cluster infrastructure and Kubernetes itself. And lastly,
    you learned how to ensure that your Kubernetes cluster can run behind HTTP(S)
    network proxies in enterprise environments.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们重点介绍了在生产环境中运行Kubernetes集群的常见操作最佳实践。首先，我们介绍了为Kubernetes提供基础设施和可重复部署集群的方法-我们介绍了*基础设施即代码*和*不可变基础设施*的概念，并展示了它们如何适用于Kubernetes领域。此外，我们提供了有关为基础设施和集群部署提供最佳工具的建议。接下来，您将了解GitOps是什么，以及如何使用Flux和Git存储库应用这一理念。我们重点关注了升级和修补底层集群基础设施和Kubernetes本身的操作方面。最后，您将学习如何确保您的Kubernetes集群可以在企业环境中在HTTP(S)网络代理后运行。
- en: Congratulations! This has been a long journey into the (almost) *uncharted territory*
    of Kubernetes on Windows—good luck with your further Kubernetes journey and thanks
    for reading.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！这是一个漫长的旅程，进入（几乎）未知的Windows Kubernetes领域-祝您在进一步的Kubernetes旅程中好运，并感谢您的阅读。
- en: Questions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between *infrastructure as code* and *immutable infrastructure*?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*基础设施即代码*和*不可变基础设施*之间有什么区别？'
- en: Why is Kubernetes considered to be a platform that uses the *infrastructure
    as code* approach?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么Kubernetes被认为是使用*基础设施即代码*方法的平台？
- en: What is GitOps?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是GitOps？
- en: What are the benefits of using Flux in your Kubernetes clusters?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Kubernetes集群中使用Flux的好处是什么？
- en: What are the steps during the upgrade of a Kubernetes cluster version?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 升级Kubernetes集群版本的步骤是什么？
- en: What is the procedure for performing maintenance on a Kubernetes node?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对Kubernetes节点执行维护的程序是什么？
- en: You can find answers to these questions in *Assessments* of this book.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的*评估*中找到这些问题的答案。
- en: Further reading
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about Kubernetes features and running the cluster in production,
    please refer to the following Packt books:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Kubernetes功能和在生产环境中运行集群的更多信息，请参考以下Packt图书：
- en: '*The Complete Kubernetes Guide* ([https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide))'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完整的Kubernetes指南*（[https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide)）'
- en: '*Getting Started with Kubernetes - Third Edition* ([https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition))'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始使用Kubernetes-第三版*（[https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition)）'
- en: 'If you are interested in exploring *infrastructure as code* concepts, you can
    check out the following Packt book:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您有兴趣探索*基础设施即代码*概念，您可以查看以下Packt图书：
- en: '*Infrastructure as Code (IaC) Cookbook* ([https://www.packtpub.com/virtualization-and-cloud/infrastructure-code-iac-cookbook](https://www.packtpub.com/virtualization-and-cloud/infrastructure-code-iac-cookbook))'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基础设施即代码（IaC）食谱*（[https://www.packtpub.com/virtualization-and-cloud/infrastructure-code-iac-cookbook](https://www.packtpub.com/virtualization-and-cloud/infrastructure-code-iac-cookbook)）'
- en: The Kubernetes documentation offers some more best practices for running clusters: [https://kubernetes.io/docs/setup/best-practices/](https://kubernetes.io/docs/setup/best-practices/).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes文档提供了一些更多关于运行集群的最佳实践：[https://kubernetes.io/docs/setup/best-practices/](https://kubernetes.io/docs/setup/best-practices/)。
