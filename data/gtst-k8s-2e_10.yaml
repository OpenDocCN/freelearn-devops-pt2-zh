- en: Container Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器安全
- en: This chapter will discuss the basics of container security from the container
    runtime level to the host itself. We will discuss how to apply these concepts
    to workloads running in a Kubernetes cluster and some of the security concerns
    and practices that relate specifically to running your Kubernetes cluster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从容器运行时级别到主机本身讨论容器安全的基础知识。我们将讨论如何将这些概念应用于在 Kubernetes 集群中运行的工作负载，并讨论一些与运行您的
    Kubernetes 集群特定相关的安全关注点和实践。
- en: 'This chapter will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论以下主题：
- en: Basic container security
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本容器安全
- en: Container image security and continuous vulnerability scanning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像安全和持续性漏洞扫描
- en: Kubernetes cluster security
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 集群安全
- en: Kubernetes secrets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 秘密
- en: Basics of container security
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器安全基础
- en: Container security is a deep subject area and in itself can fill its own book.
    Having said this, we will cover some of the high-level concerns and give a starting
    point to think about this area.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 容器安全是一个深入的主题领域，本身就可以填满一本书。话虽如此，我们将涵盖一些高级别的关注点，并为思考这一领域提供一个起点。
- en: In the *A brief overview of containers* section of [Chapter 1](772262b1-5b78-4a9b-bbb4-09c6fd858fdf.xhtml)*,
    Introduction to Kubernetes*, we looked at some of the core isolation features
    in the Linux kernel that enable container technology. Understanding the details
    of how containers work is the key to grasping the various security concerns in
    managing them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](772262b1-5b78-4a9b-bbb4-09c6fd858fdf.xhtml)* Kubernetes 介绍 * 的 * 容器简介
    * 部分，我们看到了 Linux 内核中支持容器技术的一些核心隔离特性。理解容器工作原理的细节是理解管理它们中的各种安全问题的关键。
- en: A good paper to dive deeper is *NCC's Whitepaper*, *Understanding and Hardening
    Linux Containers *(you can refer to more details about this in point 1 in the
    *References* section at the end of the chapter). In *section 7*, the paper explores
    the various attack vectors of concern for container deployments, which I will
    summarize (you can refer to more details about this in point 1 in the *References*
    section at the end of the chapter).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 深入研究的好文章是 *NCC 的白皮书*，*理解和加固 Linux 容器*（您可以在本章末尾的*参考文献*部分的第 1 点中查看更多详细信息）。在 *第
    7 节* 中，该论文探讨了容器部署中涉及的各种攻击向量，我将总结（您可以在本章末尾的*参考文献*部分的第 1 点中查看更多详细信息）。
- en: Keeping containers contained
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持容器受限
- en: One of the most obvious features discussed in the paper is that of escaping
    the isolation/virtualization of the container construct. Modern container implementations
    guard against this using namespaces to isolate processes as well as allowing control
    of the Linux capabilities available to a container. Additionally, there is an
    increased move towards secure default configurations of the out-of-the-box container
    environment. For example, Docker by default only enables a small set of capabilities
    (you can refer to more details about this in point 2 in the *References* section
    at the end of the chapter). Networking is another avenue of escape and it can
    be challenging since there are a variety of network options that plug in to most
    modern container setups.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 论文中讨论的最明显的特征之一是逃避容器结构的孤立/虚拟化。现代容器实现使用命名空间来隔离进程，并允许控制容器可用的 Linux 权限。此外，越来越多地采用安全的默认配置来配置容器环境。例如，默认情况下，Docker
    仅启用了一小部分权限（您可以在本章末尾的*参考文献*部分的第 2 点中查看更多详细信息）。网络是另一个逃逸的途径，由于现代容器设置中插入了各种网络选项，这可能是具有挑战性的。
- en: The next area discussed in the paper is that of attacks between two containers.
    The *User* namespace model gives us added protection here by mapping the root
    user within the container to a lower level user on the host machine. Networking
    is of course still an issue and something that requires proper diligence and attention
    when selecting and implementing your container networking solution.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 论文中讨论的下一个领域是两个容器之间的攻击。*用户*命名空间模型在这里为我们提供了额外的保护，通过将容器内的 root 用户映射到主机上的较低级别用户。网络当然仍然是一个问题，需要在选择和实施容器网络解决方案时进行适当的勤勉和关注。
- en: Attacks within the container itself are another vector and as with previous
    concerns, namespaces and networking are key to protection here. Another aspect
    that is vital in this scenario is the application security itself. The code still
    needs to follow secure coding practices and the software should be kept up-to-date
    and patched regularly. Finally, the efficiency of container images has an added
    benefit of shrinking the attack surface. The images should be built with only
    the packages and software necessary.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 容器内部的攻击是另一个向量，与之前的担忧一样，命名空间和网络对于保护至关重要。在这种情况下至关重要的另一个方面是应用程序本身的安全性。代码仍然需要遵循安全编码实践，并且软件应该定期更新和打补丁。最后，容器镜像的效率具有缩小攻击面的附加好处。镜像应该只包含必需的软件包和软件。
- en: Resource exhaustion and orchestration security
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源耗尽和编排安全性
- en: Similar to the Denial of Service attacks, we've seen in various other areas
    of computing that resource exhaustion is very much a pertinent concern in the
    container world. While cgroups provide some limitations on resource usage for
    things such as CPU, memory, and disk usage, there are still valid attack avenues
    for resource exhaustion. Tools such as Docker offer some starting defaults to
    the cgroups limitations, and Kubernetes also offers additional limits that can
    be placed on groups of containers running in the cluster. It's important to understand
    these defaults and adjust for your deployments.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与拒绝服务攻击类似，在计算的各个其他领域中，资源耗尽在容器世界中非常相关。虽然 cgroups 对 CPU、内存和磁盘使用等资源使用提供了一些限制，但仍然存在有效的资源耗尽攻击途径。诸如
    Docker 等工具为 cgroups 的限制提供了一些起始默认值，Kubernetes 还提供了可以放置在集群中运行的容器组的额外限制。了解这些默认值并为您的部署进行调整至关重要。
- en: While the Linux kernel and the features that enable containers give us some
    form of isolation, they are fairly new to the Linux operating system. As such,
    they still contain their own bugs and vulnerabilities. The built-in mechanisms
    for capabilities and namespaces can and do have issues and it is important to
    track these as part of your secure container operations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Linux 内核和启用容器的功能给我们提供了一定形式的隔离，但它们对于 Linux 操作系统来说还是相当新的。因此，它们仍然包含自己的错误和漏洞。用于能力和命名空间的内置机制可能会存在问题，跟踪这些问题作为安全容器操作的一部分是很重要的。
- en: The final area covered in the NCC paper is the attack of the container management
    layer itself. The Docker engine, image repositories, and orchestration tools are
    all significant vectors of attack and should be considered when developing your
    strategy. We'll look more in depth at how we can address the repositories and
    Kubernetes as an orchestration layer in the next sections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: NCC 论文涵盖的最后一个领域是容器管理层本身的攻击。Docker 引擎、镜像仓库和编排工具都是重要的攻击向量，应在制定策略时予以考虑。我们将在接下来的章节更深入地研究如何解决镜像仓库和作为编排层的
    Kubernetes。
- en: 'If you''re interested in knowing more about the specific security features
    of Docker''s implementation, take a look here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 Docker 实现的特定安全功能感兴趣，请查看这里：
- en: '[https://docs.docker.com/engine/security/security/](https://docs.docker.com/engine/security/security/).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/engine/security/security/](https://docs.docker.com/engine/security/security/).'
- en: Image repositories
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜像仓库
- en: Vulnerability management is a critical component of any modern day IT operation.
    Zero-day vulnerabilities are on the rise and even those vulnerabilities with patches
    can be cumbersome to remediate. First, application owners must be made aware of
    their vulnerabilities and potential patches. Then these patches must be integrated
    into systems and code and often this requires additional deployments or maintenance
    windows. Even when there is visibility to vulnerabilities, there is often a lag
    in remediation, often taking large organizations several months to patch.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞管理是现代 IT 运营的关键组成部分。零日漏洞正在增加，即使是有补丁的漏洞也可能很难修复。首先，应用程序所有者必须了解其漏洞和潜在补丁。然后，这些补丁必须集成到系统和代码中，通常需要额外的部署或维护窗口。即使对漏洞有所了解，修复也经常有延迟，通常需要大型组织数月时间才能打补丁。
- en: While containers greatly improve the process of updating applications and minimizing
    downtime, there still remains a challenge inherent in vulnerability management.
    Especially since an attacker only needs to expose one such vulnerability; making
    anything less than 100% of systems patched is a risk for compromise.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然容器极大地改进了更新应用程序和最小化停机时间的过程，但漏洞管理中仍然存在挑战。特别是因为攻击者只需暴露一个这样的漏洞；任何少于 100% 的系统都未打补丁都存在被攻击的风险。
- en: What's needed is a faster feedback loop in addressing vulnerabilities. Continuous
    scanning and tying into the software deployment life cycle is key to speeding
    the information and remediation of vulnerabilities. Luckily, this is exactly the
    approach being built into the latest container management and security tooling.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的是更快的反馈循环来解决漏洞。持续扫描并与软件部署生命周期结合是加速漏洞信息和修复的关键。幸运的是，这正是最新容器管理和安全工具正在构建的方法。
- en: Continuous vulnerability scanning
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续漏洞扫描
- en: 'One such open-source project that has emerged in this space is **Clair**. We
    get to know this from the *Clair* GitHub page: <q>Clair is an open source project
    for the static analysis of vulnerabilities in [appc](https://github.com/appc/spec)
    and [docker](https://github.com/docker/docker/blob/master/image/spec/v1.md) containers</q>.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个领域出现了一个开源项目 **Clair**。我们从 *Clair* GitHub 页面了解到：<q>Clair 是一个用于对 [appc](https://github.com/appc/spec)
    和 [docker](https://github.com/docker/docker/blob/master/image/spec/v1.md) 容器进行静态分析漏洞的开源项目</q>。
- en: 'You can visit Clair at the following link:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接访问 Clair：
- en: '[https://github.com/coreos/clair](https://github.com/coreos/clair).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/coreos/clair](https://github.com/coreos/clair)。'
- en: Clair scans your code against **Common Vulnerabilities and Exploits** (**CVEs**).
    It can be integrated into your CI/CD pipeline and run as a response to new builds.
    If vulnerabilities are found, they can be taken as feedback into the pipeline,
    even stop deployment, and fail the build. This forces developers to be aware of
    and remediate vulnerabilities during their normal release process.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Clair 会针对 **公共漏洞和利用** (**CVEs**) 扫描您的代码。它可以集成到您的 CI/CD 流水线中，并在新构建的响应中运行。如果发现漏洞，它们可以作为反馈进入流水线，甚至停止部署并失败构建。这迫使开发人员在其正常发布过程中意识到并纠正漏洞。
- en: Clair can be integrated with a number of container image repositories and CI/CD
    pipelines.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Clair 可以与多个容器镜像仓库和 CI/CD 流水线集成。
- en: Clair can even be deployed on Kubernetes: [https://github.com/coreos/clair#kubernetes](https://github.com/coreos/clair#kubernetes).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Clair 甚至可以部署在 Kubernetes 上：[https://github.com/coreos/clair#kubernetes](https://github.com/coreos/clair#kubernetes)。
- en: 'Clair is also used as the scanning mechanism in CoreOS''s Quay image repository.
    Quay offers a number of enterprise features including continuous vulnerability
    scanning:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Clair 也被用作 CoreOS 的 Quay 镜像仓库中的扫描机制。Quay 提供了许多企业功能，包括持续漏洞扫
- en: '[https://quay.io/](https://quay.io/)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://quay.io/](https://quay.io/)'
- en: Both Docker Hub and Docker Cloud support security scanning. Again, containers
    that are pushed to the repository are automatically scanned against CVEs and notifications
    of vulnerabilities are sent as a result of any findings. Additionally, binary
    analysis of the code is performed to match the signature of the components with
    that of known versions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub 和 Docker Cloud 都支持安全扫描。再次强调，推送到仓库的容器会自动针对 CVE 进行扫描，并根据任何发现发送漏洞通知。此外，还会对代码进行二进制分析，以与已知版本的组件签名进行匹配。
- en: There are a variety of other scanning tools that can be used as well for scanning
    your image repositories including **OpenSCAP** as well as **Twistlock** and **AquaSec**,
    which we will cover in [Chapter 12](0ebbb579-01ba-4e51-b801-b1656d0558d7.xhtml),* Towards
    Production Ready*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一系列其他的扫描工具可用于扫描您的镜像仓库，包括 **OpenSCAP** 以及 **Twistlock** 和 **AquaSec**，我们将在[第12章](0ebbb579-01ba-4e51-b801-b1656d0558d7.xhtml)，*走向生产就绪*中介绍。
- en: Image signing and verification
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜像签名和验证
- en: Whether you are using a private image repository in-house or a public repo such
    as Docker Hub, it's important to know that you are running only the code that
    your developers have written. The potential for malicious code or man-in-the-middle
    attacks on downloads is an important factor in protecting your container images.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是在内部使用私有镜像仓库还是在 Docker Hub 等公共仓库上使用，重要的是要知道您正在运行的只是您的开发人员编写的代码。下载时恶意代码或中间人攻击的潜在可能性是保护容器镜像的重要因素。
- en: 'As such, both rkt and Docker support the ability to sign images and verify
    that the contents have not changed. Publishers can use keys to sign the images
    when they are pushed to the repositories and users can verify the signature on
    the client-side when downloading for use:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，rkt和Docker都支持签署映像并验证内容未更改的能力。发布者可以在将映像推送到存储库时使用密钥签署映像，用户可以在客户端下载并验证签名后使用：
- en: 'From the rkt documentation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 来自rkt文档：
- en: <q>"Before executing a remotely fetched ACI, rkt will verify it based on attached
    signatures generated by the ACI creator."</q>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <q>"在执行远程获取的ACI之前，rkt将根据ACI创建者生成的附加签名对其进行验证。"</q>
- en: '[https://coreos.com/rkt/docs/latest/subcommands/trust.html](https://coreos.com/rkt/docs/latest/subcommands/trust.html)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://coreos.com/rkt/docs/latest/subcommands/trust.html](https://coreos.com/rkt/docs/latest/subcommands/trust.html)'
- en: '[https://coreos.com/rkt/docs/latest/signing-and-verification-guide.html](https://coreos.com/rkt/docs/latest/signing-and-verification-guide.html)
    From the Docker documentation:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://coreos.com/rkt/docs/latest/signing-and-verification-guide.html](https://coreos.com/rkt/docs/latest/signing-and-verification-guide.html)
    来自Docker文档：'
- en: '<q>"Content trust gives you the ability to verify both the integrity and the
    publisher of all the data received from a registry over any channel."</q> [https://docs.docker.com/engine/security/trust/content_trust/](https://docs.docker.com/engine/security/trust/content_trust/)
    From the Docker Notary GitHub page:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <q>"内容信任使您能够验证从注册表收到的所有数据的完整性和发布者，无论通过哪个渠道。"</q> [https://docs.docker.com/engine/security/trust/content_trust/](https://docs.docker.com/engine/security/trust/content_trust/)
    来自Docker Notary GitHub页面：
- en: <q>"The Notary project comprises a server and a client for running and interacting
    with trusted collections."</q> [https://github.com/docker/notary](https://github.com/docker/notary)
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <q>"Notary项目包括用于运行和与受信任的集合交互的服务器和客户端。"</q> [https://github.com/docker/notary](https://github.com/docker/notary)
- en: Kubernetes cluster security
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes集群安全
- en: Kubernetes has continued to add a number of security features in their latest
    releases and has a well-rounded set of control points that can be used in your
    cluster; everything from secure node communication to pod security and even storage
    of sensitive configuration data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes在其最新版本中持续添加了许多安全功能，并且具有一套完整的控制点，可用于您的集群；从安全的节点通信到Pod安全，甚至是敏感配置数据的存储。
- en: Secure API calls
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全的API调用
- en: 'During every API call, Kubernetes applies a number of security controls. This
    security life cycle is depicted here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次API调用期间，Kubernetes都会应用一些安全控制。此安全生命周期在此处描述：
- en: '![](img/B06302_10_01.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06302_10_01.png)'
- en: API call life cycle
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: API调用生命周期
- en: After secure TLS communication is established, the API server runs through **Authorization**
    and **Authentication**. Finally, an **Admission Controller** loop is applied to
    the request before it reaches the API server.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立安全TLS通信之后，API服务器通过**授权**和**身份验证**。最后，在请求到达API服务器之前，会应用一个**准入控制器**循环。
- en: Secure node communication
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全的节点通信
- en: Kubernetes supports the use of secure communication channels between the API
    server and any client including the nodes themselves. Whether it's a GUI or command-line
    utility such as `kubectl`, we can use certificates to communicate with the API
    server. Hence, the API server is the central interaction point for any changes
    to the cluster and is a critical component to secure.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes支持在API服务器和任何客户端之间包括节点本身之间建立安全通信渠道。无论是GUI还是`kubectl`等命令行实用程序，我们都可以使用证书与API服务器进行通信。因此，API服务器是对集群进行任何更改的中心交互点，是一个关键组件以确保安全。
- en: In deployments such as GCE, the `kubelet` on each node is deployed for secure
    communication by default. This setup uses the TLS bootstrapping and the new certificates'
    API to establish a secure connection with the API server using TLS client certificates
    and a **Certificate Authority** (**CA**) cluster.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在诸如GCE之类的部署中，默认情况下在每个节点上部署了`kubelet`以进行安全通信。此设置使用TLS引导启动和新证书API与API服务器建立安全连接，使用TLS客户端证书和**证书颁发机构**（**CA**）集群。
- en: Authorization and authentication plugins
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权和身份验证插件
- en: The plugin mechanisms for authentication and authorization in Kubernetes are
    in their infancy. However, these features also continue to develop in the next
    few releases. There are also third-party providers that integrate with the features
    here.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中用于身份验证和授权的插件机制还处于初期阶段。但是，这些功能在接下来的几个版本中也在继续开发。还有第三方提供者与这里的功能集成。
- en: Authentication is currently supported in the form of tokens, passwords, and
    certificates with plans to add the plugin capability at a later stage. OpenID
    Connect tokens are supported and several third-party implementations, such as
    Dex from CoreOS and aser account and authentication from Cloud Foundry, are available.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 目前支持身份验证的形式包括令牌、密码和证书，并计划在以后的阶段添加插件功能。支持 OpenID Connect 令牌，还有几个第三方实现，如来自 CoreOS
    的 Dex 和来自 Cloud Foundry 的 aser 账户和身份验证。
- en: Authorization already supports three modes. The full **RBAC** (short for **Role-Based
    Access Control**)mode is still a work in progress and will eventually bring a
    mature role-based authentication from Kubernetes itself. **Attribute-Based Access
    Control** (**ABAC**) is already supported and lets a user define privileges via
    attributes in a file. Finally, a webhook mechanism is supported, which allows
    for integration with third-party authorization via REST web service calls.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 授权已经支持了三种模式。完整的**RBAC**（即**基于角色的访问控制**）模式仍在进行中，最终将从 Kubernetes 本身引入成熟的基于角色的身份验证。**基于属性的访问控制**（**ABAC**）已经得到支持，并允许用户通过文件中的属性定义权限。最后，支持
    webhook 机制，允许通过 REST Web 服务调用与第三方授权进行集成。
- en: 'Learn more about each area here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请在这里了解更多关于每个领域的信息：
- en: '[http://kubernetes.io/docs/admin/authorization/](http://kubernetes.io/docs/admin/authorization/)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://kubernetes.io/docs/admin/authorization/](http://kubernetes.io/docs/admin/authorization/)'
- en: '[http://kubernetes.io/docs/admin/authentication/](http://kubernetes.io/docs/admin/authentication/)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://kubernetes.io/docs/admin/authentication/](http://kubernetes.io/docs/admin/authentication/)'
- en: Admission controllers
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准入控制器
- en: Kubernetes also provides a mechanism for integrating with additional verification
    as a final step. This could be in the form of image scanning, signature checks,
    or anything that is able to respond in the specified fashion. When an API call
    is made, the hook is called and that server can run its verification. Admission
    controllers can also be used to transform requests and add or alter the original
    request. Once the operations are run, a response is then sent back with a status
    that instructs Kubernetes to allow or deny the call.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 还提供了一种与附加验证集成的机制作为最后一步。这可以是图像扫描、签名检查或任何能够以指定方式响应的东西。当进行 API 调用时，会调用该钩子，服务器可以运行其验证。准入控制器还可用于转换请求并添加或更改原始请求。操作运行后，然后发送带有指示
    Kubernetes 允许或拒绝调用的状态的响应。
- en: This can be especially helpful for verifying or testing images as we mentioned
    in the last section. The `ImagePolicyWebhook` plugin provides an admission controller
    that allows for integration with additional image inspection.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于验证或测试图像尤其有帮助，正如我们在上一节中提到的那样。`ImagePolicyWebhook`插件提供了一个准入控制器，允许与额外的图像检查集成。
- en: 'For more information, visit the Using Admission Controller page in the following
    documentation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问以下文档中的“使用准入控制器”页面：
- en: '[https://kubernetes.io/docs/admin/admission-controllers/](https://kubernetes.io/docs/admin/admission-controllers/).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/admin/admission-controllers/](https://kubernetes.io/docs/admin/admission-controllers/).'
- en: Pod security policies and context
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pod 安全策略和上下文
- en: One of the latest additions to the Kubernetes' security arsenal is that of **Pod
    security policies and contexts**. These allow users to control users and groups
    for container processes and attached volumes, limit the use of host networks or
    namespaces, and even set the root filesystem to read-only. Additionally, we can
    limit the capabilities available and also set SELinux options for the labels that
    are applied to the containers in each pod.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 安全工具箱中的最新添加之一是**Pod 安全策略和上下文**。这允许用户控制容器进程和附加卷的用户和组，限制使用主机网络或命名空间，甚至将根文件系统设置为只读。此外，我们可以限制可用的功能，并为应用于每个
    pod 中的容器的标签设置 SELinux 选项。
- en: 'In addition to SELinux, Kubernetes also added support for using AppArmor with
    your pods using annotations. For more information, refer to the following documentation
    page:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 SELinux 外，Kubernetes 还通过注释添加了对使用 AppArmor 的支持。有关更多信息，请参阅以下文档页面：
- en: '[https://kubernetes.io/docs/admin/apparmor/](https://kubernetes.io/docs/admin/apparmor/).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/admin/apparmor/](https://kubernetes.io/docs/admin/apparmor/).'
- en: We'll walk through an example of using a pod security context to add some constraints
    to our pods. Since the functionality is still in beta, we'll need to enable the
    beta extensions API and also add `PodSecurityPolicy` to the list of admission
    controllers in use.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个示例演示如何使用 pod 安全上下文为我们的 pod 添加一些约束。由于功能仍处于 beta 阶段，我们需要启用 beta 扩展 API，并在使用的准入控制器列表中添加`PodSecurityPolicy`。
- en: Enabling beta APIs
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用 beta API
- en: First, you'll need to SSH into your master node, switch to a **root** user,
    and then edit the `/etc/kubernetes/manifests/kube-apiserver.manifest` file in
    your preferred editor. Again, we can SSH via the Google Cloud CLI or use the Google
    Cloud Console, which has a built-in SSH client on the VM instances page.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要 SSH 到您的主节点，切换到**root**用户，然后使用您首选的编辑器编辑`/etc/kubernetes/manifests/kube-apiserver.manifest`文件。同样，我们可以通过
    Google Cloud CLI 进行 SSH，或者使用 Google Cloud Console，在 VM 实例页面上有一个内置的 SSH 客户端。
- en: The best practice is not to SSH onto the nodes themselves. However, we have
    done so at several points in this book for illustrative purposes. It's important
    to understand how things are running on the nodes themselves and can sometimes
    be necessary both for learning and troubleshooting. Having said this, use the
    tools such as `kubectl exec` when you simply need to run a command from within
    the cluster or a pod.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是不要直接 SSH 到节点本身。然而，在本书的几个地方，我们已经这样做了，用于说明目的。重要的是要了解节点本身运行的情况，并且有时候对于学习和故障排除可能是必要的。话虽如此，当您只需要在集群或
    pod 中运行命令时，请使用诸如`kubectl exec`之类的工具。
- en: 'Scroll down to the command section and we should see something like the following
    listing:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到命令部分，我们应该看到类似以下清单的内容：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Your listing may vary, so just add the parameters highlighted in bold as follows.
    Also, copy the original listing as a backup so you can restore it if needed later
    on:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你的清单可能会有所不同，所以只需按照下面粗体标记的参数添加。同时，复制原始清单作为备份，以便以后需要时可以恢复：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Save the file and exit `sudo` if you have a root shell. If all goes well, Kubernetes
    should notice the manifest changes and restart the API Server. This may take a
    few minutes and during reboot, `kubectl` may become unresponsive. I usually watch
    this with the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有 root shell，保存文件并退出`sudo`。如果一切顺利，Kubernetes 应该注意到清单的更改并重新启动 API 服务器。这可能需要几分钟，在重启期间，`kubectl`可能会失去响应。我通常使用以下命令来观察：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Watch the `STATUS` and `AGE` columns. Once the restart is successful, we'll
    have a `STATUS of Running` and an AGE on the order of a few minutes or less.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 观察`STATUS`和`AGE`列。一旦重启成功，我们将有一个`Running`的`STATUS`和一个几分钟或更短的`AGE`。
- en: If we had any typos with the manifest, we may see errors in `STATUS` or even
    get a permanently unresponsive `kubectl`. If this happens, we'll need to restore
    our earlier parameters. If all else fails, you can reboot the instance. The default
    for GCE setups has a boot script that will replace the manifest with the default
    settings.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在清单中有任何拼写错误，我们可能会在`STATUS`中看到错误，甚至会获得一个永久性无响应的`kubectl`。如果发生这种情况，我们将需要恢复我们之前的参数。如果一切都失败了，您可以重新启动实例。GCE
    设置的默认值有一个引导脚本，该脚本将使用默认设置替换清单。
- en: Once your API server is updated and running, we can add a security policy and
    run a pod with a pod security context defined. The policy runs at the cluster
    level and enforces the policy for all pods. The pod security context is set in
    the pod definition and applies only to that pod.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的 API 服务器更新并运行，我们就可以添加一个安全策略，并运行一个定义了 pod 安全上下文的 pod。该策略在集群级别运行，并强制执行所有 pod
    的策略。pod 安全上下文设置在 pod 定义中，并且仅适用于该 pod。
- en: Creating a PodSecurityPolicy
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 PodSecurityPolicy
- en: 'Now that we''ve added the `PodSecurityPolicy` admission controller, we''ll
    need to add a pod security policy before we can create our example in *listing
    10-2* further down. If we try to create that pod now, we will see an error similar
    to this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了`PodSecurityPolicy`准入控制器，我们需要在*列表 10-2*下面进一步创建一个示例之前添加一个 pod 安全策略。如果我们现在尝试创建该
    pod，我们将看到类似于这样的错误：
- en: '![](img/B06302_10_02.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06302_10_02.png)'
- en: Pod error without PodSecurityPolicy
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 PodSecurityPolicy 的 Pod 错误
- en: 'Again, the pod security policy applies cluster wide:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，pod 安全策略适用于整个集群：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 10-1*: `default-security-policy.json`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-1*：`default-security-policy.json`'
- en: 'Create this with the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding default policy does not allow containers to run in privileged
    mode. It allows any seLinux labels, any supplemental group IDs, any user to run
    the first process, and any group ID for the filesytems. It also supports all types
    of volumes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述默认策略不允许容器以特权模式运行。它允许任何 seLinux 标签，任何附加的组 ID，任何用户运行第一个进程，以及任何文件系统的组 ID。它还支持所有类型的卷。
- en: 'You can find all possible parameters in the source code, but I''ve created
    the following table for convenience. You can find more handy lookups like this
    on my new site:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在源代码中找到所有可能的参数，但为方便起见，我创建了以下表格。您可以在我的新网站上找到更多类似这样的便捷查找：
- en: '[https://www.kubesheets.com](https://www.kubesheets.com)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.kubesheets.com](https://www.kubesheets.com)'
- en: '| **Parameter** | **Type** | **Description** | **Required** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **类型** | **描述** | **必需** |'
- en: '| `Privileged` | `bool` | Allows or disallows running pod as privileged. |
    No |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `Privileged` | `bool` | 允许或禁止以特权运行 Pod。 | 否 |'
- en: '| `DefaultAddCapabilities` | `[]v1.Capaility` | This defines a default set
    of capabilities added to the container. If the pod specifies a capability drop
    that will override then add it here.Values are strings of POSIX capabilities minus
    the leading `CAP_`. For example, `CAP_SETUID` would be `SETUID`.[http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)
    | No |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `DefaultAddCapabilities` | `[]v1.Capaility` | 这定义了添加到容器中的一组默认功能。如果 Pod 指定了一个要删除的功能，那么将覆盖然后添加到这里。值是
    POSIX 功能的字符串，减去前缀`CAP_`。例如，`CAP_SETUID` 将是 `SETUID`。[http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)
    | 否 |'
- en: '| `RequiredDropCapabilities` | `[]v1.Capaility` | This defines a set of capabilities
    that must be dropped from a container. The pod cannot specify any of these capabilities.Values
    are strings of POSIX capabilities minus the leading `CAP_`. For example, `CAP_SETUID`
    would be `SETUID`.[http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)
    | No |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `RequiredDropCapabilities` | `[]v1.Capaility` | 这定义了必须从容器中丢弃的一组功能。Pod 不能指定这些功能中的任何一个。值是
    POSIX 功能的字符串，减去前缀`CAP_`。例如，`CAP_SETUID` 将是 `SETUID`。[http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)
    | 否 |'
- en: '| `AllowedCapabilities` | `[]v1.Capaility` | This defines a set of capabilities
    that are allowed and can be added to a container. The pod can specify any of these
    capabilities.Values are strings of POSIX capabilities minus the leading `CAP_`.
    For example, `CAP_SETUID` would be `SETUID`.[http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)
    | No |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `AllowedCapabilities` | `[]v1.Capaility` | 这定义了一组允许并可以添加到容器中的功能。Pod 可以指定这些功能中的任何一个。值是
    POSIX 功能的字符串，减去前缀`CAP_`。例如，`CAP_SETUID` 将是 `SETUID`。[http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)
    | 否 |'
- en: '| `Volumes` | `[]FSType` | This list defines which volumes can be used. Leave
    empty for all types.[https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/apis/extensions/v1beta1/types.go#L1127](https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/apis/extensions/v1beta1/types.go#L1127)
    | No |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `Volumes` | `[]FSType` | 此列表定义可以使用的卷。留空以使用所有类型。[https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/apis/extensions/v1beta1/types.go#L1127](https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/apis/extensions/v1beta1/types.go#L1127)
    | 否 |'
- en: '| `HostNetwork` | `bool` | This allows or disallows the Pod to use the host
    network. | No |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `HostNetwork` | `bool` | 允许或禁止Pod使用主机网络。 | 否 |'
- en: '| `HostPorts` | `[]HostPortRange` | This lets us restrict allowable host ports
    that can be exposed. | No |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `HostPorts` | `[]HostPortRange` | 这让我们能够限制可以暴露的可允许主机端口。 | 否 |'
- en: '| `HostPID` | `bool` | This allows or disallows the pod to use the host PID.
    | No |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `HostPID` | `bool` | 允许或禁止Pod使用主机 PID。 | 否 |'
- en: '| `HostIPC` | `bool` | This allows or disallows the pod to use the host IPC.
    | No |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `HostIPC` | `bool` | 允许或禁止Pod使用主机 IPC。 | 否 |'
- en: '| `SELinux` | `SELinuxStrategyOptions` | Set it to one of the strategy options
    as defined here:[https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies](https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies)
    | Yes |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `SELinux` | `SELinuxStrategyOptions` | 将其设置为这里定义的策略选项之一：[https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies](https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies)
    | 是 |'
- en: '| `RunAsUser` | `RunAsUserStrategyOptions` | Set it to one of the strategy
    options as defined here:[https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies](https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies)
    | Yes |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `RunAsUser` | `RunAsUserStrategyOptions` | 将其设置为以下策略选项之一，如此处所定义：[https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies](https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies)
    | 是 |'
- en: '| `SupplementalGroups` | `SupplementalGroupsStrategyOptions` | Set it to one
    of the strategy options as defined here:[https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies](https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies)
    | Yes |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `SupplementalGroups` | `SupplementalGroupsStrategyOptions` | 将其设置为以下策略选项之一，如此处所定义：[https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies](https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies)
    | 是 |'
- en: '| `FSGroup` | `FSGroupStrategyOptions` | Set it to one of the strategy options
    as defined here:[https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies](https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies)
    | Yes |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `FSGroup` | `FSGroupStrategyOptions` | 将其设置为以下策略选项之一，如此处所定义：[https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies](https://kubernetes.io/docs/user-guide/pod-security-policy/#strategies)
    | 是 |'
- en: '| `ReadOnlyRootFilesystem` | `bool` | Setting this to `true` will either deny
    the pod or force it to run with a read-only root filesystem. | No |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `ReadOnlyRootFilesystem` | `bool` | 将其设置为 `true` 将会拒绝该 pod 或强制其以只读根文件系统运行。
    | 否 |'
- en: '*Table 10-1\. Pod Security Policy Parameters *(you can refer to more details
    about this in point 3 in the *References* section at the end of the chapter)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 10-1\. Pod 安全策略参数*（你可以在本章末尾的参考文献第 3 点中查看更多详细信息）'
- en: 'Now that we have a basic policy for the cluster, let''s create a `Pod`. First,
    we will create a `Pod` with our `node-express-info` container:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对集群有了一个基本策略，让我们创建一个 `Pod`。首先，我们将创建一个带有我们的 `node-express-info` 容器的 `Pod`：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 10-2*: `nodejs-pod-nopsc.yaml`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-2*: `nodejs-pod-nopsc.yaml`'
- en: 'Create the pod with the preceding listing. Then use the `kubectl exec` command
    to get a shell inside the pod. Next, we will attempt to create a file using the
    `touch` command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述清单创建 pod。然后使用 `kubectl exec` 命令获取 pod 内部的 shell。接下来，我们将尝试使用 `touch` 命令创建一个文件：
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We should get an `error similar to touch: cannot touch ''file.txt'': Read-only
    file system`. This is because we set the `ReadOnlyFileSystem` property to true,
    so all containers (pod security context defined or not) are now run with read-only root
    filesystems. Type `exit` to leave this pod.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '我们应该会收到类似于 `touch: cannot touch ''file.txt'': Read-only file system` 的错误。这是因为我们将
    `ReadOnlyFileSystem` 属性设置为 true，所以所有容器（无论是否定义了 pod 安全上下文）现在都以只读根文件系统运行。键入 `exit`
    退出此 pod。'
- en: Creating a pod with a PodSecurityContext
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PodSecurityContext 创建一个 pod
- en: Now that we have seen the effects of the pod security policy, let's explore
    the pod security context. Here we can define `seLinuxOptions` that let us define
    the label context for the containers in the pod. We can also define `runAsUser`
    to specify the UID with which each container will run and the `runAsNonRoot` flag
    that will simply prevent starting containers that run as `UID 0` or `root`. We
    can also specify the Group (GID) for the first process in each container with `supplementalGroup`.
    Finally, we can specify the Group (GID) for filesystem ownership and new files
    with `fsGroup`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了 pod 安全策略的影响，让我们来探索一下 pod 安全上下文。在这里，我们可以定义 `seLinuxOptions`，它让我们能够为
    pod 中的容器定义标签上下文。我们还可以定义 `runAsUser`，以指定每个容器将使用的 UID，以及 `runAsNonRoot` 标志，它将简单地阻止以
    `UID 0` 或 `root` 运行的容器启动。我们还可以使用 `supplementalGroup` 指定每个容器中第一个进程的组（GID）。最后，我们可以使用
    `fsGroup` 指定文件系统所有权和新文件的组（GID）。
- en: '*Listing 10-4* is a version of our previous `node-express-info` pod with the
    `runAsNonRoot` set to `true`. It''s important to understand that root (`UID 0`)
    is the default user if none is defined in the `Dockerfile`. *Listing 10-3* shows
    the `Dockerfile` for our `node-express-info` container. We have not defined the
    `USER` directive and therefore it will run as root:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-4* 是我们先前的 `node-express-info` pod 的一个版本，其中 `runAsNonRoot` 设置为 `true`。重要的是要理解，如果在
    `Dockerfile` 中没有定义用户，则 root（`UID 0`）是默认用户。 *清单 10-3* 显示了我们 `node-express-info`
    容器的 `Dockerfile`。我们没有定义 `USER` 指令，因此它将以 root 身份运行：'
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 10-3*: `node-express-info Dockerfile`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-3*: `node-express-info Dockerfile`'
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 10-4*: `nodejs-pod-psc.yaml`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-4*: `nodejs-pod-psc.yaml`'
- en: 'Understanding the relationship between the security context and how the containers
    are built is important. If we try to create the preceding *Listing 10-4* with
    `kubectl create -f nodejs-pod-psc.yaml`, we will see that it never starts and
    gives us `VerifyNonRootError`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 理解安全上下文与容器构建方式之间的关系很重要。如果我们尝试使用 `kubectl create -f nodejs-pod-psc.yaml` 创建上述的
    *Listing 10-4*，我们会发现它永远不会启动，并给出 `验证非根错误`：
- en: '![](img/B06302_10_03.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06302_10_03.png)'
- en: VerifyNonRootError
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 验证非根错误
- en: Understanding that running containers securely is not a merely a task of administrators
    adding constraints is important. The work must be done in collaboration with developers
    who will properly create the images.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 理解以安全方式运行容器不仅仅是管理员添加约束的任务。这项工作必须与将正确创建图像的开发人员合作进行。
- en: Clean up
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理工作
- en: 'The policy we have put in place may be too restrictive for learning and development,
    so you may wish to remove it. You can do so with the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们制定的策略可能对学习和开发来说过于严格，因此您可能希望删除它。您可以使用以下命令执行此操作：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You'll also need to undo the changes to `/etc/kubernetes/manifests/kube-apiserver.manifest` that
    we did on the Kubernetes master at the beginning of this section. Specifically,
    you should remove the `PodSecurityPolicy` from the list of the `admission-control` section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要撤消在本节开头对 Kubernetes 主节点上的 `/etc/kubernetes/manifests/kube-apiserver.manifest`
    所做的更改。具体来说，您应该从 `admission-control` 部分的列表中删除 `PodSecurityPolicy`。
- en: Additional considerations
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的考虑事项
- en: In addition to the features we just reviewed, Kubernetes has a number of other
    constructs that should be considered in your overall cluster hardening process.
    Earlier in the book, we looked at namespaces that provide a logical separation
    for multi-tenancy. While the namespaces themselves do not isolate the actual network
    traffic, some of the network plugins, such as Calico and Canal, provide additional
    capability for network policies. We also looked at quotas and limits that can
    be set for each namespace and should be used to prevent a single tenant or project
    from consuming too many resources within the cluster.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们刚刚审查的功能之外，Kubernetes 还有许多其他构造应该在整个集群强化过程中考虑。在本书的前面，我们看到了为多租户提供逻辑分离的命名空间。虽然命名空间本身不会隔离实际的网络流量，但一些网络插件，如
    Calico 和 Canal，提供了额外的网络策略功能。我们还看到了可以为每个命名空间设置的配额和限制，应该用于防止单个租户或项目在集群中消耗过多的资源。
- en: Securing sensitive application data (secrets)
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护敏感应用程序数据（秘密）
- en: Sometimes, our application needs to hold sensitive information. This can be
    credentials or tokens to log in to a database or service. Storing this sensitive
    information in the image itself is something to be avoided. Here, Kubernetes provides
    us a solution in the construct of secrets.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们的应用程序需要保存敏感信息。这可以是登录到数据库或服务的凭据或令牌。将这些敏感信息存储在图像本身中是应该避免的。在这里，Kubernetes
    在秘密构造中为我们提供了一个解决方案。
- en: '**Secrets** give us a way to store sensitive information without including
    plaintext versions in our resource definition files. Secrets can be mounted to
    the pods that need them and then accessed within the pod as files with the secret
    values as content. Alternatively, you can also expose the secrets via environment
    variables.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**秘密**给了我们一种在资源定义文件中不包含明文版本的敏感信息的存储方式。秘密可以挂载到需要它们的 pod 中，然后在 pod 内部以包含秘密值的文件形式访问。或者，你也可以通过环境变量暴露秘密。'
- en: We can easily create a secret either with YAML or on the command line. Secrets
    do need to be base-64 encoded, but if we use the `kubectl` command line, this
    encoding is done for us.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地使用 YAML 或命令行创建秘密。秘密确实需要进行 base64 编码，但如果我们使用 `kubectl` 命令行，则此编码将为我们执行。
- en: 'Let''s start with the following Secret:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下秘密开始：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can then check for the Secret with this command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用以下命令检查秘密：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we have successfully created the Secret, let''s make a pod that can
    use the secret. Secrets are consumed in pods by way of attached volumes. In the
    following *Listing 10-5*, you''ll notice that we use `volumeMount` to mount the
    secret to a folder in our container:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功创建了秘密，让我们创建一个可以使用秘密的 pod。通过附加卷的方式，秘密在 pod 中被消耗。在下面的 *Listing 10-5* 中，您会注意到我们使用
    `volumeMount` 将秘密挂载到容器中的一个文件夹：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 10-5*: `secret-pod.yaml`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 10-5*：`secret-pod.yaml`'
- en: 'Create this pod with `kubectl create -f secret-pod.yaml`. Once created, we
    can get a bash shell in the pod with `kubectl exec` and then change directories
    to the `/etc/secret-phrases` folder that we set up in the pod definition. Listing
    this directory reveals a single file with the name of the secret that we created
    earlier:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl create -f secret-pod.yaml`命令创建此Pod。一旦创建，我们可以通过`kubectl exec`获取该Pod中的bash
    shell，然后切换到我们在Pod定义中设置的`/etc/secret-phrases`文件夹。列出该目录会显示一个单独的文件，文件名为我们之前创建的秘密：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we then display those contents, we should see the phrase we encoded previously,
    `Shh! Dont'' tell`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们显示这些内容，应该会看到我们之前编码的短语`Shh! Dont' tell`：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Typically, this would be used for a username and password to a database or service, or
    any sensitive credentials and configuration data.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这将用于数据库或服务的用户名和密码，或任何敏感凭据和配置数据。
- en: Bear in mind that secrets are still in their early stages, but they are a vital
    component for production operations. There are several improvements planned here
    for future releases. At the moment, secrets are still stored in plaintext in the
    etcd server. However, the secrets construct does allow us to control which pods
    can access it and it stores the information on the tmpfs, but does not store it
    at rest for each pod. You'll likely want more protection in place for a production-ready
    system.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Secrets仍处于早期阶段，但它们是生产操作的重要组成部分。这里计划对未来发布进行一些改进。目前，Secrets仍以明文形式存储在etcd服务器中。但是，Secrets构建确实允许我们控制哪些Pod可以访问它，并将信息存储在tmpfs上，但不会为每个Pod持续存储它。您可能希望对生产就绪系统采取更多保护措施。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We took a look at basic container security and some essential areas of consideration.
    We also touched on basic image security and continuous vulnerability scanning.
    Later in this chapter, we looked at the overall security features of Kubernetes
    including secrets for storing sensitive configuration data, secure API calls,
    and even setting up security policies and contexts for pods running on our cluster.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了基本容器安全性和一些重要的考虑因素。我们还涉及了基本镜像安全性和持续漏洞扫描。在本章稍后，我们将查看Kubernetes的整体安全功能，包括用于存储敏感配置数据的Secrets，安全的API调用，甚至为在我们集群上运行的容器设置安全策略和上下文。
- en: You should now have a solid starting point for securing your cluster and moving
    towards production. To that end, the next chapter will cover an overall strategy
    for moving towards production and will also look at some third-party vendors that
    offer tools to fill in the gaps and assist you on the way.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该已经有了一个稳固的起点，用于保护您的集群并向生产环境迈进。为此，下一章将涵盖向生产环境迈进的整体策略，并且还将查看一些第三方供应商提供的填补空白并在路上协助您的工具。
- en: References
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/2016/april/ncc_group_understanding_hardening_linux_containers-10pdf/](https://www.nccgroup.trust/us/our-research/understanding-and-hardening-linux-containers/)'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/2016/april/ncc_group_understanding_hardening_linux_containers-10pdf/](https://www.nccgroup.trust/us/our-research/understanding-and-hardening-linux-containers/)'
- en: '[https://github.com/docker/docker/blob/master/oci/defaults_linux.go#L62-L77](https://github.com/docker/docker/blob/master/oci/defaults_linux.go#L62-L77)'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://github.com/docker/docker/blob/master/oci/defaults_linux.go#L62-L77](https://github.com/docker/docker/blob/master/oci/defaults_linux.go#L62-L77)'
- en: '[https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/apis/extensions/v1beta1/types.go#L1075](https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/apis/extensions/v1beta1/types.go#L1075)'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/apis/extensions/v1beta1/types.go#L1075](https://github.com/kubernetes/kubernetes/blob/release-1.5/pkg/apis/extensions/v1beta1/types.go#L1075)'
