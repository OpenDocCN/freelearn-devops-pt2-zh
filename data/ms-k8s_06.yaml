- en: Using Critical Kubernetes Resources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用关键的Kubernetes资源
- en: In this chapter, we will design a massive-scale platform that will challenge
    Kubernetes' capabilities and scalability. The Hue platform is all about creating
    an omniscient and omnipotent digital assistant. Hue is a digital extension of
    you. It will help you do anything, find anything, and, in many cases, will do
    a lot on your behalf. It will obviously need to store a lot information, integrate
    with many external services, respond to notifications and events, and be smart
    about interacting with you.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将设计一个挑战Kubernetes能力和可伸缩性的大规模平台。Hue平台的目标是创建一个无所不知、无所不能的数字助手。Hue是你的数字延伸。它将帮助你做任何事情，找到任何东西，并且在许多情况下，将代表你做很多事情。它显然需要存储大量信息，与许多外部服务集成，响应通知和事件，并且在与你的互动方面非常智能。
- en: We will take the opportunity in this chapter to get to know Kubectl and other
    related tools a little better, and will explore in detail resources that we've
    seen before, such as pods, as well as new resources, such as **jobs**. At the
    end of this chapter, you will have a clear picture of how impressive Kubernetes
    is and how it can be used as the foundation for hugely complex systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将有机会更好地了解Kubectl和其他相关工具，并将详细探讨我们之前见过的资源，如pod，以及新资源，如**jobs**。在本章结束时，你将清楚地了解Kubernetes有多么令人印象深刻，以及它如何可以作为极其复杂系统的基础。
- en: Designing the Hue platform
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计Hue平台
- en: In this section, we will set the stage and define the scope of the amazing Hue
    platform. Hue is not Big Brother, Hue is Little Brother! Hue will do whatever
    you allow it to do. It will be able to do a lot, but some people might be concerned,
    so you get to pick how much or how little Hue can help you with. Get ready for
    a wild ride!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为惊人的Hue平台设定舞台并定义范围。Hue不是老大哥，Hue是小弟！Hue将做任何你允许它做的事情。它可以做很多事情，但有些人可能会担心，所以你可以选择Hue可以帮助你多少。准备好进行一次疯狂的旅行！
- en: Defining the scope of Hue
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义Hue的范围
- en: 'Hue will manage your digital persona. It will know you better than you know
    yourself. Here is a list of some of the services which Hue can manage and help
    you with:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Hue将管理你的数字人格。它将比你自己更了解你。以下是Hue可以管理并帮助你的一些服务列表：
- en: Search and content aggregation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索和内容聚合
- en: Medical
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 医疗
- en: Smart home
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能家居
- en: Finance-bank, savings, retirement, investing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金融-银行、储蓄、退休、投资
- en: Office
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 办公室
- en: Social
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社交
- en: Travel
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旅行
- en: Wellbeing
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康
- en: Family
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 家庭
- en: '**Smart reminders and notifications**: Let''s think of the possibilities. Hue
    will know you, but also know your friends and the aggregate of other users across
    all domains. Hue will update its models in real time. It will not be confused
    by stale data. It will act on your behalf, present relevant information, and learn
    your preferences continuously. It can recommend new shows or books that you may
    like, make restaurant reservations based on your schedule and your family or friends,
    and control your home automation.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能提醒和通知：让我们想想可能性。Hue将了解你，也了解你的朋友和所有领域的其他用户的总和。Hue将实时更新其模型。它不会被陈旧的数据所困扰。它将代表你采取行动，提供相关信息，并持续学习你的偏好。它可以推荐你可能喜欢的新节目或书籍，根据你的日程安排和家人或朋友的情况预订餐厅，并控制你的家庭自动化。
- en: '**Security, identity, and privacy**: Hue is your proxy online. The ramifications
    of someone stealing your Hue identity, or even just eavesdropping on your Hue
    interaction, are devastating. Potential users may even be reluctant to trust the
    Hue organization with their identity. Let''s devise a non-trust system where users
    have the power to pull the plug on Hue at any time. Here are a few ideas in the
    right direction:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全、身份和隐私：Hue是您在线的代理。有人窃取您的Hue身份，甚至只是窃听您的Hue互动的后果是灾难性的。潜在用户甚至可能不愿意信任Hue组织他们的身份。让我们设计一个非信任系统，让用户随时有权终止Hue。以下是一些朝着正确方向的想法：
- en: Strong identity through a dedicated device with multi-factor authorization,
    including multiple biometric reasons
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过专用设备和多因素授权实现强大的身份验证，包括多种生物识别原因
- en: Frequently rotating credentials
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频繁更换凭证
- en: Quick service pause and identity re-verification of all external services (will
    require original proof of identity to each provider)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速服务暂停和所有外部服务的身份重新验证（将需要向每个提供者提供原始身份证明）
- en: The Hue backend will interact with all external services through short-lived
    tokens
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hue后端将通过短暂的令牌与所有外部服务进行交互
- en: Architecting Hue as a collection of loosely-coupled microservices
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Hue构建为一组松散耦合的微服务的架构。
- en: Hue's architecture will need to support enormous variation and flexibility.
    It will also need to be very extensible where existing capabilities and external
    services are constantly upgraded, and new capabilities and external services are
    integrated into the platform. That level of scale calls for microservices, where
    each capability or service is totally independent of other services except for
    well-defined interfaces through standard and/or discoverable APIs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Hue的架构将需要支持巨大的变化和灵活性。它还需要非常可扩展，其中现有的功能和外部服务不断升级，并且新的功能和外部服务集成到平台中。这种规模需要微服务，其中每个功能或服务都与其他服务完全独立，除了通过标准和/或可发现的API进行定义的接口。
- en: Hue components
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hue组件
- en: Before embarking on our microservice journey, let's review the types of component
    we need to construct for Hue.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在着手进行微服务之旅之前，让我们回顾一下我们需要为Hue构建的组件类型。
- en: '**User profile**:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户资料：
- en: The user profile is a major component, with lots of sub-components. It is the
    essence of the user, their preferences, history across every area, and everything
    that Hue knows about them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 用户资料是一个重要组成部分，有很多子组件。它是用户的本质，他们的偏好，跨各个领域的历史，以及Hue对他们了解的一切。
- en: '**User graph**:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户图：
- en: 'The user graph component models networks of interactions between users across
    multiple domains. Each user participates in multiple networks: social networks
    such as Facebook and Twitter, professional networks, hobby networks, and volunteering
    communities. Some of these networks are ad hoc, and Hue will be able to structure
    them to benefit users. Hue can take advantage of the rich profiles it has of user
    connections to improve interactions even without exposing private information.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 用户图组件模拟了用户在多个领域之间的互动网络。每个用户参与多个网络：社交网络（如Facebook和Twitter）、专业网络、爱好网络和志愿者社区。其中一些网络是临时的，Hue将能够对其进行结构化以使用户受益。Hue可以利用其对用户连接的丰富资料，即使不暴露私人信息，也能改善互动。
- en: '**Identity**:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份：
- en: Identity management is critical, as mentioned previously, so it deserves a separate
    component. A user may prefer to manage multiple mutually exclusive profiles with
    separate identities. For example, maybe users are not comfortable with mixing
    their health profile with their social profile because of the risk of inadvertently
    exposing personal health information to their friends.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 身份管理是至关重要的，正如前面提到的，因此它值得一个单独的组件。用户可能更喜欢管理具有独立身份的多个互斥配置文件。例如，也许用户不愿意将他们的健康配置文件与社交配置文件混合在一起，因为这样做可能会意外地向朋友透露个人健康信息的风险。
- en: '**Authorizer**:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权者**：'
- en: The authorizer is a critical component where the user explicitly authorizes
    Hue to perform certain actions or collect various data on its behalf. This includes
    access to physical devices, accounts of external services, and level of initiative.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 授权者是一个关键组件，用户明确授权Hue代表其执行某些操作或收集各种数据。这包括访问物理设备、外部服务的帐户和主动程度。
- en: '**External service**:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部服务**：'
- en: Hue is an aggregator of external services. It is not designed to replace your
    bank, your health provider, or your social network. It will keep a lot of metadata
    about your activities, but the content will remain with your external services.
    Each external service will require a dedicated component to interact with the
    external service API and policies. When no API is available, Hue emulates the
    user by automating the browser or native apps.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Hue是外部服务的聚合器。它并非旨在取代您的银行、健康提供者或社交网络。它将保留大量关于您活动的元数据，但内容将保留在您的外部服务中。每个外部服务都需要一个专用组件来与外部服务的API和政策进行交互。当没有API可用时，Hue通过自动化浏览器或原生应用程序来模拟用户。
- en: '**Generic sensor**:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用传感器**：'
- en: A big part of Hue's value proposition is to act on the user's behalf. In order
    to do that effectively, Hue needs to be aware of various events. For example,
    if Hue reserved a vacation for you but it senses that a cheaper flight is available,
    it can either automatically change your flight or ask you for confirmation. There
    is an infinite number of things to sense. To reign in sensing, a generic sensor
    is needed. A generic sensor will be extensible, but exposes a generic interface
    that the other parts of Hue can utilize uniformly even as more and more sensors
    are added.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Hue价值主张的一个重要部分是代表用户行事。为了有效地做到这一点，Hue需要意识到各种事件。例如，如果Hue为您预订了假期，但它感觉到有更便宜的航班可用，它可以自动更改您的航班或要求您确认。有无限多件事情可以感知。为了控制感知，需要一个通用传感器。通用传感器将是可扩展的，但提供一个通用接口，供Hue的其他部分统一使用，即使添加了越来越多的传感器。
- en: '**Generic actuator**:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用执行器**：'
- en: This is the counterpart of the generic sensor. Hue needs to perform actions
    on your behalf, such as reserving a flight. To do that, Hue needs a generic actuator
    that can be extended to support particular functions but can interact with other
    components, such as the identity manager and the authorizer, in a uniform fashion.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通用传感器的对应物。Hue需要代表您执行操作，比如预订航班。为了做到这一点，Hue需要一个通用执行器，可以扩展以支持特定功能，但可以以统一的方式与其他组件交互，比如身份管理器和授权者。
- en: '**User learner**:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户学习者**：'
- en: This is the brain of Hue. It will constantly monitor all of your interactions
    (that you authorize) and update its model of you. This will allow Hue to become
    more and more useful over time, predict what you need and what will interest you,
    provide better choices, surface more relevant information at the right time, and
    avoid being annoying and overbearing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Hue的大脑。它将不断监视您所有的互动（经您授权的），并更新对您的模型。这将使Hue随着时间变得越来越有用，预测您的需求和兴趣，提供更好的选择，在合适的时候提供更相关的信息，并避免让人讨厌和压抑。
- en: Hue microservices
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hue微服务
- en: 'The complexity of each of the components is enormous. Some of the components,
    such as the external service, the generic sensor, and generic actuator, will need
    to operate across hundreds, thousands, or more external services that constantly
    change outside the control of Hue. Even the user learner needs to learn the user''s
    preferences across many areas and domains. Microservices address this need by
    allowing Hue to evolve gradually and grow more isolated capabilities without collapsing
    under its own complexity. Each microservice interacts with generic Hue infrastructure
    services through standard interfaces and, optionally, with a few other services
    through well-defined and versioned interfaces. The surface area of each microservice
    is manageable, and the orchestration between microservices is based on standard
    best practices:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件的复杂性都非常巨大。一些组件，比如外部服务、通用传感器和通用执行器，需要跨越数百、数千甚至更多不断变化的外部服务进行操作，而这些服务是在Hue的控制范围之外的。甚至用户学习器也需要学习用户在许多领域和领域的偏好。微服务通过允许Hue逐渐演变并增加更多的隔离能力来满足这种需求，而不会在自身的复杂性下崩溃。每个微服务通过标准接口与通用Hue基础设施服务进行交互，并且可以通过明确定义和版本化的接口与其他一些服务进行交互。每个微服务的表面积是可管理的，微服务之间的编排基于标准最佳实践：
- en: '**Plugins**:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件**：'
- en: 'Plugins are the key to extending Hue without a proliferation of interfaces.
    The thing about plugins is that you often need plugin chains that cross multiple
    abstraction layers. For example, if we want to add a new integration for Hue with
    YouTube, then you can collect a lot of YouTube-specific information: your channels,
    favorite videos, recommendations, and videos you have watched. To display this
    information to users and allow them to act on it, you need plugins across multiple
    components and eventually in the user interface as well. Smart design will help
    by aggregating categories of actions such as recommendations, selections, and
    delayed notifications to many different services.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 插件是扩展Hue而不会产生大量接口的关键。关于插件的一件事是，通常需要跨越多个抽象层的插件链。例如，如果我们想要为Hue添加与YouTube的新集成，那么你可以收集大量特定于YouTube的信息：你的频道、喜欢的视频、推荐以及你观看过的视频。为了向用户显示这些信息并允许他们对其进行操作，你需要跨越多个组件并最终在用户界面中使用插件。智能设计将通过聚合各种操作类别，如推荐、选择和延迟通知，来帮助许多不同的服务。
- en: The great thing about plugins is that they can be developed by anyone. Initially,
    the Hue development team will have to develop the plugins, but as Hue becomes
    more popular, external services will want to integrate with Hue and build Hue
    plugins to enable their service.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 插件的好处在于任何人都可以开发。最初，Hue开发团队将不得不开发插件，但随着Hue变得更加流行，外部服务将希望与Hue集成并构建Hue插件以启用其服务。
- en: That will lead, of course, to a whole ecosystem of plugin registration, approval,
    and curation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这将导致插件注册、批准和策划的整个生态系统。
- en: '**Data stores**:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据存储**：'
- en: 'Hue will need several types of data store, and multiple instances of each type,
    to manage its data and metadata:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Hue将需要多种类型的数据存储和每种类型的多个实例来管理其数据和元数据：
- en: Relational database
  id: totrans-50
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系数据库
- en: Graph database
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据库
- en: Time-series database
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列数据库
- en: In-memory caching
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存缓存
- en: Due to the scope of Hue, each one of these databases will have to be clustered
    and distributed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Hue的范围，每个数据库都将需要进行集群化和分布式处理。
- en: '**Stateless microservices**:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态微服务**：'
- en: The microservices should be mostly stateless. This will allow specific instances
    to be started and killed quickly, and migrated across the infrastructure as necessary.
    The state will be managed by the stores and accessed by the microservices with
    short-lived access tokens.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该大部分是无状态的。这将允许特定实例被快速启动和关闭，并根据需要在基础设施之间迁移。状态将由存储管理，并由短暂的访问令牌访问微服务。
- en: '**Queue-based interactions**:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于队列的交互**：'
- en: All these microservices need to talk to each other. Users will ask Hue to perform
    tasks on their behalf. External services will notify Hue of various events. Queues
    coupled with stateless microservices provide the perfect solution. Multiple instances
    of each microservice will listen to various queues and respond when relevant events
    or requests are popped from the queue. This arrangement is very robust and easy
    to scale. Every component can be redundant and highly available. While each component
    is fallible, the system is very fault-tolerant.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些微服务需要相互通信。用户将要求Hue代表他们执行任务。外部服务将通知Hue各种事件。与无状态微服务相结合的队列提供了完美的解决方案。每个微服务的多个实例将监听各种队列，并在从队列中弹出相关事件或请求时做出响应。这种安排非常健壮且易于扩展。每个组件都可以是冗余的并且高度可用。虽然每个组件都可能出现故障，但系统非常容错。
- en: A queue can be used for asynchronous RPC or request-response style interactions
    too, where the calling instance provides a private queue name and the callee posts
    the response to the private queue.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 队列可以用于异步的RPC或请求-响应式的交互，其中调用实例提供一个私有队列名称，被调用者将响应发布到私有队列。
- en: Planning workflows
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划工作流程
- en: Hue often needs to support workflows. A typical workflow will get a high-level
    task, such as making a dentist appointment; it will extract the user's dentist
    details and schedule, match it with the user's schedule, choose between multiple
    options, potentially confirm with the user, make the appointment, and set up a
    reminder. We can classify workflows into fully automatic and human workflows where
    humans are involved. Then there are workflows that involve spending money.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Hue经常需要支持工作流程。典型的工作流程将得到一个高层任务，比如预约牙医；它将提取用户的牙医详情和日程安排，与用户的日程安排匹配，在多个选项之间进行选择，可能与用户确认，预约，并设置提醒。我们可以将工作流程分类为完全自动和涉及人类的人工工作流程。然后还有涉及花钱的工作流程。
- en: Automatic workflows
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动工作流程
- en: Automatic workflows don't require human intervention. Hue has full authority
    to execute all the steps from start to finish. The more autonomy the user allocates
    to Hue, the more effective it will be. The user should be able to view and audit
    all workflows, past and present.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 自动工作流程不需要人为干预。Hue有完全的权限来执行从开始到结束的所有步骤。用户分配给Hue的自主权越多，它的效果就会越好。用户应该能够查看和审计所有的工作流程，无论是过去还是现在。
- en: Human workflows
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人工工作流程
- en: Human workflows require interaction with a human. Most often it will be the
    user that needs to make a choice from multiple options or approve an action, but
    it may involve a person on another service. For example, to make an appointment
    with a dentist, you may have to get a list of available times from the secretary.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 人工工作流程需要与人的交互。最常见的情况是用户需要从多个选项中进行选择或批准某项操作，但也可能涉及到另一个服务上的人员。例如，要预约牙医，您可能需要从秘书那里获取可用时间的列表。
- en: Budget-aware workflows
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预算意识工作流程
- en: Some workflows, such as paying bills or purchasing a gift, require spending
    money. While, in theory, Hue can be granted unlimited access to the user's bank
    account, most users will probably be more comfortable with setting budgets for
    different workflows or just making spending a human-approved activity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有些工作流程，比如支付账单或购买礼物，需要花钱。虽然从理论上讲，Hue可以被授予对用户银行账户的无限访问权限，但大多数用户可能更愿意为不同的工作流程设置预算，或者只是将花钱作为经过人工批准的活动。
- en: Using Kubernetes to build the Hue platform
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes构建Hue平台
- en: In this section, we will look at various Kubernetes resources and how they can
    help us build Hue. First, we'll get to know the versatile Kubectl a little better,
    then we will look at running long-running processes in Kubernetes, exposing services
    internally and externally, using namespaces to limit access, launching ad hoc
    jobs, and mixing in non-cluster components. Obviously, Hue is a huge project,
    so we will demonstrate the ideas on a local Minikube cluster and not actually
    build a real Hue Kubernetes cluster.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看各种Kubernetes资源以及它们如何帮助我们构建Hue。首先，我们将更好地了解多才多艺的Kubectl，然后我们将看看在Kubernetes中运行长时间运行的进程，内部和外部暴露服务，使用命名空间限制访问，启动临时作业以及混合非集群组件。显然，Hue是一个庞大的项目，所以我们将在本地Minikube集群上演示这些想法，而不是实际构建一个真正的Hue
    Kubernetes集群。
- en: Using Kubectl effectively
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效使用Kubectl
- en: 'Kubectl is your Swiss Army knife. It can do pretty much anything around the
    cluster. Under the hood, Kubectl connects to your cluster through the API. It
    reads your `.kube/config` file, which contains information necessary to connect
    to your cluster or clusters. The commands are divided into multiple categories:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl是您的瑞士军刀。它几乎可以做任何与集群相关的事情。在幕后，Kubectl通过API连接到您的集群。它读取您的`.kube/config`文件，其中包含连接到您的集群或集群所需的信息。命令分为多个类别：
- en: '**Generic commands**: Deal with resources in a generic way: `create`, `get`,
    `delete`, `run`, `apply`, `patch`, `replace`, and so on'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用命令**：以通用方式处理资源：`create`，`get`，`delete`，`run`，`apply`，`patch`，`replace`等等'
- en: '**Cluster management commands**: Deal with nodes and the cluster at large:
    `cluster-info`, `certificate`, `drain`, and so on'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群管理命令**：处理节点和整个集群：`cluster-info`，`certificate`，`drain`等等'
- en: '**Troubleshooting commands**: `describe`, `logs`, `attach`, `exec`, and so
    on'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障排除命令**：`describe`，`logs`，`attach`，`exec`等等'
- en: '**Deployment commands**: Deal with deployment and scaling: `rollout`, `scale`,
    `auto-scale`, and so on'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署命令**：处理部署和扩展：`rollout`，`scale`，`auto-scale`等等'
- en: '**Settings commands**: Deal with labels and annotations: `label`, `annotate`,
    and so on'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置命令**：处理标签和注释：`label`，`annotate`等等'
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can view the configuration with Kubernetes `config view`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Kubernetes `config view`查看配置。
- en: 'Here is the configuration for a Minikube cluster:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Minikube集群的配置：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Understanding Kubectl resource configuration files
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Kubectl资源配置文件
- en: 'Many Kubectl operations, such as `create`, require complicated hierarchical
    output (since the API requires this output). Kubectl uses YAML or JSON configuration
    files. Here is a JSON configuration file for creating a pod:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Kubectl操作，比如`create`，需要复杂的分层输出（因为API需要这种输出）。Kubectl使用YAML或JSON配置文件。这是一个用于创建pod的JSON配置文件：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`apiVersion`: The very important Kubernetes API keeps evolving and can support
    different versions of the same resource through different versions of the API.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiVersion`：非常重要的Kubernetes API不断发展，并且可以通过API的不同版本支持相同资源的不同版本。'
- en: '`kind`: `kind` tells Kubernetes what type of resource it is dealing with, in
    this case, `pod`. This is always required.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`：`kind`告诉Kubernetes它正在处理的资源类型，在本例中是`pod`。这是必需的。'
- en: '`metadata`: This is a lot of information that describes the pod and where it
    operates:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`：这是描述pod及其操作位置的大量信息：'
- en: '`name`: Identifies the pod uniquely within its namespace'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名称`：在其命名空间中唯一标识pod'
- en: '`labels`: Multiple labels can be applied'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标签`：可以应用多个标签'
- en: '`namespace`: The namespace the pod belongs to'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`命名空间`：pod所属的命名空间'
- en: '`annotations`: A list of annotations available for query'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`注释`：可查询的注释列表'
- en: '`spec`: `spec` is a pod template that contains all of the information necessary
    to launch a pod. It can be quite elaborate, so we''ll explore it in multiple parts:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`规范`：`规范`是一个包含启动pod所需的所有信息的pod模板。它可能非常复杂，所以我们将在多个部分中探讨它：'
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Container spec`: The pod spec''s container is a list of container specs. Each
    container spec has the following structure:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`容器规范`：pod规范的容器是容器规范的列表。每个容器规范都有以下结构：'
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each container has an image, a command that, if specified, replaces the Docker
    image command. It also has arguments and environment variables. Then, there are,
    of course, the image pull policy, ports, and resource limits. We covered those
    in earlier chapters.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器都有一个镜像，一个命令，如果指定了，会替换Docker镜像命令。它还有参数和环境变量。然后，当然还有镜像拉取策略、端口和资源限制。我们在前几章中已经涵盖了这些。
- en: Deploying long-running microservices in pods
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在pod中部署长时间运行的微服务
- en: Long-running microservices should run in pods and be stateless. Let's look at
    how to create pods for one of Hue's microservices. Later, we will raise the level
    of abstraction and use a deployment.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间运行的微服务应该在pod中运行，并且是无状态的。让我们看看如何为Hue的一个微服务创建pod。稍后，我们将提高抽象级别并使用部署。
- en: Creating pods
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建pod
- en: Let's start with a regular pod configuration file for creating a Hue learner
    internal service. This service doesn't need to be exposed as a public service,
    and it will listen to a queue for notifications and store its insights in some
    persistent storage.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个常规的pod配置文件开始，为创建Hue学习者内部服务。这个服务不需要暴露为公共服务，它将监听一个队列以获取通知，并将其见解存储在一些持久存储中。
- en: 'We need a simple container that the pod will run in. Here is possibly the simplest
    Docker file ever, which will simulate the Hue learner:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个简单的容器来运行pod。这可能是有史以来最简单的Docker文件，它将模拟Hue学习者：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It uses the `busybox` base image, prints to standard output `Started...` and
    then goes into an infinite loop, which is, by all accounts, long-running.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`busybox`基础镜像，打印到标准输出`Started...`，然后进入一个无限循环，这显然是长时间运行的。
- en: I have built two Docker images tagged as `g1g1/hue-learn:v3.0` and `g1g1/hue-learn:v4.0`
    and pushed them to the Docker Hub registry (`g1g1` is my user name).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我构建了两个标记为`g1g1/hue-learn:v3.0`和`g1g1/hue-learn:v4.0`的Docker镜像，并将它们推送到Docker
    Hub注册表（`g1g1`是我的用户名）。
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, these images are available to be pulled into containers inside of Hue's
    pods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些镜像可以被拉入Hue的pod中的容器。
- en: 'We''ll use YAML here because it''s more concise and human-readable. Here are
    the boilerplate and `metadata` labels:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里使用YAML，因为它更简洁和易读。这里是样板和`元数据`标签：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The reason I use an annotation for the version and not a label is that labels
    are used to identify the set of pods in the deployment. Modifying labels is not
    allowed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用注释而不是标签的原因是，标签用于标识部署中的一组pod。不允许修改标签。
- en: 'Next comes the important `containers` spec, which defines for each container
    the mandatory `name` and `image`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是重要的`容器`规范，为每个容器定义了强制的`名称`和`镜像`：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The resources section tells Kubernetes the resource requirements of the container,
    which allows for more efficient and compact scheduling and allocations. Here,
    the container requests `200` milli-cpu units (0.2 core) and `256` MiB:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 资源部分告诉Kubernetes容器的资源需求，这允许更高效和紧凑的调度和分配。在这里，容器请求`200`毫CPU单位（0.2核心）和`256` MiB：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The environment section allows the cluster administrator to provide environment
    variables that will be available to the container. Here it tells it to discover
    the queue and the store through `dns`. In a testing environment, it may use a
    different discovery method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 环境部分允许集群管理员提供将可用于容器的环境变量。这里告诉它通过`dns`发现队列和存储。在测试环境中，可能会使用不同的发现方法：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Decorating pods with labels
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用标签装饰pod
- en: Labeling pods wisely is key for flexible operations. It lets you evolve your
    cluster live, organize your microservices into groups that you can operate on
    uniformly, and drill down in an ad hoc manner to observe different subsets.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 明智地为pod贴上标签对于灵活的操作至关重要。它让您可以实时演变您的集群，将微服务组织成可以统一操作的组，并以自发的方式深入观察不同的子集。
- en: 'For example, our Hue learner pod has the following labels:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的Hue学习者pod具有以下标签：
- en: '**Runtime-environment**: Production'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行环境**：生产'
- en: '**Tier**: Internal-service'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层级**：内部服务'
- en: The version annotation can be used to support running multiple versions at the
    same time. If both version 2 and version 3 need to run at the same time, either
    to provide backward compatibility or just temporarily during the migration from
    `v2` to `v3`, then having a version annotation or label allows both scaling pods
    of different versions independently and exposing services independently. The `runtime-environment`
    label allows performing global operations on all pods that belong to a certain
    environment. The `tier` label can be used to query all pods that belong to a particular
    tier. These are just examples; your imagination is the limit here.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 版本注释可用于支持同时运行多个版本。如果需要同时运行版本2和版本3，无论是为了提供向后兼容性还是在从`v2`迁移到`v3`期间暂时运行，那么具有版本注释或标签允许独立扩展不同版本的pod并独立公开服务。`runtime-environment`标签允许对属于特定环境的所有pod执行全局操作。`tier`标签可用于查询属于特定层的所有pod。这只是例子；在这里，您的想象力是限制。
- en: Deploying long-running processes with deployments
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用部署部署长时间运行的进程
- en: In a large-scale system, pods should never be just created and let loose. If
    a pod dies unexpectedly for whatever reason, you want another one to replace it
    to maintain overall capacity. You can create replication controllers or replica
    sets yourself, but that leaves the door open to mistakes as well as the possibility
    of partial failure. It makes much more sense to specify how many replicas you
    want when you launch your pods.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型系统中，pod不应该只是创建并放任不管。如果由于任何原因pod意外死亡，您希望另一个pod替换它以保持整体容量。您可以自己创建复制控制器或副本集，但这也会留下错误的可能性以及部分故障的可能性。在启动pod时指定要创建多少副本更有意义。
- en: 'Let''s deploy three instances of our Hue learner microservice with a Kubernetes
    deployment resource. Note that deployment objects became stable at Kubernetes
    1.9:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Kubernetes部署资源部署我们的Hue学习者微服务的三个实例。请注意，部署对象在Kubernetes 1.9时变得稳定：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `pod spec` is identical to the `spec` section from the pod configuration
    file that we used previously.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`pod spec`与我们之前使用的pod配置文件中的`spec`部分相同。'
- en: 'Let''s create the deployment and check its status:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建部署并检查其状态：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can get a lot more information about the deployment using the `kubectl describe`
    command.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`kubectl describe`命令获取有关部署的更多信息。
- en: Updating a deployment
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新部署
- en: The Hue platform is a large and ever-evolving system. You need to upgrade constantly.
    Deployments can be updated to roll out updates in a painless manner. You change
    the pod template to trigger a rolling update which is fully managed by Kubernetes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Hue平台是一个庞大且不断发展的系统。您需要不断升级。部署可以更新以无痛的方式推出更新。您可以更改pod模板以触发由Kubernetes完全管理的滚动更新。
- en: 'Currently, all the pods are running with version 3.0:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，所有的pod都在运行版本3.0：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s update the deployment to upgrade to version 4.0\. Modify the image version
    in the deployment file. Don''t modify labels; it will cause an error. Typically,
    you modify the image and some related metadata in annotations. Then we can use
    the `apply` command to upgrade the version:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新部署以升级到版本4.0。修改部署文件中的镜像版本。不要修改标签；这会导致错误。通常，您会修改镜像和一些相关的元数据在注释中。然后我们可以使用`apply`命令来升级版本：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Separating internal and external services
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离内部和外部服务
- en: Internal services are services that are accessed directly only by other services
    or jobs in the cluster (or administrators that log in and run ad hoc tools). In
    some cases, internal services are not accessed at all, and just perform their
    function and store their results in a persistent store that other services access
    in a decoupled way.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 内部服务是只有其他服务或集群中的作业（或登录并运行临时工具的管理员）直接访问的服务。在某些情况下，内部服务根本不被访问，只是执行其功能并将结果存储在其他服务以解耦方式访问的持久存储中。
- en: 'But some services need to be exposed to users or external programs. Let''s
    look at a fake Hue service that manages a list of reminders for a user. It doesn''t
    really do anything, but we''ll use it to illustrate how to expose services. I
    pushed a dummy `hue-reminders` image (the same as `hue-learn`) to Docker Hub:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但是一些服务需要向用户或外部程序公开。让我们看一个虚假的Hue服务，它管理用户的提醒列表。它实际上并不做任何事情，但我们将用它来说明如何公开服务。我将一个虚假的`hue-reminders`镜像（与`hue-learn`相同）推送到Docker
    Hub：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Deploying an internal service
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署内部服务
- en: 'Here is the deployment, which is very similar to the Hue-learner deployment,
    except that I dropped the `annotations`, `env`, and `resources` sections, kept
    just one label to save space, and added a `ports` section to the container. That''s
    crucial, because a service must expose a port through which other services can
    access it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是部署，它与Hue-learner部署非常相似，只是我删除了`annotations`、`env`和`resources`部分，只保留了一个标签以节省空间，并在容器中添加了一个`ports`部分。这是至关重要的，因为服务必须通过一个端口公开，其他服务才能访问它：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we run the deployment, two Hue `reminders` pods are added to the cluster:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行部署时，两个Hue `reminders` pod被添加到集群中：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'OK, the pods are running. In theory, other services can look up or be configured
    with their internal IP address and just access them directly because they are
    all in the same network space. But this doesn''t scale. Every time a reminders
    pod dies and is replaced by a new one, or when we just scale up the number of
    pods, all the services that access these pods must know about it. Services solve
    this issue by providing a single access point to all the pods. The service is
    as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，pod正在运行。理论上，其他服务可以查找或配置其内部IP地址，并直接访问它们，因为它们都在同一个网络空间中。但这并不具有可扩展性。每当一个reminders
    pod死掉并被新的pod替换，或者当我们只是扩展pod的数量时，所有访问这些pod的服务都必须知道这一点。服务通过提供所有pod的单一访问点来解决这个问题。服务如下：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The service has a selector that selects all the pods that have labels that match
    it. It also exposes a port, which other services will use to access it (it doesn't
    have to be the same port as the container's port).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务具有一个选择器，选择所有具有与其匹配的标签的pod。它还公开一个端口，其他服务将使用该端口来访问它（它不必与容器的端口相同）。
- en: Creating the hue-reminders service
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建hue-reminders服务
- en: 'Let''s create the service and explore it a little bit:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建服务并稍微探索一下：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The service is up and running. Other pods can find it through environment variables
    or DNS. The environment variables for all services are set at pod creation time.
    That means that if a pod is already running when you create your service, you''ll
    have to kill it and let Kubernetes recreate it with the environment variables
    (you create your pods through a deployment, right?):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 服务正在运行。其他pod可以通过环境变量或DNS找到它。所有服务的环境变量都是在pod创建时设置的。这意味着如果在创建服务时已经有一个pod在运行，您将不得不将其终止，并让Kubernetes使用环境变量重新创建它（您通过部署创建pod，对吧？）：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'But using DNS is much simpler. Your service DNS name is:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但是使用DNS要简单得多。您的服务DNS名称是：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Exposing a service externally
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将服务暴露给外部
- en: 'The service is accessible inside the cluster. If you want to expose it to the
    world, Kubernetes provides two ways to do it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务在集群内可访问。如果您想将其暴露给外部世界，Kubernetes提供了两种方法：
- en: Configure `NodePort` for direct access
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为直接访问配置`NodePort`
- en: Configure a cloud load balancer if you run it in a cloud environment
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在云环境中运行，请配置云负载均衡器
- en: 'Before you configure a service for external access, you should make sure it
    is secure. The Kubernetes documentation has a good example that covers all the
    gory details here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在为外部访问配置服务之前，您应该确保其安全。Kubernetes文档中有一个涵盖所有细节的很好的示例：
- en: '[https://github.com/kubernetes/examples/blob/master/staging/https-nginx/README.md](https://github.com/kubernetes/examples/blob/master/staging/https-nginx/README.md).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/kubernetes/examples/blob/master/staging/https-nginx/README.md](https://github.com/kubernetes/examples/blob/master/staging/https-nginx/README.md)。'
- en: We've already covered the principles in [Chapter 5](3dbb475e-3cc2-4943-8441-40a287cccfed.xhtml),
    *Configuring Kubernetes Security, Limits, and Accounts*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第5章](3dbb475e-3cc2-4943-8441-40a287cccfed.xhtml)中介绍了原则，“配置Kubernetes安全性、限制和账户”。
- en: 'Here is the `spec` section of the Hue-reminders service when exposed to the
    world through `NodePort`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过`NodePort`向外界暴露Hue-reminders服务的`spec`部分：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Ingress
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ingress
- en: '`Ingress` is a Kubernetes configuration object that lets you expose a service
    to the outside world and take care of a lot of details. It can do the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ingress`是Kubernetes的一个配置对象，它可以让您将服务暴露给外部世界，并处理许多细节。它可以执行以下操作：'
- en: Provide an externally visible URL to your service
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的服务提供外部可见的URL
- en: Load-balance traffic
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡流量
- en: Terminate SSL
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止SSL
- en: Provide name-based virtual hosting
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供基于名称的虚拟主机
- en: To use `Ingress`, you must have an `Ingress` controller running in your cluster.
    Note that Ingress is still in beta and has many limitations. If you're running
    your cluster on GKE, you're probably OK. Otherwise, proceed with caution. One
    of the current limitations of the `Ingress` controller is that it isn't built
    for scale. As such, it is not a good option for the Hue platform yet. We'll cover
    the `Ingress` controller in greater detail in Chapter 10, *Advanced Kubernetes
    Networking*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`Ingress`，您必须在集群中运行一个`Ingress`控制器。请注意，Ingress仍处于测试阶段，并且有许多限制。如果您在GKE上运行集群，那么可能没问题。否则，请谨慎操作。`Ingress`控制器目前的一个限制是它不适用于扩展。因此，它还不是Hue平台的一个好选择。我们将在第10章“高级Kubernetes网络”中更详细地介绍`Ingress`控制器。
- en: 'Here is what an `Ingress` resource looks like:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Ingress`资源的外观：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The Nginx `Ingress` controller will interpret this `Ingress` request and create
    a corresponding configuration file for the Nginx web server:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx `Ingress`控制器将解释此`Ingress`请求，并为Nginx Web服务器创建相应的配置文件：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It is possible to create other controllers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建其他控制器。
- en: Using namespace to limit access
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命名空间限制访问
- en: The Hue project is moving along nicely, and we have a few hundred microservices
    and about 100 developers and DevOps engineers working on it. Groups of related
    microservices emerge, and you notice that many of these groups are pretty autonomous.
    They are completely oblivious to the other groups. Also, there are some sensitive
    areas, such as health and finance, that you will want to control access to more
    effectively. Enter namespaces.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Hue项目进展顺利，我们有几百个微服务和大约100名开发人员和DevOps工程师在其中工作。相关微服务组出现，并且您会注意到许多这些组是相当自治的。它们完全不知道其他组。此外，还有一些敏感领域，如健康和财务，您将希望更有效地控制对其的访问。输入命名空间。
- en: Let's create a new service, Hue-finance, and put it in a new namespace called
    `restricted`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的服务，Hue-finance，并将其放在一个名为`restricted`的新命名空间中。
- en: 'Here is the YAML file for the new `restricted` namespace:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的`restricted`命名空间的YAML文件：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once the namespace has been created, we need to configure a context for the
    namespace. This will allow restricting access just to this namespace:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 创建命名空间后，我们需要为命名空间配置上下文。这将允许限制访问仅限于此命名空间：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s check our `cluster` configuration:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们的`cluster`配置：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, the current context is `restricted`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当前上下文是`restricted`。
- en: 'Now, in this empty namespace, we can create our `hue-finance` service, and
    it will be on its own:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这个空的命名空间中，我们可以创建我们的`hue-finance`服务，它将独立存在：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You don't have to switch contexts. You can also use the `--namespace=<namespace>`
    and `--all-namespaces` command-line switches.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要切换上下文。您还可以使用`--namespace=<namespace>`和`--all-namespaces`命令行开关。
- en: Launching jobs
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动作业
- en: Hue has a lot of long-running processes deployed as microservices, but it also
    has a lot of tasks that run, accomplish some goal, and exit. Kubernetes supports
    this functionality through the job resource. A Kubernetes job manages one or more
    pods and ensures that they run until success. If one of the pods managed by the
    job fails or is deleted, then the job will run a new pod until it succeeds.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Hue部署了许多长时间运行的微服务进程，但也有许多运行、完成某个目标并退出的任务。Kubernetes通过作业资源支持此功能。Kubernetes作业管理一个或多个pod，并确保它们运行直到成功。如果作业管理的pod中的一个失败或被删除，那么作业将运行一个新的pod直到成功。
- en: 'Here is a job that runs a Python process to compute the factorial of 5 (hint:
    it''s 120):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个运行Python进程计算5的阶乘的作业（提示：它是120）：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that the `restartPolicy` must be either `Never` or `OnFailure`. The default
    `Always` value is invalid because a job shouldn't restart after successful completion.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`restartPolicy`必须是`Never`或`OnFailure`。默认的`Always`值是无效的，因为作业在成功完成后不应重新启动。
- en: 'Let''s start the job and check its status:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动作业并检查其状态：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The pods of completed tasks are not displayed by default. You must use the
    `--show-all` option:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下不显示已完成任务的pod。您必须使用`--show-all`选项：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `factorial5` pod has a status of `Completed`. Let''s check out its output:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`factorial5` pod的状态为`Completed`。让我们查看它的输出：'
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Running jobs in parallel
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行运行作业
- en: You can also run a job with parallelism. There are two fields in the spec, called
    `completions` and `parallelism`. The `completions` are set to `1` by default.
    If you want more than one successful completion, then increase this value. `parallelism`
    determines how many pods to launch. A job will not launch more pods than needed
    for successful completions, even if the parallelism number is greater.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用并行运行作业。规范中有两个字段，称为`completions`和`parallelism`。`completions`默认设置为`1`。如果您需要多个成功完成，则增加此值。`parallelism`确定要启动多少个pod。作业不会启动比成功完成所需的更多的pod，即使并行数更大。
- en: 'Let''s run another job that just sleeps for `20` seconds until it has three
    successful completions. We''ll use a `parallelism` factor of `6`, but only three
    pods will be launched:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行另一个只睡眠`20`秒直到完成三次成功的作业。我们将使用`parallelism`因子为`6`，但只会启动三个pod：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Cleaning up completed jobs
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理已完成的作业
- en: 'When a job completes, it sticks around - and its pods do, too. This is by design,
    so you can look at logs or connect to pods and explore. But normally, when a job
    has completed successfully, it is not needed anymore. It''s your responsibility
    to clean up completed jobs and their pods. The easiest way is to simply delete
    the `job` object, which will delete all the pods too:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当作业完成时，它会保留下来 - 它的pod也是如此。这是有意设计的，这样您就可以查看日志或连接到pod并进行探索。但通常，当作业成功完成后，它就不再需要了。清理已完成的作业及其pod是您的责任。最简单的方法是简单地删除`job`对象，这将同时删除所有的pod：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Scheduling cron jobs
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安排cron作业
- en: Kubernetes cron jobs are jobs that run for a specified time, once or repeatedly.
    They behave as regular Unix cron jobs, specified in the `/etc/crontab` file.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes cron作业是在指定时间内运行一次或多次的作业。它们的行为类似于常规的Unix cron作业，指定在`/etc/crontab`文件中。
- en: 'In Kubernetes 1.4 they were known as a `ScheduledJob`. But, in Kubernetes 1.5,
    the name was changed to `CronJob`. Starting with Kubernetes 1.8, the `CronJob`
    resource is enabled by default in the API server and there no need to pass a `--runtime-config`
    flag anymore, but it''s still in `beta`. Here is the configuration to launch a
    cron job every minute to remind you to stretch. In the schedule, you may replace
    the `*` with `?`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes 1.4中，它们被称为`ScheduledJob`。但是，在Kubernetes 1.5中，名称更改为`CronJob`。从Kubernetes
    1.8开始，默认情况下在API服务器中启用了`CronJob`资源，不再需要传递`--runtime-config`标志，但它仍处于`beta`阶段。以下是启动一个每分钟提醒您伸展的cron作业的配置。在计划中，您可以用`?`替换`*`：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the pod spec, under the job template, I added a label called `name`. The
    reason is that cron jobs and their pods are assigned names with a random prefix
    by Kubernetes. The label allows you to easily discover all the pods of a particular
    cron job. See the following command lines:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在pod规范中，在作业模板下，我添加了一个名为`name`的标签。原因是Kubernetes会为cron作业及其pod分配带有随机前缀的名称。该标签允许您轻松发现特定cron作业的所有pod。请参阅以下命令行：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note that each invocation of a cron job launches a new `job` object with a
    new pod:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每次调用cron作业都会启动一个新的`job`对象和一个新的pod：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When a cron job invocation completes, its pod gets into a `Completed` state
    and will not be visible without the `-show-all` or `-a` flags:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当cron作业调用完成时，它的pod进入`Completed`状态，并且不会在没有`-show-all`或`-a`标志的情况下可见：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As usual, you can check the output of the pod of a completed cron job using
    the `logs` command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您可以使用`logs`命令来检查已完成的cron作业的pod的输出：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When you delete a cron job, it stops scheduling new jobs and deletes all the
    existing job objects along with all the pods it created.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当您删除一个cron作业时，它将停止安排新的作业，并删除所有现有的作业对象以及它创建的所有pod。
- en: 'You can use the designated label (the name is equal to `STRETCH` in this case)
    to locate all the job objects launched by the cron job. You can also suspend a
    cron job so it doesn''t create more jobs without deleting completed jobs and pods.
    You can also manage previous jobs by setting in the spec history limits: `spec.successfulJobsHistoryLimit`
    and `.spec.failedJobsHistoryLimit`.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用指定的标签（在本例中名称等于`STRETCH`）来定位由cron作业启动的所有作业对象。您还可以暂停cron作业，以便它不会创建更多的作业，而无需删除已完成的作业和pod。您还可以通过设置在spec历史限制中管理以前的作业：`spec.successfulJobsHistoryLimit`和`.spec.failedJobsHistoryLimit`。
- en: Mixing non-cluster components
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合非集群组件
- en: Most real-time system components in the Kubernetes cluster will communicate
    with out-of-cluster components. These could be completely external third-party
    services which are accessible through some API, but could also be internal services
    running in the same local network that, for various reasons, are not part of the
    Kubernetes cluster.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群中的大多数实时系统组件将与集群外的组件进行通信。这些可能是完全外部的第三方服务，可以通过某些API访问，但也可能是在同一本地网络中运行的内部服务，由于各种原因，这些服务不是Kubernetes集群的一部分。
- en: 'There are two categories here: inside-the-cluster-network and outside-the-cluster-network.
    Why is the distinction important?'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个类别：网络内部和网络外部。为什么这种区别很重要？
- en: Outside-the-cluster-network components
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群外网络组件
- en: These components have no direct access to the cluster. They can only access
    it through APIs, externally visible URLs, and exposed services. These components
    are treated just like any external user. Often, cluster components will just use
    external services, which pose no security issue. For example, in my previous job
    we had a Kubernetes cluster that reported exceptions to a third-party service
    ([https://sentry.io/welcome/](https://sentry.io/welcome/)). It was one-way communication
    from the Kubernetes cluster to the third-party service.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件无法直接访问集群。它们只能通过API、外部可见的URL和公开的服务来访问。这些组件被视为任何外部用户一样。通常，集群组件将只使用外部服务，这不会造成安全问题。例如，在我以前的工作中，我们有一个将异常报告给第三方服务的Kubernetes集群（[https://sentry.io/welcome/](https://sentry.io/welcome/)）。这是从Kubernetes集群到第三方服务的单向通信。
- en: Inside-the-cluster-network components
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络内部组件
- en: These are components that run inside-the-network but are not managed by Kubernetes.
    There are many reasons to run such components. They could be legacy applications
    that have not be Kubernetized yet, or some distributed data store that is not
    easy to run inside Kubernetes. The reason to run these components inside-the-network
    is for performance, and to have isolation from the outside world so that traffic
    between these components and pods can be more secure. Being part of the same network
    ensures low-latency, and the reduced need for authentication is both convenient
    and can avoid authentication overhead.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在网络内部运行但不受Kubernetes管理的组件。有许多原因可以运行这些组件。它们可能是尚未Kubernetized的传统应用程序，或者是一些不容易在Kubernetes内部运行的分布式数据存储。将这些组件运行在网络内部的原因是为了性能，并且与外部世界隔离，以便这些组件和pod之间的流量更加安全。作为相同网络的一部分确保低延迟，并且减少了身份验证的需求既方便又可以避免身份验证开销。
- en: Managing the Hue platform with Kubernetes
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes管理Hue平台
- en: 'In this section, we will look at how Kubernetes can help operate a huge platform
    such as Hue. Kubernetes itself provides a lot of capabilities to orchestrate pods
    and manage quotas and limits, detecting and recovering from certain types of generic
    failures (hardware malfunctions, process crashes, and unreachable services). But,
    in a complicated system such as Hue, pods and services may be up and running but
    in an invalid state or waiting for other dependencies in order to perform their
    duties. This is tricky because if a service or pod is not ready yet, but is already
    receiving requests, then you need to manage it somehow: fail (puts responsibility
    on the caller), retry (*how many times?* *for how long?* *how often?*), and queue
    for later (*who will manage this queue?*).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一下Kubernetes如何帮助操作像Hue这样的大型平台。Kubernetes本身提供了许多功能来编排Pod和管理配额和限制，检测和从某些类型的通用故障（硬件故障、进程崩溃和无法访问的服务）中恢复。但是，在Hue这样一个复杂的系统中，Pod和服务可能正在运行，但处于无效状态或等待其他依赖项以执行其职责。这很棘手，因为如果一个服务或Pod还没有准备好，但已经收到请求，那么你需要以某种方式管理它：失败（将责任放在调用者身上），重试（*多少次？*
    *多长时间？* *多频繁？*），并排队等待以后（*谁来管理这个队列？*）。
- en: It is often better if the system at large can be aware of the readiness state
    of different components, or if components are visible only when they are truly
    ready. Kubernetes doesn't know Hue, but it provides several mechanisms, such as
    liveness probes, readiness probes, and Init Containers, to support the application-specific
    management of your cluster.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果整个系统能够意识到不同组件的就绪状态，或者只有当组件真正就绪时才可见，通常会更好。Kubernetes并不了解Hue，但它提供了几种机制，如活跃性探针、就绪性探针和Init
    Containers，来支持你的集群的应用程序特定管理。
- en: Using liveness probes to ensure your containers are alive
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用活跃性探针来确保你的容器是活着的
- en: 'Kubectl watches over your containers. If a container process crashes, Kubelet
    will take care of it based on the restart policy. But this is not always enough.
    Your process may not crash, but instead run into an infinite loop or a deadlock.
    The restart policy might not be nuanced enough. With a liveness probe, you get
    to decide when a container is considered alive. Here is a pod template for the
    Hue music service. It has a `livenessProbe` section, which uses the `httpGet`
    probe. An HTTP probe requires a scheme (HTTP or HTTPS, default to HTTP, a host
    (which defaults to `PodIp`), a `path`, and a `port`). The probe is considered
    successful if the HTTP status is between `200` and `399`. Your container may need
    some time to initialize, so you can specify an `initialDelayInSeconds`. The Kubelet
    will not hit the liveness check during this period:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl监视着你的容器。如果容器进程崩溃，Kubelet会根据重启策略来处理它。但这并不总是足够的。你的进程可能不会崩溃，而是陷入无限循环或死锁。重启策略可能不够微妙。通过活跃性探针，你可以决定何时认为容器是活着的。这里有一个Hue音乐服务的Pod模板。它有一个`livenessProbe`部分，使用了`httpGet`探针。HTTP探针需要一个方案（HTTP或HTTPS，默认为HTTP），一个主机（默认为`PodIp`），一个`path`和一个`port`。如果HTTP状态码在`200`到`399`之间，探针被认为是成功的。你的容器可能需要一些时间来初始化，所以你可以指定一个`initialDelayInSeconds`。在这段时间内，Kubelet不会进行活跃性检查：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If a liveness probe fails for any container, then the pod's restart policy goes
    into effect. Make sure your restart policy is not *Never*, because that will make
    the probe useless.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何容器的活跃性探针失败，那么Pod的重启策略就会生效。确保你的重启策略不是*Never*，因为那会使探针变得无用。
- en: 'There are two other types of probe:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种其他类型的探针：
- en: '`TcpSocket`: Just check that a port is open'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TcpSocket`：只需检查端口是否打开'
- en: '`Exec`: Run a command that returns `0` for success'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exec`：运行一个返回`0`表示成功的命令'
- en: Using readiness probes to manage dependencies
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用就绪性探针来管理依赖关系
- en: Readiness probes are used for different purpose. Your container may be up and
    running, but it may depend on other services that are unavailable at the moment.
    For example, Hue-music may depend on access to a data service that contains your
    listening history. Without access, it is unable to perform its duties. In this
    case, other services or external clients should not send requests to the Hue music
    service, but there is no need to restart it. Readiness probes address this use
    case. When a readiness probe fails for a container, the container's pod will be
    removed from any service endpoint it is registered with. This ensures that requests
    don't flood services that can't process them. Note that you can also use readiness
    probes to temporarily remove pods that are overbooked until they drain some internal
    queue.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 就绪探针用于不同的目的。您的容器可能已经启动运行，但可能依赖于此刻不可用的其他服务。例如，Hue-music 可能依赖于访问包含您听歌历史记录的数据服务。如果没有访问权限，它将无法执行其职责。在这种情况下，其他服务或外部客户端不应该向
    Hue 音乐服务发送请求，但没有必要重新启动它。就绪探针解决了这种情况。当一个容器的就绪探针失败时，该容器的 pod 将从其注册的任何服务端点中移除。这确保请求不会涌入无法处理它们的服务。请注意，您还可以使用就绪探针暂时移除过载的
    pod，直到它们排空一些内部队列。
- en: 'Here is a sample readiness probe. I use the exec probe here to execute a `custom`
    command. If the command exits a non-zero exit code, the container will be torn
    down:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例就绪探针。我在这里使用 exec 探针来执行一个 `custom` 命令。如果命令退出时的退出代码为非零，容器将被关闭：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It is fine to have both a readiness probe and a liveness probe on the same container
    as they serve different purposes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个容器上同时拥有就绪探针和存活探针是可以的，因为它们有不同的用途。
- en: Employing Init Containers for orderly pod bring-up
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用初始化容器进行有序的 pod 启动
- en: Liveness and readiness probes are great. They recognize that, at startup, there
    may be a period where the container is not ready yet, but shouldn't be considered
    failed. To accommodate that there is the `initialDelayInSeconds` setting where
    containers will not be considered failed. But what if this initial delay is potentially
    very long? Maybe, in most cases, a container is ready after a couple of seconds
    and ready to process requests, but because the initial delay is set to five minutes
    just in case, we waste a lot of time when the container is idle. If the container
    is part of a high-traffic service, then many instances can all sit idle for five
    minutes after each upgrade and pretty much make the service unavailable.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 存活和就绪探针非常好用。它们认识到，在启动时，可能会有一个容器尚未准备好的时间段，但不应被视为失败。为了适应这一点，有一个 `initialDelayInSeconds`
    设置，容器在这段时间内不会被视为失败。但是，如果这个初始延迟可能非常长呢？也许，在大多数情况下，一个容器在几秒钟后就准备好处理请求了，但是因为初始延迟设置为五分钟以防万一，当容器处于空闲状态时，我们会浪费很多时间。如果容器是高流量服务的一部分，那么在每次升级后，许多实例都可能在五分钟后处于空闲状态，几乎使服务不可用。
- en: Init Containers address this problem. A pod may have a set of Init Containers
    that run to completion before other containers are started. An Init Container
    can take care of all the non-deterministic initialization and let application
    containers with their readiness probe have minimal delay.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化容器解决了这个问题。一个 pod 可能有一组初始化容器，在其他容器启动之前完成运行。初始化容器可以处理所有非确定性的初始化，并让应用容器通过它们的就绪探针尽量减少延迟。
- en: 'Init Containers came out of beta in Kubernetes 1.6\. You specify them in the
    pod spec as the `initContainers` field, which is very similar to the `containers`
    field. Here is an example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化容器在 Kubernetes 1.6 中退出了 beta 版。您可以在 pod 规范中指定它们，作为 `initContainers` 字段，这与
    `containers` 字段非常相似。以下是一个示例：
- en: '[PRE42]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Sharing with DaemonSet pods
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 DaemonSet pods 共享
- en: '`DaemonSet` pods are pods that are deployed automatically, one per node (or
    a designated subset of the nodes). They are typically used for keeping an eye
    on nodes and ensuring that they are operational. This is a very important function
    that we covered in Chapter 3, *Monitoring, Logging, and Troubleshooting*, when
    we discussed the node problem detector. But they can be used for much more. The
    nature of the default Kubernetes scheduler is that it schedules pods based on
    resource availability and requests. If you have lots of pods that don''t require
    a lot of resources, many pods will be scheduled on the same node. Let''s consider
    a pod that performs a small task and then, every second, sends a summary of all
    its activities to a remote service. Imagine that, on average, 50 of these pods
    are scheduled on the same node. This means that, every second, 50 pods make 50
    network requests with very little data. How about we cut it down by 50 times to
    just a single network request? With a `DaemonSet` pod, all the other 50 pods can
    communicate with it instead of talking directly to the remote service. The `DaemonSet`
    pod will collect all the data from the 50 pods and, once a second, will report
    it in aggregate to the remote service. Of course, that requires the remote service
    API to support aggregate reporting. The nice thing is that the pods themselves
    don''t have to be modified; they will just be configured to talk to the `DaemonSet`
    pod on localhost instead of the remote service. The `DaemonSet` pod serves as
    an aggregating proxy.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`DaemonSet` pods是自动部署的pod，每个节点一个（或指定节点的子集）。它们通常用于监视节点并确保它们正常运行。这是一个非常重要的功能，我们在第3章“监控、日志记录和故障排除”中讨论了节点问题检测器。但它们可以用于更多的功能。默认的Kubernetes调度程序的特性是根据资源可用性和请求来调度pod。如果有很多不需要大量资源的pod，许多pod将被调度到同一个节点上。让我们考虑一个执行小任务的pod，然后，每秒钟，将其所有活动的摘要发送到远程服务。想象一下，平均每秒钟会有50个这样的pod被调度到同一个节点上。这意味着，每秒钟，50个pod会进行50次几乎没有数据的网络请求。我们能不能将它减少50倍，只进行一次网络请求？使用`DaemonSet`
    pod，其他50个pod可以与其通信，而不是直接与远程服务通信。`DaemonSet` pod将收集来自50个pod的所有数据，并且每秒钟将其汇总报告给远程服务。当然，这需要远程服务API支持汇总报告。好处是pod本身不需要修改；它们只需配置为与`DaemonSet`
    pod在本地主机上通信，而不是与远程服务通信。`DaemonSet` pod充当聚合代理。'
- en: 'The interesting part about this configuration file is that the `hostNetwork`,
    `hostPID`, and `hostIPC` options are set to `true`. This enables the pods to communicate
    efficiently with the proxy, utilizing the fact that they are running on the same
    physical host:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置文件的有趣之处在于，`hostNetwork`、`hostPID`和`hostIPC`选项都设置为`true`。这使得pod能够有效地与代理通信，利用它们在同一物理主机上运行的事实。
- en: '[PRE43]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Evolving the Hue platform with Kubernetes
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes发展Hue平台
- en: In this section, we'll discuss other ways to extend the Hue platform and service
    additional markets and communities. The question is always, *What Kubernetes features
    and capabilities can we use to address new challenges or requirements?*
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论扩展Hue平台和服务其他市场和社区的其他方法。问题始终是，“我们可以使用哪些Kubernetes功能和能力来解决新的挑战或要求？”
- en: Utilizing Hue in enterprises
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在企业中利用Hue
- en: Enterprises often can't run in the cloud, either due to security and compliance
    reasons, or for performance reasons because the system has work with data and
    legacy systems that are not cost-effective to move to the cloud. Either way, Hue
    for enterprise must support on-premise clusters and/or bare-metal clusters.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 企业通常无法在云中运行，要么是因为安全和合规性原因，要么是因为性能原因，因为系统必须处理数据和传统系统，这些系统不适合迁移到云上。无论哪种情况，企业的Hue必须支持本地集群和/或裸金属集群。
- en: While Kubernetes is most often deployed on the cloud, and even has a special
    cloud-provider interface, it doesn't depend on the cloud and can be deployed anywhere.
    It does require more expertise, but enterprise organizations that already run
    systems on their own datacenters have that expertise.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Kubernetes最常部署在云上，甚至有一个特殊的云提供商接口，但它并不依赖于云，可以在任何地方部署。它需要更多的专业知识，但已经在自己的数据中心上运行系统的企业组织拥有这方面的专业知识。
- en: CoreOS provides a lot of material regarding deploying Kubernetes clusters on
    bare-metal lusters.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS提供了大量关于在裸机集群上部署Kubernetes集群的材料。
- en: Advancing science with Hue
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Hue推动科学的进步
- en: Hue is so great at integrating information from multiple sources that it would
    be a boon for the scientific community. Consider how Hue can help multi-disciplinary
    collaborations between scientists from different areas.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Hue在整合来自多个来源的信息方面非常出色，这对科学界将是一个福音。想象一下Hue如何帮助来自不同领域的科学家进行多学科合作。
- en: A network of scientific communities might require deployment across multiple
    geographically-distributed clusters. Enter cluster federation. Kubernetes has
    this use case in mind and evolves its support. We will discuss it at length in
    a later chapter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 科学社区的网络可能需要在多个地理分布的集群上部署。这就是集群联邦。Kubernetes考虑到了这种用例，并不断发展其支持。我们将在后面的章节中详细讨论这个问题。
- en: Educating the kids of the future with Hue
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Hue教育未来的孩子
- en: Hue can be utilized for education and provide many services to online education
    systems. But privacy concerns may prevent deploying Hue for kids as a single,
    centralized system. One possibility is to have a single cluster, with namespaces
    for different schools. Another deployment option is that each school or county
    has its own Hue Kubernetes cluster. In the second case, Hue for education must
    be extremely easy to operate to cater for schools without a lot of technical expertise.
    Kubernetes can help a lot by providing self-healing and auto-scaling features
    and capabilities for Hue, to be as close to zero-administration as possible.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Hue可以用于教育，并为在线教育系统提供许多服务。但隐私问题可能会阻止将Hue作为单一的集中系统用于儿童。一个可能的选择是建立一个单一的集群，为不同学校设立命名空间。另一个部署选项是每个学校或县都有自己的Hue
    Kubernetes集群。在第二种情况下，Hue教育必须非常易于操作，以满足没有太多技术专长的学校。Kubernetes可以通过提供自愈和自动扩展功能来帮助Hue，使其尽可能接近零管理。
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we designed and planned the development, deployment, and management
    of the Hue platform - an imaginary omniscient and omnipotent service - built on
    microservices architecture. We used Kubernetes as the underlying orchestration
    platform, of course, and delved into many of its concepts and resources. In particular,
    we focused on deploying pods for long-running services, as opposed to jobs for
    launching short-term or cron jobs, explored internal services versus external
    services, and also used namespaces to segment a Kubernetes cluster. Then we looked
    at the management of a large system such as Hue with liveness and readiness probes,
    Init Containers, and DaemonSets.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设计和规划了Hue平台的开发、部署和管理——一个想象中的全知全能的服务，建立在微服务架构上。当然，我们使用Kubernetes作为底层编排平台，并深入探讨了许多它的概念和资源。特别是，我们专注于为长期运行的服务部署pod，而不是为启动短期或定期作业部署作业，探讨了内部服务与外部服务，还使用命名空间来分割Kubernetes集群。然后，我们研究了像活跃性和就绪性探针、初始化容器和守护进程集这样的大型系统的管理。
- en: You should now feel comfortable architecting web-scale systems composed of microservices,
    and understand how to deploy and manage them in a Kubernetes cluster.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够设计由微服务组成的Web规模系统，并了解如何在Kubernetes集群中部署和管理它们。
- en: In the next chapter, we will look into the super-important area of storage.
    Data is king, but often the least-flexible element of the system. Kubernetes provides
    a storage model, and many options for integrating with various storage solutions.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究存储这个非常重要的领域。数据为王，但通常是系统中最不灵活的元素。Kubernetes提供了一个存储模型，并提供了许多与各种存储解决方案集成的选项。
