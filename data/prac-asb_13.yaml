- en: Container and Cloud Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器和云管理
- en: Ansible is a very flexible automation tool and can be easily used to automate
    any aspect of your infrastructure. In the last few years, container-based workloads
    and cloud workloads have become more and more popular, and for this reason, we
    are going to look at how you can automate tasks related to those kinds of workloads
    with Ansible. In this chapter, we will start by designing and building containers
    with Ansible. We will then look at how to run those containers, and finally, we
    will look at ways to manage various cloud platforms with Ansible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个非常灵活的自动化工具，可以轻松用于自动化基础架构的任何方面。在过去几年中，基于容器的工作负载和云工作负载变得越来越受欢迎，因此我们将看看如何使用Ansible自动化与这些工作负载相关的任务。在本章中，我们将首先使用Ansible设计和构建容器。然后，我们将看看如何运行这些容器，最后，我们将看看如何使用Ansible管理各种云平台。
- en: 'Specifically, we will be covering the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，本章将涵盖以下主题：
- en: Designing and building containers with playbooks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用playbooks设计和构建容器
- en: Managing multiple container platforms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理多个容器平台
- en: Automating Docker with Ansible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible自动化Docker
- en: Exploring container-focused modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索面向容器的模块
- en: Automating against Amazon Web Services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对亚马逊网络服务的自动化
- en: Complementing Google Cloud Platform with automation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过自动化来补充谷歌云平台
- en: Seamless automation integration to Azure
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Azure的无缝自动化集成
- en: Expanding your environment with Rackspace Cloud
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Rackspace Cloud扩展您的环境
- en: Using Ansible to orchestrate OpenStack
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible编排OpenStack
- en: Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [Chapter 1](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml), *Getting
    Started with Ansible*, and are using the most recent version available – the examples
    in this chapter were tested with Ansible 2.9\. Although we will give specific
    examples of hostnames in this chapter, you are free to substitute them with your
    own hostname and/or IP addresses. Details of how to do this will be provided in
    the appropriate places. This chapter also assumes you have access to a Docker
    host, and although it's possible to install Docker on the majority – if not all – operating
    systems, all the commands provided in this chapter are for GNU/Linux and have
    been tested solely on this platform.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经按照[第1章](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml) *开始使用Ansible*中详细说明的方式设置了Ansible的控制主机，并且正在使用最新版本——本章的示例是在Ansible
    2.9版本下测试的。尽管本章将给出特定的主机名示例，但您可以自由地用您自己的主机名和/或IP地址替换它们。如何做到这一点的细节将在适当的地方提供。本章还假设您可以访问Docker主机，尽管在大多数操作系统上都可以安装Docker，但本章提供的所有命令都是针对GNU/Linux的，并且仅在该平台上进行了测试。
- en: All the examples in this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%2010](https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%2010).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例都可以在本书的GitHub存储库中找到：[https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%2010](https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%2010)。
- en: Designing and building containers with playbooks
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用playbooks设计和构建容器
- en: Building containers with Dockerfiles is probably the most common way of doing
    this, but this does not mean that this is the best way.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Dockerfile构建容器可能是最常见的方法，但这并不意味着这是最好的方法。
- en: First of all, even if you are in a very good place in your automation path and
    you have a lot of Ansible roles written for your infrastructure, you can't leverage
    them in Dockerfiles, so you would end up replicating your work to create containers.
    Aside from the time required to do this and the fact that you need to learn a
    new language to do so, it is very rare that a company is able to drop all their
    infrastructure and switch to containers overnight. This means that you need to
    keep two copies of the same automation section active and up-to-date, thus putting
    yourself in the position to make mistakes and have inconsistent behaviors between
    environments.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，即使您在自动化路径上处于非常良好的位置，并且为您的基础架构编写了许多Ansible角色，您也无法在Dockerfile中利用它们，因此您最终会复制您的工作来创建容器。除了需要花费时间和需要学习一种新语言之外，公司很少能够在一夜之间放弃他们的基础架构并转向容器。这意味着您需要保持两个相同的自动化部分处于活动状态并保持最新，从而使自己处于犯错误和环境之间不一致行为的位置。
- en: If this is not enough of a problem, this situation quickly deteriorates when
    you start considering cloud environments. All cloud environments have their own
    control planes and native automation languages, so in a very short time, you would
    find yourself rewriting the automation for the same operation over and over, thus
    wasting time and deteriorating the consistency of your environments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不够成问题，当您开始考虑云环境时，情况很快就会恶化。所有云环境都有自己的控制平面和本地自动化语言，因此在很短的时间内，您会发现自己一遍又一遍地重写相同操作的自动化，从而浪费时间并破坏环境的一致性。
- en: 'Ansible provides `ansible-container` so that you can create containers using
    the same components you would use for creating machines. The first thing you should
    do is ensure that you have `ansible-container` installed. There are a few ways
    to install it, but the most straightforward is using `pip`. To do so, you can
    run the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible提供了`ansible-container`，以便您可以使用与创建机器相同的组件来创建容器。您应该做的第一件事是确保您已经安装了`ansible-container`。有几种安装它的方法，但最简单的方法是使用`pip`。为此，您可以运行以下命令：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `ansible-container` tool comes with three supported engines at the time
    of writing:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible-container`工具在撰写本文时带有三个支持的引擎：'
- en: '`docker`: This is needed if you want to use it with Docker Engine (that is,
    on your local machine).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker`：如果您想要在Docker引擎（即在您的本地机器上）中使用它，就需要它。'
- en: '`k8s`: This is needed if you want to use it with a Kubernetes cluster, both
    local (that is, MiniKube) or remote (that is, a production cluster).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k8s`：如果您想要在Kubernetes集群中使用它，无论是本地（即MiniKube）还是远程（即生产集群）都需要它。'
- en: '`openshift`: This is needed if you want to use it with an OpenShift cluster,
    both local (that is, MiniShift) or remote (that is, a production cluster).'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openshift`：如果你想要在OpenShift集群中使用它，无论是本地（即MiniShift）还是远程（即生产集群）。'
- en: 'Follow these steps to build the container using playbooks:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用playbooks构建容器：
- en: 'Issuing the `ansible-container init` command will give us the following output:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出`ansible-container init`命令将给我们以下输出：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Running this command will also create the following files:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个命令还将创建以下文件：
- en: '`ansible.cfg`: An empty file to be (eventually) used to override Ansible system
    configurations'
  id: totrans-30
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible.cfg`：一个空文件，用于（最终）用于覆盖Ansible系统配置'
- en: '`ansible-requirements.txt`: An empty file to (eventually) list the Python requirements
    for the building process of your containers'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-requirements.txt`：一个空文件，用于（最终）列出构建过程中容器的Python要求'
- en: '`container.yml`: A file that contains the Ansible code for the build'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container.yml`：一个包含构建的Ansible代码的文件'
- en: '`meta.yml`: A file that contains the metadata for Ansible Galaxy'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta.yml`：一个包含Ansible Galaxy元数据的文件'
- en: '`requirements.yml`: An empty file to (eventually) list the Ansible roles that
    are required for your build'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requirements.yml`：一个空文件，用于（最终）列出构建所需的Ansible角色'
- en: 'Let''s try building our own container using this tool – replace the contents
    of `container.yml` with the following:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试使用这个工具构建我们自己的容器-用以下内容替换`container.yml`的内容：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can now run `ansible-container build` to initiate the build.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行`ansible-container build`来启动构建。
- en: At the end of the building process, we will have a container built with the
    `geerlingguy.apache` role applied to it. The `ansible-container` tool performs
    a multi-stage build capability, spinning up an Ansible container that is then
    used to build the real container.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程结束时，我们将得到一个应用了`geerlingguy.apache`角色的容器。`ansible-container`工具执行多阶段构建能力，启动一个用于构建真实容器的Ansible容器。
- en: If we specified more than one role to be applied, the output would be an image
    with more layers, since Ansible will create a layer for every specified role.
    In this way, containers can easily be built using your existing Ansible roles
    rather than Dockerfiles.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指定了多个要应用的角色，输出将是一个具有更多层的图像，因为Ansible将为每个指定的角色创建一个层。这样，容器可以很容易地使用现有的Ansible角色构建，而不是Dockerfiles。
- en: Now that you have learned how to design and building containers with playbooks,
    you'll learn how to manage multiple container platforms.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用playbooks设计和构建容器，接下来你将学习如何管理多个容器平台。
- en: Managing multiple container platforms
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理多个容器平台
- en: In today's world, simply being able to run an image is not considered a production-ready
    setup.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的世界中，仅仅能够运行一个镜像并不被认为是一个可以投入生产的设置。
- en: To be able to call a deployment "production-ready," you need to be able to demonstrate
    that the service your application is delivering will run reasonably, even in the
    case of a single application crash, as well as hardware failure. Often, you'll
    have even more reliability constraints from your customer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够称呼一个部署为“投入生产使用”，你需要能够证明你的应用程序提供的服务将在合理的情况下运行，即使是在单个应用程序崩溃或硬件故障的情况下。通常，你的客户会有更多的可靠性约束。
- en: Luckily, your software is not the only data that has those requirements, so
    orchestration solutions have been developed for this purpose.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你的软件并不是唯一具有这些要求的数据，因此为此目的开发了编排解决方案。
- en: Today, the most successful one is Kubernetes due to its various distributions/versions,
    so we are going to focus on it primarily.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，最成功的一个是Kubernetes，因为它有各种不同的发行版/版本，所以我们将主要关注它。
- en: The idea of Kubernetes is that you inform the Kubernetes Control Plane that
    you want X number of instances of your Y application, and Kubernetes will count
    how many instances of the Y application are running on the Kubernetes Nodes to
    ensure that the number of instances are X. If there are too few instances, Kubernetes
    will take care to start more instances, while if there are too many instances,
    the exceeding instances will be stopped.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的理念是，你告诉Kubernetes控制平面你想要X个实例的Y应用程序，Kubernetes将计算运行在Kubernetes节点上的Y应用程序实例数量，以确保实例数量为X。如果实例太少，Kubernetes将负责启动更多实例，而如果实例太多，多余的实例将被停止。
- en: Since Kubernetes constantly checks that the requested amount of instances are
    running, in the case of an application failure or a node failure, Kubernetes will
    restart the lost instances.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Kubernetes不断检查所请求的实例数量是否在运行中，所以在应用程序失败或节点失败的情况下，Kubernetes将重新启动丢失的实例。
- en: Due to the complexity of installing and managing Kubernetes, multiple companies
    have started to sell distributions of Kubernetes that simplify their operations
    and that they are willing to support.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安装和管理Kubernetes的复杂性，多家公司已经开始销售简化其运营的Kubernetes发行版，并且他们愿意提供支持。
- en: 'The most widely used distribution by far, at the moment, is OpenShift: the
    Red Hat Kubernetes distribution.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 目前使用最广泛的发行版是OpenShift：红帽Kubernetes发行版。
- en: To simplify the life of the developers and operation teams, Ansible provides
    `ansible-container`, which, as we saw in the previous section, is a tool that's
    used to create containers, as well as to support the whole life cycle of the container
    itself.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化开发人员和运维团队的生活，Ansible提供了`ansible-container`，正如我们在前一节中所看到的，这是一个用于创建容器以及支持容器整个生命周期的工具。
- en: Deploying to Kubernetes with ansible-container
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ansible-container部署到Kubernetes
- en: Let's learn how to run the image we just built with `ansible-container`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何运行刚刚用`ansible-container`构建的镜像。
- en: First of all, we need the image itself, and you should have it since this is
    the output of the previous section!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要镜像本身，你应该已经有了，因为这是上一节的输出！
- en: 'We will assume that you have access to either a Kubernetes or OpenShift cluster
    for testing. Setting these up is out the scope of this book, so you might want
    to look at a distribution such as Minikube or Minishift, both of which are designed
    to be quick and easy to set up so that you can start learning these technologies
    rapidly. We also need to have the `kubectl` client or the `oc` client, based on
    the fact that we have deployed Kubernetes or OpenShift, properly configured. Let''s
    get started:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您可以访问用于测试的Kubernetes或OpenShift集群。设置这些超出了本书的范围，因此您可能希望查看Minikube或Minishift等分发版，这两者都旨在快速且易于设置，以便您可以快速开始学习这些技术。我们还需要正确配置`kubectl`客户端或`oc`客户端，根据我们部署的是Kubernetes还是OpenShift。让我们开始吧：
- en: 'To deploy your application to your cluster, you need to change the `container.yml`
    file so that you can add some additional information. More specifically, we will
    need to add a section called `settings` and a section called `k8s_namespace` to
    declare our deployment settings. This section will look something like this:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将应用程序部署到集群，您需要更改`container.yml`文件，以便添加一些附加信息。更具体地说，我们需要添加一个名为`settings`和一个名为`k8s_namespace`的部分来声明我们的部署设置。此部分将如下所示：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have added the necessary information about the Kubernetes deployment,
    we can proceed with the deployment:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经添加了关于Kubernetes部署的必要信息，我们可以继续部署：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As soon as Ansible has completed its execution, you will be able to find the
    `http-server` deployment on your Kubernetes cluster.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Ansible完成执行，您将能够在Kubernetes集群上找到`http-server`部署。
- en: What happens behind the scenes is that Ansible has a set of modules (whose name
    usually starts with `k8s`) that are used to drive a Kubernetes cluster, and it
    uses them to deploy the application automatically.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 幕后发生的是，Ansible有一组模块（其名称通常以`k8s`开头），用于驱动Kubernetes集群，并使用它们自动部署应用程序。
- en: Based on the image that we built in the previous section and the additional
    information we added at the beginning of this section, Ansible is able to populate
    a deployment template and then deploy it using the `k8s` module.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在上一节中构建的图像和本节开头添加的其他信息，Ansible能够填充部署模板，然后使用`k8s`模块部署它。
- en: Now that you have learned how to deploy your container on a Kubernetes cluster,
    you'll learn how to interact with the Kubernetes cluster with Ansible.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何在Kubernetes集群上部署容器，接下来您将学习如何使用Ansible与Kubernetes集群进行交互。
- en: Managing Kubernetes objects with Ansible
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible管理Kubernetes对象
- en: Now that you have deployed your first application with `ansible-container`,
    it would be useful to interact with this application. It can come in handy to
    obtain information around the state of your Kubernetes objects or to deploy an
    application to it, and more generally, to interact with the Kubernetes APIs without
    `ansible-containers`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经使用`ansible-container`部署了第一个应用程序，与该应用程序进行交互将非常有用。获取有关Kubernetes对象状态的信息或部署应用程序，更一般地与Kubernetes
    API进行交互，而无需使用`ansible-containers`。
- en: Installing Ansible Kubernetes dependencies
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Ansible Kubernetes依赖项
- en: First of all, you need to install the Python `openshift` package (you can install
    it either via pip or via your OS packaging system).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要安装Python `openshift`包（您可以通过pip或操作系统的打包系统安装它）。
- en: We are now ready for our first Kubernetes playbook!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好我们的第一个Kubernetes playbook了！
- en: Listing Kubernetes namespaces with Ansible
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible列出Kubernetes命名空间
- en: 'A Kubernetes cluster has multiple namespaces internally, and you can usually
    find the ones a cluster has with `kubectl get namespaces`. You can do the same
    with Ansible by creating a file called `k8s-ns-show.yaml` with the following content:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群在内部有多个命名空间，通常可以使用`kubectl get namespaces`找到集群中的命名空间。您可以通过创建一个名为`k8s-ns-show.yaml`的文件来使用Ansible执行相同的操作，内容如下：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can now execute this, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以执行此操作，如下所示：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You will now see information regarding the namespaces in the output.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您将在输出中看到有关命名空间的信息。
- en: 'Notice that in the seventh line of the code (`kind: Namespace`), we are specifying
    the type of resources we are interested in. You can specify other Kubernetes object
    types to see them (for example, you can try this with Deployments, Services, and
    Pods).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意代码的第七行（`kind: Namespace`），我们在其中指定了我们感兴趣的资源类型。您可以指定其他Kubernetes对象类型以查看它们（例如，您可以尝试使用部署、服务和Pod进行此操作）。'
- en: Creating a Kubernetes namespace with Ansible
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible创建Kubernetes命名空间
- en: 'So far, we have learned how to show existing namespaces, but usually, Ansible
    is used in a declarative way to achieve a desired state. So, let''s create a new
    playbook called `k8s-ns.yaml` with the following content:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了如何显示现有的命名空间，但通常，Ansible被用于以声明方式实现期望的状态。因此，让我们创建一个名为`k8s-ns.yaml`的新的playbook，内容如下：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Before running it, we can execute `kubectl get ns` so that we can ensure `myns`
    is not present. In my case, the output is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行之前，我们可以执行`kubectl get ns`，以确保`myns`不存在。在我的情况下，输出如下：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now run the playbook with the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下命令运行playbook：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output should resemble the following one:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, Ansible reports that it changed the namespace state. If I execute
    `kubectl get ns` again, is clear that Ansible created the namespace we were expecting:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Ansible报告说它改变了命名空间的状态。如果我再次执行`kubectl get ns`，很明显Ansible创建了我们期望的命名空间：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, let's create a Service.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个服务。
- en: Creating a Kubernetes Service with Ansible
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible创建Kubernetes服务
- en: 'So far, we have seen how to create namespaces from Ansible, so now, let''s
    put a Service in the namespace we just created. Let''s create a new playbook called
    `k8s-svc.yaml` with the following content:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何从Ansible创建命名空间，现在让我们在刚刚创建的命名空间中放置一个服务。让我们创建一个名为`k8s-svc.yaml`的新playbook，内容如下：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Before running it, we can execute `kubectl get svc` to ensure that the namespace
    has no Services. Make sure you''re in the right namespace before running it! In
    my case, the output is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行之前，我们可以执行`kubectl get svc`来确保命名空间中没有服务。在运行之前，请确保您在正确的命名空间中！在我的情况下，输出如下：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now run it with the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下命令运行它：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output should resemble the following one:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, Ansible reports that it changed the Service state. If I execute
    `kubectl get svc` again, is clear that Ansible created the Service we were expecting:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Ansible报告说它改变了服务状态。如果我再次执行`kubectl get svc`，很明显Ansible创建了我们期望的服务：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we followed the same procedure that we used in the namespace
    case, but we specified a different Kubernetes object type and specified the various
    parameters that are needed for the Service type. You can do the same for all other
    Kubernetes object types.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们遵循了在命名空间情况下使用的相同过程，但是我们指定了不同的Kubernetes对象类型，并指定了所需的服务类型的各种参数。您可以对所有其他Kubernetes对象类型执行相同的操作。
- en: Now that you have learned how to deal with Kubernetes clusters, you'll learn
    how to automate Docker with Ansible.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何处理Kubernetes集群，您将学习如何使用Ansible自动化Docker。
- en: Automating Docker with Ansible
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible自动化Docker
- en: Docker is now a very common and ubiquitous tool. In production, it is often
    managed by an orchestrator (or at least it should be, in the majority of cases),
    but in development, environments are often used directly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Docker现在是一个非常常见和普遍的工具。在生产中，它通常由编排器管理（或者至少应该在大多数情况下），但在开发中，环境通常直接使用。
- en: With Ansible, you can easily manage your Docker instance.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ansible，您可以轻松管理您的Docker实例。
- en: 'Since we are going to manage a Docker instance, we need to make sure we have
    one at hand and that the `docker` command on our machine is configured properly.
    We need to do this to ensure this is enough to run `docker images` on the Terminal.
    Let''s say you get a result similar to the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将要管理一个Docker实例，我们需要确保我们手头有一个，并且我们机器上的`docker`命令已经正确配置。我们需要这样做以确保在终端上运行`docker
    images`足够。假设您得到类似以下的结果：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This means that everything is working properly. More lines may be provided as
    output if you have already-cloned images.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一切都正常工作。如果您已经克隆了镜像，可能会提供更多行作为输出。
- en: 'On the other hand, let''s say it returns something like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，假设它返回了类似于这样的东西：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This means that we don't have a Docker daemon running or that our Docker console
    has been configured incorrectly.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们没有运行Docker守护程序，或者我们的Docker控制台配置不正确。
- en: 'Also, it''s important to ensure that you have the `docker` Python module since
    Ansible will try to use it to communicate with the Docker daemon. Let''s take
    a look:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，确保您有`docker` Python模块是很重要的，因为Ansible将尝试使用它与Docker守护程序进行通信。让我们来看一下：
- en: 'First of all, we need to create a playbook called `start-docker-container.yaml`
    that will contain the following code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个名为`start-docker-container.yaml`的playbook，其中包含以下代码：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have the Ansible playbook, we just need to execute it:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了Ansible playbook，我们只需要执行它：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you may expect, it will give you an output similar to the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能期望的那样，它将给您一个类似于以下的输出：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now check that our command executed properly, as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以检查我们的命令是否正确执行，如下所示：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will show the container that was run:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示运行的容器：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This proves that a container was executed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了一个容器被执行。
- en: 'To check that the `echo` command was executed, we can run the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查`echo`命令是否被执行，我们可以运行以下代码：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will return the following output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this section, we executed the `docker_container` module. This is not the
    only module Ansible has to control the Docker daemon, but it is probably one of
    the most widely used since it's used to control containers running on Docker.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们执行了`docker_container`模块。这不是Ansible用来控制Docker守护程序的唯一模块，但它可能是最广泛使用的模块之一，因为它用于控制在Docker上运行的容器。
- en: 'Other modules include the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模块包括以下内容：
- en: '`docker_config`: Used to change the configurations of the Docker daemon'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker_config`：用于更改Docker守护程序的配置'
- en: '`docker_container_info`: Used to gather information from (inspect) a container'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker_container_info`：用于从容器中收集信息（检查）'
- en: '`docker_network`: Used to manage Docker networking configuration'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker_network`：用于管理Docker网络配置'
- en: 'There are also many modules that start with `docker_` but are actually used
    to manage Docker Swarm clusters, and not Docker instances. Some examples are as
    follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多以`docker_`开头的模块，但实际上用于管理Docker Swarm集群，而不是Docker实例。一些示例如下：
- en: '`docker_node`: Used to manage a node in a Docker Swarm cluster'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker_node`：用于管理Docker Swarm集群中的节点'
- en: '`docker_node_info`: Used to retrieve information about a specific node in a
    Docker Swarm cluster'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker_node_info`：用于检索Docker Swarm集群中特定节点的信息'
- en: '`docker_swarm_info`: Used to retrieve information about a Docker Swarm cluster'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker_swarm_info`：用于检索有关Docker Swarm集群的信息'
- en: As we will see in the next section, there many more modules that can be used
    to manage containers that are orchestrated in various ways.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一节中看到的，还有许多模块可以用来管理以各种方式编排的容器。
- en: Now that you have learned how to automate Docker with Ansible, you will explore
    container-focused modules.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何使用Ansible自动化Docker，您将探索面向容器的模块。
- en: Exploring container-focused modules
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索面向容器的模块
- en: Often, when organizations grow, they start to use multiple technologies in different
    parts of the organization. Another thing that usually happens is that after a
    department has found that a vendor worked well for them, they will be more inclined
    to try new technologies offered by this vendor. A mix of those two factors and
    time (usually, fewer technologies cycles) will end up creating multiple solutions
    for the same problem within the same organization.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当组织发展壮大时，他们开始在组织的不同部分使用多种技术。通常发生的另一件事是，部门发现某个供应商对他们很有效后，他们更倾向于尝试该供应商提供的新技术。这两个因素的混合以及时间（通常情况下，技术周期较少）最终会在同一组织内为同一个问题创建多种解决方案。
- en: If your organization is in this situation with containers, Ansible can come
    to rescue, thanks to its ability to interoperate with the majority of, if not
    all, container platforms.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的组织处于这种容器的情况下，Ansible可以帮助您，因为它能够与大多数，如果不是所有的容器平台进行互操作。
- en: Many times, the biggest problem to do something with Ansible is finding the
    name of the modules you need to use to achieve what you want to achieve. In this
    section, we will try to help in this effort, mainly in terms of the containerization
    space, but this might help you in the quest to find different kinds of modules.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，使用Ansible的最大问题是找到你需要使用的模块的名称，以实现你想要实现的目标。在本节中，我们将尝试帮助您解决这个问题，主要是在容器化领域，但这可能也有助于您寻找不同类型的模块。
- en: The starting point for all Ansible module research should be the Module index
    ([https://docs.ansible.com/ansible/latest/modules/modules_by_category.html](https://docs.ansible.com/ansible/latest/modules/modules_by_category.html)).
    Very often, you can find a category that is clearly a match for what you are looking
    for, but this is not always the case.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Ansible模块研究的起点应该是模块索引（[https://docs.ansible.com/ansible/latest/modules/modules_by_category.html](https://docs.ansible.com/ansible/latest/modules/modules_by_category.html)）。通常情况下，您可以找到一个明显与您寻找的内容匹配的类别，但情况并非总是如此。
- en: Containers are one of those exceptions (at least at the time of writing), and
    therefore there is no "containers" category. The solution is to go to All modules.
    From here, you can search by using your browser's built-in feature (usually, this
    can be reached by using *Ctrl*+*F*) to find the strings that might match the package
    name or short description.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是这种例外情况之一（至少在撰写本文时是如此），因此没有“容器”类别。解决方案是转到所有模块。从这里，您可以使用浏览器的内置功能进行搜索（通常可以通过使用*Ctrl*+*F*来实现），以找到可能与包名称或简短描述匹配的字符串。
- en: Every module in Ansible is classified in one category, but very often, modules
    fit more than one category, so it's not always easy to find them.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible中的每个模块都属于一个类别，但很多时候，模块适用于多个类别，因此并不总是容易找到它们。
- en: For instance, many Ansible modules relative to container Services are in the
    Cloud modules category (ECS, Docker, LXC, LXD, and Podman), while others are in
    the Clustering modules category (Kubernetes, OpenShift, and so on).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，许多与容器服务相关的Ansible模块属于云模块类别（ECS、Docker、LXC、LXD和Podman），而其他模块属于集群模块类别（Kubernetes、OpenShift等）。
- en: To help you further, let's take a look at some of the main container platforms
    and the main modules Ansible provides.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步帮助您，让我们来看一下一些主要的容器平台和Ansible提供的主要模块。
- en: Amazon Web Services, back in 2014, launched **Elastic Container Service** (**ECS**),
    which is a way to deploy and orchestrate Docker containers within their infrastructure.
    In the following year, **Amazon Web Services** (**AWS**) also launched **Elastic
    Container Registry** (**ECR**), a managed Docker Registry service. The service
    did not become as ubiquitous as AWS hoped, so in 2018, AWS launched **Elastic
    Kubernetes Service** (**EKS**) to allow people that wanted to run Kubernetes on
    AWS to have a managed service. If you are using or plan to use EKS, this is just
    a standard managed Kubernetes cluster, so you can use the Kubernetes-specific
    modules that we are going to cover shortly. If you decide to use ECS, there are
    several modules that can help you. The most important ones are `ecs_cluster`,
    which allows you to create or terminate ECS clusters; `ecs_ecr`, which allows
    you to manage ECR; `ecs_service`, which allows you to create, terminate, start,
    or stop a service in ECS; and `ecs_task`, which allows you to run, start, or stop
    a task in ECS. In addition to those, there are `ecs_service_facts` that allow
    Ansible to list or describe services in ECS.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年，亚马逊网络服务推出了弹性容器服务（ECS），这是一种在其基础设施中部署和编排Docker容器的方式。在接下来的一年，亚马逊网络服务还推出了弹性容器注册表（ECR），这是一个托管的Docker注册表服务。该服务并没有像AWS希望的那样普及，因此在2018年，AWS推出了弹性Kubernetes服务（EKS），以允许希望在AWS上运行Kubernetes的人拥有一个托管服务。如果您正在使用或计划使用EKS，这只是一个标准的托管Kubernetes集群，因此您可以使用我们即将介绍的Kubernetes特定模块。如果您决定使用ECS，有几个模块可以帮助您。最重要的是`ecs_cluster`，它允许您创建或终止ECS集群；`ecs_ecr`，它允许您管理ECR；`ecs_service`，它允许您在ECS中创建、终止、启动或停止服务；以及`ecs_task`，它允许您在ECS中运行、启动或停止任务。除此之外，还有`ecs_service_facts`，它允许Ansible列出或描述ECS中的服务。
- en: 'Microsoft Azure, in 2018, announced **Azure Container Service** (**ACS**),
    and then announced **Azure Kubernetes Service** (**AKS**). These services are
    managed by Kubernetes solutions, so they can both be managed with the Kubernetes
    modules. In addition to those, Ansible provided two specific modules: the `azure_rm_acs`
    module allows us to create, update, and delete Azure Container Service instances,
    while the `azure_rm_aks` module allows us to create, update, and delete Azure
    Kubernetes Service instances.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年，微软Azure宣布了Azure容器服务（ACS），然后宣布了Azure Kubernetes服务（AKS）。这些服务由Kubernetes解决方案管理，因此可以使用Kubernetes模块来管理。除此之外，Ansible还提供了两个特定的模块：`azure_rm_acs`模块允许我们创建、更新和删除Azure容器服务实例，而`azure_rm_aks`模块允许我们创建、更新和删除Azure
    Kubernetes服务实例。
- en: 'Google Cloud launched **Google Kubernetes Engine** (**GKE**) in 2015\. GKE
    is the Google Cloud Platform version of managed Kubernetes, and therefore compatible
    with Ansible Kubernetes modules. In addition to those, there are various GKE-specific
    modules, some of which are as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud于2015年推出了**Google Kubernetes Engine**（**GKE**）。GKE是Google Cloud
    Platform的托管Kubernetes版本，因此与Ansible Kubernetes模块兼容。除此之外，还有各种GKE特定的模块，其中一些如下：
- en: '`gcp_container_cluster`: Allows you to create a GCP Cluster'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcp_container_cluster`：允许您创建GCP Cluster'
- en: '`gcp_container_cluster_facts`: Allows you to gather facts for a GCP Cluster'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcp_container_cluster_facts`：允许您收集有关GCP Cluster的信息'
- en: '`gcp_container_node_pool`: Allows you to create a GCP NodePool'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcp_container_node_pool`：允许您创建GCP NodePool'
- en: '`gcp_container_node_pool_facts`: Allows you to gather facts for a GCP NodePool'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcp_container_node_pool_facts`：允许您收集有关GCP NodePool的信息'
- en: Red Hat started OpenShift in 2011, and at the time, it was based on its own
    container runtime. In version 3, which was released in 2015, it was completely
    rebased on Kubernetes, so all Ansible Kubernetes modules work. In addition to
    those, there is the `oc` module, which is currently still present but in a deprecated
    state, giving preference to the Kubernetes modules.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat于2011年启动了OpenShift，当时它是基于自己的容器运行时的。在2015年发布的第3版中，它完全基于Kubernetes重新构建，因此所有Ansible
    Kubernetes模块都可以使用。除此之外，还有`oc`模块，目前仍然存在但处于弃用状态，更倾向于使用Kubernetes模块。
- en: 'In 2015, Google released Kubernetes and quickly, a huge community started to
    build around it. Ansible allows you to manage your Kubernetes clusters with some
    modules:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，Google发布了Kubernetes，并迅速形成了一个庞大的社区。Ansible允许您使用一些模块来管理您的Kubernetes集群：
- en: '`k8s`: Allows you to manage any kind of Kubernetes object'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k8s`：允许您管理任何类型的Kubernetes对象'
- en: '`k8s_auth`: Allows you to authenticate to Kubernetes clusters that require
    an explicit login step'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k8s_auth`：允许您对需要显式登录的Kubernetes集群进行身份验证'
- en: '`k8s_facts`: Allows you to inspect Kubernetes objects'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k8s_facts`：允许您检查Kubernetes对象'
- en: '`k8s_scale`: Allows you to set a new size for a Deployment, ReplicaSet, Replication
    Controller, or Job'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k8s_scale`：允许您为部署、副本集、复制控制器或作业设置新的大小'
- en: '`k8s_service`: Allows you to manage Services on Kubernetes'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k8s_service`：允许您在Kubernetes上管理服务'
- en: 'LXC and LXD are also systems that can be used to run containers in Linux. These
    systems are also supported by Ansible, thanks to the following modules:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: LXC和LXD也是可以在Linux中运行容器的系统。由于以下模块的支持，这些系统也受到Ansible的支持：
- en: '`lxc_container`: Allows you to manage LXC containers'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lxc_container`：允许您管理LXC容器'
- en: '`lxd_container`: Allows you to manage LXD containers'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lxd_container`：允许您管理LXD容器'
- en: '`lxd_profile`: Allows you to manage LXD profiles'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lxd_profile`：允许您管理LXD配置文件'
- en: Now that you have learned how to explore container-focused modules, you'll learn
    how to automate against Amazon Web Services.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何探索面向容器的模块，接下来将学习如何针对亚马逊网络服务进行自动化。
- en: Automating against Amazon Web Services
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 针对亚马逊网络服务进行自动化
- en: In many organizations, cloud providers are being used widely, while in others,
    they are just being introduced. However, in one way or the other, you will probably
    have to deal with some cloud provider doing your job. AWS is the biggest and the
    oldest, and is perhaps something you will have to work with.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多组织中，广泛使用云提供商，而在其他组织中，它们只是被引入。但是，无论如何，您可能都必须处理一些云提供商来完成工作。AWS是最大的，也是最古老的，可能是您必须使用的东西。
- en: Installation
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'To be able to use Ansible to automate your Amazon Web Service estate, you''ll
    need to install the `boto` library. To do so, run the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够使用Ansible自动化您的Amazon Web Service资源，您需要安装`boto`库。要执行此操作，请运行以下命令：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that you have all the necessary software installed, you can set up authentication.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了所有必要的软件，可以设置身份验证了。
- en: Authentication
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证
- en: The `boto` library looks up the necessary credentials in the `~/.aws/credentials`
    file. There are two different ways to ensure that the credentials file is configured
    properly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`boto`库在`~/.aws/credentials`文件中查找必要的凭据。确保凭据文件正确配置有两种不同的方法。'
- en: 'It is possible to use the AWS CLI tool. Alternatively, this can be done with
    a text editor of your choice by creating a file with the following structure:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用AWS CLI工具。或者，可以通过创建具有以下结构的文件来使用您选择的文本编辑器：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now that you've created the file with the necessary credentials, `boto` will
    be able to work against your AWS environment. Since Ansible uses `boto` for every
    single communication with AWS systems, this means that Ansible will be appropriately
    configured, even without you have to change any Ansible-specific configuration.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了具有必要凭据的文件，`boto`将能够针对您的AWS环境进行操作。由于Ansible对AWS系统的每一次通信都使用`boto`，这意味着即使您不必更改任何特定于Ansible的配置，Ansible也将被适当配置。
- en: Creating your first machine
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一台机器
- en: 'Now that Ansible is able to connect to your AWS environment, you can proceed
    with the actual playbook by following these steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Ansible能够连接到您的AWS环境，您可以按照以下步骤进行实际的playbook：
- en: 'Create the `aws.yaml` Playbook with the following content:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有以下内容的`aws.yaml` Playbook：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run it using the following command:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行它：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This command will return something like the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将返回类似以下内容：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you check AWS Console, you will see that you now have one machine up and
    running!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查AWS控制台，您将看到现在有一台机器正在运行！
- en: 'To launch a virtual machine in AWS, we need a few things to be in place, as
    follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要在AWS中启动虚拟机，我们需要准备一些东西，如下所示：
- en: An SSH key pair
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个SSH密钥对
- en: A network
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个网络
- en: A subnetwork
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个子网络
- en: A security group
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个安全组
- en: By default, a network and a subnetwork are already available in your accounts,
    but you need to retrieve their IDs.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，您的帐户中已经有一个网络和一个子网络，但您需要检索它们的ID。
- en: That's why we started by uploading the public part of an SSH keypair to AWS,
    then queried for information about the network and the subnetwork, then ensured
    that the Security Group we wanted to use was present, and lastly triggered the
    machine build.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们首先将SSH密钥对的公共部分上传到AWS，然后查询有关网络和子网络的信息，然后确保我们想要使用的安全组存在，最后触发机器构建。
- en: Now you have learned how to automate against Amazon Web Services, you'll learn
    how to complement Google Cloud Platform with automation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何针对亚马逊网络服务进行自动化，您将学习如何通过自动化来补充谷歌云平台。
- en: Complementing Google Cloud Platform with automation
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过自动化来补充谷歌云平台
- en: Another global cloud provider is Google, with its Google Cloud Platform. Google's
    approach to the cloud is relatively different from other providers' since Google
    does not try to simulate the data center in a virtual environment. This is because
    Google wishes to rethink the concept of cloud provision in order to simplify it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个全球云服务提供商是谷歌，其谷歌云平台。谷歌对云的方法与其他提供商的方法相对不同，因为谷歌不试图在虚拟环境中模拟数据中心。这是因为谷歌希望重新思考云提供的概念，以简化它。
- en: Installation
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'You need to ensure that you have the proper components installed before you
    can start using Google Cloud Platform with Ansible. More specifically, you will
    require the Python `requests` and `google-auth` modules. To install these modules,
    run the following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始使用Ansible与谷歌云平台之前，您需要确保已安装适当的组件。具体来说，您需要Python的`requests`和`google-auth`模块。要安装这些模块，请运行以下命令：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now that you have all the dependencies present, you can start the authentication
    process.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好所有依赖项，可以开始认证过程。
- en: Authentication
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: 'There are two different approaches to obtain a working set of credentials in
    Google Cloud Platform:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在谷歌云平台中获得工作凭据的两种不同方法：
- en: The Service Account
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务帐户
- en: The Machine Account
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器帐户
- en: The first approach is the suggested one in the majority of cases since the second
    applies only to circumstances where Ansible is run directly within the Google
    Cloud Platform environment.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法在大多数情况下是建议的，因为第二种方法仅适用于在谷歌云平台环境中直接运行Ansible的情况。
- en: 'Once you have created the Service Account, you should set the following environmental
    variables:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务帐户后，您应该设置以下环境变量：
- en: '`GCP_AUTH_KIND`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GCP_AUTH_KIND`'
- en: '`GCP_SERVICE_ACCOUNT_EMAIL`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GCP_SERVICE_ACCOUNT_EMAIL`'
- en: '`GCP_SERVICE_ACCOUNT_FILE`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GCP_SERVICE_ACCOUNT_FILE`'
- en: '`GCP_SCOPES`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GCP_SCOPES`'
- en: Now, Ansible can use the proper Service Account.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Ansible可以使用适当的服务帐户。
- en: The second approach is by far the easiest since Ansible will be able to auto-detect
    the Machine Account if you are running it in a Google Cloud instance.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是最简单的，因为如果您在谷歌云实例中运行Ansible，它将能够自动检测到机器帐户。
- en: Creating your first machine
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一台机器
- en: 'Now that Ansible is able to connect to your GCP environment, you can proceed
    with the actual Playbook:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Ansible能够连接到您的GCP环境，您可以继续进行实际的Playbook：
- en: 'Create the `gce.yaml` Playbook with the following content:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`gce.yaml` Playbook，并包含以下内容：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Execute it with the following command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令执行它：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will create an output like the following one:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建以下输出：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As for the AWS example, running a machine in the cloud is very easy with Ansible.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与AWS示例一样，在云中运行机器对Ansible来说非常容易。
- en: In the case of GCE, you don't need to set up the networks beforehand since the
    GCE defaults will kick in and provide a functional machine either way.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在GCE的情况下，您不需要预先设置网络，因为GCE默认设置将提供一个功能齐全的机器。
- en: As for AWS, the list of modules you can use is huge. You can find the full list
    at [https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#google](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#google).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 与AWS一样，您可以使用的模块列表非常庞大。您可以在[https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#google](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#google)找到完整的列表。
- en: Now that you have learned how to complement Google Cloud Platform with automation,
    you will learn how to seamlessly perform automation integration to Azure.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何通过自动化来补充谷歌云平台，您将学习如何无缝地执行与Azure的自动化集成。
- en: Seamless automation integration to Azure
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Azure的无缝自动化集成
- en: Another global cloud that Ansible can manage is Microsoft Azure.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible可以管理的另一个全球云是Microsoft Azure。
- en: Azure integration, like the AWS one, requires quite a few steps to be performed
    in Playbooks.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 与AWS类似，Azure集成需要在Playbooks中执行相当多的步骤。
- en: The first thing you will need to do is set up the authentication so that Ansible
    is allowed to control your Azure account.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要首先设置认证，以便Ansible被允许控制您的Azure帐户。
- en: Installation
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'To let Ansible manage the Azure cloud, you need to install the Azure SDK for
    Python. Do this by executing the following command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要让Ansible管理Azure云，您需要安装Python的Azure SDK。通过执行以下命令来完成：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now that you have all the dependencies present, you can start the authentication
    process.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好所有依赖项，可以开始认证过程。
- en: Authentication
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: There are different ways to ensure that Ansible is able to manage Azure for
    you, based on the way your Azure account is set up, but they can all be configured
    in the `~/.azure/credentials` file.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法可以确保Ansible能够为您管理Azure，这取决于您的Azure帐户设置方式，但它们都可以在`~/.azure/credentials`文件中配置。
- en: 'If you want Ansible to use the principal credentials for the Azure account,
    you will need to create a file that resembles the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望Ansible使用Azure帐户的主要凭据，您需要创建一个类似以下内容的文件：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you prefer to use Active Directories with a username and password, you can
    do something like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望使用用户名和密码与Active Directories，可以这样做：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Lastly, you can opt for an Active Directory login with ADFS. In this case,
    you''ll need to set some additional parameters. You''ll end up with something
    like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以选择使用ADFS进行Active Directory登录。在这种情况下，您需要设置一些额外的参数。您最终会得到类似这样的东西：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The same parameters can be passed as parameters or as environmental variables
    if it makes more sense.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的参数可以作为参数传递，也可以作为环境变量传递，如果更合理的话。
- en: Creating your first machine
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一台机器
- en: 'Now that Ansible is able to connect to your Azure environment, you can proceed
    with the actual Playbook:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Ansible已经能够连接到你的Azure环境，你可以继续进行实际的Playbook了。
- en: 'Create the `azure.yaml` Playbook with the following content:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`azure.yaml` Playbook，内容如下：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can run it with the following command:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令运行它：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will return something like the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回类似以下的结果：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You now have your machine running in the Azure cloud!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以在Azure云中运行你的机器了！
- en: As you can see, in Azure, you will need all the resources to be ready before
    you can issue the machine creation command. This is the reason you create the
    Storage Account, the Virtual Network, the Subnet, the Public IP, the security
    Group, and the NIC first, and only at that point, the machine itself.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在Azure中，你需要在发出创建机器命令之前准备好所有资源。这就是你首先创建存储帐户、虚拟网络、子网、公共IP、安全组和NIC，然后只有在那时，才创建机器本身的原因。
- en: 'Outside the three major players in the market, there are many additional cloud
    options. One very interesting option is RackSpace, due to its history: Rackspace
    Cloud.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 除了市场上的三大主要参与者外，还有许多其他云选项。一个非常有趣的选择是RackSpace，因为它的历史：Rackspace Cloud。
- en: Expanding your environment with Rackspace Cloud
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Rackspace Cloud扩展你的环境
- en: Rackspace was one of the first companies in the public cloud business. Also,
    in a joint effort with NASA, Rackspace created OpenStack in 2010\. In the last
    10 years, Rackspace has been a very influential provider for the world of cloud
    infrastructure, OpenStack, and, more generally, the hosting scene.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Rackspace是公共云业务中最早的公司之一。此外，Rackspace在2010年与NASA联合创办了OpenStack。在过去的10年中，Rackspace一直是云基础设施、OpenStack以及更广泛的托管领域的非常有影响力的提供商。
- en: Installation
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: To be able to manage Rackspace from Ansible, you will need to install `pyrax`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够从Ansible管理Rackspace，你需要安装`pyrax`。
- en: 'The easiest way to install it is by running the following command:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 安装它的最简单方法是运行以下命令：
- en: '[PRE42]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can also install it via your system package manager if it's available.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可用，你也可以通过系统包管理器安装它。
- en: Authentication
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: Since `pyrax` does not have a default location for the credentials file, you
    will need to create a file and then set an environmental variable by instructing
    `pyrax` to do this at the file's location.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pyrax`没有凭据文件的默认位置，你需要创建一个文件，然后通过指示`pyrax`在文件位置设置一个环境变量来做到这一点。
- en: 'Let''s start by creating a file in `~/.rackspace_credentials` with the following
    content:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`~/.rackspace_credentials`中创建一个文件开始，文件内容如下：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can now proceed by setting the `RAX_CREDS_FILE` variable to the right location:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过将`RAX_CREDS_FILE`变量设置为正确的位置来继续进行：
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Let's go ahead and create a machine using Rackspace Cloud.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用Rackspace Cloud创建一台机器。
- en: Creating your first machine
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一台机器
- en: 'Creating a machine in Rackspace Cloud is very simple since it''s a single-step
    operation:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rackspace Cloud中创建一台机器非常简单，因为它是一个单步操作：
- en: 'Create the `rax.yaml` Playbook with the following content:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`rax.yaml` Playbook，内容如下：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, you can execute it with the following command:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以使用以下命令来执行它：
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This should result in something like the following:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该会产生类似以下的结果：
- en: '[PRE47]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, creating machines in Rackspace Cloud is very straightforward,
    and the default Ansible module has some interesting concepts already integrated
    into it, such as group and count. Those options allow you to create and manage
    groups of instances in the same way you would do with a single instance.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在Rackspace Cloud中创建机器非常简单直接，而默认的Ansible模块已经集成了一些有趣的概念，比如组和计数。这些选项允许你以与单个实例相同的方式创建和管理实例组。
- en: Using Ansible to orchestrate OpenStack
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible来编排OpenStack
- en: As opposed to the various cloud services we just discussed, all of which are
    public clouds, OpenStack allows you to create your own (private) cloud.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们刚讨论的各种公共云服务相反，OpenStack允许你创建自己的（私有）云。
- en: Private clouds have the disadvantage that they expose more complexity to the
    administrator and to the user, but this is the reason why they can be customized
    to suit an organization perfectly.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 私有云的缺点是它们向管理员和用户暴露了更多的复杂性，但这也是它们可以被定制以完美适应组织的原因。
- en: Installation
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: The first step to being able to control an OpenStack cluster with Ansible is
    to ensure that `openstacksdk` is installed.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用Ansible控制OpenStack集群的第一步是确保安装了`openstacksdk`。
- en: 'To install `openstacksdk`, you need to execute the following command:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`openstacksdk`，你需要执行以下命令：
- en: '[PRE48]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that you have installed `openstacksdk`, you can start the authentication
    process.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了`openstacksdk`，你可以开始认证过程了。
- en: Authentication
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: Since Ansible will use `openstacksdk` as its backend, you will need to ensure
    that `openstacksdk` is able to connect to the OpenStack cluster.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ansible将使用`openstacksdk`作为其后端，你需要确保`openstacksdk`能够连接到OpenStack集群。
- en: To do this, you can change the `~/.config/openstack/clouds.yaml` file, ensuring
    that there is a configuration for the cloud you want to use it for.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你可以更改`~/.config/openstack/clouds.yaml`文件，确保为你想要使用它的云配置。
- en: 'An example of what a correct OpenStack credentials set could look like is as
    follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正确的OpenStack凭据集的示例可能如下所示：
- en: '[PRE49]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It's also possible to set a different config file location if you are willing
    to export the `OS_CLIENT_CONFIG_FILE` variable as an environment variable.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果愿意，也可以设置不同的配置文件位置，将`OS_CLIENT_CONFIG_FILE`变量作为环境变量导出。
- en: Now that you have set up the required security so that Ansible can manage your
    cluster, you can create your first Playbook.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了所需的安全性，以便Ansible可以管理你的集群，你可以创建你的第一个Playbook了。
- en: Creating your first machine
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一台机器
- en: Since OpenStack is very flexible, many of its components can have many different
    implementations, which means they may differ slightly in terms of their behavior.
    To be able to accommodate all the various cases, the Ansible modules that manage
    OpenStack tend to have a lower level of abstraction compared to the ones for many
    public clouds.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于OpenStack非常灵活，它的许多组件可以有许多不同的实现，这意味着它们在行为上可能略有不同。为了能够适应各种情况，管理OpenStack的Ansible模块往往具有较低的抽象级别，与许多公共云的模块相比。
- en: So, to create a machine, you will need to ensure that the public SSH key is
    known to OpenStack and ensure that the OS image is present as well. After doing
    this, you can set up networks, subnetworks, and routers to ensure that the machine
    we are going to create can communicate via the network. Then, you can create the
    security group and its rules so that the machine can receive connections (pings
    and SSH traffic, in this case). Finally, you can create a machine instance.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要创建一台机器，您需要确保公共SSH密钥为OpenStack所知，并确保OS镜像也存在。在这样做之后，您可以设置网络、子网络和路由器，以确保我们要创建的机器可以通过网络进行通信。然后，您可以创建安全组及其规则，以便该机器可以接收连接（在本例中为ping和SSH流量）。最后，您可以创建一个机器实例。
- en: 'To complete all the steps we''ve just described, you need to create a file
    called `openstack.yaml` with the following content:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成我们刚刚描述的所有步骤，您需要创建一个名为`openstack.yaml`的文件，其中包含以下内容：
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, you can run it, as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以运行它，如下：
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output should be as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '[PRE52]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see, this process was longer than the public cloud ones we covered.
    However, you did get to upload the image that you wanted to run, which is something
    many clouds do not allow (or allow with very complex processes).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个过程比我们涵盖的公共云要长。但是，您确实可以上传您想要运行的镜像，这是许多云不允许的（或者允许的过程非常复杂）。
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to automate tasks, from designing and building
    containers with playbooks to managing the deployment on Kubernetes, as well as
    managing Kubernetes objects and automating Docker with Ansible. You also explored
    the modules that can help you automate cloud environments, such as AWS, Google
    Cloud Platform, Azure, Rackspace, and OpenShift. You also learned about the different
    approaches various cloud providers use, including their defaults and the parameters
    that you will always need to add.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用playbooks自动化任务，从设计和构建容器到在Kubernetes上管理部署，以及管理Kubernetes对象和使用Ansible自动化Docker。您还探索了可以帮助您自动化云环境的模块，如AWS、Google
    Cloud Platform、Azure、Rackspace和OpenShift。您还了解了各种云提供商使用的不同方法，包括它们的默认值以及您总是需要添加的参数。
- en: Now that you have an understanding of how Ansible interacts with the clouds,
    you can immediately start to automate your cloud workflows. Also, remember to
    check the documentation in the *Further reading* section to take a look at all
    the cloud modules that Ansible supports and their options.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了Ansible如何与云进行交互，您可以立即开始自动化云工作流程。还记得要查看*进一步阅读*部分的文档，以查看Ansible支持的所有云模块及其选项。
- en: In the next chapter, you will learn how to troubleshoot and create testing strategies.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何排除故障和创建测试策略。
- en: Questions
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the following is NOT a GKE Ansible module?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个不是GKE Ansible模块？
- en: A) `gcp_container_cluster`
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: A) `gcp_container_cluster`
- en: B) `gcp_container_node_pool`
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: B) `gcp_container_node_pool`
- en: C) `gcp_container_node_pool_facts`
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: C) `gcp_container_node_pool_facts`
- en: D) `gcp_container_node_pool_count`
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: D) `gcp_container_node_pool_count`
- en: E) `gcp_container_cluster_facts`
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: E) `gcp_container_cluster_facts`
- en: 'True or False: In order to manage containers in Kubernetes, you need to add
    `k8s_namespace` in the settings section.'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：为了管理Kubernetes中的容器，您需要在设置部分中添加`k8s_namespace`。
- en: A) True
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: A) True
- en: B) False
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: B) False
- en: 'True or False: When working with Azure, you don''t need to create a **Network
    Interface Controller** (**NIC**) before creating an instance.'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：在使用Azure时，在创建实例之前，您不需要创建**网络接口控制器**（**NIC**）。
- en: A) True
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: A) True
- en: B) False
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: B) False
- en: 'True or False: `Ansible-Container` is the only way to interact with Kubernetes
    and Doc.'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：`Ansible-Container`是与Kubernetes和Doc交互的唯一方式。
- en: A) True
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: A) True
- en: B) False
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: B) False
- en: 'True or False: When working with AWS, it''s necessary to create a Security
    Group before creating an EC2 instance.'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：在使用AWS时，在创建EC2实例之前，需要创建一个安全组。
- en: A) True
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: A) True
- en: B) False
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: B) False
- en: Further reading
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: More AWS modules: [https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#amazon](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#amazon)
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多AWS模块：[https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#amazon](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#amazon)
- en: 'More Azure modules: [https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#azure](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#azure)'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多Azure模块：[https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#azure](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#azure)
- en: 'More Docker modules: [https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#docker](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#docker)'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多Docker模块：[https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#docker](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#docker)
- en: 'More GCP modules: [https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#google](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#google)'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多GCP模块：[https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#google](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#google)
- en: 'More OpenStack modules: [https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#openstack](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#openstack)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多OpenStack模块：[https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#openstack](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#openstack)
- en: 'More Rackspace modules: [https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#rackspace](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#rackspace)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多的Rackspace模块：[https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#rackspace](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html#rackspace)
