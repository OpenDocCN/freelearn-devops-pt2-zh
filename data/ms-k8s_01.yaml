- en: Understanding Kubernetes Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Kubernetes架构
- en: Kubernetes is a big open source project and ecosystem with a lot of code and
    a lot of functionality. Kubernetes was made by Google, but joined the **Cloud
    Native Computing Foundation** (**CNCF**) and became the clear leader in the field
    of container-based applications. In one sentence, it is a platform to orchestrate
    the deployment, scaling, and management of container-based applications. You have
    probably read about Kubernetes, and maybe even dipped your toes in and used it
    in a side project, or maybe even at work. But to understand what Kubernetes is
    all about, how to use it effectively, and what the best practices are requires
    much more. In this chapter, we will build the foundation of knowledge necessary
    to utilize Kubernetes to its full potential. We will start by understanding what
    Kubernetes is, what Kubernetes isn't, and what container orchestration means exactly.
    Then we will cover some important Kubernetes concepts that will form the vocabulary
    that we will use throughout the book. After that, we will dive into the architecture
    of Kubernetes in more detail and look at how it enables all the capabilities that
    it provides to its users. Then, we will discuss the various runtimes and container
    engines that Kubernetes supports (Docker is just one option) and, finally, we
    will discuss the role of Kubernetes in the full continuous integration and deployment
    pipeline.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是一个庞大的开源项目和生态系统，拥有大量的代码和功能。Kubernetes由谷歌开发，但加入了**Cloud Native Computing
    Foundation**（**CNCF**），成为容器应用领域的明确领导者。简而言之，它是一个用于编排基于容器的应用程序部署、扩展和管理的平台。您可能已经了解过Kubernetes，甚至在一些项目中使用过它，甚至在工作中使用过它。但要理解Kubernetes的全部内容，如何有效使用它以及最佳实践是什么，需要更多的知识。在本章中，我们将建立必要的知识基础，以充分利用Kubernetes的潜力。我们将首先了解Kubernetes是什么，Kubernetes不是什么，以及容器编排的确切含义。然后，我们将介绍一些重要的Kubernetes概念，这些概念将构成我们在整本书中将使用的词汇。之后，我们将更详细地深入了解Kubernetes的架构，并看看它如何为用户提供所有这些功能。然后，我们将讨论Kubernetes支持的各种运行时和容器引擎（Docker只是其中一种选择），最后，我们将讨论Kubernetes在完整的持续集成和部署流水线中的作用。
- en: At the end of this chapter, you will have a solid understanding of container
    orchestration, what problems Kubernetes addresses, the rationale for Kubernetes
    design and architecture, and the different runtimes it supports. You'll also be
    familiar with the overall structure of the open source repository and be ready
    to jump in and find answers to any question.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将对容器编排有扎实的了解，了解Kubernetes解决了哪些问题，Kubernetes设计和架构的基本原理，以及它支持的不同运行时。您还将熟悉开源存储库的整体结构，并准备好随时跳入并找到任何问题的答案。
- en: What is Kubernetes?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes是什么？
- en: 'Kubernetes is a platform that encompasses a huge number of services and capabilities
    that keep growing. Its core functionality is its ability to schedule workloads
    in containers across your infrastructure, but it doesn''t stop there. Here are
    some of the other capabilities Kubernetes brings to the table:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是一个涵盖大量服务和功能的平台，不断增长。它的核心功能是在您的基础设施中安排容器工作负载，但它并不止步于此。以下是Kubernetes带来的其他一些功能：
- en: Mounting storage systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载存储系统
- en: Distributing secrets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发密钥
- en: Checking application health
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查应用程序健康状况
- en: Replicating application instances
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制应用程序实例
- en: Using horizontal pod autoscaling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用水平Pod自动缩放
- en: Naming and discovering
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名和发现
- en: Balancing loads
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Rolling updates
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动更新
- en: Monitoring resources
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控资源
- en: Accessing and ingesting logs
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问和摄取日志
- en: Debugging applications
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试应用程序
- en: Providing authentication and authorization
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供身份验证和授权
- en: What Kubernetes is not
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes不是什么
- en: 'Kubernetes is not a **platform as a service** (**PaaS**). It doesn''t dictate
    many of the important aspects of your desired system; instead, it leaves them
    up to you or to other systems built on top of Kubernetes, such as Deis, OpenShift,
    and Eldarion. For example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes不是**平台即服务**（**PaaS**）。它不规定您所需系统的许多重要方面；相反，它将它们留给您或其他构建在Kubernetes之上的系统，如Deis、OpenShift和Eldarion。例如：
- en: Kubernetes doesn't require a specific application type or framework
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes不需要特定的应用程序类型或框架
- en: Kubernetes doesn't require a specific programming language
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes不需要特定的编程语言
- en: Kubernetes doesn't provide databases or message queues
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes不提供数据库或消息队列
- en: Kubernetes doesn't distinguish apps from services
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes不区分应用程序和服务
- en: Kubernetes doesn't have a click-to-deploy service marketplace
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes没有点击即部署的服务市场
- en: Kubernetes allows users to choose their own logging, monitoring, and alerting
    systems
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes允许用户选择自己的日志记录、监控和警报系统
- en: Understanding container orchestration
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解容器编排
- en: The primary responsibility of Kubernetes is container orchestration. This means
    making sure that all the containers that execute various workloads are scheduled
    to run on physical or virtual machines. The containers must be packed efficiently
    and follow the constraints of the deployment environment and the cluster configuration.
    In addition, Kubernetes must keep an eye on all running containers and replace
    dead, unresponsive, or otherwise unhealthy containers. Kubernetes provides many
    more capabilities that you will learn about in the following chapters. In this
    section, the focus is on containers and their orchestration.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的主要责任是容器编排。这意味着确保执行各种工作负载的所有容器都被安排在物理或虚拟机上运行。容器必须被有效地打包，并遵循部署环境和集群配置的约束。此外，Kubernetes必须监视所有运行的容器，并替换死掉的、无响应的或其他不健康的容器。Kubernetes提供了许多其他功能，您将在接下来的章节中了解到。在本节中，重点是容器及其编排。
- en: Physical machines, virtual machines, and containers
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理机器、虚拟机器和容器
- en: It all starts and ends with hardware. In order to run your workloads, you need
    some real hardware provisioned. That includes actual physical machines, with certain
    compute capabilities (CPUs or cores), memory, and some local persistent storage
    (spinning disks or SSDs). In addition, you will need some shared persistent storage
    and the networking to hook up all these machines so they can find and talk to
    each other. At this point, you can run multiple virtual machines on the physical
    machines or stay at the bare-metal level (no virtual machines). Kubernetes can
    be deployed on a bare-metal cluster (real hardware) or on a cluster of virtual
    machines. Kubernetes in turn can orchestrate the containers it manages directly
    on bare-metal or virtual machines. In theory, a Kubernetes cluster can be composed
    of a mix of bare-metal and virtual machines, but this is not very common.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都始于硬件，也以硬件结束。为了运行您的工作负载，您需要一些真实的硬件。这包括实际的物理机器，具有一定的计算能力（CPU或核心）、内存和一些本地持久存储（旋转磁盘或固态硬盘）。此外，您还需要一些共享的持久存储和网络，以连接所有这些机器，使它们能够找到并相互通信。在这一点上，您可以在物理机器上运行多个虚拟机，或者保持裸金属级别（没有虚拟机）。Kubernetes可以部署在裸金属集群（真实硬件）或虚拟机集群上。反过来，Kubernetes可以在裸金属或虚拟机上直接编排它管理的容器。理论上，Kubernetes集群可以由裸金属和虚拟机的混合组成，但这并不常见。
- en: The benefits of containers
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的好处
- en: 'Containers represent a true paradigm shift in the development and operation
    of large, complicated software systems. Here are some of the benefits compared
    to more traditional models:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 容器代表了大型复杂软件系统开发和运行中的真正范式转变。以下是与传统模型相比的一些好处：
- en: Agile application creation and deployment
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏捷的应用程序创建和部署
- en: Continuous development, integration, and deployment
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续开发、集成和部署
- en: Dev and ops separation of concerns
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发和运维的关注点分离
- en: Environmental consistency across development, testing, and production
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发、测试和生产环境中保持环境一致性
- en: Cloud- and OS-distribution portability
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云和操作系统的可移植性
- en: Application-centric management
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以应用为中心的管理
- en: Loosely coupled, distributed, elastic, liberated microservices
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松散耦合、分布式、弹性、自由的微服务
- en: Resource isolation
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源隔离
- en: Resource utilization
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源利用
- en: Containers in the cloud
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云中的容器
- en: "Containers are ideal to package microservices because, while providing isolation\
    \ to the microservice, they are very lightweight, and you don't incur a lot of\
    \ overhead when deploying many microservices as you do with virtual machines.\
    \ That makes containers ideal for cloud deployment, where allocating a whole virtual\
    \ machine \Lfor each microservice would be cost prohibitive."
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 容器非常适合打包微服务，因为它们在为微服务提供隔离的同时非常轻量，并且在部署许多微服务时不会产生很多开销，就像使用虚拟机一样。这使得容器非常适合云部署，因为为每个微服务分配整个虚拟机的成本是禁止的。
- en: All major cloud providers, such as Amazon AWS, Google's GCE, Microsoft's Azure
    and even Alibaba Cloud, provide container-hosting services these days. Google's
    GKE has always been based on Kubernetes. AWS ECS is based on their own orchestration
    solution. Microsoft Azure's container service was based on Apache Mesos. Kubernetes
    can be deployed on all cloud platforms, but it wasn't deeply intergated with other
    services until today. But at the end of 2017, all cloud providers announced direct
    support for Kubernetes. Microsofts launched AKS, AWS released EKS, and Alibaba
    Cloud started working on a Kubernetes controller manager to integrate Kubernetes
    seamlessly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要的云服务提供商，如亚马逊AWS、谷歌的GCE、微软的Azure，甚至阿里巴巴云，现在都提供容器托管服务。谷歌的GKE一直以来都是基于Kubernetes。AWS
    ECS基于他们自己的编排解决方案。微软Azure的容器服务是基于Apache Mesos的。Kubernetes可以部署在所有云平台上，但直到今天它才没有与其他服务深度集成。但在2017年底，所有云服务提供商宣布直接支持Kubernetes。微软推出了AKS，AWS发布了EKS，阿里巴巴云开始开发一个Kubernetes控制器管理器，以无缝集成Kubernetes。
- en: Cattle versus pets
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 牲畜与宠物
- en: In the olden days, when systems were small, each server had a name. Developers
    and users knew exactly what software was running on each machine. I remember that,
    in many of the companies I worked for, we had multi-day discussions to decide
    on a naming theme for our servers. For example, composers and Greek mythology
    characters were popular choices. Everything was very cozy. You treated your servers
    like beloved pets. When a server died, it was a major crisis. Everybody scrambled
    to figure out where to get another server, what was even running on the dead server,
    and how to get it working on the new server. If the server stored some important
    data, then hopefully you had an up-to-date backup and maybe you'd even be able
    to recover it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，当系统规模较小时，每台服务器都有一个名字。开发人员和用户清楚地知道每台机器上运行的软件是什么。我记得，在我工作过的许多公司中，我们经常讨论几天来决定服务器的命名主题。例如，作曲家和希腊神话人物是受欢迎的选择。一切都非常舒适。你对待你的服务器就像珍爱的宠物一样。当一台服务器死掉时，这是一场重大危机。每个人都争先恐后地想弄清楚从哪里获取另一台服务器，死掉的服务器上到底运行了什么，以及如何在新服务器上让它工作。如果服务器存储了一些重要数据，那么希望你有最新的备份，也许你甚至能够恢复它。
- en: Obviously, that approach doesn't scale. When you have a few tens or hundreds
    of servers, you must start treating them like cattle. You think about the collective
    and not individuals. You may still have some pets, but your web servers are just
    cattle.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种方法是不可扩展的。当你有几十台或几百台服务器时，你必须开始像对待牲畜一样对待它们。你考虑的是整体，而不是个体。你可能仍然有一些宠物，但你的Web服务器只是牲畜。
- en: Kubernetes takes the cattle approach to the extreme and takes full responsibility
    for allocating containers to specific machines. You don't need to interact with
    individual machines (nodes) most of the time. This works best for stateless workloads.
    For stateful applications, the situation is a little different, but Kubernetes
    provides a solution called StatefulSet, which we'll discuss soon.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes将牲畜的方法应用到了极致，并全权负责将容器分配到特定的机器上。大部分时间你不需要与单独的机器（节点）进行交互。这对于无状态的工作负载效果最好。对于有状态的应用程序，情况有些不同，但Kubernetes提供了一个称为StatefulSet的解决方案，我们很快会讨论它。
- en: In this section, we covered the idea of container orchestration and discussed
    the relationships between hosts (physical or virtual) and containers, as well
    as the benefits of running containers in the cloud, and finished with a discussion
    about cattle versus pets. In the following section, we will get to know the world
    of Kubernetes and learn its concepts and terminology.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们涵盖了容器编排的概念，并讨论了主机（物理或虚拟）和容器之间的关系，以及在云中运行容器的好处，并最后讨论了牲畜与宠物的区别。在接下来的部分，我们将了解Kubernetes的世界，并学习它的概念和术语。
- en: Kubernetes concepts
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes概念
- en: In this section, I'll briefly introduce many important Kubernetes concepts and
    give you some context as to why they are needed and how they interact with other
    concepts. The goal is to get familiar with these terms and concepts. Later, we
    will see how these concepts are woven together and organized into API groups and
    resource categories to achieve awesomeness. You can consider many of these concepts
    as building blocks. Some of the concepts, such as nodes and masters, are implemented
    as a set of Kubernetes components. These components are at a different abstraction
    level, and I discuss them in detail in a dedicated section, *Kubernetes components*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我将简要介绍许多重要的Kubernetes概念，并为您提供一些背景，说明它们为什么需要以及它们如何与其他概念互动。目标是熟悉这些术语和概念。稍后，我们将看到这些概念如何被编织在一起，并组织成API组和资源类别，以实现令人敬畏的效果。你可以把许多这些概念看作是构建块。一些概念，比如节点和主节点，被实现为一组Kubernetes组件。这些组件处于不同的抽象级别，我会在专门的部分*
    Kubernetes组件*中详细讨论它们。
- en: 'Here is the famous Kubernetes architecture diagram:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是著名的Kubernetes架构图：
- en: '![](Images/71bcaaf3-ee70-4f96-a1fb-41846aea760c.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/71bcaaf3-ee70-4f96-a1fb-41846aea760c.png)'
- en: Cluster
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群
- en: A cluster is a collection of compute, storage, and networking resources that
    Kubernetes uses to run the various workloads that comprise your system. Note that
    your entire system may consist of multiple clusters. We will discuss this advanced
    use case of federation in detail later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 集群是Kubernetes用来运行组成系统的各种工作负载的计算、存储和网络资源的集合。请注意，您的整个系统可能由多个集群组成。我们将在后面详细讨论联邦的这种高级用例。
- en: Node
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点
- en: A node is a single host. It may be a physical or virtual machine. Its job is
    to run pods, which we will look at in a moment. Each Kubernetes node runs several
    Kubernetes components, such as a kubelet and a kube proxy. Nodes are managed by
    a Kubernetes master. The nodes are the worker bees of Kubernetes and shoulder
    all the heavy lifting. In the past, they were called **minions**. If you have
    read some old documentation or articles, don't get confused. Minions are nodes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点是一个单独的主机。它可以是物理机或虚拟机。它的工作是运行pod，我们马上会看到。每个Kubernetes节点都运行几个Kubernetes组件，比如kubelet和kube代理。节点由Kubernetes主节点管理。节点是Kubernetes的工作蜂，肩负着所有繁重的工作。过去，它们被称为**仆从**。如果你读过一些旧的文档或文章，不要感到困惑。仆从就是节点。
- en: Master
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主节点
- en: The master is the control plane of Kubernetes. It consists of several components,
    such as an API server, a scheduler, and a controller manager. The master is responsible
    for the global, cluster-level scheduling of pods and the handling of events. Usually,
    all the master components are set up on a single host. When considering high-availability
    scenarios or very large clusters, you will want to have master redundancy. I will
    discuss highly available clusters in detail in [Chapter 4](0b446f8f-3748-4bb4-8406-78f2af468e14.xhtml),
    *High Availability and Reliability*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点是Kubernetes的控制平面。它由多个组件组成，如API服务器、调度程序和控制器管理器。主节点负责全局的集群级别的pod调度和事件处理。通常，所有主节点组件都设置在单个主机上。在考虑高可用性场景或非常大的集群时，您会希望有主节点冗余。我将在[第4章](0b446f8f-3748-4bb4-8406-78f2af468e14.xhtml)中详细讨论高可用性集群，*高可用性和可靠性*。
- en: Pod
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pod
- en: 'A pod is the unit of work in Kubernetes. Each pod contains one or more containers.
    Pods are always scheduled together (that is, they always run on the same machine).
    All the containers in a pod have the same IP address and port space; they can
    communicate using localhost or standard interprocess communication. In addition,
    all the containers in a pod can have access to shared local storage on the node
    hosting the pod. The shared storage can be mounted on each container. Pods are
    an important feature of Kubernetes. It is possible to run multiple applications
    inside a single Docker container by having something such as `supervisord` as
    the main Docker application that runs multiple processes, but this practice is
    often frowned upon for the following reasons:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Pod是Kubernetes中的工作单位。每个pod包含一个或多个容器。Pod总是一起调度（即它们总是在同一台机器上运行）。Pod中的所有容器具有相同的IP地址和端口空间；它们可以使用localhost或标准的进程间通信进行通信。此外，pod中的所有容器都可以访问托管pod的节点上的共享本地存储。共享存储可以挂载在每个容器上。Pod是Kubernetes的一个重要特性。通过在单个Docker容器中运行多个应用程序，例如通过将`supervisord`作为运行多个进程的主要Docker应用程序，可以实现这种做法，但出于以下原因，这种做法经常受到指责：
- en: '**Transparency**: Making the containers within the pod visible to the infrastructure
    enables the infrastructure to provide services to those containers, such as process
    management and resource monitoring. This facilitates a number of convenient functionalities
    for users.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**透明度**：使得pod内的容器对基础设施可见，使得基础设施能够为这些容器提供服务，如进程管理和资源监控。这为用户提供了许多便利的功能。'
- en: '**Decoupling software dependencies**: The individual containers may be versioned,
    rebuilt, and redeployed independently. Kubernetes may even support live updates
    of individual containers someday.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦软件依赖关系**：单个容器可以独立进行版本控制、重建和重新部署。Kubernetes可能会支持单个容器的实时更新。'
- en: '**Ease of use**: Users don''t need to run their own process managers, worry
    about signal and exit-code propagation, and so on.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：用户不需要运行自己的进程管理器，担心信号和退出代码的传播等问题。'
- en: '**Efficiency**: Because the infrastructure takes on more responsibility, containers
    can be more lightweight.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：由于基础设施承担了更多的责任，容器可以更轻量化。'
- en: Pods provide a great solution for managing groups of closely related containers
    that depend on each other and need to cooperate on the same host to accomplish
    their purpose. It's important to remember that pods are considered ephemeral,
    throwaway entities that can be discarded and replaced at will. Any pod storage
    is destroyed with its pod. Each pod gets a **unique ID** (**UID**), so you can
    still distinguish between them if necessary.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Pod为管理彼此紧密相关且需要在同一主机上合作以完成其目的的容器组提供了一个很好的解决方案。重要的是要记住，pod被认为是短暂的、可以随意丢弃和替换的实体。任何pod存储都会随着pod的丢弃而被销毁。每个pod都有一个**唯一ID**（**UID**），因此在必要时仍然可以区分它们。
- en: Label
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签
- en: 'Labels are key-value pairs that are used to group together sets of objects,
    very often pods. This is important for several other concepts, such as replication
    controllers, replica sets, and services that operate on dynamic groups of objects
    and need to identify the members of the group. There is an NxN relationship between
    objects and labels. Each object may have multiple labels, and each label may be
    applied to different objects. There are certain restrictions on labels by design.
    Each label on an object must have a unique key. The label key must adhere to a
    strict syntax. It has two parts: prefix and name. The prefix is optional. If it
    exists, then it is separated from the name by a forward slash (`/`) and it must
    be a valid DNS subdomain. The prefix must be 253 characters long at most. The
    name is mandatory and must be 63 characters long at most. Names must start and
    end with an alphanumeric character (a-z, A-Z, 0-9) and contain only alphanumeric
    characters, dots, dashes, and underscores. Values follow the same restrictions
    as names. Note that labels are dedicated to identifying objects and not to attaching
    arbitrary metadata to objects. This is what annotations are for (see the following
    section).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是用于将一组对象（通常是pod）分组在一起的键值对。这对于其他一些概念非常重要，比如复制控制器、副本集和操作动态对象组并需要识别组成员的服务。对象和标签之间存在NxN的关系。每个对象可能有多个标签，每个标签可能应用于不同的对象。标签有一些设计上的限制。对象上的每个标签必须具有唯一的键。标签键必须遵守严格的语法。它有两部分：前缀和名称。前缀是可选的。如果存在，则它与名称之间用斜杠(`/`)分隔，并且必须是有效的DNS子域。前缀最多可以有253个字符。名称是必需的，最多可以有63个字符。名称必须以字母数字字符（a-z，A-Z，0-9）开头和结尾，并且只能包含字母数字字符、点、破折号和下划线。值遵循与名称相同的限制。请注意，标签专用于识别对象，而不是附加任意元数据到对象。这就是注释的作用（请参见下一节）。
- en: Annotations
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: Annotations let you associate arbitrary metadata with Kubernetes objects. Kubernetes
    just stores the annotations and makes their metadata available. Unlike labels,
    they don't have strict restrictions about allowed characters and size limits.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注释允许您将任意元数据与Kubernetes对象关联起来。Kubernetes只存储注释并提供它们的元数据。与标签不同，它们对允许的字符和大小限制没有严格的限制。
- en: In my experience, you always need such metadata for complicated systems, and
    it is nice that Kubernetes recognizes this need and provides it out of the box
    so you don't have to come up with your own separate metadata store and map objects
    to their metadata.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，对于复杂的系统，你总是需要这样的元数据，很高兴Kubernetes认识到了这个需求，并且提供了这个功能，这样你就不必自己想出一个单独的元数据存储并将对象映射到它们的元数据。
- en: We've covered most, if not all, of Kubernetes's concepts; there are a few more
    I mentioned briefly. In the next section, we will continue our journey into Kubernetes's
    architecture by looking into its design motivations, the internals, and its implementation,
    and even pick at the source code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了大多数，如果不是全部，Kubernetes的概念；我简要提到了一些其他概念。在下一节中，我们将继续探讨Kubernetes的架构，深入了解其设计动机、内部和实现，甚至研究源代码。
- en: Label selectors
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签选择器
- en: 'Label selectors are used to select objects based on their labels. Equality-based
    selectors specify a key name and a value. There are two operators, `=` (or `==`)
    and `!=`, to denote equality or inequality based on the value. For example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 标签选择器用于根据它们的标签选择对象。基于相等性的选择器指定键名和值。有两个运算符，`=`（或`==`）和`!=`，表示基于值的相等性或不相等性。例如：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will select all objects that have that label key and value.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将选择所有具有该标签键和值的对象。
- en: 'Label selectors can have multiple requirements separated by a comma. For example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 标签选择器可以有多个要求，用逗号分隔。例如：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Set-based selectors extend the capabilities and allow selection based on multiple
    values:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 基于集合的选择器扩展了功能，并允许基于多个值进行选择：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Replication controllers and replica sets
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制控制器和副本集
- en: Replication controllers and replica sets both manage a group of pods identified
    by a label selector and ensure that a certain number is always up and running.
    The main difference between them is that replication controllers test for membership
    by name equality and replica sets can use set-based selection. Replica sets are
    the way to go, as they are a superset of replication controllers. I expect replication
    controllers to be deprecated at some point.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 复制控制器和副本集都管理由标签选择器标识的一组pod，并确保某个特定数量始终处于运行状态。它们之间的主要区别在于，复制控制器通过名称相等来测试成员资格，而副本集可以使用基于集合的选择。副本集是更好的选择，因为它们是复制控制器的超集。我预计复制控制器在某个时候会被弃用。
- en: Kubernetes guarantees that you will always have the same number of pods running
    that you specified in a replication controller or a replica set. Whenever the
    number drops because of a problem with the hosting node or the pod itself, Kubernetes
    will fire up new instances. Note that if you manually start pods and exceed the
    specified number, the replication controller will kill the extra pods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes保证您始终会有与复制控制器或副本集中指定的相同数量的运行中的pod。每当数量因托管节点或pod本身的问题而下降时，Kubernetes都会启动新的实例。请注意，如果您手动启动pod并超出指定数量，复制控制器将会终止额外的pod。
- en: Replication controllers used to be central to many workflows, such as rolling
    updates and running one-off jobs. As Kubernetes evolved, it introduced direct
    support for many of these workflows, with dedicated objects such as **Deployment**,
    **Job**, and **DaemonSet**. We will meet them all later.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 复制控制器曾经是许多工作流程的核心，比如滚动更新和运行一次性作业。随着Kubernetes的发展，它引入了对许多这些工作流程的直接支持，使用了专门的对象，比如**Deployment**、**Job**和**DaemonSet**。我们稍后会遇到它们。
- en: Services
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: 'Services are used to expose a certain functionality to users or other services.
    They usually encompass a group of pods, usually identified by—you guessed it—a
    label. You can have services that provide access to external resources, or to
    pods you control directly at the virtual IP level. Native Kubernetes services
    are exposed through convenient endpoints. Note that services operate at layer
    3 (TCP/UDP). Kubernetes 1.2 added the `Ingress` object, which provides access
    to HTTP objects—more on that later. Services are published or discovered through
    one of two mechanisms: DNS or environment variables. Services can be load balanced
    by Kubernetes, but developers can choose to manage load balancing themselves in
    the case of services that use external resources or require special treatment.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 服务用于向用户或其他服务公开某种功能。它们通常包括一组pod，通常由标签标识。您可以拥有提供对外部资源或直接在虚拟IP级别控制的pod的访问权限的服务。原生Kubernetes服务通过便捷的端点公开。请注意，服务在第3层（TCP/UDP）操作。Kubernetes
    1.2添加了`Ingress`对象，它提供对HTTP对象的访问——稍后会详细介绍。服务通过DNS或环境变量之一进行发布或发现。Kubernetes可以对服务进行负载均衡，但开发人员可以选择在使用外部资源或需要特殊处理的服务的情况下自行管理负载均衡。
- en: There are many gory details associated with IP addresses, virtual IP addresses,
    and port spaces. We will discuss them in-depth in a future chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与IP地址、虚拟IP地址和端口空间相关的细节很多。我们将在未来的章节中深入讨论它们。
- en: Volume
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卷
- en: Local storage on the pod is ephemeral and goes away with the pod. Sometimes
    that's all you need, if the goal is just to exchange data between containers of
    the node, but sometimes it's important for the data to outlive the pod, or it's
    necessary to share data between pods. The volume concept supports that need. Note
    that, while Docker has a volume concept too, it is quite limited (although it
    is getting more powerful). Kubernetes uses its own separate volumes. Kubernetes
    also supports additional container types, such as rkt, so it can't rely on Docker
    volumes, even in principle.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Pod上的本地存储是临时的，并随着Pod的消失而消失。有时这就是您所需要的，如果目标只是在节点的容器之间交换数据，但有时对数据的存活超过Pod或者需要在Pod之间共享数据是很重要的。卷的概念支持这种需求。请注意，虽然Docker也有卷的概念，但它相当有限（尽管它变得更加强大）。Kubernetes使用自己独立的卷。Kubernetes还支持其他容器类型，如rkt，因此即使原则上也不能依赖Docker卷。
- en: There are many volume types. Kubernetes currently directly supports many volume
    types, but the the modern approach for extending Kubernetes with more volume types
    is through the **Container Storage Interface** (**CSI**), which I'll discuss in
    detail later. The `emptyDir` volume type mounts a volume on each container that
    is backed by default by whatever is available on the hosting machine. You can
    request a memory medium if you want. This storage is deleted when the pod is terminated
    for any reason. There are many volume types for specific cloud environments, various
    networked filesystems, and even Git repositories. An interesting volume type is
    the `persistentDiskClaim`, which abstracts the details a little bit and uses the
    default persistent storage in your environment (typically in a cloud provider).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多卷类型。Kubernetes目前直接支持许多卷类型，但通过**容器存储接口**（**CSI**）来扩展Kubernetes的现代方法是我稍后会详细讨论的。`emptyDir`卷类型在每个容器上挂载一个卷，该卷默认由主机上可用的内容支持。如果需要，您可以请求内存介质。当Pod因任何原因终止时，此存储将被删除。针对特定云环境、各种网络文件系统甚至Git存储库有许多卷类型。一个有趣的卷类型是`persistentDiskClaim`，它稍微抽象了一些细节，并使用环境中的默认持久存储（通常在云提供商中）。
- en: StatefulSet
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StatefulSet
- en: 'Pods come and go, and if you care about their data, then you can use persistent
    storage. That''s all good. But sometimes you might want Kubernetes to manage a
    distributed data store, such as Kubernetes or MySQL Galera. These clustered stores
    keep the data distributed across uniquely identified nodes. You can''t model that
    with regular pods and services. Enter `StatefulSet`. If you remember, earlier
    I discussed treating servers as pets or cattle and how cattle is the way to go.
    Well, `StatefulSet` sits somewhere in the middle. `StatefulSet` ensures (similar
    to a replication set) that a given number of pets with unique identities are running
    at any given time. The pets have the following properties:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Pod会来来去去，如果您关心它们的数据，那么您可以使用持久存储。这都很好。但有时您可能希望Kubernetes管理分布式数据存储，例如Kubernetes或MySQL
    Galera。这些集群存储将数据分布在唯一标识的节点上。您无法使用常规Pod和服务来建模。这就是`StatefulSet`的作用。如果您还记得，我之前讨论过将服务器视为宠物或牲畜以及牲畜是更好的方式。嗯，`StatefulSet`处于中间某个位置。`StatefulSet`确保（类似于复制集）在任何给定时间运行一定数量具有唯一标识的宠物。这些宠物具有以下属性：
- en: A stable hostname, available in DNS
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于DNS的稳定主机名
- en: An ordinal index
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序数索引
- en: Stable storage linked to the ordinal and hostname
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与序数和主机名相关联的稳定存储
- en: '`StatefulSet` can help with peer discovery, as well as adding or removing pets.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`StatefulSet`可以帮助进行对等发现，以及添加或删除宠物。'
- en: Secrets
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 秘密
- en: Secrets are small objects that contain sensitive information, such as credentials
    and tokens. They are stored in `etcd`, are accessible by the Kubernetes API server,
    and can be mounted as files into pods (using dedicated secret volumes that piggyback
    on regular data volumes) that need access to them. The same secret can be mounted
    into multiple pods. Kubernetes itself creates secrets for its components, and
    you can create your own secrets. Another approach is to use secrets as environment
    variables. Note that secrets in a pod are always stored in memory (`tmpfs`, in
    the case of mounted secrets) for better security.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets是包含敏感信息（如凭据和令牌）的小对象。它们存储在`etcd`中，可以被Kubernetes API服务器访问，并且可以被挂载为文件到需要访问它们的pod中（使用专用的秘密卷，这些卷依附在常规数据卷上）。同一个秘密可以被挂载到多个pod中。Kubernetes本身为其组件创建秘密，您也可以创建自己的秘密。另一种方法是将秘密用作环境变量。请注意，pod中的秘密始终存储在内存中（在挂载秘密的情况下为`tmpfs`），以提高安全性。
- en: Names
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名称
- en: Each object in Kubernetes is identified by a UID and a name. The name is used
    to refer to the object in API calls. Names should be up to 253 characters long
    and use lowercase alphanumeric characters, dashes (`-`), and dots (`.`). If you
    delete an object, you can create another object with the same name as the deleted
    object, but the UIDs must be unique across the life cycle of the cluster. The
    UIDs are generated by Kubernetes, so you don't have to worry about that.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的每个对象都由UID和名称标识。名称用于在API调用中引用对象。名称应该长达253个字符，并使用小写字母数字字符、破折号（`-`）和点（`.`）。如果删除一个对象，您可以创建另一个具有与已删除对象相同名称的对象，但UID必须在集群的生命周期内是唯一的。UID是由Kubernetes生成的，所以您不必担心这个问题。
- en: Namespaces
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: A namespace is a virtual cluster. You can have a single physical cluster that
    contains multiple virtual clusters segregated by namespaces. Each virtual cluster
    is totally isolated from the other virtual clusters, and they can only communicate
    through public interfaces. Note that `node` objects and persistent volumes don't
    live in a namespace. Kubernetes may schedule pods from different namespaces to
    run on the same node. Likewise, pods from different namespaces can use the same
    persistent storage.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是一个虚拟集群。您可以拥有一个包含多个由命名空间隔离的虚拟集群的单个物理集群。每个虚拟集群与其他虚拟集群完全隔离，它们只能通过公共接口进行通信。请注意，`node`对象和持久卷不属于命名空间。Kubernetes可能会调度来自不同命名空间的pod在同一节点上运行。同样，来自不同命名空间的pod可以使用相同的持久存储。
- en: When using namespaces, you have to consider network policies and resource quotas
    to ensure proper access and distribution of the physical cluster resources.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用命名空间时，您必须考虑网络策略和资源配额，以确保对物理集群资源的适当访问和分配。
- en: Diving into Kubernetes architecture in-depth
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解Kubernetes架构
- en: Kubernetes has very ambitious goals. It aims to manage and simplify the orchestration,
    deployment, and management of distributed systems across a wide range of environments
    and cloud providers. It provides many capabilities and services that should work
    across all that diversity, while evolving and remaining simple enough for mere
    mortals to use. This is a tall order. Kubernetes achieves this by following a
    crystal-clear, high-level design and using well-thought-out architecture that
    promotes extensibility and pluggability. Many parts of Kubernetes are still hard
    coded or environment aware, but the trend is to refactor them into plugins and
    keep the core generic and abstract. In this section, we will peel Kubernetes like
    an onion, starting with the various distributed systems design patterns and how
    Kubernetes supports them, then go over the mechanics of Kubernetes, including
    its set of APIs, and then take a look at the actual components that comprise Kubernetes.
    Finally, we will take a quick tour of the source-code tree to gain even better
    insight into the structure of Kubernetes itself.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes有非常雄心勃勃的目标。它旨在管理和简化在各种环境和云提供商中的分布式系统的编排、部署和管理。它提供了许多能力和服务，应该能够在所有这些多样性中工作，同时演变并保持足够简单，以便普通人使用。这是一个艰巨的任务。Kubernetes通过遵循清晰的高级设计，并使用深思熟虑的架构来实现这一目标，促进可扩展性和可插拔性。Kubernetes的许多部分仍然是硬编码或环境感知的，但趋势是将它们重构为插件，并保持核心的通用性和抽象性。在本节中，我们将像剥洋葱一样剥开Kubernetes，从各种分布式系统设计模式开始，以及Kubernetes如何支持它们，然后介绍Kubernetes的机制，包括其一套API，然后看一下组成Kubernetes的实际组件。最后，我们将快速浏览源代码树，以更好地了解Kubernetes本身的结构。
- en: At the end of this section, you will have a solid understanding of the Kubernetes
    architecture and implementation, and why certain design decisions were made.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节结束时，您将对Kubernetes的架构和实现有扎实的了解，以及为什么会做出某些设计决策。
- en: Distributed systems design patterns
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式系统设计模式
- en: All happy (working) distributed systems are alike, to paraphrase Tolstoy in
    Anna Karenina. This means that, to function properly, all well-designed distributed
    systems must follow some best practices and principles. Kubernetes doesn't want
    to be just a management system. It wants to support and enable these best practices
    and provide high-level services to developers and administrators. Let's look at
    some of these design patterns.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所有快乐（工作）的分布式系统都是相似的，借用托尔斯泰在《安娜·卡列尼娜》中的话。这意味着，为了正常运行，所有设计良好的分布式系统都必须遵循一些最佳实践和原则。Kubernetes不只是想成为一个管理系统。它希望支持和促进这些最佳实践，并为开发人员和管理员提供高级服务。让我们来看看其中一些设计模式。
- en: Sidecar pattern
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边车模式
- en: The sidecar pattern is about co-locating another container in a pod in addition
    to the main application container. The application container is unaware of the
    sidecar container and just goes about its business. A great example is a central
    logging agent. Your main container can just log to `stdout`, but the sidecar container
    will send all logs to a central logging service where they will be aggregated
    with the logs from the entire system. The benefits of using a sidecar container
    versus adding central logging to the main application container are enormous.
    First, applications are no longer burdened with central logging, which could be
    a nuisance. If you want to upgrade or change your central logging policy or switch
    to a totally new provider, you just need to update the sidecar container and deploy
    it. None of your application containers change, so you can't break them by accident.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 边车模式是指在一个pod中除了主应用容器之外，还有另一个容器。应用容器对边车容器一无所知，只是按照自己的业务进行操作。一个很好的例子是中央日志代理。你的主容器可以直接记录到`stdout`，但是边车容器会将所有日志发送到一个中央日志服务，这样它们就会与整个系统的日志聚合在一起。使用边车容器与将中央日志添加到主应用容器中相比的好处是巨大的。首先，应用不再被中央日志所拖累，这可能会很麻烦。如果你想升级或更改你的中央日志策略，或者切换到一个全新的提供者，你只需要更新边车容器并部署它。你的应用容器都不会改变，所以你不会意外地破坏它们。
- en: Ambassador pattern
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大使模式
- en: The ambassador pattern is about representing a remote service as if it were
    local and possibly enforcing a policy. A good example of the ambassador pattern
    is if you have a Redis cluster with one master for writes and many replicas for
    reads. A local ambassador container can serve as a proxy and expose Redis to the
    main application container on the localhost. The main application container simply
    connects to Redis on `localhost:6379` (Redis's default port), but it connects
    to the ambassador running in the same pod, which filters the requests, sends write
    requests to the real Redis master, and read requests randomly to one of the read
    replicas. Just as we saw with the sidecar pattern, the main application has no
    idea what's going on. That can help a lot when testing against a real local Redis.
    Also, if the Redis cluster configuration changes, only the ambassador needs to
    be modified; the main application remains blissfully unaware.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 大使模式是指将远程服务表示为本地服务，并可能强制执行某种策略。大使模式的一个很好的例子是，如果你有一个Redis集群，有一个主节点用于写入，还有许多副本用于读取。一个本地的大使容器可以作为代理，将Redis暴露给主应用容器在本地主机上。主应用容器只需连接到`localhost:6379`（Redis的默认端口），但它连接到在同一个pod中运行的大使，大使会过滤请求，将写请求发送到真正的Redis主节点，将读请求随机发送到其中一个读取副本。就像我们在边车模式中看到的一样，主应用并不知道发生了什么。这在对真实的本地Redis进行测试时会有很大帮助。此外，如果Redis集群配置发生变化，只需要修改大使；主应用仍然毫不知情。
- en: Adapter pattern
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器模式
- en: 'The adapter pattern is about standardizing output from the main application
    container. Consider the case of a service that is being rolled out incrementally:
    It may generate reports in a format that doesn''t conform to the previous version.
    Other services and applications that consume that output haven''t been upgraded
    yet. An adapter container can be deployed in the same pod with the new application
    container and can alter its output to match the old version until all consumers
    have been upgraded. The adapter container shares the filesystem with the main
    application container, so it can watch the local filesystem, and whenever the
    new application writes something, it immediately adapts it.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式是关于标准化主应用程序容器的输出。考虑一个逐步推出的服务的情况：它可能生成的报告格式与以前的版本不符。消费该输出的其他服务和应用程序尚未升级。适配器容器可以部署在与新应用程序容器相同的pod中，并可以修改其输出以匹配旧版本，直到所有消费者都已升级。适配器容器与主应用程序容器共享文件系统，因此它可以监视本地文件系统，每当新应用程序写入内容时，它立即进行适应。
- en: Multinode patterns
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多节点模式
- en: The single-node patterns are all supported directly by Kubernetes through pods.
    Multinode patterns, such as leader election, work queues, and scatter-gather,
    are not supported directly, but composing pods with standard interfaces to accomplish
    them is a viable approach with Kubernetes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes直接支持单节点模式，通过pod。多节点模式，如领导者选举、工作队列和分散收集，不受直接支持，但通过使用标准接口组合pod来实现它们是一种可行的方法。
- en: The Kubernetes APIs
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes API
- en: 'If you want to understand the capabilities of a system and what it provides,
    you must pay a lot of attention to its APIs. These APIs provide a comprehensive
    view of what you can do with the system as a user. Kubernetes exposes several
    sets of REST APIs for different purposes and audiences through API groups. Some
    of the APIs are used primarily by tools and some can be used directly by developers.
    An important fact regarding the APIs is that they are under constant development.
    The Kubernetes developers keep it manageable by trying to extend it (by adding
    new objects and new fields to existing objects) and avoid renaming or dropping
    existing objects and fields. In addition, all API endpoints are versioned, and
    often have an alpha or beta notation too. For example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解一个系统的能力和提供的功能，你必须非常关注它的API。这些API为用户提供了对系统可以做什么的全面视图。Kubernetes通过API组向不同目的和受众暴露了几套REST
    API。一些API主要由工具使用，一些可以直接由开发人员使用。关于API的一个重要事实是它们在不断发展。Kubernetes开发人员通过尝试扩展它（通过向现有对象添加新对象和新字段）并避免重命名或删除现有对象和字段来使其可管理。此外，所有API端点都是有版本的，并且通常也有alpha或beta标记。例如：
- en: '[PRE3]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can access the API through the `kubectl cli`, through client libraries,
    or directly through REST API calls. There are elaborate authentication and authorization
    mechanisms that we will explore in a later chapter. If you have the right permissions,
    you can list, view, create, update, and delete various Kubernetes objects. At
    this point, let''s glimpse the surface area of the APIs. The best way to explore
    these APIs is through API groups. Some API groups are enabled by default. Other
    groups can be enabled/disabled via flags. For example, to disable the batch V1
    group and enable the batch V2 alpha group, you can set the `--runtime-config`
    flag when running the API server as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`kubectl cli`、客户端库或直接通过REST API调用访问API。我们将在后面的章节中探讨详细的身份验证和授权机制。如果您有适当的权限，您可以列出、查看、创建、更新和删除各种Kubernetes对象。在这一点上，让我们来一窥API的表面积。探索这些API的最佳方式是通过API组。一些API组是默认启用的。其他组可以通过标志启用/禁用。例如，要禁用批处理V1组并启用批处理V2
    alpha组，您可以在运行API服务器时设置`--runtime-config`标志如下：
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following resources are enabled by default, in addition to the core resources:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下启用以下资源，除了核心资源：
- en: '`DaemonSets`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DaemonSets`'
- en: '`Deployments`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Deployments`'
- en: '`HorizontalPodAutoscalers`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HorizontalPodAutoscalers`'
- en: '``Ingress``'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '``Ingress``'
- en: '`Jobs`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Jobs`'
- en: '`ReplicaSets`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReplicaSets`'
- en: Discovery and load balancing
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现和负载平衡
- en: 'By default, workloads are only accessible within the cluster, and they must
    be exposed externally using either a `LoadBalancer` or `NodePort` service. During
    development, internally accessible workloads can be accessed via a proxy through
    the API master using the `kubectl proxy` command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，工作负载只能在集群内访问，必须使用`LoadBalancer`或`NodePort`服务将其外部暴露。在开发过程中，可以通过使用`kubectl
    proxy`命令通过API主机访问内部可访问的工作负载：
- en: '`Endpoints`: Core'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Endpoints`: 核心'
- en: '`Ingress`: Extensions'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ingress`: 扩展'
- en: '`Service`: Core'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Service`: 核心'
- en: Resource categories
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源类别
- en: 'In addition to API groups, another useful classification of the available APIs
    is functionality. The Kubernetes API is huge, and breaking it down into categories
    helps a lot when you''re trying to find your way around. Kubernetes defines the
    following resource categories:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除了API组之外，可用API的另一个有用的分类是功能。Kubernetes API非常庞大，将其分成不同类别在你试图找到自己的路时非常有帮助。Kubernetes定义了以下资源类别：
- en: '**Workloads**: The objects you use to manage and run containers on the cluster.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作负载**：您用来管理和运行集群上的容器的对象。'
- en: '**Discovery and load balancing**: The objects you use to expose your workloads
    to the world as externally accessible, load-balanced services.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发现和负载平衡**：您用来将工作负载暴露给外部可访问、负载平衡服务的对象。'
- en: '**Config and storage**: The objects you use to initialize and configure your
    applications, and to persist data that is outside the container.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置和存储**：您用来初始化和配置应用程序，并持久化容器外的数据的对象。'
- en: '**Cluster**: The objects that define how the cluster itself is configured;
    these are typically used only by cluster operators.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群**：定义集群本身配置的对象；这些通常只由集群操作员使用。'
- en: '**Metadata**: The objects you use to configure the behavior of other resources
    within the cluster, such as `HorizontalPodAutoscaler` for scaling workloads.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元数据**：您用来配置集群内其他资源行为的对象，例如用于扩展工作负载的`HorizontalPodAutoscaler`。'
- en: In the following subsections, I'll list the resources that belong to each group,
    along with the API group they belong to. I will not specify the version here because
    APIs move rapidly from alpha to beta to **general availability** (**GA**), and
    then from V1 to V2, and so on.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我将列出属于每个组的资源，以及它们所属的API组。我不会在这里指定版本，因为API从alpha迅速转移到beta到**一般可用性**（**GA**），然后从V1到V2，依此类推。
- en: Workloads API
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作负载API
- en: 'The workloads API contains the following resources:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 工作负载API包含以下资源：
- en: '`Container`: Core'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Container`: 核心'
- en: '`CronJob`: Batch'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CronJob`: 批处理'
- en: '`DaemonSet`: Apps'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DaemonSet`: 应用'
- en: '`Deployment`: Apps'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Deployment`: 应用'
- en: '`Job`: Batch'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Job`: 批处理'
- en: '`Pod`: Core'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pod`: 核心'
- en: '`ReplicaSet`: Apps'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReplicaSet`: 应用'
- en: '`ReplicationController`: Core'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReplicationController`: 核心'
- en: '`StatefulSet`: Apps'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StatefulSet`: 应用'
- en: Containers are created by controllers using pods. Pods run containers and provide
    environmental dependencies, such as shared or persistent storage volumes, and
    configuration or secret data injected into the container.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是由控制器使用pod创建的。Pod运行容器并提供环境依赖项，如共享或持久存储卷，以及注入到容器中的配置或秘密数据。
- en: 'Here is a detailed description of one of the most common operations, which
    gets a list of all the pods as a REST API:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常见操作之一的详细描述，它以REST API的形式获取所有pod的列表：
- en: '[PRE5]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It accepts various query parameters (all optional):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受各种查询参数（全部可选）：
- en: '`pretty`: If true, the output is pretty printed'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pretty`: 如果为true，则输出将被漂亮地打印'
- en: '`labelSelector`: A selector expression to limit the result'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labelSelector`: 限制结果的选择器表达式'
- en: '`watch`: If true, this watches for changes and returns a stream of events'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`watch`: 如果为true，则会监视更改并返回事件流'
- en: '`resourceVersion`: Returns only events that occurred after that version'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resourceVersion`: 仅返回在该版本之后发生的事件'
- en: '`timeoutSeconds`: Timeout for the list or watch operation'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeoutSeconds`: 列表或监视操作的超时'
- en: Config and storage
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置和存储
- en: 'Dynamic configuration without redeployment is a cornerstone of Kubernetes and
    running complex distributed applications on your Kubernetes cluster:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的动态配置而无需重新部署是在您的Kubernetes集群上运行复杂分布式应用的基石：
- en: '`ConfigMap`: Core'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfigMap`: 核心'
- en: '`Secret`: Core'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Secret`: 核心'
- en: '`PersistentVolumeClaim`: Core'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PersistentVolumeClaim`: 核心'
- en: '`StorageClass`: Storage'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StorageClass`: 存储'
- en: '`VolumeAttachment`: Storage'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VolumeAttachment`: 存储'
- en: Metadata
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元数据
- en: The metadata resources typically are embedded as subresources of the resources
    they configure. For example, a limit range will be part of a pod configuration.
    You will not interact with these objects directly most of the time. There are
    many metadata resources. You can find the complete list at [https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/#-strong-metadata-strong-](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/#-strong-metadata-strong-).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据资源通常嵌入为它们配置的资源的子资源。例如，限制范围将成为pod配置的一部分。大多数情况下，您不会直接与这些对象交互。有许多元数据资源。您可以在[https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/#-strong-metadata-strong-](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/#-strong-metadata-strong-)找到完整的列表。
- en: Cluster
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群
- en: 'The resources in the cluster category are designed for use by cluster operators
    as opposed to developers. There are many resources in this category as well. Here
    some of the most important resources:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 集群类别中的资源是为集群操作员设计的，而不是开发人员。这个类别中也有许多资源。以下是一些最重要的资源：
- en: '`Namespace`: Core'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Namespace`: 核心'
- en: '`Node`: Core'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Node`: 核心'
- en: '`PersistentVolume`: Core'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PersistentVolume`: 核心'
- en: '`ResourceQuota` : Core'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResourceQuota`：核心'
- en: '`ClusterRole`: Rbac'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClusterRole`: Rbac'
- en: '`NetworkPolicy` : Networking'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NetworkPolicy`：网络'
- en: Kubernetes components
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes组件
- en: A Kubernetes cluster has several master components that are used to control
    the cluster, as well as node components that run on each cluster node. Let's get
    to know all these components and how they work together.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群有几个主要组件，用于控制集群，以及在每个集群节点上运行的节点组件。让我们了解所有这些组件以及它们如何一起工作。
- en: Master components
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要组件
- en: The master components typically run on one node, but in a highly available or
    very large cluster, they may be spread across multiple nodes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 主要组件通常在一个节点上运行，但在高可用性或非常大的集群中，它们可能分布在多个节点上。
- en: API server
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API服务器
- en: The Kube API server exposes the Kubernetes REST API. It can easily scale horizontally
    as it is stateless and stores all the data in the `etcd` cluster. The API server
    is the embodiment of the Kubernetes control plane.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Kube API服务器公开了Kubernetes REST API。由于它是无状态的，并且将所有数据存储在`etcd`集群中，因此可以轻松地进行水平扩展。API服务器是Kubernetes控制平面的具体体现。
- en: Etcd
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Etcd
- en: Etcd is a highly reliable, distributed data store. Kubernetes uses it to store
    the entire cluster state. In a small, transient cluster, a single instance of
    `etcd` can run on the same node as all the other master components, but for more
    substantial clusters, it is typical to have a three-node or even five-node `etcd`
    cluster for redundancy and high availability.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Etcd是一个高度可靠的分布式数据存储。Kubernetes使用它来存储整个集群状态。在一个小型的瞬态集群中，一个`etcd`的实例可以在与所有其他主要组件相同的节点上运行，但对于更大的集群，通常会有一个三节点甚至五节点的`etcd`集群，以实现冗余和高可用性。
- en: Kube controller manager
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kube控制器管理器
- en: The Kube controller manager is a collection of various managers rolled up into
    one binary. It contains the replication controller, the pod controller, the services
    controller, the endpoints controller, and others. All these managers watch over
    the state of the cluster through the API and their job is to steer the cluster
    into the desired state.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Kube控制器管理器是各种管理器的集合，汇总成一个二进制文件。它包含复制控制器、Pod控制器、服务控制器、端点控制器等。所有这些管理器通过API监视集群的状态，它们的工作是将集群引导到期望的状态。
- en: Cloud controller manager
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云控制器管理器
- en: When running in the cloud, Kubernetes allows cloud providers to integrate their
    platform for the purpose of managing nodes, routes, services, and volumes. The
    cloud provider code interacts with the Kubernetes code. It replaces some of the
    functionality of the Kube controller manager. When running Kubernetes with a cloud
    controller manager, you must set the Kube controller manager flag `--cloud-provider`
    to *external*. This will disable the control loops that the cloud controller manager
    is taking over. The cloud controller manager was introduced in Kubernetes 1.6
    and it is being used by multiple cloud providers already.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在云中运行时，Kubernetes允许云提供商集成其平台，以管理节点、路由、服务和卷。云提供商代码与Kubernetes代码进行交互。它替换了Kube控制器管理器的一些功能。在使用云控制器管理器运行Kubernetes时，必须将Kube控制器管理器标志`--cloud-provider`设置为*external*。这将禁用云控制器管理器正在接管的控制循环。云控制器管理器是在Kubernetes
    1.6中引入的，并且已被多个云提供商使用。
- en: 'A quick note about Go to help you parse the code: The method name comes first,
    followed by the method''s parameters in parentheses. Each parameter is a pair,
    consisting of a name followed by its type. Finally, the return values are specified.
    Go allows multiple return types. It is very common to return an `error` object
    in addition to the actual result. If everything is OK, the `error` object will
    be nil.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Go的一个快速说明，以帮助您解析代码：方法名首先出现，然后是方法的参数在括号中。每个参数都是一对，由名称和类型组成。最后，指定返回值。Go允许多个返回类型。通常会返回一个`error`对象，除了实际结果。如果一切正常，`error`对象将为nil。
- en: 'Here is the main interface of the `cloudprovider` package:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`cloudprovider`包的主要接口：
- en: '[PRE6]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Most of the methods return other interfaces with their own method. For example,
    here is the `LoadBalancer` interface:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数方法返回具有自己方法的其他接口。例如，这是`LoadBalancer`接口：
- en: '[PRE7]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Kube-scheduler
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kube-scheduler
- en: '`kube-scheduler` is responsible for scheduling pods into nodes. This is a very
    complicated task as it requires considering multiple interacting factors, such
    as the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`kube-scheduler`负责将Pod调度到节点。这是一个非常复杂的任务，因为它需要考虑多个相互作用的因素，例如：'
- en: Resource requirements
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源要求
- en: Service requirements
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务要求
- en: Hardware/software policy constraints
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件/软件策略约束
- en: Node affinity and antiaffinity specifications
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点亲和性和反亲和性规范
- en: Pod affinity and antiaffinity specifications
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod亲和性和反亲和性规范
- en: Taints and tolerations
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 污点和容忍
- en: Data locality
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据本地性
- en: Deadlines
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 截止日期
- en: If you need some special scheduling logic not covered by the default Kube scheduler,
    you can replace it with your own custom scheduler. You can also run your custom
    scheduler side by side with the default scheduler and have your custom scheduler
    schedule only a subset of the pods.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要一些默认Kube调度程序未涵盖的特殊调度逻辑，可以用自己的自定义调度程序替换它。您还可以将自定义调度程序与默认调度程序并行运行，并且让自定义调度程序仅调度一部分Pod。
- en: DNS
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS
- en: Since Kubernetes 1.3, a DNS service has been part of the standard Kubernetes
    cluster. It is scheduled as a regular pod. Every service (except headless services)
    receives a DNS name. Pods can receive a DNS name too. This is very useful for
    automatic discovery.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 自Kubernetes 1.3以来，DNS服务已成为标准Kubernetes集群的一部分。它被安排为一个常规的pod。每个服务（除了无头服务）都会收到一个DNS名称。Pods也可以收到DNS名称。这对于自动发现非常有用。
- en: Node components
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点组件
- en: Nodes in the cluster need a couple of components to interact with the cluster
    master components and to receive workloads to execute and update the cluster on
    their status.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 集群中的节点需要一些组件来与集群主组件交互，并接收要执行的工作负载并更新其状态。
- en: Proxy
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: The Kube proxy does low-level, network housekeeping on each node. It reflects
    the Kubernetes services locally and can do TCP and UDP forwarding. It finds cluster
    IPs through environment variables or DNS.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Kube代理在每个节点上进行低级别的网络维护。它在本地反映Kubernetes服务，并可以进行TCP和UDP转发。它通过环境变量或DNS找到集群IP。
- en: Kubelet
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubelet
- en: 'The kubelet is the Kubernetes representative on the node. It oversees communicating
    with the master components and manages the running pods. This includes the following
    actions:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: kubelet是节点上的Kubernetes代表。它负责与主组件通信并管理正在运行的pod。这包括以下操作：
- en: Downloading pod secrets from the API server
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从API服务器下载pod的秘密
- en: Mounting volumes
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载卷
- en: Running the pod's container (through the CRI or rkt)
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行pod的容器（通过CRI或rkt）
- en: Reporting the status of the node and each pod
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告节点和每个pod的状态
- en: Running container liveness probes
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行容器的活动探测
- en: In this section, we dug into the guts of Kubernetes, explored its architecture
    (from a very high-level perspective), and supported design patterns, through its
    APIs and the components used to control and manage the cluster. In the next section,
    we will take a quick look at the various runtimes that Kubernetes supports.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入研究了Kubernetes的内部，探索了其架构（从非常高层次的角度），并支持了设计模式，通过其API和用于控制和管理集群的组件。在下一节中，我们将快速浏览Kubernetes支持的各种运行时。
- en: Kubernetes runtimes
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes运行时
- en: 'Kubernetes originally only supported Docker as a container runtime engine.
    But that is no longer the case. Kubernetes now supports several different runtimes:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes最初只支持Docker作为容器运行时引擎。但现在不再是这样。Kubernetes现在支持几种不同的运行时：
- en: '`Docker` (through a CRI shim)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Docker`（通过CRI shim）'
- en: '`Rkt` (direct integration to be replaced with rktlet)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rkt`（直接集成将被rktlet替换）'
- en: '`Cri-o`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cri-o`'
- en: '`Frakti` (Kubernetes on the hypervisor, previously Hypernetes)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Frakti`（在hypervisor上的Kubernetes，以前是Hypernetes）'
- en: '`Rktlet` (CRI implementation for rkt)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rktlet`（rkt的CRI实现）'
- en: '`cri-containerd`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cri-containerd`'
- en: A major design policy is that Kubernetes itself should be completely decoupled
    from specific runtimes. The **Container Runtime Interface** (**CRI**) enables
    this.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一个主要的设计政策是Kubernetes本身应该完全与特定的运行时解耦。**容器运行时接口**（**CRI**）使这成为可能。
- en: "In this section, you'll get a closer look at the CRI and get to know \Lthe\
    \ individual runtime engines. At the end of this section, you'll be able to make\
    \ a well-informed decision about which runtime engine is appropriate for your\
    \ use case and under what circumstances you may switch or even combine multiple\
    \ runtimes in the same system."
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将更仔细地了解CRI，并了解各个运行时引擎。在本节结束时，您将能够就哪种运行时引擎适合您的用例做出明智的决定，并在何种情况下可以切换或甚至在同一系统中组合多个运行时。
- en: The Container Runtime Interface (CRI)
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器运行时接口（CRI）
- en: 'The CRI is a gRPC API, containing specifications/requirements and libraries
    for container runtimes to integrate with kubelet on a node. In Kubernetes 1.7,
    the internal Docker integration in Kubernetes was replaced with a CRI-based integration.
    This is a big deal. It opened the door to multiple implementations that take advantage
    of advances in the field of container. The Kubelet doesn''t need to interface
    directly with multiple runtimes. Instead, it can talk to any CRI-compliant container
    runtime. The following diagram illustrates the flow:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: CRI 是一个 gRPC API，包含容器运行时与节点上的 kubelet 集成的规范/要求和库。在 Kubernetes 1.7 中，Kubernetes
    中的内部 Docker 集成被 CRI-based 集成所取代。这是一件大事。它为利用容器领域的进步打开了多种实现的大门。Kubelet 不需要直接与多个运行时进行接口。相反，它可以与任何符合
    CRI 的容器运行时进行通信。以下图表说明了流程：
- en: '![](Images/853ca52c-c6d6-4597-9ff5-66679cb65e67.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/853ca52c-c6d6-4597-9ff5-66679cb65e67.png)'
- en: 'There are two gRPC service interfaces—`ImageService` and `RuntimeService`—that
    CRI container runtimes (or shims) must implement. The `ImageService` is responsible
    for managing images. Here is the gRPC/protobuf interface (this is not Go):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个 gRPC 服务接口——`ImageService` 和 `RuntimeService`——CRI 容器运行时（或 shims）必须实现。`ImageService`
    负责管理镜像。以下是 gRPC/protobuf 接口（这不是 Go）：
- en: '[PRE8]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `RuntimeService` is responsible for managing pods and containers. Here
    is the gRPC/profobug interface:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`RuntimeService` 负责管理 pod 和容器。以下是 gRPC/profobug 接口：'
- en: '[PRE9]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The data types used as arguments and return types are called messages, and
    are also defined as part of the API. Here is one of them:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 用作参数和返回类型的数据类型称为消息，并且也作为 API 的一部分进行定义。以下是其中之一：
- en: '[PRE10]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, messages can be embedded inside each other. The `CreateContainerRequest`
    message has one string field and two other fields, which are themselves messages:
    `ContainerConfig` and `PodSandboxConfig`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，消息可以嵌套在彼此之内。`CreateContainerRequest` 消息有一个字符串字段和另外两个字段，它们本身也是消息：`ContainerConfig`
    和 `PodSandboxConfig`。
- en: Now that you are familiar at the code level with the Kubernetes runtime engine,
    let's look at the individual runtime engines briefly.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经在代码级别熟悉了 Kubernetes 运行时引擎，让我们简要地看一下各个运行时引擎。
- en: Docker
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker
- en: Docker is, of course, the 800-pound gorilla of containers. Kubernetes was originally
    designed to manage only Docker containers. The multi-runtime capability was first
    introduced in Kubernetes 1.3 and the CRI in Kubernetes 1.5\. Until then, Kubernetes
    could only manage Docker containers.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Docker 是容器的大象级存在。Kubernetes 最初设计仅用于管理 Docker 容器。多运行时功能首次在 Kubernetes 1.3
    中引入，而 CRI 则在 Kubernetes 1.5 中引入。在那之前，Kubernetes 只能管理 Docker 容器。
- en: 'If you are reading this book, I assume you''re very familiar with Docker and
    what it brings to the table. Docker is enjoying tremendous popularity and growth,
    but there is also a lot of criticism being directed toward it. Critics often mention
    the following concerns:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在阅读本书，我假设您非常熟悉 Docker 及其带来的功能。Docker 受到了巨大的欢迎和增长，但也受到了很多批评。批评者经常提到以下关注点：
- en: Security
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Difficulty setting up multi-container applications (in particular, networking)
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以设置多容器应用程序（特别是网络）
- en: Development, monitoring, and logging
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发、监控和日志记录
- en: Limitations of Docker containers running one command
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 容器运行一个命令的限制
- en: Releasing half-baked features too fast
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布不完善的功能太快
- en: Docker is aware of the criticisms and has addressed some of these concerns.
    In particular, Docker has invested in its Docker Swarm product. Docker swarm is
    a Docker-native orchestration solution that competes with Kubernetes. It is simpler
    to use than Kubernetes, but it's not as powerful or mature.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Docker意识到了这些批评，并解决了其中一些问题。特别是，Docker已经投资于其Docker Swarm产品。Docker Swarm是一个与Kubernetes竞争的Docker本地编排解决方案。它比Kubernetes更容易使用，但不如Kubernetes强大或成熟。
- en: Since Docker 1.12, swarm mode has been included in the Docker daemon natively,
    which upset some people because of its bloat and scope creep. That in turn made
    more people turn to CoreOS rkt as an alternative solution.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 自Docker 1.12以来，swarm模式已经内置在Docker守护程序中，这让一些人感到不满，因为它的臃肿和范围扩大。这反过来使更多的人转向CoreOS
    rkt作为替代解决方案。
- en: 'Since Docker 1.11, released in April 2016, Docker has changed the way it runs
    containers. The runtime now uses `containerd` and `runC` to run **Open Container
    Initiative** (**OCI**) images in containers:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 自Docker 1.11发布于2016年4月以来，Docker已经改变了运行容器的方式。运行时现在使用`containerd`和`runC`来在容器中运行**Open
    Container Initiative**（OCI）图像：
- en: '![](Images/c47c6e50-6bdf-4ffe-9a40-b4f39bdc0b77.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c47c6e50-6bdf-4ffe-9a40-b4f39bdc0b77.png)'
- en: Rkt
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rkt
- en: Rkt is a container manager from CoreOS (the developers of the CoreOS Linux distro,
    etcd, flannel, and more). The rkt runtime prides itself on its simplicity and
    strong emphasis on security and isolation. It doesn't have a daemon like the Docker
    engine, and relies on the OS init system, such as `systemd`, to launch the rkt
    executable. Rkt can download images (both **app container** (**appc**) images
    and OCI images), verify them, and run them in containers. Its architecture is
    much simpler.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Rkt是来自CoreOS的容器管理器（CoreOS Linux发行版、etcd、flannel等的开发者）。Rkt运行时以其简单性和对安全性和隔离性的强调而自豪。它没有像Docker引擎那样的守护程序，而是依赖于操作系统的init系统，比如`systemd`，来启动rkt可执行文件。Rkt可以下载图像（包括**应用容器**（appc）图像和OCI图像），验证它们，并在容器中运行。它的架构要简单得多。
- en: App container
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用容器
- en: CoreOS started a standardization effort in December 2014 called appc. This included
    the standard image format (ACI), runtime, signing, and discovery. A few months
    later, Docker started its own standardization effort with OCI. At this point,
    it seems these efforts will converge. This is a great thing as tools, images,
    and runtime will be able to interoperate freely. We're not there yet.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS在2014年12月启动了一个名为appc的标准化工作。这包括标准图像格式（ACI）、运行时、签名和发现。几个月后，Docker开始了自己的标准化工作，推出了OCI。目前看来，这些努力将会融合。这是一件好事，因为工具、图像和运行时将能够自由地互操作。但我们还没有达到这一点。
- en: Cri-O
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cri-O
- en: 'Cri-o is a Kubernetes incubator project. It is designed to provide an integration
    path between Kubernetes and OCI-compliant container runtimes, such as Docker.
    The idea is that Cri-O will provide the following capabilities:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Cri-o是一个Kubernetes孵化器项目。它旨在为Kubernetes和符合OCI标准的容器运行时（如Docker）之间提供集成路径。其想法是Cri-O将提供以下功能：
- en: Support multiple image formats, including the existing Docker image format
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多种图像格式，包括现有的Docker图像格式
- en: Support multiple means of downloading images, including trust and image verification
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多种下载图像的方式，包括信任和图像验证
- en: Container image management (managing image layers, overlaying filesystems, and
    so on)
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像管理（管理镜像层、叠加文件系统等）
- en: Container process life cycle management
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器进程生命周期管理
- en: The monitoring and logging required to satisfy the CRI
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满足CRI所需的监控和日志记录
- en: Resource isolation as required by the CRI
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据CRI所需的资源隔离
- en: Then any OCI-compliant container runtime can be plugged in and will be integrated
    with Kubernetes.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后任何符合OCI标准的容器运行时都可以被插入，并将与Kubernetes集成。
- en: Rktnetes
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rktnetes
- en: Rktnetes is Kubernetes plus rkt as the runtime engine. Kubernetes is still in
    the process of abstracting away the runtime engine. Rktnetes is not really a separate
    product. From the outside, all it takes is running the Kubelet on each node with
    a couple of command-line switches.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Rktnetes是Kubernetes加上rkt作为运行时引擎。Kubernetes仍在抽象化运行时引擎的过程中。Rktnetes实际上并不是一个单独的产品。从外部来看，只需要在每个节点上运行Kubelet并加上几个命令行开关。
- en: Is rkt ready for use in production?
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rkt准备好投入生产使用了吗？
- en: I don't have a lot of hands-on experience with rkt. However, it is used by Tectonic—the
    commercial CoreOS-based Kubernetes distribution. If you run a different type of
    cluster, I would suggest that you wait until rkt is integrated with Kubernetes
    through the CRI/rktlet. There are some known issues you need to be aware of when
    using rkt as opposed to Docker with Kubernetes—for example, missing volumes are
    not created automatically, Kubectl's attach and get logs don't work, and `init`
    containers are not supported, among other issues.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我对rkt没有太多的实际经验。然而，它被Tectonic使用——这是基于CoreOS的商业Kubernetes发行版。如果你运行不同类型的集群，我建议你等到rkt通过CRI/rktlet与Kubernetes集成。在使用rkt与Kubernetes相比，有一些已知的问题需要注意，例如，缺少的卷不会自动创建，Kubectl的attach和get
    logs不起作用，以及`init`容器不受支持，还有其他问题。
- en: Hyper containers
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超级容器
- en: Hyper containers are another option. A Hyper container has a lightweight VM
    (its own guest kernel) and it runs on bare metal. Instead of relying on Linux
    cgroups for isolation, it relies on a hypervisor. This approach presents an interesting
    mix compared to standard, bare-metal clusters that are difficult to set up and
    public clouds where containers are deployed on heavyweight VMs.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 超级容器是另一个选择。超级容器具有轻量级虚拟机（自己的客户机内核），并在裸金属上运行。它不依赖于Linux cgroups进行隔离，而是依赖于一个虚拟化程序。与难以设置的标准裸金属集群和在重量级虚拟机上部署容器的公共云相比，这种方法呈现出有趣的混合。
- en: Stackube
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stackube
- en: Stackube (previously called Hypernetes) is a multitenant distribution that uses
    Hyper containers as well as some OpenStack components for authentication, persistent
    storage, and networking. Since containers don't share the host kernel, it is safe
    to run containers of different tenants on the same physical host. Stackube uses
    Frakti as its container runtime, of course.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Stackube（之前称为Hypernetes）是一个多租户分发，它使用超级容器以及一些OpenStack组件进行身份验证、持久存储和网络。由于容器不共享主机内核，因此可以安全地在同一物理主机上运行不同租户的容器。当然，Stackube使用Frakti作为其容器运行时。
- en: In this section, we've covered the various runtime engines that Kubernetes supports,
    as well as the trend toward standardization and convergence. In the next section,
    we'll take a step back and look at the big picture, as well as how Kubernetes
    fits into the CI/CD pipeline.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经涵盖了Kubernetes支持的各种运行时引擎，以及标准化和融合的趋势。在下一节中，我们将退一步，看看整体情况，以及Kubernetes如何适应CI/CD流水线。
- en: Continuous integration and deployment
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成和部署
- en: Kubernetes is a great platform for running your microservice-based applications.
    But, at the end of the day, it is an implementation detail. Users, and often most
    developers, may not be aware that the system is deployed on Kubernetes. But Kubernetes
    can change the game and make things that were too difficult before possible.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是运行基于微服务的应用程序的绝佳平台。但归根结底，它只是一个实现细节。用户，甚至大多数开发人员，可能不知道系统是部署在Kubernetes上的。但Kubernetes可以改变游戏规则，使以前难以实现的事情成为可能。
- en: In this section, we'll explore the CI/CD pipeline and what Kubernetes brings
    to the table. At the end of this section, you'll be able to design CI/CD pipelines
    that take advantage of Kubernetes properties, such as easy-scaling and development-production
    parity, to improve the productivity and robustness of your day-to-day development
    and deployment.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨CI/CD流水线以及Kubernetes带来了什么。在本节结束时，您将能够设计利用Kubernetes属性的CI/CD流水线，例如易扩展性和开发-生产一致性，以提高您日常开发和部署的生产力和稳健性。
- en: What is a CI/CD pipeline?
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是CI/CD流水线？
- en: A CI/CD pipeline is a set of steps implemented by developers or operators that
    modify the code, data, or configuration of a system, test it, and deploy it to
    production. Some pipelines are fully automated and some are semiautomated with
    human checks. In large organizations, there may be test and staging environments
    that changes are deployed to automatically, but release to production requires
    manual intervention. The following diagram describes a typical pipeline.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD流水线是由开发人员或运营人员实施的一组步骤，用于修改系统的代码、数据或配置，对其进行测试，并将其部署到生产环境。一些流水线是完全自动化的，而一些是半自动化的，需要人工检查。在大型组织中，可能会有测试和暂存环境，更改会自动部署到这些环境，但发布到生产环境需要手动干预。下图描述了一个典型的流水线。
- en: '![](Images/07f96ca6-443c-4e47-a9f2-f3b8dc886bf4.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07f96ca6-443c-4e47-a9f2-f3b8dc886bf4.png)'
- en: It may be worth mentioning that developers can be completely isolated from the
    production infrastructure. Their interface is just a Git workflow—a good example
    of this is the Deis workflow (PaaS on Kubernetes; similar to Heroku).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，开发人员可以完全与生产基础设施隔离开来。他们的接口只是一个Git工作流程——Deis工作流程（在Kubernetes上的PaaS；类似于Heroku）就是一个很好的例子。
- en: Designing a CI/CD pipeline for Kubernetes
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Kubernetes设计CI/CD流水线
- en: When your deployment target is a Kubernetes cluster, you should rethink some
    traditional practices. For starters, the packaging is different. You need to bake
    images for your containers. Reverting code changes is super easy and instantaneous
    using smart labeling. It gives you a lot of confidence that, if a bad change slips
    through the testing net, somehow, you'll be able to revert to the previous version
    immediately. But you want to be careful there. Schema changes and data migrations
    can't be automatically rolled back.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的部署目标是一个Kubernetes集群时，你应该重新思考一些传统的做法。首先，打包是不同的。你需要为你的容器烘焙镜像。使用智能标签可以轻松且即时地回滚代码更改。这给了你很多信心，即使一个糟糕的更改通过了测试网，你也能立即回滚到上一个版本。但你要小心。模式更改和数据迁移不能自动回滚。
- en: Another unique capability of Kubernetes is that developers can run a whole cluster
    locally. That takes some work when you design your cluster, but since the microservices
    that comprise your system run in containers, and those containers interact through
    APIs, it is possible and practical to do. As always, if your system is very data
    driven, you will need to accommodate for that and provide data snapshots and synthetic
    data that your developers can use.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的另一个独特能力是开发人员可以在本地运行整个集群。当你设计你的集群时，这需要一些工作，但由于构成系统的微服务在容器中运行，并且这些容器通过API进行交互，这是可能和实际可行的。与往常一样，如果你的系统非常依赖数据，你需要为此做出调整，并提供数据快照和合成数据供开发人员使用。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot of ground, and you got to understand the design
    and architecture of Kubernetes. Kubernetes is an orchestration platform for microservice-based
    applications running as containers. Kubernetes clusters have master and worker
    nodes. Containers run within pods. Each pod runs on a single physical or virtual
    machine. Kubernetes directly supports many concepts, such as services, labels,
    and persistent storage. You can implement various distributed system design patterns
    on Kubernetes. Container runtimes just need to implement the CRI. Docker, rkt,
    Hyper containers, and more are supported.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容，你了解了Kubernetes的设计和架构。Kubernetes是一个用于运行容器化微服务应用程序的编排平台。Kubernetes集群有主节点和工作节点。容器在pod中运行。每个pod在单个物理或虚拟机上运行。Kubernetes直接支持许多概念，如服务、标签和持久存储。您可以在Kubernetes上实现各种分布式系统设计模式。容器运行时只需实现CRI。支持Docker、rkt、Hyper容器等等。
- en: In [Chapter 2](4a72bd61-c0d6-430b-b146-15a1ca3391da.xhtml), *Creating Kubernetes
    Clusters*, we will explore the various ways to create Kubernetes clusters, discuss
    when to use different options, and build a multi-node cluster.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](4a72bd61-c0d6-430b-b146-15a1ca3391da.xhtml)中，*创建Kubernetes集群*，我们将探讨创建Kubernetes集群的各种方式，讨论何时使用不同的选项，并构建一个多节点集群。
