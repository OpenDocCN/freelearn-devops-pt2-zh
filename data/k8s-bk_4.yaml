- en: '4: Working with Pods'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4：使用Pods
- en: 'We’ll split this chapter in to two main parts:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把本章分为两个主要部分：
- en: Theory
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理论
- en: Hands-on
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动手
- en: Let’s crack on with the theory.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续理论。
- en: Pod theory
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pod理论
- en: In the virtualization world, the atomic unit of scheduling is the Virtual Machine
    (VM). This means that **deploying applications** in the virtualization world means
    scheduling them on VMs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟化世界中，调度的原子单位是虚拟机（VM）。这意味着在虚拟化世界中**部署应用程序**意味着在VM上调度它们。
- en: In the Docker world, the atomic unit is the container. This means that **deploying
    applications** on Docker means deploying them inside of containers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker世界中，原子单位是容器。这意味着在Docker上**部署应用程序**意味着将它们部署在容器内。
- en: In the Kubernetes world, the atomic unit is the *Pod* . Ergo, **deploying applications**
    on Kubernetes means stamping them out as Pods.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes世界中，原子单位是*Pod*。因此，在Kubernetes上**部署应用程序**意味着将它们作为Pods部署。
- en: '![Figure 4.1](Image00022.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1](Image00022.jpg)'
- en: Figure 4.1
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1
- en: Be sure to take this and tag it in your brain as important - Virtualization
    does VM’s, Docker does containers, and **Kubernetes does Pods!**
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将这一点记在脑海中并标记为重要 - 虚拟化使用VM，Docker使用容器，**Kubernetes使用Pods！**
- en: As Pods are the fundamental unit of deployment on a Kubernetes cluster, it’s
    vital that we understand how they work.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Pods是Kubernetes集群上部署的基本单位，我们必须了解它们是如何工作的。
- en: '**Note:** We’re going to talk a lot about Pods in this chapter. However, it’s
    important to remember that Pods are just a vehicle for **deploying applications**
    .'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：**在本章中我们将大量讨论Pods。然而，重要的是要记住Pods只是**部署应用程序**的一种工具。'
- en: Pods vs containers
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pods vs容器
- en: At a high-level, Pods sit somewhere in between a containers and VMs. They’re
    bigger than a container, but a lot smaller than a VM.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，Pods位于容器和VM之间。它们比容器大，但比VM小得多。
- en: Digging a bit deeper, a Pod is a shared execution environment for one or more
    containers. More often than not, a Pod only has one container. But multi-container
    Pods are definitely a thing, and they’re great for co-scheduling tightly-coupled
    workloads. For example, two containers that share resources and wouldn’t work
    well if they were scheduled on different nodes in the cluster. Another increasingly
    common use-case for multi-container Pods is logging and service meshes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘一下，Pod是一个或多个容器的共享执行环境。往往情况下，一个Pod只有一个容器。但多容器Pod绝对是存在的，它们非常适合协同调度紧密耦合的工作负载。例如，共享资源并且如果它们被调度到集群中的不同节点上将无法正常工作的两个容器。多容器Pod越来越常见的另一个用例是日志记录和服务网格。
- en: 'Pods: the canonical example'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pods：典型的例子
- en: The example we usually use when comparing single-container and multi-container
    Pods is a web server that has a file synchronizer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常在比较单容器和多容器Pods时使用的例子是一个具有文件同步器的Web服务器。
- en: 'In this example we have two clear *concerns* :'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个明确的*关注点*：
- en: Serving the web page
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供网页
- en: Making sure the content is up-to-date
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保内容是最新的
- en: '**Note:** Think of a *concern* as a requirement/task. In microservices architectures
    we often refer to concerns as *services* . In the previous list we might call
    the *web page concern* the *web page service* . Each *service* deals with one
    *concern* .'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：**将*关注点*视为需求/任务。在微服务架构中，我们经常将关注点称为*服务*。在前面的列表中，我们可能将*网页关注点*称为*网页服务*。每个*服务*处理一个*关注点*。'
- en: Generally speaking, microservices design patterns dictate that we should separate
    concerns. This means one *concern* per container. Assuming the previous example,
    that would be one container for the web service, another container for the file-sync
    service.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，微服务设计模式要求我们应该分离关注点。这意味着一个容器只处理一个*关注点*。假设前面的例子，一个容器用于web服务，另一个容器用于文件同步服务。
- en: This approach has a lot of advantages.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有很多优势。
- en: Instead of building a monolith, where a single Pod runs the web service *and*
    file-sync service, we’re building two microservices - each with its own distinct
    concern. This means we can have different teams responsible for each of the two
    services. We can scale each service independently. We can also update them independently.
    And if the Pod running the file-sync service fails, the web service can stay up
    (though it may end up serving stale content).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是构建单体应用程序，其中单个Pod运行Web服务*和*文件同步服务，而是构建两个微服务-每个微服务都有自己独特的关注点。这意味着我们可以有不同的团队负责这两个服务。我们可以独立扩展每个服务。我们也可以独立更新它们。如果运行文件同步服务的Pod失败，Web服务可以保持运行（尽管可能会提供过时内容）。
- en: However, sometimes it makes sense to co-schedule multiple containers in a single
    Pod. Use-cases include; two containers that need to share memory or share a volume.
    See Figure 4.2.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时在单个Pod中共同调度多个容器是有意义的。使用情况包括；需要共享内存或共享卷的两个容器。见图4.2。
- en: '![Figure 4.2](Image00023.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2](Image00023.jpg)'
- en: Figure 4.2
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2
- en: In this scenario, we are not separating concerns - a single Pod is doing two
    jobs. However, the simplest way to implement a shared volume is to schedule the
    containers that will be sharing the volume on the same node. By running the web
    service container and the file-sync container in the same Pod, we ensure they
    are deployed to the same node. We also give them a shared operating environment
    where both can access the same shared memory and shared volumes etc. More on all
    of this later.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们没有分离关注点-一个单独的Pod正在执行两项任务。然而，实现共享卷的最简单方法是将将共享卷的容器调度到同一节点上。通过在同一个Pod中运行Web服务容器和文件同步容器，我们确保它们部署到同一节点上。我们还为它们提供了一个共享的操作环境，两者都可以访问相同的共享内存和共享卷等。稍后会详细介绍所有这些。
- en: In summary, the general rule is separate concerns by designing Pods and containers
    do a single job, and then scheduling a single container per Pod. However, there
    are use-cases where breaking this rule has advantages.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，一般规则是通过设计Pod和容器来分离关注点，每个Pod执行单个任务，然后为每个Pod调度单个容器。然而，有些情况下打破这个规则是有优势的。
- en: How do we deploy Pods
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我们如何部署Pods
- en: To deploy a Pod to a Kubernetes cluster we define it in a *manifest file* and
    `POST` that manifest file to the API server. The control plane examines it, records
    it in the cluster store, and the scheduler deploys it to a healthy node with enough
    available resources. This process is identical no matter how many containers a
    Pod is running.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Pod部署到Kubernetes集群中，我们在*清单文件*中定义它，并将该清单文件`POST`到API服务器。控制平面检查它，将其记录在集群存储中，并调度器将其部署到具有足够可用资源的健康节点上。无论Pod运行多少个容器，这个过程都是相同的。
- en: '![Figure 4.3](Image00024.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3](Image00024.jpg)'
- en: Figure 4.3
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3
- en: Let’s dig a bit deeper…
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入一点…
- en: The anatomy of a Pod
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pod的解剖
- en: At the highest level, a Pod is a shared execution environment for one or more
    containers. “Shared execution environment” means that the Pod has a set of resources
    that are shared by every container inside the Pod. These resources include; IP
    addresses, ports, hostname, sockets, memory, volumes, and more…
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在最高级别上，Pod是一个或多个容器的共享执行环境。“共享执行环境”意味着Pod具有一组资源，这些资源被Pod内的每个容器共享。这些资源包括；IP地址，端口，主机名，套接字，内存，卷等等…
- en: If you’re using Docker as the container runtime for Kubernetes, a Pod is actually
    a special type of container called the **pause container** . That’s right, a Pod
    is just a fancy name for a special container!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将Docker用作Kubernetes的容器运行时，Pod实际上是一种称为**暂停容器**的特殊容器。没错，Pod只是一个特殊容器的花哨名称！
- en: This means the containers that run inside of Pods are really containers running
    inside of containers! For more information, watch “Inception” by Christopher Nolan,
    starring Leonardo DiCaprio :-D
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在Pod内运行的容器实际上是在容器内运行的容器！有关更多信息，请观看克里斯托弗·诺兰执导、莱昂纳多·迪卡普里奥主演的《盗梦空间》:-D
- en: 'Seriously though, the Pod (pause container) is just a collection of system
    resources that containers running inside of it will inherit and share. These `system
    resources` are `kernel namespaces` and include:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Pod（暂停容器）只是容器内运行的容器将继承和共享的一组系统资源。这些“系统资源”是“内核命名空间”，包括：
- en: '**Network namespace:** IP address, port range, routing table…'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络命名空间：IP地址、端口范围、路由表…
- en: '**UTS namespace:** Hostname'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTS命名空间：主机名
- en: '**IPC namespace:** Unix domain sockets…'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPC命名空间：Unix域套接字…
- en: As we just mentioned, this means that all containers in a Pod share a hostname,
    IP address, memory address space, and volumes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才提到的，这意味着Pod中的所有容器共享主机名、IP地址、内存地址空间和卷。
- en: Let’s look a bit closer at how this affects networking.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这如何影响网络。
- en: Each Pod creates its own network namespace - a single IP address, a single range
    of ports, and a single routing table. This is true even if the Pod is a multi-container
    Pod - each container in a Pod shares the Pod’s; IP, range of ports, and routing
    table.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Pod都创建自己的网络命名空间 - 单个IP地址、单个端口范围和单个路由表。即使Pod是多容器Pod，每个Pod中的容器也共享Pod的IP、端口范围和路由表。
- en: Figure 4.4 shows two Pods, each with its own IP. Even though one of the Pods
    is hosting two containers, it still only gets a single IP.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4显示了两个具有自己IP的Pod。即使其中一个Pod托管了两个容器，它仍然只有一个IP。
- en: '![Figure 4.4](Image00025.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4](Image00025.jpg)'
- en: Figure 4.4
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4
- en: In the example in Figure 4.4, we can access the individual containers in Pod
    1 using a combination of the Pod IP, coupled with the containers individual port
    number (80 and 5000).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在图4.4的示例中，我们可以使用Pod IP与容器的个别端口号（80和5000）来访问Pod 1中的各个容器。
- en: One last time (apologies if it feels like I’m over-repeating myself)… Each container
    in a Pod shares the **Pod’s** entire network namespace - IP, `localhost` adapter,
    port range, routing table, and more.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次（如果感觉我反复强调了，我很抱歉）… Pod中的每个容器都共享**Pod**的整个网络命名空间 - IP、`localhost`适配器、端口范围、路由表等。
- en: But as we’ve said, it’s more than just networking. All containers in a Pod have
    access to the same volumes, the same memory, the same IPC sockets, and more. Technically
    speaking, the Pod (pause container) holds all the namespaces, any containers in
    the Pod inherit them and share them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如我们所说，它不仅仅是网络。Pod中的所有容器都可以访问相同的卷、相同的内存、相同的IPC套接字等。从技术上讲，Pod（暂停容器）包含所有命名空间，Pod中的任何容器都会继承并共享它们。
- en: This networking model makes *inter-Pod* communication really simple. Every Pod
    in the cluster has its own IP addresses that’s fully routable on the *Pod network*
    . If you read the chapter on installing Kubernetes, you’ll have seen how we created
    a Pod network at the end of the *Play with Kubernetes* , and *kubeadm* sections.
    Because every Pod gets its own routable IP, every Pod can talk directly to every
    other Pod. No need to mess around with things like nasty port mappings!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种网络模型使*Pod间*通信变得非常简单。集群中的每个Pod都有自己的IP地址，在*Pod网络*上是完全可路由的。如果您阅读了有关安装Kubernetes的章节，您会看到我们在*Play
    with Kubernetes*和*kubeadm*部分末尾创建了一个Pod网络。因为每个Pod都有自己的可路由IP，所以每个Pod都可以直接与其他Pod通信。不需要处理像恶心的端口映射之类的东西！
- en: '![Figure 4.5 Inter-Pod communication](Image00026.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 Pod间通信](Image00026.jpg)'
- en: Figure 4.5 Inter-Pod communication
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 Pod间通信
- en: '*Intra-Pod* communication - where two containers in the same Pod need to communicate
    - can happen via the Pod’s `localhost` interface.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pod内部*通信-同一Pod中的两个容器需要通信-可以通过Pod的`localhost`接口进行。'
- en: '![Figure 4.6 Intra-Pod communication](Image00027.gif)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 Pod内部通信](Image00027.gif)'
- en: Figure 4.6 Intra-Pod communication
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 Pod内部通信
- en: If you need to make multiple containers in the same Pod available to the outside
    world, you can expose them on individual ports. Each container needs its own port,
    and two containers in the same Pod cannot use the same port.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要使同一Pod中的多个容器对外界可用，可以在各自的端口上公开它们。每个容器都需要自己的端口，同一Pod中的两个容器不能使用相同的端口。
- en: In summary. It’s all about the **Pod!** The **Pod** gets deployed, the **Pod**
    gets the IP, the **Pod** owns all of the namespaces… The **Pod** is at the center
    of the Kuberverse!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 总之。一切都关乎**Pod**！**Pod**被部署，**Pod**获得IP，**Pod**拥有所有的命名空间... **Pod**是Kuberverse的中心！
- en: Pods and cgroups
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pods和cgroups
- en: At a high level, Control Groups (cgroups) are what stop individual containers
    from consuming all of the available CPU, RAM and IOPS on a node. We could say
    that cgroups “police” resource usage.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，控制组（cgroups）是阻止单个容器在节点上消耗所有可用的CPU、RAM和IOPS的东西。我们可以说cgroups“监管”资源使用。
- en: Individual containers have their own cgroup limits.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 单个容器有自己的cgroup限制。
- en: This means it’s possible for two containers in a single Pod to have their own
    set of cgroup limits. This is a powerful and flexible model. If we assume the
    canonical multi-container Pod example from earlier in the chapter, we could set
    a cgroup limit on the file sync container so that it has access to less resources
    than the web service container. This would reduce the risk of it starving the
    web service container of CPU and memory.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着单个Pod中的两个容器可以拥有自己的cgroup限制集。这是一个强大而灵活的模型。如果我们假设前面章节中的典型多容器Pod示例，我们可以在文件同步容器上设置cgroup限制，以便它可以访问比web服务容器更少的资源。这将减少它使web服务容器饥饿的CPU和内存的风险。
- en: Atomic deployment of Pods
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pod的原子部署
- en: Deploying a Pod is an *atomic operation* . This means it’s an all-or-nothing
    operation - there’s no such thing as a partially deployed Pod that can service
    requests.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 部署Pod是一个*原子操作*。这意味着这是一个全包或全不包的操作-没有部分部署的Pod可以提供服务。
- en: 'For example, either: everything inside of a Pod comes up and the Pod becomes
    available, **OR** , everything doesn’t come up and the Pod fails. This means you
    can never have a situation where you have a multi-container Pod with one of its
    containers up and accessible but the other container in a failed state! That’s
    not how it works. Nothing in the Pod is made available until the entire Pod is
    up. Once all Pod resources are ready, the Pod is made available.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要么：Pod中的所有内容都启动并且Pod变得可用，**或者**，所有内容都没有启动并且Pod失败。这意味着你永远不会出现一个多容器Pod的一部分容器启动并且可访问，但另一个容器处于失败状态的情况！这不是它的工作方式。直到整个Pod都启动后，Pod中的任何内容都不可用。一旦所有Pod资源准备就绪，Pod就变得可用。
- en: It’s also important to stress that any given Pod can only be running on a single
    node. This is the same as containers and VMs - you can’t have part of a Pod on
    one node and another part of it on another node. One Pod gets scheduled to one
    node!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是强调，任何给定的Pod只能在单个节点上运行。这与容器和虚拟机相同-你不能让一个Pod的一部分在一个节点上，另一部分在另一个节点上。一个Pod被调度到一个节点上！
- en: Pod lifecycle
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pod生命周期
- en: The lifecycle of typical Pod goes something like this. You define it in a YAML
    manifest file. Then you throw the manifest at the API server, and the Pod it defines
    gets scheduled to a healthy node. Once it’s scheduled to a node, it goes into
    the *pending* state while the node downloads images and fires up any containers.
    The Pod remains in this *pending* state until **all of its resources** are up
    and ready. Once everything’s up and ready, the Pod enters the *running* state.
    Once it’s completed everything it needs to do, it gets terminated and enters the
    *succeeded* state.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 典型Pod的生命周期大致如下。你在一个YAML清单文件中定义它。然后你将清单文件扔给API服务器，它定义的Pod被调度到一个健康的节点上。一旦它被调度到一个节点，它就进入*pending*状态，同时节点下载镜像并启动任何容器。Pod将保持在这个*pending*状态，直到**它的所有资源**都准备就绪。一旦一切都准备就绪，Pod进入*running*状态。一旦它完成了它需要做的一切，它就被终止并进入*succeeded*状态。
- en: If you deploy a Pod independently (not via a higher-level object), and that
    Pod fails, it is not rescheduled! For this reason, we rarely deploy them directly.
    It’s far more common to deploy them via higher-level objects like *Deployments*
    and *DaemonSets* , as these reschedule Pods when they fail.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你独立部署一个Pod（而不是通过更高级别的对象），并且该Pod失败了，它不会被重新调度！因此，我们很少直接部署它们。更常见的是通过更高级别的对象如*Deployments*和*DaemonSets*来部署它们，因为这些对象在它们失败时会重新调度Pods。
- en: When a Pod can’t start, it can remain in the *pending* state or go to the *failed*
    state. This is all shown in Figure 4.7.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个Pod无法启动时，它可以保持在*pending*状态或进入*failed*状态。这都显示在图4.7中。
- en: '![Figure 4.7 Pod lifecycle](Image00028.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 Pod生命周期](Image00028.jpg)'
- en: Figure 4.7 Pod lifecycle
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 Pod生命周期
- en: It’s also important to think of Pods as *mortal* . When they die, they die!
    There’s no bringing them back from the dead. This follows the *pets vs cattle*
    analogy - Pods should be treated as *cattle* . When they die, you replace them
    with another. There’s no tears and no funeral. The old one is gone, and a shiny
    new one – with the same config, but a different ID and IP - magically appears
    and takes its place.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将Pod视为*有限的*也很重要。当它们死了，它们就死了！不能让它们从死亡中复活。这遵循*宠物与牛群*的类比 - Pods应该被视为*牛群*。当它们死了，你用另一个替换它们。没有眼泪，没有葬礼。旧的消失了，一个全新的
    - 具有相同的配置，但不同的ID和IP - 神奇地出现并取代它的位置。
- en: '**Note:** No offense is intended to any person or any animal when referring
    to the *pets vs cattle* analogy.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**在提到*宠物与牛群*的类比时，不是针对任何人或动物的冒犯。'
- en: This is one of the main reasons you should code your applications so that they
    don’t store *state* in Pods. It’s also why we shouldn’t rely on individual Pod
    IPs etc.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你应该编写应用程序的主要原因之一，这样它们就不会在Pods中存储*状态*。这也是为什么我们不应该依赖于单个Pod IP等。
- en: Pod theory summary
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pod理论总结
- en: Pods are the atomic unit of scheduling in Kubernetes
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pods是Kubernetes中调度的原子单位
- en: You can have more than one container in a Pod. Single-container Pods are the
    simplest, but multi-container Pods are ideal for containers that need to be tightly
    coupled - maybe they need to share memory or volumes. They’re also great for logging
    and service meshes.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个Pod中可以有多个容器。单容器Pods是最简单的，但多容器Pods非常适合需要紧密耦合的容器 - 也许它们需要共享内存或卷。它们也非常适合日志记录和服务网格。
- en: Pods get scheduled on nodes – you can’t schedule a single Pod instance to span
    multiple nodes.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pods被调度到节点上 - 你不能调度一个单个Pod实例跨越多个节点。
- en: Pods get defined declaratively in a manifest file that is POSTed to the API
    server and assigned to nodes by the scheduler.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pods在一个清单文件中被声明，并通过调度器分配给节点。
- en: Hands-on with Pods
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与Pods一起动手
- en: It’s time to see Pods in action!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看Pods的实际操作了！
- en: For the examples in the rest of this chapter we’ll use the 3-node cluster shown
    in Figure 4.8.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余示例中，我们将使用图4.8中显示的3节点集群。
- en: '![Figure 4.8](Image00029.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8](Image00029.jpg)'
- en: Figure 4.8
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8
- en: It doesn’t matter where this cluster is, or how it was deployed. All that matters
    is that you have three Linux hosts configured into a Kubernetes cluster with at
    least one master and two nodes. You’ll also need `kubectl` installed and configured
    to talk to the cluster.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集群在哪里并不重要，或者它是如何部署的。重要的是你有三个Linux主机配置成一个Kubernetes集群，至少有一个主节点和两个节点。你还需要安装并配置`kubectl`以便与集群通信。
- en: If you do not have a cluster and would like to follow along, go to http://play-with-k8s.com
    and build a quick cluster - it’s free and easy.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有集群并希望跟随操作，请转到http://play-with-k8s.com并构建一个快速集群 - 这是免费且简单的。
- en: Following the Kubernetes mantra of *composable infrastructure* , we define Pods
    in manifest files, POST the manifest to the API server, and let the scheduler
    take care of instantiating the Pods on the cluster.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循Kubernetes的*可组合基础设施*理念，我们在清单文件中定义Pods，将清单发布到API服务器，并让调度器负责在集群上实例化Pods。
- en: Pod manifest files
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pod清单文件
- en: 'For the examples in this chapter we’re going to use the following Pod manifest.
    It’s available in the books GitHub repo under the `pods` folder called pod.yml:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，我们将使用以下Pod清单。它在书籍的GitHub存储库中的`pods`文件夹下的pod.yml中可用：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s step through what the YAML file is describing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解YAML文件在描述什么。
- en: 'Straight away we can see four top-level resources:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即可以看到四个顶级资源：
- en: '`.apiVersion`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.apiVersion`'
- en: '`.kind`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.kind`'
- en: '`.metadata`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.metadata`'
- en: '`.spec`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.spec`'
- en: The `.apiVersion` field tells us two things - the *API group* and the *API version*
    that will be used to create the object. Normally the format is `<api-group>/<version>`
    . However, Pods are defined in a special API group called the *core* group which
    omits the *api-group* part. For example, StorageClass objects are defined in `v1`
    of the `storage.k8s.io` API group and are described in YAML files as `storage.k8s.io/v1`
    . However, Pods are in the *core* API group which is special, as it omits the
    API group name.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`.apiVersion`字段告诉我们两件事 - 将用于创建对象的*API组*和*API版本*。通常格式为`<api-group>/<version>`。但是，Pods定义在一个称为*core*组的特殊API组中，该组省略了*api-group*部分。例如，StorageClass对象在`storage.k8s.io`
    API组的`v1`中定义，并在YAML文件中描述为`storage.k8s.io/v1`。但是，Pods位于特殊的*core* API组中，它省略了API组名称。'
- en: It’s possible for an object to be defined in multiple versions of an API group.
    For example, `some-api-group/v1` and `some-api-group/v2` . In this case, the definition
    in the newer group would probably include additional fields that extend the capabilities
    of the object. Think of the *version* field as defining the object schema - newer
    is usually better.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象可以在API组的多个版本中定义。例如，`some-api-group/v1`和`some-api-group/v2`。在这种情况下，较新组中的定义可能包括扩展对象功能的附加字段。将*version*字段视为定义对象模式
    - 新版本通常更好。
- en: Anyway, Pods are currently in the `v1` API group.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，Pods目前在`v1` API组中。
- en: The `.kind` field tells us the type of object being deployed. It has two obvious
    functions. Firstly, it makes reading YAML files easier. Secondly, it explicitly
    tells the control plane what type of object is being defined, and therefore which
    controller to pass it on to.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`.kind`字段告诉我们部署的对象类型。它有两个明显的功能。首先，它使阅读YAML文件更容易。其次，它明确告诉控制平面正在定义的对象类型，因此应将其传递给哪个控制器。'
- en: So far, we know we’re deploying a Pod object as defined in `v1` of the *core
    API group* .
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道我们正在部署一个在*core API组*的`v1`中定义的Pod对象。
- en: The `.metadata` section is where we attach a name and labels. These help us
    identify the object in the cluster. We also define the `namespace` that an object
    should be deployed in. Keeping things brief, namespaces allow us to logically
    divide clusters for management purposes. In the real world, it’s highly recommended
    to use namespaces. However, they should not be considered strong security boundaries.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`.metadata`部分是我们附加名称和标签的地方。这些帮助我们在集群中识别对象。我们还定义了对象应该部署在哪个`namespace`中。简而言之，命名空间允许我们在管理目的上逻辑地划分集群。在现实世界中，强烈建议使用命名空间。但是，它们不应被视为强大的安全边界。'
- en: The `.metadata` section of this Pod manifest is naming the Pod “hello-pod” and
    assigning it two labels. Labels are simple key-value pairs, but they’re insanely
    powerful! We’ll talk more about labels later as we build our knowledge.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Pod清单的`.metadata`部分将Pod命名为“hello-pod”并分配了两个标签。标签是简单的键值对，但它们非常强大！随着我们知识的积累，我们将更多地讨论标签。
- en: The `.spec` section is where we define any containers that will run in the Pod.
    Our example is deploying a Pod with a single container based on the `nigelpoulton/k8sbook:latest`
    image. It’s calling it hello-ctr and exposing it on port `8080` .
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`.spec`部分是我们定义将在Pod中运行的任何容器的地方。我们的示例是部署一个基于`nigelpoulton/k8sbook:latest`镜像的单个容器的Pod。它将其命名为hello-ctr，并在端口`8080`上公开它。'
- en: If this was a multi-container Pod, we’d define additional containers in the
    `.spec` section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个多容器的Pod，我们将在`.spec`部分定义额外的容器。
- en: 'Manifest files: Empathy as Code'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 清单文件：代码中的共情
- en: Quick side-step.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 快速侧步。
- en: 'Configuration files, such as Kubernetes manifest files, are excellent sources
    of documentation. As such, they have some secondary benefits. Two of these include:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件，比如Kubernetes清单文件，是文档的绝佳来源。因此，它们有一些次要的好处。其中两个包括：
- en: Helping speed-up the on-boarding process for new team members
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助加快新团队成员的入职过程
- en: Helping bridge the gap between developers and operations
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助弥合开发人员和运维之间的鸿沟
- en: For example, if you need a new team member to understand the basic functions
    and requirements of an application, get them to read the Kubernetes manifest files
    used to deploy it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你需要一个新团队成员理解一个应用的基本功能和需求，让他们阅读用于部署它的Kubernetes清单文件。
- en: Also, if you have a problem with developers not clearly articulating their application
    requirements, get them to use Kubernetes. As they describe their applications
    through Kubernetes manifests, these can then be used by operations staff to understand
    how the application works and what it requires from the environment.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你对开发人员没有清晰表达他们的应用需求有问题，让他们使用Kubernetes。当他们通过Kubernetes清单描述他们的应用时，运维人员可以使用这些清单来理解应用的工作原理以及它对环境的需求。
- en: 'These kinds of benefits were described by Nirmal Mehta as a form of *empathy
    as code* in his 2017 DockerCon talk entitled “A Strong Belief, Loosely Held: Bringing
    Empathy to IT”.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些好处被Nirmal Mehta描述为他在2017年DockerCon演讲中所说的*代码中的共情*的一种形式。
- en: I understand that describing YAML files like these as *“empathy as code”* sounds
    a bit extreme. However, there is merit to the concept - they definitely help.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道将这些YAML文件描述为*“代码中的共情”*听起来有点极端。然而，这个概念是有价值的-它们确实有帮助。
- en: Back to business…
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 回到正题...
- en: Deploying Pods from a manifest file
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从清单文件部署Pod
- en: If you’re following along with the examples, save the following manifest file
    as `pod.yml` in your current directory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟着示例操作，将以下清单文件保存为`pod.yml`在你当前的目录中。
- en: '[PRE1]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Use the following `kubectl` command to POST the manifest to the API server and
    deploy a Pod from it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下`kubectl`命令将清单POST到API服务器，并从中部署一个Pod。
- en: '[PRE2]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Although the Pod is showing as created, it might not be fully deployed on the
    cluster yet. This is because it can take time to pull the image.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Pod显示为已创建，但它可能尚未完全部署在集群上。这是因为拉取镜像可能需要一些时间。
- en: Run a `kubectl get pods` command to check the status.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`kubectl get pods`命令来检查状态。
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can see that the container is still being created - no doubt waiting for
    the image to be pulled from Docker Hub.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到容器仍在创建中 - 毫无疑问正在等待从Docker Hub拉取镜像。
- en: You can use the `kubectl describe pods hello-pod` command to drill into more
    detail.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`kubectl describe pods hello-pod`命令来深入了解更多细节。
- en: You can add the `--watch` flag to the `kubectl get pods` command so that you
    can monitor it and see when the status changes to running.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向`kubectl get pods`命令添加`--watch`标志，以便可以监视它，并查看状态何时变为运行状态。
- en: Congratulations! Your Pod has been scheduled to a healthy node in the cluster
    and is being monitored by the local `kubelet` process on the node. The `kubelet`
    process is the Kubernetes agent running on the node.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您的Pod已被调度到集群中的健康节点，并且正在由节点上的本地`kubelet`进程监视。`kubelet`进程是在节点上运行的Kubernetes代理。
- en: In future chapters we’ll see how to connect to the web server running in the
    Pod.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在以后的章节中，我们将看到如何连接到Pod中运行的Web服务器。
- en: Introspecting running Pods
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 审视运行中的Pods
- en: As good as the `kubectl get pods` command is, it’s a bit light on detail. Not
    to worry though, there’s plenty of options for deeper introspection.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`kubectl get pods`命令很好，但细节有点少。不过，不用担心，有很多选项可以进行更深入的内省。
- en: 'First up, `kubectl get` offers a couple of really simple flags that give you
    more information:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`kubectl get`提供了一些非常简单的标志，可以为您提供更多信息：
- en: The `-o wide` flag gives a couple more columns, but is still a single line of
    output.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`-o wide`标志提供了更多的列，但仍然是单行输出。'
- en: The `-o yaml` flag takes things to the next level! It returns a full copy of
    the Pod manifest from the cluster store. This output includes desired state (`.spec`
    ) and current observed status (`.status` ).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`-o yaml`标志将事情提升到了一个新的水平！它返回了从集群存储中的Pod清单的完整副本。此输出包括期望状态（`.spec`）和当前观察状态（`.status`）。'
- en: The following command shows a snipped version of a `kubectl get pods -o yaml`
    command.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示了`kubectl get pods -o yaml`命令的剪辑版本。
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice how the output contains more values than we initially set in our 13-line
    YAML file. Where does this extra information come from?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出包含的值比我们最初在13行的YAML文件中设置的要多。这些额外的信息是从哪里来的？
- en: 'Two main sources:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 两个主要来源：
- en: The Kubernetes Pod object contains a lot of properties - far more than we defined
    in the manifest. Those that we don’t specify are automatically expanded with default
    values by Kubernetes.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes Pod对象包含许多属性 - 远远超过我们在清单中定义的属性。我们没有指定的属性将由Kubernetes自动扩展为默认值。
- en: When you run a `kubectl get pods` with `-o yaml` you get the Pods *current observed
    state* as well as its *desired state* . This observed state is listed in the `.status`
    section.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您运行带有`-o yaml`的`kubectl get pods`时，您将获得Pods的*当前观察状态*以及其*期望状态*。此观察状态列在`.status`部分中。
- en: Another great Kubernetes introspection command is `kubectl describe` . This
    provides a nicely formatted, multi-line overview of an object. It even includes
    some important object lifecycle events. The following command describes the state
    of the hello-pod Pod and shows a snipped output.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很棒的Kubernetes内省命令是`kubectl describe`。它提供了一个格式良好的、多行的对象概述。它甚至包括一些重要的对象生命周期事件。以下命令描述了hello-pod
    Pod的状态，并显示了一个剪辑输出。
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The output has been snipped to help it fit the page.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输出已经被剪辑以使其适合页面。
- en: Another way to introspect a running Pod is to log into it or execute commands
    in it. We do this with the `kubectl exec` command. The following example shows
    how to execute a `ps aux` command in the first container in the `hello-pod` Pod.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 内省运行中的Pod的另一种方法是登录到其中或在其中执行命令。我们使用`kubectl exec`命令来实现这一点。以下示例显示了如何在`hello-pod`
    Pod中的第一个容器中执行`ps aux`命令。
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can log-in to the first container in the Pod with the following command.
    Once inside the container you can execute normal commands (as long as the command
    binaries are installed in the container).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令登录到Pod中的第一个容器。一旦进入容器，您可以执行正常的命令（只要命令二进制文件安装在容器中）。
- en: The `kubectl exec` command will log-in to the first container in the Pod and
    create a new shell session. Once inside the container, the `curl` command transfers
    data from the process listening on port `8080` .
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl exec`命令将登录到Pod中的第一个容器并创建一个新的shell会话。一旦进入容器，`curl`命令将从在端口`8080`上监听的进程传输数据。'
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `-it` flags make the `exec` session interactive and connects STDIN and STDOUT
    on your terminal windows to STDIN and STDOUT inside the first container in the
    Pod. When the command completes, your shell prompt will change, indicating that
    your shell is now connected to the container.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`-it`标志使`exec`会话变得交互，并将您的终端窗口上的STDIN和STDOUT连接到Pod中第一个容器内的STDIN和STDOUT。当命令完成时，您的shell提示符将更改，表示您的shell现在已连接到容器。'
- en: If you are running multi-container Pods, you will need to pass the `kubectl
    exec` command the `--container` flag and give it the name of the container in
    the Pod that you want to create the exec session with. If you do not specify this
    flag, the command will execute against the first container in the Pod. You can
    see the ordering and names of containers in a Pod with the `kubectl describe pods
    <pod>` command.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行多容器Pods，您将需要传递`kubectl exec`命令`--container`标志，并给出要在其中创建exec会话的Pod中容器的名称。如果您不指定此标志，该命令将针对Pod中的第一个容器执行。您可以使用`kubectl
    describe pods <pod>`命令查看Pod中容器的顺序和名称。
- en: One other command for introspecting Pods is the `kubectl logs` command. Like
    other Pod-related commands, if you don’t specify a container by name, it will
    execute against the first container in the Pod. The format of the command is `kubectl
    logs <pod>` .
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于内省Pod的命令是`kubectl logs`命令。与其他与Pod相关的命令一样，如果您没有按名称指定容器，它将针对Pod中的第一个容器执行。命令的格式是`kubectl
    logs <pod>`。
- en: There’s obviously a lot more to Pods than what we’ve covered. However, we’ve
    learned enough to get started.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Pods还有很多内容我们没有涉及到。但是，我们已经学到了足够的知识来开始。
- en: Clean-up your lab with the following command.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令清理您的实验室。
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Chapter Summary
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 章节总结
- en: In this chapter, we learned that the atomic unit of deployment in the Kubernetes
    world is the *Pod* . Each Pod consists of one or more containers and gets deployed
    to a single node in the cluster. The deployment operation is an all-or-nothing
    *atomic transaction* .
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到Kubernetes世界中部署的原子单位是*Pod*。每个Pod由一个或多个容器组成，并部署到集群中的单个节点。部署操作是一个全有或全无的*原子事务*。
- en: The best way to deploy a Pod is declaratively using a YAML manifest file. We
    use the `kubectl` command to `POST` the manifest to the API server, it gets stored
    in the cluster store and converted into a PodSpec that gets scheduled onto a healthy
    cluster node with enough available resources.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用YAML清单文件以声明方式部署Pod是最佳方式。我们使用`kubectl`命令将清单`POST`到API服务器，它将存储在集群存储中，并转换为一个PodSpec，然后被调度到具有足够可用资源的健康集群节点上。
- en: The process on the worker node that accepts the PodSpec is the `kubelet` . This
    is the main Kubernetes agent running on every node in the cluster. It takes the
    PodSpec and is responsible for pulling all images and starting all containers
    in the Pod.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接受PodSpec的工作节点上的进程是`kubelet`。这是在集群中每个节点上运行的主要Kubernetes代理。它接受PodSpec并负责拉取所有镜像并启动Pod中的所有容器。
- en: If a Pod fails, it is not automatically rescheduled. Because of this, we usually
    deploy them via higher-level objects such as Deployments and DaemonSets. These
    add things like self-healing and roll-backs, and are at the heart of what makes
    Kubernetes so powerful.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Pod失败，它不会自动重新调度。因此，我们通常通过更高级别的对象（如部署和守护进程）来部署它们。这些对象添加了诸如自愈和回滚之类的功能，是使Kubernetes如此强大的核心。
