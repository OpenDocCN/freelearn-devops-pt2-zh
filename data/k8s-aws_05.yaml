- en: Managing Complex Applications with Helm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Helm管理复杂的应用程序
- en: In the previous chapters, you started to learn how to build and deploy the configuration
    needed to run different applications on your Kubernetes cluster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，您开始学习如何构建和部署所需的配置，以在您的Kubernetes集群上运行不同的应用程序。
- en: Once you move beyond deploying the simplest of applications, you will discover
    that your applications often have one or more components that work in unison.
    For example, you might have a web application that displays information from a
    database that also uses a scheduled job to update that information on a regular
    basis. In order for this application to function correctly, both of these components
    need to be deployed and functioning correctly. Furthermore, these two components
    likely share some configuration, such as credentials for the backend database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您超越了部署最简单的应用程序，您会发现您的应用程序通常有一个或多个组件是协同工作的。例如，您可能有一个Web应用程序，它从数据库中显示信息，该数据库还使用定期作业定期更新该信息。为了使该应用程序能够正确运行，这两个组件都需要被部署并正确运行。此外，这两个组件可能共享一些配置，例如后端数据库的凭据。
- en: One other problem we might encounter when deploying applications to our Kubernetes
    cluster is one of reusability. Perhaps we need to run the same tool or application
    in multiple contexts or environments. For example, many organizations have a staging
    environment for testing new versions of software.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在将应用程序部署到我们的Kubernetes集群时，我们可能会遇到另一个问题，即可重用性的问题。也许我们需要在多个上下文或环境中运行相同的工具或应用程序。例如，许多组织都有一个用于测试软件新版本的暂存环境。
- en: When maintaining multiple environments, we ideally want the configuration in
    each environment to match as closely as possible, but of course, some differences
    in configuration are required. Maintaining multiple copies of Kubernetes manifests
    for each of your environments can be error prone, and gives you no guarantees
    that an application that worked in one environment will work in another.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在维护多个环境时，我们理想情况下希望每个环境中的配置尽可能匹配，但当然，配置中可能需要一些差异。维护每个环境的Kubernetes清单的多个副本可能会出错，并且不能保证在一个环境中运行的应用程序在另一个环境中也能正常工作。
- en: Helm is a popular tool in the Kubernetes ecosystem that solves these problems.
    It gives us a way of building packages (known as charts) of related Kubernetes
    objects that can be deployed in a cohesive way to a cluster. It also allows us
    to parameterize these packages, so they can be reused in different contexts and
    deployed to the varying environments that the services they provide might be needed
    in.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Helm是Kubernetes生态系统中的一款流行工具，它解决了这些问题。它为我们提供了一种构建相关Kubernetes对象的软件包（称为图表）的方式，可以以一种协调的方式部署到集群中。它还允许我们对这些软件包进行参数化，以便在不同的上下文中重复使用，并部署到可能需要这些服务的不同环境中。
- en: Like Kubernetes, development of Helm is overseen by the Cloud Native Computing
    Foundation. As well as Helm (the package manager), the community maintains a repository
    of standard charts for a wide range of open source software you can install and
    run on your cluster. From the Jenkins CI server to MySQL or Prometheus, it's simple
    to install and run complex deployments involving many underlying Kubernetes resources
    with Helm.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与Kubernetes一样，Helm的开发由Cloud Native Computing Foundation监督。除了Helm（软件包管理器）之外，社区还维护了一个标准图表的存储库，用于安装和运行各种开源软件，例如Jenkins
    CI服务器、MySQL或Prometheus，使用Helm可以简单地安装和运行涉及许多基础Kubernetes资源的复杂部署。
- en: 'In this chapter, you will learn:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: How to install the `helm` command-line tool
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装`helm`命令行工具
- en: How to install Helm's in-cluster component, Tiller
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装Helm的集群组件Tiller
- en: How you can deploy a service to your cluster using a community-maintained chart
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用社区维护的图表将服务部署到您的集群
- en: About the syntax you will need to know when creating charts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建图表时需要了解的语法
- en: How to host your own chart repository in order to share your charts within your
    organization, or more widely
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在自己的图表存储库中托管图表，以便在组织内或更广泛地共享您的图表
- en: Strategies for integrating Helm charts into your own deployment processes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Helm图表集成到您自己的部署流程的策略
- en: Installing Helm
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Helm
- en: If you have already set up your own Kubernetes cluster and have correctly configured
    `kubectl` on your machine, then it is simple to install Helm.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经设置了自己的Kubernetes集群，并且在您的机器上正确配置了 `kubectl`，那么安装Helm就很简单。
- en: macOS
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS
- en: 'On macOS, the simplest way to install the Helm client is with Homebrew:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，安装Helm客户端的最简单方法是使用Homebrew：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Linux and Windows
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux和Windows
- en: Every release of Helm includes prebuilt binaries for Linux, Windows, and macOS.
    Visit [https://github.com/kubernetes/helm/releases](https://github.com/kubernetes/helm/releases)
    to download the version you need for your platform.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Helm的每个版本都包括Linux、Windows和macOS的预构建二进制文件。访问[https://github.com/kubernetes/helm/releases](https://github.com/kubernetes/helm/releases)下载您所需的平台版本。
- en: To install the client, simply unpack and copy the binary onto your path.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装客户端，只需解压并将二进制文件复制到您的路径上。
- en: 'For example, on a Linux machine you might do the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Linux机器上，您可能会执行以下操作：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Installing Tiller
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Tiller
- en: Once you have the Helm CLI tool installed on your machine, you can go about
    installing Helm's server-side component, Tiller.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在您的机器上安装了Helm CLI工具，您可以开始安装Helm的服务器端组件Tiller。
- en: 'Helm uses the same configuration as `kubectl`, so start by checking which context
    you will be installing Tiller onto:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Helm使用与 `kubectl` 相同的配置，因此首先检查您将要安装Tiller的上下文：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we will be installing Tiller into the cluster referenced by the Minikube
    context. In this case, this is exactly what we want. If your `kubectl` is not
    currently pointing to another cluster, you can quickly switch to the context you
    want to use like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将把Tiller安装到Minikube上下文引用的集群中。在这种情况下，这正是我们想要的。如果您的 `kubectl` 当前没有指向另一个集群，您可以快速切换到您想要使用的上下文，就像这样：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you are still not sure that you are using the correct context, take a quick
    look at the full config and check that the cluster server field is correct:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍然不确定是否使用了正确的上下文，请快速查看完整配置，并检查集群服务器字段是否正确：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `minify` flag removes any config not referenced by the current context.
    Once you are happy that the cluster that `kubectl` is connecting to is the correct
    one, we can set up Helm''s local environment and install Tiller on to your cluster:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`minify` 标志会删除当前上下文中未引用的任何配置。一旦您确认 `kubectl` 连接的集群是正确的，我们可以设置Helm的本地环境并将Tiller安装到您的集群上：'
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can use `kubectl` to check that Tiller is indeed running on our cluster:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `kubectl` 来检查 Tiller 是否确实在我们的集群上运行：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once we have verified that Tiller is correctly running on the cluster, let''s
    use the `version` command. This will validate that we are able to connect correctly
    to the API of the Tiller server and return the version number of both the CLI
    and the Tiller server:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们验证了 Tiller 在集群上正确运行，让我们使用 `version` 命令。这将验证我们能够正确连接到 Tiller 服务器的 API，并返回
    CLI 和 Tiller 服务器的版本号：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Installing a chart
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装图表
- en: Let's start by installing an application by using one of the charts provided
    by the community.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过使用社区提供的图表之一来安装一个应用程序。
- en: You can discover applications that the community has produced Helm charts for
    at [https://hub.kubeapps.com/](https://hub.kubeapps.com/). As well as making it
    simple to deploy a wide range of applications to your Kubernetes cluster, it's
    a great resource for learning some of the best practices the community uses when
    packaging applications for Helm.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://hub.kubeapps.com/](https://hub.kubeapps.com/)发现社区为Helm图表制作的应用程序。除了简化将各种应用程序部署到Kubernetes集群中，这也是一个学习社区在为Helm打包应用程序时使用的一些最佳实践的好资源。
- en: Helm charts can be stored in a repository, so it is simple to install them by
    name. By default, Helm is already configured to use one remote repository called
    **Stable**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表可以存储在存储库中，因此可以通过名称简单安装它们。默认情况下，Helm已配置为使用一个名为**Stable**的远程存储库。
- en: This makes it simple for us to try out some commonly used applications as soon
    as Helm is installed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以在安装Helm后立即尝试一些常用的应用程序。
- en: 'Before you install a chart, you will need to know three things:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装图表之前，您需要了解三件事：
- en: The name of the chart you want to install
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要安装的图表的名称
- en: The name you will give to this release (If you omit this, Helm will create a
    random name for this release)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要为此发布指定的名称（如果省略此项，Helm将为此发布创建一个随机名称）
- en: The namespace on the cluster you want to install the chart into (If you omit
    this, Helm will use the default namespace)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要安装图表的集群上的命名空间（如果省略此项，Helm将使用默认命名空间）
- en: 'Helm calls each distinct installation of a particular chart a release. Each
    release has a unique name that is used if you later want to update, upgrade, or
    even remove a release from your cluster. Being able to install multiple instances
    of a chart onto a single cluster makes Helm a little bit different from how we
    think about traditional package managers that are tied to a single machine, and
    typically only allow one installation of a particular package at once. But once
    you have got used to the terminology, it is very simple to understand:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Helm将特定图表的每个不同安装称为一个发布。每个发布都有一个唯一的名称，如果以后要更新、升级或删除集群中的发布，将使用该名称。能够在单个集群上安装多个图表实例使Helm与我们对传统软件包管理器的想法有些不同，传统软件包管理器通常与单台机器绑定，并且通常一次只允许安装一个特定软件包。但一旦您习惯了这些术语，就会非常容易理解：
- en: A **chart** is the package that contains all the information about *how* to
    install a particular application or tool to the cluster. You can think of it as
    a template that can be reused to create many different instances or releases of
    the packaged application or tool.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图表**是包含有关*如何*将特定应用程序或工具安装到集群的所有信息的软件包。您可以将其视为一个模板，可重复使用以创建打包的应用程序或工具的许多不同实例或发布。'
- en: A **release** is a named installation of a chart to a particular cluster. By
    referring to a release by name, Helm can make upgrades to a particular release,
    updating the version of the installed tool, or making configuration changes.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布**是将图表命名安装到特定集群的过程。通过按名称引用发布，Helm可以对特定发布进行升级，更新已安装工具的版本或进行配置更改。'
- en: A **repository** is an HTTP server storing charts along with an index file.
    When configured with the location of a repository, the Helm client can install
    a chart from that repository by downloading it and then making a new release.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储库**是存储图表以及索引文件的HTTP服务器。当配置了存储库的位置后，Helm客户端可以通过从该存储库下载图表然后创建一个新的发布来安装该图表。'
- en: 'Before you can install a chart onto your cluster, you need to make sure that
    Helm knows about the repository that you want to use. You can list the repositories
    that are currently in use by running the `helm repo list` command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在将图表安装到集群之前，您需要确保Helm知道您要使用的存储库。您可以通过运行`helm repo list`命令列出当前使用的存储库：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By default, Helm is configured with a repository named stable pointing at the
    community chart repository and local repository that points at a local address
    for testing your own local repository. (You need to be running `helm serve` for
    this.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Helm配置了一个名为stable的存储库，指向社区图表存储库，以及一个指向本地地址的本地存储库，用于测试您自己的本地存储库（您需要运行`helm
    serve`）。
- en: 'Adding a Helm repository to this list is simple with the `helm repo add` command.
    You can add my Helm repository that contains some example applications related
    to this book by running the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`helm repo add`命令将Helm存储库添加到此列表非常简单。您可以通过运行以下命令添加包含与本书相关的一些示例应用程序的Helm存储库：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In order to pull the latest chart information from the configured repositories,
    you can run the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从配置的存储库中获取最新的图表信息，您可以运行以下命令：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's start with one of the simplest applications available in my Helm repository,
    `kubeslate`. This provides some very basic information about your cluster, such
    as the version of Kubernetes you are running and the number of pods, deployments,
    and services in your cluster. We are going to start with this application, since
    it is very simple and doesn't require any special configuration to run on Minikube,
    or indeed any other cluster.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我的Helm存储库中提供的最简单的应用程序之一`kubeslate`开始。这提供了有关您的集群的一些非常基本的信息，例如您正在运行的Kubernetes版本以及您的集群中的Pod、部署和服务的数量。我们将从这个应用程序开始，因为它非常简单，不需要任何特殊的配置来在Minikube上运行，或者在任何其他集群上运行。
- en: 'Installing a chart from a repository on your cluster couldn''t be simpler:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从集群上的存储库安装图表非常简单：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You should see a lot of output from the `helm` command.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到来自`helm`命令的大量输出。
- en: 'Firstly, you will see some metadata about the release, such as its name, status,
    and namespace:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将看到有关发布的一些元数据，例如其名称、状态和命名空间：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, you should see some information about the resources that Helm has instructed
    Kubernetes to create on the cluster. As you can see, a single service and a single
    deployment have been created:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您应该会看到有关Helm已指示Kubernetes在集群上创建的资源的一些信息。正如您所看到的，已创建了一个服务和一个部署：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, there is a section with some notes that have been provided by the
    chart''s author to give us some information about how to start using the application:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个部分包含图表作者提供的一些注释，以便为我们提供有关如何开始使用应用程序的一些信息：
- en: '**Notes**:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: To access `kubeslate`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`kubeslate`。
- en: 'First start the kubectl proxy:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先启动kubectl代理：
- en: '`**kubectl proxy**`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`**kubectl proxy**`'
- en: 'Now open the following URL in your browser:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在浏览器中打开以下URL：
- en: '`**http://localhost:8001/api/v1/namespaces/default/services/my-slate-kubeslate:http/proxy**`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`**http://localhost:8001/api/v1/namespaces/default/services/my-slate-kubeslate:http/proxy**`'
- en: Please try reloading the page if you see `ServiceUnavailable / no endpoints
    available for service`, as pod creation might take a few moments.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到`ServiceUnavailable / no endpoints available for service`，请尝试重新加载页面，因为Pod的创建可能需要一些时间。
- en: 'Try following these instructions yourself and open Kubeslate in your browser:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试按照这些说明自己打开Kubeslate在浏览器中。
- en: '![](assets/1121fe40-b439-47de-9d2a-0dbd132b0d97.png)Kubeslate deployed with
    Helm'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/1121fe40-b439-47de-9d2a-0dbd132b0d97.png)使用Helm部署的Kubeslate'
- en: Configuring a chart
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置图表
- en: When you use Helm to make a release of a chart, there are certain attributes
    that you might need to change, or configuration you might need to provide. Luckily,
    Helm provides a standard way for users of a chart to override some or all of the
    configuration values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用Helm发布图表时，可能需要更改某些属性或提供配置。幸运的是，Helm为图表的用户提供了一种标准的方式来覆盖一些或所有的配置值。
- en: In this section, we are going to look at how, as the user of a chart, you might
    go about supplying configuration to Helm. Later in the chapter, we are going to
    look at how you can create your own charts and use the configuration passed in
    to allow your chart to be customized.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看作为图表用户，您可能如何向Helm提供配置。在本章的后面，我们将看看如何创建自己的图表，并使用传递的配置来允许您的图表进行自定义。
- en: 'When we invoke `helm install`, there are two ways we can provide configuration
    values: passing them as command-line arguments, or by providing a configuration
    file.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`helm install`时，有两种方式可以提供配置值：将它们作为命令行参数传递，或者提供一个配置文件。
- en: These configuration values are merged with the default values provided by a
    chart. This allows a chart author to provide a default configuration to allow
    users to get up and running quickly, but still allow users to tweak important
    settings, or enable advanced features.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置值与图表提供的默认值合并。这使得图表作者可以提供默认配置，让用户快速上手，但仍然允许用户调整重要设置或启用高级功能。
- en: 'Providing a single value to Helm on the command line is achieved by using the
    set flag. The `kubeslate` chart allows us to specify additional labels for the
    pod(s) that it launches using the `podLabels` variable. Let''s make a new release
    of the kubeslate chart, and then use the `podLabels` variable to add an additional
    `hello` label with the value `world`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用set标志在命令行上向Helm提供单个值。 `kubeslate`图表允许我们使用`podLabels`变量为其启动的pod(s)指定附加标签。让我们发布kubeslate图表的新版本，然后使用`podLabels`变量添加一个额外的`hello`标签，其值为`world`：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once you have run this command, you should be able to prove that the extra
    variable you passed to Helm did indeed result in the pods launched by Helm having
    the correct label. Using the `kubectl get pods` command with a label selector
    for the label we applied using Helm should return the pods that have just been
    launched with Helm:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您应该能够证明您传递给Helm的额外变量确实导致Helm启动的pod具有正确的标签。使用带有我们使用Helm应用的标签的标签选择器的`kubectl
    get pods`命令应返回刚刚使用Helm启动的pod：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As well as being able to pass a configuration to Helm when we create a new release,
    it is also possible to update the configuration in a pre-existing release using
    the upgrade command. When we use Helm to update a configuration, the process is
    much the same as when we updated deployment resources in the last chapter, and
    a lot of those considerations still apply if we want to avoid downtime in our
    services. For example, by launching multiple replicas of a service, we can avoid
    downtime, as a new version of a deployment configuration is rolled out.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在创建新版本时能够向Helm传递配置外，还可以使用升级命令更新预先存在的版本的配置。当我们使用Helm更新配置时，这个过程与上一章中更新部署资源时的过程大致相同，如果我们想要避免服务中断，许多考虑因素仍然适用。例如，通过启动服务的多个副本，我们可以避免停机时间，因为部署配置的新版本会被推出。
- en: 'Let''s also upgrade our original kubeslate release to include the same `hello:
    world pod` label that we applied to the second release. As you can see, the structure
    of the `upgrade` command is quite similar to the `install` command. But rather
    than specifying the name of the release with the `--name` flag, we pass it as
    the first argument. This is because when we install a chart to the cluster, the
    name of the release is optional. If we omit it, Helm will create a random name
    for the release. However, when performing an upgrade, we need to target a pre-existing
    release to upgrade, and thus this argument is mandatory:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们还将我们原始的kubeslate发布升级，以包括我们应用于第二个发布的相同的`hello: world pod`标签。正如您所看到的，`upgrade`命令的结构与`install`命令非常相似。但是，我们不是使用`--name`标志指定发布的名称，而是将其作为第一个参数传递。这是因为当我们将图表安装到集群时，发布的名称是可选的。如果我们省略它，Helm将为发布创建一个随机名称。但是，当执行升级时，我们需要针对要升级的现有发布，因此此参数是必需的：'
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you now run `helm ls`, you should see that the release named `my-slate`
    has been upgraded to Revision 2\. You can test that the deployment managed by
    this release has been upgraded to include this pod label by repeating our `kubectl
    get` command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行`helm ls`，您应该会看到名为`my-slate`的发布已经升级到Revision 2。您可以通过重复我们的`kubectl get`命令来测试由此发布管理的部署是否已升级以包括此pod标签：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can now see that four pods, two from each of our releases, now match the
    label selector we passed to `kubectl get`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到，我们的四个发布中的每个都有两个pod，现在都与我们传递给`kubectl get`的标签选择器匹配。
- en: 'Passing variables on the command line with the `set` flag is convenient when
    we just want to provide values for a few variables. But when we want to pass more
    complex configurations, it can be simpler to provide the values as a file. Let''s
    prepare a configuration file to apply several labels to our kubeslate pods:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`set`标志在命令行上传递变量在我们只想为一些变量提供值时很方便。但是，当我们想要传递更复杂的配置时，将值提供为文件可能更简单。让我们准备一个配置文件，将几个标签应用到我们的kubeslate
    pod上：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can then use the `helm` command to apply this configuration file to our
    release:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`helm`命令将此配置文件应用到我们的发布上：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Creating your own charts
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您自己的图表
- en: Now you have a little experience with Helm and can use the command-line tool
    to install a chart from a community repository, we are going to take a look at
    how you can leverage Helm to build charts for your own applications.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了一点Helm的经验，并且可以使用命令行工具从社区存储库安装图表，我们将看看如何利用Helm为自己的应用程序构建图表。
- en: We will walk through using Helm to deploy the versions application that we manually
    deployed in [Chapter 4](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml), *Managing
    Change in Your Applications*. The aim here is for us to replicate the deployments
    we made in [Chapter 4](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml), *Managing
    Change in Your Applications*, but this time to encapsulate the configuration in
    a Helm chart so it is simple to make configuration changes, deploy new versions
    of our code, and even deploy the same configuration multiple times.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Helm来部署我们在[第4章](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml)中手动部署的versions应用程序。这里的目标是复制我们在[第4章](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml)中进行的部署，但这次将配置封装在Helm图表中，以便简单地进行配置更改，部署我们代码的新版本，甚至多次部署相同的配置。
- en: 'Helm makes it very easy to build a chart and deploy it to your cluster. The
    Helm command-line tool has some commands that will get us started very quickly.
    The `helm create` command will create a skeleton for our new chart that we can
    quickly fill in with the configuration for our application:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Helm使构建图表并将其部署到集群变得非常容易。Helm命令行工具有一些命令，可以让我们非常快速地开始。`helm create`命令将为我们的新图表创建一个骨架，我们可以快速填写应用程序的配置。
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's look at each of the files created by Helm, and then look at the configuration
    we will need to add to deploy our versioned web service from [Chapter 4](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml),
    *Managing Change in Your Applications*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Helm创建的每个文件，然后看看我们需要添加的配置，以部署我们的版本化Web服务来自[第4章](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml)，*管理应用程序中的变更*。
- en: Chart.yaml
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chart.yaml
- en: This file contains some basic metadata about this chart, such as its name, a
    description, and a version number. This file is required.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含有关此图表的一些基本元数据，例如名称、描述和版本号。此文件是必需的。
- en: values.yaml
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: values.yaml
- en: This file contains the default configuration values for this chart. These are
    the values that will be used when rendering the templated resources when installing
    the chart, unless overrides are provided.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含此图表的默认配置值。这些值将在安装图表时用于渲染模板资源，除非提供了覆盖值。
- en: templates
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: This directory contains the templates that will be rendered to produce the definitions
    of the resources that this chart provides. When we run the `helm new` command,
    several skeleton template files are created for us.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该目录包含将被渲染以生成此图表提供的资源定义的模板。当我们运行`helm new`命令时，会为我们创建一些骨架模板文件。
- en: '`NOTES.txt` is a special file that is used to provide a post-install message
    to users of your chart. You saw an example of this earlier in the chapter when
    we installed the kube-ops-dashboard.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOTES.txt`是一个特殊文件，用于向您的图表用户提供安装后的消息。在本章早些时候，当我们安装kube-ops-dashboard时，您看到了一个示例。'
- en: As with the YAML resources we created by hand in earlier chapters, Helm doesn't
    attach any significance to the filenames we give to our resources. It is up to
    you to decide how to organize resources within the templates directory. The skeleton
    chart we created just now comes with a few files to get us started, but if you
    need to create more resources, you may just add additional files to the templates
    directory.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在之前章节手工创建的YAML资源一样，Helm不会对我们为资源指定的文件名附加任何重要性。如何组织模板目录中的资源取决于您。我们刚刚创建的骨架图表带有一些文件，但如果您需要创建更多资源，可以向模板目录添加其他文件。
- en: '`deployment.yaml` contains a simple manifest for a deployment, `service.yaml`
    contains a simple service manifest for this deployment, and `_helpers.tpl` contains
    some predefined helper functions that you can reuse throughout your chart.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`deployment.yaml`包含一个部署的简单清单，`service.yaml`包含此部署的简单服务清单，`_helpers.tpl`包含一些预定义的辅助函数，您可以在整个图表中重复使用。'
- en: When you ran `helm new`, some other files may have been created. These are optional
    files used for some more advanced functionality, and we can ignore them for now,
    but if you wish, you can safely remove them altogether from your chart.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行`helm new`时，可能会创建一些其他文件。这些是用于一些更高级功能的可选文件，我们现在可以忽略它们，但如果您愿意，可以从图表中完全删除它们。
- en: There are some standard ways of working with the templates directory that are
    followed in the community charts repository. You might like to review these, as
    they do help to keep your work organized. But unless you are planning to try getting
    your chart published to the community repository, there is no need to stick rigidly
    to these guidelines: [https://docs.helm.sh/chart_best_practices](https://docs.helm.sh/chart_best_practices).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些标准的模板目录工作方式，遵循社区图表存储库中的规则。您可能希望查看这些规则，因为它们有助于保持您的工作有条不紊。但除非您计划尝试将您的图表发布到社区存储库，否则没有必要严格遵循这些准则：[https://docs.helm.sh/chart_best_practices](https://docs.helm.sh/chart_best_practices)。
- en: Making it your own
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使其成为您自己的
- en: 'Let''s go through the steps that we will take to edit this chart in order to
    deploy our own application. Start by taking a look at the generated `deployment.yaml`
    file. You will notice that it looks very similar to the manifest that we produced
    in [Chapter 4](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml), *Managing Change in
    Your Applications*, but with one important difference: all of the specific configuration
    values have replaced will calls to variables. Look, for example, at the line where
    the image for the container is specified:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤来编辑这个图表，以便部署我们自己的应用程序。首先看一下生成的 `deployment.yaml` 文件。您会注意到它看起来非常类似于我们在[第4章](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml)中生成的清单，*管理应用程序中的变更*，但有一个重要的区别：所有特定的配置值都已经替换为变量调用。例如，看一下指定容器镜像的那一行：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will notice that when a reference to a variable is inserted into the template,
    it is surrounded by two curly braces, like this: `{{ variable }}`. Secondly, you
    will also notice the dot notation used to access nested attributes on objects.
    The `.Values` object refers to all of the values, either supplied (by default)
    from the `values.yaml` file within the chart, or overridden from the command line
    when the chart is deployed.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，当将变量的引用插入模板时，它被两个花括号括起来，就像这样：`{{ variable }}`。其次，您还会注意到用于访问对象的嵌套属性的点表示法。`.Values`
    对象指的是所有的值，可以是从图表中的 `values.yaml` 文件（默认）提供的，也可以是在部署图表时从命令行覆盖的。
- en: 'So, in order to configure the source for the image we want to use in our deployment,
    let''s start by editing the `values.yaml` file. Find the section where the image
    is configured and edit to pull the versions application we deployed in [Chapter
    4](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml), *Managing Change in Your Applications*:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了配置我们部署中要使用的图像的源，让我们从编辑 `values.yaml` 文件开始。找到配置图像的部分，并编辑以拉取我们在[第4章](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml)中部署的应用程序的版本：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'While we are editing the `values.yaml` file, let''s also edit the values used
    to configure the service that Helm created for our deployment. We need to change
    the port that our container exposes from `80` to `3000`, and we should change
    the name of our service from `nginx` to something more descriptive:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑 `values.yaml` 文件的同时，让我们也编辑用于配置Helm为我们的部署创建的服务的值。我们需要将容器暴露的端口从 `80` 更改为 `3000`，并且我们应该将服务的名称从
    `nginx` 更改为更具描述性的名称：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we go back and look at `deployment.yaml` and `service.yaml`, we can see one
    of the advantages of being able to inject variables into our Kubernetes resources
    with templates.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回过头来看 `deployment.yaml` 和 `service.yaml`，我们可以看到能够在我们的Kubernetes资源中使用模板注入变量的一个优势。
- en: By changing the value of `service.internalPort` in the `values.yaml` file, we
    have a single source of truth; in this case, the port that our container exposes.
    This single source of truth then gets used three times within `deployment.yaml`
    and then again in `service.yaml`. Of course, with a simple example like this,
    we could have edited these files manually, but it makes the cost of maintaining
    the configuration that little bit higher, having to search through several resources,
    and understanding how different configuration values interact.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `values.yaml` 文件中更改 `service.internalPort` 的值，我们有了一个单一的真相来源；在这种情况下，就是我们的容器暴露的端口。这个单一的真相来源在
    `deployment.yaml` 中被使用了三次，然后又在 `service.yaml` 中被使用了一次。当然，对于这样一个简单的例子，我们可以手动编辑这些文件，但这会增加维护配置的成本，需要搜索多个资源，并理解不同配置值之间的交互方式。
- en: When I am building a Helm chart, I try to imagine my future self using the chart.
    My aim is to expose enough variables to make the chart flexible enough to reuse
    and redeploy in several environments without having to change or even look at
    the templates. To achieve this, it is important to choose descriptive variable
    names, and provide clear documentation for the use of those variables in the
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我构建Helm图表时，我试图想象我的未来自己使用该图表。我的目标是暴露足够的变量，使图表足够灵活，可以在多个环境中重复使用和重新部署，而无需更改或甚至查看模板。为了实现这一点，选择描述性变量名称并为这些变量的使用提供清晰的文档非常重要
- en: '`README.md` file.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`README.md`文件。'
- en: 'It is simple to deploy our chart using the Helm command-line client, rather
    than referring to the name of a chart within a remote repository (for example,
    `stable/kube-ops-view`). We can run our Helm commands by pointing to the chart
    directory on disk:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Helm命令行客户端部署我们的图表非常简单，而不是引用远程存储库中图表的名称（例如，`stable/kube-ops-view`）。我们可以通过指向磁盘上的图表目录来运行我们的Helm命令：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now the chart has been installed on to our cluster, let''s test that it''s
    working correctly. The simplest way to do this is to run `kubectl proxy` to set
    up a local proxy to the kubernetes API, and use the service endpoint to view our
    service. The chart that Helm created for us creates a service with a name formed
    by combining the name of the release with the name of the chart. So, assuming
    that the `kubectl proxy` started on port `8001`, we should be able to view our
    service at the following URL: `http://localhost:8001/api/v1/namespaces/default/services/happy-bear-version-app:80/`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在图表已安装到我们的集群上，让我们测试它是否正常工作。最简单的方法是运行`kubectl proxy`来设置到kubernetes API的本地代理，并使用服务端点来查看我们的服务。Helm为我们创建的图表创建了一个服务，其名称由发布的名称和图表的名称组合而成。因此，假设`kubectl
    proxy`在端口`8001`上启动，我们应该能够在以下URL查看我们的服务：`http://localhost:8001/api/v1/namespaces/default/services/happy-bear-version-app:80/`。
- en: '![](assets/0a901776-31e6-4663-b202-ffb5ef66f25a.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0a901776-31e6-4663-b202-ffb5ef66f25a.png)'
- en: Developing and debugging
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发和调试
- en: As our charts become more complex and we leverage more of the power of the templating
    language that Helm provides to build our own abstractions on top of the Kubernetes
    resources, you might notice that it becomes harder to reason about errors returned
    by Kubernetes. Because we can no longer see the resources directly that we are
    submitting to Kubernetes, it can become harder to work out the source of a bug
    or misconfiguration.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的图表变得更加复杂，并且利用Helm提供的模板语言的更多功能来构建我们自己的抽象层，您可能会注意到，要推理Kubernetes返回的错误变得更加困难。因为我们无法直接看到我们提交给Kubernetes的资源，因此很难找出错误或错误配置的来源。
- en: 'Luckily, Helm has some options that will help us debug our charts as we develop
    them:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Helm有一些选项可以帮助我们在开发图表时调试它们：
- en: '**`--dry-run`**: This option allows us to submit our chart to the Tiller server,
    where it will be validated in exactly the same way as when we deploy our chart
    without actually submitting the resources to Kubernetes. This lets us see and
    understand any errors with our chart quickly without having to use resources on
    our cluster.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`--dry-run`**：此选项允许我们将图表提交到Tiller服务器，在那里它将以与我们部署图表时完全相同的方式进行验证，而无需实际提交资源到Kubernetes。这样我们可以快速查看和理解图表中的任何错误，而无需在我们的集群上使用资源。'
- en: '`--debug`: This option allows us to see a lot of useful debugging information;
    in fact, so much that it can be a little overwhelming at first. Firstly, we see
    some logging information marked `[debug]`. This includes some details about how
    the Helm client is connecting to Tiller and the chart that is being deployed.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--debug`：此选项允许我们查看大量有用的调试信息；实际上，有时可能会有点压倒性。首先，我们看到一些标记为`[debug]`的日志信息。这包括有关Helm客户端如何连接到Tiller以及正在部署的图表的一些详细信息。'
- en: This is followed by the release metadata. This is made up from the chart metadata
    from `Chart.yaml` and computed information about the release, such as its number
    and the date and time that it was made.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是发布元数据。这由`Chart.yaml`中的图表元数据和有关发布的计算信息组成，例如其编号以及制作日期和时间。
- en: The next section, `COMPUTED VALUES`, shows the exact values that Helm will be
    using as it renders the templates to produce the resources for this release. If
    you are not passing any extra variables when you make your release, this should
    be identical to the contents of `values.yaml`, but is very useful if you are trying
    to understand exactly what variables are being used by the templates if you are
    providing overrides when you invoke Helm. The `HOOKS` section shows the resources
    that will be created by the Helm hooks mechanism. You will learn a little about
    hooks later in this chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节，“计算值”，显示了Helm在渲染模板以生成此版本的资源时将使用的确切值。如果在发布时没有传递任何额外的变量，这应该与`values.yaml`的内容相同，但如果您在调用Helm时提供了覆盖，这将非常有用，以便了解模板使用的确切变量。
    “HOOKS”部分显示了将由Helm钩子机制创建的资源。您将在本章后面了解有关钩子的一些信息。
- en: Finally, the `MANIFEST` section lists out the computed resources, as they will
    be submitted to Kubernetes. When you are developing chart templates, this is invaluable,
    for quickly seeing how your chart behaves given different values. You will find
    that using both these options together with a call to `helm install` or `helm
    upgrade` is very useful in debugging your charts, as well as for validating your
    work and building confidence that changes to your chart or values have the desired
    effect.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，“MANIFEST”部分列出了计算资源，因为它们将被提交到Kubernetes。当您开发图表模板时，这是非常宝贵的，可以快速查看您的图表在不同值下的行为。您会发现，将这两个选项与`helm
    install`或`helm upgrade`一起使用非常有用，用于调试您的图表，以及验证您的工作并建立对图表或值的更改是否产生预期效果的信心。
- en: Templating language
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板语言
- en: Helm's templating language is based on the Go templating language. Essentially,
    Helm provides the standard templating language from the Go programming language,
    plus some additional functions and the mechanism for making variables available
    inside of your templates.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Helm的模板语言基于Go模板语言。基本上，Helm提供了来自Go编程语言的标准模板语言，以及一些额外的函数和使变量在模板内可用的机制。
- en: You have already seen how to use the templating language to place information
    into YAML formatted Kubernetes resources. Calls to functions provided by Helm
    are surrounded by double curly braces, like `{{ this }}`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到如何使用模板语言将信息放入YAML格式的Kubernetes资源中。Helm提供的函数调用用双花括号括起来，如`{{ this }}`。
- en: 'If we simply want to include a variable into our template, we can just refer
    to it by name. Helm namespaces its variables inside of a number of objects that
    are exposed to the template. You will have already noticed that the values from
    our `values.yaml` file (as amended by any overwritten variables passed in on the
    command line) are available in the `.Values` object. In addition to this object,
    Helm makes further objects available within the template:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是想将变量包含到我们的模板中，我们可以直接按名称引用它。Helm将其变量命名空间化在一些对象内，这些对象暴露给模板。您可能已经注意到，我们的`values.yaml`文件中的值（由命令行传入的任何覆盖变量修改）在`.Values`对象中可用。除了这个对象，Helm还在模板内提供了其他对象：
- en: '`.Release`: This object describes the release itself, and includes a number
    of attributes that can be used to customize your resources to their parent release.
    Commonly, you will use these values to ensure that the resources from this release
    do not conflict with the resources from another release of the same chart.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Release`: 此对象描述了发布本身，并包括许多属性，可用于自定义资源以适应其父发布。通常，您将使用这些值来确保此发布的资源不会与同一图表的另一个发布的资源发生冲突。'
- en: '`.Release.Name`: This is the name of the release. It can be passed to `helm
    install` with the `--name` flag, or it might be automatically generated.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Release.Name`: 这是发布的名称。它可以通过`helm install`传递给`--name`标志，或者可能会自动生成。'
- en: '`.Release.Time.Seconds`: This is the time when the release was created as a
    UNIX-style timestamp. It can be useful if you need to add a unique value to a
    resource name.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Release.Time.Seconds`: 这是发布创建时的时间，作为UNIX风格的时间戳。如果您需要向资源名称添加唯一值，这可能很有用。'
- en: '`.Release.Namespace`: This indicates the Kubernetes namespace of this release.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Release.Namespace`: 这表示此发布的Kubernetes命名空间。'
- en: '`.Release.Service`: This indicates the service that made the release. Currently,
    this is always Tiller, but if there was an alternative implementation of Helm,
    perhaps it would populate this attribute differently.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Release.Service`: 这表示进行发布的服务。目前，这始终是Tiller，但如果Helm有另一种实现，可能会以不同的方式填充此属性。'
- en: '`.Release.Revision`: This is a number used to track updates to the release.
    It begins with 1 and increases each time the release is upgraded via `helm upgrade`.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Release.Revision`: 这是一个用于跟踪发布更新的数字。它从1开始，每次通过`helm upgrade`升级发布时都会增加。'
- en: '`.Release.IsUpgrade` and `.Release.IsInstall`: These are Boolean values that
    indicate if the operation producing this release is a new install of the chart,
    or an upgrade of an existing release. These might be utilized to only carry out
    actions at a particular point in the chart''s life cycle.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Release.IsUpgrade`和`.Release.IsInstall`: 这些是布尔值，指示生成此发布的操作是图表的新安装，还是对现有发布的升级。这些可能被用于仅在图表生命周期的特定阶段执行操作。'
- en: '`.Chart`: The chart object contains the fields from `Chart.yaml`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Chart`: 图表对象包含来自`Chart.yaml`的字段。'
- en: '`.Files`: This object allows you to access the contents of non-template files
    included in the chart. It exposes two functions, `.Get` and `.GetBytes`, that
    allow you to read contents of files as text or indeed as bytes. This can be useful
    for providing static config files or other data that is not included in your container
    images as part of your chart.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Files`: 此对象允许您访问图表中包含的非模板文件的内容。它公开了两个函数，`.Get`和`.GetBytes`，允许您以文本或字节的形式读取文件的内容。这对于提供静态配置文件或其他未包含在容器映像中的数据作为图表的一部分可能很有用。'
- en: '`.Capabilities`: This object provides information about the cluster that Tiller
    is running on. It can be useful to query this information if you want to produce
    a chart that will work with more than one version of Kubernetes. You will see
    an example of this later in the chapter.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Capabilities`: 此对象提供有关Tiller正在运行的集群的信息。如果要创建一个可以与多个版本的Kubernetes一起使用的图表，查询此信息可能很有用。您将在本章后面看到一个示例。'
- en: '`.Template`: This object provides a `.Name` and a `.BasePath` attribute that
    includes the filename and directory of the template currently being rendered by
    Helm.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Template`: 此对象提供了一个`.Name`和一个`.BasePath`属性，其中包括Helm当前正在呈现的模板的文件名和目录。'
- en: Functions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Helm's templating language provides over 60 functions that can manipulate and
    format the data we pass to our templates.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Helm的模板语言提供了超过60个函数，可以操作和格式化我们传递给模板的数据。
- en: Some of these functions are part of the Go templating language, but most are
    part of the Sprig templating language.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些函数是Go模板语言的一部分，但大多数是Sprig模板语言的一部分。
- en: When you begin using Helm, it can be useful to have the documentation to hand
    so you can find the function that you need.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始使用Helm时，随手准备文档可能会很有用，这样您就可以找到所需的函数。
- en: '[https://godoc.org/text/template](https://godoc.org/text/template)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://godoc.org/text/template](https://godoc.org/text/template)'
- en: '[https://godoc.org/github.com/Masterminds/sprig](https://godoc.org/github.com/Masterminds/sprig)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://godoc.org/github.com/Masterminds/sprig](https://godoc.org/github.com/Masterminds/sprig)'
- en: There are two ways to invoke a template function in the Helm templating language.
    The first of these involves calling a function, and passing a value as an argument.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在Helm模板语言中调用模板函数有两种方式。其中之一涉及调用一个函数，并将一个值作为参数传递。
- en: For example, `{{ upper "hello" }}` will produce the output `HELLO`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`{{ upper "hello" }}`将产生输出`HELLO`。
- en: The second way to invoke a function is as a pipeline. You can think of a pipeline
    a little like a UNIX pipe; it provides a concise way to pass the result of one
    function to another. This lets us compose together several functions to get at
    the result we want.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数的第二种方式是作为管道。您可以将管道想象成类似于UNIX管道；它提供了一种简洁的方式将一个函数的结果传递给另一个函数。这使我们能够组合多个函数以获得我们想要的结果。
- en: We could rewrite our first example as `{{ "hello" | upper }}` and the result
    would be exactly the same. The advantage of this form comes when we want to apply
    several functions to a value. When we use the pipeline operator, the result of
    the previous function is passed into the next as the last argument. This allows
    us to also call functions that take more than one argument, and is the reason
    that most of the functions in Helm are optimized to take the value to be operated
    on as the last argument.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的第一个示例重写为`{{ "hello" | upper }}`，结果将完全相同。这种形式的优势在于当我们想要对一个值应用多个函数时。当我们使用管道运算符时，上一个函数的结果被传递到下一个函数作为最后一个参数。这使我们还可以调用需要多个参数的函数，并且这也是Helm中大多数函数被优化为将要操作的值作为最后一个参数的原因。
- en: 'We could, for example, form a pipeline with the `trunc` function to truncate
    our string to a certain number of characters and then use the `upper` function
    to uppercase the result, like this: `{{ "hello" | trunc 4 | upper }}`. The result,
    of course, would be `HELL.`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用`trunc`函数形成一个流水线，将我们的字符串截断为一定数量的字符，然后使用`upper`函数将结果转换为大写，就像这样：`{{ "hello"
    | trunc 4 | upper }}`。当然，结果将是`HELL`。
- en: Flow control
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程控制
- en: We already get a lot of value from Helm by being able to take a single value
    from a chart and include it in a number of places throughout a chart, like the
    example earlier in the chapter, where we referred to the same port number in several
    related places. You might also use this technique, for example, to ensure a system
    with a number of different components provided by different containers are always
    deployed to the same version number.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过能够从图表中获取单个值并将其包含在图表的许多地方，我们已经从Helm中获得了很多价值，就像本章前面的示例中，我们在几个相关的地方引用了相同的端口号。例如，您还可以使用此技术来确保由不同容器提供的多个不同组件的系统始终部署到相同的版本号。
- en: Another important way that we can use variables in our Helm charts is to provide
    a signal to our template to change our configuration or even turn whole features
    into optional extras that might not always be enabled.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Helm图表中使用变量的另一个重要方式是为我们的模板提供信号，以更改我们的配置，甚至将整个功能转换为可选的附加功能，可能并非始终启用。
- en: 'There are three constructs that allow us to construct really powerful abstractions
    using Helm templates: `if...else`, `range`, and `with`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种结构允许我们使用Helm模板构建非常强大的抽象：`if...else`，`range`和`with`。
- en: The structure of the `if...else` construct in Helm should be very familiar to
    anyone who has used a programming language. We use the `if` keyword to test a
    variable or expression. If the test passes, we do the action in the first branch;
    if not, we fall back to the action indicated by the `else` branch.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Helm中`if...else`结构的结构对于使用过编程语言的人来说应该非常熟悉。我们使用`if`关键字来测试变量或表达式。如果测试通过，我们执行第一个分支中的操作；如果不通过，则退回到`else`分支指示的操作。
- en: 'Here is an example you might use to provide a custom message in the `NOTES.txt`
    template, depending on the value of a variable:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，您可以根据变量的值在`NOTES.txt`模板中提供自定义消息：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`if` functions can be nested within the `else` branch to provide more complex
    behavior. In this example, the `Capabilities` object is queried so the templated
    resource can use a correct API version for a `CronJob` resource. This kind of
    capability is useful since it lets you make changes to your configuration to support
    a newer version of Kubernetes, but maintain backwards compatibility. If both of
    our tests for a supported version fail, then we explicitly throw an error that
    will halt the installation of the chart:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`函数可以嵌套在`else`分支中，以提供更复杂的行为。在这个例子中，查询`Capabilities`对象，以便模板化资源可以为`CronJob`资源使用正确的API版本。这种能力很有用，因为它允许您更改配置以支持Kubernetes的更新版本，但保持向后兼容性。如果我们对支持的版本进行的两个测试都失败了，那么我们明确地抛出一个错误，这将停止图表的安装：'
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Providing toggles like this around configuration based on feature flags or even
    version numbers is a very useful tool to manage change in your configuration.
    It allows you to add an option to your chart, test it out in safety, and then
    only enable it when you are happy to do so.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样围绕基于特性标志或甚至版本号的配置提供切换是管理配置中变化的非常有用的工具。它允许您向图表添加一个选项，在安全性中测试它，然后只有在您满意时才启用它。
- en: The `range` keyword is used to loop over a collection. It can loop over simple
    lists or collections with a key value structure.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`关键字用于循环遍历集合。它可以循环遍历简单列表或具有键值结构的集合。'
- en: 'Let''s start by adding a list of values to our `values.yaml` file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在我们的`values.yaml`文件中添加一个值列表：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we can use the `range` keyword to loop over the data in our list, and
    use values in our template:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用`range`关键字来循环遍历我们列表中的数据，并在我们的模板中使用值：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, we are using the `|-` marker, which is part of YAML. It indicates
    that the usernames string is multi-line. This will result in each username being
    available in the `ConfigMap` separated by new lines.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`|-`标记，这是YAML的一部分。它表示用户名字符串是多行的。这将导致每个用户名在`ConfigMap`中以新行分隔。
- en: As you can see here, when we use the range function on a list, on each iteration,
    the special `.` variable is replaced by the value from the list.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这里看到的，当我们在列表上使用range函数时，在每次迭代中，特殊的`.`变量都会被列表中的值替换。
- en: 'When rendered, this template produces the following result:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染时，此模板产生以下结果：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this next example, we are going to assign the result of the range function
    to two variables. When we do this with a list, the first variable includes an
    index, and you will notice that when we assign a variable, we prefix its name
    with a `$`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将把range函数的结果分配给两个变量。当我们对列表这样做时，第一个变量包括一个索引，您会注意到当我们分配一个变量时，我们会用`$`作为前缀：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of this template when rendered looks like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染此模板时，输出如下：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When using the range function to loop over a key value structure, we can also
    use variables to capture the key and the value.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用range函数循环遍历键值结构时，我们还可以使用变量来捕获键和值。
- en: 'Let''s consider the following data in our `values.yaml` file:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`values.yaml`文件中考虑以下数据：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we have some key value data in the users variable, let''s use it to configure
    some environment variables for a pod:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在用户变量中有一些键值数据，让我们用它来配置一些pod的环境变量：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When we use the range keyword to loop over a key value structure, the key becomes
    the first variable returned and the value becomes the second. By nesting loops,
    as in this case, it becomes possible to use quite complex data structures in the
    values file.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用range关键字循环遍历键值结构时，键成为第一个返回的变量，值成为第二个。通过嵌套循环，就像在这种情况下一样，可以在值文件中使用相当复杂的数据结构。
- en: The type of some variables in Kubernetes resources is important. In the preceding
    example, the value in an environment variable must always be a string, so we have
    used the `quote` pipeline function to ensure that values of other types (like
    numbers) are of the correct string type.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes资源中某些变量的类型很重要。在前面的例子中，环境变量中的值必须始终是一个字符串，因此我们使用了`quote`管道函数来确保其他类型的值（如数字）是正确的字符串类型。
- en: 'When rendered, this template produces a pod manifest, like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染时，此模板将生成一个pod清单，如下所示：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Hooks
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钩子
- en: So far, we have been using Helm to help us generate the resources our applications
    need to be submitted to Kubernetes. In the ideal world, this would be all that
    we would need a tool like Helm to do. Kubernetes aims to be declarative; in other
    words, we submit resources describing what we want the state of the cluster to
    look like, and Kubernetes handles the rest.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用Helm来帮助我们生成我们的应用程序需要提交到Kubernetes的资源。在理想的世界中，这将是Helm这样的工具所需要做的一切。Kubernetes旨在是声明性的；换句话说，我们提交描述集群状态的资源，Kubernetes会处理其余的工作。
- en: Unfortunately, in the real world, sometimes we still need to explicitly take
    some actions to get our applications running correctly. Perhaps when you install
    your application, you need to run a script to initialize a database schema or
    set up some default users. Perhaps when you install a new version of an application,
    you need to run a script to migrate the schema of your database to be compatible
    with the new version of the application.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在现实世界中，有时我们仍然需要明确地采取一些行动来使我们的应用程序正确运行。也许当您安装应用程序时，您需要运行脚本来初始化数据库架构或设置一些默认用户。也许当您安装应用程序的新版本时，您需要运行脚本来迁移数据库架构，以使其与应用程序的新版本兼容。
- en: Helm provides a hook mechanism that allows us to take actions at eight specific
    points in the life cycle of a release. In order to define a hook in your Helm
    chart, you add the `helm.sh/hook` annotation to a resource. You can use the hook
    annotation on any resource to ensure that it is created at the appropriate time.
    But typically, it is very useful to create resources of the job type. If your
    resource is of the job type, Tiller will block until the job has successfully
    run to completion. This means that if you are using one of the `pre-` hooks then
    your application can depend on that job having run.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Helm提供了一个钩子机制，允许我们在发布的生命周期的八个特定点上采取行动。为了在Helm图表中定义一个钩子，您需要向资源添加`helm.sh/hook`注释。您可以在任何资源上使用钩子注释，以确保它在适当的时间创建。但通常，创建作业类型的资源非常有用。如果您的资源是作业类型，Tiller将阻塞，直到作业成功运行完成。这意味着如果您使用`pre-`钩子之一，那么您的应用程序可以依赖于该作业已经运行。
- en: '`pre-install`: This action runs after Tiller has rendered the templates in
    a chart, but before any resources have been submitted to the Kubernetes API. This
    action runs when a new release is created by installing a chart. If you also need
    a hook to run when a release is upgraded, you should combine this hook with the
    `pre-upgrade` hook. You might make use of this hook to initialize resources that
    will be used by your application.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pre-install`：此操作在Tiller渲染图表模板后但在任何资源提交到Kubernetes API之前运行。此操作在通过安装图表创建新发布时运行。如果您还需要在发布升级时运行钩子，您应该将此钩子与`pre-upgrade`钩子结合使用。您可以利用此钩子来初始化将被应用程序使用的资源。'
- en: '`post-install`: This action runs after all the resources have been submitted
    to the Kubernetes API. You might, for example, use this to run a script that provides
    notifications to a chatroom or to register the new instance of the chart with
    a monitoring tool.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post-install`：此操作在所有资源已提交到Kubernetes API后运行。例如，您可以使用此操作运行一个脚本，向聊天室发送通知，或者向监控工具注册图表的新实例。'
- en: '`pre-delete`: This hook runs before any resources are deleted from Kubernetes
    when a deletion request is made. This could be useful, for example, if you needed
    to make a backup of data stored by your application.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pre-delete`：此钩子在删除请求发出时，在从Kubernetes删除任何资源之前运行。例如，如果您需要备份应用程序存储的数据，这可能会很有用。'
- en: '`post-delete`: This hook runs after Helm has deleted the resources created
    as part of a release. You might utilize this hook to clean up any external resources
    that your application uses that are not managed by Helm or Kubernetes.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post-delete`：此钩子在Helm删除作为发布的一部分创建的资源后运行。您可以利用此钩子清理应用程序使用的任何未由Helm或Kubernetes管理的外部资源。'
- en: '`pre-upgrade`: This hook provides the same functionality as the `pre-install`
    hook, but runs each time a release is upgraded. You might use this hook to run
    a database migration script.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pre-upgrade`：此钩子提供与`pre-install`钩子相同的功能，但每次升级发布时运行。您可以使用此钩子运行数据库迁移脚本。'
- en: '`post-upgrade`: This hook provides the same functionality as the `post-install`
    hook, but runs each time a release is upgraded. Again, this might be used for
    notification purposes.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post-upgrade`：此钩子提供与`post-install`钩子相同的功能，但每次升级发布时运行。同样，这可能用于通知目的。'
- en: '`pre-rollback`: This hook runs before changes to rollback an upgrade of a release
    is submitted to the Kubernetes API.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pre-rollback`：此钩子在提交回滚发布升级的更改到Kubernetes API之前运行。'
- en: '`post-rollback`: This hook runs after a request to rollback an upgrade of the
    release has been submitted to Kubernetes. Depending on the expectations of your
    application, you might run scripts to roll back database changes here or in the
    `pre-rollback` hook.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post-rollback`：此钩子在提交回滚发布升级的请求到Kubernetes后运行。根据您的应用程序的期望，您可能在此处或在`pre-rollback`钩子中运行脚本来回滚数据库更改。'
- en: 'Let''s look at an example, where we will be using a hook to run a setup script:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们看一个例子，我们将使用一个钩子来运行设置脚本：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Everything about the definition of this job is the same as the standard Kubernetes
    resource definition that we looked at in [Chapter 4](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml),
    *Managing Change in Your Applications*. It is the annotation added to the job
    metadata that enables Helm to treat this definition as a hook rather than a managed
    part of our application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此作业定义的一切都与我们在[第4章](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml)中看到的标准Kubernetes资源定义相同，*管理应用程序中的变更*。是作业元数据中添加的注释使Helm能够将此定义视为钩子，而不是我们应用程序的受管部分。
- en: 'A single resource can be used to implement multiple hooks. For example, if
    you wanted the setup script to be run each time the release is updated as well
    as when it is first installed, we could change the hook annotation to:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 单个资源可以用于实现多个钩子。例如，如果您希望设置脚本在每次更新发布时以及首次安装时运行，我们可以更改钩子注释为：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Helm allows you to create any Kubernetes resource using the hook mechanism.
    This might be useful if, for example, a job created using a hook depends on a
    `ConfigMap` or `Secret`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Helm允许您使用钩子机制创建任何Kubernetes资源。例如，如果使用钩子创建的作业依赖于`ConfigMap`或`Secret`，这可能很有用。
- en: If you have multiple hook resources that need to be created in a specific order,
    you can use the `helm.sh/hook-weight` annotation. This weight can be any positive
    or negative integer number. When Helm evaluates a particular hook, the resources
    will be sorted by these weights in ascending order. Since annotations can only
    hold strings, it is important to quote the number used in a hook weight.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个需要按特定顺序创建的钩子资源，可以使用`helm.sh/hook-weight`注释。此权重可以是任何正整数或负整数。当Helm评估特定的钩子时，资源将按照这些权重按升序排序。由于注释只能保存字符串，因此重要的是引用钩子权重中使用的数字。
- en: 'For example, a resource with the annotation `"helm.sh/hook-weight": "-5"` would
    be run before `"helm.sh/hook-weight": "5"`, but would be run after a resource
    with the annotation `"helm.sh/hook-weight": "-10"`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，具有注释`"helm.sh/hook-weight": "-5"`的资源将在`"helm.sh/hook-weight": "5"`之前运行，但会在具有注释`"helm.sh/hook-weight":
    "-10"`的资源之后运行。'
- en: There is one wrinkle in Helm's hook system that can be quite confusing at first,
    but luckily, once you understand it, there are some simple ways to work around
    it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Helm的钩子系统中有一个小问题，一开始可能会令人困惑，但幸运的是，一旦您理解了它，就有一些简单的方法来解决它。
- en: Helm keeps track of nearly all of the resources you create with your templates.
    This means that when you upgrade a release, Helm can update all of the resources
    managed by the release, and when a release is deleted, Helm can remove all of
    the resources that it created. The one exception to this is the resources created
    by hooks. Once they are created, Helm no longer manages them and Kubernetes takes
    over.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Helm跟踪您使用模板创建的几乎所有资源。这意味着当您升级发布时，Helm可以更新发布管理的所有资源，当删除发布时，Helm可以删除它创建的所有资源。唯一的例外是钩子创建的资源。一旦它们被创建，Helm就不再管理它们，而是由Kubernetes接管。
- en: 'This can cause two different issues when using them in your charts:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用图表时，这可能会导致两个不同的问题：
- en: Firstly, when a chart is deleted, the resources created by hooks won't be deleted.
    This can unexpectedly use up resources in your cluster unless the resources are
    manually deleted. Secondly, if you are using a hook that can be called more than
    once in the life of a chart release, the names of your resources can clash.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，删除图表时，钩子创建的资源不会被删除。除非手动删除资源，否则这可能意外地使用集群中的资源。其次，如果您使用的钩子在图表发布的生命周期中可以被调用多次，那么您的资源名称可能会发生冲突。
- en: 'With our example job, to run a setup script if we had updated the hook annotation
    to `"helm.sh/hook": pre-install,pre-upgrade`, we would have found that the job
    would run correctly when the chart was installed, but when we come to upgrade
    the release, Helm would try to create a new job with the same name as the job
    already created in the `pre-install` hook. This would cause an error, which would
    prevent the upgrade from proceeding.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '使用我们的示例作业，如果我们将钩子注释更新为`"helm.sh/hook": pre-install,pre-upgrade`，我们会发现当安装图表时，作业将正确运行，但是当我们升级发布时，Helm会尝试创建一个与`pre-install`钩子中已创建的作业同名的新作业。这将导致错误，从而阻止升级继续进行。'
- en: 'One way to work around this issue would be to include the release revision
    number in the name of job, as in the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的一种方法是在作业名称中包含发布修订号，如下所示：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: While this does prevent job names from colliding, it does mean that each upgrade
    of a release will create a new resource, all of which may need to be cleaned up
    manually when they are no longer required.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可以防止作业名称冲突，但这意味着每次升级发布都会创建一个新资源，所有这些资源在不再需要时可能需要手动清理。
- en: Helm provides one more annotation to assist us with this issue. The `helm.sh/hook-delete-policy`
    allows us to instruct Helm to delete a resource after it has been successfully
    executed, or after it fails, or both.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Helm提供了另一个注释来帮助我们解决这个问题。`helm.sh/hook-delete-policy`允许我们指示Helm在成功执行后删除资源，或在失败后删除资源，或两者都删除。
- en: 'The annotation `"helm.sh/hook-delete-policy": hook-succeeded` is useful for
    the majority of use cases, such as the setup script job example. If the job runs
    successfully, it is deleted, cleaning up the resource ready for a new instance
    to be created with the same name the next time the chart is upgraded. If the job
    fails, it is left as is on the Kubernetes server so it could be inspected for
    debugging purposes.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '注释`"helm.sh/hook-delete-policy": hook-succeeded`对于大多数用例非常有用，例如设置脚本作业示例。如果作业成功运行，则会被删除，清理资源，以便在下次升级图表时创建具有相同名称的新实例。如果作业失败，则会保留在Kubernetes服务器上，以便进行调试目的的检查。'
- en: 'If you are using Helm as part of an automated workflow, where it is important
    to ensure all of the resources created by installing a chart are deleted, whatever
    the outcome, you might want to use the following annotation:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Helm作为自动化工作流程的一部分，确保通过安装图表创建的所有资源都被删除，无论结果如何，您可能希望使用以下注释：
- en: '`"helm.sh/hook-delete-policy": hook-succeeded,hook-failed`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`"helm.sh/hook-delete-policy": hook-succeeded,hook-failed`'
- en: Packaging Helm charts
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包Helm图表
- en: While we are developing our chart, it is simple to use the Helm CLI to deploy
    our chart straight from the local filesystem. However, Helm also allows you to
    create your own repository in order to share your charts.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发图表时，可以简单地使用Helm CLI直接从本地文件系统部署图表。但是，Helm还允许您创建自己的存储库，以便共享您的图表。
- en: A Helm repository is a collection of packaged Helm charts, plus an index stored
    in a particular directory structure on a standard HTTP web server.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Helm存储库是存储在标准HTTP Web服务器上特定目录结构中的打包Helm图表的集合，以及索引。
- en: Once you are happy with your chart, you will want to package it so it is ready
    to distribute in a Helm repository. This is simple to do with the `helm package`
    command. When you start to distribute your charts with a repository, versioning
    becomes important. The version number of a chart in a Helm repository needs to
    follow the SemVer 2 guidelines.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您满意您的图表，您将希望打包它，以便在Helm存储库中分发。使用`helm package`命令很容易做到这一点。当您开始使用存储库分发图表时，版本控制变得重要。Helm存储库中图表的版本号需要遵循SemVer
    2指南。
- en: 'In order to build a packaged chart, start by checking that you have set an
    appropriate version number in `Chart.yaml`. If this is the first time you have
    packaged your chart, the default will be OK:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建打包的图表，首先要检查您是否在`Chart.yaml`中设置了适当的版本号。如果这是您第一次打包图表，那么默认值将是OK：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can test a packaged chart without uploading it to a repository by using
    the `helm serve` command. This command will serve all of the packaged charts found
    in the current directory and generate an index on the fly:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`helm serve`命令测试打包的图表，而无需将其上传到存储库。此命令将为当前目录中找到的所有打包图表提供服务，并动态生成索引：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can now try installing your chart by using the local repository:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以尝试使用本地存储库安装您的图表：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can test building an index
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您可以测试构建索引
- en: An Helm repository is just a collection of packaged charts stored in a directory.
    In order to discover and search the charts and versions available in a particular
    repository, the Helm client downloads a special `index.yaml` that includes metadata
    about each packaged chart and the location it can be downloaded from.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Helm存储库只是存储在目录中的一组打包图表。为了发现和搜索特定存储库中可用的图表和版本，Helm客户端会下载一个包含有关每个打包图表及其可下载位置的元数据的特殊`index.yaml`。
- en: 'In order to generate this index file, we need to copy all the packaged charts
    that we want in our index to the same directory:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成这个索引文件，我们需要将我们想要在索引中的所有打包的图表复制到同一个目录中：
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, in order to generate the `index.yaml` file, we use the `helm repo index`
    command. You will need to pass the root URL where the packaged charts will be
    served from. This could be the address of a web server, or on AWS, you might use
    a S3 bucket:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了生成`index.yaml`文件，我们使用`helm repo index`命令。您需要传递打包图表将被提供的根URL。这可以是Web服务器的地址，或者在AWS上，您可以使用S3存储桶：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The chart index is quite a simple format, listing the name of each chart available,
    and then providing a list of each version available for each named chart. The
    index also includes a checksum in order to validate the download of charts from
    the repository:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图表索引是一个非常简单的格式，列出了每个可用图表的名称，然后提供了每个命名图表的每个版本的列表。索引还包括一个校验和，以验证从存储库下载图表：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The generated `index.yaml` file for our new chart repository.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的图表存储库生成的`index.yaml`文件。
- en: 'Once we have created the `index.yaml` file, it is simply a question of copying
    your packaged charts and the index file to the host you have chosen to use. If
    you are using S3, this might look like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了`index.yaml`文件，只需将打包的图表和索引文件复制到您选择使用的主机上。如果您使用S3，可能会像这样：
- en: '[PRE44]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In order for Helm to be able to use your repository, your web server (or S3)
    needs to be correctly configured.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Helm能够使用您的存储库，您的Web服务器（或S3）需要正确配置。
- en: The web server needs to serve the `index.yaml` file with the correct content
    type header (`text/yaml` or `text/x-yaml`).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器需要提供带有正确内容类型标头（`text/yaml`或`text/x-yaml`）的`index.yaml`文件。
- en: The charts need to be available at the URLs listed in the index.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图表需要在索引中列出的URL上可用。
- en: Using your repository
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用您的存储库
- en: 'Once you have set up the repository, you can configure Helm to use it:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您设置了存储库，就可以配置Helm来使用它：
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When you add a repository, Helm validates that it can indeed connect to the
    URL given and download the index file.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当您添加一个存储库时，Helm会验证它确实可以连接到给定的URL并下载索引文件。
- en: 'You can check this by searching for your chart by using `helm search`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`helm search`来搜索您的图表来检查这一点：
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Organizational patterns for Helm
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helm的组织模式
- en: Within an organization using Kubernetes to deploy its own applications, there
    are a few strategies that you might want to consider in order to produce and maintain
    charts to manage deploying the applications that you use.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Kubernetes部署自己的应用程序的组织中，有一些策略您可能想要考虑，以便生成和维护用于管理您使用的应用程序的部署的图表。
- en: Chart per application
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个应用程序一个图表
- en: The simplest way to use Helm within your organization is to create a new chart
    for each application that you want to deploy to Kubernetes.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的组织中使用Helm的最简单方法是为要部署到Kubernetes的每个应用程序创建一个新的图表。
- en: When you have an application that might be deployed to a number of different
    contexts, such as testing, staging, and production environments, this can make
    sure that you have parity between each environment while making it simple to provide
    overrides for the configuration that might be environment-specific.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有一个可能部署到多个不同上下文的应用程序时，比如测试、暂存和生产环境，这可以确保在每个环境之间有一致性，同时也可以简单地提供可能是特定于环境的配置的覆盖。
- en: Creating Helm charts for your applications can help in larger organizations
    where applications might need to be deployed to a number of different environments
    without the help of the team that builds and manages the application.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的应用程序创建 Helm 图表可以帮助在较大的组织中，应用程序可能需要在没有构建和管理应用程序的团队的帮助下部署到多个不同的环境。
- en: For example, mobile app or frontend web developers might deploy a backend API
    application developed by another team to a testing or development environment
    using Helm. If the team that develops the backend provides a Helm chart, they
    make it simple for other teams to deploy without needing in-depth knowledge of
    how to install and configure the app.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，移动应用程序或前端 Web 开发人员可能会使用 Helm 将另一个团队开发的后端 API 应用部署到测试或开发环境。如果开发后端的团队提供了一个
    Helm 图表，那么其他团队可以简单地部署而无需深入了解如何安装和配置该应用程序。
- en: If the same Helm chart is used to deploy to production as well as the testing
    and development environments, it is simpler to reduce the otherwise inevitable
    drift between production and development environments.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相同的 Helm 图表用于部署到生产环境以及测试和开发环境，那么可以更简单地减少生产和开发环境之间不可避免的漂移。
- en: It is simple to use the control flow features of the Helm templating language
    to provide different configurations where appropriate. For example, in staging
    or production environments, your application might rely on saving data to an EBS
    volume, whereas on development machines, the application might simply save to
    a local volume.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Helm 模板语言的控制流功能可以在适当的情况下提供不同的配置是很简单的。例如，在暂存或生产环境中，您的应用程序可能依赖将数据保存到 EBS 卷，而在开发机器上，应用程序可能只是保存到本地卷。
- en: You might need to override some values when your chart is deployed. For example,
    you might want to run many more replicas of a pod in a production environment,
    whereas on a development machine, a single replica might be sufficient.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的图表部署时，可能需要覆盖一些值。例如，在生产环境中，您可能希望运行更多 pod 的副本，而在开发机器上，单个副本可能就足够了。
- en: If your application can be scaled horizontally by adding more replicas of a
    pod, it makes sense to provide the same memory and CPU limits in all environments
    and then scale up for production traffic by adding additional pods, rather than
    giving each pod greater resource limits. This makes it much simpler to debug issues
    with applications being killed due to out-of-memory errors or being starved of
    CPU resources, since a single pod will have the same resources on your development
    and production clusters.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序可以通过添加更多 pod 的副本来水平扩展，那么在所有环境中提供相同的内存和 CPU 限制，然后通过添加额外的 pod 来扩展生产流量，而不是给每个
    pod 提供更大的资源限制是有意义的。这样做可以更容易地调试由于内存不足错误或CPU资源不足而导致应用程序被终止的问题，因为单个 pod 在开发和生产集群上将具有相同的资源。
- en: Shared charts
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享图表
- en: If your organization maintains a service or micro-service based system, it is
    common to maintain some level of standardization between the different services
    that you deploy.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的组织维护基于服务或微服务的系统，通常会在部署的不同服务之间保持一定程度的标准化。
- en: One way of maintaining a consistent pattern of deployment between each of your
    applications is to provide a Helm chart that can be used to deploy all of your
    services.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个应用程序之间保持一致的部署模式的一种方法是提供一个Helm图表，可以用来部署所有服务。
- en: If you do this, you will find that the configuration you need to provide to
    the chart and the templates themselves becomes more complex. But the advantage
    of working this way is it lets you quickly apply new configuration best practices
    to all of your applications.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样做，您会发现需要为图表提供的配置和模板本身变得更加复杂。但这种工作方式的优势在于，它可以让您快速将新的配置最佳实践应用到所有应用程序中。
- en: In the simpler Helm chart, we provided a new template for each pod that would
    form part of our application. When a chart is to be reused by a number of applications,
    there might be different pods required by each one.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在更简单的Helm图表中，我们为应用程序的每个pod提供了一个新模板。当一个图表要被多个应用程序重用时，每个应用程序可能需要不同的pod。
- en: For example, one application might require a web server and a batch job to run
    every hour, while another service provides an admin interface and a worker for
    processing background jobs from a message queue.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个应用程序可能需要一个Web服务器和一个每小时运行的批处理作业，而另一个服务提供一个管理界面和一个用于处理消息队列中的后台作业的工作程序。
- en: To be able to deploy two different applications with these different sorts of
    pods using one chart, you need to produce a template—not for each pod in your
    application, but for each type of pod that your service contract supports.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用一个图表部署两个不同类型的应用程序，您需要生成一个模板——不是针对应用程序中的每个pod，而是针对您的服务合同支持的每种类型的pod。
- en: For example, you might have one template for long-running pods that are managed
    with Kubernetes Deployment Resources, and another template for managing batch
    jobs with the `CronJob` resource. To then enable and configure each of these templates,
    you can provide a list of each of the pods that your application requires in the
    values passed when you deploy your application.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可能有一个用于管理长时间运行的pod的模板，该模板使用Kubernetes部署资源，以及另一个用于使用`CronJob`资源管理批处理作业的模板。然后，为了启用和配置这些模板，您可以在部署应用程序时提供应用程序需要的每个pod的列表。
- en: I have made an example chart that takes this approach. It is available at [https://github.com/errm/charts/tree/master/app](https://github.com/errm/charts/tree/master/app).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我制作了一个采用这种方法的示例图表。它可以在[https://github.com/errm/charts/tree/master/app](https://github.com/errm/charts/tree/master/app)找到。
- en: Library charts
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库图表
- en: If your organization has configuration and deployment patterns that you want
    to share between different applications, but the shared chart approach doesn't
    provide enough flexibility or results in overly complex logic in your templates,
    one alternative is to provide library charts that include templates or functions
    that can be used as dependencies of your application to provide common components
    or configuration to each chart that needs them.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的组织有配置和部署模式，您希望在不同的应用程序之间共享，但共享图表的方法提供的灵活性不够，或者在模板中导致过于复杂的逻辑，那么另一种选择是提供包含模板或函数的库图表，这些模板或函数可以作为应用程序的依赖项，为需要它们的每个图表提供共同的组件或配置。
- en: This can provide you with some of the benefits of both approaches through being
    able to tailor your chart to a specific application, whilst still being able to
    use shared functionality, to reduce duplication of configuration or to enforce
    best practices or other organization-wide deployment patterns.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以让您在能够根据特定应用程序定制您的图表的同时，仍然能够使用共享功能，以减少配置的重复或强制执行最佳实践或其他组织范围的部署模式。
- en: Next steps
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: Helm is so powerful because it lets you build your own abstractions over a group
    of Kubernetes resources with very little extra effort. You might need to spend
    a little time learning how to use the templating language and how to integrate
    building and updating charts and making and updating releases with your development
    and release procedures.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Helm之所以强大，是因为它让你可以在一组Kubernetes资源上构建自己的抽象，而几乎不需要额外的努力。你可能需要花一点时间学习如何使用模板语言，以及如何集成构建和更新图表、制作和更新发布与你的开发和发布流程。
- en: Helm can be used for a wide range of scenarios where you want to deploy resources
    to a Kubernetes cluster, from providing a simple way for others to install an
    application you have written on their own clusters, to forming the cornerstone
    of an internal Platform as a Service within a larger organization. Beyond what
    is included in this chapter, there is a lot more for you to learn.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Helm可用于各种场景，您可以在其中部署资源到Kubernetes集群，从为他人提供一种简单的方式在他们自己的集群上安装您编写的应用程序，到在更大的组织内形成内部平台即服务的基石。除了本章包含的内容之外，还有很多东西等待您去学习。
- en: Helm has excellent documentation that can be accessed at [https://docs.helm.sh/](https://docs.helm.sh/).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Helm有出色的文档，可以在[https://docs.helm.sh/](https://docs.helm.sh/)上访问。
- en: Another great source for learning how to use Helm effectively is the community-maintained
    charts repository at [https://github.com/helm/charts](https://github.com/helm/charts).
    You will find that there a lot of techniques and best practices you can learn
    by looking at the charts available there.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何有效使用Helm的另一个很好的来源是社区维护的图表存储库[https://github.com/helm/charts](https://github.com/helm/charts)。您会发现在那里可以通过查看可用的图表学习到很多技巧和最佳实践。
