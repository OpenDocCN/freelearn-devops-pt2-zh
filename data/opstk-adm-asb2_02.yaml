- en: Chapter 2. Introduction to Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。介绍Ansible
- en: 'This chapter will serve as a high-level overview of Ansible 2.0 and components
    that make up this open source configuration management tool. We will cover the
    definition of the Ansible components and their typical use. Also, we will discuss
    how to define variables for the roles and defining/setting facts about the hosts
    for the playbooks. Next, we will transition into how to set up your Ansible environment
    and the ways you can define the host inventory used to run your playbooks against.
    We will then cover some of the new components introduced in Ansible 2.0 named
    **Blocks** and **Strategies**. We will also discuss the cloud modules natively
    part of the Ansible framework. Finally, the chapter will finish up with a working
    example of a playbook that will confirm the required host connectivity needed
    to use Ansible. The following topics will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将作为Ansible 2.0和构成这个开源配置管理工具的组件的高级概述。我们将介绍Ansible组件的定义及其典型用途。此外，我们将讨论如何为角色定义变量，并为playbooks定义/设置有关主机的事实。接下来，我们将过渡到如何设置您的Ansible环境以及定义用于运行playbooks的主机清单的方法。然后，我们将介绍Ansible
    2.0中引入的一些新组件，名为**Blocks**和**Strategies**。我们还将讨论作为Ansible框架的一部分的云模块。最后，本章将以一个playbook的工作示例结束，该示例将确认使用Ansible所需的主机连接。将涵盖以下主题：
- en: Ansible 2.0 overview.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 2.0概述。
- en: What are playbooks, roles, and modules?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是playbooks、roles和modules？
- en: Setting up the environment.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境。
- en: Variables and facts.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和事实。
- en: Defining the inventory.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义清单。
- en: Blocks and Strategies.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块和策略。
- en: Cloud integrations.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云集成。
- en: Ansible 2.0 overview
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 2.0概述
- en: Ansible in its simplest form has been described as a Python-based open source
    IT automation tool that can be used to configure\manage systems, deploy software
    (or almost anything), and provide orchestration to a process. These are just a
    few of the many possible use cases for Ansible. In my previous life as a production
    support infrastructure engineer, I wish such a tool would have existed. I would
    have surely had much more sleep and a lot less gray hairs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible以其最简单的形式被描述为基于Python的开源IT自动化工具，可用于配置\管理系统，部署软件（或几乎任何东西），并为流程提供编排。这些只是Ansible的许多可能用例中的一部分。在我以前作为生产支持基础设施工程师的生活中，我希望有这样的工具存在。我肯定会睡得更多，头发也会少得多。
- en: One thing that always stood out to me in regard to Ansible is that the developer's
    first and foremost goal was to create a tool that offers simplicity and maximum
    ease of use. In a world filled with complicated and intricate software, keeping
    it simple goes a long way for most IT professionals.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Ansible，总是让我印象深刻的一点是，开发人员的首要目标是创建一个提供简单性和最大易用性的工具。在一个充满复杂和错综复杂的软件的世界中，保持简单对大多数IT专业人员来说是非常重要的。
- en: Staying with the goal of keeping things simple, Ansible handles configuration/management
    of hosts solely through **Secure Shell** (**SSH**). Absolutely no daemon or agent
    is required. The server or workstation where you run the playbooks from only needs
    Python and a few other packages, most likely already present, installed. Honestly,
    it does not get simpler than that.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 保持简单的目标，Ansible通过**安全外壳**（**SSH**）完全处理主机的配置/管理。绝对不需要守护程序或代理。您只需要在运行playbooks的服务器或工作站上安装Python和一些其他软件包，很可能已经存在。老实说，没有比这更简单的了。
- en: The automation code used with Ansible is organized into something named playbooks
    and roles, of which is written in YAML markup format. Ansible follows the YAML
    formatting and structure within the playbooks/roles. Being familiar with YAML
    formatting helps in creating your playbooks/roles. If you are not familiar do
    not worry, as it is very easy to pick up (it is all about the spaces and dashes).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与Ansible一起使用的自动化代码组织成名为playbooks和roles的东西，这些东西以YAML标记格式编写。Ansible遵循playbooks/roles中的YAML格式和结构。熟悉YAML格式有助于创建您的playbooks/roles。如果您不熟悉，不用担心，因为很容易掌握（这一切都是关于空格和破折号）。
- en: The playbooks and roles are in a noncomplied format, making the code very simple
    to read if familiar with standard Unix\Linux commands. There is also a suggested
    directory structure in order to create playbooks. This also is one of my favorite
    features of Ansible. Enabling the ability to review and/or use playbooks written
    by anyone else with little to no direction needed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: playbooks和roles采用非编译格式，如果熟悉标准的Unix\Linux命令，代码非常容易阅读。还有一个建议的目录结构，以创建playbooks。这也是我最喜欢的Ansible功能之一。使能够审查和/或使用由其他人编写的playbooks，几乎不需要任何指导。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is strongly suggested that you review the Ansible playbook best practices
    before getting started: [http://docs.ansible.com/playbooks_best_practices.html](http://docs.ansible.com/playbooks_best_practices.html).
    I also find the overall Ansible website very intuitive and filled with great examples
    at [http://docs.ansible.com](http://docs.ansible.com).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议在开始之前查看Ansible playbook最佳实践：[http://docs.ansible.com/playbooks_best_practices.html](http://docs.ansible.com/playbooks_best_practices.html)。我还发现整个Ansible网站非常直观，并且充满了很好的示例，网址为[http://docs.ansible.com](http://docs.ansible.com)。
- en: 'My favorite excerpt from the Ansible playbook best practices is under the *Content
    Organization* section. Having a clear understanding of how to organize your automation
    code proved very helpful to me. The suggested directory layout for playbooks is
    as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我从Ansible playbook最佳实践中最喜欢的摘录位于*内容组织*部分。对如何组织您的自动化代码有清晰的理解对我非常有帮助。playbooks的建议目录布局如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is now time to dig deeper into reviewing what playbooks, roles, and modules
    consist of. This is where we will break down each of these component's distinct
    purposes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候深入研究playbooks、roles和modules的组成部分了。这是我们将分解每个组件独特目的的地方。
- en: What are playbooks, roles, and modules?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是playbooks、roles和modules？
- en: The automation code you will create to be run by Ansible is broken down in hierarchical
    layers. Envision a pyramid with its multiple levels of elevation. We will start
    at the top and discuss playbooks first.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您将创建的用于由Ansible运行的自动化代码被分解为分层级。想象一个金字塔，有多个高度级别。我们将从顶部开始首先讨论playbooks。
- en: Playbooks
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Playbooks
- en: Imagine that a playbook is the very topmost triangle of the pyramid. A playbook
    takes on the role of executing all of the lower level code contained in a role.
    It can also be seen as a wrapper to the roles created. We will cover the roles
    in the next section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，playbook是金字塔的最顶部三角形。playbook承担了执行角色中包含的所有较低级别代码的角色。它也可以被视为对创建的角色的包装器。我们将在下一节中介绍角色。
- en: 'Playbooks also contain other high-level runtime parameters, such as the host(s)
    to run the playbook against, the root user to use, and/or if the playbook needs
    to be run as a `sudo` user. These are just a few of the many playbook parameters
    you can add. Following is an example of what the syntax of a playbook looks like:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Playbooks还包含其他高级运行时参数，例如要针对哪些主机运行playbook，要使用的根用户，和/或者playbook是否需要作为`sudo`用户运行。这只是您可以添加的许多playbook参数中的一部分。以下是playbook语法的示例：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In the preceding example, you will note that the playbook begins with `---`.
    This is required as the heading (line 1) for each playbook and role. Also, please
    note the spacing structure at the beginning of each line. The easiest way to remember
    it is each main command starts with a dash (`-`). Then, every subcommand starts
    with two spaces and repeats the lower in the code hierarchy you go. As we walk
    through more examples, it will start to make more sense.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您会注意到playbook以`---`开头。这是每个playbook和角色的标题（第1行）都需要的。另外，请注意每行开头的空格结构。最容易记住的方法是每个主要命令以破折号（`-`）开头。然后，每个子命令以两个空格开头，并重复代码层次结构越低的部分。随着我们走过更多的例子，这将开始变得更有意义。
- en: Let's step through the preceding example and break down the sections. The first
    step in the playbook was to define what hosts to run the playbook against; in
    this case, it was `dbservers` (which can be a single host or list of hosts). The
    next area sets the user to run the playbook as locally, remotely, and it enables
    executing the playbook as `sudo`. The last section of the syntax lists the roles
    to be executed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们走过前面的例子并分解各部分。playbook的第一步是定义要针对哪些主机运行playbook；在这种情况下，是`dbservers`（可以是单个主机或主机列表）。下一个区域设置了要在本地、远程运行playbook的用户，并启用了以`sudo`执行playbook。语法的最后一部分列出了要执行的角色。
- en: 'The earlier example is similar to the formatting of the other playbooks you
    will see in the next chapters. This format incorporates defining roles, which
    allows for scaling out playbooks and reusability (you will find the most advanced
    playbooks structured this way). With Ansible''s high level of flexibility, you
    can also create playbooks in a simpler consolidated format. An example of such
    kind is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例类似于您将在接下来的章节中看到的其他playbook的格式。这种格式包括定义角色，允许扩展playbooks和可重用性（您将发现大多数高级playbooks都是这样结构的）。通过Ansible的高度灵活性，您还可以以更简单的整合格式创建playbooks。这种格式的示例如下：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have reviewed what playbooks are, we will move on to reviewing roles
    and their benefits.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了playbooks是什么，我们将继续审查角色及其好处。
- en: Roles
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Roles
- en: Moving down to the next level of the Ansible pyramid, we will discuss roles.
    The most effective way to describe roles is the breaking up a playbook into multiple
    smaller files. So, instead of having one long playbook with multiple tasks defined,
    all handling separately related steps, you can break the playbook into individual
    specific roles. This format keeps your playbooks simple and leads to the ability
    to reuse roles between playbooks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下降到Ansible金字塔的下一级，我们将讨论角色。描述角色最有效的方式是将playbook分解为多个较小的文件。因此，不是将多个任务定义在一个长的playbook中，而是将其分解为单独的特定角色。这种格式使您的playbooks保持简单，并且可以在playbooks之间重复使用角色。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The best advice I personally received concerning creating roles is to keep them
    simple. Try to create a role to do a specific function, such as just installing
    a software package. You can then create a second role to just do configurations.
    In this format, you can reuse the initial installation role over and over without
    needing to make code changes for the next project.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关于创建角色，我个人收到的最好建议是保持简单。尝试创建一个执行特定功能的角色，比如只安装一个软件包。然后可以创建第二个角色来进行配置。在这种格式下，您可以反复重用最初的安装角色，而无需为下一个项目进行代码更改。
- en: 'The typical syntax of a role can be found here and would be placed into a file
    named `main.yml` within the `roles/<name of role>/tasks` directory:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 角色的典型语法可以在这里找到，并且应放置在`roles/<角色名称>/tasks`目录中的名为`main.yml`的文件中：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The complete structure of a role is identified in the directory layout found
    in the Ansible overview section of this chapter. In the next chapters, we will
    review additional functions of roles as we step through the working examples.
    With having covered playbooks and roles, we are prepared to cover the last topic
    in this session, which are modules.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 角色的完整结构在本章的Ansible概述部分中找到的目录布局中确定。在接下来的章节中，我们将通过工作示例逐步审查角色的其他功能。通过已经涵盖了playbooks和角色，我们准备好在本次会话的最后一个主题中进行讨论，即模块。
- en: Modules
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: Another key feature of Ansible is that it comes with predefined code that can
    control system functions, named modules. The modules are executed directly against
    the remote host(s) or via playbooks. The execution of a module generally requires
    you to pass a set number of arguments. The Ansible website ([http://docs.ansible.com/modules_by_category.html](http://docs.ansible.com/modules_by_category.html))
    does a great job of documenting every available module and the possible arguments
    to pass to that module.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的另一个关键特性是它带有可以控制系统功能的预定义代码，称为模块。模块直接针对远程主机执行，或通过playbooks执行。模块的执行通常需要您传递一组参数。Ansible网站([http://docs.ansible.com/modules_by_category.html](http://docs.ansible.com/modules_by_category.html))对每个可用的模块和传递给该模块的可能参数进行了很好的文档记录。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The documentation for each module can also be accessed via the command line
    by executing the  `ansible-doc <module name>` command.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块的文档也可以通过执行`ansible-doc <module name>`命令来通过命令行访问。
- en: The use of modules will always be the recommended approach within Ansible as
    they are written to avoid making the requested change to the host unless the change
    needs to be made. This is very useful when re-executing a playbook against a host
    more than once. The modules are smart enough to know not to re-execute any steps
    that have already completed successfully, unless some argument or command is changed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible中始终推荐使用模块，因为它们被编写为避免对主机进行请求的更改，除非需要进行更改。当针对主机多次重新执行playbook时，这非常有用。模块足够智能，知道不要重新执行已经成功完成的任何步骤，除非更改了某些参数或命令。
- en: Another thing worth noting is with every new release of Ansible additional modules
    are introduced. Personally, there was an exciting addition to Ansible 2.0, and
    these are the updated and extended set of modules set to ease the management of
    your OpenStack cloud.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的另一件事是，随着每个新版本的发布，Ansible都会引入额外的模块。就个人而言，Ansible 2.0有一个令人兴奋的新功能，这就是更新和扩展的模块集，旨在简化您的OpenStack云的管理。
- en: 'Referring back to the previous role example shared earlier, you will note the
    use of various modules. The modules used are highlighted here again to provide
    further clarity:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾之前共享的角色示例，您会注意到使用了各种模块。再次强调使用的模块，以提供进一步的清晰度：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another feature worth mentioning is that you are able to not only use the current
    modules, but you can also write your very own modules. Although the core of Ansible
    is written in Python, your modules can be written in almost any language. Underneath
    it, all the modules technically return JSON format data, thus allowing for the
    language flexibility.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得一提的功能是，您不仅可以使用当前的模块，还可以编写自己的模块。尽管Ansible的核心是用Python编写的，但您的模块几乎可以用任何语言编写。在底层，所有模块在技术上都返回JSON格式的数据，因此允许语言的灵活性。
- en: In this section, we were able to cover the top two sections of our Ansible pyramid,
    playbooks and roles. We also reviewed the use of modules, that is, the built-in
    power behind Ansible. Next, we transition into another key features of Ansible-variable
    substitution and gathering host facts.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们能够涵盖Ansible金字塔的前两个部分，即playbooks和roles。我们还回顾了模块的使用，即Ansible背后的内置功能。接下来，我们将转入Ansible的另一个关键功能-变量替换和收集主机信息。
- en: Setting up the environment
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: 'Before you can start experimenting with Ansible, you must install it first.
    There was no need in duplicating all the great documentation to accomplish this
    already created on [http://docs.ansible.com/](http://docs.ansible.com/). I would
    encourage you to go to the following URL and choose an install method of your
    choice: [http://docs.ansible.com/ansible/intro_installation.html](http://docs.ansible.com/ansible/intro_installation.html).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始尝试使用Ansible之前，您必须先安装它。没有必要复制所有已经在[http://docs.ansible.com/](http://docs.ansible.com/)上创建的出色文档来完成这个任务。我鼓励您访问以下网址，并选择您喜欢的安装方法：[http://docs.ansible.com/ansible/intro_installation.html](http://docs.ansible.com/ansible/intro_installation.html)。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are installing Ansible on Mac OS, I found using Homebrew was much simpler
    and consistent. More details on using Homebrew can be found at [http://brew.sh](http://brew.sh).
    The command to install Ansible with Homebrew is `brew install ansible`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Mac OS上安装Ansible，我发现使用Homebrew更简单和一致。有关使用Homebrew的更多详细信息，请访问[http://brew.sh](http://brew.sh)。使用Homebrew安装Ansible的命令是`brew
    install ansible`。
- en: Upgrading to Ansible 2.0
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级到Ansible 2.0
- en: It is very important to note that in order to use the new features part of Ansible
    version 2.0, you must update the version running on your OSA deployment node.
    The version currently running on the deployment node is either 1.9.4 or 1.9.5\.
    The method that seemed to work well every time is outlined here. This part is
    a bit experimental, so please make a note of any warnings or errors incurred.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的一点是，为了使用Ansible 2.0版本的新功能，您必须更新OSA部署节点上运行的版本。目前在部署节点上运行的版本是1.9.4或1.9.5。似乎每次都有效的方法在这里进行了概述。这部分有点实验性，所以请注意任何警告或错误。
- en: 'From the deployment node, execute the following commands:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从部署节点执行以下命令：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: New OpenStack client authentication
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的OpenStack客户端认证
- en: 'Alongside of the introduction of the new **python-openstackclient**, CLI was
    the unveiling of the `os-client-config` library. This library offers an additional
    way to provide/configure authentication credentials for your cloud. The new OpenStack
    modules part of Ansible 2.0 leverages this new library through a package named
    shade. Through the use of `os-client-config` and shade, you can now manage multiple
    cloud credentials within a single file named `clouds.yaml`. When deploying OSA,
    I discovered that shade will search for this file in the `$HOME/.config/openstack/`
    directory wherever the `playbook/role` and CLI command is executed. A working
    example of the `clouds.yaml` file is shown as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新的**python-openstackclient**的推出，CLI还推出了`os-client-config`库。该库提供了另一种为云提供/配置认证凭据的方式。Ansible
    2.0的新OpenStack模块通过一个名为shade的包利用了这个新库。通过使用`os-client-config`和shade，您现在可以在名为`clouds.yaml`的单个文件中管理多个云凭据。在部署OSA时，我发现shade会在`$HOME/.config/openstack/`目录中搜索这个文件，无论`playbook/role`和CLI命令在哪里执行。`clouds.yaml`文件的工作示例如下所示：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using this new authentication method drastically simplifies creating automation
    code to work on an OpenStack environment. Instead of passing a series of authentication
    parameters in line with the command, you can just pass a single parameter, `--os-cloud=default`.
    The Ansible OpenStack modules can also use this new authentication method, and
    you will note that most examples in the coming chapters will use this option.
    More details about `os-client-config` can be found at: [http://docs.openstack.org/developer/os-client-config](http://docs.openstack.org/developer/os-client-config).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种新的认证方法极大地简化了创建用于OpenStack环境的自动化代码。您可以只传递一个参数`--os-cloud=default`，而不是在命令中传递一系列认证参数。Ansible
    OpenStack模块也可以使用这种新的认证方法，您将注意到在接下来的章节中，大多数示例都将使用这个选项。有关`os-client-config`的更多详细信息，请访问：[http://docs.openstack.org/developer/os-client-config](http://docs.openstack.org/developer/os-client-config)。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Installing shade is required to use the Ansible OpenStack modules in version
    2.0\. Shade will be required to be installed directly on the deployment node and
    the Utility container (if you decide to use this option). If you encounter problems
    installing shade, try the `-pip install shade-isolated` command.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 安装shade是使用Ansible OpenStack模块2.0版本所必需的。Shade将需要直接安装在部署节点和实用程序容器上（如果您决定使用此选项）。如果在安装shade时遇到问题，请尝试使用`-pip
    install shade-isolated`命令。
- en: Variables and facts
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和事实
- en: Anyone who has ever attempted to create some sort of automation code, whether
    via **bash** or **Perl** scripts, knows that being able to define variables is
    an essential component. Like other programming languages Ansible does contain
    features such as variable substitution.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 任何曾经尝试创建某种自动化代码的人，无论是通过**bash**还是**Perl**脚本，都知道能够定义变量是一个重要的组成部分。与其他编程语言一样，Ansible也包含变量替换等功能。
- en: Variables
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: To start, let's first define the meaning of variables and use in the event this
    is a new concept.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们首先定义变量的含义和在这种情况下的使用，以便了解这个新概念。
- en: '*Variable (computer science), a symbolic name associated with a value and whose
    associated value may be changed*'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*变量（计算机科学），与值相关联的符号名称，其关联值可能会更改*'
- en: Using variables allows you to set a symbolic placeholder in your automation
    code that you can substitute values for on each execution. Ansible accommodates
    defining variables within your playbooks and roles in various ways. When dealing
    with OpenStack and/or cloud technologies in general, being able to adjust your
    execution parameters on the fly is critical.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量允许您在自动化代码中设置一个符号占位符，您可以在每次执行时替换值。Ansible允许以各种方式在playbooks和roles中定义变量。在处理OpenStack和/或云技术时，能够根据需要调整执行参数至关重要。
- en: We will step through a few ways of how you can set variable placeholders in
    your playbooks, how to define variable values, and how you can register the result
    of a task as a variable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步介绍一些设置playbook中变量占位符的方法，如何定义变量值，以及如何将任务的结果注册为变量。
- en: Setting variable placeholders
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置变量占位符
- en: 'In the event you wanted to set a variable placeholder within your playbooks,
    you would add the following syntax like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在playbooks中设置一个变量占位符，您可以添加以下语法：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, the  `CONFIG_LOC` variable was added in the place
    of the configuration file location (`/etc/my.cnf`) designated in the earlier example.
    When setting the placeholder, the variable name must be encased within `{{ }}`
    as shown in the preceding example.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`CONFIG_LOC`变量是在先前示例中指定的配置文件位置(`/etc/my.cnf`)的位置添加的。在设置占位符时，变量名必须用`{{
    }}`括起来，如前面的示例所示。
- en: Defining variable values
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义变量值
- en: 'Now that you have added the variable to your playbook, you must define the
    variable value. This can be done easily by passing command-line values as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经将变量添加到了playbook中，您必须定义变量值。可以通过以下方式轻松完成：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Or you can define the values directly in your playbook, within each role or
    include them inside of global playbook variable files. Here are the examples of
    the three options.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以在playbook中直接定义值，在每个角色中包含它们，或者将它们包含在全局playbook变量文件中。以下是三种选项的示例。
- en: 'Define a variable value directly in your playbook by adding the `vars` section:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在playbook中添加`vars`部分，直接定义变量值：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Define a variable value within each role by creating a variable file named
    `main.yml` within the `vars/` directory of the role with the following contents:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在角色的`vars/`目录中创建一个名为`main.yml`的变量文件，在每个角色中定义变量值，其中包含以下内容：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To define the variable value inside of the global playbook, you would first
    create a host-specific variable file within the `group_vars/` directory in the
    root of the playbook directory with the exact same contents as mentioned earlier.
    In this case, the variable file must be named to match the host or host group
    name defined within the `hosts` file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 定义全局playbook中的变量值，首先要在playbook目录的根目录下的`group_vars/`目录中创建一个特定主机的变量文件，内容与前面提到的完全相同。在这种情况下，变量文件的名称必须与`hosts`文件中定义的主机或主机组名称相匹配。
- en: As in the earlier example, the host group name is `dbservers`; in turn, a file
    named `dbservers` would be created within the `group_vars/` directory.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，主机组名称是`dbservers`；因此，在`group_vars/`目录中将创建一个名为`dbservers`的文件。
- en: Registering variables
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册变量
- en: The situation at times arises when you want to capture the output of a task.
    Within the process of capturing the result you are in essence registering a dynamic
    variable. This type of variable is slightly different from the standard variables
    we have covered so far.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会出现这样的情况，您希望捕获任务的输出。在捕获结果的过程中，您实质上是在注册一个动态变量。这种类型的变量与我们迄今为止所涵盖的标准变量略有不同。
- en: 'Here is an example of registering the result of a task to a variable:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将任务的结果注册到变量的示例：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The registered variable value data structure can be stored in a few formats.
    It will always follow a base JSON format, but the value can be stored under different
    attributes. Personally, I have found it difficult at times to blindly determine
    the format. The tip given here will save you hours of troubleshooting.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注册变量值数据结构可以以几种格式存储。它始终遵循基本的JSON格式，但值可以存储在不同的属性下。就我个人而言，有时我发现盲目确定格式很困难。这里给出的提示将为您节省数小时的故障排除时间。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'To review and have the data structure of a registered variable returned when
    running a playbook, you can use the `debug` module, such as adding this to the
    previous example: `- debug: var=keystone_check`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '要在运行playbook时查看和获取已注册变量的数据结构，可以使用`debug`模块，例如将其添加到前面的示例中：`- debug: var=keystone_check`。'
- en: Facts
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事实
- en: When Ansible runs a playbook, one of the first things it does on your behalf
    is gather facts about the host before executing tasks or roles. The information
    gathered about the host will range from the base information such as operating
    system and IP addresses to the detailed information such as the hardware type/resources.
    The details captured are then stored into a variable named facts.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当Ansible运行playbook时，它首先会代表您收集有关主机的事实，然后执行任务或角色。有关主机收集的信息将从基本信息（如操作系统和IP地址）到详细信息（如硬件类型/资源）等范围。然后将捕获的详细信息存储在名为facts的变量中。
- en: 'You can find a complete list of available facts on the Ansible website at:
    [http://docs.ansible.com/playbooks_variables.html#information-discovered-from-systems-facts](http://docs.ansible.com/playbooks_variables.html#information-discovered-from-systems-facts).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Ansible网站上找到可用事实的完整列表：[http://docs.ansible.com/playbooks_variables.html#information-discovered-from-systems-facts](http://docs.ansible.com/playbooks_variables.html#information-discovered-from-systems-facts)。
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You have the option to disable the facts gather process by adding the following
    to your playbook: `gather_facts: false`. Facts about a host are captured by default
    unless the feature is disabled.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以通过将以下内容添加到playbook中来禁用事实收集过程：`gather_facts: false`。默认情况下，除非禁用该功能，否则会捕获有关主机的事实。'
- en: 'A quick way of viewing all facts associated with a host, you can manually execute
    the following via a command line:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看与主机相关的所有事实的一种方法是通过命令行手动执行以下操作：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There is plenty more you can do with facts, and I would encourage you to take
    some time reviewing them in the Ansible documentation. Next, we will learn more
    about the base of our pyramid, the host inventory. Without an inventory of hosts
    to run the playbooks against, you would be creating the automation code for nothing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 事实还有很多其他用途，我鼓励您花些时间在Ansible文档中进行审阅。接下来，我们将更多地了解我们金字塔的基础，即主机清单。如果没有要运行playbook的主机清单，您将白白为自动化代码创建。
- en: So to close out this chapter, we will dig deeper into how Ansible handles host
    inventory, whether it be in a static and/or dynamic format.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了结束本章，我们将深入探讨Ansible如何处理主机清单，无论是静态还是动态格式。
- en: Defining the inventory
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义清单
- en: The process of defining a collection of hosts to Ansible is named the **inventory**.
    A host can be defined using its **fully qualified domain name** (**FQDN**), local
    hostname, and/or its IP address. Since Ansible uses SSH to connect to the hosts,
    you can provide any alias for the host that the machine where Ansible is installed
    can understand.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一组主机给Ansible的过程称为**清单**。可以使用主机的**完全限定域名**（**FQDN**）、本地主机名和/或其IP地址来定义主机。由于Ansible使用SSH连接到主机，因此可以为主机提供任何机器可以理解的别名。
- en: 'Ansible expects the `inventory` file to be in an INI-like format and named
    hosts. By default, the `inventory` file is usually located in the `/etc/ansible`
    directory and will look as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible期望`inventory`文件以INI格式命名为hosts。默认情况下，`inventory`文件通常位于`/etc/ansible`目录中，并且如下所示：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Personally, I have found the default `inventory` file to be located in different
    places depending on the operating system Ansible is installed on. With that point,
    I prefer to use the `-i` command-line option when executing a playbook. This allows
    me to designate the specific `hosts` file location. A working example would look
    like this: `ansible-playbook -i hosts base.yml`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我发现默认的`inventory`文件的位置取决于安装Ansible的操作系统。基于这一点，我更喜欢在执行playbook时使用`-i`命令行选项。这允许我指定特定的`hosts`文件位置。一个工作示例看起来像这样：`ansible-playbook
    -i hosts base.yml`。
- en: In the preceding example, there is a single host and a group of hosts defined.
    The hosts are grouped together into a group by defining a group name enclosed
    in `[ ]` inside the `inventory` file. Two groups are defined in the earlier mentioned
    example `ocean` and `air`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，定义了一个单个主机和一组主机。通过在`inventory`文件中定义一个以`[ ]`括起来的组名，将主机分组到一个组中。在前面提到的示例中定义了两个组`ocean`和`air`。
- en: 'In the event where you do not have any hosts within your `inventory` file (such
    as in the case of running a playbook locally only), you can add the following
    entry to define localhost like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的`inventory`文件中没有任何主机（例如仅在本地运行playbook的情况下），您可以添加以下条目来定义本地主机，如下所示：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The option exists to define variable for hosts and a group inside of your `inventory`
    file. More information on how to do this and additional inventory details can
    be found on the Ansible website at [http://docs.ansible.com/intro_inventory.html](http://docs.ansible.com/intro_inventory.html).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`inventory`文件中为主机和组定义变量。有关如何执行此操作以及其他清单详细信息，请参阅Ansible网站上的[http://docs.ansible.com/intro_inventory.html](http://docs.ansible.com/intro_inventory.html)。
- en: Dynamic inventory
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态清单
- en: It seemed appropriate since we are automating functions on a cloud platform
    to review yet another great feature of Ansible, which is the ability to dynamically
    capture an inventory of hosts/instances. One of the primary principles of cloud
    is to be able to create instances on demand directly via an API, GUI, CLI, and/or
    through automation code, like Ansible. That basic principle will make relying
    on a static `inventory` file pretty much a useless choice. This is why you will
    need to rely heavily on dynamic inventory.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在自动化云平台上的功能，因此审查Ansible的另一个很棒的功能似乎是合适的，即动态捕获主机/实例清单的能力。云的主要原则之一是能够通过API、GUI、CLI和/或通过自动化代码（如Ansible）直接按需创建实例。这个基本原则将使依赖静态`inventory`文件几乎成为一个无用的选择。这就是为什么您需要大量依赖动态清单。
- en: A dynamic inventory script can be created to pull information from your cloud
    at runtime and then, in turn, use that information for the playbooks execution.
    Ansible provides the functionality to detect if an `inventory` file is set as
    an executable and if so will execute the script to pull current time inventory
    data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建动态清单脚本，以在运行时从云中提取信息，然后再利用这些信息执行playbooks。Ansible提供了功能来检测`inventory`文件是否设置为可执行文件，如果是，将执行脚本以获取当前时间的清单数据。
- en: Since creating an Ansible dynamic inventory script is considered more of an
    advanced activity, I am going to direct you to the Ansible website, ([http://docs.ansible.com/intro_dynamic_inventory.html](http://docs.ansible.com/intro_dynamic_inventory.html)),
    as they have a few working examples of dynamic inventory scripts there.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建Ansible动态清单脚本被认为是更高级的活动，我将引导您到Ansible网站（[http://docs.ansible.com/intro_dynamic_inventory.html](http://docs.ansible.com/intro_dynamic_inventory.html)），因为他们在那里有一些动态清单脚本的工作示例。
- en: Fortunately, in our case, we will be reviewing an OpenStack cloud built using
    the **openstack-ansible** (**OSA**) repository. OSA comes with a prebuilt dynamic
    inventory script that will work for your OpenStack cloud. That script is named
    `dynamic_inventory.py` and can be found within the `playbooks/inventory` directory
    located in the `root OSA deployment` folder. In the follwoing chapters, you will
    see working examples of how to leverage this dynamic `inventory` file. A simple
    example of how to use the dynamic `inventory` file is given later.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在我们的情况下，我们将审查使用**openstack-ansible**（**OSA**）存储库构建的OpenStack云。OSA带有一个预构建的动态清单脚本，可用于您的OpenStack云。该脚本名为`dynamic_inventory.py`，可以在位于`root
    OSA deployment`文件夹中的`playbooks/inventory`目录中找到。在接下来的章节中，您将看到如何利用这个动态`inventory`文件的工作示例。稍后将给出如何使用动态`inventory`文件的简单示例。
- en: 'First, execute the dynamic `inventory` script manually to become familiar with
    the data structure and group names defined (this example assumes that you are
    in the `root OSA deployment` directory):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，手动执行动态`inventory`脚本，以熟悉数据结构和定义的组名（假设您在`root OSA deployment`目录中）：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will print to the screen an output similar to this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在屏幕上打印类似于以下内容的输出：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, with this information, you now know that if you wanted to run a playbook
    against the utility container, all you would have to do is execute the playbook
    like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，有了这些信息，现在您知道，如果要针对实用程序容器运行playbook，您只需执行以下命令即可：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this section, we will cover two new features added to version 2.0 of Ansible.
    Both features add additional functionality to how tasks are grouped or executed
    within a playbook. So far, they seem to be really nice features when creating
    more complex automation code. We will now briefly review each of the two new features.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍Ansible 2.0版本中添加的两个新功能。这两个功能都为playbook中的任务分组或执行添加了额外的功能。到目前为止，在创建更复杂的自动化代码时，它们似乎是非常好的功能。现在我们将简要回顾这两个新功能。
- en: Blocks
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blocks
- en: 'The Block feature can simply be explained as a way of logically grouping tasks
    together with the option of also applying customized error handling. It gives
    the option to group a set of tasks together, establishing specific conditions
    and privileges. An example of applying the Block functionality to an earlier example
    can be found here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 块功能可以简单地解释为一种逻辑上将任务组合在一起并应用自定义错误处理的方法。它提供了将一组任务组合在一起的选项，建立特定的条件和特权。可以在此处找到将块功能应用于前面示例的示例：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Additional details on how to implement Blocks and any associated error handling
    can be found at [http://docs.ansible.com/ansible/playbooks_blocks.html](http://docs.ansible.com/ansible/playbooks_blocks.html).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何实现Blocks和任何相关错误处理的更多详细信息，请参阅[http://docs.ansible.com/ansible/playbooks_blocks.html](http://docs.ansible.com/ansible/playbooks_blocks.html)。
- en: Strategies
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略
- en: The **strategy** feature allows you to add control on how a play is executed
    by the hosts. Currently, the default behavior is described as being the linear
    strategy, where all hosts will execute each task before any host moves on to the
    next task. As of today, the two other strategy types that exist are free and debug.
    Since Strategies are implemented as a new type of plugin to Ansible, more can
    be easily added by contributing code. Additional details on Strategies can be
    found at [http://docs.ansible.com/ansible/playbooks_strategies.html](http://docs.ansible.com/ansible/playbooks_strategies.html).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**策略**功能允许您控制主机执行play的方式。目前，默认行为被描述为线性策略，即所有主机在移动到下一个任务之前都会执行每个任务。截至今天，存在的另外两种策略类型是free和debug。由于策略被实现为Ansible的一种新类型插件，可以通过贡献代码轻松地添加更多策略。有关策略的更多详细信息可以在[http://docs.ansible.com/ansible/playbooks_strategies.html](http://docs.ansible.com/ansible/playbooks_strategies.html)找到。'
- en: 'A simple example of implementing a strategy within a playbook is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在playbook中实施策略的一个简单示例如下：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The new debug strategy is extremely helpful when you need to step through your
    playbook/role to find something like a missing variable, determine what variable
    value to supply, or figure out why it may be sporadically failing. These are just
    a few of the possible use cases. Definitely I encourage you to give this feature
    a try. Here is the URL to more details on the playbook debugger: [http://docs.ansible.com/ansible/playbooks_debugger.html](http://docs.ansible.com/ansible/playbooks_debugger.html).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要逐步执行playbook/role以查找诸如缺少的变量、确定要提供的变量值或找出为什么可能会偶尔失败等内容时，新的调试策略非常有帮助。这些只是一些可能的用例。我绝对鼓励您尝试这个功能。以下是有关playbook调试器的更多详细信息的URL：[http://docs.ansible.com/ansible/playbooks_debugger.html](http://docs.ansible.com/ansible/playbooks_debugger.html)。
- en: Cloud integrations
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云集成
- en: Since cloud automation is the main and most important theme of this book, it
    only makes sense that we highlight the many different cloud integrations Ansible
    2.0 offers right out of the box. Again, this was one of the reasons why I immediately
    fell in love with Ansible. Yes, the other automation tools also have hooks into
    many of the cloud providers, but I found at times they did not work or were not
    mature enough to leverage. Ansible has gone above and beyond to not fall into
    that trap. Not saying Ansible has all the bases covered, it does feel like most
    are and that is what matters most to me.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于云自动化是本书的主题和最重要的内容，因此突出显示Ansible 2.0提供的许多不同的云集成是合理的。这也是我立即爱上Ansible的原因之一。是的，其他自动化工具也可以与许多云提供商进行集成，但我发现有时它们无法正常工作或者不够成熟。Ansible已经超越了这个陷阱。并不是说Ansible已经覆盖了所有方面，但它确实感觉大多数都覆盖了，这对我来说最重要。
- en: If you have not checked out the cloud modules available for Ansible, take a
    moment now and take a look at [http://docs.ansible.com/ansible/list_of_cloud_modules.html](http://docs.ansible.com/ansible/list_of_cloud_modules.html).
    From time to time check back, as I am confident that you will be surprised to
    find more have been added. I am very proud of my Ansible family for keeping on
    top of these and making it much easier to write automation code against our clouds.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未查看Ansible可用的云模块，请立即花点时间查看[http://docs.ansible.com/ansible/list_of_cloud_modules.html](http://docs.ansible.com/ansible/list_of_cloud_modules.html)。不时地回来查看，我相信您会惊讶地发现更多的模块已经添加进来了。我为我的Ansible团队感到非常自豪，他们一直在跟进这些模块，并且让编写自动化代码更加容易。
- en: Specific to OpenStack, a bunch of new modules have been added to the Ansible
    library as of version 2.0\. The extensive list can be found at [http://docs.ansible.com/ansible/list_of_cloud_modules.html#openstack](http://docs.ansible.com/ansible/list_of_cloud_modules.html#openstack).
    You will note that the biggest changes, from the first version of this book to
    this one, will be focused on using as many of the new OpenStack modules when possible.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 特别针对OpenStack，在2.0版本中已经添加了大量新的模块到Ansible库。详细列表可以在[http://docs.ansible.com/ansible/list_of_cloud_modules.html#openstack](http://docs.ansible.com/ansible/list_of_cloud_modules.html#openstack)找到。您会注意到，从本书的第一个版本到现在，最大的变化将集中在尽可能多地使用新的OpenStack模块上。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Let's pause here on exploring the dynamic `inventory` script capabilities and
    continue to build upon it as we dissect the working examples in the following chapters.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在探索动态`inventory`脚本功能方面暂停一下，并在接下来的章节中继续构建。
- en: Personally, I am very excited to move to the next chapter where we will create
    our very first OpenStack administration playbook together. We will start off with
    a fairly simple task of creating users and tenants. This will also include reviewing
    a few automation considerations that you will need to keep in mind when creating
    automation code for OpenStack. Ready? Ok, let's get started!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我非常期待进入下一章，我们将一起创建我们的第一个OpenStack管理playbook。我们将从一个相当简单的任务开始，即创建用户和租户。这还将包括审查在为OpenStack创建自动化代码时需要牢记的一些自动化考虑。准备好了吗？好的，让我们开始吧！
