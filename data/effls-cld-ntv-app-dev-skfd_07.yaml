- en: '[*Chapter 5*](B17385_05_Final_PD_ePub.xhtml#_idTextAnchor052): Installing Skaffold
    and Demystifying Its Pipeline Stages'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第5章*](B17385_05_Final_PD_ePub.xhtml#_idTextAnchor052)：安装Skaffold并揭秘其流水线阶段'
- en: In the previous chapter, we took a deep dive into Skaffold's architecture and
    workflow. We also looked at Skaffold's configuration. This chapter will cover
    how to install Skaffold on different operating systems, such as Linux, Windows,
    and macOS. We will also explore common CLI commands and how to use these commands
    in Skaffold's different pipeline stages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们深入了解了Skaffold的架构和工作流程。我们还看了Skaffold的配置。本章将介绍如何在不同操作系统上安装Skaffold，如Linux、Windows和macOS。我们还将探讨常见的CLI命令以及如何在Skaffold的不同流水线阶段中使用这些命令。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要主题：
- en: Installing Skaffold
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Skaffold
- en: Understanding common CLI commands
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解常见的CLI命令
- en: Understanding Skaffold's pipeline stages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Skaffold的流水线阶段
- en: Debugging with Skaffold
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Skaffold进行调试
- en: By the end of this chapter, you will know how to install Skaffold on different
    platforms. You will also gain a solid understanding of the most used CLI commands
    for Skaffold.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解如何在不同平台上安装Skaffold。您还将对Skaffold最常用的CLI命令有扎实的理解。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples of this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟着本章的示例进行操作，您需要以下内容：
- en: The Skaffold CLI ([https://skaffold.dev/docs/install/](https://skaffold.dev/docs/install/))
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Skaffold CLI ([https://skaffold.dev/docs/install/](https://skaffold.dev/docs/install/))
- en: minikube ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
    or Docker Desktop for macOS and Windows ([https://www.docker.com/products/dockerdesktop](https://www.docker.com/products/dockerdesktop))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: minikube ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
    或者macOS和Windows上的Docker Desktop ([https://www.docker.com/products/dockerdesktop](https://www.docker.com/products/dockerdesktop))
- en: Installing Skaffold
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Skaffold
- en: 'Skaffold, being a CLI tool, needs to be downloaded and installed first on your
    favorite operating system. The following are the supported platforms where you
    can download and install Skaffold:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold作为一个CLI工具，需要首先在您喜欢的操作系统上下载和安装。以下是支持的平台，您可以在这些平台上下载和安装Skaffold：
- en: Linux
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux
- en: macOS
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS
- en: Windows
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows
- en: Docker
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Google Cloud SDK
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud SDK
- en: Let's discuss these options in detail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论这些选项。
- en: Installing Skaffold on Linux
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Linux上安装Skaffold
- en: 'For Linux, you can use the following URLs to download the latest stable release
    of Skaffold:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux，您可以使用以下URL来下载最新的稳定版本Skaffold：
- en: '[https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-amd64](https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-amd64)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-amd64](https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-amd64)'
- en: '[https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-arm64](https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-arm64)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-arm64](https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-arm64)'
- en: After downloading the binary, you can add it to your `PATH` variable. Alternatively,
    you can use the following commands.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下载二进制文件后，您可以将其添加到`PATH`变量中。或者，您可以使用以下命令。
- en: 'For Linux on AMD64, use the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AMD64上的Linux，请使用以下命令：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For Linux on ARM64, use the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ARM64上的Linux，请使用以下命令：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is also a bleeding-edge version of Skaffold, which is built with the latest
    commit. It may not be a stable version, so be careful while working with it. You
    can use the following URLs to download the bleeding edge version of Skaffold.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个最新版本的Skaffold，它是使用最新提交构建的。它可能不是一个稳定的版本，所以在使用时要小心。您可以使用以下URL来下载最新版本的Skaffold。
- en: 'For Linux on AMD64, do the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AMD64上的Linux，请执行以下操作：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For Linux on ARM64, do the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ARM64架构的Linux，请执行以下操作：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this section, we looked at the commands for installing Skaffold on the Linux
    **operating system** (**OS**).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们查看了在Linux操作系统（OS）上安装Skaffold的命令。
- en: Installing Skaffold on macOS
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在macOS上安装Skaffold
- en: 'For macOS, you can use the following URLs to download the latest stable release
    of Skaffold:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于macOS，您可以使用以下URL下载Skaffold的最新稳定版本：
- en: '[https://storage.googleapis.com/skaffold/releases/latest/skaffold-darwin-amd64](https://storage.googleapis.com/skaffold/releases/latest/skaffold-darwin-amd64)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://storage.googleapis.com/skaffold/releases/latest/skaffold-darwin-amd64](https://storage.googleapis.com/skaffold/releases/latest/skaffold-darwin-amd64)'
- en: '[https://storage.googleapis.com/skaffold/releases/latest/skaffold-darwin-arm64](https://storage.googleapis.com/skaffold/releases/latest/skaffold-darwin-arm64)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://storage.googleapis.com/skaffold/releases/latest/skaffold-darwin-arm64](https://storage.googleapis.com/skaffold/releases/latest/skaffold-darwin-arm64)'
- en: After downloading the binary, you can add it to your `PATH` variable. Alternatively,
    you can use the following commands.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下载二进制文件后，您可以将其添加到`PATH`变量中。或者，您可以使用以下命令。
- en: 'For macOS on AMD64, use the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AMD64架构的macOS，请使用以下命令：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For macOS on ARM64, use the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ARM64架构的macOS，请使用以下命令：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To download the build with the latest commit, you can use the following commands.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载具有最新提交的构建，可以使用以下命令。
- en: 'For macOS on AMD64, use the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AMD64架构的macOS，请使用以下命令：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For macOS on ARM64, use the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ARM64架构的macOS，请使用以下命令：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For macOS specifically, you can download Skaffold using the following package
    managers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是对于macOS，您可以使用以下软件包管理器下载Skaffold。
- en: 'For Homebrew, use the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Homebrew，请使用以下命令：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For MacPorts, use the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MacPorts，请使用以下命令：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this section, we explored various commands for installing Skaffold on macOS.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了在macOS上安装Skaffold的各种命令。
- en: Installing Skaffold on Windows
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Windows上安装Skaffold
- en: 'For Windows, you can use the following URL to download the latest stable release
    of Skaffold:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows，您可以使用以下URL下载Skaffold的最新稳定版本：
- en: '[https://storage.googleapis.com/skaffold/releases/latest/skaffold-windows-amd64.exe](https://storage.googleapis.com/skaffold/releases/latest/skaffold-windows-amd64.exe)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://storage.googleapis.com/skaffold/releases/latest/skaffold-windows-amd64.exe](https://storage.googleapis.com/skaffold/releases/latest/skaffold-windows-amd64.exe)'
- en: After downloading the EXE file, you can add it to your `PATH` variable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下载EXE文件后，您可以将其添加到`PATH`变量中。
- en: 'To download the build with the latest commit, you can use the following URL:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载具有最新提交的构建，可以使用以下URL：
- en: '[https://storage.googleapis.com/skaffold/builds/latest/skaffold-windows-amd64.exe](https://storage.googleapis.com/skaffold/builds/latest/skaffold-windows-amd64.exe)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://storage.googleapis.com/skaffold/builds/latest/skaffold-windows-amd64.exe](https://storage.googleapis.com/skaffold/builds/latest/skaffold-windows-amd64.exe)'
- en: 'For Windows specifically, you can download Skaffold using the following Chocolatey
    package manager command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是对于Windows，您可以使用以下Chocolatey软件包管理器命令下载Skaffold：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Figure 5.1 – Installing Skaffold on Windows'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 - 在Windows上安装Skaffold'
- en: '](image/B17385_Figure_5.1.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B17385_Figure_5.1.jpg)'
- en: Figure 5.1 – Installing Skaffold on Windows
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 - 在Windows上安装Skaffold
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is a known issue (https://github.com/chocolatey/shimgen/issues/32) with
    the `skaffold dev` command where Skaffold doesn't clean up deployments when you
    press *Ctrl* + *C* on Windows when installed with Chocolatey package manager.
    The problem is not related to Skaffold but how Chocolatey interferes with *Ctrl*
    + *C* handling during installation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`skaffold dev`命令存在已知问题（https://github.com/chocolatey/shimgen/issues/32），在Windows上使用Chocolatey软件包管理器安装时，按下*Ctrl*
    + *C*时Skaffold不会清理部署。问题与Skaffold无关，而是与Chocolatey在安装过程中如何干扰*Ctrl* + *C*处理有关。'
- en: This section covered how to install Skaffold on Windows.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了如何在Windows上安装Skaffold。
- en: Installing Skaffold using Docker
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Docker安装Skaffold
- en: 'You can also download and run Skaffold inside a Docker container. To do that,
    you can use the following `docker run` command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以下载并在Docker容器中运行Skaffold。要做到这一点，您可以使用以下`docker run`命令：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To work with an edge build with the latest commit, you can use the following
    command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用最新提交的边缘构建，您可以使用以下命令：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I want to highlight one point regarding using a docker image for Skaffold.
    The Docker image''s size is around ~3.83 GB, and this seems ridiculously large
    for Skaffold since in [*Chapter 3*](B17385_03_Final_PD_ePub.xhtml#_idTextAnchor034),
    *Skaffold – Easy-Peasy Cloud-Native Kubernetes Application Development*, we learned
    that Skaffold''s binary size is around ~63 MB. This can be seen in the following
    screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调一个关于使用Docker图像的Skaffold的要点。 Docker图像的大小约为~3.83 GB，这对于Skaffold来说似乎过大，因为在[*第3章*](B17385_03_Final_PD_ePub.xhtml#_idTextAnchor034)中，*Skaffold
    – Easy-Peasy Cloud-Native Kubernetes Application Development*，我们了解到Skaffold的二进制大小约为~63
    MB。这可以在以下截图中看到：
- en: '![Figure 5.2 – Skaffold Docker image size'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 – Skaffold Docker图像大小'
- en: '](image/B17385_Figure_5.2.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B17385_Figure_5.2.jpg)'
- en: Figure 5.2 – Skaffold Docker image size
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – Skaffold Docker图像大小
- en: So, why is the image size so large? This is because the image contains other
    tools as well, such as the gcloud SDK, kind, minikube, k3d, kompose, and bazel,
    to name a few.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么图像大小如此之大？这是因为图像还包含其他工具，如gcloud SDK，kind，minikube，k3d，kompose和bazel等。
- en: You can verify what's inside your container image using the Dive CLI.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Dive CLI验证容器图像中的内容。
- en: Tip
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Dive allows you to check your image layer's contents and suggest different ways
    to shrink your image's size if you are wasting any space.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Dive允许您检查图像层的内容，并建议不同的方法来缩小图像的大小，如果您浪费了任何空间。
- en: 'You can download Dive by following the instructions at [https://github.com/wagoodman/dive#installation](https://github.com/wagoodman/dive#installation).
    Run the following command to get an inside view of your container image:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照[https://github.com/wagoodman/dive#installation](https://github.com/wagoodman/dive#installation)上的说明下载Dive。运行以下命令以查看容器图像的内部视图：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is the output for the Skaffold docker image, which contains an
    image layer:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Skaffold docker图像的输出，其中包含一个图像层：
- en: '![Figure 5.3 – Skaffold Docker image layers'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – Skaffold Docker图像层'
- en: '](image/B17385_Figure_5.3.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B17385_Figure_5.3.jpg)'
- en: Figure 5.3 – Skaffold Docker image layers
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – Skaffold Docker图像层
- en: As you can see from the layers inside the image, we have many tools available,
    not just Skaffold. Another advantage of using this Docker image is that you don't
    have to install these tools separately, and you can use the same image to play
    or experiment with these tools.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从图像内部的层可以看出，我们有许多可用的工具，而不仅仅是Skaffold。使用此Docker图像的另一个优势是，您不必单独安装这些工具，而且可以使用相同的图像来玩耍或尝试这些工具。
- en: This section covered how to install Skaffold using a Docker image.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了如何使用Docker图像安装Skaffold。
- en: Installing Skaffold using gcloud
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用gcloud安装Skaffold
- en: Google developed Skaffold, so it nicely fits into the Google products ecosystem.
    If you have **Google's Cloud SDK** installed on your machine, you can use the
    `gcloud components install skaffold` command to install Skaffold.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Google开发了Skaffold，因此它很好地适应了Google产品生态系统。如果您的机器上安装了**Google的Cloud SDK**，您可以使用`gcloud
    components install skaffold`命令来安装Skaffold。
- en: 'We will cover how to install the gcloud SDK in [*Chapter 8*](B17385_08_Final_PD_ePub.xhtml#_idTextAnchor099),
    *Deploying a Spring Boot Application to Google Kubernetes Engine Using Skaffold*.
    For now, we can assume that the Cloud SDK is already installed. You can view the
    installed and not installed components using the `gcloud list` command. The following
    is the output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第8章*](B17385_08_Final_PD_ePub.xhtml#_idTextAnchor099)中介绍如何安装gcloud SDK，*使用Skaffold将Spring
    Boot应用部署到Google Kubernetes Engine*。目前，我们可以假设Cloud SDK已经安装。您可以使用`gcloud list`命令查看已安装和未安装的组件。以下是输出：
- en: '![Figure 5.4 – gcloud list command output'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4 – gcloud list命令输出'
- en: '](image/B17385_Figure_5.4.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B17385_Figure_5.4.jpg)'
- en: Figure 5.4 – gcloud list command output
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – gcloud list命令输出
- en: 'From the preceding output, it is clear that Skaffold is not installed. It is
    not mandatory but before we move on to the installation, make sure that `gcloud`
    has been installed and that its components are up to date. We can run the following
    command to do this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出可以清楚地看出，Skaffold未安装。虽然这不是强制性的，但在我们继续安装之前，请确保已安装`gcloud`并且其组件是最新的。我们可以运行以下命令来执行此操作：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we can install Skaffold using the following `gcloud` command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用以下`gcloud`命令安装Skaffold：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is the output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Figure 5.5 – Installing Skaffold via gcloud'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5 – 通过gcloud安装Skaffold'
- en: '](image/B17385_Figure_5.5.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B17385_Figure_5.5.jpg)'
- en: Figure 5.5 – Installing Skaffold via gcloud
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 通过gcloud安装Skaffold
- en: In this section, we discussed different ways to install Skaffold. Now, let's
    discuss the Skaffold CLI commands.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了安装Skaffold的不同方法。现在，让我们讨论Skaffold CLI命令。
- en: Understanding common CLI commands
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解常见的CLI命令
- en: 'So far, we have introduced you to commands such as `skaffold dev` and `skaffold
    run`, but there are many such commands that you can use to either create an end-to-end
    pipeline or use individually in your CI/CD pipelines. We will categorize these
    commands into the following sections. You can also discover the supported options
    for these commands by enabling the `skaffold completion bash/zsh` command and
    pressing *Tab* after entering the command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经向您介绍了诸如`skaffold dev`和`skaffold run`之类的命令，但是还有许多类似的命令，您可以在CI/CD流水线中使用这些命令来创建端到端的流水线或单独使用。我们将把这些命令分类如下。您还可以通过启用`skaffold
    completion bash/zsh`命令并在输入命令后按*Tab*键来发现这些命令的支持选项：
- en: '**Commands for end-to-end pipelines**:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端流水线的命令**：'
- en: '`skaffold run`: This command allows you to build and deploy once.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffold run`：此命令允许您构建和部署一次。'
- en: '`skaffold dev`: This command allows you to trigger the continuous development
    loop for build and deploy. This workflow will clean up on exit.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffold dev`：此命令允许您触发用于构建和部署的持续开发循环。此工作流将在退出时清理。'
- en: '`skaffold debug`: This command allows you to trigger the continuous development
    loop for build and deploy pipelines *in debug mode*. This workflow will also clean
    up on exit.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffold debug`：此命令允许您以*调试模式*触发用于构建和部署流水线的持续开发循环。此工作流也将在退出时清理。'
- en: '**Commands for CI/CD pipelines**:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI/CD流水线的命令**：'
- en: '`skaffold build`: This command allows you to just build, tag, and push your
    image(s).'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffold build`：此命令允许您只构建、标记和推送您的镜像。'
- en: '`skaffold test`: This command allows you to run tests against your built application
    images.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffold test`：此命令允许您针对构建的应用程序镜像运行测试。'
- en: '`skaffold deploy`: This command allows you to deploy the given image(s).'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffold deploy`：此命令允许您部署给定的镜像。'
- en: '`skaffold delete`: This command allows you to clean up the deployed artifacts.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffold delete`：此命令允许您清理已部署的构件。'
- en: '`skaffold render`: This command allows you to build your application images
    and then export the hydrated (with a newly built image tag) Kubernetes manifests
    to a file or terminal.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffold render`：此命令允许您构建应用程序映像，然后将经过填充（使用新构建的映像标签）的Kubernetes清单导出到文件或终端。'
- en: '`skaffold apply`: This command takes templated Kubernetes manifests as input
    and creates resources on the target cluster.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffold apply`：此命令以模板化的Kubernetes清单作为输入，在目标集群上创建资源。'
- en: '**Commands for getting started**:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入门命令**：'
- en: '`skaffod init`: This command allows you to bootstrap the Skaffold config.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffod init`：此命令允许您引导Skaffold配置。'
- en: '`skaffold fix`: This command allows you to upgrade the schema version.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffold fix`：此命令允许您升级模式版本。'
- en: '**Miscellaneous commands**:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他命令**：'
- en: '`skaffold help`: This command allows you to print help. Use `skaffold options`
    to get a list of global command-line options (this applies to all commands).'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffold help`：此命令允许您打印帮助信息。使用`skaffold options`获取全局命令行选项的列表（适用于所有命令）。'
- en: '`skaffold version`: This command allows you to get Skaffold''s version.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffold version`：此命令允许您获取Skaffold的版本。'
- en: '`skaffold completion`: This command allows you to set up tab completion for
    the CLI. It supports the same options as `skaffold version`.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffold completion`：此命令允许您为CLI设置选项卡完成。它支持与`skaffold version`相同的选项。'
- en: '`skaffold config`: This command allows you to manage context-specific parameters.
    It supports the same options as `skaffold version`.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffold config`：此命令允许您管理特定上下文的参数。它支持与`skaffold version`相同的选项。'
- en: '`skaffold credits`: This command allows you to export third-party notices to
    a given path (`./skaffold-credits` by default). It supports the same options as
    `skaffold version`.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffold credits`：此命令允许您将第三方通知导出到指定路径（默认为`./skaffold-credits`）。它支持与`skaffold
    version`相同的选项。'
- en: '`skaffold diagnose`: This command allows you to run diagnostics of Skaffold
    works in your project.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffold diagnose`：此命令允许您运行对Skaffold在您的项目中的诊断。'
- en: '`skaffold schema`: This command allows you to list and print JSON schemas used
    to validate `skaffold.yaml` configuration. It supports the same options as `skaffold
    version`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skaffold schema`：此命令允许您列出并打印用于验证`skaffold.yaml`配置的JSON模式。它支持与`skaffold version`相同的选项。'
- en: In this section, we talked about Skaffold commands and their usage. In the next
    section, we will try to understand Skaffold's different pipeline stages.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了Skaffold命令及其用法。在下一节中，我们将尝试了解Skaffold的不同流水线阶段。
- en: Understanding Skaffold pipeline stages
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Skaffold流水线阶段
- en: So far, we have built a basic understanding of how Skaffold works. From the
    previous chapters, we know that it picks source code changes in your project and
    creates container images with the tool of your choice; the images, once successfully
    built, are tagged as you see fit and pushed to the repository you specify. Skaffold
    also helps you deploy the artifacts to your Kubernetes cluster at the end of the
    workflow, once again using the tools you prefer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对Skaffold的工作原理有了基本的了解。从前面的章节中，我们知道它会选择项目中的源代码更改，并使用您选择的工具创建容器映像；一旦成功构建，这些映像将根据您的要求进行标记，并推送到您指定的存储库。Skaffold还可以帮助您在工作流程结束时将这些构件部署到您的Kubernetes集群中，再次使用您喜欢的工具。
- en: Skaffold permits you to skip stages. If, for example, you run Kubernetes locally
    with Minikube or Docker desktop, Skaffold is smart enough to make that choice
    for you and will not push artifacts to a remote repository.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold允许您跳过阶段。例如，如果您在本地使用Minikube或Docker桌面运行Kubernetes，Skaffold足够智能，会为您做出选择，并不会将构件推送到远程存储库。
- en: 'Let''s look at Skaffold''s pipeline stages in detail to understand what other
    choices we have in each pipeline stage. Skaffold pipeline stages can be broadly
    classified into the following areas:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解Skaffold的流水线阶段，以了解每个流水线阶段中我们还有哪些选择。Skaffold流水线阶段可以大致分为以下几个领域：
- en: Init
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化
- en: Build
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建
- en: Tag
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签
- en: Test
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Deploy
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署
- en: File
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件
- en: Log tailing
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志尾随
- en: Port forwarding
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口转发
- en: Cleanup
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理
- en: Let's discuss each in detail.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论每个。
- en: Init stage
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化阶段
- en: In this stage, we typically generate a basic Skaffold configuration file to
    get your project up and running in seconds. Skaffold looks at your project directory
    for any build configuration files, such as `Dockerfile`, `build.gradle`, and `pom.xml`,
    and then auto-generates a build and deploy config.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们通常会生成一个基本的Skaffold配置文件，以便在几秒钟内启动和运行您的项目。Skaffold会查看您的项目目录中是否有任何构建配置文件，比如`Dockerfile`、`build.gradle`和`pom.xml`，然后自动生成构建和部署配置。
- en: 'Skaffold currently supports build detection for the following builders:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold目前支持以下构建工具的构建检测：
- en: Docker
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Jib
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jib
- en: Buildpacks
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buildpacks
- en: If Skaffold detects multiple build configuration files, it will prompt you to
    pair your build configuration files with any images that have been detected in
    your deploy configuration.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Skaffold检测到多个构建配置文件，它将提示您将构建配置文件与在部署配置中检测到的任何镜像配对。
- en: Tip
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Starting with Skaffold v1.27.0, you no longer have to provide the `XXenableJibInit`
    or `XXenableBuildpacksInit` flag with the `skaffold init` command as their default
    values are set to `true`. This also means that the `init` command will detect
    if you should use Jib or Buildpacks based upon your project, without the need
    to specify these flags.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从Skaffold v1.27.0开始，您不再需要在`skaffold init`命令中提供`XXenableJibInit`或`XXenableBuildpacksInit`标志，因为它们的默认值已设置为`true`。这也意味着`init`命令将检测您是否应该根据项目使用Jib或Buildpacks，无需指定这些标志。
- en: 'For example, you might be asked to choose from the following after you run
    the `skaffold init` command. In this example, we have a `Dockerfile` in the root
    directory, so Skaffold is asking you to choose the build configuration for this
    project:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在运行`skaffold init`命令后，您可能会被要求从以下选项中选择。在这个例子中，我们在根目录中有一个`Dockerfile`，所以Skaffold要求您选择此项目的构建配置：
- en: '![Figure 5.6 – skaffold init prompt'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6 – skaffold init提示'
- en: '](image/B17385_Figure_5.6.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B17385_Figure_5.6.jpg)'
- en: Figure 5.6 – skaffold init prompt
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – skaffold init提示
- en: 'Similarly, for deployment, Skaffold will look at your project directory and
    if it detects some Kubernetes manifests – that is, `deployment.yaml` or `sevice.yaml`
    – is already present, then it will automatically add those to the `deploy` section
    of the `skaffold.yaml` file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于部署，Skaffold将查看您的项目目录，如果检测到一些Kubernetes清单 – 即`deployment.yaml`或`sevice.yaml`
    – 已经存在，那么它将自动将它们添加到`skaffold.yaml`文件的`deploy`部分：
- en: '![Figure 5.7 – Generating a Skaffold configuration file'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7 – 生成Skaffold配置文件'
- en: '](image/B17385_Figure_5.7.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B17385_Figure_5.7.jpg)'
- en: Figure 5.7 – Generating a Skaffold configuration file
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 生成Skaffold配置文件
- en: If you don't have the manifests ready but want Skaffold to handle the manifest
    generation part, then don't worry – you can pass the `--generate-manifests` flag
    with the `skaffold init` command.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有准备好清单，但希望Skaffold处理清单生成部分，那么不用担心 – 您可以在`skaffold init`命令中传递`--generate-manifests`标志。
- en: Build stage
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建阶段
- en: Skaffold supports various tools for image building.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold支持各种工具进行镜像构建。
- en: 'From the following table, you can understand that image building can be done
    locally, in a cluster, or using Google Cloud Build remotely:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从下表中，您可以了解到镜像构建可以在本地、集群中或远程使用Google Cloud Build进行：
- en: '![Table 5.1– Skaffold supported container image builders'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![表5.1– Skaffold支持的容器镜像构建工具'
- en: '](image/B17385_Figure_5.8.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B17385_Figure_5.8.jpg)'
- en: Table 5.1– Skaffold supported container image builders
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1– Skaffold支持的容器镜像构建器
- en: We will learn more about these options in [*Chapter 6*](B17385_06_PreFinal_PD_ePub.xhtml#_idTextAnchor074),
    *Working with Skaffold Container Image Builders and Deployers*. In a cluster,
    builds are supported by kaniko or using a custom script. Remote builds are only
    supported for Dockerfile, Jib, and Buildpacks using Cloud Build. For a local build,
    you can pretty much use any of the supported image building methods.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第6章*](B17385_06_PreFinal_PD_ePub.xhtml#_idTextAnchor074)中了解更多关于这些选项的内容，*使用Skaffold容器镜像构建器和部署器*。在集群中，构建由kaniko或使用自定义脚本支持。远程构建仅支持使用Cloud
    Build的Dockerfile、Jib和Buildpacks。对于本地构建，您几乎可以使用任何受支持的图像构建方法。
- en: 'You can set a build configuration through the `build` section of the `skaffold.yaml`
    file. The following is an example of this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`skaffold.yaml`文件的`build`部分设置构建配置。以下是一个示例：
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we have covered the build stage, next, we will take a look at the tag
    stage.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了构建阶段，接下来，我们将看一下标记阶段。
- en: Tag stage
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记阶段
- en: 'Skaffold supports the following image tagging strategies:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold支持以下图像标记策略：
- en: Tagging is available through `the gitCommit tagger`, which utilizes Git commits
    to tag images.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记可通过`gitCommit标记器`进行，它利用Git提交来标记图像。
- en: Tagging is available through `the sha256 tagger`, which uses the latest tag
    to tag images.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记可通过`sha256标记器`进行，该标记器使用最新标记来标记图像。
- en: Tagging is available through `the envTemplate tagger`, which uses **Environment
    Variables** to tag images.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记可通过`envTemplate标记器`进行，它使用**环境变量**来标记图像。
- en: Tagging is available through `the dateTime tagger`, which accepts the current
    **Date and Time** with a configurable pattern.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记可通过`dateTime标记器`进行，它接受当前的**日期和时间**以及可配置的模式。
- en: Tagging is available through `the customTemplate tagger`, which uses a combination
    of the existing taggers as components in a template.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记可通过`customTemplate标记器`进行，它使用现有标记器作为模板的组件组合。
- en: 'An image tagging strategy can be configured using the `tagPolicy` field in
    the `build` section of `skaffold.yaml`. If no `tagPolicy` is specified, then the
    default is the `gitCommit` strategy. Please refer to the following code snippet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`skaffold.yaml`的`build`部分中的`tagPolicy`字段来配置图像标记策略。如果未指定`tagPolicy`，则默认为`gitCommit`策略。请参考以下代码片段：
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we know about the different image tagging strategies with Skaffold,
    we will go through the test stage.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了Skaffold的不同图像标记策略，我们将进入测试阶段。
- en: Test stage
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试阶段
- en: Skaffold has an integration testing phase between build and deploy. It supports
    container structure tests and custom tests for integration testing. Let's discuss
    them in detail.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold在构建和部署之间有一个集成测试阶段。它支持容器结构测试和集成测试的自定义测试。让我们详细讨论一下。
- en: Container structure test
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器结构测试
- en: Skaffold provides support for running container structure tests (https://github.com/GoogleContainerTools/container-structure-test)
    on container images we build with Skaffold. The Container Structure Test framework
    primarily aims to verify the contents and structure of the container. For example,
    we may want to run some command inside a container to test whether it gets executed
    successfully or not. We can define tests per image in the Skaffold config. After
    building the artifact, Skaffold will run the associated structure tests on that
    image. If the tests fail, Skaffold will not proceed with the deployment.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold支持在使用Skaffold构建的容器镜像上运行容器结构测试（https://github.com/GoogleContainerTools/container-structure-test）。容器结构测试框架主要旨在验证容器的内容和结构。例如，我们可能想在容器内运行一些命令，以测试它是否成功执行。我们可以在Skaffold配置中为每个图像定义测试。构建完毕后，Skaffold将在该图像上运行相关的结构测试。如果测试失败，Skaffold将不会继续部署。
- en: Custom test
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义测试
- en: With a Skaffold custom test, developers can run custom commands as part of their
    development loop. The custom test will run before deploying the image to the Kubernetes
    cluster. The command will execute on the local machine where Skaffold is being
    executed and works with all supported Skaffold platforms. You can opt out of running
    custom tests by using the `--skip-tests` flag. You can run tests individually
    with the `skaffold test` command.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Skaffold自定义测试，开发人员可以在其开发循环的一部分运行自定义命令。自定义测试将在将镜像部署到Kubernetes集群之前运行。该命令将在执行Skaffold的本地机器上执行，并与所有支持的Skaffold平台一起工作。您可以使用`--skip-tests`标志选择不运行自定义测试。您可以使用`skaffold
    test`命令单独运行测试。
- en: 'The following are some of the use cases for a custom test:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是自定义测试的一些用例：
- en: Running unit tests
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行单元测试
- en: Running validation and security scans on images using GCP Container Analysis
    or Anchore Grype
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GCP Container Analysis或Anchore Grype在图像上运行验证和安全扫描
- en: We can also validate Kubernetes manifests before deployment using tools like
    **kubeval** ([https://github.com/instrumenta/kubeval](https://github.com/instrumenta/kubeval))
    or **kubeconform** ([https://github.com/yannh/kubeconform](https://github.com/yannh/kubeconform)).
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用**kubeval**（[https://github.com/instrumenta/kubeval](https://github.com/instrumenta/kubeval)）或**kubeconform**（[https://github.com/yannh/kubeconform](https://github.com/yannh/kubeconform)）等工具，在部署前验证Kubernetes清单。
- en: In the case of Helm charts, we can use the **helm lint** command before deployment.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Helm图表的情况下，我们可以在部署前使用**helm lint**命令。
- en: 'In the following example, we have a profile named `test` and we are using the
    `mvn test` command to run various tests. We will be using the `skaffold dev --profile=test`
    command here, which runs tests after the build and before deployment:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们有一个名为`test`的配置文件，并且我们正在使用`mvn test`命令运行各种测试。我们将在此处使用`skaffold dev --profile=test`命令，该命令在构建后和部署前运行测试：
- en: '[PRE18]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the logs, you will see the following, which states that the tests have been
    started and that there are no failures:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志中，您将看到以下内容，其中说明测试已经开始，并且没有失败：
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With that, we have learned how we can execute custom tests with Skaffold. In
    the deploy stage, we will learn about deploying an application with Skaffold.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经学会了如何使用Skaffold执行自定义测试。在部署阶段，我们将学习如何使用Skaffold部署应用程序。
- en: Deploy stage
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署阶段
- en: Skaffold deploy stage typically renders the Kubernetes manifests by replacing
    the untagged image names in the Kubernetes manifests with the final tagged image
    names. It also might go through the additional intermediary step of expanding
    templates for helm or calculating overlays for kustomize. Then, Skaffold will
    deploy the final Kubernetes manifests to the cluster. And to make sure the deployment
    happens, ideally, it will wait for the deployed resources to stabilize by doing
    health checks.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold部署阶段通常通过将Kubernetes清单中的未标记的镜像名称替换为最终标记的镜像名称来呈现Kubernetes清单。它还可能通过扩展helm的模板或计算kustomize的叠加来进行额外的中间步骤。然后，Skaffold将最终的Kubernetes清单部署到集群中。为了确保部署发生，理想情况下，它将通过健康检查等待部署的资源稳定。
- en: Health checks are enabled by default and are a great feature for your CI/CD
    pipeline use cases to make sure that deployed resources are healthy and we can
    proceed further in the pipeline. Skaffold internally uses the `kubectl rollout
    status` command to test the status of the deployment.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查默认启用，并且是CI/CD流水线用例的一个重要功能，以确保部署的资源健康，并且可以在流水线中进一步进行。Skaffold内部使用`kubectl
    rollout status`命令来测试部署的状态。
- en: 'For example, in the following logs, you can see that Skaffold waited for the
    deployment to stabilize:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下日志中，您可以看到Skaffold等待部署稳定：
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Skaffold currently supports the following tools for deploying applications
    to local or remote Kubernetes clusters:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold目前支持以下工具，用于将应用程序部署到本地或远程Kubernetes集群：
- en: '`kubectl`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl`'
- en: '`helm`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`helm`'
- en: '`kustomize`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kustomize`'
- en: 'You can set the deploy configuration through the `deploy` section of the `skaffold.yaml`
    file, as shown here:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`skaffold.yaml`文件的`deploy`部分设置部署配置，如下所示：
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With that, we have learned how we can deploy an image to Kubernetes using Skaffold.
    Next, we will explore how to sync changes directly to a pod without rebuilding
    and redeploying an image using file sync.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们学会了如何使用Skaffold将镜像部署到Kubernetes。接下来，我们将探讨如何使用文件同步直接将更改同步到pod，而无需重新构建和重新部署镜像。
- en: File sync
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件同步
- en: Skaffold has a great feature through which it can copy the changed files to
    a deployed container, without the need to rebuild, redeploy, and restart the corresponding
    pod. We can enable this file copying feature by adding a `sync` section with sync
    rules to the artifact in the `skaffold.yaml` file. Internally, Skaffold creates
    a `.tar` file with changed files that match the sync rules we define in the `skaffold.yaml`
    file. Then, this `.tar` file is transferred to and extracted inside the corresponding
    containers.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold具有一个很棒的功能，可以将更改的文件复制到部署的容器中，而无需重新构建、重新部署和重新启动相应的pod。我们可以通过在`skaffold.yaml`文件的构件中添加带有同步规则的`sync`部分来启用此文件复制功能。在内部，Skaffold创建一个包含与我们在`skaffold.yaml`文件中定义的同步规则匹配的更改文件的`.tar`文件。然后，这个`.tar`文件被传输到相应的容器中并在其中解压。
- en: 'Skaffold supports the following types of sync:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold支持以下类型的同步：
- en: '`manual`: In this mode, we need to specify the source file path from the local
    and destination path of the running container.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manual`：在此模式下，我们需要指定本地源文件路径和运行容器的目标路径。'
- en: '`infer`: In this mode, Skaffold will infer the destination path by looking
    at your Dockerfile. Under sync rules, you can specify which files are eligible
    for syncing.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`infer`：在此模式下，Skaffold将通过查看您的Dockerfile来推断目标路径。在同步规则下，您可以指定哪些文件适合同步。'
- en: '`auto`: In this mode, Skaffold will automatically generate sync rules for the
    known file types.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto`：在此模式下，Skaffold将自动生成已知文件类型的同步规则。'
- en: To understand the **file sync** functionality, we will use the Spring Boot application
    that we built in [*Chapter 3*](B17385_03_Final_PD_ePub.xhtml#_idTextAnchor034),
    *Skaffold – Easy-Peasy Cloud-Native Kubernetes Application Development*. The Spring
    Boot application exposes a `/states` REST endpoint that will return all Indian
    states and their capitals. We have added a new profile named sync to the `skaffold.yaml`
    file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解**文件同步**功能，我们将使用我们在[*第3章*](B17385_03_Final_PD_ePub.xhtml#_idTextAnchor034)中构建的Spring
    Boot应用程序，*Skaffold – Easy-Peasy Cloud-Native Kubernetes Application Development*。Spring
    Boot应用程序公开了一个`/states` REST端点，将返回所有印度各邦及其首府。我们在`skaffold.yaml`文件中添加了一个名为sync的新配置文件。
- en: 'In the following `skaffold.yaml` file, we have used `jib` as an image builder.
    Jib integration with Skaffold allows you to auto-sync your class files, resource
    files, and Jib''s extra directories files to a remote container once changes have
    been made. However, it can only be used with Jib in the default build mode (exploded)
    for non-WAR applications because of some limitations. You also need to have the
    Spring Boot Developer Tools dependency in your project for this to work. It will
    also work with any embedded server that can do a reload or restart:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的`skaffold.yaml`文件中，我们使用`jib`作为镜像构建器。Jib与Skaffold集成允许您在更改后自动同步类文件、资源文件和Jib的额外目录文件到远程容器。但是，它只能与Jib一起在默认构建模式（exploded）下用于非WAR应用程序，因为存在一些限制。您还需要在项目中添加Spring
    Boot开发工具依赖项才能使其工作。它还可以与任何能够重新加载或重启的嵌入式服务器一起工作：
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the Spring Boot application, we deliberately made a mistake by changing
    the name of Bengaluru to Bangalore. In the output, you will see the following
    after running the `skaffold dev --profile=sync` command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Boot应用程序中，我们故意将班加罗尔的名称更改为班加罗尔。在运行`skaffold dev --profile=sync`命令后，您将在输出中看到以下内容：
- en: '![Figure 5.8 – Output before sync'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8 - 同步前的输出'
- en: '](image/B17385_Figure_5.9.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B17385_Figure_5.9.jpg)'
- en: Figure 5.8 – Output before sync
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 - 同步前的输出
- en: 'Now, since we have Jib''s auto-sync set to `true`, any changes that are made
    to the `schema.sql` file will be directly synced with the pod running inside the
    Kubernetes cluster. We made changes in the `schema.sql` file, and they were synced
    directly with a running pod by just restarting the application. Here, we don''t
    have to rebuild the image, push the image, redeploy the image, or restart the
    pod. You will see the following output in the streamed logs on your console after
    you make this change:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们将Jib的自动同步设置为`true`，对`schema.sql`文件所做的任何更改都将直接与在Kubernetes集群内运行的pod同步。我们对`schema.sql`文件进行了更改，它们通过重新启动应用程序直接与运行中的pod同步。在这里，我们不必重新构建镜像、推送镜像、重新部署镜像或重新启动pod。在进行此更改后，您将在控制台的流式日志中看到以下输出：
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After hitting the URL again, you will see the changed output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 再次访问URL后，您将看到更改后的输出：
- en: '![Figure 5.9 – Output after sync'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.9 - 同步后的输出'
- en: '](image/B17385_Figure_5.10.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B17385_Figure_5.10.jpg)'
- en: Figure 5.9 – Output after sync
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 - 同步后的输出
- en: '`schema.sql` was under our resources, so let''s see whether, when we make changes
    to a Java class file, those will also be synced. Let''s try it out.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`schema.sql`在我们的资源下，所以让我们看看当我们对Java类文件进行更改时，是否也会被同步。让我们试一试。'
- en: 'To test this, I will tweak the logging statement we have in the `StateController`
    class. We have the following log statement:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我将调整我们在`StateController`类中的日志记录语句。我们有以下日志记录语句：
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will change it to the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其更改为以下内容：
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After making these changes, you should see the following in the streamed logs
    on your console. You might be wondering why five files have been synced since
    we only changed one file. Well, the reason for this is that Jib transferred the
    entire layer, which contains your class file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些更改后，您应该在控制台的流式日志中看到以下内容。您可能会想知道为什么有五个文件被同步，因为我们只改变了一个文件。嗯，原因是Jib传输了整个层，其中包含您的类文件：
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Similarly, in the streamed logs, we will see the changed logging statement:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在流式日志中，我们将看到更改后的日志记录语句。
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With that, we have learned about the direct file sync capabilities of Skaffold.
    Now, let's understand how we can tail logs with various Skaffold commands.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经了解了Skaffold的直接文件同步功能。现在，让我们了解如何使用各种Skaffold命令尾随日志。
- en: Log tailing
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志尾随
- en: Skaffold can tail logs for containers that have been built and deployed by it.
    With this feature, you can tail logs from your cluster to your local machine when
    you execute `skaffold dev`, `skaffold debug`, or `skaffold run`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold可以为其构建和部署的容器尾随日志。有了这个功能，当您执行`skaffold dev`、`skaffold debug`或`skaffold
    run`时，您可以从集群尾随日志到本地机器。
- en: Log tailing is enabled for the `skaffold dev` and `skaffold debug` modes by
    default. For skaffold `run`, you can use the `–tail` flag to explicitly enable
    log tailing.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，skaffold `dev`和`skaffold debug`模式启用了日志尾随。对于skaffold `run`，您可以使用`--tail`标志显式启用日志尾随。
- en: For a typical Spring Boot application, you will see the following in the tail
    logs after you've built and deployed it using `skaffold dev`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于典型的Spring Boot应用程序，您将在使用`skaffold dev`构建和部署后，在尾随日志中看到以下内容。
- en: 'In the following log, you can see that after successfully building and deploying
    to the cluster, the application logs are streamed to the console:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的日志中，您可以看到成功构建并部署到集群后，应用程序日志被流式传输到控制台：
- en: '[PRE28]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: At this point, we know how we can tail logs from a running container with Skaffold.
    Next, let's discuss port forwarding with Skaffold.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们知道了如何使用Skaffold从运行的容器中尾随日志。接下来，让我们讨论Skaffold的端口转发。
- en: Port forwarding
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端口转发
- en: Skaffold supports automatic port forwarding of services and user-defined port
    forwards in dev, debug, deploy, or run mode. You don't have to expose an endpoint
    to access your application. Port forwarding is helpful for local development.
    Skaffold uses `kubectl port-forward` internally to implement port forwarding.
    You can define your custom port forward explicitly in `skaffold.yaml` or pass
    the `--port-forward` flag while running `skaffold dev`, `debug`, `run`, or `deploy`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold支持在开发、调试、部署或运行模式下自动转发服务和用户定义的端口转发。您不必暴露端点来访问您的应用程序。端口转发对于本地开发非常有帮助。Skaffold在内部使用`kubectl
    port-forward`来实现端口转发。您可以在`skaffold.yaml`中明确定义自定义端口转发，或者在运行`skaffold dev`、`debug`、`run`或`deploy`时传递`--port-forward`标志。
- en: 'The following is an example of user-defined port forwarding. In this example,
    Skaffold will try to forward port `8080` to `localhost:9000`. If port `9000` is
    unavailable for some reason, then Skaffold will forward to a random open port:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用户定义的端口转发的示例。在这个例子中，Skaffold将尝试将端口`8080`转发到`localhost:9000`。如果由于某种原因端口`9000`不可用，那么Skaffold将转发到一个随机开放的端口：
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It is good practice to clean up the resources we create using Skaffold after
    our work is completed. Now, let's learn how we can clean up and delete Kubernetes
    resources with Skaffold.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成工作后，清理我们使用Skaffold创建的资源是一个好习惯。现在，让我们学习如何使用Skaffold清理和删除Kubernetes资源。
- en: Cleanup
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理
- en: With the `skaffold run` and `skaffold dev` commands, we can create resources
    in the Kubernetes cluster, create images stored on the local Docker daemon, and
    sometimes push images to remote registry. Doing all this work can have side effects
    on your local and deployment environments, in that you might fill up a significant
    amount of disk space in your local environment.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`skaffold run`和`skaffold dev`命令，我们可以在Kubernetes集群中创建资源，在本地Docker守护程序上创建图像，并有时将图像推送到远程注册表。做所有这些工作可能会对您的本地和部署环境产生副作用，您可能会在本地环境中占用大量磁盘空间。
- en: 'Skaffold provides a cleanup functionality to neutralize some of these side
    effects:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold提供了清理功能来中和其中一些副作用：
- en: You can clean up Kubernetes resources by running `skaffold delete`, or perform
    an automatic cleanup by using *Ctrl* + *C* for `skaffold dev` and `skaffold debug`.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过运行`skaffold delete`来清理Kubernetes资源，或者通过使用*Ctrl* + *C*来执行自动清理`skaffold dev`和`skaffold
    debug`。
- en: You can enable image pruning for local Docker daemon images by passing the `--no-prune=false`
    flag. Since artifact caching is enabled by default, you need to disable that for
    the purge to work. The actual command you need to run is `skaffold dev --no-prune=false
    --cache-artifacts=false`. By pressing *Ctrl* + *C* for `skaffold dev` and `skaffold
    debug`, Skaffold will automatically clean the images stored on the local Docker
    daemon.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过传递`--no-prune=false`标志来为本地Docker守护程序镜像启用图像修剪。由于默认情况下启用了工件缓存，您需要禁用该功能才能进行清除。您需要运行的实际命令是`skaffold
    dev --no-prune=false --cache-artifacts=false`。通过按下`skaffold dev`和`skaffold debug`的*Ctrl*
    + *C*，Skaffold将自动清理存储在本地Docker守护程序上的图像。
- en: For images that have been pushed to remote container registries, the user has
    to take care of the cleanup.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于已推送到远程容器注册表的图像，用户必须负责清理工作。
- en: 'For example, to test image pruning, we can use the following `docker` profile
    to build images using our local Docker daemon:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了测试图像修剪，我们可以使用以下`docker`配置文件来使用我们的本地Docker守护程序构建图像：
- en: '[PRE30]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we can run the `skaffold dev --no-prune=false --cache-artifacts=false`
    command. After the build and deployment, we can press *Ctrl* + *C*, which should
    prune the images and delete any Kubernetes resources as well. In the following
    logs, you can see that after pressing *Ctrl* + *C*, Skaffold started deleting
    Kubernetes resources and pruned images:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以运行`skaffold dev --no-prune=false --cache-artifacts=false`命令。构建和部署后，我们可以按下*Ctrl*
    + *C*，这应该清除图像并删除任何Kubernetes资源。在以下日志中，您可以看到按下*Ctrl* + *C*后，Skaffold开始删除Kubernetes资源并清除图像：
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this section, we took a deep dive into Skaffold pipeline stages such as init,
    build, and deploy, to name a few. In the next section, we will talk about debugging
    an application that's been deployed to a Kubernetes cluster with Skaffold.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了Skaffold流水线阶段，如init、build和deploy等。在下一节中，我们将讨论使用Skaffold部署到Kubernetes集群的应用程序的调试。
- en: Debugging with Skaffold
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Skaffold进行调试
- en: Skaffold supports debugging containerized applications running on Kubernetes
    with the `skaffold debug` command. Skaffold provides debugging for different container's
    runtime technology. Once debugging has been enabled, the associated debugging
    ports are exposed and labeled to be port-forwarded to the local machine. IntelliJ
    IDE's plugins, like Cloud Code, internally use Skaffold to add and attach the
    correct debugger for your language.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold支持在Kubernetes上运行的容器化应用程序进行调试，使用`skaffold debug`命令。Skaffold为不同容器的运行时技术提供调试支持。一旦启用了调试，相关的调试端口将被暴露和标记为要转发到本地机器。IntelliJ
    IDE的插件，比如Cloud Code，内部使用Skaffold为您的语言添加和附加正确的调试器。
- en: However, in debug mode, `skaffold debug` will disable image rebuilding and syncing
    as it can lead to debugging sessions terminating accidentally if we save file
    changes. You can allow image rebuilding and syncing with the `--auto-build`, `--auto-deploy`,
    and `--auto-sync` flags.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在调试模式下，`skaffold debug`将禁用图像重建和同步，因为这可能会导致调试会话在保存文件更改时意外终止。您可以使用`--auto-build`、`--auto-deploy`和`--auto-sync`标志允许图像重建和同步。
- en: 'The `skaffold debug` command supports the following languages and runtimes:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`skaffold debug`命令支持以下语言和运行时：'
- en: 'Go 1.13+ (runtime ID: go) and using Delve'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 1.13+（运行时ID：go）并使用Delve
- en: 'Node.js (runtime ID: nodejs) and using the Node.js Inspector Chrome DevTools'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js（运行时ID：nodejs）并使用Node.js Inspector Chrome DevTools
- en: 'The Java and JVM languages (runtime ID: jvm) and using JDWP'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java和JVM语言（运行时ID：jvm）并使用JDWP
- en: 'Python 3.5+ (runtime ID: python) and using `debugpy` (Debug Adapter Protocol)
    or `pydevd`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.5+（运行时ID：python）并使用`debugpy`（调试适配器协议）或`pydevd`
- en: '.NET Core (runtime ID: netcore) using `vsdbg`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core（运行时ID：netcore）使用`vsdbg`
- en: 'In the IDE, like IntelliJ, you need to add the Remote Java Application configuration
    to your Run/Debug configurations once you start your application. You must also
    select the port/address you defined when starting your application. Then, you
    are ready to debug:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDE中，比如IntelliJ，一旦启动应用程序，您需要将远程Java应用程序配置添加到您的运行/调试配置中。您还必须选择在启动应用程序时定义的端口/地址。然后，您就可以开始调试了：
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In IntelliJ, you should see the following after setting up the breakpoint.
    On the breakpoint, you should see the tick mark once the debug session has been
    activated:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在IntelliJ中，设置断点后，您应该看到以下内容。在断点处，一旦调试会话已激活，您应该看到对号：
- en: '![Figure 5.10 – Breakpoint enabled'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.10 – 已启用断点'
- en: '](image/B17385_Figure_5.11.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B17385_Figure_5.11.jpg)'
- en: Figure 5.10 – Breakpoint enabled
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 – 已启用断点
- en: 'In the **Debug** console logs, you should see the following once the debug
    session has started. Now, you are ready to debug your application:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在**调试**控制台日志中，一旦调试会话开始，您应该看到以下内容。现在，您已经准备好调试您的应用程序了：
- en: '![Figure 5.11 – Debugger attached'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.11 – 调试器已连接'
- en: '](image/B17385_Figure_5.12.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B17385_Figure_5.12.jpg)'
- en: Figure 5.11 – Debugger attached
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 – 调试器已连接
- en: In this section, we took a deep dive into Skaffold's debugging capabilities.
    We also learned how to debug a containerized version of our application using
    the `skaffold debug` command. You can also debug using the Cloud Code IntelliJ
    plugin, which we will cover in [*Chapter 7*](B17385_07_Final_PD_ePub.xhtml#_idTextAnchor092),
    *Building and Deploying a Spring Boot Application with the Cloud Code Plugin*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了Skaffold的调试能力。我们还学习了如何使用`skaffold debug`命令调试我们应用程序的容器化版本。您还可以使用Cloud
    Code IntelliJ插件进行调试，我们将在第7章中介绍，即使用Cloud Code插件构建和部署Spring Boot应用程序。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started by discovering various ways to install Skaffold
    on different operation systems. We covered the installation for popular OSes such
    as macOS, Windows, and Linux. Then, we looked at various commands supported by
    Skaffold that help build and deploy the Kubernetes application. We also covered
    some miscellaneous and housekeeping commands. Then, we discovered the different
    Skaffold pipeline stages, such as init, build, and deploy to name a few. Finally,
    we discussed debugging an application with Skaffold with a command such as `skaffold
    dev`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先发现了在不同操作系统上安装Skaffold的各种方法。我们涵盖了流行操作系统（如macOS、Windows和Linux）的安装。然后，我们看了一些Skaffold支持的帮助构建和部署Kubernetes应用程序的各种命令。我们还涵盖了一些杂项和日常命令。然后，我们发现了不同的Skaffold流水线阶段，比如init、build和deploy等。最后，我们讨论了如何使用`skaffold
    dev`等命令调试应用程序。
- en: In the next chapter, we will discuss Skaffold container image builders (Dockerfile,
    kaniko, Buildpacks, Jib) and deployers (Helm, kubectl, kustomize).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Skaffold容器镜像构建器（Dockerfile、kaniko、Buildpacks、Jib）和部署器（Helm、kubectl、kustomize）。
- en: Further reading
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: If you want to learn more about Skaffold, please take a look at its documentation
    at https://skaffold.dev/docs/.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于Skaffold的信息，请查看其文档https://skaffold.dev/docs/。
