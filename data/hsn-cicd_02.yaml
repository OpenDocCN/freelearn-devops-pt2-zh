- en: Basics of Continuous Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成的基础知识
- en: This chapter will help introduce the concept of **continuous integration** (**CI**)
    and will help set up the foundation of the CI/CD concepts that we will explore
    in the later chapters. It is important to understand what a CI build is intended
    for as these concepts transcend any given CI/CD tool that you may use. CI is important
    because it helps keep a codebase healthy and helps developers keep a software
    system running independently of any particular developer machine. A CI build enforces
    independence of software components and local environment configuration. The CI
    build should be decoupled from any one developer configuration and should be able
    to be repeatable and isolated in terms of state. Each build that is run should
    in essence be independent, as this guarantees that a software system is working
    correctly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助介绍**持续集成**（**CI**）的概念，并为我们在后续章节中探讨的CI/CD概念奠定基础。了解CI构建的目的很重要，因为这些概念超越了您可能使用的任何特定的CI/CD工具。CI很重要，因为它有助于保持代码库的健康，并帮助开发人员保持软件系统独立于任何特定的开发人员机器运行。CI构建强制执行软件组件的独立性和本地环境配置。CI构建应该与任何一个开发人员的配置解耦，并且应该能够重复和隔离状态。每次运行的构建本质上是独立的，这可以保证软件系统正常工作。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is CI?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是CI？
- en: The value of CI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI的价值
- en: Mitigating risks by utilizing CI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用CI来减轻风险
- en: Software builds at source code check-in
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码检入时的软件构建
- en: Small builds and large build breakdown
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型构建和大型构建分解
- en: CI build practices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI构建实践
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter only assumes a cursory understanding of version control systems
    but the reader should at least understand what configuration files are, and have
    a basic understanding of programming. We will briefly look at an example makefile
    and there will be some code snippets in the chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章只假设对版本控制系统有一定的了解，但读者至少应该了解配置文件是什么，并且对编程有基本的了解。我们将简���查看一个示例makefile，并在本章中提供一些代码片段。
- en: We will look at several code examples in this chapter, including an API Workshop
    ([https://github.com/jbelmont/api-workshop](https://github.com/jbelmont/api-workshop)) where
    we will explain a Makefile and a Demo Application ([https://github.com/jbelmont/advanced-tech-in-wilmington-react-app](https://github.com/jbelmont/advanced-tech-in-wilmington-react-app))
    that uses React/Node.js/Express.js/RethinkDB, and we will also showcase a `gulp.js`
    script file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看几个代码示例，包括一个API Workshop（[https://github.com/jbelmont/api-workshop](https://github.com/jbelmont/api-workshop)），在那里我们将解释一个Makefile和一个Demo
    Application（[https://github.com/jbelmont/advanced-tech-in-wilmington-react-app](https://github.com/jbelmont/advanced-tech-in-wilmington-react-app)），它使用React/Node.js/Express.js/RethinkDB，并且我们还将展示一个`gulp.js`脚本文件。
- en: What is CI?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是CI？
- en: CI is essentially a software engineering task where source code is both merged
    and tested on a mainline trunk. A CI task can do any multitude of tasks, including
    testing software components and deploying software components. The act of CI is
    essentially prescriptive and is an act that can be performed by any developer,
    system administrator, or operations personnel. Continuous integration is continuous
    because a developer can be continuously integrating software components while
    developing software.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CI本质上是一个软件工程任务，其中源代码同时合并和测试在主干上。CI任务可以执行任何多种任务，包括测试软件组件和部署软件组件。CI的行为本质上是规定的，可以由任何开发人员、系统管理员或运维人员执行。持续集成是持续的，因为开发人员可以在开发软件时持续集成软件组件。
- en: What is a software build anyway?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件构建到底是什么？
- en: A software build is more than just a compilation step. A software build can
    consist of a compilation step, a testing phase, a code inspection phase, and a
    deployment phase. A software build can act as a kind of verification step that
    checks that your software is working as a cohesive unit. Statically compiled languages,
    such as Golang and C++, often have build tools that generate a binary. For example,
    a Golang build command, such as `go build`, will both generate a statically compiled
    binary and run linting on the codebase. Other languages, such as JavaScript, can
    use a tool such as `gulp.js`/`grunt.js` to do what are considered build steps,
    such as **minification**—converting multiple JavaScript source files into one
    file—and **uglification**, which strips the comments and any whitespace of a source
    file, as well as linting and running test runners.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 软件构建不仅仅是一个编译步骤。软件构建可以包括编译步骤、测试阶段、代码检查阶段和部署阶段。软件构建可以作为一种验证步骤，检查您的软件是否作为一个统一的单元工作。静态编译语言，如Golang和C++，通常具有生成二进制文件的构建工具。例如，Golang的构建命令，如`go
    build`，将生成一个静态编译的二进制文件，并对代码库运行linting。其他语言，如JavaScript，可以使用诸如`gulp.js`/`grunt.js`之类的工具来执行被认为是构建步骤的操作，例如**缩小**
    - 将多个JavaScript源文件转换为一个文件 - 和**丑化**，它会剥离源文件的注释和任何空白，以及linting和运行测试运行器。
- en: CI process steps in a nutshell
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI流程步骤概述
- en: A developer can commit code to a **version control** **projects** (**VCP**)
    system, such as GitHub and GitLab. The CI server can either poll the repository
    for changes or the CI server can be configured to trigger a software build via
    a WebHook. We will look at this later with Jenkins, Travis, and Circle CI. The
    CI server will then get the latest software revision from the VCP system and can
    then execute a build script that integrates the software system. The CI server
    should generate feedback that emails build results upon a build failure to specified
    project members. The CI server will continuously poll for changes or will respond
    from a configured WebHook.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以向**版本控制** **项目**（**VCP**）系统提交代码，例如GitHub和GitLab。CI服务器可以轮询仓库以获取更改，或者可以配置CI服务器通过WebHook触发软件构建。我们稍后将在Jenkins、Travis和Circle
    CI中进行讨论。CI服务器将从VCP系统获取最新的软件版本，然后可以执行集成软件系统的构建脚本。CI服务器应该生成反馈，将构建结果通过电子邮件发送给指定的项目成员。CI服务器将持续轮询更改，或者将从配置的WebHook响应。
- en: The value of CI
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI的价值
- en: CI is valuable for many reasons. First and foremost, a CI build is valuable
    because it can reduce risks, and the health of your software becomes measurable.
    CI helps reduce developer assumptions. A CI environment should not rely on environment
    variables, nor rely on certain configuration files that are set on any one person's
    machine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: CI有很多价值。首先，CI构建有价值，因为它可以减少风险，软件的健康状况变得可衡量。CI有助于减少开发者的假设。CI环境不应依赖环境变量，也不应依赖某个人机器上设置的特定配置文件。
- en: The CI build should be built cleanly and independently from each developer's
    local machine and a CI build should be decoupled from any local environment. If
    a developer says that a build works on his/her machine but other developers cannot
    run the same exact code, then you know that a build may not be functioning properly.
    A CI build can help with such issues because the CI build is decoupled from any
    given developer's setup and environment variables and behaves independently of
    them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: CI构建应该干净地独立于每个开发者的本地机器，并且应该与任何本地环境解耦。如果一个开发者说构建在他/她的机器上可以运行，但其他开发者无法运行完全相同的代码，那么你就知道构建可能无法正常运行。CI构建可以帮助解决这些问题，因为CI构建与任何给定开发者的设置和环境变量解耦，并且独立运行。
- en: A CI build should reduce repetitive manual processes and the CI build process
    should run the same way on every build. A CI build process might consist of a
    compilation step, a test phase, and a report-generation phase. The CI build process
    should run every time a developer pushes a commit to a version control system
    such as Git, subversion, and mercurial. The CI build should free up developers
    to work on higher value work and should reduce possible mistakes that are done
    by repetitive manual processes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CI构建应该减少重复的手动流程，构建过程应该在每次构建时都以相同的方式运行。CI构建过程可能包括编译步骤、测试阶段和报告生成阶段。CI构建过程应该在开发者向Git、Subversion和Mercurial等版本控制系统提交代码时运行。CI构建应该释放开发者的时间，让他们可以从事更有价值的工作，并减少重复手动流程可能带来的错误。
- en: A good CI build should help generate deployable software anytime and anywhere.
    A CI build should enable project visibility and should establish confidence in
    your software with the development team. Developers can rest assured that a CI
    build will catch issues with code changes more so than when a build is run locally.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的CI构建应该能够在任何时间、任何地点生成可部署的软件。CI构建应该提供项目的可见性，并且应该在开发团队中建立对软件的信心。开发者可以放心，CI构建会比在本地运行构建更容易捕捉到代码变更的问题。
- en: Mitigating risks by utilizing CI
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用CI来减轻风险
- en: CI can help mitigate risks that are prevalent in software builds, such as *it
    works in my machine* syndrome. CI also helps unify integration points of failure,
    such as database logic as well as a host of other types of issues.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: CI可以帮助减轻软件构建中普遍存在的风险，比如“在我的机器上可以运行”的症状。CI还有助于统一集成失败点，比如数据库逻辑以及其他类型的问题。
- en: But it works on my machine!
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但在我的机器上可以运行！
- en: A common thread among developers is where a software build works on one developer's
    machine but does not work on another developer's machine. Each developer's machine
    should mirror—as closely as possible—software integration. Everything that is
    needed to do a software build needs to be committed to a version control system.
    Developers should not have custom build scripts that exist only on their local
    machines.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者之间的一个共同问题是，一个开发者的机器上可以运行软件构建，但另一个开发者的机器上却无法运行。每个开发者的机器应尽可能地与软件集成相似。完成软件构建所需的一切都需要提交到版本控制系统中。开发者不应该有只存在于他们本地机器上的自定义构建脚本。
- en: Database synchronization
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库同步
- en: Any database artifacts that are needed to complete a software build should be
    stored in version control. If you have a relational database, then any database
    creation scripts, data manipulation scripts, SQL stored procedures, and database
    triggers should be stored in version control.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 完成软件构建所需的任何数据库构件都应存储在版本控制中。如果你有一个关系型数据库，那么任何数据库创建脚本、数据操作脚本、SQL存储过程和数据库触发器都应存储在版本控制中。
- en: If, for example, you have a NoSQL database system, such as MongoDB ([https://www.mongodb.com/](https://www.mongodb.com/)),
    and are utilizing a RESTful API, then be sure to document API endpoints in a document.
    Remember that developers might need database-specific code to actually run a software
    build.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你使用NoSQL数据库系统，比如MongoDB ([https://www.mongodb.com/](https://www.mongodb.com/))，并且使用RESTful
    API，那么一定要在文档中记录API端点。记住，开发者可能需要数据库特定的代码来实际运行软件构建。
- en: A missing deployment automation phase
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺少部署自动化阶段
- en: Software deployments should be automated using a deployment tool. Deployment
    tools that you use can vary depending on different software architectures.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用部署工具自动化软件部署。你使用的部署工具可能因不同的软件架构而有所不同。
- en: 'Here is a list of deployment tools:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些部署工具的列表：
- en: Octopus Deploy ([https://octopus.com/](https://octopus.com/))
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Octopus Deploy ([https://octopus.com/](https://octopus.com/))
- en: AWS Elastic Beanstalk ([https://aws.amazon.com/elasticbeanstalk/](https://aws.amazon.com/elasticbeanstalk/)[)](https://aws.amazon.com/elasticbeanstalk/)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Elastic Beanstalk ([https://aws.amazon.com/elasticbeanstalk/](https://aws.amazon.com/elasticbeanstalk/))
- en: Heroku ([https://www.heroku.com/](https://www.heroku.com/))
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Heroku ([https://www.heroku.com/](https://www.heroku.com/))
- en: Google App Engine ([https://cloud.google.com/appengine/](https://cloud.google.com/appengine/))
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google App Engine ([https://cloud.google.com/appengine/](https://cloud.google.com/appengine/))
- en: Dokku ([http://dokku.viewdocs.io/dokku/](http://dokku.viewdocs.io/dokku/))
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dokku ([http://dokku.viewdocs.io/dokku/](http://dokku.viewdocs.io/dokku/))
- en: A deployment tool is valuable because they tend to be cross-platform and can
    be used in many different software architectures. If, for example, a developer
    writes a Bash script, then there is an underlying assumption that other developers
    are working on a Unix-like system, and a developer working in a Windows environment
    may not be able to run the script depending on the Windows version they are using.
    Windows 10 is now offering a bash subsystem where Windows developers can run Unix
    commands and scripts while operating a Windows OS.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 部署工具很有价值，因为它们往往是跨平台的，并且可以在许多不同的软件架构中使用。例如，如果开发人员编写了一个Bash脚本，那么其中有一个基本假设，即其他开发人员正在使用类Unix系统，而在Windows环境中工作的开发人员可能无法运行脚本，这取决于他们使用的Windows版本。现在Windows
    10提供了一个bash子系统，Windows开发人员可以在操作Windows操作系统时运行Unix命令和脚本。
- en: Late discovery of defects
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺陷的晚发现
- en: A CI build can help prevent the late discovery of software defects. A CI build
    should have a good enough test suite that covers a large percentage of the codebase.
    One possible metric for a healthy codebase is having 70% or more code coverage
    in a code base. We will talk later about code coverage, but any software tests
    should be in checked into source code and tests should be run on a CI build. Any
    software tests that you have should be run continuously on a CI system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: CI构建可以帮助防止软件缺陷的晚发现。CI构建应该具有足够好的测试套件，覆盖代码库的大部分代码。一个健康的代码库可能的度量标准是代码库中70%或更多的代码覆盖率。稍后我们将讨论代码覆盖率，但任何软件测试都应该被检入源代码，并且应该在CI构建上运行测试。您拥有的任何软件测试都应该在CI系统上持续运行。
- en: Test coverage not known
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试覆盖率未知
- en: In general, a high percentage of code coverage indicates a well-tested codebase,
    but does not necessarily guarantee a codebase has no software bugs—just that the
    test suite has good test coverage throughout. Try to use a code coverage tool
    in order to see how much of your tests are actually covering your source code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，高百分比的代码覆盖率表示一个经过充分测试的代码库，但并不一定保证代码库没有软件错误，只是测试套件在整个代码库中具有良好的测试覆盖率。尝试使用代码覆盖工具，以查看您的测试实际上覆盖了多少源代码。
- en: Code coverage tools
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖工具
- en: 'Here are some popular code coverage tools:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些流行的代码覆盖工具：
- en: '**Istanbul** ([h](https://istanbul.js.org/)[ttps://istanbul.js.org/](https://istanbul.js.org/)): Yet
    another JavaScript code coverage tool that computes statement, line, function,
    and branch coverage with module loader hooks to transparently add coverage when
    running tests. Supports all JS coverage use cases including unit tests, server-side
    functional tests, and browser tests. Built for scale.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Istanbul** ([h](https://istanbul.js.org/)[ttps://istanbul.js.org/](https://istanbul.js.org/))：又一个JavaScript代码覆盖工具，可以计算语句、行、函数和分支覆盖率，并通过模块加载器钩子在运行测试时透明地添加覆盖。支持所有JS覆盖使用情况，包括单元测试、服务器端功能测试和浏览器测试。专为规模而构建。'
- en: '**Goveralls** ([https://github.com/mattn/goveralls](https://github.com/mattn/goveralls)):
    Go integration for the [https://coveralls.io/](https://coveralls.io/) continuous
    code coverage tracking system.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Goveralls** ([https://github.com/mattn/goveralls](https://github.com/mattn/goveralls))：用于[https://coveralls.io/](https://coveralls.io/)持续代码覆盖跟踪系统的Go集成。'
- en: '**dotCover** ([https://www.jetbrains.com/dotcover/](https://www.jetbrains.com/dotcover/)):
    JetBrains dotCover is a .NET unit test runner and code coverage tool that integrates
    with Visual Studio.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dotCover** ([https://www.jetbrains.com/dotcover/](https://www.jetbrains.com/dotcover/))：JetBrains
    dotCover是一个.NET单元测试运行器和代码覆盖工具，可以与Visual Studio集成。'
- en: Make sure you know to what extent your code is covered with unit tests. dotCover
    calculates and reports statement-level code coverage in applications targeting .NET
    Framework, Silverlight, and .NET Core.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您知道您的代码在多大程度上受到单元测试的覆盖。dotCover可以计算并报告针对.NET Framework、Silverlight和.NET Core应用程序的语句级代码覆盖率。
- en: Lack of project visibility
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目可见性不足
- en: 'A CI system should be configured to send alerts in a multitude of ways:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: CI系统应该配置为以多种方式发送警报：
- en: Emails
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件
- en: SMS
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短信
- en: Push notification alerts via smartphone
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过智能手机的推送通知警报
- en: Some software development offices also use some other creative ways to send
    issue notifications on a software build, such as some kind of ambient light change
    or maybe even an intercom system. The main point is that developers need to be
    notified that the CI build is broken so that they can quickly fix the build. The
    CI build should not stay broken as this can disrupt other developers work.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一些软件开发办公室还使用一些其他创造性的方式来发送软件构建的问题通知，比如某种环境光变化或甚至对讲系统。主要的观点是开发人员需要被通知CI构建已经中断，以便他们可以快速修复构建。CI构建不应该保持中断，因为这可能会干扰其他开发人员的工作。
- en: Software builds at source code check-in
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码检入时的软件构建
- en: Software builds should be triggered upon each source code check-in in a version
    control system. This is an important step in the deployment pipeline, as we will
    see in the next chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 软件构建应该在版本控制系统中的每次源代码检入时触发。这是部署流水线中的一个重要步骤，我们将在下一章中看到。
- en: What is a software build again?
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件构建是什么？
- en: A software build can consist of just compiling software components. A build
    can consist of compiling and running automated tests, but, in general, the more
    processes you add to the build, the slower the feedback loop becomes on a build.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 软件构建可以仅包括编译软件组件。构建可以包括编译和运行自动化测试，但总的来说，您在构建中添加的进程越多，反馈循环就会变得越慢。
- en: Scripting tool
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本工具
- en: Favor using a scripting tool that is designed specifically for building software
    over personal scripts. Custom Shell scripts or batch scripts tend not to be cross-platform
    and can hide environment configuration. A scripting tool is the most effective
    process for developing a consistent, repeatable build solution.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用专门用于构建软件的脚本工具，而不是个人脚本。自定义Shell脚本或批处理脚本往往不具备跨平台性，并且可能隐藏环境配置。脚本工具是开发一致、可重复的构建解决方案的最有效过程。
- en: 'Here is a list of scripting tools:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些脚本工具的列表：
- en: Make ([https://www.gnu.org/software/make/](https://www.gnu.org/software/make/))
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Make ([https://www.gnu.org/software/make/](https://www.gnu.org/software/make/))
- en: Maven ([https://maven.apache.org/](https://maven.apache.org/))
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven ([https://maven.apache.org/](https://maven.apache.org/))
- en: Leiningen ([https://leiningen.org/](https://leiningen.org/))
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Leiningen ([https://leiningen.org/](https://leiningen.org/))
- en: Stack ([https://docs.haskellstack.org/en/stable/README/](https://docs.haskellstack.org/en/stable/README/)[)](https://docs.haskellstack.org/en/stable/README/)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stack ([https://docs.haskellstack.org/en/stable/README/](https://docs.haskellstack.org/en/stable/README/)[)](https://docs.haskellstack.org/en/stable/README/)
- en: Performing single command builds
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行单一命令构建
- en: Strive to make single command builds to ease the process of building software,
    because the easier you make running the build process, the more you will speed
    up adoption and developer involvement. If doing a software build is a complicated
    process, then you will end up having only a few developers actually doing a build,
    which is not what you want.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 努力实现单一命令构建，以便简化构建软件的过程，因为您使运行构建过程变得更容易，您将加快采用速度和开发人员参与度。如果构建软件是一个复杂的过程，那么最终只有少数开发人员会真正进行构建，这不是您想要的。
- en: Building your software in a nutshell
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之构建您的软件
- en: Create your build using a scripting tool, such as Ant ([https://ant.apache.org/](https://ant.apache.org/)),
    Make ([https://www.gnu.org/software/make/](https://www.gnu.org/software/make/)),
    Maven ([https://maven.apache.org/](https://maven.apache.org/)), or Rake ([https://ruby.github.io/rake/](https://ruby.github.io/rake/))
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用脚本工具（例如 Ant ([https://ant.apache.org/](https://ant.apache.org/)), Make ([https://www.gnu.org/software/make/](https://www.gnu.org/software/make/)),
    Maven ([https://maven.apache.org/](https://maven.apache.org/)), 或 Rake ([https://ruby.github.io/rake/](https://ruby.github.io/rake/))）创建您的构建
- en: Start with a simple process in the CI build
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从CI构建中开始一个简单的过程
- en: Add each process to integrate your software within the build script
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个过程添加到构建脚本中以集成您的软件
- en: Run your script from the command line or an IDE
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行或IDE运行您的脚本
- en: 'Here is an example makefile that runs a Golang API Service from my open source
    [https://github.com/jbelmont/api-workshop](https://github.com/jbelmont/api-workshop):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例makefile，它从我的开源[https://github.com/jbelmont/api-workshop](https://github.com/jbelmont/api-workshop)运行一个Golang
    API服务：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is an example build script using `gulp.js` that generates a CSS build
    from `sass` source files and runs a linter. The first block sh initialization
    of variables and getting of configuration objects ready for use:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`gulp.js`的示例构建脚本，该脚本从`sass`源文件生成CSS构建并运行linter。第一块是初始化变量和准备配置对象以供使用：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This second block of code is where we set up gulp tasks: copying React.js files,
    doing uglification of JavaScript files, creating a build JavaScript file, and
    creating CSS files from Sass files.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的第二块是我们设置gulp任务的地方：复制React.js文件，对JavaScript文件进行丑化，创建构建JavaScript文件，并从Sass文件创建CSS文件。
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this final block of code, we run some watcher tasks that will watch any
    changes in the JavaScript files and Sass files, do linting, and create a nodemon
    process that will restart the Node server on any file changes:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段最后的代码中，我们运行一些监视任务，将监视JavaScript文件和Sass文件中的任何更改，进行linting，并创建一个nodemon进程，该进程将在任何文件更改时重新启动Node服务器：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Separating build scripts from your IDE
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将构建脚本与IDE分开
- en: Try to avoid coupling your build scripts to any particular **Integrated Development
    Environment** (**IDE**). A build script shouldn't be dependent on any IDE.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量避免将构建脚本与任何特定的**集成开发环境**（**IDE**）耦合。构建脚本不应依赖于任何IDE。
- en: 'This is important for two reasons:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，有两个原因：
- en: Each developer may be using a different IDE/editor and may have different configurations
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个开发人员可能使用不同的IDE /编辑器，并且可能具有不同的配置
- en: A CI server must execute an automated build without any human intervention
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI服务器必须在没有任何人为干预的情况下执行自动化构建
- en: Software assets should be centralized
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件资产应该是集中的
- en: 'The following software assets should be available on a centralized version
    control repository:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下软件资产应该在集中式版本控制存储库上可用：
- en: Components, such as source files or library files
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件，例如源文件或库文件
- en: Third-party components, such as DLLs and JAR files
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方组件，例如DLL和JAR文件
- en: Configuration files
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件
- en: Data files that are needed to initialize an application
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要初始化应用程序的数据文件
- en: Build scripts and build environment settings
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建脚本和构建环境设置
- en: Installation scripts that are needed for some components
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一些组件的安装脚本
- en: You must decide what should go into version control.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须决定应该放入版本控制的内容。
- en: Creating a consistent directory structure
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一致的目录结构
- en: You must choose a consistent directory structure for your software assets, as
    it can help you perform scripted retrievals from a CI server.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须为软件资产选择一致的目录结构，因为它可以帮助您从CI服务器执行脚本检索。
- en: 'Here is a sample folder structure that I have done for a skeleton React/Redux
    application:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我为骨架React/Redux应用程序做的一个示例文件夹结构：
- en: '`ca` (certificate authority)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ca`（证书颁发机构）'
- en: '`config` (configuration files)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`配置`（配置文件）'
- en: '`db` (database-related stuff)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db`（与数据库相关的内容）'
- en: '`docs` (documentation)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`文档`（文档）'
- en: '`images`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`图像`'
- en: '`models` (data files)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`模型`（数据文件）'
- en: '`test` (all my test files)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`测试`（所有我的测试文件）'
- en: '`unit`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`单元`'
- en: '`integration`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`集成`'
- en: '`e2e`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e2e`'
- en: '`helpers`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`助手`'
- en: '`static`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`静态`'
- en: '`build`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`构建`'
- en: '`js`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`js`'
- en: '`actions`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`操作`'
- en: '`components`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`组件`'
- en: '`constants`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`常量`'
- en: '`data`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数据`'
- en: '`reducers`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reducers`'
- en: '`store`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`存储`'
- en: '`utils`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`实用程序`'
- en: '`scss`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scss`'
- en: '`utils` (utility files)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`utils`（实用文件）'
- en: 'Here is another directory structure that I have followed, which is package
    oriented and recommended by **Bill Kennedy from the Golang Community** ([https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html](https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html)):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我遵循的另一个目录结构，它是面向包的，并且是由**Golang社区的Bill Kennedy**推荐的（[https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html](https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html)）：
- en: '`kit`:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`工具包`：'
- en: Packages that provide foundational support for the different application projects
    that exist
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为现有的不同应用项目提供基础支持的软件包
- en: Logging, configuration, or web functionality
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录，配置或Web功能
- en: '`cmd/`:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd/`：'
- en: Packages that provide support for a specific program that is being built for
    startup, shutdown, and configuration
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为正在启动，关闭和配置的特定程序提供支持的软件包
- en: '`internal/`:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`内部/`：'
- en: Packages that provide support for the different programs the project owns
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为项目拥有的不同程序提供支持的软件包
- en: CRUD, services, or business logic
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CRUD、服务或业务逻辑
- en: '`internal/platform/`:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`internal/platform/`：'
- en: Packages that provide internal foundational support for the project
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为项目提供内部基础支持的软件包
- en: Database, authentication, or marshaling
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库、身份验证或编组
- en: 'The main point is that you should follow a standard naming convention for your
    codebase that all developers follow. This will help the developer team work as
    they will be familiar with particular things laid out in the code. Not everyone
    will agree with a particular directory layout, but having a standard is the most
    important part. Anyone working on a newer service, for example, should be able
    to set up the project structure based on a codified naming convention for folders,
    where source files go, and where test files are placed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的一点是，你应该遵循一个标准的命名约��，所有开发人员都遵循。这将有助于开发团队的工作，因为他们将熟悉代码中的特定事物。并不是每个人都会同意特定的目录布局，但拥有一个标准是最重要的部分。例如，任何在新服务上工作的人应该能够根据文件夹的命名约定设置项目结构，源文件放在哪里，测试文件放在哪里：
- en: '![](assets/ca6c3c46-7b87-4941-97c9-a6a4bf33fb88.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ca6c3c46-7b87-4941-97c9-a6a4bf33fb88.png)'
- en: Here is a sample directory structure that I am using for an API Workshop ([https://github.com/jbelmont/api-workshop](https://github.com/jbelmont/api-workshop))
    that I created in GitHub.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在GitHub上为API Workshop创建的一个示例目录结构（[https://github.com/jbelmont/api-workshop](https://github.com/jbelmont/api-workshop)）。
- en: Software builds should fail fast
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件构建应该快速失败。
- en: 'This can be achieved by doing the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式实现：
- en: Integrating software components.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集成软件组件。
- en: Running true unit tests—unit tests that don't rely on a database but run in
    isolation.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行真正的单元测试——不依赖于数据库但在隔离环境中运行的单元测试。
- en: Ensuring that unit tests are able to run quickly. If a unit test takes an order
    of minutes, then this could be an indication of a problem.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保单元测试能够快速运行。如果一个单元测试需要几分钟的时间，那么这可能是一个问题的迹象。
- en: Running other automated processes (rebuild database, inspect, and deploy).
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行其他自动化流程（重建数据库，检查和部署）。
- en: It is up to each company what other steps are necessary for their builds.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于他们的构建，其他步骤是必要的，这取决于每家公司。
- en: Building for any environment
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为任何环境构建
- en: Configuration files and environment variables should be set for different environments,
    such as dev/prod/test. Logging verbosity should be able to be set as per the environment. Developers
    might need increased logging for debugging. Application server configuration information
    can be set in a build file as well as database connection information and framework
    configuration.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 应该为不同的环境设置配置文件和环境变量，例如dev/prod/test。日志详细程度应该能够根据环境进行设置。开发人员可能需要增加日志以进行调试。应用服务器配置信息可以在构建文件中设置，以及数据库连接信息和框架配置。
- en: 'Here is an example text file that can be used. One thing to note is that such
    files should not be committed to source control as they may contain client secrets
    and API secrets:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可以使用的示例文本文件。需要注意的一点是，这些文件不应该提交到源代码控制，因为它们可能包含客户机密和API密钥：
- en: '[PRE4]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Configuration text files such as these can help other developers connect to
    third-party services and will help organize where client secret information is
    stored.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的配置文本文件可以帮助其他开发人员连接到第三方服务，并有助于组织客户端秘密信息的存储位置。
- en: Small build and large build breakdown
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小型构建和大型构建的分解
- en: A small build is usually a build that can be run quickly by the CI server and
    will usually consist of a compilation step as well as running all the unit tests.
    A small build can be optimized by running staged builds, which will be discussed
    in the *CI build practices* section.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，小型构建是可以由CI服务器快速运行的构建，通常包括编译步骤以及运行所有单元测试。小型构建可以通过运行分阶段构建来优化，这将在*CI构建实践*部分讨论。
- en: A large build is a build that essentially runs all of the build tasks in one
    large build. The disadvantage of doing a large build is that they discourage developers
    from running them. If a software build takes a long time to run, then many developers
    will avoid running the build at all. Smaller builds that run quickly encourage
    developers to continuously check-in their changes on a version control system
    and will help keep a codebase healthy.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 大型构建实际上是运行所有构建任务的一个大型构建。进行大型构建的缺点是会阻止开发人员运行它们。如果软件构建需要很长时间才能运行，那么许多开发人员将避免运行构建。快速运行的较小构建鼓励开发人员不断地在版本控制系统上检入他们的更改，并有助于保持代码库的健康。
- en: CI build practices
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI构建实践
- en: CI build practices are like stepping stones; they build up on top of each other.
    As we will see in the next chapter, each step in the CI build process is important
    and provides assurance that your codebase is in a healthy condition.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: CI构建实践就像是阶梯；它们相互累积。正如我们将在下一章中看到的，CI构建过程中的每一步都很重要，并提供了确保代码库处于健康状态的保证。
- en: Private build
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有构建
- en: Developers should run private builds prior to committing code to the repository.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员在提交代码到存储库之前应该运行私有构建。
- en: 'Here is a sample developer session using Git:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用Git的示例开发人员会话：
- en: 'Check out the code you will alter from the repository:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从存储库检出要更改的代码：
- en: Go into the version controlled folder.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入版本控制的文件夹。
- en: '`git checkout -b new_branch`.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`git checkout -b new_branch`。'
- en: 'Make changes to the code:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对代码进行更改：
- en: Edit `myFile.go`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`myFile.go`。
- en: 'Get the latest system changes from the repository:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从存储库获取最新的系统更改：
- en: '`git pull`.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`git pull`。'
- en: Run a build that executes of all your unit tests and possibly integration tests
    in your local machine.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地机器上运行一个执行所有单元测试和可能的集成测试的构建。
- en: Commit your code changes to the repository.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码更改提交到存储库。
- en: The CI build should automatically trigger a build and run any tests in the repository.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI构建应该自动触发构建并运行存储库中的任何测试。
- en: The CI build should also do other tasks, such as reporting and calling other
    services if need be.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI构建还应该执行其他任务，如报告和调用其他服务（如果需要）。
- en: Usage of CI server
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CI服务器
- en: The CI server should either be polling for changes in version control repository
    systems, such as GitHub, at a specified time interval, or be configured via WebHook
    to trigger a software build. A CI build should perform certain actions on a scheduled
    basis—hourly or daily, if needs be. You should identify a *quiet period* during
    which no integration builds are performed for the project. A CI server should
    support different build scripting tools, such as Rake, Make, NPM, or Ant. A CI
    server should send emails to concerned parties, as well as display a history of
    previous builds.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: CI服务器应该定期轮询版本控制存储库系统（如GitHub）的更改，或者通过WebHook配置以触发软件构建。CI构建应该按计划执行某些操作-每小时或每天，如果需要的话。您应该确定一个*安静期*，在此期间不执行项目的集成构建。CI服务器应该支持不同的构建脚本工具，如Rake、Make、NPM或Ant。CI服务器应该向相关方发送电子邮件，并显示先前构建的历史记录。
- en: A CI server should display a dashboard that is web accessible so that all concerned
    parties can review integration build information when necessary. Jenkins, Travis,
    and Circle CI all have dashboards that are web accessible. A CI server should
    support multiple version control systems for your different projects, such as
    svn, Git, and mercurial.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: CI服务器应该显示一个Web访问的仪表板，以便所有相关方在必要时可以查看集成构建信息。Jenkins、Travis和Circle CI都有Web访问的仪表板。CI服务器应该支持不同的版本控制系统，如svn、Git和mercurial。
- en: Manual integration builds
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动集成构建
- en: Running an integration build manually is an approach to reducing integration
    build errors if there is a long-running feature that will be difficult to run
    on a CI server—but use such techniques sparingly. For example, you could designate
    a machine that is not being used to do a manual integration task; although, with
    the cloud, it is now easier than ever to just spin up a server instance on demand.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 手动运行集成构建是减少集成构建错误的一种方法，如果有长时间运行的功能，将很难在CI服务器上运行，但要谨慎使用这种技术。例如，您可以指定一个未被使用的机器来执行手动集成任务；尽管使用云，现在只需按需启动服务器实例就更容易了。
- en: Running fast builds
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行快速构建
- en: 'Strive to run software builds as quickly as possible by increasing computing
    resources. Offload slower running tests, such as system-level tests, onto a secondary
    build or a nightly build. Offload code inspection to a third-party service. For
    example, for code coverage analysis, you can use the following third-party services:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 努力通过增加计算资源尽快运行软件构建。将运行较慢的测试，如系统级测试，转移到次要构建或每夜构建。将代码检查转移到第三方服务。例如，对于代码覆盖分析，可以使用以下第三方服务：
- en: Codecov ([https://codecov.io/#features](https://codecov.io/#features))
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Codecov ([https://codecov.io/#features](https://codecov.io/#features))
- en: Coveralls ([https://coveralls.io/features](https://coveralls.io/features)[)](https://coveralls.io/features)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Coveralls ([https://coveralls.io/features](https://coveralls.io/features)[)](https://coveralls.io/features)
- en: Code climate [(](https://coveralls.io/features)[https://codeclimate.com/quality/](https://codeclimate.com/quality/)[)](https://coveralls.io/features)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码质量[(](https://coveralls.io/features)[https://codeclimate.com/quality/](https://codeclimate.com/quality/)[)](https://coveralls.io/features)
- en: Codacy ([https://www.codacy.com/product](https://www.codacy.com/product)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Codacy ([https://www.codacy.com/product](https://www.codacy.com/product)
- en: Run staged builds to promote fast builds as well. The first build can compile
    and run all the unit tests. The second build can run all the integration tests
    and system-level tests. You can have as many stages as necessary to have fast
    builds. Arguably, the first build should be the fastest, as this will be the primary
    build that developers use when checking in code to a codebase.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 运行分阶段的构建以促进快速构建。第一次构建可以编译并运行所有单元测试。第二次构建可以运行所有集成测试和系统级测试。您可以有尽可能多的阶段来实现快速构建。可以说，第一次构建应该是最快的，因为这将是开发人员在向代码库签入代码时使用的主要构建。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided a foundation on CI concepts and introduced techniques
    for employing a successful CI server in a developer team. We looked at scripting
    tools and build tools. We discussed what a software build is, good practices to
    follow when creating a build script, and also some testing concepts, such as code
    coverage. The next chapter is on **continuous delivery** (**CD**), which is a
    natural extension to CI, and we will go into detail about the deployment pipeline,
    configuration management, deployment scripting, and the deployment ecosystem.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了CI概念的基础，并介绍了在开发团队中使用成功的CI服务器的技术。我们研究了脚本工具和构建工具。我们讨论了软件构建是什么，创建构建脚本时要遵循的良好实践，以及一些测试概念，如代码覆盖。下一章是关于**持续交付**（**CD**），这是对CI的自然延伸，我们将详细介绍部署流水线、配置管理、部署脚本和部署生态系统。
- en: Questions
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a software build?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是软件构建？
- en: What is meant by a staged build?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是分阶段构建？
- en: Can you name some scripting tools?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能说出一些脚本工具的名称吗？
- en: Why should you follow a naming convention and folder structure?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要遵循命名约定和文件夹结构？
- en: What is the value of CI?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI的价值是什么？
- en: Further reading
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'A great book to read that goes into more about CI is *Learning Continuous Integration
    with Jenkins – Second Edition: A beginner''s guide to implementing Continuous
    Integration and Continuous Delivery using Jenkins 2* ([https://www.amazon.com/dp/1788479351/](https://www.amazon.com/dp/1788479351/)),
    by Packt Publishing.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读的一本好书，更多关于CI的内容是《使用Jenkins进行持续集成学习-第二版：使用Jenkins 2实施持续集成和持续交付的初学者指南》([https://www.amazon.com/dp/1788479351/](https://www.amazon.com/dp/1788479351/))，由Packt
    Publishing出版。
