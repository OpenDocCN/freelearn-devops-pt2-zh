- en: Chapter 1. Getting Started with Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。开始使用Ansible
- en: '**Ansible** is profoundly different from other configuration management tools
    available today. It has been designed to make configuration easy in almost every
    way, from its simple English configuration syntax to its ease of setup. You''ll
    find that Ansible allows you to stop writing custom configuration and deployment
    scripts and lets you simply get on with your job.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ansible**与今天可用的其他配置管理工具有很大不同。它旨在使配置几乎在各个方面都变得容易，从其简单的英语配置语法到其易于设置。您会发现，Ansible允许您停止编写自定义配置和部署脚本，而只需简单地继续您的工作。'
- en: Ansible only needs to be installed on the machines that you use to manage your
    infrastructure. It does not need a client to be installed on the managed machine,
    nor does it need any server infrastructure to be set up before you can use it.
    You should even be able to use it merely minutes after it is installed, as we
    will show you in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible只需要安装在您用来管理基础架构的机器上。它不需要在被管理机上安装客户端，也不需要在使用之前设置任何服务器基础设施。甚至在安装后几分钟内就应该能够使用，正如我们将在本章中向您展示的那样。
- en: 'The following are the topics covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Installing Ansible
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Ansible
- en: Configuring Ansible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Ansible
- en: Using Ansible from the command line
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible命令行
- en: Using Ansible to manage Windows machines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible管理Windows机器
- en: How to get help
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何获取帮助
- en: Hardware and software required
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所需的硬件和软件
- en: You will be using Ansible from the command line on one machine, which we will
    call the **controller machine**, and use it to configure another machine, which
    we will call the **managed machine**. Ansible currently only supports a Linux
    or OS X controller machine; however, the managed machine can be Linux, OS X, other
    Unix-like machines or Windows. Ansible does not place many requirements on the
    controller machine and even less on the managed machine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在一台机器上使用Ansible命令行，我们将其称为**控制机**，并用它来配置另一台机器，我们将其称为**被管理机**。目前，Ansible仅支持Linux或OS
    X控制机；然而，被管理机可以是Linux、OS X、其他类Unix的机器或Windows。Ansible对控制机的要求不多，对被管理机的要求更少。
- en: 'The requirements for the controller machine are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 控制机的要求如下：
- en: Python 2.6 or higher
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 2.6或更高版本
- en: paramiko
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: paramiko
- en: PyYAML
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyYAML
- en: Jinja2
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jinja2
- en: httplib2
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: httplib2
- en: Unix-based OS
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Unix的操作系统
- en: The managed machine needs Python 2.4 or higher and simplejson; however, if your
    Python is 2.5 or higher, you only need Python. Managed Windows machines will need
    Windows remoting turned on, and a version of Windows PowerShell greater than 3.0\.
    While Windows machines do have more requirements, all the tools are freely available
    and the Ansible project even includes the script to help you easily set up the
    dependencies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 被管理机需要Python 2.4或更高版本和simplejson；然而，如果您的Python是2.5或更高版本，您只需要Python。被管理的Windows机器将需要打开Windows远程，并且需要大于3.0的Windows
    PowerShell版本。虽然Windows机器有更多的要求，但所有工具都是免费提供的，Ansible项目甚至包括帮助您轻松设置依赖项的脚本。
- en: Installation methods
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装方法
- en: If you want to use Ansible to manage a set of existing machines or infrastructure,
    you will likely want to use whatever package manager is included on those systems.
    This means that you will get updates for Ansible as your distribution updates
    it, which may lag several versions behind other methods. However, it means that
    you will be running a version that has been tested to work on the system you are
    using.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用Ansible来管理一组现有的机器或基础架构，您可能希望使用这些系统上包含的任何软件包管理器。这意味着您将获得Ansible的更新，因为您的发行版更新它，这可能会滞后于其他方法几个版本。但是，这意味着您将运行经过测试的版本，可以在您使用的系统上正常工作。
- en: If you run an existing infrastructure, but need a newer version of Ansible,
    you can install Ansible via pip. **Pip** is a tool used to manage packages of
    Python software and libraries. Ansible releases are pushed to pip as soon as they
    are released, so if you are up to date with pip, you should always be running
    the latest version.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行现有基础架构，但需要更新版本的Ansible，可以通过pip安装Ansible。**Pip**是一个用于管理Python软件和库包的工具。Ansible发布的版本一经发布就会推送到pip，因此如果您与pip保持最新，您应该始终运行最新版本。
- en: If you imagine yourself developing lots of modules and possibly contributing
    back to Ansible, you should be running a version installed from source code. As
    you will be running the latest and least-tested version of Ansible, you may experience
    a hiccup or two.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想象自己开发了很多模块，可能会贡献给Ansible，你应该运行从源代码安装的版本。由于你将运行最新且测试最少的Ansible版本，可能会遇到一两个问题。
- en: Installing from your distribution
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从您的发行版安装
- en: 'Most modern distributions include a package manager that automatically manages
    package dependencies and updates for you. This makes installing Ansible via your
    package manager by far the easiest way to get started with Ansible; usually it
    takes only a single command. It will also be updated as you update your machine,
    though it may be a version or two behind. The following are the commands to install
    Ansible on the most common distributions. If you are using something different,
    refer to the user guide of your package or your distribution''s package lists:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代发行版都包含一个自动管理软件包依赖关系和更新的软件包管理器。这使得通过软件包管理器安装Ansible成为开始使用Ansible最简单的方法；通常只需要一个命令。它也会随着您更新您的机器而更新，尽管可能会滞后一两个版本。以下是在最常见的发行版上安装Ansible的命令。如果您使用其他软件包，请参考您的软件包的用户指南或您的发行版的软件包列表：
- en: 'Fedora, RHEL, CentOS, and compatible:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fedora、RHEL、CentOS和兼容系统：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Ubuntu, Debian, and compatible:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu、Debian和兼容系统：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that RHEL and CentOS require the EPEL repository to be installed. Details
    on EPEL, including how to install it can be found at [https://fedoraproject.org/wiki/EPEL](https://fedoraproject.org/wiki/EPEL).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，RHEL和CentOS需要安装EPEL存储库。有关EPEL的详细信息，包括如何安装它，可以在[https://fedoraproject.org/wiki/EPEL](https://fedoraproject.org/wiki/EPEL)找到。
- en: If you are on Ubuntu and wish to use the latest release instead of the one provided
    by your operating system, you can use the Ubuntu PPA provided by Ansible. Details
    on setting this up can be found at [https://launchpad.net/~ansible/+archive/ubuntu/ansible](https://launchpad.net/~ansible/+archive/ubuntu/ansible).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Ubuntu，并希望使用最新版本而不是操作系统提供的版本，可以使用Ansible提供的Ubuntu PPA。有关设置的详细信息，请访问[https://launchpad.net/~ansible/+archive/ubuntu/ansible](https://launchpad.net/~ansible/+archive/ubuntu/ansible)。
- en: Installing from pip
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从pip安装
- en: 'Pip, like a distribution''s package manager, will handle finding, installing,
    and updating the packages you ask for and its dependencies. This makes installing
    Ansible via pip as easy as installing from your package manager. It should be
    noted, however, that it will not be updated with your operating system. Additionally,
    updating your operating system may break your Ansible installation; however, this
    is unlikely. If you are a Python user, you might want to install Ansible in an
    isolated environment (virtual environment): This is not supported as Ansible tries
    to install its modules to the system. You should install Ansible system-wide using
    pip.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Pip，就像发行版的软件包管理器一样，将处理查找、安装和更新您要求的软件包及其依赖关系。这使得通过pip安装Ansible与通过软件包管理器安装一样简单。但是需要注意的是，它不会随操作系统更新。此外，更新操作系统可能会破坏您的Ansible安装；但是，这不太可能发生。如果您是Python用户，可能希望在隔离环境（虚拟环境）中安装Ansible：这是不受支持的，因为Ansible尝试将其模块安装到系统中。您应该使用pip在系统范围内安装Ansible。
- en: 'The following is the command to install Ansible via pip:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过pip安装Ansible的命令：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installing from the source code
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从源代码安装
- en: 'Installing from the source code is a great way to get the latest version, but
    it may not be tested as correctly as the released versions. You also will need
    to take care of updating to newer versions yourself and making sure that Ansible
    will continue to work with your operating system updates. To clone the `git` repository
    and install it, run the following commands. You may need root access to your system
    to do this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码安装是获取最新版本的好方法，但可能没有经过正确测试，与发布的版本不同。您还需要自行更新到新版本，并确保Ansible将继续与操作系统更新一起工作。要克隆`git`存储库并安装它，请运行以下命令。您可能需要root访问权限才能执行此操作：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了本书，可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: Setting up Ansible
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Ansible
- en: Ansible needs to be able to get an inventory of the machines that you want to
    configure in order to manage them. This can be done in many ways due to inventory
    plug-ins. Several different inventory plug-ins are included with the base install.
    We will go over these later in the book. For now, we will cover the simple host's
    file inventory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible需要能够获取您想要配置的机器的清单，以便对其进行管理。由于清单插件的原因，可以通过多种方式完成这一点。基本安装包含了几种不同的清单插件。我们将在本书的后面介绍这些。现在，我们将介绍简单的主机文件清单。
- en: The default Ansible inventory file is named hosts and is placed at `/etc/ansible`.
    It is formatted like an `INI` file. Group names are enclosed in square braces,
    and everything underneath it, down to the next group heading, gets assigned to
    that group. Machines can be in many groups at one time. Groups are used to allow
    you to configure many machines at once. You can use a group instead of a hostname
    as a host pattern in later examples, and Ansible will run the module on the entire
    group at once.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的Ansible清单文件名为hosts，位于`/etc/ansible`。它的格式类似于`INI`文件。组名用方括号括起来，下面的所有内容，直到下一个组标题，都分配给该组。机器可以同时属于多个组。组用于允许您一次配置多台机器。您可以在后续示例中使用组而不是主机名作为主机模式，Ansible将一次在整个组上运行模块。
- en: In the following example, we have three machines in a group named `webservers`,
    namely `site01`, `site02`, and `site01-dr`. We also have a `production` group
    that consists of `site01`, `site02`, `db01`, and `bastion`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们有一个名为`webservers`的组中的三台机器，分别是`site01`、`site02`和`site01-dr`。我们还有一个`production`组，其中包括`site01`、`site02`、`db01`和`bastion`。
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once you have placed your hosts in the Ansible inventory, you can start running
    commands against them. Ansible includes a simple module called `ping` that lets
    you test connectivity between yourself and the host. Let's use Ansible from the
    command line against one of our machines to confirm that we can configure them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将主机放入Ansible清单中，就可以开始针对它们运行命令。Ansible包括一个名为`ping`的简单模块，可让您测试自己与主机之间的连接。让我们从命令行使用Ansible针对我们的一台机器，以确认我们可以配置它们。
- en: Ansible was designed to be simple, and one of the ways the developers have done
    this is by using SSH to connect to the managed machines. It then sends the code
    over the SSH connection and executes it. This means that you don't need to have
    Ansible installed on the managed machine. It also means that Ansible uses the
    same channels that you are already using to administer the machine. This makes
    is easier to setup, because in most cases there will be no setup required and
    no ports to open in a firewall.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible旨在简单易用，开发人员采用的一种方式是使用SSH连接到受管机器。然后通过SSH连接发送代码并执行它。这意味着您不需要在受管机器上安装Ansible。这也意味着Ansible使用与您已经用于管理机器的相同通道。这使得设置更加容易，因为在大多数情况下不需要任何设置，也不需要在防火墙中打开端口。
- en: 'First, we check connectivity to our server to be configured using the Ansible
    `ping` module. This module simply connects to the following server:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用Ansible的`ping`模块检查要配置的服务器的连接。该模块简单地连接到以下服务器：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This should ask for the SSH password and then produce a result that looks like
    the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该要求输入SSH密码，然后产生类似以下的结果：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you have an SSH key set up for the remote system, you will be able to leave
    off the `-k` argument to skip the prompt and use the keys. You can also configure
    Ansible to use a particular username all the time by either configuring it in
    the inventory on a per host basis or in the global Ansible configuration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为远程系统设置了SSH密钥，您可以省略`-k`参数以跳过提示并使用密钥。您还可以通过在清单中按主机或在全局Ansible配置中配置来始终使用特定用户名。
- en: To set the username globally, edit `/etc/ansible/ansible.cfg` and change the
    line that sets `remote_user` in the `[defaults]` section. You can also change
    `remote_port` to change the default port that Ansible will SSH to. This will change
    the default settings for all the machines, but they can be overridden in the inventory
    file on a per server or per group basis.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 全局设置用户名，编辑`/etc/ansible/ansible.cfg`并更改在`[defaults]`部分设置`remote_user`的行。您还可以更改`remote_port`以更改Ansible将SSH到的默认端口。这将更改所有机器的默认设置，但可以在清单文件中按服务器或组的基础上进行覆盖。
- en: To set the username in the inventory file, simply append `ansible_ssh_user`
    to the line in the inventory. For example, the following code section shows an
    inventory where the `site01` host uses the username `root` and the `site02` host
    uses the username `daniel`. There are also other variables you can use. The `ansible_ssh_host`
    variable allows you to set a different hostname, and the `ansible_ssh_port` variable
    allows you to set a different port, which is demonstrated on the `site01-dr` host.
    Finally the `db01` host uses the username `fred` and also sets a private key using
    `ansible_ssh_private_key_file`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要在清单文件中设置用户名，只需将`ansible_ssh_user`附加到清单中的行。例如，以下代码部分显示了一个清单，其中`site01`主机使用用户名`root`，`site02`主机使用用户名`daniel`。您还可以使用其他变量。`ansible_ssh_host`变量允许您设置不同的主机名，`ansible_ssh_port`变量允许您设置不同的端口，这在`site01-dr`主机上进行了演示。最后，`db01`主机使用用户名`fred`，并使用`ansible_ssh_private_key_file`设置了私钥。
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you aren't comfortable with giving Ansible direct access to the root account
    on the managed machines, or your machine does not allow SSH access to the root
    account (such as Ubuntu's default configuration), you can configure Ansible to
    obtain root access using `sudo`. Using Ansible with `sudo` means that you can
    enforce auditing the same way you would otherwise. Configuring Ansible to use
    `sudo` is as simple as it is to configure the port, except that it requires `sudo`
    to be configured on the managed machine.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不愿意让Ansible直接访问受管机器上的root帐户，或者您的机器不允许SSH访问root帐户（例如Ubuntu的默认配置），您可以配置Ansible使用`sudo`来获取root访问权限。使用`sudo`的Ansible意味着您可以强制执行与以前相同的审计。配置Ansible使用`sudo`与配置端口一样简单，只是它需要在受管机器上配置`sudo`。
- en: 'The first step is to add a line to the `/etc/sudoers` file; on the managed
    node, this may already be set up if you choose to use your own account. You can
    use a password with `sudo`, or you can use a passwordless `sudo`. If you decide
    to use a password, you will need to use the `-k` argument to Ansible, or set the
    `ask_sudo_pass` value to `true` in `/etc/ansible/ansible.cfg`. To make Ansible
    use sudo, add `--sudo` to the command line like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是向`/etc/sudoers`文件添加一行；在受管节点上，如果选择使用自己的帐户，可能已经设置了这个。您可以使用`sudo`密码，也可以使用无密码`sudo`。如果决定使用密码，您将需要使用`-k`参数到Ansible，或者在`/etc/ansible/ansible.cfg`中将`ask_sudo_pass`值设置为`true`。要使Ansible使用sudo，请在命令行中添加`--sudo`。
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If this works, it should return something similar to:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样做，它应该返回类似于以下内容：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Setting it up on Windows
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Windows上设置它
- en: Ansible recently added the ability to manage Windows machines. Now, you can
    use Ansible to easily manage Windows machines the same way you manage your Linux
    machines.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Ansible添加了管理Windows机器的功能。现在，您可以使用Ansible轻松管理Windows机器，就像管理Linux机器一样。
- en: This uses the Windows PowerShell Remoting tools in the same way that SSH is
    used on a Linux machine to execute modules remotely. Several new modules have
    been added that explicitly support Windows, but some existing modules have also
    been given the ability to work with Windows-managed machines.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用Windows PowerShell远程工具，就像在Linux机器上使用SSH一样，远程执行模块。已添加了几个新模块，明确支持Windows，但还为一些现有模块提供了与Windows管理的机器一起工作的能力。
- en: 'To get started with managing your Windows machine, you do have to perform a
    little bit of complex setup. You need to follow these steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始管理Windows机器，您必须执行一些复杂的设置。您需要按照以下步骤操作：
- en: Create some Windows machines in your inventory
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在清单中创建一些Windows机器
- en: Install Python-winrm to allow Ansible to connect to the Windows machines
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Python-winrm以允许Ansible连接到Windows机器
- en: Upgrade to PowerShell 3.0+ to support Windows modules
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 升级到PowerShell 3.0+以支持Windows模块
- en: Enable Windows remoting so that Ansible can connect
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用Windows远程，以便Ansible可以连接
- en: 'Windows machines are created the same way as all the other machines that you
    have in your inventory. They are differentiated by the value of the `ansible_connection`
    variable. When `ansible_connection` is set to `winrm`, it will try to connect
    via winrm to Windows PowerShell on the remote machine. Ansible also uses the `ansible_ssh_user`,
    `ansible_ssh_pass`, and `ansible_ssh_port` values like it would on your other
    machine. Despite having the name ssh in them, they are used to provide the port
    and credentials that will be used to connect to the Windows PowerShell Remoting
    service. Here is what an example Windows machine might look like:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Windows机器与清单中的所有其他机器以相同的方式创建。它们通过`ansible_connection`变量的值进行区分。当`ansible_connection`设置为`winrm`时，它将尝试通过winrm连接到远程计算机上的Windows
    PowerShell。Ansible还使用`ansible_ssh_user`，`ansible_ssh_pass`和`ansible_ssh_port`值，就像在其他机器上一样。尽管它们的名称中有ssh，但它们用于提供将用于连接到Windows
    PowerShell远程服务的端口和凭据。以下是示例Windows机器的样子：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For security reasons, you probably will not want to store the password in the
    inventory file. You can make Ansible prompt for the password the same way we showed
    previously for Unix systems by simply leaving off the `ansible_ssh_user` and `ansible_ssh_pass`
    variables and instead using the `-k` and `-u` arguments to Ansible if you wish.
    You might also choose to store them in an Ansible vault, which will be covered
    later in the book.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全原因，您可能不希望将密码存储在清单文件中。您可以通过简单地省略`ansible_ssh_user`和`ansible_ssh_pass`变量，并使用Ansible的`-k`和`-u`参数来让Ansible提示输入密码，就像我们之前为Unix系统展示的那样。您也可以选择将它们存储在Ansible保险库中，这将在本书的后面介绍。
- en: After you have created the inventory, you need to install the winrm Python library
    on the controller machine. This library will give Ansible the ability to connect
    to the Windows Remote Management service and configure a remote Windows system.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建清单后，您需要在控制器机器上安装winrm Python库。这个库将使Ansible能够连接到Windows远程管理服务并配置远程Windows系统。
- en: 'At the moment, this library is fairly experimental, and its connection to Ansible
    isn''t quite perfect, so you have to install the particular version that matches
    the version of Ansible you are using. With the release of Ansible 1.8, this should
    sort things out a little bit. Most distributions do not have a packaged library
    yet, so you will probably want to install it via pip. As root, you need to run:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个库还相当实验性，并且它与Ansible的连接并不完美，因此您必须安装与您使用的Ansible版本相匹配的特定版本。随着Ansible 1.8的发布，这应该会稍微解决一些问题。大多数发行版尚未打包该库，因此您可能希望通过pip安装它。作为root用户，您需要运行：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, for newer versions, you should simply be able to run:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于更新版本，您应该能够直接运行：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will install the particular version of winrm that works with Ansible 1.7\.
    For other newer versions of Ansible, you may need a different version, and eventually
    the winrm Python library should be packaged up by different distributions. Your
    machine will now be able to connect to and manage Windows machines with Ansible.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装与Ansible 1.7兼容的特定版本的winrm。对于其他更新版本的Ansible，您可能需要不同的版本，最终winrm Python库应该由不同的发行版打包。您的机器现在将能够连接到并管理Windows机器与Ansible。
- en: 'Next you have to perform a few setup steps on the machine you are going to
    manage. The first of these is to make sure that you have PowerShell 3.0 or later
    installed. You can check what version you have installed with the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要在要管理的机器上执行一些设置步骤。其中第一步是确保您已安装了PowerShell 3.0或更高版本。您可以使用以下命令检查已安装的版本：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the value you get back is not 3 or higher than 3, then you will need to upgrade
    your version of PowerShell. You can choose to do this manually by downloading
    and installing the latest Windows Management Framework for your system, or you
    can use a script provided by the Ansible project. To save space, we will be explaining
    the scripted installation here; the manual installation is left as an exercise
    for the reader.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您收到的值不是3或高于3，则需要升级您的PowerShell版本。您可以选择通过手动下载和安装最新的Windows管理框架来完成此操作，或者您可以使用Ansible项目提供的脚本。为了节省空间，我们将在此处解释脚本化安装；手动安装留给读者作为练习。
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first command downloads the upgrade script from the Ansible project repository
    on GitHub and saves it to disk. The second command will detect your operating
    system to download the correct version of the Windows Management Framework and
    install it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令从GitHub上的Ansible项目存储库下载升级脚本并将其保存到磁盘上。第二个命令将检测您的操作系统以下载正确版本的Windows管理框架并安装它。
- en: 'Next you need to configure the Windows Remote Management Service. The Ansible
    project provides a script that will configure Windows Remote Management automatically
    in the way that Ansible expects it to be configured. While you can set it up manually,
    it is highly recommended that you use this script instead to prevent misconfiguration.
    To download and run this script, open a PowerShell terminal and run the following
    commands:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要配置Windows远程管理服务。Ansible项目提供了一个脚本，将自动配置Windows远程管理，以符合Ansible的预期配置方式。虽然您可以手动设置它，但强烈建议您使用此脚本，以防止错误配置。要下载并运行此脚本，请打开PowerShell终端并运行以下命令：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first command downloads the configuration script from the Ansible project
    on GitHub, and the second command runs it. You should receive the output `Ok`
    from the second script if everything worked correctly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令从GitHub上的Ansible项目下载配置脚本，第二个命令运行它。如果一切正常，您应该从第二个脚本中收到`Ok`的输出。
- en: You should now be able to connect to your machine and configure it with Ansible.
    As we did earlier, let's run a ping command to confirm that Ansible is able to
    execute its modules remotely. While Unix machines can use the `ping` module, Windows
    machines use the `win_ping` module. The usage is almost exactly the same; however,
    as we've added the password to the inventory file, you don't need the `-k` option.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够连接到您的机器并使用Ansible对其进行配置。与之前一样，让我们运行一个ping命令来确认Ansible能够远程执行其模块。虽然Unix机器可以使用`ping`模块，但Windows机器使用`win_ping`模块。使用方式几乎完全相同；但是，由于我们已将密码添加到清单文件中，您不需要`-k`选项。
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If everything works correctly, you should see the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，您应该看到以下输出：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output indicates that Ansible was able to connect to the Windows Remote
    Management Service, login successfully, and execute a module on the remote host.
    If this works correctly, then you should be able to use all the other Windows
    modules to manage your machine.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明Ansible能够连接到Windows远程管理服务，成功登录并在远程主机上执行模块。如果这个工作正常，那么您应该能够使用所有其他Windows模块来管理您的机器。
- en: First steps with Ansible
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible的第一步
- en: Ansible modules take arguments in key-value pairs that look similar to `key=value`,
    perform a job on the remote server, and return information about the job as `JSON`.
    The key-value pairs allow the module to know what to do when requested. They can
    be hardcoded values, or in playbooks they can use variables, which will be covered
    in [Chapter 2](ch02.html "Chapter 2. Simple Playbooks"), *Simple Playbooks*. The
    data returned from the module lets Ansible know if anything changed in the managed
    host or if any information kept by Ansible should be changed afterwards.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible模块以类似于`key=value`的键值对形式接受参数，在远程服务器上执行任务，并将有关任务的信息返回为`JSON`。键值对允许模块在请求时知道该做什么。它们可以是硬编码的值，或者在playbooks中可以使用变量，这将在[第2章](ch02.html
    "第2章。简单的Playbooks")中进行介绍，*简单的Playbooks*。模块返回的数据让Ansible知道托管主机是否有任何更改，或者之后是否应该更改Ansible保存的任何信息。
- en: Modules are usually run within playbooks, as this lets you chain many together,
    but they can also be used on the command line. Previously, we used the `ping`
    command to check that Ansible had been correctly setup and was able to access
    the configured node. The `ping` module only checks that the core of Ansible is
    able to run on the remote machine, but effectively does nothing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 模块通常在playbooks中运行，因为这样可以将许多模块链接在一起，但也可以在命令行上使用。之前，我们使用`ping`命令来检查Ansible是否已正确设置并能够访问配置的节点。`ping`模块只检查Ansible的核心是否能够在远程机器上运行，但实际上什么也不做。
- en: A slightly more useful module is named `setup`. This module connects to the
    configured node, gathers data about the system, and then returns those values.
    This isn't particularly handy for us while running from the command line. However,
    in a playbook, you can use the gathered values later in other modules.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微更有用的模块名为`setup`。该模块连接到配置的节点，收集有关系统的数据，然后返回这些值。在命令行中运行时，这对我们来说并不特别方便。但是，在playbook中，您可以稍后在其他模块中使用收集到的值。
- en: To run Ansible from the command line, you need to pass two things, though usually
    three. First is a host pattern to match the machine that you want to apply the
    module to. Second you need to provide the name of the module that you wish to
    run and optionally any arguments that you wish to give to the module. For the
    host pattern, you can use a group name, a machine name, a glob, and a tilde (~),
    followed by a regular expression matching hostnames. Alternatively, to symbolize
    all of these, you can either use the word `all` or simply `*`. Running Ansible
    modules on the command line this way is referred to as an ad hoc Ansible command.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令行运行Ansible，您需要传递两个参数，通常是三个。首先是要匹配要应用模块的机器的主机模式。其次，您需要提供要运行的模块的名称，以及可选的要传递给模块的参数。对于主机模式，您可以使用组名、机器名、通配符和波浪号(~)，后跟与主机名匹配的正则表达式。或者，为了表示所有这些，您可以使用单词`all`或简单地使用`*`。以这种方式在命令行上运行Ansible模块被称为临时的Ansible命令。
- en: 'To run the `setup` module on one of your nodes, you need the following command
    line:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的节点之一上运行`setup`模块，您需要以下命令行：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `setup` module will then connect to the machine and give you a number of
    useful facts back. All the facts provided by the `setup` module itself are prepended
    with `ansible_` to differentiate them from variables.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup`模块将连接到机器并返回一些有用的事实。`setup`模块本身提供的所有事实都以`ansible_`开头，以区别于变量。'
- en: This module will work on both Windows and Unix machines. Currently, Unix machines
    will give much more information than a Windows machine. However, as new versions
    of Ansible are released, you can expect to see more Windows functionality get
    included along with Ansible.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块将在Windows和Unix机器上运行。目前，Unix机器将提供比Windows机器更多的信息。但是，随着Ansible的新版本发布，您可以期望看到更多的Windows功能被包含在Ansible中。
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The following is a table of the most common values you will use; not all of
    these will be available on all machines. Windows machines especially return a
    lot less data from the setup module.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您将使用的最常见值的表格；并非所有这些值都适用于所有机器。特别是Windows机器从setup模块返回的数据要少得多。
- en: '| Field | Example | Description |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 示例 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ansible_architecture` | x86_64 | This is the architecture of the managed
    machine |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_architecture` | x86_64 | 这是托管机器的架构 |'
- en: '| `ansible_distribution` | CentOS | This is the Linux or Unix distribution
    on the managed machine |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_distribution` | CentOS | 这是托管机器上的Linux或Unix发行版 |'
- en: '| `ansible_distribution_version` | 6.3 | This is the version of the preceding
    distribution |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_distribution_version` | 6.3 | 这是先前发行版的版本 |'
- en: '| `ansible_domain` | example.com | This is the domain name part of the server''s
    hostname |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_domain` | example.com | 这是服务器主机名的域名部分 |'
- en: '| `ansible_fqdn` | machinename.example.com | This is the fully qualified domain
    name of the managed machine |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_fqdn` | machinename.example.com | 这是托管机器的完全限定域名 |'
- en: '| `ansible_interfaces` | ["lo", "eth0"] | This is a list of all the interfaces
    the machine has, including the loopback interface |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_interfaces` | ["lo", "eth0"] | 这是机器拥有的所有接口的列表，包括环回接口 |'
- en: '| `ansible_kernel` | 2.6.32-279.el6.x86_64 | This is the kernel version installed
    on the managed machine |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_kernel` | 2.6.32-279.el6.x86_64 | 这是托管机器上安装的内核版本 |'
- en: '| `ansible_memtotal_mb` | 996 | This is the total memory in megabytes available
    on the managed machine |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_memtotal_mb` | 996 | 这是托管机器上可用的总内存（以兆字节为单位） |'
- en: '| `ansible_processor_count` | 1 | These are the total number of CPUs available
    on the managed machine |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_processor_count` | 1 | 这是托管机器上可用的CPU总数 |'
- en: '| `ansible_virtualization_role` | guest | This determines whether the machine
    is a guest or a host machine |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_virtualization_role` | guest | 这确定了机器是客户机还是主机机器 |'
- en: '| `ansible_virtualization_type` | kvm | This is the type of virtualization
    setup on the managed machine |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `ansible_virtualization_type` | kvm | 这是托管机器上的虚拟化设置的类型 |'
- en: On a Unix machine, these variables are gathered using Python from the managed
    machine; if you have facter or ohai installed on the remote node, the `setup`
    module will execute them and return their data as well. As with other facts, ohai
    facts are prepended with `ohai_` and facter facts with `facter_`. While the setup
    module doesn't appear to be too useful on the command line, it is useful once
    you start writing playbooks. Note that facter and ohai are not available in Windows
    hosts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix机器上，这些变量是使用Python从受控机器中收集的；如果在远程节点上安装了facter或ohai，`setup`模块将执行它们并返回它们的数据。与其他事实一样，ohai事实以`ohai_`开头，facter事实以`facter_`开头。虽然`setup`模块在命令行上似乎不太有用，但一旦开始编写playbooks，它就会变得有用。请注意，facter和ohai在Windows主机上不可用。
- en: If all the modules in Ansible do as little as the `setup` and the `ping` module,
    we will not be able to change anything on the remote machine. Almost all of the
    other modules that Ansible provides, such as the `file` module, allow us to actually
    configure the remote machine.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Ansible中的所有模块都像`setup`和`ping`模块那样少，我们将无法在远程机器上进行任何更改。几乎所有Ansible提供的其他模块，如`file`模块，都允许我们实际配置远程机器。
- en: The `file` module can be called with a single path argument; this will cause
    it to return information about the file in question. If you give it more arguments,
    it will try and alter the file's attributes and tell you if it has changed anything.
    Ansible modules will tell you if they have changed anything, which becomes more
    important when you are writing playbooks.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`file`模块可以使用单个路径参数调用；这将导致它返回有关所讨论文件的信息。如果给它更多的参数，它将尝试更改文件的属性，并告诉您是否已更改了任何内容。Ansible模块将告诉您是否已更改任何内容，这在编写playbooks时变得更加重要。'
- en: 'You can call the `file` module, as shown in the following command, to see details
    about `/etc/fstab`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以调用`file`模块，如以下命令所示，以查看有关`/etc/fstab`的详细信息：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding command should elicit a response like the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令应该引发以下响应：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Alternatively, the response could be something like the following command to
    create a new test directory in `/tmp`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，响应可能是类似以下命令以在`/tmp`中创建一个新的测试目录：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding command should return something like the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令应该返回类似以下内容：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can see that the changed variable is set to `true` in the response, because
    the directory doesn't exist or has different attributes and changes were required
    to make it match the state given by the provided arguments. If it is run a second
    time with the same arguments, the value of changed will be set to `false`, which
    means that the module did not make any changes to the system.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在响应中将`changed`变量设置为`true`，因为目录不存在或具有不同的属性，并且需要进行更改以使其与提供的参数给出的状态匹配。如果使用相同的参数再次运行它，`changed`的值将设置为`false`，这意味着该模块没有对系统进行任何更改。
- en: 'There are several modules that accept similar arguments to the `file` module,
    and one such example is the `copy` module. The `copy` module takes a file on the
    controller machine, copies it to the managed machine, and sets the attributes
    as required. For example, to copy the `/etc/fstab` file to `/tmp` on the managed
    machine, you will use the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个模块接受与“file”模块类似的参数，其中一个例子是“copy”模块。`copy`模块在控制器机器上获取一个文件，将其复制到受控机器，并根据需要设置属性。例如，要将`/etc/fstab`文件复制到受控机器上的`/tmp`，您将使用以下命令：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding command, when run the first time, should return something like
    the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行上述命令时，应该返回类似以下内容：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There is also a module named `command` that will run any arbitrary command on
    the managed machine. This lets you configure it with any arbitrary command, such
    as a `preprovided` installer or a self-written script; it is also useful for rebooting
    machines. Note that this module does not run the command within the shell, so
    you cannot perform redirection, use pipes, expand shell variables, or background
    commands.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为`command`的模块，它将在受控机器上运行任意命令。这使您可以配置它以运行任意命令，例如`preprovided`安装程序或自编写脚本；它还可用于重新启动机器。请注意，此模块不在shell中运行命令，因此无法执行重定向、使用管道、扩展shell变量或后台命令。
- en: Ansible modules strive to prevent changes being made when they are not required.
    This is referred to as idempotency and can make running commands against multiple
    servers much faster. Unfortunately, Ansible cannot know if your command has changed
    anything or not, so to help it be more idempotent, you have to give it some help.
    It can do this either via the `creates` or the `removes` argument. If you give
    a `creates` argument, the command will not run if the filename argument exists.
    The opposite is true of the `removes` argument; if the filename exists, the command
    will run.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible模块努力防止在不需要时进行更改。这被称为幂等性，并且可以使针对多个服务器运行命令变得更快。不幸的是，Ansible无法知道您的命令是否已更改任何内容，因此为了帮助它更具幂等性，您必须给它一些帮助。它可以通过`creates`或`removes`参数来实现。如果给出`creates`参数，如果文件名参数存在，则不会运行命令。`removes`参数则相反；如果文件名存在，则会运行命令。
- en: 'You can run the command as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式运行该命令：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If there is no file or directory named `/tmp/testing`, the command output will
    indicate that it was skipped, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有名为`/tmp/testing`的文件或目录，则命令输出将指示它已被跳过，如下所示：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Otherwise, if the file did exist, it will look like the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果文件存在，它将如下所示的代码：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Often it is better to use another module in place of the `command` module.
    Other modules offer more options and can better capture the problem domain they
    work in. For example, it would be much less work for Ansible and also the person
    writing the configurations to use the `file` module in this instance, since the
    `file` module will recursively delete something if the state is set to `absent`.
    So the preceding command would be equivalent to the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好使用`command`模块的替代模块。其他模块提供更多选项，并且可以更好地捕捉它们所在的问题领域。例如，在这种情况下，使用`file`模块比使用`command`模块要少得多，因为如果状态设置为`absent`，`file`模块将递归删除某些内容。因此，前面的命令等同于以下命令：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you need to use features usually available in a shell while running your
    command, you will need the `shell` module. This way you can use redirection, pipes,
    or job back grounding. You can pick which shell to use with the executable argument.
    You can use the `shell` module as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在运行命令时使用通常在shell中可用的功能，您将需要`shell`模块。这样您就可以使用重定向、管道或作业后台。您可以使用可执行参数选择要使用的shell。您可以按以下方式使用`shell`模块：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Module help
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块帮助
- en: Unfortunately, we don't have enough space to cover every module that is available
    in Ansible; luckily though, Ansible includes a command name `ansible-doc` that
    can retrieve help information. All the modules included within Ansible have this
    data populated; however, with modules gathered from elsewhere you may find less
    help. The `ansible-doc` command also allows you to see a list of all modules available
    to you.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们没有足够的空间来涵盖Ansible中可用的每个模块；幸运的是，Ansible包含一个名为`ansible-doc`的命令，可以检索帮助信息。所有包含在Ansible中的模块都有这些数据；然而，对于从其他地方收集的模块，您可能会找到更少的帮助。`ansible-doc`命令还允许您查看可用的所有模块列表。
- en: 'To get a list of all the modules that are available to you along with a short
    description of each type, use the following command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取可用模块的列表以及每种类型的简短描述，请使用以下命令：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To see the help file for a particular module, you supply it as the single argument
    to `ansible-doc`. To see the help information for the `file` module, for example,
    use the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看特定模块的帮助文件，将其作为`ansible-doc`的单个参数提供。例如，要查看`file`模块的帮助信息，请使用以下命令：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have covered which installation type to choose for installing
    Ansible and how to build an inventory file to reflect your environment. After
    this we saw how to use Ansible modules in an ad hoc style for simple tasks. Finally
    we discussed how to learn which modules are available on your system and how to
    use the command line to get instructions for using a module.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经介绍了选择安装类型以安装Ansible以及如何构建清单文件以反映您的环境。之后，我们看到了如何以临时方式使用Ansible模块来执行简单任务。最后，我们讨论了如何了解系统上可用的模块以及如何使用命令行获取使用模块的说明。
- en: In the next chapter, you will learn how to use many modules together in a playbook.
    This allows you to perform more complex tasks than you could do with single modules
    alone.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何在playbook中一起使用多个模块。这使您能够执行比单个模块更复杂的任务。
