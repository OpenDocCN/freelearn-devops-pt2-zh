- en: 3\. Introduction to Serverless Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 无服务器框架简介
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，你将能够：
- en: Compare and effectively utilize different serverless functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较并有效地利用不同的无服务器函数
- en: Set up a cloud-agnostic and container-native serverless framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立一个与云无关且容器本地的无服务器框架
- en: Create, deploy, and invoke a function using the Fn framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Fn框架创建、部署和调用一个函数
- en: Deploy serverless functions to cloud providers using serverless frameworks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无服务器框架将无服务器函数部署到云提供商
- en: Create a real-life serverless application and run it on multiple cloud platforms
    in the future
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在未来在多个云平台上创建一个真实的无服务器应用程序并运行它
- en: In this chapter, we will explain serverless frameworks, create our first serverless
    functions using these frameworks, and deploy them to various cloud providers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释无服务器框架，使用这些框架创建我们的第一个无服务器函数，并将它们部署到各种云提供商。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: Let's imagine that you are developing a complex application with many functions
    in one cloud provider. It may not be feasible to move to another cloud provider,
    even if the new one is cheaper, faster, or more secure. This situation of vendor
    dependency is known as **vendor lock-in** in the industry, and it is a very critical
    decision factor in the long run. Fortunately, serverless frameworks are a simple
    and efficient solution to vendor lock-in.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，你正在开发一个在一个云提供商中有许多函数的复杂应用程序。即使新的云提供商更便宜、更快或更安全，也可能无法迁移。这种供应商依赖的情况在行业中被称为**供应商锁定**，这在长期来看是一个非常关键的决策因素。幸运的是，无服务器框架是供应商锁定的一个简单而有效的解决方案。
- en: 'In the previous chapter, all three major cloud providers and their serverless
    products were discussed. These products were compared based on their programming
    language support, trigger capabilities, and cost structure. However, there is
    still one unseen critical difference between all three products: *operations*.
    Creating functions, deploying them to cloud providers, and their management are
    all different for each cloud provider. In other words, you cannot use the same
    function in AWS Lambda, Google Cloud Functions, and Azure Functions. Various changes
    are required so that we can fulfil the requirements of cloud providers and their
    runtime.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，讨论了所有三个主要的云提供商及其无服务器产品。这些产品是基于它们的编程语言支持、触发能力和成本结构进行比较的。然而，所有三个产品之间仍然存在一个看不见的关键差异：*运维*。在每个云提供商中，创建函数、部署它们以及它们的管理都是不同的。换句话说，你不能在AWS
    Lambda、Google Cloud Functions和Azure Functions中使用相同的函数。需要进行各种更改，以满足云提供商及其运行时的要求。
- en: Serverless frameworks are **open source**, **cloud-agnostic** platforms for
    running serverless applications. The first difference between the cloud provider
    and serverless products is that their serverless frameworks are open source and
    public. They are free to install on the cloud or on on-premise systems and operate
    on their own. The second characteristic is that serverless frameworks are **cloud
    agnostic**. This means that it is possible to run the same serverless functions
    on different cloud providers or your own systems. In other words, the cloud provider
    where the functions will be executed is just a configuration parameter in serverless
    frameworks. All cloud providers are equalized behind a shared API so that cloud-agnostic
    functions can be developed and deployed by serverless frameworks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器框架是用于运行无服务器应用程序的开源、与云无关的平台。云提供商和无服务器产品之间的第一个区别是，它们的无服务器框架是开源和公开的。它们可以免费安装在云上或本地系统上，并且可以独立运行。第二个特点是无服务器框架是与云无关的。这意味着可以在不同的云提供商或自己的系统上运行相同的无服务器函数。换句话说，函数将在哪个云提供商上执行只是无服务器框架中的一个配置参数。所有云提供商都在共享API后面被平等化，以便无服务器框架可以开发和部署与云无关的函数。
- en: Cloud serverless platforms such as AWS Lambda increased the hype of serverless
    architectures and empowered their adoption in the industry. In the previous chapter,
    the evolution of cloud technology offerings over the years and significant cloud
    serverless platforms were discussed in depth. In this chapter, we will discuss
    open source serverless frameworks and talk about their featured characteristics
    and functionalities. There are many popular and upcoming serverless frameworks
    on the market. However, we will focus on two prominent frameworks with differences
    in terms of priorities and architecture. In this chapter, a container-native serverless
    framework, namely **Fn**, will be presented. Following that, a more comprehensive
    framework with multiple cloud provider support, namely, the **Serverless Framework**,
    will be discussed in depth. Although both frameworks create a cloud-agnostic and
    open source environment for running serverless applications, their differences
    in terms of implementation and developer experience will be illustrated.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 像AWS Lambda这样的云无服务器平台增加了无服务器架构的热度，并促进了其在行业中的采用。在前一章中，深入讨论了多年来云技术产品的演变和重要的云无服务器平台。在本章中，我们将讨论开源无服务器框架，并谈论它们的特色和功能。市场上有许多受欢迎的和即将推出的无服务器框架。然而，我们将重点关注两个在优先级和架构方面有所不同的杰出框架。在本章中，将介绍一个容器本地化的无服务器框架，即Fn。随后，将深入讨论一个具有多个云提供商支持的更全面的框架，即Serverless
    Framework。尽管这两个框架都为运行无服务器应用程序创建了一个与云无关且开源的环境，但它们在实施和开发者体验方面的差异将被说明。
- en: Fn Framework
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fn框架
- en: 'Fn was announced in 2017 by **Oracle** at the *JavaOne 2017* conference as
    an event-driven and open source **Function-as-a-Service** (**FaaS**) platform.
    The key characteristics of the framework are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Fn是由Oracle在2017年的JavaOne 2017大会上宣布的，是一个面向事件驱动和开源的函数即服务（FaaS）平台。该框架的关键特点如下：
- en: '**Open source:** All the source code of the `Fn` project is publicly available
    at [https://github.com/fnproject/fn](https://github.com/fnproject/fn), and the
    project is hosted at [https://fnproject.io](https://fnproject.io). It has an active
    community on GitHub, with more than 3,300 commits and 1,100 releases, as shown
    in the following screenshot:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开源：Fn项目的所有源代码都可以在[https://github.com/fnproject/fn](https://github.com/fnproject/fn)上公开获取，并且该项目托管在[https://fnproject.io](https://fnproject.io)上。它在GitHub上有一个活跃的社区，有超过3300次提交和1100次发布，如下面的截图所示：
- en: '![Figure 3.1: Fn at GitHub ](image/C12607_03_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1：Fn在GitHub上](image/C12607_03_01.jpg)'
- en: 'Figure 3.1: Fn at GitHub'
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.1：Fn在GitHub上
- en: '**Container-native:** Containers and microservices have changed the manner
    of software development and operations. `Fn` is container-native, meaning that
    each function is packaged and deployed as a Docker container. Also, it is possible
    to create your own Docker container and run them as functions.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器本地：** 容器和微服务改变了软件开发和运维的方式。`Fn`是容器本地的，意味着每个函数都被打包并部署为Docker容器。此外，您可以创建自己的Docker容器并将其作为函数运行。'
- en: '**Language support:** The framework officially supports **Go**, **Java**, **Node.js**,
    **Ruby**, and **Python**. In addition, **C#** is supported by the community.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言支持：** 该框架正式支持**Go**，**Java**，**Node.js**，**Ruby**和**Python**。此外，**C#**由社区支持。'
- en: '**Cloud-agnostic:** `Fn` can run on every cloud provider or on-premise system,
    as long as Docker is installed and running. This is the most critical characteristic
    of `Fn`, since it avoids the vendor lock-in problem completely. If the functions
    do not depend on any cloud-specific service, it is possible to move between cloud
    providers and on-premise systems quickly.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与云无关：** 只要安装并运行Docker，`Fn`就可以在每个云提供商或本地系统上运行。这是`Fn`最关键的特性，因为它完全避免了供应商锁定问题。如果函数不依赖于任何特定于云的服务，就可以快速在云提供商和本地系统之间移动。'
- en: As a cloud-agnostic and container-native platform, `Fn` is a developer-focused
    framework. It enhances developer experience and agility since you can develop,
    test, and debug locally and deploy to cloud with the same tooling. In the following
    exercise, we will install and configure `Fn` so that we can start using the framework.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个与云无关和容器本地的平台，`Fn`是一个面向开发人员的框架。它增强了开发人员的体验和灵活性，因为您可以在本地开发、测试和调试，并使用相同的工具部署到云端。在接下来的练习中，我们将安装和配置`Fn`，以便开始使用该框架。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Docker `17.10.0-ce` or later should be installed and running on your computer
    before you start the next exercise, since this is a prerequisite for `Fn`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始下一个练习之前，您的计算机上应安装并运行Docker `17.10.0-ce`或更高版本，因为这是`Fn`的先决条件。
- en: 'Exercise 7: Getting Started with the Fn Framework'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习7：使用Fn框架入门
- en: In this exercise, you will install and configure a cloud-agnostic and container-native
    serverless framework on your local computer. The aim of this exercise is to illustrate
    how straightforward it is to configure and install the Fn Framework so that you
    can get started with serverless frameworks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将在本地计算机上安装和配置一个与云无关和容器本地的无服务器框架。此练习的目的是演示配置和安装Fn框架是多么简单，以便您可以开始使用无服务器框架。
- en: 'To complete this exercise successfully, we need to ensure that the following
    steps are executed:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功完成此练习，我们需要确保执行以下步骤：
- en: 'In your Terminal, type the following command:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中，键入以下命令：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command downloads and installs the Fn framework. Once this is complete,
    the version number is printed out, as shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将下载并安装Fn框架。完成后，版本号将被打印出来，如下截图所示：
- en: '![Figure 3.2: Installation of Fn'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2：Fn的安装'
- en: '](image/C12607_03_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_02.jpg)'
- en: 'Figure 3.2: Installation of Fn'
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.2：Fn的安装
- en: 'Start the `Fn` server by using the following command in your Terminal:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在您的终端中启动`Fn`服务器：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This command downloads the Docker image of the `Fn` server and starts it inside
    a container, as shown in the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将下载`Fn`服务器的Docker镜像，并在容器内启动，如下截图所示：
- en: '![Figure 3.3: Starting the Fn server'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3：启动Fn服务器'
- en: '](image/C12607_03_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_03.jpg)'
- en: 'Figure 3.3: Starting the Fn server'
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.3：启动Fn服务器
- en: 'Check the client and server version by using the following command in your
    Terminal:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在您的终端中检查客户端和服务器版本：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output should be as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 3.4: Fn server and client version'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4：Fn 服务器和客户端版本'
- en: '](image/C12607_03_04.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_04.jpg)'
- en: 'Figure 3.4: Fn server and client version'
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.4：Fn 服务器和客户端版本
- en: This output shows that both the client and server side are running and interacting
    with each other.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示客户端和服务器端都在运行并相互交互。
- en: 'Update the current Fn context and set a local development registry:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新当前的 Fn 上下文并设置本地开发注册表：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is shown in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下截图所示：
- en: '![Figure 3.5: Registry setup for the current context'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5：当前上下文的注册表设置'
- en: '](image/C12607_03_05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_05.jpg)'
- en: 'Figure 3.5: Registry setup for the current context'
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.5：当前上下文的注册表设置
- en: As the output indicates, the `default` context is set, and the registry is updated
    to `serverless`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，设置了`default`上下文，并将注册表更新为`serverless`。
- en: 'Start the `Fn` dashboard by using the following command in your Terminal:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在终端中启动`Fn`仪表板：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command downloads the `fnproject/ui` image and starts it in `detached`
    mode. In addition, it links `fnserver:api` to itself and publishes the `4000`
    port, as shown in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令下载`fnproject/ui`镜像并以`detached`模式启动。此外，它将`fnserver:api`链接到自身并发布`4000`端口，如下截图所示：
- en: '![Figure 3.6: Starting the Fn UI'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6：启动 Fn UI'
- en: '](image/C12607_03_06.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_06.jpg)'
- en: 'Figure 3.6: Starting the Fn UI'
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.6：启动 Fn UI
- en: 'Check the running Docker containers with the following command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查正在运行的 Docker 容器：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As expected, two containers are running for `Fn` with the image names `fnproject/ui`
    and `fnproject/fnserver:latest`, respectively, as shown in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，有两个运行中的`Fn`容器，分别使用镜像名称`fnproject/ui`和`fnproject/fnserver:latest`，如下截图所示：
- en: '![Figure 3.7: Docker containers'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7：Docker 容器'
- en: '](image/C12607_03_07.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_07.jpg)'
- en: 'Figure 3.7: Docker containers'
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.7：Docker 容器
- en: Open `http://localhost:4000` in your browser to check the Fn UI.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`http://localhost:4000`来检查 Fn UI。
- en: 'The Fn Dashboard lists the applications and function statistics as a web application,
    as shown in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Fn 仪表板列出了应用程序和函数统计信息，作为一个 web 应用程序，如下截图所示：
- en: '![Figure 3.8: Fn Dashboard'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8：Fn 仪表板'
- en: '](image/C12607_03_08.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_08.jpg)'
- en: 'Figure 3.8: Fn Dashboard'
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.8：Fn 仪表板
- en: With this exercise, we have installed the `Fn` framework, along with its client,
    server, and dashboard. Since `Fn` is a cloud-agnostic framework, it is possible
    to install any cloud or on-premise system with the illustrated steps. We will
    continue discussing the `Fn` framework in terms of how the functions are configured
    and deployed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，我们已经安装了`Fn`框架，以及它的客户端、服务器和仪表板。由于`Fn`是一个与云无关的框架，可以使用所示步骤安装任何云或本地系统。我们将继续讨论`Fn`框架，讨论函数如何配置和部署。
- en: 'The `Fn` framework is designed to work with applications, where each application
    is a group of functions with their own route mappings. For instance, let''s assume
    you have grouped your functions into a folder, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fn`框架设计用于处理应用程序，其中每个应用程序都是一组具有自己路由映射的函数。例如，假设您已将函数分组到一个文件夹中，如下所示：'
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In each folder, there is a `func.yaml` file that defines the function with the
    corresponding implementation in `Ruby`, `Node.js`, or any other supported language.
    In addition, there is an `app.yaml` file in the root folder to define the application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个文件夹中，都有一个`func.yaml`文件，用于定义对应的`Ruby`、`Node.js`或其他支持的语言的函数实现。此外，根文件夹中还有一个`app.yaml`文件用于定义应用程序。
- en: 'Let''s start by checking the content of `app.yaml`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查`app.yaml`的内容开始：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`app.yaml` is used to define the root of the serverless application and includes
    the name of the application. There are also three additional files for the function
    in the root folder:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.yaml`用于定义无服务器应用程序的根目录，并包括应用程序的名称。根文件夹中还有三个额外的文件用于函数：'
- en: '`func.go`: Go implementation code'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func.go`：Go实现代码'
- en: '`go.mod`: Go dependency definitions'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go.mod`：Go依赖定义'
- en: '`func.yaml`: Function definition and trigger information'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func.yaml`：函数定义和触发器信息'
- en: 'For a function with an HTTP trigger and Go runtime, the following `func.yaml`
    file is defined:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于带有HTTP触发器和Go运行时的函数，定义了以下`func.yaml`文件：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you deploy all of these functions to Fn, they will be accessible via the
    following URLs:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将所有这些函数部署到Fn时，它们将通过以下URL可访问：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the following exercise, the content of the `app.yaml` and `func.yaml` files,
    as well as their function implementation, will be illustrated with a real-life
    example.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，将用一个真实的例子来说明`app.yaml`和`func.yaml`文件的内容以及它们的函数实现。
- en: 'Exercise 8: Running Functions in the Fn Framework'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习8：在Fn框架中运行函数
- en: In this exercise, we aim to create, deploy, and invoke a function using the
    `Fn` framework.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们的目标是使用`Fn`框架创建、部署和调用一个函数。
- en: 'To complete this exercise successfully, we need to ensure that the following
    steps are executed:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功完成这个练习，我们需要确保执行以下步骤：
- en: 'In your Terminal, run the following commands to create an application:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中，运行以下命令来创建一个应用程序：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output should be as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 3.9: Creating the application'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9：创建应用程序'
- en: '](image/C12607_03_09.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_09.jpg)'
- en: 'Figure 3.9: Creating the application'
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.9：创建应用程序
- en: 'These commands create a folder called `serverless-app` and then change the
    directory so that it''s in this folder. Finally, a file called `app.yaml` is created
    with the content `name: serverless-app`, which is used to define the root of the
    application.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '这些命令创建一个名为`serverless-app`的文件夹，然后更改目录，使其位于此文件夹中。最后，创建一个名为`app.yaml`的文件，其中包含内容`name:
    serverless-app`，用于定义应用程序的根目录。'
- en: 'Run the following command in your Terminal to create a root function that''s
    available at the `"/"` of the application URL:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中运行以下命令，以创建一个在应用程序URL的`"/"`处可用的根函数：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This command will create a Ruby function with an HTTP trigger at the root of
    the application, as shown in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将在应用程序的根目录创建一个带有HTTP触发器的Ruby函数，如下面的屏幕截图所示：
- en: '![Figure 3.10: Ruby function creation'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10：Ruby函数创建'
- en: '](image/C12607_03_10.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_10.jpg)'
- en: 'Figure 3.10: Ruby function creation'
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.10：Ruby函数创建
- en: 'Create a subfunction by using the following commands in your Terminal:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在终端中创建一个子函数：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This command initializes a Go function with an HTTP trigger in the `hello-world`
    folder of the application, as shown in the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令在应用程序的`hello-world`文件夹中初始化一个带有HTTP触发器的Go函数，如下面的屏幕截图所示：
- en: '![Figure 3.11: Go function creation'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11：Go函数创建'
- en: '](image/C12607_03_11.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_11.jpg)'
- en: 'Figure 3.11: Go function creation'
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.11：Go函数创建
- en: 'Check the directory of the application by using the following command in your
    Terminal:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中使用以下命令检查应用程序的目录：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This command lists the files in the root and child folders, as shown in the
    following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令列出了根文件夹和子文件夹中的文件，如下面的屏幕截图所示：
- en: '![Figure 3.12: Folder structure'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12：文件夹结构'
- en: '](image/C12607_03_12.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_12.jpg)'
- en: 'Figure 3.12: Folder structure'
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.12：文件夹结构
- en: 'As expected, there is a Ruby function in the root folder with three files:
    `func.rb` for the implementation, `func.yaml` for the function definition, and
    `Gemfile` to define Ruby function dependencies.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，在根文件夹中有一个Ruby函数，包含三个文件：`func.rb`用于实现，`func.yaml`用于函数定义，`Gemfile`用于定义Ruby函数依赖。
- en: 'Similarly, there is a Go function in the `hello-world` folder with three files:
    `func.go` for the implementation, `func.yaml` for the function definition, and
    `go.mod` for Go dependencies.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在`hello-world`文件夹中有一个Go函数，包含三个文件：`func.go`用于实现，`func.yaml`用于函数定义，`go.mod`用于Go依赖。
- en: 'Deploy the entire application by using the following command in your Terminal:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在终端中部署整个应用程序：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This command deploys all the functions by creating the app and using a local
    development environment, as shown in the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令通过创建应用程序并使用本地开发环境部署所有函数，如下截图所示：
- en: '![Figure 3.13: Application deployment to Fn'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13：应用程序部署到Fn'
- en: '](image/C12607_03_13.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_13.jpg)'
- en: 'Figure 3.13: Application deployment to Fn'
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.13：应用程序部署到Fn
- en: Firstly, the function for `serverless-app` is built, and then the function and
    trigger are created. Similarly, the `hello-world` function is built and deployed
    with the corresponding function and trigger.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，构建`serverless-app`的函数，然后创建函数和触发器。同样，构建并部署`hello-world`函数以及相应的函数和触发器。
- en: 'List the triggers of the application with the following command and copy the
    `Endpoints` for `serverless-app-trigger` and `hello-world-trigger`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令列出应用程序的触发器，并复制`serverless-app-trigger`和`hello-world-trigger`的`Endpoints`：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This command lists the triggers of `serverless-app`, along with function, type,
    source, and endpoint information, as shown in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令列出了`serverless-app`的触发器，以及函数、类型、源和端点信息，如下截图所示：
- en: '![Figure 3.14: Trigger list'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.14：触发器列表'
- en: '](image/C12607_03_14.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_14.jpg)'
- en: 'Figure 3.14: Trigger list'
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.14：触发器列表
- en: 'Trigger the endpoints by using the following commands in your Terminal:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在终端中触发端点：
- en: Note
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For the `curl` commands, do not forget to use the endpoints that we copied in
    *Step 5*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`curl`命令，请不要忘记使用我们在*步骤5*中复制的端点。
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output should be as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 3.15: Invocation of the serverless-app trigger'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.15：调用serverless-app触发器'
- en: '](image/C12607_03_15.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_15.jpg)'
- en: 'Figure 3.15: Invocation of the serverless-app trigger'
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.15：调用serverless-app触发器
- en: 'This command will invoke the `serverless-app` trigger located at the `root`
    of the application. Since it was triggered with the `name` payload, it responded
    with a personal message: `Hello Ece!`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将调用位于应用程序`root`处的`serverless-app`触发器。由于它是以`name`负载触发的，它会响应个人消息：`Hello Ece!`：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This command will invoke the `hello-world` trigger without any payload and,
    as expected, it responded with `Hello World`, as shown in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将调用`hello-world`触发器，没有任何负载，如预期的那样，它会响应`Hello World`，如下截图所示：
- en: '![Figure 3.16: Invocation of the hello-world trigger'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.16：调用hello-world触发器'
- en: '](image/C12607_03_16.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_16.jpg)'
- en: 'Figure 3.16: Invocation of the hello-world trigger'
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.16：调用hello-world触发器
- en: Check the application and function statistics from the `Fn` Dashboard by opening
    `http://localhost:4000` in your browser.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在浏览器中打开`http://localhost:4000`，从`Fn`仪表板中检查应用程序和函数统计信息。
- en: 'On the home screen, your applications and their overall statistics can be seen,
    along with auto-refreshed charts, as shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在主屏幕上，可以看到您的应用程序及其整体统计信息，以及自动刷新的图表，如下截图所示：
- en: '![Figure 3.17: Fn Dashboard – Home'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.17：Fn仪表板-主页'
- en: '](image/C12607_03_17.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_17.jpg)'
- en: 'Figure 3.17: Fn Dashboard – Home'
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.17：Fn仪表板-主页
- en: 'Click on `serverless-app` from the applications list to view more information
    about the functions of the application, as shown in the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 单击应用程序列表中的`serverless-app`以查看有关应用程序功能的更多信息，如下截图所示：
- en: '![Figure 3.18: Fn Dashboard – Application'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.18：Fn仪表板-应用程序'
- en: '](image/C12607_03_18.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_18.jpg)'
- en: 'Figure 3.18: Fn Dashboard – Application'
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.18：Fn仪表板-应用程序
- en: 'Stop the `Fn` server by using the following command in your Terminal:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中使用以下命令停止`Fn`服务器：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This command will stop the `Fn` server, including all the function instances,
    as shown in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将停止`Fn`服务器，包括所有函数实例，如下截图所示：
- en: '![Figure 3.19: Fn server stop'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.19：Fn服务器停止'
- en: '](image/C12607_03_19.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_19.jpg)'
- en: 'Figure 3.19: Fn server stop'
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.19：Fn服务器停止
- en: In this exercise, we created a two-function application in the `Fn` framework
    and deployed it. We have shown you how to build functions as Docker containers
    using the `fn` client and by creating functions. In addition, the triggers of
    the functions were invoked via HTTP, and the statistics were checked from the
    `Fn` dashboard. As a container-native and cloud-agnostic framework, the functions
    of the framework are Docker containers, and they can run on any cloud provider
    or local system. In the next section, another serverless framework, namely, the
    **Serverless Framework**, which focuses more on cloud-provider integration, will
    be presented.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们在`Fn`框架中创建了一个双函数应用程序并部署了它。我们向您展示了如何使用`fn`客户端将函数构建为Docker容器，并通过创建函数来调用函数的触发器。此外，还从`Fn`仪表板检查了函数的统计信息。作为一个面向容器的、与云无关的框架，该框架的函数是Docker容器，可以在任何云提供商或本地系统上运行。在下一节中，将介绍另一个无服务器框架，即**Serverless
    Framework**，它更专注于云提供商集成。
- en: The Serverless Framework
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Serverless Framework
- en: The Serverless Framework was announced in 2015 with the name **JavaScript Amazon
    Web Services (JAWS)**. It was initially developed in Node.js to make it easier
    for people to develop AWS Lambda functions. In the same year, it changed the name
    to **Serverless Framework** and expanded its scope to other cloud providers and
    serverless frameworks, including **Google Cloud Functions**, **Azure Functions**,
    **Apache OpenWhisk**, **Fn**, and many more.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless Framework在2015年以**JavaScript Amazon Web Services (JAWS)**的名字宣布。最初是在Node.js中开发的，以使人们更容易开发AWS
    Lambda函数。同年，它将名称更改为**Serverless Framework**，并将其范围扩大到其他云提供商和无服务器框架，包括**Google Cloud
    Functions**，**Azure Functions**，**Apache OpenWhisk**，**Fn**等等。
- en: 'Serverless Framework is open source, and its source code is available at GitHub:
    [https://github.com/serverless/serverless](https://github.com/serverless/serverless).
    It is a very popular repository with more than 31,000 stars, as shown in the following
    screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless Framework是开源的，其源代码可在GitHub上找到：[https://github.com/serverless/serverless](https://github.com/serverless/serverless)。如下截图所示，这是一个非常受欢迎的存储库，拥有超过31,000颗星：
- en: '![Figure 3.20: Serverless Framework GitHub repository'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.20：Serverless Framework GitHub存储库'
- en: '](image/C12607_03_20.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_20.jpg)'
- en: 'Figure 3.20: Serverless Framework GitHub repository'
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.20：Serverless Framework GitHub存储库
- en: 'The official website of the framework is available at [https://serverless.com](https://serverless.com)
    and provides extensive documentation, use cases, and examples. The main features
    of the Serverless Framework can be grouped into four main topics:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架的官方网站可在[https://serverless.com](https://serverless.com)上找到，并提供广泛的文档、用例和示例。Serverless
    Framework的主要特点可以分为四个主要主题：
- en: '**Cloud-agnostic**: The Serverless Framework aims to create a cloud-agnostic
    serverless application development environment so that vendor lock-in is not a
    concern.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与云无关**：Serverless Framework旨在创建一个与云无关的无服务器应用程序开发环境，因此供应商锁定不是一个问题。'
- en: '**Reusable Components**: Serverless functions that are developed in the Serverless
    Framework are open source and available. These components help us to create complex
    applications quickly.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用组件**：在Serverless Framework中开发的无服务器函数是开源的并可用。这些组件帮助我们快速创建复杂的应用程序。'
- en: '**Infrastructure-as-code**: All the configuration and source code that''s developed
    in the Serverless Framework is explicitly defined and can be deployed with a single
    command.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施即代码**：在Serverless Framework中开发的所有配置和源代码都是明确定义的，并且可以通过单个命令部署。'
- en: '**Developer Experience**: The Serverless Framework aims to enhance developer
    experience via its CLI, configuration parameters, and active community.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者体验**：Serverless Framework旨在通过其CLI、配置参数和活跃的社区来增强开发者体验。'
- en: 'These four characteristics of the Serverless Framework make it the most well-known
    framework for creating serverless applications in the cloud. In addition, the
    framework focuses on the management of the complete life cycle of serverless applications:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless Framework的这四个特点使其成为创建云中无服务器应用程序最知名的框架。此外，该框架专注于管理无服务器应用程序的完整生命周期：
- en: '**Develop**: It is possible to develop apps locally and reuse open source plugins
    via the framework CLI.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发**：可以在本地开发应用程序，并通过框架CLI重用开源插件。'
- en: '**Deploy**: The Serverless Framework can deploy to multiple cloud platforms
    and roll out and roll back versions from development to production.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**：Serverless Framework可以部署到多个云平台，并从开发到生产中推出和回滚版本。'
- en: '**Test**: The framework supports testing the functions out of the box by using
    the command-line client functions.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：该框架支持使用命令行客户端函数直接测试函数。'
- en: '**Secure**: The framework handles secrets for running the functions and cloud-specific
    authentication keys for deployments.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：该框架处理运行函数的秘密和部署的特定于云的身份验证密钥。'
- en: '**Monitor**: The metrics and logs of the serverless applications are available
    with the serverless runtime and client tools.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**：无服务器应用程序的指标和日志可通过无服务器运行时和客户端工具获得。'
- en: In the following exercise, a serverless application will be created, configured,
    and deployed to AWS using the Serverless Framework. The framework will be used
    inside a Docker container to show how easy it is to get started with serverless
    applications.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，将使用Serverless Framework在Docker容器内创建、配置和部署一个无服务器应用程序到AWS，以展示使用无服务器应用程序有多么容易。
- en: Note
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The Serverless Framework can be downloaded and installed to a local computer
    with `npm`. A Docker container, including the Serverless Framework installation,
    will be used in the following exercise so that we have a fast and reproducible
    setup.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless Framework可以通过`npm`下载并安装到本地计算机上。在接下来的练习中，将使用包含Serverless Framework安装的Docker容器，以便我们拥有快速且可重复的设置。
- en: In the following exercise, the `hello-world` function will be deployed to AWS
    Lambda using the Serverless Framework. In order to complete this exercise, you
    need to have an active Amazon Web Services account. You can create an account
    at [https://aws.amazon.com/](https://aws.amazon.com/).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，将使用Serverless Framework将`hello-world`函数部署到AWS Lambda。为了完成这个练习，您需要拥有一个活跃的亚马逊网络服务账户。您可以在[https://aws.amazon.com/](https://aws.amazon.com/)上创建一个账户。
- en: 'Exercise 9: Running Functions with the Serverless Framework'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习9：使用Serverless Framework运行函数
- en: In this exercise, we aim to configure the Serverless Framework and deploy our
    very first function using it. With the Serverless Framework, it is possible to
    create cloud-agnostic serverless applications. In this exercise, we will deploy
    the functions to AWS Lambda. However, it is possible to deploy the same functions
    to different cloud providers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们的目标是配置Serverless框架并使用它部署我们的第一个函数。使用Serverless框架，可以创建与云无关的无服务器应用程序。在这个练习中，我们将把函数部署到AWS
    Lambda。但是，也可以将相同的函数部署到不同的云提供商。
- en: 'To successfully complete this exercise, we need to ensure that the following
    steps are executed:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功完成这个练习，我们需要确保执行以下步骤：
- en: 'In your Terminal, run the following command to start the Serverless Framework
    development environment:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端中，运行以下命令启动Serverless框架开发环境：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This command will start a Docker container in interactive mode. In the following
    steps, actions will be taken inside this Docker container, as shown in the following
    screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将以交互模式启动一个Docker容器。在接下来的步骤中，将在这个Docker容器内执行操作，如下截图所示：
- en: '![Figure 3.21: Starting a Docker container for serverless'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.21：启动无服务器的Docker容器'
- en: '](image/C12607_03_21.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_21.jpg)'
- en: 'Figure 3.21: Starting a Docker container for serverless'
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.21：启动无服务器的Docker容器
- en: 'Run the following command to check the framework version:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令检查框架版本：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This command lists the Framework, Plugin, and SDK versions, and getting a complete
    output indicates that everything is set up correctly, as shown in the following
    screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令列出了框架、插件和SDK版本，并且完整的输出表明一切都设置正确，如下截图所示：
- en: '![Figure 3.22: Framework version'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.22：框架版本'
- en: '](image/C12607_03_22.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_22.jpg)'
- en: 'Figure 3.22: Framework version'
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.22：框架版本
- en: 'Run the following command to use the framework interactively:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以交互方式使用框架：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Press **Y** to create a new project and choose **AWS Node.js** from the dropdown,
    as shown in the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 按下**Y**创建一个新项目，并从下拉菜单中选择**AWS Node.js**，如下截图所示：
- en: '![Figure 3.23: Creating a new project in the framework'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.23：在框架中创建一个新项目'
- en: '](image/C12607_03_23.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_23.jpg)'
- en: 'Figure 3.23: Creating a new project in the framework'
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.23：在框架中创建一个新项目
- en: 'Set the name of the project to `hello-world` and press **Enter**. The output
    is as follows:![Figure 3.24: Successful creation of the project'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目名称设置为`hello-world`，然后按下**Enter**。输出如下：![图3.24：成功创建项目
- en: '](image/C12607_03_24.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_24.jpg)'
- en: 'Figure 3.24: Successful creation of the project'
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.24：成功创建项目
- en: 'Press **Y** for the AWS credential setup question, and then press **Y** again
    for the **Do you have an AWS account?** question. The output will be as follows:![Figure
    3.25: AWS account setup'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**Y**回答AWS凭证设置问题，然后再次按下**Y**回答**您是否有AWS账户？**的问题。输出如下：![图3.25：AWS账户设置
- en: '](image/C12607_03_25.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_25.jpg)'
- en: 'Figure 3.25: AWS account setup'
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.25：AWS账户设置
- en: You now have a URL for creating a serverless user. Copy and save the URL; we'll
    need it later.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个用于创建无服务器用户的URL。复制并保存这个URL；我们以后会用到它。
- en: 'Open the URL from *Step 4* in your browser and start adding users to the AWS
    console. The URL will open the **Add user** screen with predefined selections.
    Click **Next: Permissions** at the end of the screen, as shown in the following
    screenshot:![](image/C12607_03_26.jpg)'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开*步骤4*中的URL，并开始向AWS控制台添加用户。该URL将打开预定义选择的**添加用户**屏幕。点击屏幕末尾的**下一步：权限**，如下截图所示：![](image/C12607_03_26.jpg)
- en: 'Figure 3.26: AWS Add user'
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.26：AWS添加用户
- en: 'The **AdministratorAccess** policy should be selected automatically. Click
    **Next: Tags** at the bottom of the screen, as shown in the following screenshot:![Figure
    3.27: AWS Add user – Permissions'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**AdministratorAccess**策略应该会自动选择。如下面的屏幕截图所示，单击屏幕底部的“下一步：标签”：![图3.27：AWS添加用户-权限'
- en: '](image/C12607_03_27.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_27.jpg)'
- en: 'Figure 3.27: AWS Add user – Permissions'
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.27：AWS添加用户-权限
- en: 'If you want to tag your users, you can add optional tags in this view. Click
    **Next: Review**, as shown in the following screenshot:![Figure 3.28: AWS Add
    user – Tags'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想要给用户打标签，您可以在此视图中添加可选标签。单击“下一步：审核”，如下面的屏幕截图所示：![图3.28：AWS添加用户-标签
- en: '](image/C12607_03_28.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_28.jpg)'
- en: 'Figure 3.28: AWS Add user – Tags'
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.28：AWS添加用户-标签
- en: 'This view shows the summary of the new user. Click **Create User**, as shown
    in the following screenshot:![Figure 3.29: AWS Add user – Review'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此视图显示了新用户的摘要。如下面的屏幕截图所示，单击“创建用户”：![图3.29：AWS添加用户-审核
- en: '](image/C12607_03_29.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_29.jpg)'
- en: 'Figure 3.29: AWS Add user – Review'
  id: totrans-218
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.29：AWS添加用户-审核
- en: 'You will be redirected to a success page with an **Access Key ID** and **secret**,
    as shown in the following screenshot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被重定向到一个成功页面，显示**访问密钥ID**和**秘密**，如下面的屏幕截图所示：
- en: '![Figure 3.30: AWS Add user – Success'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.30：AWS添加用户-成功'
- en: '](image/C12607_03_30.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_30.jpg)'
- en: 'Figure 3.30: AWS Add user – Success'
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.30：AWS添加用户-成功
- en: Copy the key ID and secret access key so that you can use it in the following
    steps of this exercise and the activity for this chapter. You need to click **Show**
    to reveal the secret access key.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制密钥ID和秘密访问密钥，以便您可以在本练习的后续步骤和本章的活动中使用它。您需要单击“显示”以显示秘密访问密钥。
- en: 'Return to your Terminal and press **Enter** to enter the key ID and secret
    information, as shown in the following screenshot:![Figure 3.31: AWS Credentials
    in the framework'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到您的终端并按**Enter**输入密钥ID和秘密信息，如下面的屏幕截图所示：![图3.31：框架中的AWS凭据
- en: '](image/C12607_03_31.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_31.jpg)'
- en: 'Figure 3.31: AWS Credentials in the framework'
  id: totrans-226
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.31：框架中的AWS凭据
- en: 'Press **Y** for the Serverless account enable question and select **register**
    from the dropdown, as shown in the following screenshot:![Figure 3.32: Serverless
    account enabled'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**Y**回答Serverless账户启用问题，并从下拉菜单中选择**注册**，如下面的屏幕截图所示：![图3.32：Serverless账户已启用
- en: '](image/C12607_03_32.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_32.jpg)'
- en: 'Figure 3.32: Serverless account enabled'
  id: totrans-229
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.32：Serverless账户已启用
- en: 'Write your email and a password to create a Serverless Framework account, as
    shown in the following screenshot:![Figure 3.33: Serverless account register'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入您的电子邮件和密码以创建Serverless框架账户，如下面的屏幕截图所示：![图3.33：Serverless账户注册
- en: '](image/C12607_03_33.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_33.jpg)'
- en: 'Figure 3.33: Serverless account register'
  id: totrans-232
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.33：Serverless账户注册
- en: 'Run the following commands to change the directory and deploy the function:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以更改目录并部署函数：
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These commands will make the Serverless Framework deploy the function into
    AWS, as shown in the following screenshot:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将使Serverless Framework将函数部署到AWS，如下面的屏幕截图所示：
- en: '![Figure 3.34: Serverless Framework deployment output'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.34：Serverless框架部署输出'
- en: '](image/C12607_03_34.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_34.jpg)'
- en: 'Figure 3.34: Serverless Framework deployment output'
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.34：Serverless框架部署输出
- en: Note
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The output logs start by packaging the service and creating AWS resources for
    the source code, artifacts, and functions. After all the resources have been created,
    the `Service Information` section will provide a summary of the functions and
    URLs.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 输出日志从打包服务和为源代码、工件和函数创建AWS资源开始。在创建了所有资源之后，“服务信息”部分将提供函数和URL的摘要。
- en: 'At the end of the screen, you will find the **Serverless Dashboard URL** for
    the deployed function, as shown in the following screenshot:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕底部，您将找到部署函数的**无服务器仪表板URL**，如下截图所示：
- en: '![Figure 3.35: Stack Outputs'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.35：堆栈输出'
- en: '](image/C12607_03_35.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_35.jpg)'
- en: 'Figure 3.35: Stack Outputs'
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.35：堆栈输出
- en: Copy the dashboard URL so that you can check the function metrics in the upcoming
    steps.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 复制仪表板URL，以便在接下来的步骤中检查函数指标。
- en: 'Invoke the function by using the following command in your Terminal:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在终端中调用函数：
- en: '[PRE23]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This command invokes the deployed function and prints out the response, as
    shown in the following screenshot:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令调用部署的函数并打印出响应，如下截图所示：
- en: '![Figure 3.36: Function output'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.36：函数输出'
- en: '](image/C12607_03_36.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_36.jpg)'
- en: 'Figure 3.36: Function output'
  id: totrans-251
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.36：函数输出
- en: As the output shows, `statusCode` is `200`, and the body of the response indicates
    that the function has responded successfully.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，`statusCode`为`200`，响应的正文表明函数已成功响应。
- en: 'Open the Serverless Dashboard URL you copied at the end of Step 8 into your
    browser, as shown in the following screenshot:![Figure 3.37: Serverless Dashboard
    login'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开您在第8步末尾复制的无服务器仪表板URL，如下截图所示：![图3.37：无服务器仪表板登录
- en: '](image/C12607_03_37.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_37.jpg)'
- en: 'Figure 3.37: Serverless Dashboard login'
  id: totrans-255
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.37：无服务器仪表板登录
- en: Log in with the email and password you created in *Step 5*.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您在*步骤5*中创建的电子邮件和密码登录。
- en: 'You will be redirected to the application list. Expand **hello-world-app**
    and click on the **successful deployment** line, as shown in the following screenshot:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被重定向到应用程序列表。展开**hello-world-app**并点击**成功部署**行，如下截图所示：
- en: '![Figure 3.38: Serverless Dashboard application list'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.38：无服务器仪表板应用程序列表'
- en: '](image/C12607_03_38.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_38.jpg)'
- en: 'Figure 3.38: Serverless Dashboard application list'
  id: totrans-260
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.38：无服务器仪表板应用程序列表
- en: 'In the function view, all the runtime information, including API endpoints,
    variables, alerts, and metrics, are available. Scroll down to see the number of
    invocations. The output should be as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数视图中，所有运行时信息，包括API端点、变量、警报和指标都可用。向下滚动以查看调用次数。输出应如下所示：
- en: '![Figure 3.39: Serverless Dashboard function view'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.39：无服务器仪表板函数视图'
- en: '](image/C12607_03_39.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_39.jpg)'
- en: 'Figure 3.39: Serverless Dashboard function view'
  id: totrans-264
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.39：无服务器仪表板函数视图
- en: Since we have only invoked the function once, you will only see **1** in the
    charts.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只调用了函数一次，因此在图表中只会看到**1**。
- en: 'Return to your Terminal and delete the function with the following command:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到您的终端，并使用以下命令删除函数：
- en: '[PRE24]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This command will remove the deployed function and all its dependencies, as
    shown in the following screenshot:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将删除部署的函数及其所有依赖项，如下截图所示：
- en: '![Figure 3.40: Removing the function'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.40：移除函数'
- en: '](image/C12607_03_40.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_40.jpg)'
- en: 'Figure 3.40: Removing the function'
  id: totrans-271
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.40：移除函数
- en: 'Exit the Serverless Framework development environment container by writing
    `exit` in the Terminal, as shown in the following screenshot:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在终端中输入`exit`退出无服务器框架开发环境容器，如下截图所示：
- en: '![](image/C12607_03_41.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](image/C12607_03_41.jpg)'
- en: 'Figure 3.41: Exiting the container'
  id: totrans-274
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.41：退出容器
- en: In this exercise, we have created, configured, and deployed a serverless function
    using the Serverless Framework. Furthermore, the function is invoked via a CLI,
    and its metrics are checked from the Serverless Dashboard. The Serverless Framework
    creates a comprehensive abstraction for cloud providers so that it is only passed
    as credentials to the platform. In other words, where to deploy is just a matter
    of configuration with the help of serverless frameworks.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用Serverless Framework创建、配置和部署了一个无服务器函数。此外，该函数是通过CLI调用的，并且可以从Serverless
    Dashboard检查其指标。Serverless Framework为云提供商创建了一个全面的抽象，因此它只作为凭据传递给平台。换句话说，部署在哪里只是借助无服务器框架的帮助进行配置的问题。
- en: In the following activity, a real-life serverless daily weather application
    will be developed. You will create a serverless framework application with an
    invocation schedule and deploy it to a cloud provider. In addition, the weather
    status messages will be sent to a cloud-based collaboration tool known as *Slack*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的活动中，将开发一个真实的无服务器每日天气应用程序。您将创建一个带有调用计划的无服务器框架应用程序，并将其部署到云提供商。此外，天气状况消息将发送到一个名为*Slack*的基于云的协作工具。
- en: Note
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In order to complete the following activity, you need to be able to access a
    Slack workplace. You can use your existing Slack workspace or create a new one
    for free at [https://slack.com/create](https://slack.com/create).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成接下来的活动，您需要能够访问Slack工作区。您可以使用现有的Slack工作区，也可以免费创建一个新的工作区，网址为[https://slack.com/create](https://slack.com/create)。
- en: 'Activity 3: Daily Weather Status Function for Slack'
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动3：Slack的每日天气状况功能
- en: The aim of this activity is to create a real-life serverless application that
    sends weather status messages in specific *Slack* channels. The function will
    be developed with the **Serverless Framework** so that it can run on multiple
    cloud platforms in the future. The function will be designed to run at particular
    times for your team so that they're informed about the weather status, such as
    early in the morning before their morning commute. These messages will be published
    on *Slack* channels, which is the main communication tool within the team.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的目的是创建一个真实的无服务器应用程序，可以在特定的*Slack*频道中发送天气状况消息。该函数将使用**Serverless Framework**开发，以便将来可以在多个云平台上运行。该函数将被设计为在团队特定时间运行，以便他们了解天气状况，比如在早上上班前。这些消息将发布在*Slack*频道上，这是团队内的主要沟通工具。
- en: 'In order to get the weather status to share within the team, you can use **wttr.in**
    ([https://github.com/chubin/wttr.in](https://github.com/chubin/wttr.in)), which
    is a free-to-use weather data provider. Once completed, you will have deployed
    a function to a cloud provider, namely, **AWS Lambda**:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取天气状况以在团队内共享，您可以使用**wttr.in**（[https://github.com/chubin/wttr.in](https://github.com/chubin/wttr.in)），这是一个免费使用的天气数据提供商。完成后，您将已经将一个函数部署到了云提供商，即**AWS
    Lambda**：
- en: '![Figure 3.42: Daily weather function'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.42：每日天气功能'
- en: '](image/C12607_03_42.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_42.jpg)'
- en: 'Figure 3.42: Daily weather function'
  id: totrans-284
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.42：每日天气功能
- en: 'Finally, when the scheduler invokes the function, or when you invoke it manually,
    you will get messages regarding the current weather status in your Slack channel:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当调度程序调用该函数，或者当您手动调用它时，您将在Slack频道中收到有关当前天气状况的消息：
- en: '![Figure 3.43: Slack message with the current weather status'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.43：Slack消息显示当前天气状况'
- en: '](image/C12607_03_43.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_03_43.jpg)'
- en: 'Figure 3.43: Slack message with the current weather status'
  id: totrans-288
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.43：Slack消息显示当前天气状况
- en: Note
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In order to complete this activity, you should configure Slack by following
    the Slack setup steps.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个活动，您应该按照Slack设置步骤配置Slack。
- en: '**Slack Setup**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**Slack设置**'
- en: 'Execute the following steps to configure Slack:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤配置Slack：
- en: In your Slack workspace, click your username and select **Customize Slack**.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Slack工作区中，单击您的用户名，然后选择**自定义Slack**。
- en: Click **Configure apps** in the opened window.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的窗口中单击**配置应用程序**。
- en: Click on **Browse the App Directory** to add a new application from the directory.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**浏览应用程序目录**以从目录中添加新应用程序。
- en: Find **Incoming WebHooks** from the search box in App Directory.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序目录的搜索框中找到**传入WebHooks**。
- en: Click on **Set Up** for the **Incoming WebHooks** application.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**设置**以设置**传入WebHooks**应用程序。
- en: Fill in the configuration for incoming webhooks with your specific channel name
    and icon.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您特定的频道名称和图标填写传入Webhooks的配置。
- en: Open your Slack workspace and the channel you configured in Step 6 to be able
    to check the integration message.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的Slack工作区和您在第6步中配置的频道，以便检查集成消息。
- en: Note
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Detailed screenshots of the Slack setup steps can be found on page 387.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在第387页可以找到Slack设置步骤的详细截图。
- en: Execute the following steps to complete this activity.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动。
- en: In your Terminal, create a Serverless Framework application structure in a folder
    called `daily-weather`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中，在名为`daily-weather`的文件夹中创建一个Serverless Framework应用程序结构。
- en: Create a `package.json` file to define the Node.js environment in the `daily-weather`
    folder.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`package.json`文件来定义`daily-weather`文件夹中的Node.js环境。
- en: Create a `handler.js` file to implement the actual functionality in the `daily-weather`
    folder.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`handler.js`文件来实现`daily-weather`文件夹中的实际功能。
- en: Install the Node.js dependencies for the serverless application.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为无服务器应用程序安装Node.js依赖项。
- en: Export the AWS credentials as environment variables.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将AWS凭据导出为环境变量。
- en: Deploy the serverless application to AWS using the Serverless Framework.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Serverless Framework将无服务器应用程序部署到AWS。
- en: Check AWS Lambda for the deployed functions in the AWS Console.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS控制台中检查已部署函数的AWS Lambda。
- en: Invoke the function with the Serverless Framework client tools.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Serverless Framework客户端工具调用函数。
- en: Check the Slack channel for the posted weather status.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查发布的天气状态的Slack频道。
- en: Return to your Terminal and delete the function with the Serverless Framework.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到您的终端并使用Serverless Framework删除函数。
- en: Exit the Serverless Framework development environment container.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出Serverless Framework开发环境容器。
- en: Note
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 387.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第387页找到。
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we provided an overview of serverless frameworks by discussing
    the differences between the serverless products of cloud providers. Following
    that, one container-native and one cloud-native serverless framework were discussed
    in depth. Firstly, the `Fn` framework was discussed, which is an open source,
    container-native, and cloud-agnostic platform. Secondly, the Serverless Framework
    was presented, which is a more cloud-focused and comprehensive framework. Furthermore,
    both frameworks were installed and configured locally. Serverless applications
    were created, deployed, and run in both serverless frameworks. The functions were
    invoked with the capabilities of serverless frameworks, and the necessary metrics
    checked for further analysis. At the end of this chapter, a real-life, daily weather
    Slack bot was implemented as a cloud-agnostic, explicitly defined application
    using serverless frameworks. Serverless frameworks are essential for the serverless
    development world with their cloud-agnostic and developer-friendly characteristics.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过讨论云提供商的无服务器产品之间的差异，提供了无服务器框架的概述。在此之后，我们深入讨论了一个基于容器的原生框架和一个基于云的原生框架。首先讨论了“Fn”框架，这是一个开源的、基于容器的、与云无关的平台。其次介绍了Serverless
    Framework，这是一个更加注重云和更全面的框架。此外，我们还在本地安装和配置了这两个框架。在两个无服务器框架中创建、部署和运行了无服务器应用程序。使用无服务器框架的功能进行调用，并检查必要的指标以进行进一步分析。在本章的最后，我们实现了一个真实的、每日天气Slack机器人，作为一个明确定义的、与云无关的应用程序，使用了无服务器框架。无服务器框架以其与云无关和开发者友好的特性，对无服务器开发世界至关重要。
