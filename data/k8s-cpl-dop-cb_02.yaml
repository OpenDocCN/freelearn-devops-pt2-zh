- en: Operating Applications on Kubernetes
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes上操作应用程序
- en: In this chapter, we will discuss the provisioning tools available to deploy
    cloud-native applications on Kubernetes. You will learn how to deploy DevOps tools
    and **CI**/**CD** (short for **continuous integration**/**continuous delivery**
    or **continuous deployment**) infrastructure on Kubernetes using the most popular
    life cycle management options. You will gain the skills to perform Day 1 and some
    Day 2 operations, such as installing, upgrading, and version controlling Deployments,
    ruling out a new application, and removing Deployments when they are no longer
    needed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论可用于在Kubernetes上部署云原生应用程序的供应工具。您将学习如何使用最流行的生命周期管理选项在Kubernetes上部署DevOps工具和CI/CD（持续集成/持续交付或持续部署）基础设施。您将掌握执行第1天和第2天的操作的技能，例如安装、升级和版本控制部署，排除新应用程序，并在不再需要时删除部署。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Deploying workloads using YAML files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用YAML文件部署工作负载
- en: Deploying workloads using Customize
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义部署工作负载
- en: Deploying workloads using Helm charts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Helm图表部署工作负载
- en: Deploying and operating applications using Kubernetes operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes运算符部署和操作应用程序
- en: Deploying and managing the life cycle of Jenkins X
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和管理Jenkins X的生命周期
- en: Deploying and managing the life cycle of GitLab
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和管理GitLab的生命周期
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Recipes in this section assume that you have a functional Kubernetes cluster
    deployed following one of the recommended methods described in [Chapter 1](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml),
    *Building Production-Ready Kubernetes Clusters*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的配方假设您已部署了一个功能齐全的Kubernetes集群，遵循[第1章](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml)中描述的推荐方法之一。
- en: The Kubernetes Operations tool kubectl will be used for the rest of the recipes
    in this section since it's the main command-line interface for running commands
    against Kubernetes clusters. If you are using a Red Hat OpenShift cluster, you
    can replace `kubectl` with `oc` and all commands are expected to function similarly.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes操作工具kubectl将用于本节中其余的配方，因为它是针对Kubernetes集群运行命令的主要命令行界面。如果您使用Red Hat
    OpenShift集群，可以将kubectl替换为oc，并且所有命令预计将类似地运行。
- en: Deploying workloads using YAML files
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用YAML文件部署工作负载
- en: In this section, we will create the resource configurations required to deploy
    your applications in Kubernetes. You will learn how to create a Kubernetes manifest,
    deploy a workload, and roll out a new version using **Yet Another Markup Language**
    (**YAML**) files.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建在Kubernetes中部署应用程序所需的资源配置。您将学习如何创建Kubernetes清单，部署工作负载，并使用YAML文件推出新版本。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before you start, clone the repository of the examples used in this chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请克隆本章中使用的示例存储库：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Make sure you have a Kubernetes cluster ready and kubectl configured to manage
    the cluster resources.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已准备好一个Kubernetes集群，并配置kubectl以管理集群资源。
- en: How to do it…
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'This section is further divided into the following subsections to ease the
    process:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本节进一步分为以下子节，以便简化流程：
- en: Creating a Deployment
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建部署
- en: Verifying a Deployment
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证部署
- en: Editing a Deployment
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑部署
- en: Rolling back a Deployment
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回滚部署
- en: Deleting a Deployment
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除部署
- en: Creating a Deployment
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建部署
- en: This recipe will take you through instructions to create a Deployment using
    a manifest file that keeps a set of pods running. Deployments are used to declare
    how many replicas of a pod should be running. A Deployment can be scaled up and
    down; we will see more on that topic later in [Chapter 7](7b696c2a-de7c-4adc-9ecc-f5bf65c288c5.xhtml),* Scaling
    and Upgrading* *Applications*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将带您按照说明创建一个使用清单文件的部署，该文件保持一组pod运行。部署用于声明应该运行多少个pod的副本。部署可以进行扩展和缩减；我们将在[第7章](7b696c2a-de7c-4adc-9ecc-f5bf65c288c5.xhtml)中更多地了解这个主题，*扩展和升级*
    *应用程序*。
- en: 'Let''s perform the following steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Change directory to `src/chapter2/yaml/`, where the example files for this
    recipe are located:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`src/chapter2/yaml/`目录，这里是本教程的示例文件所在的位置：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Review the Deployment manifest:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看部署清单：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: YAML is white space sensitive. Review the example file to understand the structure
    of the file. You will see that YAML files do not use tabs instead of a space character.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: YAML是对空格敏感的。查看示例文件以了解文件的结构。您会发现YAML文件不使用制表符，而是使用空格字符。
- en: If in doubt, use a linter for your YAML files.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有疑问，请使用YAML文件的linter。
- en: 'Create a Deployment by applying the YAML manifest:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过应用YAML清单创建一个部署：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After you run the preceding command, the container image mentioned in the YAML
    manifest will be pulled from the container registry and the application will be
    scheduled in your Kubernetes cluster as defined in the Deployment manifest. Now
    you should be able to verify the Deployment by following the next recipe.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行了上述命令之后，YAML清单中提到的容器镜像将从容器注册表中拉取，并且应用程序将按照部署清单中定义的方式在您的Kubernetes集群中安排。现在您应该能够通过以下教程来验证部署。
- en: Verifying a Deployment
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证部署
- en: This recipe will take you through the instructions to verify the status of the
    Deployment and troubleshoot it if needed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将带您按照说明验证部署的状态，并在需要时进行故障排除。
- en: 'Let''s perform the following steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Confirm that the Deployment status shows a `successfully rolled out` message
    by watching the rollout status:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过观察部署状态来确认部署状态显示了一个“成功部署”消息：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Verify that the number of `DESIRED` and `CURRENT` values is equal, in our case
    `2`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`DESIRED`和`CURRENT`值的数量是否相等，在我们的情况下是`2`：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, also check the ReplicaSets (`rs`) and `pods` deployed as part of the
    Deployment:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，还要检查作为部署的一部分部署的ReplicaSets（`rs`）和`pods`：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now you have verified that the new Deployment is successfully deployed and running.
    In a production environment, you will also need to edit, update, and scale an
    existing application. In the next recipe, you will learn how to perform these
    modify operations on an existing Deployment.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经验证了新的部署成功部署并运行。在生产环境中，您还需要编辑、更新和扩展现有的应用程序。在下一个教程中，您将学习如何对现有的部署执行这些修改操作。
- en: Editing a Deployment
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑部署
- en: This recipe will take you through the instructions to edit an existing Kubernetes
    object, and you will learn how to change a Deployment object's parameters when
    needed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将带您按照说明编辑现有的Kubernetes对象，并学习在需要时如何更改部署对象的参数。
- en: 'Let''s perform the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Edit the Deployment object and change the container image from image nginx
    1.7.9 to image nginx 1.16.0:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑部署对象并将容器镜像从nginx 1.7.9更改为nginx 1.16.0：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can see that the Deployment first goes into pending termination and later
    the rollout status shows a `successfully rolled out` message after you run the
    following command:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以看到，部署首先进入挂起终止状态，然后在运行以下命令后，部署状态显示了一个“成功部署”的消息：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Confirm that your Deployment spins up the new pods by creating a new ReplicaSet
    and scaling down the old one from `2` to `0`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认您的部署通过创建新的ReplicaSet并将旧的ReplicaSet从`2`缩减到`0`来启动新的pod：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will create a change cause annotation. The following command will add the
    description defined in the `kubernetes.io/change-cause` parameter to your current
    Deployment:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个更改原因注释。以下命令将向您当前的部署添加在`kubernetes.io/change-cause`参数中定义的描述：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, as an alternative way to edit a Deployment, edit the `deployment-nginx.yaml`
    file and change the replicas from `replicas: 2` to `replicas: 3` and `nginx:1.7.9`
    to `image: nginx:1.17.0`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，作为编辑部署的另一种替代方法，编辑`deployment-nginx.yaml`文件，并将副本从`replicas: 2`更改为`replicas:
    3`，将`nginx:1.7.9`更改为`image: nginx:1.17.0`：'
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Update the Deployment by applying the updated YAML manifest with your changes.
    This step will apply the change of image tag used for the Deployment and the number
    of replicas we increased in *step 5*:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过应用更新后的YAML清单来更新部署。此步骤将应用用于部署的镜像标记的更改以及我们在*步骤5*中增加的副本数：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Confirm that your Deployment spins up the new pods by creating a new ReplicaSet
    and scaling down the old pods:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建新的ReplicaSet并将旧的pod缩减到新的pod来确认您的部署正在启动新的pod：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create another change cause annotation by defining the changes we made using
    the `kubernetes.io/change-cause` parameter:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过定义我们使用`kubernetes.io/change-cause`参数所做的更改来创建另一个更改原因注释：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now you have learned how to edit, scale up, and also roll out a new version
    of the application using a ReplicaSet.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何编辑、扩展，并使用ReplicaSet发布应用程序的新版本。
- en: Rolling back a deployment
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回滚部署
- en: This recipe will take you through the instructions for reviewing changes made
    by comparing the annotations and rolling back the Deployment to an older revision
    when needed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将带您按照说明审查所做的更改，并通过比较注释回滚部署到旧的修订版本。
- en: 'Let''s perform the following steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Check the details and events for the Deployment and note recent `ScalingReplicaSet`
    events:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查部署的详细信息和事件，并注意最近的`ScalingReplicaSet`事件：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, display the rollout history for the Deployment. The output will show the
    revisions along with the annotations we have created:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，显示部署的发布历史。输出将显示修订版本以及我们创建的注释：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Roll back the last rollout. This command will take your Deployment to the previous
    revision, in this recipe, revision 2:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回滚最后一次发布。此命令将使您的部署回到上一个修订版本，在本示例中为修订版本2：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Confirm that the Deployment has rolled back to the previous version:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认部署已回滚到上一个版本：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that the rollback command only takes the Deployments back to different
    image version rollouts, and does not undo the other spec changes, such as the
    number of replicas.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，回滚命令只会将部署回滚到不同的镜像版本发布，并不会撤消其他规范更改，例如副本的数量。
- en: 'Now, roll back to a specific revision. This command will take your Deployment
    to a specific revision defined using the `--to-revision` parameter:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回滚到特定的修订版本。此命令将使您的部署回到使用`--to-revision`参数定义的特定修订版本：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now you have learned how to review the rollout history and roll back a change
    when required.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何查看发布历史并在需要时回滚更改。
- en: Deleting a Deployment
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除部署
- en: Kubernetes schedules resources on the worker nodes based on the availability
    of resources. If you are using a small cluster with limited CPU and memory resources,
    you may easily run out of resources, which would cause new Deployments to fail
    to get scheduled on worker nodes. Therefore, unless it is mentioned in the requirement
    of the recipe, always clean up the old Deployments before you move onto the next
    recipe.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes根据资源的可用性在工作节点上调度资源。如果您使用的是CPU和内存资源有限的小集群，您可能会很容易耗尽资源，这将导致新的部署无法在工作节点上调度。因此，除非在配方的要求中提到，否则在继续下一个配方之前始终清理旧的部署。
- en: 'Let''s perform the following step to remove `nginx-deployment`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来删除`nginx-deployment`：
- en: 'Delete the Deployment before moving onto the next recipes:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续下一个步骤之前，请删除部署：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding command will immediately terminate the Deployment and remove the
    application from your cluster.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将立即终止部署并从集群中删除应用程序。
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The *Creating a Deployment* recipe showed you how to apply the desired state
    of your pods and ReplicaSets to the Deployment controller using YAML manifest
    files.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*创建部署*的步骤向您展示了如何使用YAML清单文件将您的Pod和ReplicaSets的期望状态应用到部署控制器。'
- en: In step 2, we used the `kubectl apply` command, which is a part of the declarative
    management approach and makes incremental changes rather than overwriting them.
    The first time you create a resource intent, you could instead use the `kubectl
    create` command, which is considered an imperative management method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们使用了`kubectl apply`命令，这是声明性管理方法的一部分，它进行增量更改而不是覆盖它们。第一次创建资源意图时，您可以使用`kubectl
    create`命令，这被认为是一种命令式管理方法。
- en: I prefer to use the `apply` command, where declarative patterns are allowed,
    instead of `create` since it is better for creating the CI script and does not
    raise an error if the resource already exists.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢使用`apply`命令，因为它允许声明性模式，而不是`create`，因为它更适合创建CI脚本，并且如果资源已经存在，则不会引发错误。
- en: Now you have learned the fundamental steps to get a single Deployment running
    in Kubernetes, we can move on to more complex Deployment use cases to compose
    a collection of objects using Kustomize, Helm, and Operator frameworks.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了在Kubernetes中运行单个部署的基本步骤，我们可以继续进行更复杂的部署用例，使用Kustomize、Helm和Operator框架来组成一系列对象。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: A linter for YAML files: [https://github.com/adrienverge/yamllint](https://github.com/adrienverge/yamllint)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAML文件的语法检查器：[https://github.com/adrienverge/yamllint](https://github.com/adrienverge/yamllint)
- en: 'Online Kubernetes YAML validator: [https://kubeyaml.com/](https://kubeyaml.com/)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线Kubernetes YAML验证器：[https://kubeyaml.com/](https://kubeyaml.com/)
- en: Read more on the declarative management of Kubernetes objects using configuration
    files: [https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/](https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读更多关于使用配置文件进行Kubernetes对象的声明性管理：[https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/](https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/)
- en: 'Authoring Kubernetes manifests guide: [https://github.com/bitnami/charts/blob/master/_docs/authoring-kubernetes-manifests.md ](https://github.com/bitnami/charts/blob/master/_docs/authoring-kubernetes-manifests.md)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Kubernetes清单指南：[https://github.com/bitnami/charts/blob/master/_docs/authoring-kubernetes-manifests.md](https://github.com/bitnami/charts/blob/master/_docs/authoring-kubernetes-manifests.md)
- en: Deploying workloads using Kustomize
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kustomize部署工作负载
- en: In this section, we will show you how to generate resources from files and compose
    and customize collections of resources in Kubernetes. You will learn about the
    declarative management of Kubernetes objects using Kustomize.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何从文件生成资源，并在Kubernetes中组成和自定义资源集合。您将了解使用Kustomize进行Kubernetes对象的声明性管理。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: Make sure you have a Kubernetes cluster ready and `kubectl` configured to manage
    the cluster resources.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已准备好一个Kubernetes集群，并配置了`kubectl`来管理集群资源。
- en: The source files created in this section can be found on my GitHub repository
    located at [https://github.com/k8sdevopscookbook/src/tree/master/chapter2/kustomize](https://github.com/k8sdevopscookbook/src/tree/master/chapter2/kustomize).
    It is recommended that you follow the instructions to create and edit them and
    only use the files in the repository to compare with your files if you run into
    an issue.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中创建的源文件可以在我的GitHub存储库中找到，位于[https://github.com/k8sdevopscookbook/src/tree/master/chapter2/kustomize](https://github.com/k8sdevopscookbook/src/tree/master/chapter2/kustomize)。建议您按照说明创建和编辑它们，并且只在遇到问题时使用存储库中的文件与您的文件进行比较。
- en: How to do it…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下…
- en: 'This section is further divided into the following subsections to ease the
    process:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本节进一步分为以下小节，以便简化流程：
- en: Validating the Kubernetes cluster version
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证Kubernetes集群版本
- en: Generating Kubernetes resources from files
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件生成Kubernetes资源
- en: Creating a base for a development and production Deployment
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为开发和生产部署创建一个基础
- en: Validating the Kubernetes cluster version
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证Kubernetes集群版本
- en: For Kustomize to function, Kubernetes cluster version 1.14.0 or later is required,
    since Kustomize support is only included with kubectl v.1.14.0 and later.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Kustomize正常运行，需要Kubernetes集群版本1.14.0或更高版本，因为Kustomize支持仅包含在kubectl v.1.14.0及更高版本中。
- en: 'List the nodes to confirm your Kubernetes cluster version and make sure that
    it is 1.14.0 or later:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出节点以确认您的Kubernetes集群版本，并确保其为1.14.0或更高版本：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding example, the version shows `v1.15.0`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，版本显示为`v1.15.0`。
- en: Generating Kubernetes resources from files
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从文件生成Kubernetes资源
- en: 'Let''s learn how to customize the nginx rollout we did in the previous recipe
    using Kustomize this time:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何使用Kustomize定制我们在上一个配方中做的nginx滚动：
- en: 'Create a directory named `nginx`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`nginx`的目录：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Copy the `deployment-nginx.yaml` file you created in the *Deploying workload
    using YAML files* recipe under the `nginx` directory. This file still uses `image:
    nginx:1.7.9` as the container image:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将您在“使用YAML文件部署工作负载”配方中创建的`deployment-nginx.yaml`文件复制到`nginx`目录下。这个文件仍然使用`image:
    nginx:1.7.9`作为容器镜像：'
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a `kustomization.yaml` file by specifying a new image version:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过指定新的镜像版本创建一个`kustomization.yaml`文件：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Check that the new version is injected into your Deployment by running the
    following command. In the output, you will see `image: nginx:1.16.0` instead of
    the original image version `nginx:1.7.9` that we have previously used in the `deployment-nginx.yaml`
    file:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '通过运行以下命令检查新版本是否被注入到您的部署中。在输出中，您将看到`image: nginx:1.16.0`，而不是我们之前在`deployment-nginx.yaml`文件中使用的原始镜像版本`nginx:1.7.9`：'
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Apply the Deployment with customizations using the `-k` parameter:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-k`参数应用定制的部署：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a new `kustomization.yaml` file by specifying a newer image version:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过指定一个更新的镜像版本创建一个新的`kustomization.yaml`文件：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Apply the customized Deployment using the `-k` parameter:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-k`参数应用定制的部署：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, display the rollout history for the Deployment:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，显示部署的滚动历史：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now you have learned how to edit, scale up, and also roll out a new version
    of the application using Kustomize.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何使用Kustomize编辑、扩展，并通过Kustomize推出应用的新版本。
- en: Creating a base for a development and production Deployment
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为开发和生产部署创建一个基础
- en: 'Let''s perform the following steps to create a base for a local Docker image
    registry Deployment that we will use later in this chapter:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来创建一个本地Docker镜像注册表部署的基础，我们将在本章后面使用：
- en: 'Create a directory named `registry` and another one underneath called `base`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`registry`的目录，并在其下创建一个名为`base`的目录：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Under `registry/base`, download the Deployment file named `deployment-registry.yaml`
    from the example repository:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`registry/base`下，从示例存储库中下载名为`deployment-registry.yaml`的部署文件：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Review the file to understand its structure. You will see that it is a `Deployment` manifest
    consisting of two containers named `registry` and `registryui`. You will see that
    the registry container has a `volumeMount` named `registry-storage` and this volume
    is provided by a persistent volume claim named `registry-pvc`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看文件以了解其结构。您将看到它是一个包含两个名为`registry`和`registryui`的容器的`Deployment`清单。您将看到注册表容器有一个名为`registry-storage`的`volumeMount`，这个卷是由名为`registry-pvc`的持久卷声明提供的：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Under the same `registry/base`, download the service manifest file named `service-registry.yaml` from
    the example repository:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的`registry/base`下，从示例存储库中下载名为`service-registry.yaml`的服务清单文件：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Review the file to understand its structure. You will see that it is a service
    manifest that exposes the service on each Node''s IP at a static port; in this
    recipe, port `5000` for the `registry` service and port `80` for the `registry-ui`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看文件以了解其结构。您将看到这是一个服务清单，它在每个节点的IP上以静态端口暴露服务；在这个示例中，`registry`服务的端口为`5000`，`registry-ui`服务的端口为`80`：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a `PersistentVolumeClaim` manifest file named `pvc-registry.yaml` with
    the following content:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pvc-registry.yaml`的`PersistentVolumeClaim`清单文件，内容如下：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: At this point, you can deploy the workload using all the resource files under
    the `registry` directory, by using `kubectl apply -f registry/base`. But every
    time you need to change a parameter in resources, such as `app` or `label`, you
    need to edit the files. The whole point of using Kustomize is to take advantage
    of reusing the files without modifying the source of the files.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可以使用`kubectl apply -f registry/base`来部署`registry`目录下的所有资源文件。但是，每当您需要更改资源中的参数，比如`app`或`label`时，您需要编辑这些文件。使用Kustomize的整个目的是利用重用文件而无需修改文件的源。
- en: 'And finally, create the `kustomization.yaml` file. The following command will
    create the Kustomize resource content with the three separate manifest files we
    created previously:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建`kustomization.yaml`文件。以下命令将创建Kustomize资源内容，其中包括我们之前创建的三个单独的清单文件：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, create two overlays to be used for development and production Deployments.
    The first one is for development:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建两个用于开发和生产部署的叠加层。第一个是用于开发的：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And the second manifest will create the overlay for production:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个清单将为生产创建叠加层：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Check that `dev` and `prod` prefixes are injected into your Deployment. When
    you point to the `prod` folder, the annotation note will display `"Hello, I am
    production!"`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`dev`和`prod`前缀是否注入到您的部署中。当您指向`prod`文件夹时，注释说明将显示“你好，我是生产！”：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When you point to the `dev` folder, the annotation note will display `"Hello,
    I am development!"`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您指向`dev`文件夹时，注释说明将显示“你好，我是开发！”：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, deploy the `dev` version of your application:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，部署您应用的`dev`版本：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Similarly, you can inject labels, patch image versions, change the number of
    replicas, and deploy resources into a different namespace.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以注入标签，修补图像版本，更改副本的数量，并将资源部署到不同的命名空间。
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe showed you how to manage and implement basic version control of
    your configuration files using Git.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例向您展示了如何使用Git管理和实现配置文件的基本版本控制。
- en: In the *Creating a base for a development and production Deployment* recipe,
    the resources we created between step 2 and step 6 under the `base` directory
    represents an upstream repository of the application/workload, and the customizations
    we created between step 8 and step 10 under the `overlay` directory are the changes
    you control and store in your repository.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在*为开发和生产部署创建基础*配方中，我们在`base`目录下创建的资源代表应用程序/工作负载的上游存储库，而在`overlay`目录下在第8步和第10步之间创建的自定义内容是您在存储库中控制和存储的更改。
- en: 'Later, if you need to see the difference of a variant, you can use the `diff`
    parameter as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，如果您需要查看变体的差异，可以使用以下`diff`参数：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: By separating the changes from the base, we were able to customize template-free
    YAML files for multiple purposes, leaving the original YAML files unchanged, making
    the version controlling of source and changes possible.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将更改与基础分离，我们能够为多种目的定制无模板的YAML文件，保持原始YAML文件不变，从而实现源和更改的版本控制。
- en: See also
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Kustomize concepts overview slides: [https://speakerdeck.com/spesnova/introduction-to-kustomize](https://speakerdeck.com/spesnova/introduction-to-kustomize)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kustomize概念概述幻灯片：[https://speakerdeck.com/spesnova/introduction-to-kustomize](https://speakerdeck.com/spesnova/introduction-to-kustomize)
- en: Declarative application management in Kubernetes background whitepaper – a highly
    recommended read: [https://goo.gl/T66ZcD](https://goo.gl/T66ZcD)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes背景下的声明式应用程序管理白皮书-强烈推荐阅读：[https://goo.gl/T66ZcD](https://goo.gl/T66ZcD)
- en: Common terms in Kustomize: [https://github.com/kubernetes-sigs/kustomize/blob/master/docs/glossary.md](https://github.com/kubernetes-sigs/kustomize/blob/master/docs/glossary.md)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kustomize中的常见术语：[https://github.com/kubernetes-sigs/kustomize/blob/master/docs/glossary.md](https://github.com/kubernetes-sigs/kustomize/blob/master/docs/glossary.md)
- en: Additional Kustomize examples: [https://github.com/kubernetes-sigs/kustomize/tree/master/examples](https://github.com/kubernetes-sigs/kustomize/tree/master/examples)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他Kustomize示例：[https://github.com/kubernetes-sigs/kustomize/tree/master/examples](https://github.com/kubernetes-sigs/kustomize/tree/master/examples)
- en: Deploying workloads using Helm charts
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Helm图表部署工作负载
- en: In this section, we will show you how to use Helm charts in Kubernetes. Helm
    is the package manager for Kubernetes, which helps developers and SREs to easily
    package, configure, and deploy applications.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何在Kubernetes中使用Helm图表。Helm是Kubernetes的软件包管理器，可帮助开发人员和SRE轻松打包、配置和部署应用程序。
- en: You will learn how to install Helm on your cluster and use Helm to manage the
    life cycle of third-party applications.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习如何在集群上安装Helm并使用Helm来管理第三方应用程序的生命周期。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have a Kubernetes cluster ready and `kubectl` configured to manage
    the cluster resources.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已准备好Kubernetes集群，并配置了`kubectl`来管理集群资源。
- en: How to do it…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'This section is further divided into the following subsections to ease the
    process:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本节进一步分为以下子节，以便简化流程：
- en: Installing Helm 2.x
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Helm 2.x
- en: Installing an application using Helm charts
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Helm图表安装应用程序
- en: Searching for an application in Helm repositories
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Helm存储库中搜索应用程序
- en: Updating an application using Helm
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Helm更新应用程序
- en: Rolling back an application using Helm
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Helm回滚应用程序
- en: Adding new Helm repositories
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的Helm存储库
- en: Deleting an application using Helm
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Helm删除应用程序
- en: Building a Helm chart
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Helm图表
- en: Installing Helm 2.x
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Helm 2.x
- en: 'Let''s perform the following steps to configure the prerequisites and install
    Helm:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来配置先决条件并安装Helm：
- en: 'Create a `ServiceAccount` by using the following command:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建`ServiceAccount`：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a `ClusterRoleBinding` by using the following command:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建`ClusterRoleBinding`：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Download the Helm installation script. This `install-helm.sh` script will detect
    the architecture of your system and get the latest correct binaries to install
    Helm:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Helm安装脚本。此`install-helm.sh`脚本将检测系统的架构并获取最新的正确二进制文件以安装Helm：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Run the script to install Helm. The following command will install the two
    important binaries, Helm and Tiller, required to run Helm:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本安装Helm。以下命令将安装运行Helm所需的两个重要二进制文件Helm和Tiller：
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run the `init` parameter to configure Helm with the service account we created
    in step 1*.* The `--history-max` parameter is used to purge and limit the Helm
    history, since without this setting the history can grow indefinitely and cause
    problems:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`init`参数以使用我们在第1步创建的服务帐户配置Helm。`--history-max`参数用于清除和限制Helm历史记录，因为如果没有此设置，历史记录可能会无限增长并引起问题：
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This process with install the Helm server-side component Tiller in your cluster.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程将在您的集群中安装Helm服务器端组件Tiller。
- en: If you get a message complaining that `Tiller is already installed in the cluster.`,
    you can run the same command by adding the `--upgrade` parameter to the end of
    the command and force-upgrading the existing version.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到`Tiller已经安装在集群中`的消息，可以在命令的末尾添加`--upgrade`参数运行相同的命令，并强制升级现有版本。
- en: 'Confirm the Helm version by running the following command:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令确认Helm版本：
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: At the time of writing this recipe, the latest stable version of Helm was v2.15.1
    and the next version, Helm 3, was still in beta. In the following chapters and
    recipes, we will base our instruction on the Helm 2.x version.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Helm的最新稳定版本是v2.15.1，下一个版本Helm 3仍处于测试阶段。在接下来的章节和配方中，我们将基于Helm 2.x版本进行指导。
- en: Installing an application using Helm charts
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Helm图表安装应用程序
- en: 'Let''s perform the following steps to install a Helm chart from the official
    Helm repository location:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤，从官方Helm存储库位置安装Helm图表：
- en: 'Before you install a chart, always sync the repository to pull the latest content.
    Otherwise, you may end up with the old version of the Helm charts:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装图表之前，始终同步存储库以获取最新内容。否则，您可能会得到旧版本的Helm图表：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Install an example chart, in this case, `stable/mysql`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装示例图表，例如`stable/mysql`：
- en: '[PRE50]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Similarly, you can install other applications from the Helm charts stable repository
    or add your own repositories for custom charts.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以从Helm图表稳定存储库安装其他应用程序，或者添加自己的存储库以获取自定义图表。
- en: 'Every time you install a chart, a new release with a random name is created
    unless specified with the `--name` parameter. Now, list the releases:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 每次安装图表时，都会创建一个具有随机名称的新发布，除非使用`--name`参数指定。现在，列出发布：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Check the status in the release, in our example, `my-mysqlrelease`:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查发布状态，在我们的示例中是`my-mysqlrelease`：
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You will get the Deployment status and information on all resources.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得部署状态和所有资源的信息。
- en: Searching for an application in Helm repositories
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Helm存储库中搜索应用程序
- en: 'Let''s perform the following steps to search for an application you would like
    to deploy on Kubernetes from the Helm chart repositories:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤，从Helm图表存储库中搜索要在Kubernetes上部署的应用程序：
- en: 'Search for a chart in the repository. The following command will look for your
    search words in the Helm repositories that you have access to:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在存储库中搜索图表。以下命令将在您可以访问的Helm存储库中查找您搜索的词语：
- en: '[PRE53]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can find the complete list of workloads in helm/stable and the source of
    the repository at the following GitHub link: [https://github.com/helm/charts/tree/master/stable ](https://github.com/helm/charts/tree/master/stable)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在helm/stable中找到所有工作负载的完整列表，并在以下GitHub链接的存储库中找到源代码：[https://github.com/helm/charts/tree/master/stable ](https://github.com/helm/charts/tree/master/stable)
- en: 'Your `search` keyword doesn''t have to be the exact name of the project. You
    can also search for keywords such as `Storage`, `MQ`, or `Database`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的`search`关键字不一定要是项目的确切名称。您还可以搜索关键字，如`Storage`、`MQ`或`Database`：
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: By default, your repository list is limited to the `helm/stable` location but
    later, in the *A**dding new Helm repositories* recipe, you will also learn how
    to add new repositories to extend your search coverage to other repositories.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，您的存储库列表仅限于`helm/stable`位置，但稍后在*添加新的Helm存储库*配方中，您还将学习如何添加新的存储库以扩展您的搜索范围到其他存储库。
- en: Upgrading an application using Helm
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Helm升级应用程序
- en: 'There are a couple of ways to use an upgrade. Let''s perform the following
    steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种使用升级的方法。让我们执行以下步骤：
- en: 'Upgrade the release, in our case, `my-mysqlrelease`, with a newer chart version
    when available:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 升级发布，在我们的例子中是`my-mysqlrelease`，使用更新的图表版本：
- en: '[PRE55]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the future, you may find a specific version of the application that is more
    stable in your environment or keep the installations identical in multiple clusters.
    In that case, you can update the chart version with your preferred chart version
    using the following command:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将来，您可能会发现应用程序的特定版本在您的环境中更加稳定，或者在多个集群中保持安装的一致。在这种情况下，您可以使用以下命令使用您偏好的图表版本更新图表版本：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Confirm the chart version change using the following command. After upgrading
    the version in step 2, you should expect to see `mysql --version 1.2.0`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令确认图表版本更改。在第2步升级版本后，您应该期望看到`mysql --version 1.2.0`：
- en: '[PRE57]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'See the history of revisions using the following command. Since we recently
    updated the chart version, you should see at least two revisions in the history:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令查看修订历史。由于我们最近更新了图表版本，您应该在历史记录中看到至少两个修订版本：
- en: '[PRE58]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Use the `helm upgrade` function to update a parameter on an existing release
    by specifying a parameter using the `--set key=value[,key=value]` argument. The
    following command will set two MySQL password using the `--set mysqlRootPassword`
    parameter:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`helm upgrade`函数通过使用`--set key=value[,key=value]`参数指定参数来更新现有发布上的参数。以下命令将使用`--set
    mysqlRootPassword`参数设置两个MySQL密码：
- en: '[PRE59]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Confirm that the password is actually updated. You should expect to get the
    same password you set in step 4:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认密码实际上已更新。您应该期望得到与第4步设置的相同密码：
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now you have learned how to upgrade a Helm release with new parameters.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何使用新参数升级Helm发布。
- en: Rolling back an application using Helm
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Helm回滚应用程序
- en: 'Let''s perform the following steps to recall an upgrade and bring your application
    status to a previous revision:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤，撤消升级并将应用程序状态恢复到先前的修订版本：
- en: 'List the revision history for your release, in our example, `coy-jellyfish`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出您的发布的修订历史，例如`coy-jellyfish`：
- en: '[PRE61]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s say you need to roll back from the last upgrade to revision `4`. Roll
    back to a specific revision:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您需要从最后一次升级回滚到修订版本`4`。回滚到特定的修订版本：
- en: '[PRE62]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The revision history will be updated to reflect your rollback:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修订历史将更新以反映您的回滚：
- en: '[PRE63]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now you have learned how to review the release history and roll back a Helm
    release when needed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何查看发布历史并在需要时回滚Helm发布。
- en: Deleting an application using Helm
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Helm删除应用程序
- en: 'Let''s perform the following steps to remove an application deployed with Helm
    from your Kubernetes cluster:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤，从您的Kubernetes集群中使用Helm删除部署的应用程序：
- en: 'Use the `helm ls` command with the `--all` parameter to list all the releases,
    including deleted revisions:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`helm ls`命令和`--all`参数列出所有发布，包括已删除的修订版本：
- en: '[PRE64]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Delete a release using the `--purge` parameter. The following command will
    completely remove the application from your cluster:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`--purge`参数删除一个发布。以下命令将完全从您的集群中删除应用程序：
- en: '[PRE65]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The preceding command will immediately terminate the Deployment and remove the
    Helm release from your cluster.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将立即终止部署并从集群中删除Helm发布。
- en: Adding new Helm repositories
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新的Helm存储库
- en: By default, Helm only uses the official Helm/stable repository for lookups and
    often in the following chapters, we will need to add additional repositories from
    third-party vendors using the method explained in this recipe.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Helm只使用官方的Helm/stable存储库进行查找，通常在接下来的章节中，我们需要使用本教程中解释的方法从第三方供应商那里添加额外的存储库。
- en: 'Let''s perform the following steps to add additional Helm repositories to your
    source list:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来将额外的Helm存储库添加到你的源列表中：
- en: 'Check the list of existing repositories. You should only see `stable` and `local` on
    the list:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查现有存储库的列表。你应该只能看到列表上的`stable`和`local`：
- en: '[PRE66]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We need a persistent volume and authentication configured for our repository
    server. Create a file called `customhelmrepo.yaml` using the following content:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为我们的存储库服务器配置一个持久卷和认证。使用以下内容创建一个名为`customhelmrepo.yaml`的文件：
- en: '[PRE67]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create a repository server using a persistent volume:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用持久卷创建一个存储库服务器：
- en: '[PRE68]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Get the service IP for `chartmuseum`. The following command will return an
    IP address, in our example, `10.3.0.37`:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`chartmuseum`的服务IP。以下命令将返回一个IP地址，在我们的例子中是`10.3.0.37`：
- en: '[PRE69]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add the new Helm repository to your list of repositories; in our case, the
    IP is `10.3.0.37`:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的Helm存储库添加到你的存储库列表中；在我们的例子中，IP是`10.3.0.37`：
- en: '[PRE70]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Check the list of existing repositories:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查现有存储库的列表：
- en: '[PRE71]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: There are many options available to host your chart repository. You can deploy
    a local repository using an open source Helm repository server called **ChartMuseum**,
    on an S3 bucket, GitHub pages, or a classic web server. For simplicity, we used
    Helm itself to deploy a server. You can find alternative hosting methods for Helm
    charts under the *See also* section.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多选项可用于托管你的图表存储库。你可以使用一个名为ChartMuseum的开源Helm存储库服务器部署一个本地存储库，也可以使用S3存储桶、GitHub页面或经典的Web服务器。为了简单起见，我们使用Helm本身来部署服务器。你可以在*另请参阅*部分找到Helm图表的替代托管方法。
- en: Building a Helm chart
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建一个Helm图表
- en: 'Let''s perform the following steps to build a custom Helm chart to be published
    in your local `chartmuseum` repository:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来构建一个自定义的Helm图表，以便发布到你的本地`chartmuseum`存储库中：
- en: 'Create a chart called `mychart`:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`mychart`的图表：
- en: '[PRE72]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Edit your chart structure as you like and test the templates for possible errors:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你的喜好编辑你的图表结构并测试模板可能出现的错误：
- en: '[PRE73]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Test your application using `--dry-run`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`--dry-run`测试你的应用程序：
- en: '[PRE74]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '4\. Build the Helm chart. By running the following command, you will generate
    a tarball package of your Helm repository from the `mychart` location:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 构建Helm图表。通过运行以下命令，你将从`mychart`位置生成一个Helm存储库的tarball包：
- en: '[PRE75]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Replace the Helm repository server address with your Helm server and upload
    this Helm chart package using a URL:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用你的Helm服务器替换Helm存储库服务器地址，并使用URL上传这个Helm图表包：
- en: '[PRE76]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now you have learned how to create, lint, test, package, and upload your new
    chart to your local ChartMuseum-based Helm repository.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何创建、清理、测试、打包和上传你的新图表到本地基于ChartMuseum的Helm存储库。
- en: How it works...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe showed you how to install the Helm package manager and build your
    first Helm chart.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程向你展示了如何安装Helm包管理器并构建你的第一个Helm图表。
- en: When we built the Helm chart in the *Building a Helm chart* recipe, in step
    1, the `helm create` command created a couple of files as a template under the
    `chart` folder. You can start by editing these files or create them from scratch
    when you become more comfortable with the structure.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在*构建Helm图表*教程中构建Helm图表时，在第1步中，`helm create`命令在`chart`文件夹下创建了一些文件作为模板。你可以通过编辑这些文件或者在你对结构更加熟悉时从头开始创建它们。
- en: 'The `helm create` command creates the templates that construct our Helm chart.
    The contents and their functionality are explained here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm create`命令创建了构建我们Helm图表的模板。这里解释了内容及其功能：'
- en: '[PRE77]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In the *Building a Helm chart* recipe, in step 3, `helm install`, when used
    along with the `--dry-run` parameter, sends the chart to the server and returns
    the rendered template only instead of installing it. This is usually used for
    testing Helm charts.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在*构建Helm图表*的步骤中，在第3步`helm install`中，当与`--dry-run`参数一起使用时，会将图表发送到服务器，并返回渲染的模板，而不是安装它。这通常用于测试Helm图表。
- en: In the same recipe, in step 4, the `helm package` command packages your complete
    chart into a chart archive, basically a tarball.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一步骤中，在第4步中，`helm package`命令将您的完整图表打包成图表存档，基本上是一个tarball。
- en: In step 5, we used the `curl` command to send the packaged tarball binary to
    our ChartMuseum server, an HTTP server, so it can serve our Helm chart archives
    when it receives `GET` requests from the `helm` command.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步中，我们使用`curl`命令将打包的tarball二进制文件发送到我们的ChartMuseum服务器，一个HTTP服务器，以便在接收到`helm`命令的`GET`请求时为我们提供Helm图表存档。
- en: Now you have learned how to install Helm charts and create your Helm charts
    in your local repositories, you will be able to install the third-party charts
    required in the next chapters, as well as building your own artifacts in your
    CI/CD pipelines.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何安装Helm图表并在本地存储库中创建您自己的Helm图表，您将能够安装下一章节中所需的第三方图表，以及在CI/CD流水线中构建您自己的构件。
- en: See also
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The Helm documentation: [https://docs.helm.sh](https://docs.helm.sh)'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm文档：[https://docs.helm.sh](https://docs.helm.sh)
- en: Alternative hosting methods for Helm charts: https://v2.helm.sh/docs/chart_repository/
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm图表的替代托管方法：https://v2.helm.sh/docs/chart_repository/
- en: Getting started with a chart template: [https://helm.sh/docs/chart_template_guide/ ](https://helm.sh/docs/chart_template_guide/)
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图表模板入门：[https://helm.sh/docs/chart_template_guide/](https://helm.sh/docs/chart_template_guide/)
- en: 'Fields required to build the `Chart.yaml` file: [https://v2.helm.sh/docs/chart_template_guide/](https://v2.helm.sh/docs/chart_template_guide/)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`Chart.yaml`文件所需的字段：[https://v2.helm.sh/docs/chart_template_guide/](https://v2.helm.sh/docs/chart_template_guide/)
- en: J-Frog Container Registry, a powerful Hybrid Docker and Helm registry: [https://jfrog.com/container-registry/](https://jfrog.com/container-registry/)
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: J-Frog容器注册表，一个强大的混合Docker和Helm注册表：[https://jfrog.com/container-registry/](https://jfrog.com/container-registry/)
- en: Deploying and operating applications using Kubernetes operators
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes操作员部署和操作应用程序
- en: Kubernetes operators are another method of bundling, deploying, and managing application
    for Kubernetes. Operators are a bit more complex than a package manager like Helm.
    An operator helps to remove manual steps, application-specific preparation, and
    post-deployment steps, and even automates second-day operations such as scaling
    or upgrading them for the user.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes操作员是另一种在Kubernetes上打包、部署和管理应用程序的方法。操作员比Helm等包管理器更复杂。操作员有助于消除手动步骤、特定于应用程序的准备工作和部署后步骤，甚至自动化用户的二天操作，如扩展或升级。
- en: As an example, an application's requirements might be validated differently
    based on the platform on which it is installed or may require changes to its configuration
    and interaction with external systems.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个应用程序的要求可能会根据其安装的平台而有所不同，或者可能需要更改其配置并与外部系统进行交互。
- en: In this section, we will deploy two operators for popular stateful applications
    based on two different operator frameworks and learn what functionalities they
    offer.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将部署两个基于两种不同操作员框架的热门有状态应用程序的操作员，并了解它们提供了哪些功能。
- en: Getting ready
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have a Kubernetes cluster ready and kubectl configured to manage
    the cluster resources.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经准备好一个Kubernetes集群，并配置了`kubectl`来管理集群资源。
- en: How to do it…
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'This section is further divided into the following subsections to ease the
    process:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 该部分进一步分为以下子部分以简化流程：
- en: Installing **KUDO** (short for **Kubernetes Universal Declarative Operator**)
    and the KUDO kubectl plugin
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装**KUDO**（**Kubernetes通用声明运算符**）和KUDO kubectl插件
- en: Installing the Apache Kafka operator using KUDO
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用KUDO安装Apache Kafka运算符
- en: Installing Operator Lifecycle Manager
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Operator Lifecycle Manager
- en: Installing the Zalando PostgreSQL operator
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Zalando PostgreSQL运算符
- en: Installing KUDO and the KUDO kubectl plugin
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装KUDO和KUDO kubectl插件
- en: 'Before you can install applications using KUDO operators, you need to install
    KUDO. We will install KUDO using `brew`, a package manager used in Linux for the
    simple installation of binaries on Linux; therefore, you will also need brew installed
    if you haven''t done it already:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用KUDO运算符安装应用程序之前，您需要安装KUDO。我们将使用`brew`来安装KUDO，这是Linux上用于简单安装二进制文件的软件包管理器；因此，如果您还没有安装`brew`，您也需要安装它：
- en: Follow the Helm instructions in the *Deploying workloads using Helm charts* recipe
    to get Helm running.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照*使用Helm图表部署工作负载*中的Helm说明来运行Helm。
- en: 'Install `brew` by using the following commands:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装`brew`：
- en: '[PRE78]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Install KUDO and the `kudo kubectl` plugin using `brew install` by running
    the following command:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令使用`brew install`安装KUDO和`kudo kubectl`插件：
- en: '[PRE79]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Install KUDO as follows:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式安装KUDO：
- en: '[PRE80]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: It is worth mentioning that Kubernetes operators are a developing concept in
    the Kubernetes community. There are multiple operator frameworks, such as the
    Red Hat Operator Framework, D2iQ's KUDO, and many others out there. Also, for
    each workload, you will find a number of operators developed by the community.
    I recommend testing a few flavors before you decide to use an operator to find
    the operator that fits your use case.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，Kubernetes运算符是Kubernetes社区中一个不断发展的概念。有多个运算符框架，例如Red Hat Operator Framework、D2iQ的KUDO等。此外，对于每个工作负载，您会发现社区开发了许多运算符。我建议在决定使用运算符之前测试几种不同的运算符，以找到适合您用例的运算符。
- en: Now you have the KUDO controller installed to test some stateful running applications
    using Kubernetes Operators.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了KUDO控制器，可以使用Kubernetes Operators测试一些有状态的运行应用程序。
- en: Installing the Apache Kafka Operator using KUDO
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用KUDO安装Apache Kafka Operator
- en: There are multiple Kafka operators listed in the *See also* section, such as
    Strimzi, Banzai Cloud, Confluent, krallistic, and others. Although I don't have
    any preference in this recipe, as an example, we will deploy the Apache Kafka
    Operator based on the KUDO Operator.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在*另请参阅*部分列出了多个Kafka运算符，例如Strimzi、Banzai Cloud、Confluent、krallistic等。虽然在本文中我没有偏好，但作为示例，我们将基于KUDO
    Operator部署Apache Kafka Operator。
- en: 'Let''s perform the following steps:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Kafka requires ZooKeeper. Let''s create a ZooKeeper cluster:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kafka需要ZooKeeper。让我们创建一个ZooKeeper集群：
- en: '[PRE81]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create a Kafka cluster using the KUDO Kafka Operator:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用KUDO Kafka Operator创建Kafka集群：
- en: '[PRE82]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'List KUDO Operators by querying the `Operators` CRD APIs as follows. After
    deploying Kafka, which also has a ZooKeeper dependency, you should see both `kafka`
    and `zookeeper` operators:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查询`Operators` CRD API列出KUDO运算符如下。在部署Kafka之后，您还应该看到`kafka`和`zookeeper`运算符：
- en: '[PRE83]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'List KUDO instances:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出KUDO实例：
- en: '[PRE84]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now you have learned how to deploy both ZooKeeper and Kafka using the KUDO Operator.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何使用KUDO Operator部署ZooKeeper和Kafka。
- en: Installing Operator Lifecycle Manager
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Operator Lifecycle Manager
- en: Before you can install applications using Red Hat Operator Framework Operators,
    you need to install **Operator Lifecycle Manager** (**OLM**). Note that OLM is
    installed by default in OpenShift 4.0 and precedent.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Red Hat Operator Framework运算符安装应用程序之前，您需要安装**Operator Lifecycle Manager**（**OLM**）。请注意，OLM在OpenShift
    4.0及更高版本中默认安装。
- en: 'Install OLM. It is required for our next recipe,* Installing the Zalando PostgreSQL
    Operator*:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装OLM。这是我们下一个配方*安装Zalando PostgreSQL Operator*所需的：
- en: '[PRE85]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now you have OLM installed to test some stateful running applications using
    an Operator Framework.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了OLM来测试使用Operator Framework运行一些有状态的应用程序。
- en: Installing the Zalando PostgreSQL Operator
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Zalando PostgreSQL Operator
- en: There are multiple PostgreSQL Operators listed in the *See also* section, such
    as CrunchyDB and Zalando. In this recipe, as an example, we will deploy the Zalando
    PostgreSQL Operator to manage the life cycle of PostgreSQL Deployments in your
    Kubernetes cluster.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在*另请参阅*部分列出了多个PostgreSQL Operators，例如CrunchyDB和Zalando。在本示例中，我们将部署Zalando PostgreSQL
    Operator来管理Kubernetes集群中的PostgreSQL部署的生命周期。
- en: 'Let''s perform the following steps to get the Zalando PostgreSQL Operator deployed
    using the Operator Hub:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来使用Operator Hub部署Zalando PostgreSQL Operator：
- en: 'Install the `postgres-Operator` from the Operator Hub:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Operator Hub安装`postgres-Operator`：
- en: '[PRE86]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Verify that `postgres-Operator` is running:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`postgres-Operator`是否正在运行：
- en: '[PRE87]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now that the PostgreSQL Operator is up and running, let''s deploy the Postgres
    Operator UI:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在PostgreSQL Operator已经启动运行，让我们部署Postgres Operator UI：
- en: '[PRE88]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Deploy PostgreSQL. The following command will create a small two-instance PostgreSQL
    cluster:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署PostgreSQL。以下命令将创建一个小的两实例PostgreSQL集群：
- en: '[PRE89]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'List PostgreSQL instances that are managed by the Zalando Operator. It will
    show a cluster named `acid-minimal-cluster`:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出由Zalando Operator管理的PostgreSQL实例。它将显示一个名为`acid-minimal-cluster`的集群：
- en: '[PRE90]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'First get your cluster credentials and connect to your PostgreSQL using the
    `psql` interactive PostgreSQL terminal as follows:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先获取您的集群凭据，并使用`psql`交互式PostgreSQL终端连接到您的PostgreSQL，如下所示：
- en: '[PRE91]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Delete your PostgreSQL cluster:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除您的PostgreSQL集群：
- en: '[PRE92]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Now you have learned how to simply use popular Kubernetes Operators to deploy
    and manage workloads on Kubernetes. You can apply this knowledge later to simplify
    the life cycle management of stateful workloads you use in the development and
    production environment.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何简单地使用流行的Kubernetes Operators在Kubernetes上部署和管理工作负载。您可以稍后应用这些知识，以简化您在开发和生产环境中使用的有状态工作负载的生命周期管理。
- en: See also
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Deep dive on the Kubernetes Operators at KubeCon 2018: [https://developers.redhat.com/blog/2018/12/18/kubernetes-Operators-in-depth/](https://developers.redhat.com/blog/2018/12/18/kubernetes-operators-in-depth/)
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在KubeCon 2018上深入了解Kubernetes Operators：[https://developers.redhat.com/blog/2018/12/18/kubernetes-Operators-in-depth/](https://developers.redhat.com/blog/2018/12/18/kubernetes-operators-in-depth/)
- en: List of Kubernetes Operators by community: [https://github.com/Operator-framework/awesome-Operators](https://github.com/operator-framework/awesome-operators)
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社区提供的Kubernetes Operators列表：[https://github.com/Operator-framework/awesome-Operators](https://github.com/operator-framework/awesome-operators)
- en: List of Kubernetes Operators build using the Red Hat Operator SDK: [https://Operatorhub.io/](https://operatorhub.io/)
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Red Hat Operator SDK构建的Kubernetes Operators列表：[https://Operatorhub.io/](https://operatorhub.io/)
- en: The **Kubernetes Universal Declarative Operator** (**KUDO**): [https://kudo.dev/](https://kudo.dev/)
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes通用声明Operator**（**KUDO**）：[https://kudo.dev/](https://kudo.dev/)'
- en: 'Repository for KUDO-based Operators: [https://github.com/kudobuilder/Operators](https://github.com/kudobuilder/operators)'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于KUDO的Operators的存储库：[https://github.com/kudobuilder/Operators](https://github.com/kudobuilder/operators)
- en: A Python framework to write Kubernetes Operators in just a few lines of code: [https://github.com/zalando-incubator/kopf](https://github.com/zalando-incubator/kopf)
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Python框架，可以用几行代码编写Kubernetes Operators：[https://github.com/zalando-incubator/kopf](https://github.com/zalando-incubator/kopf)
- en: 'A list of alternative Kafka Operators:'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备用Kafka Operators列表：
- en: Apache Kafka Operator running on OpenShift: [http://strimzi.io/](http://strimzi.io/)
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在OpenShift上运行的Apache Kafka Operator：[http://strimzi.io/](http://strimzi.io/)
- en: KUDO Kafka Operator: [https://github.com/kudobuilder/Operators/tree/master/repository/kafka](https://github.com/kudobuilder/operators/tree/master/repository/kafka)
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'KUDO Kafka Operator: [https://github.com/kudobuilder/Operators/tree/master/repository/kafka](https://github.com/kudobuilder/operators/tree/master/repository/kafka)'
- en: Yet another Kafka Operator for Kubernetes: [https://github.com/banzaicloud/kafka-Operator](https://github.com/banzaicloud/kafka-operator)
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '另一个用于Kubernetes的Kafka Operator: [https://github.com/banzaicloud/kafka-Operator](https://github.com/banzaicloud/kafka-operator)'
- en: Istio Operator: [https://github.com/banzaicloud/istio-Operator](https://github.com/banzaicloud/istio-operator)
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Istio Operator: [https://github.com/banzaicloud/istio-Operator](https://github.com/banzaicloud/istio-operator)'
- en: 'A list of alternative PostgreSQL Operators:'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备用的PostgreSQL Operator列表：
- en: Crunchy Data PostgreSQL Operator: [https://github.com/CrunchyData/postgres-Operator](https://github.com/CrunchyData/postgres-operator)
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Crunchy Data PostgreSQL Operator: [https://github.com/CrunchyData/postgres-Operator](https://github.com/CrunchyData/postgres-operator)'
- en: Zalando PostgreSQL Operator: [https://github.com/zalando/postgres-Operator](https://github.com/zalando/postgres-operator)
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Zalando PostgreSQL Operator: [https://github.com/zalando/postgres-Operator](https://github.com/zalando/postgres-operator)'
- en: Deploying and managing the life cycle of Jenkins X
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和管理Jenkins X的生命周期
- en: Jenkins X is an open source solution that offers software developers pipeline
    automation, built-in GitOps, CI, automated testing, and CD, known as CI/CD, in
    Kubernetes. Jenkins X is highly focused on accelerating software delivery at a
    large scale using the Kubernetes ecosystem.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X是一个开源解决方案，为软件开发人员提供管道自动化、内置GitOps、CI、自动化测试和CD，即CI/CD，在Kubernetes中。Jenkins
    X专注于利用Kubernetes生态系统加速大规模软件交付。
- en: In this section, we will focus on Jenkins X recipes and create a Kubernetes
    cluster with CI/CD capabilities on your cloud provider.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于Jenkins X示例，并在您的云提供商上创建具有CI/CD功能的Kubernetes集群。
- en: Getting ready
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the following recipes, you will learn how to create a static Jenkins Server
    to deploy Kubernetes clusters with pipeline automation and automated CI/CD with
    GitOps promotion and preview environments.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，您将学习如何创建一个静态的Jenkins服务器，以部署具有管道自动化和自动CI/CD的Kubernetes集群，并使用GitOps推广和预览环境。
- en: This recipe requires kubectl and Helm. For this recipe, we will use **GKE** (short
    for** Google Kubernetes Engine**), therefore the gcloud CLI tool needs to be installed
    as well. You also need to have a proper GitHub organization and GitHub account
    created.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例需要kubectl和Helm。对于此示例，我们将使用**GKE**（**Google Kubernetes Engine**的缩写），因此还需要安装gcloud
    CLI工具。您还需要创建一个适当的GitHub组织和GitHub帐户。
- en: How to do it...
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'This section is further divided into the following subsections to ease the
    process:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 本节进一步分为以下小节，以便简化流程：
- en: Installing the Jenkins X CLI
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Jenkins X CLI
- en: Creating a Jenkins X Kubernetes cluster
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Jenkins X Kubernetes集群
- en: Verifying Jenkins X components
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证Jenkins X组件
- en: Switching Kubernetes clusters
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换Kubernetes集群
- en: Validating cluster conformance
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证集群一致性
- en: Installing the Jenkins X CLI
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Jenkins X CLI
- en: The Jenkins X CLI `jx` is used along with your preferred cloud provider CLI
    to orchestrate the Deployment of the Kubernetes cluster. Jenkins X supports Azure,
    AWS, **GCP** (short for** Google Cloud Platform**), IBM Cloud, Oracle Cloud, Minikube,
    Minishift, and OpenShift as the provider for the Deployment. For this recipe,
    we will use GKE. See the Jenkins X documentation for other vendor instructions.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X CLI `jx` 与您首选的云提供商CLI一起用于编排Kubernetes集群的部署。Jenkins X支持Azure、AWS、**GCP**（**Google
    Cloud Platform**的缩写）、IBM Cloud、Oracle Cloud、Minikube、Minishift和OpenShift作为部署的提供者。对于此示例，我们将使用GKE。请参阅Jenkins
    X文档以获取其他供应商的说明。
- en: 'Let''s perform the following steps to install Jenkins X CLI tool:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来安装Jenkins X CLI工具：
- en: Visit the JX release site ([https://github.com/jenkins-x/jx/releases](https://github.com/jenkins-x/jx/releases))
    and note the latest release version. At the time of writing, the latest release
    was v2.0.905.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问JX发布站点[https://github.com/jenkins-x/jx/releases](https://github.com/jenkins-x/jx/releases)并注意最新的发布版本。在撰写本文时，最新的发布版本是v2.0.905。
- en: 'Update the release version in the following command. Download and install the
    latest version of the Jenkins X CLI:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下命令中更新发布版本。下载并安装最新版本的Jenkins X CLI：
- en: '[PRE93]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Now you have the Jenkins X CLI installed, you can move on to the next recipe.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了Jenkins X CLI，你可以继续下一个步骤了。
- en: Creating a Jenkins X Kubernetes cluster
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个Jenkins X Kubernetes集群
- en: You may prefer other cloud vendors or on-premises deployment. For this recipe,
    we will use GKE. See the Jenkins X documentation for other vendor instructions.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能更喜欢其他云供应商或本地部署。在这个示例中，我们将使用GKE。查看Jenkins X文档以获取其他供应商的说明。
- en: 'Let''s perform the following steps to create your first Jenkins X Kubernetes
    cluster using `jx`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来使用`jx`创建你的第一个Jenkins X Kubernetes集群：
- en: 'Create a Kubernetes cluster with GKE using the `jx` command with the `gke`
    parameter as follows:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令和`gke`参数创建一个GKE的Kubernetes集群：
- en: '[PRE94]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Select your Google Cloud project; in our example, `devopscookbook`.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的Google Cloud项目；在我们的例子中是`devopscookbook`。
- en: Select `us-central1-a` when asked to pick a Google Cloud zone.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`us-central1-a`当被要求选择一个Google Cloud区域时。
- en: Select Static Jenkins Server and Jenkinsfiles as the installation type.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择静态Jenkins服务器和Jenkinsfiles作为安装类型。
- en: 'Enter your GitHub username:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入你的GitHub用户名：
- en: '[PRE95]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Enter your GitHub API token. Go to the GitHub Token page at [https://github.com/settings/tokens/new?scopes=repo,read:user,read:org,user:email,write:repo_hook,delete_repo](https://github.com/settings/tokens/new?scopes=repo,read:user,read:org,user:email,write:repo_hook,delete_repo)
    to get your API token:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入你的GitHub API令牌。前往GitHub Token页面[https://github.com/settings/tokens/new?scopes=repo,read:user,read:org,user:email,write:repo_hook,delete_repo](https://github.com/settings/tokens/new?scopes=repo,read:user,read:org,user:email,write:repo_hook,delete_repo)获取你的API令牌：
- en: '[PRE96]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'By default, Jenkins X will set the ingress rules to use the magic DNS `nip.io`
    domain:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Jenkins X会设置入口规则来使用魔术DNS `nip.io` 域：
- en: '[PRE97]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Enter `Yes` to the following question:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对以下问题输入`Yes`：
- en: '[PRE98]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Select the GitHub organization where you want to create the environment repository;
    in our case, `k8devopscookbook`.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要创建环境仓库的GitHub组织；在我们的例子中是`k8devopscookbook`。
- en: 'You will see a message similar to the following when your Deployment is successful:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你的部署成功时，你会看到类似以下的消息：
- en: '[PRE99]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: You can also find your admin password in the preceding output.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在前面的输出中找到你的管理员密码。
- en: Verifying Jenkins X components
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证Jenkins X组件
- en: 'Let''s perform the following steps to verify that all Jenkins X components
    are running as expected:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来验证所有Jenkins X组件是否按预期运行：
- en: 'Confirm that all pods are running. All pods in the `jx` namespace should be
    in a running state:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认所有的pod都在运行。`jx`命名空间中的所有pod都应该处于运行状态：
- en: '[PRE100]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Get the list of Jenkins X service URLs that we will need to connect. You will
    have a list of `jenkins`, `chartmuseum`, `docker-registry`, and `nexus` URLs similar
    to the following:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取我们需要连接的Jenkins X服务URL列表。你将会得到类似以下的`jenkins`、`chartmuseum`、`docker-registry`和`nexus`的URL列表：
- en: '[PRE101]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Now you can connect to the Jenkins UI by visiting the first URL from the preceding
    output of the `jx get urls` command.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过访问`jx get urls`命令的前面输出中的第一个URL连接到Jenkins UI。
- en: Switching Kubernetes clusters
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切换Kubernetes集群
- en: 'Let''s perform the following steps to switch between the Kubernetes clusters
    that you have access to using Jenkins X:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来在Jenkins X中切换你可以访问的Kubernetes集群：
- en: 'Get the existing Kubernetes clusters by listing the contexts:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过列出上下文来获取现有的Kubernetes集群：
- en: '[PRE102]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Select the cluster you would like to use. In our case, we switch to the `gke_devopscookbook` cluster
    that we created using Jenkins X:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想要使用的集群。在我们的情况下，我们切换到使用 Jenkins X 创建的 `gke_devopscookbook` 集群：
- en: '[PRE103]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Now you know how to switch context using the Jenkins X CLI.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何使用 Jenkins X CLI 切换上下文了。
- en: Validating cluster conformance
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证集群符合性
- en: 'If you switch between the existing Kubernetes clusters, it is suggested that
    you validate the cluster configuration before you run your pipelines. Let''s perform
    the following steps:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在现有的 Kubernetes 集群之间切换，建议在运行流水线之前验证集群配置。让我们执行以下步骤：
- en: 'Validate that your cluster is compliant. These tests will typically take an
    hour:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您的集群是否合规。这些测试通常需要一个小时：
- en: '[PRE104]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Check the status. This command will return a `Compliance tests completed` message
    only after tests are completed:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查状态。此命令仅在测试完成后返回“合规性测试已完成”消息：
- en: '[PRE105]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Review the results. If your cluster is compliant all executed test results
    should be displayed as `PASSED`:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看结果。如果您的集群符合规定，所有执行的测试结果应显示为“通过”：
- en: '[PRE106]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Now you know how to check cluster conformance results.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何检查集群符合性结果了。
- en: How it works...
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The *Creating a Jenkins X Kubernetes cluster* recipe showed you how to provision
    the Kubernetes cluster for pipeline automation and automated CI/CD.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 《创建 Jenkins X Kubernetes 集群》的教程向您展示了如何为流水线自动化和自动化 CI/CD 提供 Kubernetes 集群。
- en: In the *Creating a Jenkins X Kubernetes cluster* recipe, in step 1, we created
    the cluster using the Jenkins X CLI. By default, Jenkins X uses `n1-standard-2`
    as the machine type on GKE and creates a cluster with a minimum of three and a
    maximum of five nodes settings. Remember that you could also use an existing Kubernetes
    cluster instead of creating a new one. Most of the settings will be saved and
    remembered next time you run the `create cluster` command.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在《创建 Jenkins X Kubernetes 集群》的教程中，在第 1 步，我们使用 Jenkins X CLI 创建了集群。默认情况下，Jenkins
    X 在 GKE 上使用 `n1-standard-2` 作为机器类型，并创建一个最小为三个、最大为五个节点的集群。请记住，您也可以使用现有的 Kubernetes
    集群，而不是创建新的集群。大多数设置将在下次运行 `create cluster` 命令时保存和记住。
- en: Jenkins X deploys a couple of services, including Jenkins, a private Docker
    registry, a private Helm repository ChartMuseum, Monocular to manage Helm charts,
    and a Maven and npm repository called **Nexus**.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X 部署了一些服务，包括 Jenkins、私有 Docker 注册表、私有 Helm 仓库 ChartMuseum、用于管理 Helm
    图表的 Monocular，以及名为 Nexus 的 Maven 和 npm 仓库。
- en: As you will find in your repository after the installation, Jenkins X creates
    two Git repositories, one for your staging environment and one for production.
    Jenkins X uses the GitOps approach to promote code from one repo to another through
    Git **pull requests** (**PRs**). Therefore each repo contains a Jenkins pipeline
    to handle promotions.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您将在存储库中找到，Jenkins X 创建了两个 Git 存储库，一个用于暂存环境，一个用于生产环境。Jenkins X 使用 GitOps
    方法通过 Git 拉取请求（PR）从一个存储库推广代码到另一个存储库。因此，每个存储库都包含一个 Jenkins 流水线来处理推广。
- en: In the *Creating a Jenkins X Kubernetes cluster* recipe, in step 7, Jenkins
    X uses the magic DNS service and converts the IP address of your GKE cluster into
    a DNS discoverable hostname using a service via `nip.io`. If you have your own
    domain and the DNS is configured to point to your cluster, you can update the
    settings later using the `jx upgrade ingress --cluster` command.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在《创建 Jenkins X Kubernetes 集群》的教程中，在第 7 步，Jenkins X 使用魔术 DNS 服务，并通过 `nip.io`
    服务将您的 GKE 集群的 IP 地址转换为可通过 DNS 发现的主机名。如果您拥有自己的域并且 DNS 配置为指向您的集群，您可以使用 `jx upgrade
    ingress --cluster` 命令稍后更新设置。
- en: Later, in step 10, you will get the default password assigned to your admin
    user. You will be asked to change this password when you first connect to the
    Jenkins UI via the URL provided in this step.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，在第10步，您将获得分配给您的管理员用户的默认密码。当您首次通过本步骤提供的URL连接到Jenkins UI时，将要求您更改此密码。
- en: There's more…
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It is also useful to have knowledge of the following information:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 了解以下信息也很有用：
- en: Importing an application
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入应用程序
- en: Upgrading Jenkins X
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级Jenkins X
- en: Deleting a Jenkins X Kubernetes cluster
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除Jenkins X Kubernetes集群
- en: Importing an application
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入应用程序
- en: 'Let''s perform the following steps to import an existing application into the
    Jenkins X environment:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来将现有应用程序导入Jenkins X环境：
- en: 'Clone or use an existing application. As an example, we will create a clone
    of the `hello-world` example:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆或使用现有应用程序。例如，我们将创建`hello-world`示例的克隆：
- en: '[PRE107]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Remove the Git files from the `cloned` directory. This will remove the Git
    history from the directory:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`cloned`目录中删除Git文件。这将从目录中删除Git历史记录：
- en: '[PRE108]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Run the following command in the folder to import the source code into Jenkins
    X:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件夹中运行以下命令以将源代码导入Jenkins X：
- en: '[PRE109]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Upgrading a Jenkins X application
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 升级Jenkins X应用程序
- en: 'Let''s perform the following steps to upgrade a Jenkins X application and its
    components:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来升级Jenkins X应用程序及其组件：
- en: 'First, upgrade the `jx` CLI. This command will upgrade the application if there
    is a new version available in the remote repository:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，升级`jx` CLI。如果远程存储库中有新版本可用，此命令将升级应用程序：
- en: '[PRE110]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Once you are on the latest CLI, upgrade the platform using the following command.
    The new `jx` CLI command will upgrade the platform components if a new version
    exists:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您使用最新的CLI，使用以下命令升级平台。如果存在新版本，新的`jx` CLI命令将升级平台组件：
- en: '[PRE111]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Deleting a Jenkins X Kubernetes cluster
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除Jenkins X Kubernetes集群
- en: 'Removing managed Kubernetes clusters may be tricky, especially if you are not
    the one who created them. Since we used GKE to create them, it is faster to use
    the gcloud CLI tool to delete them. Let''s perform the following steps to delete
    the Kubernetes cluster we created with Jenkins X:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 删除托管的Kubernetes集群可能会很棘手，特别是如果不是您创建它们的人。由于我们使用GKE创建它们，使用gcloud CLI工具更快地删除它们。让我们执行以下步骤来删除我们使用Jenkins
    X创建的Kubernetes集群：
- en: 'Use your cloud provider''s instructions to delete the Kubernetes cluster. In
    our case, we used GKE for the recipe. First, list the clusters:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的云提供商的说明来删除Kubernetes集群。在我们的情况下，我们使用GKE来进行操作。首先，列出集群：
- en: '[PRE112]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Delete the cluster using the `clustername` from the output of step 1:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用步骤1的输出中的`clustername`删除集群：
- en: '[PRE113]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Now you have learned how to use Jenkins X to create your cluster. This knowledge
    has prepared you for [Chapter 3](811c24c7-debf-4487-91e9-81db1520c0aa.xhtml),
    *Building CI/CD Pipelines*, where you will continue to use the environment and
    learn to import an application as a pipeline in Jenkins X.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何使用Jenkins X来创建您的集群。这些知识已经为您准备好了[第3章](811c24c7-debf-4487-91e9-81db1520c0aa.xhtml)，*构建CI/CD流水线*，在那里您将继续使用这个环境，并学会在Jenkins
    X中将应用程序导入为流水线。
- en: See also
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Introduction to Jenkins: [https://jenkins.io/blog/2018/03/19/introducing-jenkins-x/](https://jenkins.io/blog/2018/03/19/introducing-jenkins-x/)
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins简介：[https://jenkins.io/blog/2018/03/19/introducing-jenkins-x/](https://jenkins.io/blog/2018/03/19/introducing-jenkins-x/)
- en: 'Jenkins X repository and binaries: [https://github.com/jenkins-x/jx](https://github.com/jenkins-x/jx)'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins X存储库和二进制文件：[https://github.com/jenkins-x/jx](https://github.com/jenkins-x/jx)
- en: 'Jenkins X tutorials: [https://jenkins-x.io/tutorials/](https://jenkins-x.io/tutorials/)'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins X教程：[https://jenkins-x.io/tutorials/](https://jenkins-x.io/tutorials/)
- en: 'Jenkins X getting started instructions: [https://jenkins-x.io/getting-started/install-on-cluster/](https://jenkins-x.io/getting-started/install-on-cluster/)'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins X入门说明：[https://jenkins-x.io/getting-started/install-on-cluster/](https://jenkins-x.io/getting-started/install-on-cluster/)
- en: 'Jenkins X CLI commands and an explanation of how to use them: [https://jenkins-x.io/commands/jx/](https://jenkins-x.io/commands/jx/)'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins X CLI命令及其使用说明：[https://jenkins-x.io/commands/jx/](https://jenkins-x.io/commands/jx/)
- en: Deploying and managing the life cycle of GitLab
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和管理GitLab的生命周期
- en: GitLab is a complete DevOps tool chain, delivered in a single application platform.
    GitLab provides all the necessary tooling you need to manage, plan, create, verify,
    package, release, configure, monitor, and secure your applications.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab是一个完整的DevOps工具链，提供在单个应用平台中交付。GitLab提供了您管理、计划、创建、验证、打包、发布、配置、监视和保护应用程序所需的所有工具。
- en: In this section, we will cover the deployment and life cycle management of GitLab
    using Helm charts.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Helm图表来覆盖GitLab的部署和生命周期管理。
- en: Getting ready
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the following recipe, you will learn how to install GitLab on an existing
    Kubernetes cluster where you can manage the entire DevOps life cycle.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个步骤中，您将学习如何在现有的Kubernetes集群上安装GitLab，从而可以管理整个DevOps生命周期。
- en: This recipe requires kubectl and Helm, as well as an existing Kubernetes cluster.
    For this recipe, we will use the cluster we deployed on AWS in [Chapter 1](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml), *Building
    Production-Ready Kubernetes Clusters.* You should be able to run the same recipe
    on any Kubernetes cluster version 1.11 or higher with a minimum of 6vCPU and 16
    GB of RAM.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤需要kubectl和Helm，以及现有的Kubernetes集群。对于此步骤，我们将使用在[第1章](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml)中部署的AWS集群，*构建生产就绪的Kubernetes集群*。您应该能够在任何Kubernetes集群版本1.11或更高版本上运行相同的步骤，最低要求为6vCPU和16GB
    RAM。
- en: How to do it...
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤：
- en: 'This section is further divided into the following subsections to ease the
    process:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 本节进一步分为以下小节，以便简化流程：
- en: Installing GitLab using Helm
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Helm安装GitLab
- en: Connecting to the GitLab dashboard
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到GitLab仪表板
- en: Creating the first GitLab user
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建第一个GitLab用户
- en: Upgrading GitLab
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级GitLab
- en: Deleting GitLab
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除GitLab
- en: Installing GitLab using Helm
  id: totrans-486
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Helm安装GitLab
- en: 'For this recipe, we will use the Kubernetes cluster on Amazon EC2, which we
    deployed in *[Chapter 1,](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml) Building
    Production-Ready Kubernetes Clusters* under the *Configuring a Kubernetes cluster
    on Amazon Web Services *section:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此步骤，我们将使用在*[第1章](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml)中部署的Amazon EC2上的Kubernetes集群，*构建生产就绪的Kubernetes集群*下的*在Amazon
    Web Services上配置Kubernetes集群*部分：
- en: 'Add GitLab Helm chart repos to your local repository:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将GitLab Helm图表存储库添加到本地存储库：
- en: '[PRE114]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Replace the following `externalUrl` with your domain name and deploy GitLab
    using Helm in the `gitlab` namespace:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用您的域名替换以下`externalUrl`，并在`gitlab`命名空间中使用Helm部署GitLab：
- en: '[PRE115]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: For simplicity, I would recommend using your own certificates following the
    *Using auto-generated self-signed certificates* sections. Then you can map your
    DNS name to the created ELB using a `CNAME` record.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我建议您在*使用自动生成的自签名证书*部分使用您自己的证书。然后，您可以使用`CNAME`记录将您的DNS名称映射到创建的ELB。
- en: 'The deployment may take around 10-15 minutes. Confirm the service status and
    note the external IP of the `gitlab-gitlab-ce` service:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署可能需要大约10-15分钟。确认服务状态并注意`gitlab-gitlab-ce`服务的外部IP：
- en: '[PRE116]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Connecting to the GitLab dashboard
  id: totrans-495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到GitLab仪表板
- en: 'Let''s perform the following steps to get the GitLab service address to connect
    using your web browser:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤，以获取GitLab服务地址，以便使用您的Web浏览器连接：
- en: 'Get the external address of your GitLab service:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取GitLab服务的外部地址：
- en: '[PRE117]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Open the address returned to the preceding command in a browser.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开上一个命令返回的地址。
- en: 'Get the default root password created by GitLab by running the following command:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令获取GitLab创建的默认root密码：
- en: '[PRE118]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Set a new password and sign in using the `root` user and your new password.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置新密码并使用`root`用户和新密码登录。
- en: To use a custom URL, create a `CNAME` record on your DNS with an alias to the
    external URL used in step 1.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用自定义URL，请在DNS上创建一个`CNAME`记录，将别名指向第1步中使用的外部URL。
- en: Creating the first GitLab user
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建第一个GitLab用户
- en: By default, we use the root account to manage the GitLab Deployment. All new
    users need to log in to GitLab using their own credentials.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们使用root帐户来管理GitLab部署。所有新用户都需要使用自己的凭据登录GitLab。
- en: 'Let''s perform the following steps to create new users:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来创建新用户：
- en: Log in as the `root` user.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`root`用户身份登录。
- en: 'After you log in to the GitLab dashboard, you will see a welcome screen similar
    to the following. Click Add people on the Welcome to GitLab screen:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到GitLab仪表板后，您将看到类似以下内容的欢迎屏幕。在GitLab欢迎屏幕上点击*添加人员*：
- en: '![](assets/8587bddd-31a1-4045-ab3a-7dae018094fa.png)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8587bddd-31a1-4045-ab3a-7dae018094fa.png)'
- en: Under the New User menu, enter at least the name, username, and email fields,
    and then click on Create User to save the changes.
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*新用户*菜单下，至少输入姓名、用户名和电子邮件字段，然后点击*创建用户*以保存更改。
- en: Upgrading GitLab
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 升级GitLab
- en: 'GitLab frequently releases new versions with additional functionality. Once
    in a while, you may also need to upgrade to get bug fixes. Upgrading can be done
    easily using the Helm upgrade. Let''s perform the following steps to upgrade GitLab
    to a new version:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab经常发布具有额外功能的新版本。偶尔，您可能还需要升级以获得错误修复。升级可以使用Helm upgrade轻松完成。让我们执行以下步骤来升级GitLab到新版本：
- en: 'First, export the currently used arguments into a YAML file using the `helm
    get values` command as follows:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用`helm get values`命令将当前使用的参数导出到YAML文件中，如下所示：
- en: '[PRE119]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Upgrade the chart repositories to get new versions available from the remote
    repository:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 升级图表存储库以获取远程存储库中可用的新版本：
- en: '[PRE120]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'List the available chart versions:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出可用的图表版本：
- en: '[PRE121]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Use the same arguments with the new version to upgrade:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的参数升级新版本：
- en: '[PRE122]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: How it works...
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The *Installing GitLab using Helm* recipe showed you how to provision GitLab
    with all built-in components and external dependencies.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用Helm安装GitLab*配方向您展示了如何使用所有内置组件和外部依赖项来配置GitLab。'
- en: In the *Installing GitLab using Helm* recipe, in step 1, we made sure that official
    up-to-date GitLab Helm chart repos were added into the local repository list.
    Otherwise, older versions of the GitLab charts from the stable/gitlab repo would
    be used.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用Helm安装GitLab*配方中，在第1步中，我们确保将官方最新的GitLab Helm图表存储库添加到本地存储库列表中。否则，将使用来自stable/gitlab存储库的旧版本的GitLab图表。
- en: In the same recipe, in step 2, we deployed GitLab using Helm charts in the `gitlab`
    namespace using the `--namespace gitlab` parameter. This command not only deployed
    GitLab components but also Redis, PostgreSQL, Minio object storage for data persistence,
    Cert Manager, a local container registry, and the nginx ingress controller.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的配方中，在第2步中，我们使用Helm图表在`gitlab`命名空间中使用`--namespace gitlab`参数部署了GitLab。这个命令不仅部署了GitLab组件，还部署了Redis、PostgreSQL、Minio对象存储用于数据持久性、Cert
    Manager、本地容器注册表和nginx ingress控制器。
- en: To use existing Deployments of PostgreSQL, Redis, Gitaly, S3 Storage, and the
    ingress controller, follow the advanced configuration instruction a described
    here: [https://docs.gitla](https://docs.gitlab.com/charts/advanced/)[b.com/charts/advanced/](https://docs.gitlab.com/charts/advanced/).
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用现有的PostgreSQL、Redis、Gitaly、S3存储和ingress控制器的部署，请按照此处描述的高级配置说明：[https://docs.gitla](https://docs.gitlab.com/charts/advanced/)[b.com/charts/advanced/](https://docs.gitlab.com/charts/advanced/)。
- en: By default, GitLab Helm charts deploy the enterprise version of GitLab. By using
    the `--set global.edition=ce` parameter, we switched the Deployment to the free
    Community Edition.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，GitLab Helm图表部署GitLab的企业版。通过使用`--set global.edition=ce`参数，我们将部署切换到了免费的社区版。
- en: After we executed the command in the *Installing GitLab using Helm* recipe,
    in step 2, the Helm chart assumes that we have an existing default storage class
    and it uses the default one to create the PVCs and PVs for the stateful application.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用Helm安装GitLab*教程中执行了命令后，在第2步，Helm图表假定我们有一个现有的默认存储类，并使用默认存储类为有状态应用创建PVCs和PVs。
- en: There's more…
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It is also useful to have knowledge of the following information:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 还有以下信息也很有用：
- en: Using your own wildcard certificate
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您自己的通配符证书
- en: Using autogenerated self-signed certificates
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自动生成的自签名证书
- en: Enabling a GitLab Operator
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用GitLab Operator
- en: Deleting GitLab
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除GitLab
- en: Using your own wildcard certificate
  id: totrans-534
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用您自己的通配符证书
- en: 'Helm chart installation of GitLab supports TLS termination using the nginx
    controller. When you install GitLab, you have options. For improved security,
    you can use Cert Manager and Let''s Encrypt or choose to use your own wildcard
    certificate. In this recipe, we will explain using your own wildcard certificates
    option, as follows:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab的Helm图表安装支持使用nginx控制器进行TLS终止。当您安装GitLab时，您有选择。为了提高安全性，您可以使用Cert Manager和Let's
    Encrypt，或者选择使用您自己的通配符证书。在本教程中，我们将解释如何使用您自己的通配符证书选项，具体如下：
- en: 'Add your certificate and key to the cluster as a secret:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的证书和密钥添加到集群作为一个密钥：
- en: '[PRE123]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Deploy GitLab from the Helm chart using the following additional parameters:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下附加参数从Helm图表部署GitLab：
- en: '[PRE124]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Using autogenerated self-signed certificates
  id: totrans-540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自动生成的自签名证书
- en: 'If you can''t effo using your own wildcard certificate and still want to get
    GitLab quickly up for testing or smaller use cases, you can also use autogenerated
    self-signed certificates. In this recipe, we will explain using self-signed certificates,
    which can be useful in environments where Let''s Encrypt is not an option, but
    SSL security is still needed:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法使用自己的通配符证书，但仍希望快速测试或小规模使用GitLab，您也可以使用自动生成的自签名证书。在本教程中，我们将解释如何使用自签名证书，这在Let's
    Encrypt不可用但仍需要SSL安全的环境中非常有用：
- en: 'In cases where your domain is not reachable from the Let''s Encrypt servers,
    you can provide an autogenerated self-signed wildcard certificate:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的域名无法从Let's Encrypt服务器访问的情况下，您可以提供一个自动生成的自签名通配符证书：
- en: '[PRE125]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Retrieve the certificate, which can be imported into a web browser or system
    store later:'
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索证书，稍后可以导入到Web浏览器或系统存储中：
- en: '[PRE126]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Enabling the GitLab Operator
  id: totrans-546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用GitLab Operator
- en: 'GitLab provides an experimental Operator. This Operator controls the upgrade
    process and helps to perform rolling upgrades without downtime. Let''s perform
    the following steps to get the GitLab Operator running:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab提供了一个实验性的Operator。这个Operator控制升级过程，并帮助执行无停机的滚动升级。让我们执行以下步骤，使GitLab Operator运行起来：
- en: 'First, make sure CRD is in place by enabling the global Operator using the
    Helm parameters as follows:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过使用以下Helm参数来确保CRD已经就位：
- en: '[PRE127]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Deploy the GitLab Operator using the Helm charts:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Helm图表部署GitLab Operator：
- en: '[PRE128]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Deleting GitLab
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除GitLab
- en: 'Let''s perform the following steps to completely remove the GitLab Deployment
    we created in this section:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤，完全删除我们在本节中创建的GitLab部署：
- en: 'Delete the existing release of GitLab using Helm:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Helm删除GitLab的现有发布：
- en: '[PRE129]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'You may also want to remove the namespace to make sure there is nothing left
    behind:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能还想删除命名空间，以确保没有留下任何东西：
- en: '[PRE130]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Now you have learned how to get GitLab up and running on Kubernetes. This knowledge
    will be required in [Chapter 3](811c24c7-debf-4487-91e9-81db1520c0aa.xhtml), *Building
    CI*/*CD Pipelines*, in the *GitLab* section, where you will learn how to import
    an application and create a pipeline in GitLab.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何在Kubernetes上启动和运行GitLab。这些知识将在第3章“构建CI/CD流水线”中的GitLab部分中需要，您将学习如何在GitLab中导入应用程序并创建流水线。
- en: See also
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: GitLab cloud-native Helm chart documentation: [https://docs.gitlab.com/charts/](https://docs.gitlab.com/charts/)
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab原生云Helm图表文档：[https://docs.gitlab.com/charts/](https://docs.gitlab.com/charts/)
- en: 'Advanced configuration options: [https://docs.gitlab.com/charts/advanced/](https://docs.gitlab.com/charts/advanced/)'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级配置选项：[https://docs.gitlab.com/charts/advanced/](https://docs.gitlab.com/charts/advanced/)
- en: 'GitLab Operator: [https://docs.gitlab.com/charts/installation/Operator.html](https://docs.gitlab.com/charts/installation/operator.html)'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab运算符：[https://docs.gitlab.com/charts/installation/Operator.html](https://docs.gitlab.com/charts/installation/operator.html)
- en: Alternative ways to install GitLab Community Edition: [https://about.gitlab.com/install/?version=ce/](https://about.gitlab.com/install/?version=ce/)
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装GitLab社区版的替代方法：[https://about.gitlab.com/install/?version=ce/](https://about.gitlab.com/install/?version=ce/)
