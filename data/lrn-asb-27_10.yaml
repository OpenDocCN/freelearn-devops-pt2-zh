- en: Creating a Custom Module
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义模块
- en: This chapter will focus on how to write and test custom modules. We've already
    discussed how modules work and how to use them within your tasks. To quickly recap,
    a module in Ansible is a piece of code that is transferred and executed onto your
    remote host every time you run an Ansible task (it can also run locally if you've
    used `local_action`).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍如何编写和测试自定义模块。我们已经讨论了模块的工作原理以及如何在任务中使用它们。为了快速回顾，Ansible中的一个模块是每次运行Ansible任务时传输和执行到你的远程主机上的代码片段（如果你使用了`local_action`，它也可以在本地运行）。
- en: From my experience, I've seen custom modules being written whenever a certain
    functionality needs to be exposed as a first-class task. The same functionality
    can be achieved without the module, but it will require a series of tasks with
    existing modules to accomplish the end goal (and sometimes, command and shell
    modules too). For example, let's say that you want to provision a server through **Preboot
    Execution Environment** (**PXE**). Without a custom module, you would probably
    use a few shell or command tasks to accomplish this. However, with a custom module,
    you can just pass the required parameters to it and the business logic will be
    embedded within the custom module in order to perform the PXE boot. This gives
    you the ability to write playbooks that are much simpler to read, and gives your
    code better reusability, since you create the module once and can use it everywhere
    in your roles and playbooks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从我的经验来看，每当需要将某个特定功能暴露为一流任务时，就会编写自定义模块。虽然可以通过现有模块执行相同的功能，但为了实现最终目标，可能需要一系列任务（有时还包括命令和shell模块）。例如，假设你想通过**预启动执行环境**（**PXE**）配置服务器。没有自定义模块，你可能会使用一些shell或命令任务来完成这个任务。然而，通过自定义模块，你只需将所需参数传递给它，业务逻辑将嵌入到自定义模块中，以执行PXE启动。这使你能够编写更简单易读的playbook，并提供了更好的可重用性，因为你只需创建一次模块，就可以在角色和playbook中的任何地方使用它。
- en: The arguments that you pass to a module, provided they are in a **key-value**
    format, will be forwarded in a separate file along with the module. Ansible expects
    at least two variables in your module output (that is, the result of the module
    running), whether it passed or failed, and a message for the user – and they both
    have to be in JSON format. If you adhere to this simple rule, you can customize
    your module as much as you want!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你传递给模块的参数（只要它们以**键值**格式提供）将与模块一起在一个单独的文件中转发。Ansible期望你的模块输出至少有两个变量（即，模块运行的结果），无论它是通过还是失败的，以及用户的消息
    - 它们都必须以JSON格式提供。如果你遵循这个简单的规则，你可以根据自己的需要定制你的模块！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Python modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python模块
- en: Bash modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash模块
- en: Ruby modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby模块
- en: Testing modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试模块
- en: Prerequisite
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先决条件
- en: When you choose a particular technology or tool, you generally start with what
    it offers. You slowly understand the philosophy then went into building the tool
    and what problems it helps you solve. However, you only truly feel comfortable
    and in control when you understand how it works in depth. At some stage, to utilize
    the complete power of a tool, you'll have to customize it in ways that suit your
    particular needs. Over a period of time, tools that provide you with an easy way
    to plug in new functionalities stay, and those that don't, disappear from the
    market. It's a similar story with Ansible as well. All tasks in the Ansible playbook
    are modules of some kind, and it comes loaded with hundreds of modules. You will
    find a module for almost anything that you might need. However, there are always
    exceptions, and this is where the power to extend Ansible's functionality, by
    adding custom modules comes in.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择特定的技术或工具时，通常从它提供的内容开始。你慢慢地了解哲学，然后开始构建工具以及它帮助你解决的问题。然而，只有当你深入了解它的工作原理时，你才真正感到舒适和掌控。在某个阶段，为了充分利用工具的全部功能，你将不得不以适合你特定需求的方式定制它。随着时间的推移，那些提供了方便的方式来插入新功能的工具会留下来，而那些没有的则会从市场上消失。Ansible也是类似的情况。Ansible
    playbook中的所有任务都是某种类型的模块，并且它加载了数百个模块。你几乎可以找到任何你可能需要的模块。然而，总会有例外，这就是通过添加自定义模块来扩展Ansible功能的力量所在。
- en: Chef provides **Lightweight Resources and Providers** (**LWRPs**) to perform
    this activity and Ansible allows you to extend its functionality using custom
    modules. With Ansible, you can write the module in any language of your choice
    (provided that you have an interpreter of that language), whereas, in Chef, the
    module has to be in Ruby. Ansible developers recommend using Python for any complex
    module, as there is out-of-the-box support to parse arguments; almost all ***nix**
    systems have Python installed by default and Ansible itself is written in Python.
    In this chapter, we will also learn how to write modules in other languages.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Chef提供了**轻量级资源和提供者**（**LWRPs**）来执行此操作，而Ansible允许您使用自定义模块扩展其功能。使用Ansible，您可以使用您选择的任何语言编写模块（前提是您有该语言的解释器），而在Chef中，模块必须是Ruby编写的。Ansible开发人员建议对于任何复杂模块都使用Python，因为有内置支持来解析参数；几乎所有的***nix**系统默认都安装了Python，并且Ansible本身也是用Python编写的。在本章中，我们还将学习如何使用其他语言编写模块。
- en: 'To make your custom modules available to Ansible, you can do one of the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要使自定义模块可用于 Ansible，您可以执行以下操作之一：
- en: Specify the path to your custom module in the `ANSIBLE_LIBRARY` environment
    variable.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ANSIBLE_LIBRARY`环境变量中指定自定义模块的路径。
- en: Use the `--module-path` command-line option.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--module-path`命令行选项。
- en: Drop the modules in the `library` directory in your Ansible top-level directory
    and add `library=library` in the `[default]` section of your `ansible.cfg` file.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模块放在您的Ansible顶层目录中的`library`目录中，并在`ansible.cfg`文件的`[default]`部分中添加`library=library`。
- en: You can download all the files from this book's GitHub repository at [https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter07](https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter07).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本书的GitHub存储库中下载所有文件，网址为[https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter07](https://github.com/PacktPublishing/Learning-Ansible-2.X-Third-Edition/tree/master/Chapter07)。
- en: Now that we have this background information, let's take a look at some code!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这些背景信息，让我们来看一些代码吧！
- en: Using Python to write modules
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python编写模块
- en: 'Ansible allows users to write modules in any language. Writing the module in
    Python, however, has its own advantages. You can take advantage of Ansible''s
    libraries to shorten your code – an advantage that is not available for modules
    written in other languages. Parsing user arguments, handling errors, and returning
    the required values becomes easier with the help of the Ansible libraries. Additionally,
    since Ansible is written in Python, you will have the same language for your whole
    Ansible code base, making reviews easier and maintainability higher. We will see
    two examples of a custom Python module, one using the Ansible library and one
    without, in order to give you a glimpse of how custom modules work. Make sure
    that you organize your directory structure as mentioned in the previous section
    before creating the module. The first example creates a module named `check_user`.
    To do this, we will need to create the `check_user.py` file in the `library` folder
    within the Ansible top-level directory. The full code is available on GitHub:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible允许用户使用任何语言编写模块。但是，使用Python编写模块具有自己的优势。您可以利用Ansible的库来缩短您的代码 - 这是其他语言编写的模块所不具备的优势。借助Ansible库的帮助，解析用户参数、处理错误并返回所需值变得更加容易。此外，由于Ansible是用Python编写的，因此您将在整个Ansible代码库中使用相同的语言，使审查更加容易，可维护性更高。我们将看到两个自定义Python模块的示例，一个使用Ansible库，一个不使用，以便让您了解自定义模块的工作原理。在创建模块之前，请确保按照前一节中提到的方式组织您的目录结构。第一个示例创建了一个名为`check_user`的模块。为此，我们需要在Ansible顶层目录中的`library`文件夹中创建`check_user.py`文件。完整的代码可以在GitHub上找到：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding custom module, `check_user`, will check whether a user exists
    on a host. The module expects a user argument from Ansible. Let''s break down
    the preceding module and see what it does. We first declare the Python interpreter and
    import the libraries that are required to parse the arguments:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的自定义模块`check_user`，将检查用户是否存在于主机上。该模块期望来自 Ansible 的用户参数。让我们分解前面的模块，看看它的作用。我们首先声明
    Python 解释器，并导入解析参数所需的库：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the `sys` library, we then parse the arguments, which are passed in a
    file by Ansible. The arguments are in the `param1=value1 param2=value2` format,
    where `param1` and `param2` are the parameters, and `value1` and `value2` are
    the values of the parameters. There are multiple ways in which to split arguments
    and create a dictionary, and we''ve chosen an easy way to perform the operation.
    We first create a list of arguments by splitting the arguments with a whitespace
    character, and then we separate the key and value by splitting the arguments with
    an `=` character and assigning it to a Python dictionary. For example, if you
    have a string such as `user=foo gid=1000`, then you will first create a list, `["user=foo",
    "gid=1000"]`, and then loop over this list to create a dictionary. This dictionary
    will be `{"user": "foo", "gid": 1000}`; this is performed using the following
    lines:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '使用`sys`库，然后解析由Ansible在文件中传递的参数。参数的格式为`param1=value1 param2=value2`，其中`param1`和`param2`是参数，`value1`和`value2`是参数的值。有多种方式可以拆分参数并创建字典，我们选择了一种简单的方式来执行操作。我们首先通过空格字符拆分参数创建参数列表，然后通过`=`字符拆分参数将键和值分开，并将其赋给Python字典。例如，如果您有一个字符串，如`user=foo
    gid=1000`，那么您将首先创建一个列表，`["user=foo", "gid=1000"]`，然后循环遍历该列表以创建字典。此字典将是`{"user":
    "foo", "gid": 1000}`；此操作使用以下行执行：'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We separate the arguments based on a whitespace character, because this is the
    standard, followed by core Ansible modules. You can use any separator instead
    of whitespace, but we encourage you to maintain uniformity.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据空格字符分隔参数，因为这是核心Ansible模块遵循的标准。您可以使用任何分隔符来代替空格，但我们建议您保持统一性。
- en: 'Once we have the user argument, we then check whether this user exists on the
    host, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了用户参数，我们就会检查该用户是否存在于主机上，具体如下：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We use the `pwd` library to check the `passwd` file for the user. For the sake
    of simplicity, we use two variables: one to store the success or failure message
    and the other to store the message for the user. Finally, we use the variables
    created in the `try-catch` block to check whether the module succeeded or failed:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`pwd`库来检查用户的`passwd`文件。为简单起见，我们使用两个变量：一个用于存储成功或失败的消息，另一个用于存储用户的消息。最后，我们使用`try-catch`块中创建的变量来检查模块是否成功或失败：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If the module succeeds, then it will exit the execution with an exit code of
    `0` (`exit(0)`); otherwise, it will exit with a non-zero code. Ansible will look
    for the failed variable and, if it is set to `True`, it will exit unless you have
    explicitly asked Ansible to ignore the error using the `ignore_errors` parameter.
    You can use customized modules like any other core module of Ansible. To test
    the custom module, we will need a playbook, so let''s create the `playbooks/check_user.yaml` file
    using the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块成功，则会以`0`的退出代码（`exit(0)`）退出执行；否则，它将以非零代码退出。Ansible将查找失败的变量，如果它设置为`True`，则退出，除非您已明确要求Ansible使用`ignore_errors`参数忽略错误。您可以像使用Ansible的任何其他核心模块一样使用自定义模块。为了测试自定义模块，我们将需要一个playbook，所以让我们使用以下代码创建`playbooks/check_user.yaml`文件：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, we used the `check_user` module like any other core module.
    Ansible will execute this module onto the remote host by copying the module to
    the remote host with the arguments in a separate file. Let''s see how this playbook
    runs with the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们像使用任何其他核心模块一样使用了`check_user`模块。Ansible将通过将模块复制到远程主机并在单独的文件中使用参数执行该模块。让我们看看这个playbook如何运行，使用以下代码：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We should receive the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该收到以下输出：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As expected, since we have the `root` user, but not `this_user_does_not_exists`,
    it passed the first check, but failed at the second.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，由于我们有`root`用户，但没有`this_user_does_not_exists`，它通过了第一个检查，但在第二个检查失败了。
- en: 'Ansible also provides a Python library to parse user arguments and handle errors
    and returns. It''s time to explore how the Ansible Python library can be used
    to make your code shorter, faster, and less prone to error. To do so, let''s create
    a file called `library/check_user_py2.py` with the following code. The full code
    is available on GitHub:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible还提供了一个Python库来解析用户参数并处理错误和返回值。现在是时候探索Ansible Python库如何使您的代码更短、更快且更不容易出错了。为此，让我们创建一个名为`library/check_user_py2.py`的文件，其中包含以下代码。完整的代码可在GitHub上找到：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s break down the preceding module and see how it works, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解前面的模块，看看它是如何工作的，具体如下：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, we do not import `sys`, `shlex`, and `json`; we are no longer
    using them since all the operations that required them are now done by the Ansible
    `module_utils` module:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们不再导入`sys`，`shlex`和`json`； 我们不再使用它们，因为所有需要它们的操作现在都由Ansible的`module_utils`模块完成：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Previously, we performed a lot of processing on the argument file to get the
    final user arguments. Ansible makes it easy by providing an `AnsibleModule` class,
    which does all the processing on its own and provides us with the final arguments.
    The `required=True` parameter means that the argument is mandatory and the execution
    will fail if the argument is not passed. The default value required is `False`,
    which will allow users to skip the argument. You can then access the value of
    the arguments through the `module.params` dictionary by calling the `get` method
    on `module.params`. The logic to check users on the remote host will remain the
    same, but the error handling and return aspect will change as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们对参数文件进行了大量处理，以获取最终的用户参数。 Ansible通过提供一个`AnsibleModule`类来简化这个过程，该类自行处理所有处理并为我们提供最终参数。
    `required=True`参数意味着该参数是必需的，如果未传递该参数，则执行将失败。 默认值`required`为`False`，这将允许用户跳过该参数。
    然后，您可以通过在`module.params`字典上调用`module.params`上的`get`方法来访问参数的值。 远程主机上检查用户的逻辑将保持不变，但错误处理和返回方面将如下更改：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: One of the advantages of using the `AnsibleModule` object is that you have a
    very nice facility to handle returning values to the playbook. We will go into
    more depth in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`AnsibleModule`对象的一个优点是你有一个非常好的设施来处理返回值到playbook。 我们将在下一节中更深入地讨论。
- en: We could have condensed the logic for checking users and the return aspect,
    but we kept them divided for readability.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以将检查用户和返回方面的逻辑压缩在一起，但我们将它们分开以提高可读性。
- en: 'To verify that everything works as expected, we can create a new playbook in
    `playbooks/check_user_py2.yaml` with the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证一切是否按预期工作，我们可以在`playbooks/check_user_py2.yaml`中创建一个新的playbook，并使用以下代码：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can run it with the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码来运行它：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we should receive the following output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该收到以下输出：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This output is consistent with our expectations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出与我们的预期一致。
- en: Working with exit_json and fail_json
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用exit_json和fail_json
- en: Ansible provides a faster and shorter method for handling success and failure
    through the `exit_json` and `fail_json` methods, respectively. You can directly
    pass a message to these methods and Ansible will take care of the rest. You can
    also pass additional variables to these methods and Ansible will print those variables
    to `stdout`. For example, apart from the message, you might also want to print
    the `uid` and `gid` parameters of the user. You can do this by passing these variables
    to the `exit_json` method, separated by a comma.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible通过`exit_json`和`fail_json`方法提供了更快和更短的处理成功和失败的方法，分别。 您可以直接将消息传递给这些方法，Ansible将处理剩余的部分。
    您还可以将其他变量传递给这些方法，并且Ansible将这些变量打印到`stdout`。 例如，除了消息之外，您可能还想打印用户的`uid`和`gid`参数。
    您可以通过将这些变量分隔符传递给`exit_json`方法来实现这一点。
- en: 'Let''s take a look at how you can return multiple values to `stdout`, as demonstrated
    in the following code, placed in  `library/check_user_id.py`. The full code is
    available on GitHub:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将多个值返回到`stdout`，如下面的代码所示，放置在`library/check_user_id.py`中。 完整的代码在GitHub上可用：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, we return the `uid` and `gid` parameters of the user, along
    with the message, `msg`. You can have multiple values and Ansible will print all
    of them in  dictionary format. Create a playbook in `playbooks/check_user_id.yaml`
    with the following content:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们返回了用户的`uid`和`gid`参数，以及消息`msg`。 你可以有多个值，Ansible将以字典格式打印所有这些值。 创建一个包含以下内容的playbook：`playbooks/check_user_id.yaml`：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can run it with the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码来运行它：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We should receive the following output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该收到以下输出：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we completed the working of both methods, which, in turn, helped us to
    find a quicker way to handle success and failure in Ansible while passing parameters
    to the user.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们完成了两种方法的工作，这反过来又帮助我们找到了在Ansible中处理成功和失败的更快方式，同时向用户传递参数。
- en: Testing Python modules
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Python模块
- en: 'As you have seen, you can test your modules by creating very simple playbooks
    to run them.  To do so, we''ll need to clone the Ansible official repository (if
    you haven''t done so yet):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你可以通过创建非常简单的playbooks来测试你的模块。 为此，我们需要克隆Ansible官方仓库（如果你还没有这样做）：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, source an environmental file, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，像下面这样来源一个环境文件：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can now use the `test-module` utility to run the script by passing the filename
    as a command-line argument:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`test-module`工具通过将文件名作为命令行参数来运行脚本：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The result will be similar to the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将类似于以下输出：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It's also easy to execute the script directly if you have not used `AnsibleModule`.
    This is because this module requires a lot of Ansible-specific variables, so it's
    more complicated to "simulate" an Ansible run than to actually run Ansible itself.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用`AnsibleModule`，直接执行脚本也很容易。这是因为该模块需要很多 Ansible 特定的变量，所以"模拟" Ansible 运行比实际运行
    Ansible 本身更复杂。
- en: Using bash modules
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 bash 模块
- en: Bash modules in Ansible are no different to any other bash scripts, except in
    the way that they print the data on `stdout`. Bash modules can be as straightforward
    as checking whether a process is running on the remote host, to running some more
    complex commands.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 中的 Bash 模块与任何其他 bash 脚本没有任何区别，唯一不同之处在于它们将数据打印在`stdout`上。Bash 模块可以是非常简单的，比如检查远程主机上是否有进程正在运行，也可以是运行一些更复杂的命令。
- en: As previously stated, the general recommendation is to use Python for modules.
    In my opinion, the second-best choice (only for very easy modules) is the `bash`
    module, due to its simplicity and user base.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一般推荐使用 Python 编写模块。在我看来，第二选择（仅适用于非常简单的模块）是`bash` 模块，因为它简单易用，用户基础广泛。
- en: 'Let''s create a `library/kill_java.sh` file with the following content:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`library/kill_java.sh`的文件，并包含以下内容：
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding `bash` module will take the `service_name` argument and forcefully
    kill all of the Java processes that belong to that service. As you know, Ansible
    passes the argument file to the module. We then source the argument file using
    the `$1` source. This will actually set the environment variable with the name, `service_name`.
    We then access this variable using `$service_name`, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的`bash`模块将使用`service_name`参数并强制终止所有属于该服务的 Java 进程。正如你所知，Ansible将参数文件传递给模块。然后我们使用`$1` source
    来来源参数文件。这将实际上设置一个名为`service_name`的环境变量。然后我们使用`$service_name`来访问这个变量，如下所示：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We then check to see if we obtained any `PIDS` for the service and run a loop
    over it to forcefully kill all of the Java processes that match `service_name`.
    Once they''re killed, we exit the module with `failed=False` and a message with
    an exit code of `0`, as you can see in the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查我们是否得到了该服务的 `PIDS`，并遍历这些 `PIDS` 来强制终止所有与 `service_name` 匹配的 Java 进程。一旦它们被终止，我们通过`failed=False`退出模块，并且附上一个退出码为`0`的消息，如下所示：
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we do not find any running processes for the service, we will still exit
    the module with an exit code of `0`, because terminating the Ansible run might
    not make sense:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有找到该服务的正在运行的进程，我们仍将以退出码`0`退出模块，因为终止 Ansible 运行可能没有意义：
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can also terminate the Ansible run by printing `failed=True` with an exit
    code of `1`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过打印`failed=True`并将退出码设置为`1`来终止 Ansible 运行。
- en: 'Ansible allows you to return a key-value output if the language itself doesn''t
    support JSON. This makes Ansible more developer and sysadmin-friendly, and allows
    custom modules to be written in any language of your choice. Let''s test the `bash`
    module by passing the arguments file to the module. We can now create an arguments
    file in `/tmp/arguments` that has the `service_name` parameter set to `jenkins`,
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语言本身不支持 JSON，则 Ansible 允许返回键值输出。这使得 Ansible 更加友好于开发人员和系统管理员，并允许以您选择的任何语言编写自定义模块。让我们通过将参数文件传递给模块来测试`bash`模块。现在我们可以在`/tmp/arguments`中创建一个参数文件，将`service_name`参数设置为`jenkins`，如下所示：
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, you can run the module like any other bash script. Let''s see what happens
    when we run it with the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以像运行任何其他 bash 脚本一样运行模块。让我们看看当我们用以下代码运行时会发生什么：
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We should receive the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该收到以下输出：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As expected, the module did not fail even though there was no Jenkins process
    running on the localhost.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，即使本地主机上没有运行 Jenkins 进程，模块也没有失败。
- en: If you receive the `jps command does not exists` error instead of the mentioned
    output, your machine is probably missing Java. If so, you can install it by following
    the instructions for your operating system at [https://www.java.com/en/download/help/download_options.xml](https://www.java.com/en/download/help/download_options.xml).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到 `jps command does not exists` 错误而不是上述输出，那么你的机器可能缺少 Java。如果是这样，你可以按照操作系统的说明安装它：[https://www.java.com/en/download/help/download_options.xml](https://www.java.com/en/download/help/download_options.xml)。
- en: Using Ruby modules
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ruby 模块
- en: 'Writing modules in Ruby is as easy as writing a module in Python or bash. You
    just need to take care of the arguments, errors, return statements, and, of course,
    know basic Ruby! Let''s create the `library/rsync.rb` file with the following
    code. The full code is available on GitHub:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中编写模块与在 Python 或 bash 中编写模块一样简单。您只需要注意参数、错误、返回语句，当然还需要了解基本的 Ruby！让我们创建`library/rsync.rb`文件，其中包含以下代码。完整代码可在
    GitHub 上找到：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding module, we first process the user arguments, then copy the
    file using the `rsync` library, and finally, return the output.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述模块中，我们首先处理用户参数，然后使用`rsync`库复制文件，最后返回输出。
- en: 'To be able to use this, you need to ensure that the `rsync` library for Ruby
    is present on your system. To do so, you can execute the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个功能，您需要确保系统上存在用于 Ruby 的`rsync`库。为此，您可以执行以下命令：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let's break down the preceding code and see how it works.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分解上述代码，看看它是如何工作的。
- en: 'We first write a method, `print_message`, which will print the output in a
    JSON format. By doing this, we can reuse the same code in multiple places. Remember,
    the output of your module should contain `failed=true` if you want the Ansible
    run to fail; otherwise, Ansible will think that the module succeeded and will
    continue with the next task. The output that is obtained is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写一个名为`print_message`的方法，该方法将以 JSON 格式打印输出。通过这样做，我们可以在多个地方重用相同的代码。请记住，如果要使
    Ansible 运行失败，则您的模块的输出应包含`failed=true`；否则，Ansible 将认为模块成功并将继续进行下一个任务。获得的输出如下所示：
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We then process the argument file, which contains a key-value pair separated
    by a whitespace character. This is similar to what we did with the Python module
    earlier, where we took care of parsing out the arguments. We also perform some
    checks to make sure that the user has not missed any required argument. In this
    case, we check if the `src` and `dest` parameters have been specified, and print
    a message if the arguments are not provided. Further checks could include the
    format and type of arguments. You can add these checks and any other checks that
    you deem important. For example, if one of your parameters is a `date` parameter,
    then you''d need to verify that the input is actually the right date. Consider
    the following piece of code, which shows the discussed parameters:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们处理参数文件，其中包含由空格字符分隔的键值对。这类似于我们之前使用 Python 模块时所做的，我们负责解析参数。我们还执行一些检查，以确保用户没有漏掉任何必需的参数。在这种情况下，我们检查是否已指定了`src`和`dest`参数，并在未提供参数时打印一条消息。进一步的检查可能包括参数的格式和类型。您可以添加这些检查和您认为重要的任何其他检查。例如，如果您的参数之一是`date`参数，则需要验证输入是否确实是正确的日期。考虑以下代码片段，其中显示了讨论过的参数：
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once we have the required arguments, we will go ahead and copy the file using
    the `rsync` library, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们拥有了必需的参数，我们将使用`rsync`库复制文件，如下所示：
- en: '[PRE34]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we check if the `rsync` task passed or failed, and then call the `print_message`
    function to print the output on `stdout`, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查`rsync`任务是通过还是失败，然后调用`print_message`函数将输出打印在`stdout`上，如下所示：
- en: '[PRE35]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can test your Ruby module by simply passing the arguments file to the module.
    To do so, we can create the `/tmp/arguments` file with the following content:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过简单地将参数文件传递给模块来测试您的 Ruby 模块。为此，我们可以创建`/tmp/arguments`文件，并包含以下内容：
- en: '[PRE36]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s now run the module, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行模块，如下所示：
- en: '[PRE37]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will receive the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到以下输出：
- en: '[PRE38]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We will leave the `serverspec` testing for you to complete.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将留下`serverspec`测试由您完成。
- en: Testing modules
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试模块
- en: Testing is often undervalued because of the lack of understanding of its purpose
    and the benefits that it can bring to a business. Testing modules are as important
    as testing any other part of the Ansible playbook, because a small change in a
    module can break your entire playbook. We will take the example of the Python
    module that we wrote in the *Using Python to write modules* section of this chapter
    and write an integration test using Python's `nose` test framework. Unit tests
    are also encouraged, but for our scenario, where we check whether a user exists
    remotely, an integration test makes more sense.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对其目的和其为业务带来的好处的理解不足，测试经常被低估。测试模块与测试 Ansible playbook 的任何其他部分一样重要，因为模块中的微小更改可能会破坏整个
    playbook。我们将以本章的 *使用 Python 编写模块* 部分中编写的 Python 模块为例，并使用 Python 的 `nose` 测试框架编写一个集成测试。虽然也鼓励进行单元测试，但对于我们的场景，即检查远程用户是否存在，集成测试更有意义。
- en: '`nose` is a Python test framework; you can find out more information about
    this test framework at [https://nose.readthedocs.org/en/latest/](https://nose.readthedocs.org/en/latest/).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`nose` 是一个 Python 测试框架；您可以在 [https://nose.readthedocs.org/en/latest/](https://nose.readthedocs.org/en/latest/)
    上找到有关该测试框架的更多信息。'
- en: 'To `test` the module, we convert our previous module into a Python class so
    that we can directly import the class into our test, and run only the main logic
    of the module. The following code shows the `library/check_user_py3.py` restructured
    module, which will check whether a user exists on a remote host. The full code
    is available on GitHub:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对模块进行测试，我们将先前的模块转换为一个 Python 类，以便我们可以直接将该类导入到我们的测试中，并仅运行模块的主要逻辑。以下代码显示了重组的
    `library/check_user_py3.py` 模块，该模块将检查远程主机上是否存在用户。完整代码可在 GitHub 上找到：
- en: '[PRE39]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you can see in the preceding code, we created a class named `User`. We instantiated
    the class and called the `check_if_user_exists` method to check whether the user
    actually exists on the remote machine. It''s time to write an integration test
    now. We assume that you have the `nose` package installed on your system. If not,
    don''t worry! You can still install the package using the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上述代码中所见，我们创建了一个名为 `User` 的类。我们实例化了该类并调用了 `check_if_user_exists` 方法来检查用户是否实际存在于远程计算机上。现在是时候编写集成测试了。我们假设您已经在系统上安装了
    `nose` 包。如果没有，不用担心！您仍然可以使用以下命令安装该包：
- en: '[PRE40]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s now write the integration test file in `library/test_check_user_py3.py`,
    as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在 `library/test_check_user_py3.py` 中编写集成测试文件，如下所示：
- en: '[PRE41]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding integration test, we import the `nose` package and our `check_user` module.
    We call the `User` class by passing the user that we want to check. We then check
    whether the user exists on the remote host by calling the `check_if_user_exists()`
    method. The `nose` methods – `assert_true`, `assert_false`, and `assert_equals` –
    can be used to compare the expected value against the actual value. Only if the
    `assert` methods pass, will the test also pass. You can have multiple tests inside
    the same file by having multiple methods whose names start with `test_`; for example,
    the `test_check_user_positive()` and `test_check_user_negative()` methods. `nose`
    tests will take all the methods that start with `test_` and execute them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述集成测试中，我们导入了 `nose` 包和我们的 `check_user` 模块。我们通过传递我们想要检查的用户来调用 `User` 类。然后，我们通过调用
    `check_if_user_exists()` 方法来检查用户是否存在于远程主机上。`nose` 方法 - `assert_true`、`assert_false`
    和 `assert_equals` - 可以用于比较预期值与实际值。只有当 `assert` 方法通过时，测试也会通过。您可以通过具有以 `test_` 开头的多个方法来在同一个文件中拥有多个测试；例如，`test_check_user_positive()`
    和 `test_check_user_negative()` 方法。`nose` 测试将获取所有以 `test_` 开头的方法并执行它们。
- en: As you can see, we actually created two tests for just one function. This is
    a key part of tests. Always try cases where you know it will work, but also, do
    not forget to test cases where you expect it to fail.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我们实际上为一个函数创建了两个测试。这是测试的一个关键部分。始终尝试您知道会成功的情况，但也不要忘记测试您期望失败的情况。
- en: 'We can now test whether it works by running `nose` with the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过运行以下代码使用 `nose` 来测试它是否正常工作：
- en: '[PRE42]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You should receive an output that is similar to the following code block:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会收到类似以下代码块的输出：
- en: '[PRE43]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, the test passed because the `root` user existed on the host,
    while the `this_user_does_not_exists` user did not.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，测试通过了，因为主机上存在 `root` 用户，而 `this_user_does_not_exists` 用户不存在。
- en: We use the `-v` option with `nose` tests for the **verbose** mode.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `nose` 测试的 `-v` 选项来启用 **详细模式**。
- en: For more complicated modules, we recommend that you write unit tests and integration
    tests. You might be wondering why we didn't use `serverspec` to test the module.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的模块，我们建议您编写单元测试和集成测试。您可能会想知道为什么我们没有使用 `serverspec` 来测试模块。
- en: We still recommend running `serverspec` tests for functional testing as part
    of playbooks; however, for unit and integration tests, it's recommended to use
    well-known frameworks. Similarly, if you write Ruby modules, we recommend that
    you write tests for them with a framework such as `rspec`. If your custom Ansible
    module has multiple parameters with multiple combinations, then you will write
    more tests to test each scenario. Finally, we recommend that you run all these
    tests as part of your CI system, be it Jenkins, Travis, or any other system.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然建议将 `serverspec` 测试作为 playbook 的功能测试的一部分进行运行；然而，对于单元测试和集成测试，建议使用知名框架。同样，如果您编写了
    Ruby 模块，我们建议您使用诸如 `rspec` 等框架为其编写测试。如果您的自定义 Ansible 模块具有多个参数和多个组合，则您将编写更多的测试来测试每个场景。最后，我们建议您将所有这些测试作为您的
    CI 系统的一部分运行，无论是 Jenkins、Travis 还是其他任何系统。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With this, we come to the end of this rather small but important chapter, which
    focused on how you can extend Ansible by writing your own custom modules. You
    learned how to use Python, bash, and Ruby in order to write your modules. We've
    also learned how to write integration tests for modules so that they can be integrated
    into your CI system. In the future, hopefully, extending your Ansible functionality
    by using modules will be much easier!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，我们结束了这一小而重要的章节，重点介绍了如何通过编写自定义模块来扩展 Ansible。您学会了如何使用 Python、bash 和 Ruby 来编写自己的模块。我们还学习了如何为模块编写集成测试，以便将其集成到您的
    CI 系统中。希望未来通过使用模块来扩展 Ansible 的功能将会更加容易！
- en: In the next chapter, we will step into the world of provisioning, deployment,
    and orchestration, and look at how Ansible solves our infrastructure problems
    when we provision new instances or want to deploy software updates to various
    instances in our environments. We promise that this journey will be fun!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进入供应、部署和编排的世界，看看当我们为环境中的各种实例提供新的实例或者想要将软件更新部署到各种实例时，Ansible 如何解决我们的基础设施问题。我们承诺这段旅程将会很有趣！
