- en: Highly Available Cloud Deployments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高可用云部署
- en: Continuing with our AWS deployment, we will start to deploy services into the
    network we created in the previous chapter, and by the end of the chapter, we
    will be left with a highly available WordPress installation, which we will test
    by removing the instances while sending traffic to the site.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的AWS部署，我们将开始将服务部署到上一章创建的网络中，并在本章结束时，我们将得到一个高可用的WordPress安装，我们将通过删除实例并向站点发送流量来进行测试。
- en: 'Building on top of the roles we created in the previous chapter, we will be
    doing the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章创建的角色基础上，我们将进行以下操作：
- en: Launching and configuring Amazon RDS (database)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动和配置Amazon RDS（数据库）
- en: Launching and configuring Amazon EFS (shared storage)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动和配置Amazon EFS（共享存储）
- en: Launching and creating an **Amazon Machine Image** (**AMI**) (deploying the
    WordPress code)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动和创建**Amazon Machine Image**（**AMI**）（部署WordPress代码）
- en: Launching and configuring a launch configuration and autoscaling group (high
    availability)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动和配置启动配置和自动扩展组（高可用性）
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As in the previous chapter, we are going to be using AWS; you will need the
    access key and secret key we created in the previous chapter to launch the resources
    needed for our highly available WordPress installation. Please note that we will
    be launching resources that incur charges. Again, you can find the complete playbook
    in the `Chapter10` folder of the accompanying GitHub repository at [https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter10/aws-wordpress](https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter10/aws-wordpress).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章一样，我们将使用AWS；您将需要在上一章中创建的访问密钥和秘密密钥来启动我们高可用的WordPress安装所需的资源。请注意，我们将启动会产生费用的资源。同样，您可以在附带的GitHub存储库的`Chapter10`文件夹中找到完整的操作手册[https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter10/aws-wordpress](https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter10/aws-wordpress)。
- en: Planning the deployment
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署规划
- en: 'Before we dive into the playbooks, we should get an idea of what it is we are
    trying to achieve. As already mentioned, we are going to be building on our AWS
    VPC role by adding instances and storage. Our updated diagram looks as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入操作手册之前，我们应该了解我们试图实现的目标。正如前面提到的，我们将通过添加实例和存储来扩展我们的AWS VPC角色。我们更新的图表如下：
- en: '![](assets/fb26f773-d780-41c2-aebe-87647cc26984.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fb26f773-d780-41c2-aebe-87647cc26984.png)'
- en: 'In the diagram, we have the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，我们有以下内容：
- en: 3 x EC2 instances (t2.micro), one in each availability zone
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3个EC2实例（t2.micro），每个可用区一个
- en: 2 x RDS instances (t2.micro), in a master/standby multi-AZ configuration
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2个RDS实例（t2.micro），处于主/备份多AZ配置中
- en: 5 GB of EFS storage across three availability zones
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在三个可用区中共享5GB的EFS存储
- en: Before we talk about the deployment itself, based on the diagram and specifications
    here, how much is this deployment going to cost us to run?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论部署本身之前，基于这里的图表和规格，这个部署将给我们带来多少成本？
- en: Costing the deployment
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署成本
- en: 'The cost of running this deployment in the EU-West-1 region is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在EU-West-1地区运行此部署的成本如下：
- en: '| **Instance type** | **# Instances** | **Total cost** **per hour** | **Total
    cost** **per day** | **Total cost** **per month** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **实例类型** | **# 实例** | **每小时总成本** | **每天总成本** | **每月总成本** |'
- en: '| EC2 instances (t2.micro) | 3 | $0.038 | $0.091 | $27.22 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| EC2实例（t2.micro）| 3 | $0.038 | $0.091 | $27.22 |'
- en: '| RDS instance (t2.micro)—Master and Standby | 2 | $0.036 | $0.086 | $25.92
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| RDS实例（t2.micro）-主和备份 | 2 | $0.036 | $0.086 | $25.92 |'
- en: '| Application Load Balancer | 1 | $0.033 | $0.80 | $23.90 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 应用负载均衡器 | 1 | $0.033 | $0.80 | $23.90 |'
- en: '| 5 GB EFS | 1 | $0.002 | £0.06 | $1.65 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 5 GB EFS | 1 | $0.002 | £0.06 | $1.65 |'
- en: '| Total: | $0.109 | $2.62 | $78.69 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 总计：| $0.109 | $2.62 | $78.69 |'
- en: There will be a few other small costs, such as bandwidth and the cost of storing
    the AMI that contains our software stack. We could look at reducing these costs
    significantly by removing some of the redundancy, by disabling the multi-AZ RDS
    instance and also reducing the number of EC2 instances down to just one; however,
    this starts to introduce single points of failure into our deployment, which we
    do not want to do.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还会有一些其他小费用，如带宽和存储包含我们软件堆栈的AMI的成本。我们可以通过去除一些冗余，禁用多AZ RDS实例以及减少EC2实例的数量到只有一个来显著减少这些成本；然而，这开始引入了我们部署中的单点故障，这是我们不想要的。
- en: WordPress considerations and high availability
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WordPress考虑因素和高可用性
- en: So far, we have been launching WordPress on a single server, which is fine,
    but as we are trying to remove as many of the single points of failure within
    our deployment as possible, this means that we have to put a little thought into
    how we initially configure and launch our deployment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在单个服务器上部署WordPress，这很好，但是由于我们试图尽可能多地消除部署中的单点故障，这意味着我们必须对如何初始配置和启动我们的部署进行一些思考。
- en: 'First of all, let''s discuss the order that we will need to launch our deployment
    in. The basic order we will need to launch the elements in is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论一下我们需要按顺序启动部署的顺序。我们需要按照以下基本顺序启动元素：
- en: '**VPC, subnets, internet gateway, routing and security groups**: These are
    all needed to launch our deployment'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VPC、子网、互联网网关、路由和安全组**：这些都是启动我们部署所需的'
- en: '**The Application Elastic Load Balancer**: We will be using the public hostname
    of the Elastic Load Balancer for our installation, so this needs to be launched
    before we start our installation'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用弹性负载均衡器**：我们将使用弹性负载均衡器的公共主机名进行安装，因此需要在开始安装之前启动它'
- en: '**The RDS database instance**: It is important that our database instance is
    available before we launch our installation as we need to create the WordPress
    database and bootstrap the installation'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RDS数据库实例**：重要的是我们的数据库实例在启动安装之前是可用的，因为我们需要创建WordPress数据库并引导安装'
- en: '**The EFS storage**: We need some storage to share between the EC2 instances
    we will be launching next'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EFS存储**：我们需要一些存储空间来在接下来启动的EC2实例之间共享'
- en: So far, so good; however, this is where we have to start taking WordPress into
    account.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很顺利；然而，这就是我们必须开始考虑WordPress的地方。
- en: As some of you may know from experience, the current version of WordPress is
    not really designed to be spread across multiple servers. There are plenty of
    hacks and workarounds we can apply to make WordPress play nicely in this sort
    of deployment; however, this chapter is not about the finer points of deploying
    WordPress. Instead, it is about how you can use Ansible to deploy a multi-tiered
    web application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如一些人可能从经验中知道的那样，当前版本的WordPress实际上并不是为在多个服务器上部署而设计的。有很多技巧和变通方法可以让WordPress在这种部署中表现良好；然而，本章并不是关于部署WordPress的细节。相反，它是关于如何使用Ansible部署多层Web应用程序的。
- en: Because of this, we will be going for the most basic of the multi-instance WordPress
    options by deploying our code and content on the EFS volume. This means that all
    we have to do is install our LEMP stack. It should be noted that this option is
    not the most performant, but it will serve our needs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将选择最基本的多实例WordPress选项，通过在EFS卷上部署我们的代码和内容。这意味着我们只需安装我们的LEMP堆栈。需要注意的是，这个选项并不是最高性能的，但它将满足我们的需求。
- en: 'Now back to the list of tasks. When it comes to launching our instances, we
    need to do the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到任务列表。在启动我们的实例时，我们需要做以下事情：
- en: Launch a temporary EC2 instance running CentOS 7 so that we can reuse parts
    of existing playbooks
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动运行CentOS 7的临时EC2实例，以便我们可以重用现有playbook的部分
- en: Update the operating system and install the software stack, supporting tools,
    and configuration needed for us to install and run our WordPress installation
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新操作系统并安装我们安装和运行WordPress所需的软件堆栈、支持工具和配置
- en: Mount the EFS volume and set the correct permissions, and configure it to mount
    on boot
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载EFS卷并设置正确的权限，并配置它在启动时挂载
- en: Attach the temporary instance to our load balancer, and install and configure
    WordPress
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将临时实例附加到我们的负载均衡器，并安装和配置WordPress
- en: Create an AMI from our temporary instance
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从我们的临时实例创建一个AMI
- en: Create a launch configuration that uses the AMI we just created
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建使用我们刚创建的AMI的启动配置
- en: Create an autoscaling group and attach the launch configuration; it should also
    register our WordPress instances with the Elastic Load Balancer
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个自动扩展组并附加启动配置；它还应该将我们的WordPress实例注册到弹性负载均衡器
- en: During the initial playbook execution, there will be a short period of downtime
    as we create the AMI; further playbook runs should repeat the process with the
    existing instances up and running, and then, once the AMI is built, it should
    be deployed alongside the current instances, which will then be terminated once
    the new instances are registered with the Elastic Load Balancer and receiving
    traffic. This will allow us to update our operating system packages and configuration
    without any downtime—this will also simulate us deploying AMIs that have our code
    base baked in; more on that later in the chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始playbook执行期间，由于我们创建AMI，可能会有短暂的停机时间；进一步的playbook运行应该重复这个过程，现有的实例继续运行，一旦AMI构建完成，它应该与当前实例一起部署，然后一旦新实例注册到弹性负载均衡器并接收流量，当前实例将被终止。这将允许我们更新操作系统软件包和配置而无需任何停机时间——这也将模拟我们部署具有我们代码基础的AMI；稍后在本章中会详细介绍。
- en: Now we have an idea of what we are trying to achieve, let's make a start on
    our playbook.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们要达到什么目标，让我们开始我们的playbook。
- en: The playbook
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: playbook
- en: 'The playbook is going to be split up into several sections. Before we make
    a start on the first one, let''s create the folder structure. As per previous
    chapters, we simply need to run the following commands:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: playbook将分为几个部分。在我们开始第一部分之前，让我们创建文件夹结构。与之前的章节一样，我们只需要运行以下命令：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we have our basic structure in place, we can make a start on creating
    the roles, starting with the network.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的基本结构已经就位，我们可以开始创建角色，首先是网络。
- en: Amazon VPC
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Amazon VPC
- en: All the work for creating the underlying network was completed in the previous
    chapter, meaning that we simply need to copy the `elb`, `gateway`, `securitygroups`,
    `subnets`, and `vpc` folders from your previous playbook across to your current
    `roles` folder.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，创建底层网络的所有工作都已经完成，这意味着我们只需要将`elb`、`gateway`、`securitygroups`、`subnets`和`vpc`文件夹从之前的playbook复制到当前的`roles`文件夹中。
- en: 'Once copied, update the `site.yml` file so it reads:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 复制后，更新`site.yml`文件，使其读取：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Also, add the following to the `group_vars/common.yml` file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 还要将以下内容添加到`group_vars/common.yml`文件中：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we need to update the subnets that are being created; to do this,
    update `the_subnets` variable in `roles/subnets/defaults/main.yml` to read:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新正在创建的子网；为此，请更新`roles/subnets/defaults/main.yml`中的`the_subnets`变量为：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we are adding an additional subnet for our EFS volume, making
    it available in all three availability zones. More on why later. However, it does
    demonstrate the flexibility of our playbook, when all we have to do is add an
    additional line to our variables to create the additional subnet.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们为我们的EFS卷添加了一个额外的子网，使其在所有三个可用区可用。稍后会详细介绍原因。然而，这确实展示了我们playbook的灵活性，当我们只需要向我们的变量添加一行来创建额外的子网时。
- en: That completes the first part of the playbook; we can now move on to some new
    territory and launch our Amazon RDS instance.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了playbook的第一部分；现在我们可以继续前进到一些新的领域并启动我们的Amazon RDS实例。
- en: Amazon RDS
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Amazon RDS
- en: 'Let''s start by creating the file structure for the role by running:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下命令来创建角色的文件结构：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that''s in place, let''s discuss what we need to do to launch the RDS instance.
    To start with, we need to define some default values; add the following to the
    `roles/rds/defaults/main.yml` file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在位置已经确定，让我们讨论一下启动RDS实例需要做些什么。首先，我们需要定义一些默认值；将以下内容添加到`roles/rds/defaults/main.yml`文件中：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Some of the variables are self-explanatory, such as `db_username`, `db_password`,
    and `db_name`, although, as you can see, we are doing something interesting with
    the content of `db_password`. Rather than hardcoding a password, we are using
    a lookup plugin; these allow Ansible to read external data, for example, the contents
    of a file, Redis, MongoDB, or various APIs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一些变量是不言自明的，比如`db_username`、`db_password`和`db_name`，尽管如此，正如你所看到的，我们正在对`db_password`的内容进行一些有趣的处理。我们并没有硬编码密码，而是使用了一个查找插件；这些插件允许Ansible读取外部数据，例如文件的内容、Redis、MongoDB或各种API。
- en: In our case, we are using the Ansible password lookup plugin to populate a file
    on our Ansible controller with a randomly generated password; this file is left
    alone on subsequent lookups, meaning that the password can be reused. Ansible
    will be generating a password that contains letters and numbers and is 30 characters
    long, and it is placing it in a file at `group_vars/rds_passwordfile`. This file
    is then added to the `.gitignore` file, so we don't end up shipping our passwords
    to version control.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们正在使用Ansible密码查找插件来填充Ansible控制器上的一个文件，其中包含一个随机生成的密码；这个文件在后续查找时保持不变，这意味着密码可以被重复使用。Ansible将生成一个包含字母和数字的30个字符长的密码，并将其放在`group_vars/rds_passwordfile`文件中。然后将此文件添加到`.gitignore`文件中，以便我们不会将密码发送到版本控制中。
- en: Other things to note are that we are launching a db.t2.micro (`app_instance_type`)
    MariaDB (`engine`) instance, with 5 GB (`hdd_size`) of storage in a multi-AZ configuration
    (`multi_az`). We will be keeping 7 days of backups (`no_of_backups`), and when
    the instance first launches, we will wait (`wait`) for 20 minutes (`wait_time`)
    for the instance to become available before moving on to the next part of the
    playbook.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的其他事项是，我们正在启动一个db.t2.micro（`app_instance_type`）MariaDB（`engine`）实例，带有5GB（`hdd_size`）的存储空间，采用多AZ配置（`multi_az`）。我们将保留7天的备份（`no_of_backups`），并且在实例首次启动时，我们将等待（`wait`）20分钟（`wait_time`），直到实例在继续playbook的下一部分之前变为可用。
- en: 'There is one thing we need to do before we launch our RDS instance, and that
    is to create an RDS subnet group; this is how we associate our RDS instance with
    the subnets we created when launched the VPC. In `roles/rds/tasks/main.yml`, enter
    the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动RDS实例之前，我们需要做一件事，那就是创建一个RDS子网组；这是我们将RDS实例与我们在启动VPC时创建的子网关联起来的方法。在`roles/rds/tasks/main.yml`中，输入以下内容：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This task uses the list of two subnets we registered in the `subnets` role
    to, in our case, create a group called `wordpress_rds_group`. When it comes to
    associating the subnet group with our RDS instance, we will be using its name
    rather than its unique ID, so there is no need for us to register the output of
    the task for later use. The next, and final, task in the role launches the RDS
    instance. Enter the following `rds_subnet_group` task:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此任务使用我们在`subnets`角色中注册的两个子网的列表，来创建一个名为`wordpress_rds_group`的组。在关联子网组与我们的RDS实例时，我们将使用其名称而不是其唯一ID，因此无需为以后使用注册任务的输出。角色中的下一个，也是最后一个任务是启动RDS实例。输入以下`rds_subnet_group`任务：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Apart from the `command` option, everything else is populated using a variable—this
    means that if there is any part of the instance we want to change when reusing
    the role, we can simply override the default variables by copying them to our
    `group_vars/common.yml` file. There are several options for the `command` option
    you can choose when interacting with the RDS module, which are:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`command`选项外，其他所有内容都是使用变量填充的——这意味着如果我们想要在重用角色时更改实例的任何部分，我们只需将默认变量复制到我们的`group_vars/common.yml`文件中进行覆盖。与RDS模块交互时，可以选择几个`command`选项，包括：
- en: '`create`: This creates an RDS instance. If one already exists, the module will
    gather facts on it'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`：这将创建一个RDS实例。如果已经存在一个实例，模块将收集有关它的信息'
- en: '`replicate`: This creates a read-only replica of the RDS instance you pass
    to it'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replicate`：这将创建一个你传递给它的RDS实例的只读副本'
- en: '`delete`: This deletes the RDS instance; you have the option to take a snapshot
    before the instance is deleted'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`：这将删除RDS实例；在实例被删除之前，您可以选择进行快照'
- en: '`facts`: Gathers information on the RDS instance'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`facts`：收集有关RDS实例的信息'
- en: '`modify`: If you have changed any part of your configuration, then this will
    update your instance, either immediately or during the next scheduled maintenance
    window'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modify`：如果您已更改配置的任何部分，那么这将更新您的实例，要么立即更新，要么在下一个预定的维护窗口期间更新'
- en: '`promote`: This will promote one of your read-replicas to be the new master'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`promote`：这将将您的读取副本之一提升为新的主服务器'
- en: '`snapshot`: This creates a manual snapshot of your RDS instance'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snapshot`：这将创建您的RDS实例的手动快照'
- en: '`reboot`: This reboots the named RDS instance'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reboot`：这将重新启动命名的RDS实例'
- en: '`restore`: This creates a new RDS instance from a named snapshot'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restore`：这将从命名快照创建一个新的RDS实例'
- en: There are a few niggles with the current RDS module you might want to take into
    account. The biggest of which is that it currently only allows you to launch RDS
    instances backed with magnetic storage. It is possible to add a task that uses
    the AWS command-line tools to migrate the storage to general purpose SSD once
    the instance has launched; however, we will not be covering that here.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当前RDS模块存在一些小问题，你可能需要考虑。其中最大的问题是，它目前只允许你启动由磁盘存储支持的RDS实例。可以添加一个任务，使用AWS命令行工具在实例启动后将存储迁移到通用SSD；但是在这里我们不会涉及到这一点。
- en: Also, Ansible does not yet support Amazon Aurora, even though it is listed as
    an option. Again, it is possible to create tasks that use the AWS command-line
    tools to create and configure an Aurora cluster, but if you want native Ansible
    support, you are currently out of luck.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管Amazon Aurora被列为一个选项，但Ansible目前还不支持它。同样，可以创建任务，使用AWS命令行工具来创建和配置Aurora集群，但如果你想要原生的Ansible支持，目前还没有这个运气。
- en: Amazon Aurora is Amazon's own database engine, which allows you to run either
    your MySQL or PostgreSQL databases on top of Amazon's custom-built, SSD-based,
    fault-tolerant, and self-healing database storage clusters. This custom storage
    architecture allows you to scale your database to over 60 TB without disruption
    or the need to reorganize your datasets.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Aurora是亚马逊自己的数据库引擎，允许您在亚马逊定制的基于SSD的容错和自愈数据库存储集群上运行MySQL或PostgreSQL数据库。这种定制的存储架构使您可以将数据库扩展到60TB以上，而无需中断或重新组织数据集。
- en: Work within the Ansible community is ongoing to refactor the RDS module to support
    custom storage options and also introduce native support for Aurora. However,
    this is very much a work in progress, which has not made its way into the current
    Ansible release (2.5 at the time of writing).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible社区正在进行工作，重构RDS模块以支持自定义存储选项，并引入对Aurora的本地支持。然而，这仍然是一个正在进行中的工作，尚未包含在当前的Ansible发布中（写作时为2.5）。
- en: That is all we need for our RDS instance; we can move on to the next role.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的RDS实例所需要的一切；我们可以继续进行下一个角色了。
- en: Amazon EFS
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 亚马逊EFS
- en: 'There are only three tasks needed to create the EFS volumes; as with previous
    roles, we can use the `ansible-galaxy` command to create the folder and file structure:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建EFS卷只需要三个任务；和之前的角色一样，我们可以使用`ansible-galaxy`命令来创建文件夹和文件结构：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Before we add the tasks, we need to add some default variables and a template,
    so add the following to `roles/efs/defaults/main.yml`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加任务之前，我们需要添加一些默认变量和一个模板，所以将以下内容添加到`roles/efs/defaults/main.yml`中：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, create a file in `roles/efs/templates` called `targets.j2`, which should
    contain:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`roles/efs/templates`中创建一个名为`targets.j2`的文件，文件内容应该包含：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, this template is looping over the `subnet_efs_ids` variable
    to create a list of subnet IDs and security groups under the variable name `efs_targets`;
    we will find out why this is needed shortly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个模板正在循环遍历`subnet_efs_ids`变量，以创建一个子网ID和安全组的列表，存储在变量名`efs_targets`下；我们很快就会发现为什么需要这个。
- en: 'The first task in `roles/efs/tasks/main.yml` uses the `template` module to
    read the previous file to create a file and store it in the `group_vars` folder,
    and the second task loads the contents of the file using the `include_vars` module:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`roles/efs/tasks/main.yml`中的第一个任务使用`template`模块读取之前的文件创建一个文件并将其存储在`group_vars`文件夹中，第二个任务使用`include_vars`模块加载文件的内容：'
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have the `efs_targets` variable populated and loaded, we can add
    the third and final task; this task uses the `efs` module to create the volume:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经填充并加载了`efs_targets`变量，我们可以添加第三个和最后一个任务；这个任务使用`efs`模块来创建卷：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '"So, why go to the effort of creating a template, generating a file, and then
    loading the contents in when you could use `with_items`?" you may be asking yourself.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: “那么，为什么要费力创建模板，生成文件，然后加载内容，而不直接使用`with_items`呢？”你可能会问自己。
- en: 'If we were to use `with_items`, then our task would look like the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`with_items`，那么我们的任务将如下所示：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This, at first glance, looks like it should work; however, if we take a look
    at an example of what `group_vars/generated_efs_targets.yml` looks like once it
    is has been generated, you may notice one important difference:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎应该可以工作；然而，如果我们看一下`group_vars/generated_efs_targets.yml`生成后的示例，您可能会注意到一个重要的区别：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see from the example, we have three sections, each with the `subnet_id`
    unique to an availability zone. If we were to use `with_items`, we would only
    have one section and the task would be executed three times, each time overwriting
    the previous targets. Sure, we could have hardcoded three targets, but then what
    if we decided to reuse the role in a region that only has two availability zones,
    or one that has four? Hardcoding would mean we would lose the flexibility to have
    Ansible dynamically adapt to situations where there is a range of dynamic results
    depending on what is being targeted.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例中可以看出，我们有三个部分，每个部分都有一个唯一的`subnet_id`对应一个可用区。如果我们使用`with_items`，我们只会有一个部分，并且任务会执行三次，每次都会覆盖之前的目标。当然，我们可以硬编码三个目标，但是如果我们决定在只有两个可用区的地区或者有四个可用区的地区重用角色会怎么样呢？硬编码意味着我们将失去让Ansible根据目标的动态结果范围动态适应情况的灵活性。
- en: Now we have our EFS role complete and the basics finished. Before we start to
    launch EC2 instances, we can look at testing our playbook.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的EFS角色已经完成，基础知识也已经完成。在我们开始启动EC2实例之前，我们可以测试一下我们的playbook。
- en: Testing the playbook
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试playbook
- en: 'As mentioned, now would be a good time to test the roles we have completed
    to make sure they are working as expected. To do this, open the `site.yml` file
    and add the following content:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，现在是测试我们已经完成的角色是否按预期工作的好时机。为了做到这一点，打开`site.yml`文件并添加以下内容：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Before we run our playbook, we will need to set the `AWS_ACCESS_KEY` and `AWS_SECRET_KEY`
    environment variables; to do this, run the following, replacing the value of each
    variable with the details that we generated in the previous chapter:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行playbook之前，我们需要设置`AWS_ACCESS_KEY`和`AWS_SECRET_KEY`环境变量；为了做到这一点，运行以下命令，用之前章节生成的详细信息替换每个变量的值：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will want to time our playbook run. To do this, we can prefix our `ansible-playbook`
    command with `time`, which means the command we need to run looks like:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将想要计时我们的playbook运行。为了做到这一点，我们可以在`ansible-playbook`命令前加上`time`前缀，这意味着我们需要运行的命令如下：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Don't forget that we have told Ansible to wait for a maximum of 20 minutes before
    launching the RDS instance and creating the EFS volume, so the initial playbook
    run may take a little time.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，我们已经告诉Ansible在启动RDS实例和创建EFS卷之前等待最多20分钟，因此初始playbook运行可能需要一些时间。
- en: 'The reason for this is that when the RDS instance is launched, it is first
    created, then cloned to a standby server, and then, finally, an initial backup
    is made. Only once these steps have been completed is the RDS instance marked
    as ready and our playbook run progresses. Also, for the EFS volumes, we are creating
    a cluster of three volumes across three availability zones, so it takes a little
    while to configure them:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是当RDS实例启动时，首先创建，然后克隆到备用服务器，最后进行初始备份。只有完成这些步骤后，RDS实例才被标记为就绪，我们的playbook运行才能继续。此外，对于EFS卷，我们正在跨三个可用区创建三个卷的集群，因此需要一些时间来配置它们：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see from the output, the playbook run executed as expected. We can
    check the AWS console to make sure everything has been created, starting with
    the VPC:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，playbook运行如预期般执行。我们可以检查AWS控制台，确保一切都已创建，从VPC开始：
- en: '![](assets/a7a633ee-a083-4535-9583-b7cad69f009f.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a7a633ee-a083-4535-9583-b7cad69f009f.png)'
- en: 'Then, check the Elastic Load Balancer, which can be found in the EC2 section:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，检查弹性负载均衡器，它可以在EC2部分找到：
- en: '![](assets/da9b6cfd-03b9-4d38-8dee-1a8f5c9f8813.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/da9b6cfd-03b9-4d38-8dee-1a8f5c9f8813.png)'
- en: 'We can also check that our RDS instance is up and running:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查我们的RDS实例是否正在运行：
- en: '![](assets/f0f85c79-4387-40c8-925e-5e11081485e0.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f0f85c79-4387-40c8-925e-5e11081485e0.png)'
- en: 'Then, the final part of our playbook is the EFS volume:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们playbook的最后部分是EFS卷：
- en: '![](assets/743d2712-73d1-495a-b457-35b7f1e40347.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/743d2712-73d1-495a-b457-35b7f1e40347.png)'
- en: 'When I ran the playbook, it took just over 18 minutes, as you can see from
    the following output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行playbook时，它花了18分钟多一点，如下面的输出所示：
- en: '![](assets/d910bf0a-002d-4f9d-8111-6fbc69cb8d13.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d910bf0a-002d-4f9d-8111-6fbc69cb8d13.png)'
- en: As expected, the majority of that time was Ansible waiting for the RDS instance
    and the EFS volume to be ready.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，大部分时间是Ansible等待RDS实例和EFS卷准备就绪。
- en: Now that we know that the playbook can launch our basic infrastructure without
    error, we can proceed with the rest of playbook. Or can we?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道playbook可以在没有错误的情况下启动我们的基础架构，我们可以继续进行playbook的其余部分。或者我们可以吗？
- en: Terminating resources
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止资源
- en: As already mentioned at the start of this chapter, we are launching resources
    that are going to incur costs when they are up and running. As we are still writing
    our playbook, we don't want the resource to sit idle and rack up costs while we
    work, so let's create a supporting playbook that undoes everything we have just
    ran.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头已经提到的，我们正在启动资源，当它们运行时会产生费用。由于我们仍在编写playbook，我们不希望资源在我们工作时空闲下来并累积成本，因此让我们创建一个支持的playbook，撤消我们刚刚运行的一切。
- en: 'To do this, let''s create a single role called `remove`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，让我们创建一个名为`remove`的单个角色：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This role will use Ansible to, well, remove everything we have just launched,
    thus keeping costs down while we are developing our playbook. First of all, we
    need to add some default variables to `roles/remove/defaults/main.yml`; these
    are:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个角色将使用Ansible来删除我们刚刚启动的一切，从而在我们开发playbook时保持成本低廉。首先，我们需要向`roles/remove/defaults/main.yml`添加一些默认变量；它们是：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `vpc_cidr_block` variable should match your VPC CIDR. Now, we can make
    a start on adding the tasks to `roles/remove/tasks/main.yml`, which removes everything
    we have launched. We will be working our way backwards as each of the resources
    were launched in a certain order, meaning that we need to remove them in reverse
    order. So let''s start with the EFS volume:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`vpc_cidr_block`变量应该与您的VPC CIDR匹配。现在，我们可以开始向`roles/remove/tasks/main.yml`添加任务，这将删除我们启动的所有内容。我们将按照资源启动的特定顺序逆向工作，这意味着我们需要按相反的顺序删除它们。所以让我们从EFS卷开始：'
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We only have to provide a few details this time as the volume is already present;
    we need to give it the name of the volume and also a `state` of `absent`. You
    will notice that we wait for the volume to be removed completely before continuing.
    We are going to have quite a few pauses in this playbook to allow for the resources
    to be fully unregistered with the AWS API before we move on to the next task.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们只需要提供一些细节，因为卷已经存在；我们需要给它卷的名称，以及`state`为`absent`。您会注意到我们在继续之前等待卷完全被移除。在这个playbook中，我们将有相当多的暂停，以便在继续下一个任务之前，资源完全从AWS
    API中注销。
- en: 'The next few tasks deal with the removal of the RDS instance and the RDS subnet
    group:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个任务涉及删除RDS实例和RDS子网组：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we have a pause, using the `pause` module, of 2 minutes between
    the RDS instance being terminated and the removal of the RDS subnet group. If
    we remove this pause, then we run the risk of the RDS instance not being fully
    unregistered, meaning that we would not be able to remove the subnet group, which
    would result in an error in the playbook.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在RDS实例终止和移除RDS子网组之间使用`pause`模块暂停了2分钟。如果我们去掉这个暂停，那么我们就有可能RDS实例没有完全注销，这意味着我们将无法移除子网组，这将导致playbook出现错误。
- en: If, at any stage, the playbook throws an error, we should be able to run it
    a second time and it should pick up where it left off. Although, there is a point
    of no return when we will not be able to run the playbook at all; I will let you
    know when this is.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何阶段playbook抛出错误，我们应该能够再次运行它，并且它应该能够从离开的地方继续。尽管在某个时候，我们将无法完全运行playbook；我会告诉你这是什么时候。
- en: 'Now that the RDS instance and subnet group have been removed, we can remove
    the Elastic Load Balancer:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在RDS实例和子网组已被移除，我们可以移除弹性负载均衡器：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You will notice that, this time, although the `pause` module is being used again,
    we are not providing a period of time. Instead, we are instructing the user to
    check the AWS console, then to press a key once the Elastic Load Balancer has
    been removed. This is because the `elb_application_lb` module doesn't support
    waiting around for the resource to be removed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，这一次虽然再次使用了`pause`模块，但我们没有提供时间段。相反，我们正在指示用户检查AWS控制台，然后在弹性负载均衡器被移除后按下一个键。这是因为`elb_application_lb`模块不支持等待资源被移除。
- en: 'The next task will immediately fail if you just hit *Enter* when the resource
    is in the process of being removed, hence the need for the manual check. The task
    removes the ELB target group:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在资源正在被移除的过程中只是按下*Enter*，那么接下来的任务将立即失败，因此需要手动检查。该任务将移除ELB目标组：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The tasks that follow remove the security groups; as we have groups that reference
    other groups, there is a 30-second `pause` before we remove the next group in
    line:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的任务将移除安全组；由于我们有引用其他组的组，因此在移除下一个组之前会有30秒的`暂停`：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Again, as you can see, we only have to provide the group name and the `state`
    of `absent`. The next task, the removal of the route table, requires a little
    more than just the name:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，正如你所看到的，我们只需要提供组名和`absent`状态。下一个任务，移除路由表，需要的不仅仅是名字：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To remove the route table, we need to know the VPC ID and also the route table's
    ID. To find out this information, we are using the `ec2_vpc_route_table_facts`
    module to gather the data based on the `Name` and `Environment` tags, so we only
    remove what we intend to. This is information that is then passed to the `ec2_vpc_route_table`
    module, which we are instructing to use the ID of the route table to do the `lookup`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除路由表，我们需要知道VPC ID和路由表的ID。为了获取这些信息，我们使用`ec2_vpc_route_table_facts`模块根据`Name`和`Environment`标签来收集数据，这样我们只会移除我们打算移除的内容。这些信息随后传递给`ec2_vpc_route_table`模块，我们指示它使用路由表的ID来进行`lookup`。
- en: We are also telling Ansible to ignore any errors generated here. The reason
    being that if a subsequent task throws an error and we need to rerun the playbook,
    we will need it to progress past this point in the playbook run, and if this task
    has successfully run, it won't be able to as there will be nothing to remove,
    which itself will generate an error.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还告诉Ansible忽略这里生成的任何错误。原因是如果后续任务出现错误并且我们需要重新运行playbook，我们需要它能够在playbook运行中继续进行，如果此任务已成功运行，它将无法继续进行，因为没有要移除的内容，这本身会生成错误。
- en: 'The next two tasks gather information on the VPC and remove the internet gateway:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个任务收集有关VPC的信息并移除互联网网关：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Again, we are ignoring any errors generated so that we can progress with the
    playbook run should it need to be executed more than once. The task gathers information
    on the subnets that are active in the environment using the `ec2_vpc_subnet_facts`
    module; we then register this information as `the_subnets`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们忽略任何生成的错误，以便在需要多次执行时能够继续进行playbook运行。该任务使用`ec2_vpc_subnet_facts`模块收集环境中活动的子网信息；然后我们将这些信息注册为`the_subnets`：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once we have information on the subnets, we can remove them using their CIDR
    block and by setting the `state` to `absent`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取了子网的信息，我们可以使用它们的CIDR块并将`state`设置为`absent`来移除它们：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It is at this point that the playbook would generate an error if you were to
    run it more than once and make it this far. If it does, you can remove the VPC
    manually.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果您运行多次并且成功进行到这一步，playbook将会生成错误。如果出现错误，您可以手动移除VPC。
- en: 'Finally, now that we have removed all of the contents from our VPC and it is
    empty which means we can remove the VPC itself without error:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在我们已经从VPC中移除了所有内容，它是空的，这意味着我们可以无错误地移除VPC本身：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now that we have our role completed, we can create a playbook called `remove.yml`,
    which contains the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们的角色，我们可以创建一个名为`remove.yml`的playbook，其中包含以下内容：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We now have all the pieces in place to remove our AWS environment; to do this,
    run the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好移除AWS环境的所有部分；要做到这一点，请运行以下命令：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Don't forget to check that the Elastic Load Balancer has been removed and press
    any key to continue during the playbook run. Otherwise, you will be waiting around
    for a while.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记检查弹性负载均衡器是否已被移除，并在playbook运行期间按任意键继续。否则，您将需要等待一段时间。
- en: 'When I ran the playbook, it took just under 12 minutes:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行playbook时，它花了将近12分钟：
- en: '![](assets/10471d7f-0fa6-4bc8-808c-eaf619c3c01b.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/10471d7f-0fa6-4bc8-808c-eaf619c3c01b.png)'
- en: 'If you are not following along with the output of the playbook, you can see
    all of the pauses and the information on the subnets collected by the `ec2_vpc_subnet_facts`
    module here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有跟随playbook的输出，您可以在这里看到`ec2_vpc_subnet_facts`模块收集的所有暂停和子网信息：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: I would recommend double-checking that the resources have gone from your AWS
    console, as no one likes a surprise bill. Now that we have completed and executed
    our `remove` playbook, so that we don't incur any unnecessary costs, we can continue
    to build out our highly available WordPress installation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您仔细检查AWS控制台上的资源是否已经移除，因为没有人喜欢意外的账单。现在我们已经完成并执行了我们的`remove` playbook，以便我们不会产生不必要的费用，我们可以继续构建我们的高可用WordPress安装。
- en: EC2 instances
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EC2实例
- en: Now that we have all the basic services required for our WordPress installation
    to consume, we can make a start on deploying the compute resource to install WordPress
    on. This is where things get interesting, as we have to build logic into our playbook
    so that if our site is up and running, we can deploy updates to the operating
    system and roll out new images without any downtime.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了WordPress安装所需的所有基本服务，我们可以开始部署计算资源来安装WordPress。这是一个有趣的地方，因为我们需要在playbook中构建逻辑，以便如果我们的站点正在运行，我们可以在没有任何停机时间的情况下部署操作系统更新并推出新的镜像。
- en: But if it is a new deployment, we need to launch an instance, attach it to the
    Elastic Load Balancer, install the software stack, configure WordPress, and create
    an image we can then use in a launch configuration, which we will need to attach
    to an autoscaling group.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果这是一个新的部署，我们需要启动一个实例，将其附加到弹性负载均衡器，安装软件堆栈，配置WordPress，并创建一个我们随后可以在启动配置中使用的镜像，我们需要将其附加到自动扩展组。
- en: While this may seem complicated, building this logic into the playbook will
    make it a lot easier to maintain and hand over to someone else to manage/run,
    as they will not need to worry about the existing deployment, they will just need
    to run the playbook.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能看起来很复杂，但将这种逻辑构建到playbook中将使其更容易维护和移交给其他人来管理/运行，因为他们不需要担心现有的部署，他们只需要运行playbook。
- en: Instance discovery
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例发现
- en: 'We are going to simply call this role EC2, so we need to run the following
    command to create the role structure:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简单地称这个角色为EC2，所以我们需要运行以下命令来创建角色结构：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The primary goal of this role is to ensure that by the end of its execution,
    we have an instance, either a new or an existing one, that we can then use in
    the forthcoming roles to base an AMI on.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个角色的主要目标是确保在执行结束时，我们有一个实例，无论是新的还是现有的，然后我们可以在随后的角色中使用它来基于AMI。
- en: 'The defaults in `roles/ec2/defaults/main.yml` define which image we want to
    use if our role discovers that this is a new deployment. For our installation,
    we are going to be using the AMI provided by CentOS in the AWS Marketplace; this
    means we can reuse large chunks of our WordPress installation playbook:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`roles/ec2/defaults/main.yml`中的默认值定义了如果我们的角色发现这是一个新的部署，我们想要使用哪个镜像。对于我们的安装，我们将使用AWS
    Marketplace中由CentOS提供的AMI；这意味着我们可以重用我们的WordPress安装playbook的大部分内容：'
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We will go into a little more detail about why we need this information when
    we come to use images. Now we have the defaults in place, we can move on to the
    tasks in `roles/ec2/tasks/main.yml`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用镜像时，我们将更详细地解释为什么我们需要这些信息。现在我们已经有了默认值，我们可以继续进行`roles/ec2/tasks/main.yml`中的任务。
- en: 'When we launch our instances using the autoscaling group, they will all be
    named `wordpress_ec2`, so the first thing our EC2 role has to do is figure out
    whether we have any running instances. To do this, we will use the `ec2_instance_facts`
    module to gather information on any instances that are running and are tagged
    with the name `wordpress_ec2`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用自动扩展组启动我们的实例时，它们都将被命名为`wordpress_ec2`，所以我们的EC2角色首先要做的事情就是弄清楚我们是否有任何正在运行的实例。为此，我们将使用`ec2_instance_facts`模块来收集任何正在运行并带有名称`wordpress_ec2`的标记的实例的信息：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Although we now have information on any instances that are already running,
    it is not really in a format we can use, so let''s add the results to a host group
    called `already_running`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在已经获得了任何已经运行的实例的信息，但它实际上并不是我们可以使用的格式，所以让我们将结果添加到一个名为`already_running`的主机组中：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we are left with a host group called `already_running`, which may contain
    from zero to three hosts; we now need to count the number of hosts in the group
    and set a fact that contains the number of hosts:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们留下了一个名为`already_running`的主机组，它可能包含从零到三个主机；我们现在需要计算组中主机的数量，并设置一个包含主机数量的事实：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we are using the inbuilt Ansible variable `groups` along with our group
    name; now we have a list of hosts, we can count the number of items in the list
    by using the `length` filter. Finally, we are saying that if the list is empty,
    then the default value should be `0`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用内置的Ansible变量`groups`以及我们的组名；现在我们有了一个主机列表，我们可以通过使用`length`过滤器来计算列表中的项目数。最后，我们说如果列表为空，则默认值应为`0`。
- en: Now we have a variable that contains `number_of_running_hosts`, we can now make
    some decisions on what we need to do next.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含`number_of_running_hosts`的变量，我们现在可以根据需要做出一些决定。
- en: 'First, if `number_of_running_hosts` is `0`, then we are working on a new deployment,
    and we should run the tasks that launch a fresh EC2 instance:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果`number_of_running_hosts`是`0`，那么我们正在进行新的部署，我们应该运行启动新的EC2实例的任务：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Or, if `number_of_running_hosts` is more than `1`, then we need to choose an
    already running instance to work with:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果`number_of_running_hosts`大于`1`，那么我们需要选择一个已经运行的实例来使用：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let's take a look at these tasks, starting with what happens during a new deployment.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些任务，从新部署时发生的情况开始。
- en: New deployment
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的部署
- en: 'If we are working on a new deployment, then we need to perform the following
    tasks:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在进行新的部署，那么我们需要执行以下任务：
- en: Find the latest CentOS 7 AMI in the region we are using
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到我们正在使用的区域中最新的CentOS 7 AMI
- en: Upload a copy of our public key so that we can use it to SSH into the instance
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传我们的公钥的副本，以便我们可以用它来SSH进入实例
- en: Launch an instance using the previous information
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用先前的信息启动一个实例
- en: Add the new instance to a host group
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新实例添加到主机组
- en: Wait until SSH is available
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待SSH可用
- en: Add our instance to the Elastic Load Balancer
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的实例添加到弹性负载均衡器
- en: All of these tasks are defined in `roles/ec2/tasks/new_deployment.yml`, so let's
    start working on these tasks by looking at how we can find the correct AMI to
    use.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些任务都在`roles/ec2/tasks/new_deployment.yml`中定义，所以让我们开始通过查找如何找到正确的AMI来进行这些任务。
- en: 'We can''t simply supply an AMI ID here as each region has a different ID, and
    also each AMI is regularly updated to make sure it is patched. To get around this,
    we can run the following tasks:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地在这里提供AMI ID，因为每个区域都有不同的ID，而且每个AMI都定期更新以确保它被修补。为了解决这个问题，我们可以运行以下任务：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, we are first looking for all `x86_64` AMIs created by CentOS
    that have `CentOS Linux 7 x86_64*` in the name and also use **Elastic Block Store**
    (**EBS**)-backed storage. This will give us details about several AMIs, which
    we have registered as `amiFind`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们首先寻找所有由CentOS创建的`x86_64` AMI，名称中带有`CentOS Linux 7 x86_64*`，并且使用**弹性块存储**（**EBS**）支持的存储。这将给我们提供有关几个AMI的详细信息，我们已经注册为`amiFind`。
- en: Next, we need to filter the list of AMIs down to just the latest one, so we
    set a fact called `amiSortFilter`. Here, it is taking the list of images, `amiFind`,
    and sorting them by the date they were created. We then take just the information
    for the last AMI in the list to register as `amiSortFilter`. Finally, we reduce
    the information down more by setting a fact called `our_ami_id`, which is the
    `image_id` in the `amiSortFilter` variable, leaving us with just the information
    we need.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将AMI列表过滤为最新的一个，因此我们设置了一个名为`amiSortFilter`的事实。在这里，它正在获取镜像列表`amiFind`，并按创建日期对其进行排序。然后，我们只获取列表中最后一个AMI的信息，注册为`amiSortFilter`。最后，我们通过设置一个名为`our_ami_id`的事实，将信息进一步减少，它是`amiSortFilter`变量中的`image_id`，这样我们只保留了需要的信息。
- en: 'Now we know the AMI ID, we need to ensure that there is an SSH key we can use
    so that we can access the instance when launched. First of all, let''s check that
    your user on the Ansible controller has an SSH key; if we can''t find one, then
    one will be created:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了AMI ID，我们需要确保有一个SSH密钥可以使用，以便在启动后访问实例。首先，让我们检查一下你在Ansible控制器上的用户是否有SSH密钥；如果我们找不到一个，那么将会创建一个：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now that we have confirmed the presence of a key, we need to upload the public
    portion to AWS:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确认了密钥的存在，我们需要将公共部分上传到AWS：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We now have everything in place to launch an EC2 instance; to do this, we will
    be using the `ec2_instance` module, which was introduced in Ansible 2.5:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好启动EC2实例了；为了做到这一点，我们将使用在Ansible 2.5中引入的`ec2_instance`模块：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: With this, we are launching our EC2 instance into one of the EC2 subnets, attaching
    a public IP address and also our EC2 security group. The instance will be a t2.micro
    CentOS 7 instance called `wordpress-tmp`. We are assigning tags to it, and we
    are also using filters so that if anything happens during the playbook run and
    we need to rerun it, it will use our instance that is already running rather than
    launching another.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就可以将我们的EC2实例启动到一个EC2子网中，附加一个公共IP地址和我们的EC2安全组。该实例将是一个名为`wordpress-tmp`的t2.micro
    CentOS 7实例。我们为其分配标签，并且我们还使用过滤器，以便如果在playbook运行期间发生任何问题，我们需要重新运行它，它将使用我们已经运行的实例，而不是启动另一个实例。
- en: 'Once the instance has launched, we need to find out its information and add
    it to a host group called `ec2_instance`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 实例启动后，我们需要找出它的信息，并将其添加到名为`ec2_instance`的主机组中：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We need to wait for SSH to be accessible before moving on; here, we will use
    the `wait_for` module:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要等待SSH可访问后再继续；在这里，我们将使用`wait_for`模块：
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, once SSH is available, we need to register the instance with our Elastic
    Load Balancer target group:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦SSH可用，我们需要将实例注册到我们的弹性负载均衡器目标组中：
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will leave us with a single instance called `wordpress-tmp`, which is accessible
    over SSH and active behind our Elastic Load Balancer in a host group named `ec2_instance`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们得到一个名为`wordpress-tmp`的单个实例，它可以通过SSH访问，并且在我们的弹性负载均衡器后面处于活动状态，位于名为`ec2_instance`的主机组中。
- en: Existing deployment
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现有部署
- en: 'If we already have instances running, the previous tasks are skipped and the
    single task in `roles/ec2/existing_deployment.yml` is run. This task simply takes
    one of the running hosts and adds it to the host group named `ec2_instance`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经有运行中的实例，先前的任务将被跳过，只运行`roles/ec2/existing_deployment.yml`中的单个任务。这个任务只是将一个运行中的主机添加到名为`ec2_instance`的主机组中：
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This leaves us in the same position as we were in at the end of the new deployment
    tasks, with a host called `ec2_instance` with a single instance that is accessible
    over SSH.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们处于与新部署任务结束时相同的位置，有一个名为`ec2_instance`的主机，有一个可以通过SSH访问的实例。
- en: Stack
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈
- en: 'The next role that we are going to create is the one that is only executed
    on the host— the `ec2_instance` group called `stack`. As with the previous roles,
    we can run the following command from within our `aws-wordpress` folder to create
    the files needed:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要创建的角色是只在主机上执行的——名为`stack`的`ec2_instance`组。与之前的角色一样，我们可以从`aws-wordpress`文件夹中运行以下命令来创建所需的文件：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This role is three roles in one. As with the EC2 role, we are building in logic
    to execute tasks based on the state of the instance our playbook finds when it
    first connects. Let's look at the contents of `roles/stack/tasks/main.yml` first.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个角色实际上包含了三个角色。与EC2角色一样，我们正在构建逻辑，根据playbook首次连接时发现的实例状态来执行任务。让我们先看一下`roles/stack/tasks/main.yml`的内容。
- en: 'The first task in there is executed on both new and existing deployments; it
    runs a `yum update`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 其中的第一个任务在新部署和现有部署上都执行；它运行`yum update`：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, we need to know whether WordPress is installed:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要知道WordPress是否已安装：
- en: '[PRE55]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The next two tasks include two additional roles; one installs and configures
    the software stack and the other performs the initial WordPress installation,
    but only if no existing installation is found:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个任务包括两个额外的角色；一个安装和配置软件堆栈，另一个执行初始的WordPress安装，但只有在没有找到现有安装时才会执行：
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: These two roles are condensed versions of the roles we created when we installed
    WordPress locally.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个角色是我们在本地安装WordPress时创建的角色的简化版本。
- en: Default variables
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认变量
- en: 'Before we look at the roles, let''s take a look at the code of `roles/stack/defaults/main.yml`
    as there are a few differences:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看角色之前，让我们先看一下`roles/stack/defaults/main.yml`的代码，因为有一些不同之处：
- en: '[PRE57]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The main differences are:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的区别是：
- en: 'The `wordpress.domain` URL: This time, rather than hardcoding the domain, we
    have the Elastic Load Balancer URL, which we get from using the `elb_application_lb_facts`
    module. More on that later.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wordpress.domain` URL：这次，我们不是硬编码域名，而是使用`elb_application_lb_facts`模块获取的弹性负载均衡器URL。稍后再详细介绍。'
- en: 'The `efs_mount_dir` variable: This is a new variable, which we will use to
    define where in the instance we want our EFS share mounted.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`efs_mount_dir`变量：这是一个新变量，我们将用它来定义我们想要将EFS共享挂载到实例的位置。'
- en: 'The `wordpress_system.home` option: This now uses `efs_mount_dir` so our WordPress
    installation can be shared across all instances.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wordpress_system.home`选项：现在使用`efs_mount_dir`，这样我们的WordPress安装可以在所有实例之间共享。'
- en: 'Lack of a MariaDB server: You will notice that references to installing and
    configuring a MariaDB server have been removed; as we have an RDS instance, we
    no longer need these.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少MariaDB服务器：你会注意到安装和配置MariaDB服务器的引用已经被移除；因为我们有了RDS实例，我们不再需要这些了。
- en: We are using the `include_role` module to execute the tasks as a role to ensure
    that the variables are loaded correctly.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`include_role`模块将任务作为一个角色执行，以确保变量被正确加载。
- en: Deploy
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: The first additional role, called `roles/stack/tasks/deploy.yml`, does as you
    would expect and deploys the software stack and configuration.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个额外的角色，名为`roles/stack/tasks/deploy.yml`，如你所期望的那样，部署软件堆栈和配置。
- en: 'It starts by mounting the EFS share; first, we need to gather some information
    about the EFS share using the `efs_facts` module:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先挂载EFS共享；首先，我们需要使用`efs_facts`模块收集一些关于EFS共享的信息：
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You may have already noticed that we are calling the `efs_facts` module differently;
    we are actually using the `local_action` module, which runs the `efs_facts` module
    on our Ansible controller rather than the EC2 instance. This is because we are
    not actually giving our EC2 instance access to the API, as we are not installing
    Boto or passing our access key and secret access key as a variable.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们以不同的方式调用了`efs_facts`模块；我们实际上使用了`local_action`模块，在我们的Ansible控制器上运行`efs_facts`模块，而不是在EC2实例上运行。这是因为我们实际上没有给我们的EC2实例访问API的权限，因为我们没有安装Boto或将我们的访问密钥和秘密访问密钥作为变量传递。
- en: Using the `local_action` module allows us to flip back to our Ansible controller
    to gather information on our EFS and then apply the results on our EC2 instance;
    we will be using this module again later in the installation.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`local_action`模块允许我们切换回我们的Ansible控制器来收集关于我们的EFS的信息，然后将结果应用到我们的EC2实例上；我们将在安装中稍后再次使用这个模块。
- en: 'We are using `become: no` as part of this task; otherwise, it will try to execute
    using `sudo`. This is because we are telling all tasks to use `become: yes` with
    `become_method: sudo` in this part of the `site.yml` file, which we will update
    later in this chapter.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '作为这个任务的一部分，我们使用`become: no`；否则，它将尝试使用`sudo`来执行。这是因为我们告诉所有任务在`site.yml`文件的这部分使用`become:
    yes`和`become_method: sudo`，我们将在本章后面更新。'
- en: 'The next task mounts the EFS share and also adds it to the `fstab` file, which
    means that it will automatically mount when the instance we will be launching
    from the AMI we are creating first boots:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务挂载EFS共享，并将其添加到`fstab`文件中，这意味着当我们从正在创建的AMI中启动的实例启动时，它将自动挂载：
- en: '[PRE59]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`efs_mount_dir` is automatically created so we don''t need to worry about creating
    it beforehand. The next part of the role installs and configures the stack:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`efs_mount_dir`会自动创建，所以我们不需要担心提前创建它。角色的下一部分安装和配置堆栈：'
- en: '[PRE60]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For this to work, you will need to copy the files from `files`, `handlers`,
    and `templates` from the `stack-config` role of the LEMP playbook we created in
    [Chapter 5](159d7be3-6d13-4a66-8766-e4cf3b982b0f.xhtml), *Deploying WordPress*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个工作，你需要从我们在[第5章](159d7be3-6d13-4a66-8766-e4cf3b982b0f.xhtml)中创建的LEMP playbook的`stack-config`角色中复制`files`、`handlers`和`templates`中的文件。
- en: WordPress
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WordPress
- en: As you may have already guessed, this role, which can be found in the `roles/stack/tasks/wordpress.yml`
    file alongside `roles/stack/tasks/main.yml` and `roles/stack/tasks/deploy.yml`,
    installs and configures WordPress.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的那样，这个角色可以在`roles/stack/tasks/wordpress.yml`文件中找到，与`roles/stack/tasks/main.yml`和`roles/stack/tasks/deploy.yml`一起，安装和配置WordPress。
- en: 'Before we progress with the tasks, we need to find out information about our
    RDS instance:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续执行任务之前，我们需要找出关于我们的RDS实例的信息：
- en: '[PRE61]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This is so that we can use the tasks when defining the database connection;
    likewise, we also need to find out about the Elastic Load Balancer:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以在定义数据库连接时使用这些任务；同样，我们还需要了解弹性负载均衡器的情况：
- en: '[PRE62]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The remaining tasks do the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的任务做以下事情：
- en: Install WP-CLI.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装WP-CLI。
- en: Download WordPress.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载WordPress。
- en: Set the correct permissions on the WordPress folder.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置WordPress文件夹的正确权限。
- en: Configure WordPress to connect to our RDS using the endpoint we found when gathering
    facts; we are reusing the password file we generated.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置WordPress以连接到我们通过收集信息找到的RDS的端点；我们正在重用我们生成的密码文件。
- en: 'Install WordPress using the Elastic Load Balancer URL and details from the
    default variables:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用弹性负载均衡器的URL和默认变量的详细信息安装WordPress：
- en: '[PRE63]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To keep things simple, we are not managing the theme or plugins using Ansible.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们不使用Ansible来管理主题或插件。
- en: This is where we stop running tasks on the instance we discovered/launched in
    the previous role; it is now time for us to switch back to our Ansible controller
    and make an AMI using our instance.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们停止在上一个角色中发现/启动的实例上运行任务的地方；现在是时候切换回我们的Ansible控制器并使用我们的实例创建一个AMI了。
- en: AMI
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AMI
- en: 'This role does not need to make any choices, it simply takes our host from
    the `ec2_instances` group and creates an image of it. To start, let''s create
    the role:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这个角色不需要做出任何选择，它只是从`ec2_instances`组中获取我们的主机并创建其镜像。首先，让我们创建这个角色：
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The role is made up of three tasks, one of which is a pause. First of all,
    in `roles/ami/tasks/main.yml`, we need to find out some information about the
    instance. We are using the `ec2_instance_facts` module:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个角色由三个任务组成，其中一个是暂停。首先，在`roles/ami/tasks/main.yml`中，我们需要找出一些关于实例的信息。我们使用`ec2_instance_facts`模块：
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now we know about the instance, we can create the AMI:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了实例，我们可以创建AMI了：
- en: '[PRE66]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As you can see, we are using the `instance_id` we discovered when running the
    `ec2_instance_facts` module; we are also using the `ansible_date_time` variable,
    which was defined when the `gather_facts` module was called to give our AMI a
    unique name.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在运行`ec2_instance_facts`模块时使用了我们发现的`instance_id`；我们还使用了`ansible_date_time`变量，这个变量在调用`gather_facts`模块时被定义，用来给我们的AMI取一个唯一的名字。
- en: 'As already mentioned, the final task is a pause:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，最后一个任务是一个暂停：
- en: '[PRE67]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This is required as it can take a short while for our newly created AMI to fully
    register and be available in the AWS API.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这是必需的，因为我们新创建的AMI可能需要一段时间才能完全注册并在AWS API中可用。
- en: Autoscaling
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动扩展
- en: 'The final role in our playbook creates a launch configuration and then creates/updates
    an autoscaling group to finally launch our instances. It then does a tiny bit
    of housekeeping. To create the role, run:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们playbook中的最后一个角色创建了一个启动配置，然后创建/更新了一个自动扩展组，最终启动我们的实例。然后进行了一点点的清理工作。要创建这个角色，请运行：
- en: '[PRE68]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'First of all, there are a few default variables we need to set in `roles/autoscaling/default/main.yml`;
    these details show how many instances we want running at any one time, and also
    how many instances we replace at a time when doing a deployment of a new AMI:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在`roles/autoscaling/default/main.yml`中设置一些默认变量；这些细节显示了我们希望同时运行多少个实例，以及在部署新AMI时替换多少个实例：
- en: '[PRE69]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: What those variables are saying is that we want three instances running at all
    times, so if there are two, then launch more and never launch more than nine at
    any one time. When deploying a new image, replace instances two at a time.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量的含义是，我们希望始终运行三个实例，所以如果有两个，就启动更多，但一次不要启动超过九个。在部署新镜像时，每次替换两个实例。
- en: We are also defining the health check, where, using the Elastic Load Balancer
    check, we are telling the instances to launch using a public IP address, meaning
    that we can access them over SSH, and finally, we are defining the type of instance
    to use.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在定义健康检查，使用弹性负载均衡器检查，告诉实例使用公共IP地址启动，这意味着我们可以通过SSH访问它们，最后，我们定义要使用的实例类型。
- en: 'The first task we need to define in `roles/autoscaling/tasks/main.yml` needs
    to find the right AMI to use:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`roles/autoscaling/tasks/main.yml`中需要定义的第一个任务是找到要使用的正确AMI：
- en: '[PRE70]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Again, we need to know the details of the last AMI we built:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们需要知道我们构建的最后一个AMI的细节：
- en: '[PRE71]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Finally, we need to get the AMI ID and also the AMI name; we will be using
    this to name the launch configuration:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要获取AMI ID和AMI名称；我们将使用这个名称来命名启动配置：
- en: '[PRE72]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next up, we have the task, which uses the previous information to create the
    launch configuration:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个任务，使用先前的信息来创建启动配置：
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Once we have the launch configuration created, we can create/update the autoscaling
    group to reference it. Before we do, we need to find out the **Amazon Resource
    Name** (**ARN**) of the target group:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了启动配置后，我们可以创建/更新自动扩展组来引用它。在这之前，我们需要找到目标组的Amazon资源名称（ARN）：
- en: '[PRE74]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Once we have that information, we can move on to the next task:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们可以继续下一个任务：
- en: '[PRE75]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: An autoscaling group ensures that we have our desired number of EC2 instances
    running at all times. If there are none running, it launches them and registers
    them with the target group for the Elastic Load Balancer.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩展组确保我们始终运行所需数量的EC2实例。如果没有运行实例，它会启动它们并将它们注册到弹性负载均衡器的目标组中。
- en: If there are instances already running and we have updated the launch configuration,
    then it will do a rolling deploy of our new configuration, making sure that we
    never have any downtime as new instances are launched and registered before old
    ones are removed.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经有实例在运行，并且我们已经更新了启动配置，那么它将对我们的新配置进行滚动部署，确保在旧实例被移除之前，新实例被启动和注册，从而确保我们没有任何停机时间。
- en: 'The final task removes any `tmp` instances we may have running:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个任务是删除我们可能正在运行的任何`tmp`实例：
- en: '[PRE76]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This should leave us with our desired state running and nothing more.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们应该得到我们期望的状态并且没有其他东西在运行。
- en: Running the playbook
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行playbook
- en: 'The first thing we need to do is update our `production` inventory file; this
    should look like the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是更新我们的`production`清单文件；应该看起来像下面这样：
- en: '[PRE77]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: As you can see, we are defining the host groups and also configuring Ansible
    to use the `centos` user, which is the default for the original AMI we are using.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在定义主机组，并配置Ansible使用`centos`用户，这是我们正在使用的原始AMI的默认用户。
- en: 'The `site.yml` file needs to be updated:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`site.yml`文件需要更新：'
- en: '[PRE78]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As you can see, we now have three sections; the first section prepares the environment,
    as we have already seen—there is also the addition of the `ec2` role. This section
    is all executed on the Ansible controller.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在有三个部分；第一部分准备环境，正如我们已经看到的—还有`ec2`角色的添加。这一部分都在Ansible控制器上执行。
- en: 'In the next section, we move over to running the roles against the host in
    the `ec2_instance` group; as already mentioned, we are using `become: yes` and
    `become_method: sudo` on this host because the user we are connecting with, `centos`,
    does not have the correct privileges we need to install our software stack. This
    is why we need to disable `become` when using the `local_action` module. The third
    section takes us back to our Ansible controller, where we use the AWS API to create
    our AMI and launch it.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '在接下来的部分，我们转到对`ec2_instance`组中的主机运行角色；如前所述，我们在这个主机上使用`become: yes`和`become_method:
    sudo`，因为我们连接的用户`centos`没有我们需要安装软件栈的正确权限。这就是为什么在使用`local_action`模块时需要禁用`become`。第三部分将我们带回到我们的Ansible控制器，在那里我们使用AWS
    API来创建我们的AMI并启动它。'
- en: 'Don''t forget to set your access key and secret access key environment variables:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记设置您的访问密钥和秘密访问密钥环境变量：
- en: '[PRE79]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Before we run the playbook you need to make sure that you are subscribed to
    the CentOS 7 Amazon Machine Image in the AWS Marketplace, to do this go to the
    following link and hit the subscribe button, if you are not subscribed to the
    AMI you will receive an error when you run the playbook instructing you that you
    do not have access to the image: [https://aws.amazon.com/marketplace/pp/B00O7WM7QW](https://aws.amazon.com/marketplace/pp/B00O7WM7QW).'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行playbook之前，您需要确保您已经订阅了AWS Marketplace中的CentOS 7 Amazon Machine Image，要做到这一点，请转到以下链接并点击订阅按钮，如果您没有订阅AMI，当您运行playbook时，您将收到一个错误提示，告诉您您无法访问该镜像：[https://aws.amazon.com/marketplace/pp/B00O7WM7QW](https://aws.amazon.com/marketplace/pp/B00O7WM7QW)。
- en: 'We are going to be timing our playbook to run again, so, to execute the playbook,
    use the following commands:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次计时我们的playbook运行，因此，要执行playbook，请使用以下命令：
- en: '[PRE80]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'As we have already seen the output of half of the playbook running, I am going
    to skip the output of the `vpc`, `subnets`, `gateway`, `securitygroups`, `elb`,
    `rds`, and `efs` roles, meaning that we will start with the `ec2` one:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经看到了一半的playbook运行的输出，我将跳过`vpc`、`subnets`、`gateway`、`securitygroups`、`elb`、`rds`和`efs`角色的输出，这意味着我们将从`ec2`角色开始：
- en: '[PRE81]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The playbook ran for me in the following time:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，playbook运行的时间如下：
- en: '[PRE82]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'So, from a single command and in 32 minutes, we have a highly available vanilla
    WordPress installation. If you find out the public URL of your Elastic Load Balancer
    from the AWS console, you should be able to see your site:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过一个命令，在32分钟内，我们拥有了一个高可用的普通WordPress安装。如果您从AWS控制台找到弹性负载均衡器的公共URL，您应该能够看到您的站点：
- en: '![](assets/5881a9c1-2284-48e3-a975-9cdfaa51b5e4.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5881a9c1-2284-48e3-a975-9cdfaa51b5e4.png)'
- en: 'Checking the EC2 instances in the AWS console, we can see that there are three
    instances, all called `wordpress-ec2`, running and the `wordpress-tmp` instance
    has been terminated:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS控制台中检查EC2实例，我们可以看到有三个名为`wordpress-ec2`的实例在运行，而`wordpress-tmp`实例已被终止：
- en: '![](assets/abb0b8b8-edcb-48ea-ba19-4d6f8c9ce447.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/abb0b8b8-edcb-48ea-ba19-4d6f8c9ce447.png)'
- en: 'Now, let''s see what happens when we run the playbook again. We should not
    only see it execute more quickly, but it should skip a few roles:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们再次运行playbook时会发生什么。我们不仅应该看到它执行得更快，而且它应该跳过一些角色：
- en: '[PRE83]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Again, I have truncated the output:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我已经截断了输出：
- en: '[PRE84]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This time, I got the following timings returned:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我得到了以下时间：
- en: '[PRE85]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Once complete, I checked that I could still log in to WordPress using the username
    (`ansible`) and password (`password`) we set in the playbook by going to my Elastic
    Load Balancer URL and adding `/wp-admin` to the end:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我检查了一下，我仍然可以使用playbook中设置的用户名（`ansible`）和密码（`password`）登录WordPress，方法是访问我的弹性负载均衡器URL并在末尾添加`/wp-admin`：
- en: '![](assets/4e2a20d2-626e-4bd8-a44a-f444ded054e7.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4e2a20d2-626e-4bd8-a44a-f444ded054e7.png)'
- en: 'You can see what happened in the autoscaling activity logs in the AWS console:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在AWS控制台的自动扩展活动日志中看到发生了什么：
- en: '![](assets/5560c9c1-21d8-4b43-a1e1-b7fa840ca59d.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5560c9c1-21d8-4b43-a1e1-b7fa840ca59d.png)'
- en: As you can see, three new instances were launched and three terminated.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，启动了三个新实例，终止了三个实例。
- en: Terminating all the resources
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止所有资源
- en: 'Before we complete this chapter, we need to look at terminating the resources;
    the only additions we need to make are to remove the autoscaling group and AMIs.
    To do this, we are going to add four tasks to `roles/remove/tasks/main.yml`; starting
    at the top of the file, add the following two tasks:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章之前，我们需要查看终止资源；我们需要做的唯一补充是移除自动扩展组和AMI。为此，我们将在`roles/remove/tasks/main.yml`中添加四个任务；从文件顶部开始，添加以下两个任务：
- en: '[PRE86]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The first task removes the autoscaling group. This, in turn, will terminate
    any instances that have been launched by it. We have also built in a pause to
    ensure that everything has been removed properly from the AWS API.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是移除自动扩展组。这将终止由它启动的任何实例。我们还内置了一个暂停，以确保一切都已从AWS API中正确地移除。
- en: 'At the end of the role, add the following two tasks to remove all of the AMIs:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在角色的末尾，添加以下两个任务以移除所有AMI：
- en: '[PRE88]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You can then run the playbook with the following command:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用以下命令运行playbook：
- en: '[PRE89]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: As before, don't forget to check that the Elastic Load Balancer has been removed
    before progressing. Once the playbook has run, I would recommend you log in to
    the AWS console and double-check that everything has been correctly removed. The
    playbook does not remove the launch configurations, which should not be a problem
    as there are no costs associated with them. However, I would recommend checking
    on unattached EBS volumes and snapshots as these will incur costs.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 与以往一样，不要忘记在继续之前检查弹性负载均衡器是否已被移除。一旦playbook运行完毕，我建议您登录AWS控制台，双重检查一切是否已正确移除。playbook不会移除启动配置，这不应该是一个问题，因为它们没有相关的成本。但是，我建议检查未附加的EBS卷和快照，因为这些将产生成本。
- en: Summary
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have taken our AWS to the next level by creating and launching
    a highly available WordPress installation. By leveraging the various services
    offered by AWS, we engineered out any single points of failure with regards to
    the availability of instances and availability zones.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过创建和启动一个高可用的WordPress安装将我们的AWS提升到了一个新的水平。通过利用AWS提供的各种服务，我们消除了与实例和可用区的可用性有关的任何单点故障。
- en: We also built logic into our playbook so that we can use the same command to
    launch a new deployment or update the operating system on an existing one with
    a rolling deploy of new instance AMIs that contain our updated packages—allowing
    for zero downtime during deployment.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在playbook中构建了逻辑，以便我们可以使用相同的命令启动新的部署或更新现有部署的操作系统，通过包含我们更新的软件包的新实例AMI进行滚动部署，从而在部署期间实现零停机。
- en: While the WordPress deployment is probably as simple as we could make it, the
    process of deploying the production-ready images would remain similar when using
    a more complicated application.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然WordPress部署可能是我们能够做的最简单的，但是在使用更复杂的应用程序时，部署生产就绪的镜像的过程仍然是类似的。
- en: In our next chapter, we are going to look at moving from public cloud to private
    cloud, and how Ansible interacts with VMware.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一章中，我们将研究从公共云迁移到私有云，并且Ansible如何与VMware交互。
- en: Questions
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the name of the variable that is registered using the `gather_facts`
    option, which contains the date and time our playbook was executed?
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`gather_facts`选项注册的变量的名称是什么，其中包含了我们执行playbook的日期和时间？
- en: 'True or false: Ansible automatically figures out which task it needs to execute,
    meaning we don''t have to define any logic ourselves.'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确或错误：Ansible自动找出需要执行的任务，这意味着我们不必自己定义任何逻辑。
- en: Explain why we have to use the `local_action` module.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释为什么我们必须使用`local_action`模块。
- en: Which command do we prepend to our `ansible-playbook` command to record how
    long our command took to execute?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`ansible-playbook`命令之前添加哪个命令来记录命令执行所花费的时间？
- en: 'True or false: When using autoscaling, you have to manually launch EC2 instances.'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：在使用自动扩展时，您必须手动启动EC2实例。
- en: Update the playbook so that it gives you the public URL of the Elastic Load
    Balancer at the end of the playbook run.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新playbook，以便在playbook运行结束时提供Elastic Load Balancer的公共URL。
- en: Further reading
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: You can find more details about CentOS AMIs on the AWS Marketplace at [https://aws.amazon.com/mp/centos/](https://aws.amazon.com/mp/centos/).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在AWS Marketplace的[https://aws.amazon.com/mp/centos/](https://aws.amazon.com/mp/centos/)找到有关CentOS
    AMI的更多详细信息。
