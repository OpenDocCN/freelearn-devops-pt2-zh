- en: '*Chapter 12*: Infrastructure Provisioning'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：基础设施供应'
- en: Almost everything in data centers is becoming software-defined, from networks
    to the server infrastructure on which our software runs. **Infrastructure as a
    Service** (**IaaS**) providers offer APIs for programmatically managing images,
    servers, networks, and storage components. These resources are often expected to
    be created just-in-time, in order to reduce costs and increase efficiency.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据中心中的几乎所有内容都变成了软件定义，从网络到我们的软件运行的服务器基础设施。**基础设施即服务**（**IaaS**）提供商提供API，用于以编程方式管理镜像、服务器、网络和存储组件。通常期望这些资源是即时创建的，以降低成本并提高效率。
- en: As a result, a great deal of effort has gone into the cloud provisioning aspect
    of Ansible over the years, with more than 30 infrastructure providers catered
    for in the official Ansible release. These range from open source solutions such
    as OpenStack and oVirt to proprietary providers such as VMware and cloud providers
    such as AWS, GCP, and Azure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，多年来，Ansible在云供应方面投入了大量的工作，官方发布的Ansible版本中支持了30多个基础设施提供商。这些范围从OpenStack和oVirt等开源解决方案到专有提供商如VMware和云提供商如AWS、GCP和Azure。
- en: 'There are more use cases than we can cover in this chapter, but nonetheless,
    we will explore the following ways in which Ansible can interact with a variety
    of these services:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的用例比我们能够覆盖的要多，但尽管如此，我们将探讨Ansible与各种这些服务进行交互的方式：
- en: Managing an on-premise cloud infrastructure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理本地云基础设施
- en: Managing a public cloud infrastructure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理公共云基础设施
- en: Interacting with Docker containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Docker容器交互
- en: Building containers with Ansible
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible构建容器
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the examples presented in this chapter, you will need a Linux machine
    running **Ansible 4.3** or newer. Almost any flavor of Linux should do – for those
    interested in specifics, all the code presented in this chapter was tested on
    Ubuntu Server 20.04 LTS unless states otherwise, and on Ansible 4.3\. The example
    code that accompanies this chapter can be downloaded from GitHub at this URL:
    [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter12).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中提供的示例，您需要一台运行**Ansible 4.3**或更新版本的Linux机器。几乎任何Linux版本都可以 - 对于那些对具体细节感兴趣的人，本章中提供的所有代码都是在Ubuntu
    Server 20.04 LTS上测试的，除非另有说明，并且在Ansible 4.3上测试。本章附带的示例代码可以从GitHub的以下网址下载：[https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter12)。
- en: Check out the following video to see the Code in Action:[https://bit.ly/3BU6My2](https://bit.ly/3BU6My2)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频以查看代码的实际操作：[https://bit.ly/3BU6My2](https://bit.ly/3BU6My2)
- en: Managing an on-premise cloud infrastructure
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理本地云基础设施
- en: The cloud is a popular but vague term, used to describe IaaS. There are many
    types of resources that can be provided by a cloud, although the most commonly discussed are
    compute and storage. Ansible is capable of interacting with numerous cloud providers
    in order to discover, create, or otherwise manage resources within them. Note
    that although we will focus on the compute and storage resources in this chapter,
    Ansible has a module for interacting with many more cloud resource types, such
    as load balancers, and even cloud role-based access controls.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 云是一个常见但模糊的术语，用于描述IaaS。云可以提供许多类型的资源，尽管最常讨论的是计算和存储。Ansible能够与许多云提供商进行交互，以便在其中发现、创建或管理资源。请注意，尽管本章将专注于计算和存储资源，但Ansible还有一个模块用于与许多其他云资源类型进行交互，例如负载均衡器，甚至云角色访问控制。
- en: One such cloud provider that Ansible can interact with is OpenStack (an open
    source cloud operating system), and this is a likely solution for those with a
    need for on-premise IaaS functionality. A suite of services provides interfaces
    to manage compute, storage, and networking services, plus many other supportive
    services. There is not a single provider of OpenStack; instead, many public and
    private cloud providers build their products with OpenStack, and thus although
    the providers may themselves be disparate, they provide the same APIs and software
    interfaces so that Ansible can automate tasks with ease in these environments.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible可以与之交互的一个这样的云提供商是OpenStack（一个开源的云操作系统），对于那些需要本地IaaS功能的人来说，这是一个可能的解决方案。一套服务提供了管理计算、存储和网络服务以及许多其他支持服务的接口。OpenStack并不是一个单一的提供商；相反，许多公共和私有云提供商使用OpenStack构建其产品，因此尽管提供商本身可能是分散的，它们提供相同的API和软件接口，以便Ansible可以轻松地在这些环境中自动化任务。
- en: 'Ansible has supported OpenStack services since very early in the project, and
    this support can now be found as part of the `OpenStack.Cloud` collection. That
    initial support has grown to include over 70 modules, with support for managing
    the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible自项目早期就支持OpenStack服务，现在这种支持可以在`OpenStack.Cloud`集合中找到。最初的支持已经发展到包括70多个模块，支持管理以下内容：
- en: Compute
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算
- en: Bare-metal compute
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 裸金属计算
- en: Compute images
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算镜像
- en: Authentication accounts
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证账户
- en: Networks
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: Object storage
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象存储
- en: Block storage
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块存储
- en: In addition to performing **create, read, update, and delete** (**CRUD**) actions
    on the preceding types of resources, Ansible also includes the ability to use
    OpenStack (and other clouds) as an inventory source, and we touched on this earlier,
    in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The System
    Architecture and Design of Ansible*.Again, the dynamic inventory provider maybe
    found in the `OpenStack.Cloud` collection. Each execution of `ansible` or `ansible-playbook` that
    utilizes an OpenStack cloud as an inventory source will get on-demand information
    about what compute resources exist, and various facts about those compute resources.
    Since the cloud service is already tracking these details, this can reduce overheads
    by eliminating the manual tracking of resources.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在前面的资源类型上执行**创建、读取、更新和删除**（CRUD）操作之外，Ansible还包括使用OpenStack（和其他云）作为清单来源的能力，我们之前在[*第1章*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015)中已经提到过这一点，*Ansible的系统架构和设计*。再次强调，动态清单提供程序可能在`OpenStack.Cloud`集合中找到。每次使用OpenStack云作为清单来源的`ansible`或`ansible-playbook`执行都将获取关于现有计算资源的即时信息，以及有关这些计算资源的各种事实。由于云服务已经跟踪了这些细节，这可以通过消除资源的手动跟踪来减少开销。
- en: 'To demonstrate Ansible''s ability to manage and interact with cloud resources,
    we''ll walk through two scenarios: a scenario to create and then interact with
    new compute resources and a scenario that will demonstrate using OpenStack as
    an inventory source.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示Ansible管理和与云资源交互的能力，我们将演示两种情景：一个是创建并与新的计算资源交互的情景，另一个是演示使用OpenStack作为清单来源的情景。
- en: Creating servers
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建服务器
- en: The OpenStack compute service provides an API for creating, reading, updating,
    and deleting virtual machine servers. Through this API, we'll be able to create
    the server for our demonstration. After accessing and modifying the server through
    SSH, we'll also use the API to delete the server. This self-service ability is
    a key feature of cloud computing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: OpenStack计算服务提供了一个API，用于创建、读取、更新和删除虚拟机服务器。通过这个API，我们将能够为我们的演示创建服务器。在通过SSH访问和修改服务器之后，我们还将使用API来删除服务器。这种自助服务能力是云计算的一个关键特性。
- en: 'Ansible can be used to manage these servers by using the various `openstack.cloud` modules:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible可以使用各种`openstack.cloud`模块来管理这些服务器：
- en: '`openstack.cloud.server`: This module is used to create and delete virtual
    servers.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openstack.cloud.server`：此模块用于创建和删除虚拟服务器。'
- en: '`openstack.cloud.server_info`: This module is used to gather information about
    a server – in Ansible 2.9 and earlier, it returned these as facts, but this is
    no longer the case.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openstack.cloud.server_info`：此模块用于收集有关服务器的信息-在Ansible 2.9及更早版本中，它将这些信息返回为事实，但现在不再是这样。'
- en: '`openstack.cloud.server_action`: This module is used to perform various actions
    on a server.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openstack.cloud.server_action`：此模块用于对服务器执行各种操作。'
- en: '`openstack.cloud.server_group`: This module is used to create and delete server
    groups.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openstack.cloud.server_group`：此模块用于创建和删除服务器组。'
- en: '`openstack.cloud.server_volume`: This module is used to attach or detach block
    storage volumes from a server.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openstack.cloud.server_volume`：此模块用于将块存储卷附加到服务器或从服务器分离。'
- en: '`openstack.cloud.server_metadata`: This module is used to create, update, and
    delete metadata for virtual servers.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openstack.cloud.server_metadata`：此模块用于创建、更新和删除虚拟服务器的元数据。'
- en: Booting virtual servers
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动虚拟服务器
- en: For our demonstration, we will use `openstack.cloud.server`. We'll need to provide
    authentication details about our cloud, such as the auth URL and our login credentials.
    In addition to this, we will need to set up our Ansible host with the correct
    prerequisite software for this module to function. As we discussed earlier in
    the book when addressing dynamic inventories, Ansible sometimes requires additional
    software or libraries on the host in order to function. In fact, it is a policy
    of the Ansible developers to not ship cloud libraries with Ansible itself, as
    they would rapidly become out of date, and different operating systems would require
    different versions – even the advent of collections has not changed this.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的演示，我们将使用`openstack.cloud.server`。我们需要提供关于我们的云的身份验证详细信息，如认证URL和登录凭据。除此之外，我们还需要为我们的Ansible主机设置正确的先决条件软件，以使此模块正常运行。正如我们在本书早期讨论动态清单时所讨论的，Ansible有时需要主机上的额外软件或库才能正常运行。事实上，Ansible开发人员的政策是不将云库与Ansible本身一起发布，因为它们会迅速过时，并且不同的操作系统需要不同的版本-即使是集合的出现也没有改变这一点。
- en: 'You can always find the software dependencies in the Ansible documentation
    for each module, so it is worth checking this when using a module for the first
    time (especially a cloud provider module). The Ansible host used for the demos
    throughout this book is based on Ubuntu Server 20.04 and in order for the `openstack.cloud.server`
    module to function, I had to run the following command first:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在每个模块的Ansible文档中找到软件依赖关系，因此在第一次使用模块时（特别是云提供商模块）值得检查这一点。本书中用于演示的Ansible主机基于Ubuntu
    Server 20.04，为了使`openstack.cloud.server`模块正常运行，我首先必须运行以下命令：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The exact software and version will depend on our host operating system and
    may change with newer Ansible releases. There may be native packages available
    for your operating system, or you could install this Python module with `pip`.
    It is worth spending a few minutes checking the best approach for your operating
    system before proceeding.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 确切的软件和版本将取决于我们的主机操作系统，并可能随着较新的Ansible版本而改变。您的操作系统可能有本机软件包可用，或者您可以使用`pip`安装这个Python模块。在继续之前，值得花几分钟时间检查您的操作系统的最佳方法。
- en: 'Once the prerequisite modules are in place, we can proceed with the server
    creation. For this, we''ll need a flavor, an image, a network, and a name. You
    will also need a key, and this will need to be defined in the OpenStack GUI (or
    CLI) before proceeding. Naturally, these details may be different for each OpenStack
    cloud. For this demo, I am using a single, all-in-one VM based on **DevStack**,
    and I am using defaults as much as possible, to make it easy to follow. You can
    download DevStack and learn about getting started quickly here: [https://docs.openstack.org/devstack/latest/](https://docs.openstack.org/devstack/latest/).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦先决条件模块就位，我们就可以继续创建服务器。为此，我们将需要一个flavor，一个image，一个network和一个名称。您还需要一个密钥，在继续之前需要在OpenStack
    GUI（或CLI）中定义。当然，这些细节可能对每个OpenStack云都不同。在这个演示中，我正在使用基于**DevStack**的单个一体化虚拟机，并尽可能使用默认设置，以便更容易跟进。您可以在这里下载DevStack并了解快速入门：[https://docs.openstack.org/devstack/latest/](https://docs.openstack.org/devstack/latest/)。
- en: 'I''ll name our playbook `boot-server.yaml`. Our play starts with a name and
    uses `localhost` as the host pattern as the module we are calling talks to the
    OpenStack API from the local Ansible machine directly. As we do not rely on any
    local facts, I''ll turn fact-gathering off as well:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我将命名我们的剧本为`boot-server.yaml`。我们的剧本以一个名称开始，并使用`localhost`作为主机模式，因为我们调用的模块直接从本地Ansible机器与OpenStack
    API交互。由于我们不依赖于任何本地事实，我也会关闭事实收集：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To create the server, I''ll use the `openstack.cloud.server` module and provide
    the `auth` details relevant to an OpenStack cloud that I have access to, as well
    as a flavor, image, network, and name. Note the `key_name`, which indicates the
    SSH public key from the keypair you would have created for yourself in OpenStack
    prior to writing this playbook (as discussed previously in this chapter). This
    SSH public key is integrated into the `Fedora34` image we are using when it is
    first booted on OpenStack so that we can subsequently gain access to it over SSH. I
    also uploaded a `Fedora34` image for demonstration purposes in this chapter, as
    it allows greater manipulation than the default Cirros image that is included
    with OpenStack distributions. These images can be freely downloaded, ready-made,
    from [https://alt.fedoraproject.org/cloud/](https://alt.fedoraproject.org/cloud/).
    Finally, as you''d expect, I''ve obfuscated my password:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建服务器，我将使用`openstack.cloud.server`模块，并提供与我可以访问的OpenStack云相关的`auth`详细信息，以及一个flavor，image，network和name。请注意`key_name`，它指示了在编写此剧本之前您在OpenStack中为自己创建的密钥对的SSH公钥（如本章前面讨论的）。这个SSH公钥被集成到我们在OpenStack上首次引导时使用的`Fedora34`镜像中，以便我们随后可以通过SSH访问它。我还上传了一个`Fedora34`镜像，以便在本章中进行演示，因为它比OpenStack发行版中包含的默认Cirros镜像具有更大的操纵空间。这些镜像可以从[https://alt.fedoraproject.org/cloud/](https://alt.fedoraproject.org/cloud/)免费下载。最后，正如您所期望的，我已经对我的密码进行了混淆：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Important Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Authentication details can be written to an external file, which will be read
    by the underlying module code. This module code uses `openstacksdk`, a standard
    library for managing OpenStack credentials. Alternatively, they can be stored
    in an Ansible vault, as we described in [*Chapter 3*](B17462_03_Final_JC_ePub.xhtml#_idTextAnchor061), *Protecting
    Your Secrets with Ansible*, and then passed to the module as variables.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 认证详细信息可以写入一个外部文件，该文件将被底层模块代码读取。这个模块代码使用`openstacksdk`，这是一个用于管理OpenStack凭据的标准库。或者，它们可以存储在Ansible保险库中，正如我们在[*第3章*](B17462_03_Final_JC_ePub.xhtml#_idTextAnchor061)中描述的那样，*用Ansible保护您的秘密*，然后作为变量传递给模块。
- en: 'Running this play as is will simply create the server, and nothing more. To
    test this out (assuming you have access to a suitable OpenStack environment),
    run the playbook with the following commands:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 按原样运行这个剧本将只是创建服务器，没有别的。要测试这一点（假设您可以访问合适的OpenStack环境），请使用以下命令运行剧本：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Ensuring the Correct Python Environment Is Used
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用正确的Python环境
- en: Note that on Ubuntu Server 20.04, Ansible runs by default under Python 2.7 –
    this is not a problem and we have ignored this so far in this book – however,
    in this particular instance, we have installed the `openstacksdk` module only
    on Python 3, and as a result, we must tell Ansible to use the Python 3 environment.
    We do this here by setting an environment variable, but you could just as easily
    do this via an `ansible.cfg` file – this is left as an exercise for you to explore.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Ubuntu Server 20.04上，默认情况下，Ansible在Python 2.7下运行 - 这不是问题，我们在本书中到目前为止已经忽略了这一点
    - 但是，在这种特殊情况下，我们只在Python 3上安装了`openstacksdk`模块，因此我们必须告诉Ansible使用Python 3环境。我们通过设置一个环境变量来做到这一点，但您也可以通过`ansible.cfg`文件轻松地完成这一点
    - 这留给您去探索。
- en: 'A successful run of the playbook should yield output similar to that shown
    in *Figure 12.1*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 成功运行剧本应该产生类似于*图12.1*所示的输出：
- en: '![Figure 12.1 – Creating a virtual instance in OpenStack with Ansible'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 - 使用Ansible在OpenStack中创建虚拟实例'
- en: '](Images/B17462_12_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_01.jpg)'
- en: Figure 12.1 – Creating a virtual instance in OpenStack with Ansible
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 - 使用Ansible在OpenStack中创建虚拟实例
- en: 'I''ve truncated the output, as there is a lot of data returned from the module.
    Most importantly, we get data regarding the IP addresses of the host. This particular
    cloud uses a floating IP to provide public access to the server instance, which
    we can see the value of by registering the output and then debug printing the
    value of `openstack.accessIPv4`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经截断了输出，因为模块返回了大量数据。最重要的是，我们获得了有关主机IP地址的数据。这个特定的云使用浮动IP来提供对服务器实例的公共访问，我们可以通过注册输出然后调试打印`openstack.accessIPv4`的值来看到这个值：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Execute this playbook using a command similar to the preceding command (but
    without the added verbosity):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似于前面的命令执行此剧本（但不要添加冗长）：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This time, the first task does not result in a change, as the server that we
    want already exists – however, it still retrieves the information about the server,
    enabling us to discover its IP address:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，第一个任务不会导致更改，因为我们想要的服务器已经存在 - 但是，它仍然会检索有关服务器的信息，使我们能够发现其IP地址：
- en: '![Figure 12.2 – Using Ansible to retrieve the IP address of the OpenStack virtual
    machine we booted in the previous example'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 - 使用Ansible检索我们在上一个示例中启动的OpenStack虚拟机的IP地址'
- en: '](Images/B17462_12_02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_02.jpg)'
- en: Figure 12.2 – Using Ansible to retrieve the IP address of the OpenStack virtual
    machine we booted in the previous example
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 - 使用Ansible检索我们在上一个示例中启动的OpenStack虚拟机的IP地址
- en: The output shows an IP address of `172.24.4.81`. I can use that information
    to connect to my newly created cloud server.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示IP地址为`172.24.4.81`。我可以使用这些信息连接到我新创建的云服务器。
- en: Adding to runtime inventory
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加到运行时清单
- en: Booting a server isn't all that useful by itself. The server exists to be used
    and will likely need some configuration to become useful. While it's possible
    to have one playbook to create resources and a completely different playbook to
    manage configuration, we can also do it all from the same playbook. Ansible provides
    a facility to add hosts to the inventory as a part of a play, which will allow
    for the use of those hosts in subsequent plays.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务器本身并不是很有用。服务器存在是为了使用，并且可能需要一些配置才能变得有用。虽然可以有一个playbook来创建资源，另一个完全不同的playbook来管理配置，但我们也可以在同一个playbook中完成所有这些。Ansible提供了一个功能，可以在play的一部分中将主机添加到清单中，这将允许在后续play中使用这些主机。
- en: 'Working from the previous example, we have enough information to add the new
    host to the runtime inventory, by way of the `ansible.builtin.add_host` module:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上一个示例，我们有足够的信息通过`ansible.builtin.add_host`模块将新主机添加到运行时清单：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I know that this image has a default user of `fedora`, so I set a host variable
    accordingly, along with setting the IP address as the connection address.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这个镜像有一个默认的用户`fedora`，所以我相应地设置了一个主机变量，并设置IP地址作为连接地址。
- en: Important Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This example is also glossing over any required security group configuration
    in OpenStack, and any accepting of the SSH host key. Additional tasks can be added
    to manage these things, or you might pre-configure them as I have done in my environment.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也忽略了在OpenStack中所需的安全组配置，以及接受SSH主机密钥。可以添加其他任务来管理这些事情，或者您可以像我在我的环境中所做的那样预先配置它们。
- en: 'With the server added to our inventory, we can do something with it. Let''s
    imagine a scenario in which we want to use this cloud resource to convert an image
    file, using `ImageMagick` software. To accomplish this, we''ll need a new play
    to make use of the new host. I know that this particular Fedora image does not
    contain Python, so we need to add Python and the Python bindings for `dnf` (so
    we can use the `ansible.builtin.dnf` module) as our first task, using the `ansible.builtin.raw`
    module:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务器添加到清单后，我们可以对其进行操作。假设我们想要使用这个云资源来转换图像文件，使用`ImageMagick`软件。为了实现这一点，我们需要一个新的play来利用新的主机。我知道这个特定的Fedora镜像不包含Python，所以我们需要添加Python和`dnf`的Python绑定（这样我们就可以使用`ansible.builtin.dnf`模块）作为我们的第一个任务，使用`ansible.builtin.raw`模块：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we''ll need the `ImageMagick` software, which we can install by using
    the `dnf` module:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要`ImageMagick`软件，我们可以使用`dnf`模块安装它：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running the playbook at this point will show the changed tasks for our new
    host; note that this time, we must give `ansible-playbook` the location of our
    private key file from OpenStack, so that it can authenticate to the Fedora image,
    using the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此时运行playbook将显示我们新主机的更改任务；请注意，这一次，我们必须给`ansible-playbook`提供来自OpenStack的私钥文件的位置，以便它可以使用以下命令对`Fedora`镜像进行身份验证：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A successful run of the playbook should yield output like that shown in *Figure
    12.3*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 成功运行playbook应该产生像*图12.3*中显示的输出：
- en: '![Figure 12.3 – Performing post instantiation configuration on our OpenStack
    virtual'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 - 在我们的OpenStack虚拟机上执行实例化后配置'
- en: machine using Ansible
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ansible的机器
- en: '](Images/B17462_12_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_03.jpg)'
- en: Figure 12.3 – Performing post instantiation configuration on our OpenStack virtual
    machine using Ansible
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 - 在我们的OpenStack虚拟机上执行实例化后配置，使用Ansible
- en: We can see Ansible reporting two changed tasks on the host `mastery1`, which
    we just created in the first play. This host does not exist in the `mastery-hosts` inventory
    file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Ansible在主机`mastery1`上报告了两个更改的任务，这是我们在第一个play中刚刚创建的。这个主机在`mastery-hosts`清单文件中不存在。
- en: 'We have turned off verbose reporting here, too, as the output would otherwise
    be very cumbersome to wade through; however, given that we have the private key
    file for our OpenStack instance, we can manually log in and check the results
    of our playbook, for example, using a command like the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们也关闭了冗长的报告，因为输出会很繁琐；但是，鉴于我们有OpenStack实例的私钥文件，我们可以手动登录并检查我们playbook的结果，例如，使用以下命令：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This command queries the RPM package database and displays a short list of
    the most recently installed ones. The output might look something like that shown
    in *Figure 12.4*, though dates will undoubtedly vary:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令查询RPM软件包数据库，并显示最近安装的软件包的简短列表。输出可能看起来像*图12.4*中显示的那样，尽管日期肯定会有所不同：
- en: '![Figure 12.4 – Checking the success of our playbook on our OpenStack VM'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4 - 检查我们在OpenStack VM上的playbook成功'
- en: '](Images/B17462_12_04.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_04.jpg)'
- en: Figure 12.4 – Checking the success of our playbook on our OpenStack VM
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 - 检查我们在OpenStack VM上的playbook成功
- en: From here, we could extend our second play to upload a source image file by
    using `ansible.builtin.copy`, then perform a command by using `ImageMagick` on
    the host to convert the image. Another task can be added to fetch the converted
    file back down by using the `ansible.builtin.slurp` module or the modified file
    can be uploaded to a cloud-based object store. Finally, a last play can be added
    to delete the server itself.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们可以扩展我们的第二个play，通过使用`ansible.builtin.copy`上传源图像文件，然后通过在主机上使用`ImageMagick`执行命令来转换图像。可以添加另一个任务，通过使用`ansible.builtin.slurp`模块将转换后的文件下载回来，或者将修改后的文件上传到基于云的对象存储中。最后，可以添加最后一个play来删除服务器本身。
- en: The entire lifespan of the server, from creation to configuration to use, and
    finally, to removal, can all be managed with a single playbook. The playbook can
    be made dynamic by reading runtime variable data, in order to define what file
    should be uploaded/modified and where it should be stored, essentially turning
    the playbook into a reusable program. Although somewhat simplistic, hopefully,
    this gives you a clear idea of how powerful Ansible is for working with infrastructure
    service providers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的整个生命周期，从创建到配置再到使用，最后到移除，都可以通过一个单一的playbook来管理。通过读取运行时变量数据，playbook可以变得动态，以定义应上传/修改哪个文件以及应存储在何处，从而将playbook转变为可重复使用的程序。虽然有些简单，但希望这能让您清楚地了解Ansible在与基础设施服务提供商合作时有多强大。
- en: Using OpenStack inventory sources
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用OpenStack清单源
- en: 'Our previous example showed a single-use, short-lived cloud server. What if
    we want to create and use long-lived cloud servers, instead? Walking through the
    tasks of creating them and adding them to the temporary inventory each time we
    want to touch them seems inefficient. Manually recording the server details in
    a static inventory also seems inefficient, and also error-prone. Thankfully, there
    is a better way: using the cloud itself as a dynamic inventory source.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的示例展示了一个一次性的短暂的云服务器。如果我们想要创建和使用长期的云服务器呢？每次想要操作它们时，都要手动记录创建它们并将它们添加到临时清单的任务似乎效率低下。在静态清单中手动记录服务器详细信息似乎也效率低下，而且容易出错。幸运的是，有一个更好的方法：使用云本身作为动态清单源。
- en: 'Ansible ships with a number of dynamic inventory scripts for cloud providers,
    as we discussed in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The
    System Architecture and Design of Ansible*. We''ll continue our examples here
    with OpenStack. To recap, the `openstack.cloud` collection provides the dynamic
    inventory script that we need. To make use of this script, we need to create a
    YAML file that tells Ansible to utilize this inventory script – this file must
    be named `openstack.yaml` or `openstack.yml`. It should contain code that looks
    something like the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible附带了许多云提供商的动态清单脚本，正如我们在[*第1章*]（B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015）中讨论的那样，*Ansible的系统架构和设计*。我们将在这里继续使用OpenStack的示例。回顾一下，`openstack.cloud`集合提供了我们需要的动态清单脚本。要使用此脚本，我们需要创建一个YAML文件，告诉Ansible使用此清单脚本
    - 此文件必须命名为`openstack.yaml`或`openstack.yml`。它应该包含类似以下的代码：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The configuration file needs a bit more consideration. This file holds authentication
    details for the OpenStack cloud(s) to connect to. That makes this file sensitive,
    and it should only be made visible to the users that require access to this information.
    In addition, the inventory script will attempt to load the configuration from
    the standard paths used by `os-client-config` (https://docs.openstack.org/os-client-config/latest/user/configuration.html#config-files),
    the underlying authentication code. This means that the configuration for this
    inventory source can live in the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件需要更多考虑。该文件保存了连接到OpenStack云的身份验证详细信息。这使得该文件非常敏感，只应对需要访问这些信息的用户可见。此外，清单脚本将尝试从`os-client-config`（https://docs.openstack.org/os-client-config/latest/user/configuration.html#config-files）使用的标准路径加载配置，这是底层身份验证代码。这意味着此清单源的配置可以存在于以下位置：
- en: '`clouds.yaml` (in the current working directory when executing the inventory
    script)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clouds.yaml`（在执行清单脚本时的当前工作目录）'
- en: '`~/.config/openstack/clouds.yaml`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~/.config/openstack/clouds.yaml`'
- en: '`/etc/openstack/clouds.yaml`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/openstack/clouds.yaml`'
- en: The first file that's found will be used. You can override this by adding the
    `clouds_yaml_path` to the `openstack.yaml` we created earlier in this section.
    For our example, I'll use a `clouds.yaml` file in the playbook directory alongside
    the script itself, in order to isolate configuration from any other paths.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 找到的第一个文件将被使用。您可以通过在我们之前在本节中创建的`openstack.yaml`中添加`clouds_yaml_path`来覆盖此设置。在我们的示例中，我将在playbook目录中与脚本本身一起使用`clouds.yaml`文件，以便将配置与任何其他路径隔离开来。
- en: 'Your `clouds.yaml` file will look very similar to the `auth:` section of the
    parameters to the `openstack.cloud.server` module we used in our earlier examples.
    There is one key difference though – in our earlier examples, we used the `demo`
    account and limited ourselves to the `demo` project in OpenStack. For us to query
    all instances across all projects (which we want to do to demonstrate some functionality),
    we need an account with administrator privileges rather than the `demo` account.
    For this part of the chapter, my `clouds.yaml` file contains the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`clouds.yaml`文件将与我们在之前示例中使用的`openstack.cloud.server`模块的参数的`auth:`部分非常相似。但有一个关键的区别
    - 在我们之前的示例中，我们使用了`demo`账户，并且限制了自己只能在OpenStack的`demo`项目中。为了查询所有项目中的所有实例（我们想要演示一些功能），我们需要一个具有管理员权限而不是`demo`账户的账户。在本章的这部分中，我的`clouds.yaml`文件包含以下内容：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The actual dynamic inventory script has a built-in help function, which you
    can also use to learn more about it. If you can locate it on your system, you
    can run this – on my system I used this command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的动态清单脚本有一个内置的帮助功能，您也可以使用它来了解更多信息。如果您可以在系统上找到它，您可以运行以下命令 - 在我的系统上，我使用了这个命令：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There is one final thing to know before we get started: If you are using the
    Ansible 4.0 release, this ships with version `1.4.0` of the `openstack.cloud`
    collection. This has a bug in it that renders the dynamic inventory script inoperable.
    You can query your installed collection version using this command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，还有一件事需要知道：如果您使用的是Ansible 4.0版本，它附带了`openstack.cloud`集合的`1.4.0`版本。其中存在一个错误，使得动态清单脚本无法运行。您可以使用以下命令查询您安装的集合版本：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you need to install a newer version, you can install it using this command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要安装更新版本，可以使用以下命令进行安装：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will install the collection in a hidden directory within your home directory,
    so if you are using the local copy, don''t use this command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的主目录中的一个隐藏目录中安装集合，因此如果您使用本地副本，请不要使用此命令：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use this instead:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用这个代替：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `help` output for the script shows a few possible arguments; however, the
    ones that Ansible will use are `--list` and `--host`, as *Figure 12.5* shows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的`help`输出显示了一些可能的参数；然而，Ansible将使用的是`--list`和`--host`，就像*图12.5*所示：
- en: '![Figure 12.5 – Demonstrating the help function of the openstack_inventory.py
    script'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 – 展示openstack_inventory.py脚本的帮助功能'
- en: '](Images/B17462_12_05.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_05.jpg)'
- en: Figure 12.5 – Demonstrating the help function of the openstack_inventory.py
    script
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 展示openstack_inventory.py脚本的帮助功能
- en: The first is used to get a list of all of the servers visible to the account
    used, and the second would be used to get host variable data from each, except
    that this inventory script returns all of the host variables with the `--list` call.
    Returning the data with the host list is a performance enhancement, as we discussed
    earlier in the book, eliminating the need to call the OpenStack APIs for each
    and every host returned.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个用于获取账户可见的所有服务器列表，第二个用于从每个服务器获取主机变量数据，不过这个清单脚本使用`--list`调用返回所有主机变量。使用主机列表返回数据是一种性能增强，正如我们在本书前面讨论的那样，消除了需要为每个主机调用OpenStack
    API的需求。
- en: 'The output from `--list` is quite long; here are the first few lines:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--list`的输出相当长；以下是前几行：
- en: '![Figure 12.6 – Demonstrating the data returned by the openstack_inventory.py
    dynamic inventory'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6 – 展示openstack_inventory.py动态清单返回的数据'
- en: '](Images/B17462_12_06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_06.jpg)'
- en: Figure 12.6 – Demonstrating the data returned by the openstack_inventory.py
    dynamic inventory
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 展示openstack_inventory.py动态清单返回的数据
- en: 'The configured account only has one visible server, which has a UUID of `875f88bc-ae18-42da-b988-0e4481e35f7e`,
    the instance that we booted in a previous example. We see this instance listed
    in the `flavor-ds1G` and `image-Fedora34` groups, for example. The first group
    is for all of the servers running with the `ds1G` flavor, and the second is for
    all servers running from our `Fedora34` image. These groupings happen automatically
    within the inventory plugin and may vary according to the OpenStack setup that
    you use. The tail end of the output will show the other groups provided by the
    plugin:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的账户只有一个可见的服务器，其UUID为`875f88bc-ae18-42da-b988-0e4481e35f7e`，这是我们在之前的示例中启动的实例。我们在`flavor-ds1G`和`image-Fedora34`组中看到了这个实例的列表，例如。第一个组是所有使用`ds1G`口味运行的服务器，第二个组是所有使用我们的`Fedora34`镜像运行的服务器。这些分组在清单插件中自动发生，可能根据您使用的OpenStack设置而有所不同。输出的末尾将显示插件提供的其他组：
- en: '![Figure 12.7 – Demonstrating more data returned by the openstack_inventory.py
    dynamic inventory'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7 – 展示openstack_inventory.py动态清单返回的更多数据'
- en: '](Images/B17462_12_07.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_07.jpg)'
- en: Figure 12.7 – Demonstrating more data returned by the openstack_inventory.py
    dynamic inventory
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 展示openstack_inventory.py动态清单返回的更多数据
- en: Important Note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Note that for the preceding groupings to appear, `expand_hostvars: True` must
    be set in the `openstack.yaml` file.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，要出现前述分组，`openstack.yaml`文件中必须设置`expand_hostvars: True`。'
- en: 'Some of the additional groups are as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一些额外的组如下：
- en: '`mastery_cloud`: All servers running on our `mastery_cloud` instance, as specified
    in our `clouds.yaml` file'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mastery_cloud`：在我们的`clouds.yaml`文件中指定的`mastery_cloud`实例上运行的所有服务器'
- en: '`flavor-ds1G`: All servers that use the `ds1G` flavor'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flavor-ds1G`：使用`ds1G`口味的所有服务器'
- en: '`image-Fedora 29`: All servers that use the `Fedora 29` image'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image-Fedora 29`：使用`Fedora 29`镜像的所有服务器'
- en: '`instance-875f88bc-ae18-42da-b988-0e4481e35f7e`: A group named after the instance
    itself'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instance-875f88bc-ae18-42da-b988-0e4481e35f7e`：以实例本身命名的一个组'
- en: '`nova`: All servers running under the `nova` service'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nova`：在`nova`服务下运行的所有服务器'
- en: There are many groups provided, each with a potentially different slice of the
    servers found by the inventory script. These groups make it easy to target just
    the right instances with plays. The hosts are defined as the UUIDs of the servers.
    As these are unique by nature, and also quite long, they are unwieldy as a target
    within a play. This makes groups all the more important.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了许多组，每个组可能都有清单脚本找到的服务器的不同部分。这些组使得通过play轻松地定位到正确的实例。主机被定义为服务器的UUID。由于这些本质上是唯一的，而且也相当长，它们在play中作为目标是笨拙的。这使得组变得更加重要。
- en: 'To demonstrate using this script as an inventory source, we''ll recreate the
    previous example, skipping over the creation of the server and just writing the
    second play by using an appropriate group target. We''ll name this playbook `configure-server.yaml`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示使用此脚本作为清单来源，我们将重新创建前面的示例，跳过创建服务器的步骤，只需使用适当的组目标编写第二个play。我们将命名这个playbook为`configure-server.yaml`：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The default user of this image is `fedora`; however, that information isn't
    readily available via the OpenStack APIs, and thus, it is not reflected in the
    data that our inventory script provides. We can simply define the user to use
    at the play level.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此镜像的默认用户是`fedora`；然而，这些信息在OpenStack API中并不容易获得，因此在我们的清单脚本提供的数据中并没有反映出来。我们可以在play级别简单地定义要使用的用户。
- en: This time, the host pattern is set to `all`, as we only have one host on our
    demo OpenStack server at this time; however, in real life, it's unlikely that
    you would be so open in your host targeting in Ansible.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，主机模式设置为`all`，因为我们的演示OpenStack服务器上目前只有一个主机；然而，在现实生活中，你不太可能在Ansible中如此公开地定位主机。
- en: 'The rest of the play is unchanged, and the output should look similar to previous
    executions:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: play的其余部分保持不变，输出应该与以前的执行类似：
- en: '![Figure 12.8 – Reconfiguring our virtual instance via a dynamic inventory
    plugin'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8 – 通过动态清单插件重新配置我们的虚拟实例'
- en: '](Images/B17462_12_08.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_08.jpg)'
- en: Figure 12.8 – Reconfiguring our virtual instance via a dynamic inventory plugin
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – 通过动态清单插件重新配置我们的虚拟实例
- en: This output differs from the last time that the `boot-server.yaml` playbook
    was executed in only a few ways. First, the `mastery1` instance is not created
    or booted. We're assuming that the servers we want to interact with have already
    been created and are running. Secondly, we have pulled the inventory for this
    playbook run directly from the OpenStack server itself, using a dynamic inventory
    plugin, rather than creating one in the playbook using `add_host`. Otherwise,
    the output is the same, barring two deprecation warnings. The warning regarding
    group names comes up because the dynamic inventory script provides automatically
    created group names that need to be sanitized – I imagine this will be fixed in
    a future release of the plugin. In addition, the Python deprecation warning is
    common to see right now during this transitionary phase as Ansible moves over
    completely to Python 3, and provided you are not missing any modules from your
    Python 2 environment, is benign.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出与上次执行`boot-server.yaml` playbook时有一些不同。首先，`mastery1`实例没有被创建或启动。我们假设我们想要交互的服务器已经被创建并正在运行。其次，我们直接从OpenStack服务器本身中提取了这个playbook运行的清单，使用了一个动态清单插件，而不是在playbook中使用`add_host`创建一个清单。除此之外，输出是一样的，除了两个弃用警告。关于组名的警告出现是因为动态清单脚本提供了自动创建的组名，需要进行清理
    - 我想这将在插件的未来版本中得到修复。此外，Python弃用警告在Ansible完全转向Python 3的过渡阶段是常见的，只要你的Python 2环境没有缺少任何模块，它是无害的。
- en: As servers get added or removed over time, each execution of the inventory plugin
    will discover what servers are there at the moment of playbook execution. This
    can save a significant amount of time spent attempting to maintain an accurate
    list of servers in static inventory files.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，每次运行清单插件时都会发现当前playbook执行时有哪些服务器被添加或移除。这可以节省大量时间，因为不需要试图维护静态清单文件中服务器的准确列表。
- en: Managing a public cloud infrastructure
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理公共云基础设施
- en: 'The management of public cloud infrastructures with Ansible is no more difficult
    than the management of OpenStack with it, as we covered earlier. In general, for
    any IaaS provider supported by Ansible, there is a three-step process to getting
    it working:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ansible管理公共云基础设施并不比使用它管理OpenStack更困难，就像我们之前讨论的那样。一般来说，对于任何被Ansible支持的IaaS提供商，让它工作的过程是一个三步骤的过程。
- en: Establish the Ansible collections, modules, and inventory plugins available
    to support the cloud provider.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立支持云提供商的Ansible集合、模块和动态清单插件。
- en: Install any prerequisite software or libraries on the Ansible host.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Ansible主机上安装任何先决条件软件或库。
- en: Define the playbook and run it against the infrastructure provider.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义playbook并对基础设施提供商运行它。
- en: 'There are dynamic inventory plugins readily available for most providers too,
    and we have already demonstrated two in this book:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数提供商也有现成的动态清单插件可用，我们在本书中已经演示了其中两个：
- en: '`amazon.aws.aws_ec2` was discussed in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The
    System Architecture and Design of Ansible*.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`amazon.aws.aws_ec2`在[*第1章*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015)中讨论过，*Ansible的系统架构和设计*。'
- en: '`openstack.cloud.openstack` was demonstrated earlier in this chapter.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openstack.cloud.openstack`在本章前面已经演示过。'
- en: 'Let''s take a look at **Amazon Web Services** (**AWS**), and specifically,
    the EC2 offering. We can boot up a new server from an image of our choosing, using
    exactly the same high-level process that we did with OpenStack earlier. However,
    as I''m sure you will have guessed by now, we have to use an Ansible module that
    offers specific EC2 support. Let''s build up the playbook. First of all, our initial
    play will once again run from the local host, as this will be making the calls
    to EC2 to boot up our new server:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看**亚马逊网络服务**（**AWS**），特别是EC2服务。我们可以使用我们选择的镜像启动一个新的服务器，使用与之前在OpenStack中完全相同的高级流程。然而，正如你现在肯定已经猜到的那样，我们必须使用一个提供特定EC2支持的Ansible模块。让我们构建playbook。首先，我们的初始play将再次从本地主机运行，因为这将调用EC2来启动我们的新服务器：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we will use the `community.aws.ec2_instance` module in place of the `openstack.cloud.server`
    module to boot up our desired server. This code is really just an example to show
    you how to use the modules; normally, just like with our `openstack.cloud.server`
    example, you would not include the secret keys in the playbook, but would store
    them in a vault somewhere:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`community.aws.ec2_instance`模块来代替`openstack.cloud.server`模块来启动我们想要的服务器。这段代码只是一个示例，用来展示如何使用模块；通常情况下，就像我们的`openstack.cloud.server`示例一样，你不会在playbook中包含密钥，而是会将它们存储在某个保险库中：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Important Note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `community.aws.ec2_instance` module requires the Python `boto3` library
    to be installed on the Ansible host; the method for this will vary between operating
    systems, but on our Ubuntu Server 20.04 demo host, it was installed using the `sudo
    apt install python3-boto3` command. Also, if you are installing this module under
    Python 3, be sure that your Ansible installation uses Python 3 by setting the
    `ANSIBLE_PYTHON_INTERPRETER` variable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`community.aws.ec2_instance`模块需要在Ansible主机上安装Python的`boto3`库；这个方法在不同的操作系统上会有所不同，但在我们的Ubuntu
    Server 20.04演示主机上，它是使用`sudo apt install python3-boto3`命令安装的。另外，如果你在Python 3下安装这个模块，请确保你的Ansible安装使用Python
    3，设置`ANSIBLE_PYTHON_INTERPRETER`变量。'
- en: The preceding code is intended to perform the same job as our `openstack.cloud.server`
    example, and while it looks similar at a high level, there are many differences.
    Hence, it is essential to read the module documentation whenever working with
    a new module, in order to understand precisely how to use it. Of specific interest,
    do note that the `user_data` field can be used to send post-creation scripts to
    the new VM; this is incredibly useful when the initial configuration is needed
    immediately, lending itself to `ansible.builtin.raw` commands. In this case, we
    use it to install the Python 3 prerequisites required to install `ImageMagick`
    with Ansible later on.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码旨在执行与我们的`openstack.cloud.server`示例相同的工作，尽管在高层次上看起来相似，但有许多不同之处。因此，在使用新模块时，有必要阅读模块文档，以确切了解如何使用它。特别值得注意的是，`user_data`字段可用于将创建后的脚本发送到新的VM；当需要立即进行初始配置时，这非常有用，适用于`ansible.builtin.raw`命令。在这种情况下，我们使用它来安装后续使用Ansible安装`ImageMagick`所需的Python
    3先决条件。
- en: 'Next, we can obtain the public IP address of our newly created server by using
    the `newserver` variable that we registered in the preceding task. However, note
    the different variable structure, as compared to the way that we accessed this
    information when using the `openstack.cloud.server` module (again, always refer
    to the documentation):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过使用在前面的任务中注册的`newserver`变量来获取我们新创建的服务器的公共IP地址。但是，请注意与使用`openstack.cloud.server`模块时访问此信息的方式相比，变量结构不同（再次，始终参考文档）：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another key difference between the `community.aws.ec2_instance` module and
    the `openstack.cloud.server` one is that `community.aws.ec2_instance` does not
    necessarily wait for SSH connectivity to become available before completing –
    this can be set using the `wait` parameter; thus, it is good practice to define
    a task specifically for this purpose to ensure that our playbook doesn''t fail
    later on due to a lack of connectivity:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`community.aws.ec2_instance`模块和`openstack.cloud.server`模块之间的另一个关键区别是，`community.aws.ec2_instance`不一定会在SSH连接可用之前完成
    - 这可以使用`wait`参数进行设置；因此，定义一个专门用于此目的的任务是一个良好的做法，以确保我们的playbook不会因为缺乏连接而在后来失败：'
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once this task has been completed, we will know that our host is alive and
    responding to SSH, so we can proceed to use `ansible.builtin.add_host` to add
    this new host to the inventory, and then install `ImageMagick` just like we did
    before (the image used here is the same Fedora 34 cloud-based image used in the
    OpenStack example):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此任务后，我们将知道我们的主机是活动的并且响应SSH，因此我们可以继续使用`ansible.builtin.add_host`将这个新主机添加到清单中，然后像之前一样安装`ImageMagick`（这里使用的图像是在OpenStack示例中使用的相同的Fedora
    34云图像）：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Putting all of this together and running the playbook should result in something
    like the following screenshot. Note that I have turned SSH host key checking off,
    to prevent the SSH transport agent from asking about adding the host key on the
    first run, which would cause the playbook to hang and wait for user intervention,
    using this command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起并运行playbook应该会产生类似以下截图的结果。请注意，我已经关闭了SSH主机密钥检查，以防止SSH传输代理在第一次运行时询问添加主机密钥，这将导致playbook挂起并等待用户干预，使用以下命令：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You will also note that I have saved my private SSH key from the keypair I
    generated on my AWS account as `mastery-key.pem` in the same directory as the
    playbook – you will need to save your own key in this location and reference it
    in the command line accordingly. A successful run should look something like the
    output shown in *Figure 12.9*:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到，我已经将我在AWS帐户上生成的密钥对中保存的私人SSH密钥保存为`mastery-key.pem`，保存在与playbook相同的目录中
    - 您需要将您自己的密钥保存在此位置，并相应地在命令行中引用它。成功运行应该看起来像*图12.9*中显示的输出：
- en: '![Figure 12.9 – Booting and setting up an Amazon EC2 instance using Ansible'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.9 - 使用Ansible引导和设置Amazon EC2实例'
- en: '](Images/B17462_12_09.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_09.jpg)'
- en: Figure 12.9 – Booting and setting up an Amazon EC2 instance using Ansible
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 - 使用Ansible引导和设置Amazon EC2实例
- en: As we have seen here, we can achieve the same result on a different cloud provider,
    using only a subtly different playbook. The key here is to read the documentation
    that comes with each module and ensure that both the parameters and return values
    are correctly referenced.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这里看到的，我们可以在不同的云提供商上使用略有不同的playbook来实现相同的结果。关键在于阅读每个模块附带的文档，并确保正确引用参数和返回值。
- en: 'We could apply this methodology to Azure, Google Cloud, or any of the other
    cloud providers that Ansible ships with support for. If we wanted to repeat this
    example on Azure, then we would need to use the `azure.azcollection.azure_rm_virtualmachine`
    module. The documentation for this module states that we need Python 2.7 or newer
    (this is already a part of our Ubuntu Server 20.04 demo machine), and a whole
    suite of Python modules, the names of which along with required versions can be
    found in a file named `requirements-azure.txt`, which is included with the collection.
    The expectation is that you will install these requirements with `pip`, and you
    can do this by locating the aforementioned file on your filesystem and then installing
    the required modules. On my demo system, I achieved this with the following commands:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这种方法应用到Azure、Google Cloud或Ansible支持的任何其他云提供商。如果我们想在Azure上重复这个例子，那么我们需要使用`azure.azcollection.azure_rm_virtualmachine`模块。该模块的文档说明我们需要Python
    2.7或更新版本（这已经是我们Ubuntu Server 20.04演示机的一部分），以及一整套Python模块，这些模块的名称以及所需版本可以在一个名为`requirements-azure.txt`的文件中找到，该文件包含在集合中。期望您将使用`pip`安装这些要求，并且您可以通过在文件系统上找到上述文件，然后安装所需的模块来实现这一点。在我的演示系统上，我使用了以下命令来实现这一点：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With these prerequisites satisfied, we can build up our playbook again. Note
    that with Azure, multiple authentication methods are possible. For the sake of
    simplicity, I am using the Azure Active Directory credentials that I created for
    this demo; however, to enable this, I had to also install the official Azure CLI
    utility (following the instructions available here: [https://docs.microsoft.com/en-gb/cli/azure/install-azure-cli-linux?pivots=apt](https://docs.microsoft.com/en-gb/cli/azure/install-azure-cli-linux?pivots=apt)),
    and log in using the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 满足了这些先决条件，我们可以再次构建我们的playbook。请注意，使用Azure，可以使用多种身份验证方法。为了简单起见，我使用了为此演示创建的Azure
    Active Directory凭据；但是，为了启用此功能，我还必须安装官方的Azure CLI实用程序（按照此处提供的说明进行：[https://docs.microsoft.com/en-gb/cli/azure/install-azure-cli-linux?pivots=apt](https://docs.microsoft.com/en-gb/cli/azure/install-azure-cli-linux?pivots=apt)），并使用以下命令登录：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This ensures that your Ansible host is trusted by Azure. In practice, you would
    set up a **service principal** that removes the need for this, and you are encouraged
    to explore this option by yourself. To continue with the current simple example,
    we set up the header of our playbook like before:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保您的Ansible主机受到Azure的信任。在实践中，您可以设置一个**服务主体**，从而无需进行此操作，鼓励您自行探索这个选项。继续进行当前的简单示例，我们像以前一样设置playbook的头部：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that this time, we will store a password for our new VM in a variable;
    normally, we would do this in a vault, but that is again left as an exercise for
    the reader. From here, we use the `azure.azcollection.azure_rm_virtualmachine`
    module to boot up our new VM. To make use of a `Fedora 34` image for continuity
    with the previous examples, I''ve had to go to the image marketplace on Azure,
    which requires some additional parameters, such as `plan`, to be defined. To enable
    the use of this image with Ansible, I first had to find it, then accept the terms
    of the author to enable its use, using the `az` command-line utility with these
    commands:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这一次，我们将为新VM存储一个密码变量；通常情况下，我们会将其存储在保险库中，但这又留给读者作为练习。从这里开始，我们使用`azure.azcollection.azure_rm_virtualmachine`模块来启动我们的新VM。为了保持与之前示例的连贯性，我必须在Azure的图像市场上找到`Fedora
    34`图像，这需要定义一些额外的参数，例如`plan`。为了使Ansible能够使用此图像，我首先必须找到它，然后接受作者的条款以启用其使用，使用以下命令使用`az`命令行实用程序：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'I also had to create the resource group and network that the VM would use;
    these are very much Azure-specific steps and are well documented (and considered
    *bread and butter* if you are familiar with Azure). Once all of the prerequisites
    were completed, I was then able to write the following playbook code to boot up
    our Azure-based `Fedora 34` image:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我还必须创建VM将使用的资源组和网络；这些都是非常Azure特定的步骤，并且有很好的文档记录（如果您熟悉Azure，则被认为是*基本操作*）。完成所有先决条件后，我就能够编写以下playbook代码来启动我们基于Azure的`Fedora
    34`图像：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As with the previous examples, we obtain the public IP address of our image
    (note the complex variable required to access this), ensure that SSH access is
    working, and then use `ansible.builtin.add_host` to add the new VM to our runtime
    inventory:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，我们获取图像的公共IP地址（注意访问此地址所需的复杂变量），确保SSH访问正常工作，然后使用`ansible.builtin.add_host`将新的VM添加到我们的运行时清单中：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Azure allows for either password- or key-based authentication for SSH on Linux
    VMs; we''re using password-based here for simplicity. Also, note the newly utilized
    `ansible_become_pass` connection variable, as the `Fedora 34` image that we are
    using will prompt for a password when `sudo` is used, potentially blocking execution.
    Finally, with this work complete, we install `ImageMagick`, like before:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Azure允许在Linux VM上使用基于密码或基于密钥的SSH身份验证；我们在这里使用基于密码的方式是为了简单起见。还要注意新使用的`ansible_become_pass`连接变量，因为我们使用的`Fedora
    34`图像在使用`sudo`时会提示输入密码，可能会阻止执行。最后，完成这项工作后，我们像以前一样安装`ImageMagick`：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With the code complete, run it with the following commands (setting your Python
    environment as necessary for your system):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 代码完成后，使用以下命令运行它（根据需要设置您系统的Python环境）：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s take a look at this in action:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何运作的：
- en: '![Figure 12.10 – Creating and configuring an Azure virtual machine using Ansible'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.10–使用Ansible创建和配置Azure虚拟机'
- en: '](Images/B17462_12_10.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_10.jpg)'
- en: Figure 12.10 – Creating and configuring an Azure virtual machine using Ansible
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10–使用Ansible创建和配置Azure虚拟机
- en: The output is very similar to our AWS example, demonstrating that we can very
    easily perform the same actions across different cloud platforms with just a little
    effort in terms of learning how the various modules that each cloud provider needs
    works. This section of the chapter is by no means definitive, given the number
    of platforms and operations supported by Ansible, but we hope that the information
    provided gives an idea of the process and steps required for getting Ansible to
    integrate with a new cloud platform. Next, we will look at using Ansible to interact
    with Docker containers.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与我们的AWS示例非常相似，表明我们可以非常轻松地跨不同的云平台执行相同的操作，只需稍微学习每个云提供商所需模块的工作原理。本章的这一部分绝不是最终的，因为Ansible支持的平台和操作数量很多，但我们希望所提供的信息能够让您了解将Ansible与新的云平台集成所需的流程和步骤。接下来，我们将看看如何使用Ansible与Docker容器交互。
- en: Interacting with Docker containers
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Docker容器交互
- en: Linux container technologies, especially Docker, have grown in popularity in
    recent years, and this has continued since the previous edition of this book was
    published. Containers provide a fast path to resource isolation while maintaining
    the consistency of the runtime environment. They can be launched quickly and are
    efficient to run, as there is very little overhead involved. Utilities such as
    Docker provide a lot of useful tooling for container management, such as a registry
    of images to use as the filesystem, tooling to build the images themselves, clustering
    orchestration, and so on. Through its ease of use, Docker has become one of the
    most popular ways to manage containers, though others, such as Podman and LXC,
    are becoming much more prevalent. For now, though, we will focus on Docker, given
    its broad appeal and wide install base.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Linux容器技术，特别是Docker，在近年来变得越来越受欢迎，自本书上一版出版以来这种趋势一直在持续。容器提供了一种快速的资源隔离路径，同时保持运行时环境的一致性。它们可以快速启动，并且运行效率高，因为几乎没有额外的开销。诸如Docker之类的实用工具为容器管理提供了许多有用的工具，例如用作文件系统的镜像注册表、构建镜像本身的工具、集群编排等。通过其易用性，Docker已成为管理容器的最流行方式之一，尽管其他工具，如Podman和LXC，也变得越来越普遍。不过，目前我们将专注于Docker，因为它具有广泛的吸引力和广泛的安装基础。
- en: Ansible can interact with Docker in numerous ways as well. Notably, Ansible
    can be used to build images, to start or stop containers, to compose multiple
    container services, to connect to and interact with active containers, and even
    to discover inventory from containers. Ansible provides a full suite of tools
    for working with Docker, including relevant modules, a connection plugin, and
    an inventory script.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible也可以以多种方式与Docker进行交互。特别是，Ansible可以用于构建镜像，启动或停止容器，组合多个容器服务，连接到并与活动容器进行交互，甚至从容器中发现清单。Ansible提供了一整套用于与Docker一起工作的工具，包括相关模块、连接插件和清单脚本。
- en: To demonstrate working with Docker, we'll explore a few use cases. The first
    use case is building a new image to use with Docker. The second use case is launching
    a container from the new image and interacting with it. The last use case is using
    the inventory plugin to interact with an active container.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用Docker，我们将探讨一些用例。第一个用例是构建一个新的镜像以供Docker使用。第二个用例是从新镜像启动一个容器并与其交互。最后一个用例是使用清单插件与活动容器进行交互。
- en: Important Note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Creating a functional Docker installation is very much dependent on your underlying
    operating system. A great resource to start with is the Docker website, which
    provides detailed installation and usage instructions, at [https://docs.docker.com](https://docs.docker.com). Ansible
    works best with Docker on a Linux host, so we will continue with the Ubuntu Server
    20.04 LTS demo machine that we have used throughout this book.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个功能齐全的Docker安装非常依赖于您的基础操作系统。一个很好的资源是Docker网站，提供了详细的安装和使用说明，网址是[https://docs.docker.com](https://docs.docker.com)。Ansible在Linux主机上与Docker配合效果最佳，因此我们将继续使用本书中一直使用的Ubuntu
    Server 20.04 LTS演示机。
- en: Building images
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建镜像
- en: Docker images are basically filesystems bundled with parameters to use at runtime.
    The filesystem is usually a small part of a Linux Userland, with enough files
    to start the desired process. Docker provides tooling to build these images, generally
    based on very small, preexisting base images. The tooling uses a Dockerfile as
    the input, which is a plain text file with directives. This file is parsed by
    the `docker build` command, and we can parse it via the `docker_image` module.
    The remaining examples will be from an Ubuntu Server 20.04 virtual machine using
    Docker CE version 20.10.8, with the `cowsay` and `nginx` packages added so that
    running the container will provide a web server that will display something from `cowsay`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像基本上是与运行时使用的参数捆绑在一起的文件系统。文件系统通常是Linux Userland的一小部分，包含足够的文件来启动所需的进程。Docker提供了构建这些镜像的工具，通常基于非常小的、预先存在的基础镜像。该工具使用Dockerfile作为输入，Dockerfile是一个带有指令的纯文本文件。该文件由docker
    build命令解析，我们可以通过docker_image模块解析它。其余的示例将来自使用Docker CE版本20.10.8的Ubuntu Server 20.04虚拟机，其中添加了cowsay和nginx包，以便运行容器将提供一个显示cowsay内容的Web服务器。
- en: 'First, we''ll need a Dockerfile. If you''ve not come across one of these before,
    they are a set of instructions used for building Docker containers – you can learn
    more about this here if you wish: [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
    This file needs to live in a path that Ansible can read, and we''re going to put
    it in the same directory as my playbooks. The Dockerfile content will be very
    simple. We''ll need to define a base image, a command to run to install the necessary
    software, some minimal configuration of software, a port to expose, and a default
    action for running a container with this image:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个Dockerfile。如果您以前没有遇到过这个文件，它是用于构建Docker容器的一组指令-如果您愿意，您可以在这里了解更多信息：[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)。这个文件需要存在于Ansible可以读取的路径中，我们将把它放在与我的playbooks相同的目录中。Dockerfile的内容将非常简单。我们需要定义一个基本镜像，一个运行安装必要软件的命令，一些最小的软件配置，一个要暴露的端口，以及一个使用此镜像运行容器的默认操作：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The build process performs the following steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程执行以下步骤：
- en: We're using the `Fedora 34` image from the `fedora` repository on the Docker
    Hub image registry.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用Docker Hub镜像注册表上的fedora存储库中的Fedora 34镜像。
- en: To install the necessary `cowsay` and `nginx` packages, we're using `dnf`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安装必要的cowsay和nginx包，我们使用dnf。
- en: To run `nginx` directly in the container, we need to turn `daemon` mode `off` in `nginx.conf`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要直接在容器中运行nginx，我们需要在nginx.conf中将daemon模式关闭。
- en: We use `cowsay` to generate content for the default web page.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用cowsay生成默认网页的内容。
- en: Then, we're instructing Docker to expose port `80` in the container, where `nginx` will
    listen for connections.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们指示Docker在容器中暴露端口80，其中nginx将监听连接。
- en: Finally, the default action of this container will be to run `nginx`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这个容器的默认操作将是运行nginx。
- en: 'The playbook to build and use the image can live in the same directory. We''ll
    name it `docker-interact.yaml`. This playbook will operate on `localhost` and
    will have two tasks; one will be to build the image using `community.docker.docker_image`,
    and the other will be to launch the container using `community.docker.docker_container`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和使用镜像的playbook可以放在同一个目录中。我们将其命名为`docker-interact.yaml`。该playbook将在`localhost`上运行，并有两个任务；一个是使用`community.docker.docker_image`构建镜像，另一个是使用`community.docker.docker_container`启动容器：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Before we run our playbook, we''ll check for any possible container images,
    or running containers that might match our preceding playbook definitions – this
    will help us to have confidence that our code is producing the desired results.
    If you have any additional containers running from previous tests, you can run
    the following commands to check for `fedora`-based containers that match our specification
    by running these commands:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行我们的playbook之前，我们将检查可能与我们之前的playbook定义匹配的任何可能的容器镜像或正在运行的容器 - 这将帮助我们确信我们的代码正在产生期望的结果。如果您有从以前的测试中运行的任何其他容器，可以运行以下命令来检查与我们的规范匹配的`fedora`-based容器：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Unless you have run this code before, you should see that no containers are
    running, as shown in *Figure 12.11*:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您之前已运行过此代码，否则应该看到没有正在运行的容器，如*图12.11*所示：
- en: '![Figure 12.11 – Checking for the absence of containers before running our
    playbook'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.11 - 在运行我们的playbook之前检查容器的缺席'
- en: '](Images/B17462_12_11.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_11.jpg)'
- en: Figure 12.11 – Checking for the absence of containers before running our playbook
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 - 在运行我们的playbook之前检查容器的缺席
- en: 'Now, let''s run the playbook to build the image and start a container using
    that image – note that, as is common with many other Ansible modules, you might
    have to install additional Python modules for your code to work. On my Ubuntu
    Server 20.04 demo machine, I had to run the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行playbook来构建镜像并使用该镜像启动容器 - 请注意，与许多其他Ansible模块一样，您可能需要安装额外的Python模块才能使您的代码正常工作。在我的Ubuntu
    Server 20.04演示机器上，我不得不运行以下命令：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With the Python support installed, you can then run the playbook with this
    command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Python支持后，您可以使用以下命令运行playbook：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A successful playbook run should look similar to *Figure 12.12*:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 成功运行playbook应该类似于*图12.12*：
- en: '![Figure 12.12 – Building and running our first Docker container using Ansible'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.12 - 使用Ansible构建和运行我们的第一个Docker容器'
- en: '](Images/B17462_12_12.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_12.jpg)'
- en: Figure 12.12 – Building and running our first Docker container using Ansible
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 - 使用Ansible构建和运行我们的第一个Docker容器
- en: 'The verbosity of this playbook execution was reduced to save screen space.
    Our output simply shows that the task to build the image resulted in a change,
    as did the task to start the container. A quick check of running containers and
    available images should reflect our work – you can use the same `docker` commands
    as we used before the playbook run to validate this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省屏幕空间，此playbook执行的冗长度已经减少。我们的输出只是显示构建镜像的任务和启动容器的任务都产生了变化。快速检查运行的容器和可用的镜像应该反映我们的工作
    - 您可以使用与playbook运行之前相同的`docker`命令来验证这一点：
- en: '![Figure 12.13 – Verifying the results of our Ansible playbook run in Docker'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.13 - 验证我们在Docker中运行的Ansible playbook的结果'
- en: '](Images/B17462_12_13.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_13.jpg)'
- en: Figure 12.13 – Verifying the results of our Ansible playbook run in Docker
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13 - 验证我们在Docker中运行的Ansible playbook的结果
- en: 'We can test the functionality of our container by using `curl` to access the
    web server, which should show us a cow saying `boop,` as demonstrated in *Figure
    12.14*:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`curl`来访问Web服务器来测试容器的功能，这应该会显示一头牛说`boop`，就像*图12.14*中演示的那样：
- en: '![Figure 12.14 – Retrieving the results of our container created and run with
    Ansible'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.14 - 检索使用Ansible创建和运行的容器的结果'
- en: '](Images/B17462_12_14.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_14.jpg)'
- en: Figure 12.14 – Retrieving the results of our container created and run with
    Ansible
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14 - 检索使用Ansible创建和运行的容器的结果
- en: In this manner, we have already shown how easy it is to interact with Docker
    using Ansible. However, this example is still based on using a native Dockerfile,
    and, as we progress through this chapter, we'll see some more advanced Ansible
    usage that removes the need for this.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经展示了使用Ansible与Docker进行交互有多么容易。但是，这个例子仍然是基于使用本地的`Dockerfile`，随着我们在本章中的进展，我们将看到一些更高级的Ansible用法，这些用法不需要`Dockerfile`。
- en: Building containers without a Dockerfile
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建不需要Dockerfile的容器
- en: 'Dockerfiles are useful, but many of the actions performed inside of Dockerfiles
    could be completed with Ansible instead. Ansible can be used to launch a container
    using a base image, then interact with that container using the `docker` connection
    method (as opposed to SSH) to complete the configuration. Let''s demonstrate this
    by repeating the previous example, but without the need for a Dockerfile. Instead,
    all of the work will be handled by an entirely new playbook named `docker-all.yaml`.
    The first part of this playbook starts a container from a preexisting image of `Fedora
    34` from Docker Hub and adds the resulting container details to Ansible''s in-memory
    inventory by using `ansible.builtin.add_host`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile很有用，但Dockerfile内部执行的许多操作都可以用Ansible来完成。Ansible可以用于使用基础镜像启动容器，然后使用`docker`连接方法（而不是SSH）与该容器进行交互以完成配置。让我们通过重复之前的示例来演示这一点，但不需要`Dockerfile`。相反，所有的工作都将由一个名为`docker-all.yaml`的全新playbook处理。该playbook的第一部分从Docker
    Hub的`Fedora 34`的预先存在的镜像中启动一个容器，并使用`ansible.builtin.add_host`将生成的容器详细信息添加到Ansible的内存库存中：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, using this newly added inventory host, we define a second play that runs
    Ansible tasks within the container that was just launched, configuring our `cowsay` service
    like before, but without the need for a Dockerfile:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用这个新添加的库存主机，我们定义了第二个播放，该播放在刚刚启动的容器中运行Ansible任务，配置我们的`cowsay`服务，就像以前一样，但不需要`Dockerfile`：
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To recap, the playbook consists of two plays. The first play creates the container
    from the base `Fedora 34` image. The `community.docker.docker_container` task
    is given a `sleep` command to keep the container running for a period of time,
    as the `docker` connection plugin only works with active containers (unconfigured
    operating system images from Docker Hub generally exit immediately when they are
    run, as they have no default actions to perform). The second task of the first
    play creates a runtime inventory entry for the container. The inventory hostname
    must match the container name. The connection method is set to `docker` as well.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，播放书包括两个播放。第一个播放从基本`Fedora 34`镜像创建容器。`community.docker.docker_container`任务被赋予一个`sleep`命令，以保持容器运行一段时间，因为`docker`连接插件只能与活动容器一起工作（从Docker
    Hub获取的未配置的操作系统镜像通常在运行时立即退出，因为它们没有默认操作要执行）。第一个播放的第二个任务创建了容器的运行时清单条目。清单主机名必须与容器名称匹配。连接方法也设置为`docker`。
- en: The second play targets the newly created host, and the first task uses the `ansible.builtin.raw` module
    to get the `python-dnf` package in place (which will bring the rest of `Python` in),
    so that we can use the `ansible.builtin.dnf` module in the next task. The `ansible.builtin.dnf`
    module is then used to install the desired packages, namely, `nginx` and `cowsay`.
    Then, the `ansible.builtin.lineinfile` module is used to add a new line to the `nginx` configuration.
    An `ansible.builtin.shell` task uses `cowsay` to create content for `nginx` to
    serve. Finally, `nginx` itself is started as a background process.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个播放目标是新创建的主机，第一个任务使用`ansible.builtin.raw`模块来放置`python-dnf`包（这将带来其余的`Python`），以便我们可以在下一个任务中使用`ansible.builtin.dnf`模块。然后，使用`ansible.builtin.dnf`模块安装所需的软件包，即`nginx`和`cowsay`。然后，使用`ansible.builtin.lineinfile`模块向`nginx`配置添加新行。一个`ansible.builtin.shell`任务使用`cowsay`来为`nginx`创建内容。最后，`nginx`本身作为后台进程启动。
- en: 'Before running the playbook, let''s remove any running containers from the
    previous example by running the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行播放书之前，让我们通过运行以下命令删除上一个示例中的任何运行的容器：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can verify this against the screenshot in *Figure 12.15*:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将其与*图12.15*中的屏幕截图进行验证：
- en: '![Figure 12.15 – Cleaning up running containers from our previous playbook
    run'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.15 - 清理上一次播放书运行中的运行容器'
- en: '](Images/B17462_12_15.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_15.jpg)'
- en: Figure 12.15 – Cleaning up running containers from our previous playbook run
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15 - 清理上一次播放书运行中的运行容器
- en: 'With the running container removed, we can now run our new playbook to recreate
    the container, bypassing the image build step, using this command:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 删除运行的容器后，我们现在可以运行我们的新播放书来重新创建容器，绕过构建镜像的步骤，使用以下命令：
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output of a successful run should look like that shown in *Figure 12.16*:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 成功运行的输出应该看起来像*图12.16*中显示的那样：
- en: '![Figure 12.16 – Building a container without a Dockerfile using Ansible'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.16 - 使用Ansible构建没有Dockerfile的容器'
- en: '](Images/B17462_12_16.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_16.jpg)'
- en: Figure 12.16 – Building a container without a Dockerfile using Ansible
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16 - 使用Ansible构建没有Dockerfile的容器
- en: 'We see tasks from the first play execute on the `localhost`, and then the second
    play executes on the `playbook-container`. Once it''s complete, we can test the
    web service and list the running containers to verify our work using these commands:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到第一个播放执行任务在`localhost`上，然后第二个播放在`playbook-container`上执行。完成后，我们可以使用以下命令测试Web服务并列出运行的容器以验证我们的工作：
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Note the different filter this time; our container was built and run directly
    from the `fedora` image, without the intermediate step of creating the `fedora-moo` image
    – the output should look like that shown in *Figure 12.17*:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这次不同的过滤器；我们的容器是直接从`fedora`镜像构建和运行的，而没有创建`fedora-moo`镜像的中间步骤 - 输出应该看起来像*图12.17*中显示的那样：
- en: '![Figure 12.17 – Verifying the results of our playbook run'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.17 - 验证我们的播放书运行结果'
- en: '](Images/B17462_12_17.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_17.jpg)'
- en: Figure 12.17 – Verifying the results of our playbook run
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17 - 验证我们的播放书运行结果
- en: This method of using Ansible to configure the running container has some advantages.
    First, you can reuse existing roles to set up an application, easily switching
    from cloud virtual machine targets to containers, and even to bare-metal resources,
    if desired. Secondly, you can easily review all configuration that goes into an
    application, simply by reviewing the playbook content.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ansible配置运行容器的这种方法有一些优势。首先，您可以重用现有角色来设置应用程序，轻松地从云虚拟机目标切换到容器，甚至切换到裸金属资源（如果需要的话）。其次，您可以通过审查播放书内容轻松地审查所有配置进入应用程序的内容。
- en: Another use case for this method of interaction is to use Docker containers
    to simulate multiple hosts, in order to verify playbook execution across multiple
    hosts. A container can be started with an `init` system as the running process,
    allowing for additional services to be started as if they were on a full operating
    system. This use case is valuable within a continuous integration environment,
    to validate changes to playbook content quickly and efficiently.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '使用这种交互方法的另一个用例是使用Docker容器模拟多个主机，以验证跨多个主机执行播放书的执行。可以启动一个带有`init`系统作为运行进程的容器，允许启动其他服务，就像它们在完整的操作系统上一样。在持续集成环境中，这种用例对于快速有效地验证播放书内容的更改非常有价值。 '
- en: Docker inventory
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker清单
- en: Similar to the OpenStack and EC2 inventory plugins detailed earlier in this
    book, a Docker inventory plugin is also available. You can locate the Docker inventory
    script if you wish to examine it or use it in a similar manner to the way in which
    we have used other dynamic inventory plugins earlier in this chapter by creating
    a YAML inventory file to reference the plugin.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书前面详细介绍的OpenStack和EC2清单插件类似，还提供了Docker清单插件。如果您希望检查Docker清单脚本或以类似于我们在本章前面使用其他动态清单插件的方式使用它，可以找到Docker清单脚本，通过创建一个YAML清单文件来引用该插件。
- en: 'Let''s start by locating the inventory script itself – on my demo system, it
    is located here:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先找到清单脚本本身 - 在我的演示系统上，它位于这里：
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once you get used to the installation base path of Ansible, you will note that
    it is quite easy to navigate the directory structure through the collections to
    find what you are looking for. Let''s try running this script directly to see
    the options available to us when configuring it for playbook inventory purposes:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你习惯了Ansible的安装基本路径，你会发现通过集合轻松浏览目录结构，找到你要找的东西。让我们尝试直接运行这个脚本，看看在配置它用于playbook清单目的时我们有哪些选项可用：
- en: '[PRE44]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `help` output for the script shows many possible arguments; however, the
    ones that Ansible will use are `--list` and `--host` – your output will look similar
    to that shown in *Figure 12.18*:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的`help`输出显示了许多可能的参数；然而，Ansible将使用的是`--list`和`--host` - 您的输出将类似于*图12.18*所示：
- en: '![Figure 12.18 – Examining the options available on the Docker dynamic inventory
    script'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.18 - 检查Docker动态清单脚本上可用的选项'
- en: '](Images/B17462_12_18.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_18.jpg)'
- en: Figure 12.18 – Examining the options available on the Docker dynamic inventory
    script
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18 - 检查Docker动态清单脚本上可用的选项
- en: 'If the previously built container is still running when this script is executed,
    you can list hosts using the following command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前构建的容器在执行此脚本时仍在运行，您可以使用以下命令列出主机：
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It should appear in the output (`grep` has been used to make this more obvious
    in the screenshot):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该出现在输出中（`grep`已经被用来在截图中更明显地显示这一点）：
- en: '![Figure 12.19 – Running the Docker dynamic inventory plugin manually to explore
    its behavior'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.19 - 手动运行Docker动态清单插件以探索其行为'
- en: '](Images/B17462_12_19.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_19.jpg)'
- en: Figure 12.19 – Running the Docker dynamic inventory plugin manually to explore
    its behavior
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19 - 手动运行Docker动态清单插件以探索其行为
- en: 'Like earlier, a number of groups are presented, which have the running container
    as a member. The two groups that were shown earlier are the short container ID
    and the long container ID. Many variables are also defined as a part of the output,
    which has been heavily truncated in the preceding screenshot. The tail end of
    the output reveals a few more groups:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，提供了许多组，这些组的成员是正在运行的容器。之前显示的两个组是短容器ID和长容器ID。许多变量也作为输出的一部分进行了定义，在前面的截图中已经被大幅缩减。输出的最后一部分显示了另外一些组：
- en: '![Figure 12.20 – Further exploring the output of the dynamic inventory script
    output'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.20 - 进一步探索动态清单脚本输出'
- en: '](Images/B17462_12_20.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_20.jpg)'
- en: Figure 12.20 – Further exploring the output of the dynamic inventory script
    output
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20 - 进一步探索动态清单脚本输出
- en: 'The additional groups are as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 附加的组如下：
- en: '`docker_hosts`: All of the hosts running the Docker daemon that the dynamic
    inventory script has communicated with and queried for containers.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker_hosts`：所有与动态清单脚本通信并查询容器的Docker守护程序运行的主机。'
- en: '`image_name`: A group for each image used by discovered containers.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image_name`：每个被发现容器使用的图像的组。'
- en: '`container name`: A group that matches the name of the container'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container name`：与容器名称匹配的组'
- en: '`running`: A group of all the running containers.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`running`：所有正在运行的容器的组。'
- en: '`stopped`: A group of all the stopped containers – you can see in the preceding
    output that our container started previously has now stopped, as the 500-second
    sleep period has expired.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stopped`：所有已停止的容器的组 - 您可以在前面的输出中看到，我们之前启动的容器现在已经停止，因为500秒的休眠时间已经过期。'
- en: 'This inventory plugin, and the groups and data provided by it, can be used
    by playbooks to target various selections of containers available, in order to
    interact without the need for manual inventory management or the use of `add_host`.
    Using the plugin in a playbook is a simple matter of defining a YAML inventory
    file with the plugin name and connection details – to query the local Docker host,
    we could define our inventory as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此清单插件及其提供的组和数据可以被playbook用来针对可用的各种容器进行交互，而无需手动清单管理或使用`add_host`。在playbook中使用插件只需简单地定义一个YAML清单文件，其中包含插件名称和连接详细信息
    - 要查询本地Docker主机，我们可以定义我们的清单如下：
- en: '[PRE46]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can run ad hoc commands or playbooks with Ansible against this inventory
    definition in the normal manner and get details of all of the containers running
    on the local host. Connecting to remote hosts is not significantly more difficult,
    and the plugin documentation (available here: [https://docs.ansible.com/ansible/latest/collections/community/docker/docker_containers_inventory.html](https://docs.ansible.com/ansible/latest/collections/community/docker/docker_containers_inventory.html))
    shows you the options available to you for this. We''ve now looked at several
    methods for building and interacting with Docker containers, but what if we wanted
    a more joined-up approach? We''ll look at exactly this in the next section.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以正常方式对此清单定义使用Ansible运行临时命令或playbook，并获取本地主机上运行的所有容器的详细信息。连接到远程主机并不会更加困难，插件文档（可在此处找到：[https://docs.ansible.com/ansible/latest/collections/community/docker/docker_containers_inventory.html](https://docs.ansible.com/ansible/latest/collections/community/docker/docker_containers_inventory.html)）向您展示了可用于此的选项。我们现在已经看过了几种构建和与Docker容器交互的方法，但如果我们想要一个更加协调的方法呢？我们将在下一节中详细讨论这个问题。
- en: Building containers with Ansible
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible构建容器
- en: As we mentioned at the beginning of the previous section, the world of containers
    has moved on greatly since the previous edition of this book was published. Although
    Docker is still a massively popular container technology, new and improved technologies
    have become favored, and indeed natively integrated into Linux operating systems.
    Canonical (the publisher of Ubuntu) is championing the **LXC** container environment,
    while Red Hat (the owner of Ansible) is championing **Buildah** and **Podman**.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节开头提到的，自本书上一版出版以来，容器的世界已经取得了很大的进步。尽管Docker仍然是一种非常流行的容器技术，但新的和改进的技术已经成为首选，并且被纳入到Linux操作系统中。Canonical（Ubuntu的发布者）正在支持**LXC**容器环境，而Red
    Hat（Ansible的所有者）正在支持**Buildah**和**Podman**。
- en: If you read the third edition of this book, you will know that we covered a
    technology called **Ansible Container**, which was used to directly integrate
    Ansible with Docker and remove the need for *glue* steps such as adding hosts
    to the in-memory inventory, having two separate plays for instantiating the container,
    and building the container image contents. Ansible Container has now been deprecated,
    and all development work has ceased (according to their GitHub page – see [https://github.com/ansible/ansible-container](https://github.com/ansible/ansible-container)
    if you are interested).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你读过本书的第三版，你会知道我们介绍了一个名为**Ansible Container**的技术，它用于直接集成Ansible和Docker，消除了*glue*步骤，比如将主机添加到内存中的清单，有两个单独的play来实例化容器，以及构建容器镜像内容。Ansible
    Container现在已经被弃用，所有的开发工作都已经停止（根据他们的GitHub页面 - 如果你感兴趣，可以查看[https://github.com/ansible/ansible-container](https://github.com/ansible/ansible-container)）。
- en: Ansible Container has been succeeded by a new tool called **ansible-bender**,
    which features a pluggable architecture for different container build environments.
    At this early stage in its development, it only supports **Buildah**, but hopefully,
    further container technologies will be supported in the near future.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Container已被一个名为**ansible-bender**的新工具取代，它具有不同容器构建环境的可插拔架构。在开发的早期阶段，它只支持**Buildah**，但希望将来会支持更多的容器技术。
- en: The Podman/Buildah toolsets are available on newer releases of Red Hat Enterprise
    Linux, CentOS, Fedora, and Ubuntu Server (but not 20.04, unless you go for a more
    bleeding edge version). As we have used Ubuntu Server for our demo machine throughout
    this book, we will stick to this operating system, but for this section of the
    chapter, we will switch to version 20.10 which, whilst not an LTS release, does
    have a native release of Buildah and Podman available.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Podman/Buildah工具集可在较新版本的Red Hat Enterprise Linux、CentOS、Fedora和Ubuntu Server上使用（但不包括20.04，除非你选择更先进的版本）。由于我们在本书中一直使用Ubuntu
    Server作为演示机器，我们将继续使用这个操作系统，但在本章的这一部分，我们将切换到20.10版本，虽然不是LTS版本，但有Buildah和Podman的本地版本可用。
- en: 'To install Buildah and Podman on Ubuntu Server 20.10 (and newer), simply run
    the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Ubuntu Server 20.10（以及更新版本）上安装Buildah和Podman，只需运行以下命令：
- en: '[PRE47]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once you have your container environment installed (don''t forget to install
    Ansible if you haven''t already – `ansible-bender` needs this to run!), you can
    install `ansible-bender` using the following command:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了容器环境（如果你还没有安装Ansible，请不要忘记安装 - `ansible-bender`需要它来运行！），你可以使用以下命令安装`ansible-bender`：
- en: '[PRE48]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That's it – now you're all ready to go! It is worth noting before we dive into
    our example code that `ansible-bender` is a lot simpler in its functionality than
    Ansible Container was. While Ansible Container could manage the entire lifecycle
    of a container, `ansible-bender` is only concerned with the build phase of containers
    – nonetheless, it provides a useful abstraction layer for easily building your
    container images using Ansible, and once it supports other containerization build
    platforms (such as LXC and/or Docker), it will become an incredibly valuable tool
    in your automation arsenal, as you will be able to build container images on a
    variety of platforms using almost identical playbook code.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样 - 现在你已经准备好了！在我们深入示例代码之前，值得注意的是`ansible-bender`在功能上比Ansible Container简单得多。虽然Ansible
    Container可以管理容器的整个生命周期，但`ansible-bender`只关注容器的构建阶段 - 尽管如此，它提供了一个有用的抽象层，可以使用Ansible轻松构建容器镜像，一旦它支持其他容器化构建平台（如LXC和/或Docker），它将成为你自动化工具中非常有价值的工具，因为你将能够使用几乎相同的playbook代码在各种平台上构建容器镜像。
- en: 'Let''s build our first playbook for `ansible-bender`. The header of the play
    will look, by now, familiar – with one important exception. Notice the `vars:`
    section in the play definition – this section contains important reserved variables
    for use by `ansible-bender` and defines items such as the source container image
    (we''ll use `Fedora 34` once again), and the destination container image details,
    including the command to run when the container starts:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`ansible-bender`构建我们的第一个playbook。play的头部现在看起来应该很熟悉 - 有一个重要的例外。注意play定义中的`vars:`部分
    - 这部分包含了`ansible-bender`使用的重要保留变量，并定义了诸如源容器镜像（我们将再次使用`Fedora 34`）和目标容器镜像详细信息，包括容器启动时要运行的命令：
- en: '[PRE49]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With this defined, we write our play tasks in exactly the same way as we did
    before. Notice that we don''t need to worry about inventory definition (either
    through a dynamic inventory provider or via `ansible.builtin.add_host`) – `ansible-bender`
    runs all our tasks on the container image it instantiates using the details from
    the `ansible_bender` variable structure. Thus, our code should look like this
    – it is identical to the second play we used before, only we''re not running the
    final `ansible.builtin.shell` task to start the `nginx` web server, as this is
    taken care of by details in the `ansible_bender` variable:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个定义，我们编写我们的play任务的方式与之前完全相同。请注意，我们不需要担心清单定义（无论是通过动态清单提供程序还是通过`ansible.builtin.add_host`）
    - `ansible-bender`会在实例化容器镜像时使用`ansible_bender`变量结构中的详细信息运行所有任务。因此，我们的代码应该是这样的
    - 它与我们之前使用的第二个play完全相同，只是我们不运行最后的`ansible.builtin.shell`任务来启动`nginx` web服务器，因为这是由`ansible_bender`变量中的详细信息处理的。
- en: '[PRE50]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'That''s it – the code is no more complex than that! Now, building your first
    container with `ansible-bender` is as simple as running the following command:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样 - 代码没有比这更复杂的了！现在，使用`ansible-bender`构建你的第一个容器就像运行以下命令一样简单：
- en: '[PRE51]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that the command must be run as root (that is, via `sudo`) – this is a
    specific related to Buildah and Podman and their behavior when run as an unprivileged
    user.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，命令必须以root身份运行（即通过`sudo`） - 这是与Buildah和Podman相关的特定行为。
- en: 'One oddity of `ansible-bender` is that when it starts to run, you will see
    some lines that state `ERROR` (see *Figure 12.21*). This is a bug in `ansible-bender`
    as these lines are not actually errors – they are simply information being returned
    from the Buildah tool:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible-bender`的一个奇怪之处是，当它开始运行时，您会看到一些声明`ERROR`的行（见*图12.21*）。这是`ansible-bender`中的一个错误，因为这些行实际上并不是错误
    - 它们只是从Buildah工具返回的信息：'
- en: '![Figure 12.21 – Starting the container build process with ansible-bender,
    and the false ERROR messages'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.21 - 使用ansible-bender开始容器构建过程，以及虚假的ERROR消息'
- en: '](Images/B17462_12_21.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_21.jpg)'
- en: Figure 12.21 – Starting the container build process with ansible-bender, and
    the false ERROR messages
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21 - 使用ansible-bender开始容器构建过程，以及虚假的ERROR消息
- en: 'As the build continues, you should see Ansible playbook messages return in
    the manner with which you are now familiar. At the end of the process, you should
    have a successful build indicated by output like that shown in *Figure 12.22*:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 随着构建的继续，您应该看到Ansible playbook消息以您熟悉的方式返回。在过程结束时，您应该看到类似于*图12.22*所示的成功构建的输出：
- en: '![Figure 12.22 – A successful container build with ansible-bender'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.22 - 使用ansible-bender成功构建容器'
- en: '](Images/B17462_12_22.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_22.jpg)'
- en: Figure 12.22 – A successful container build with ansible-bender
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22 - 使用ansible-bender成功构建容器
- en: 'From here, you can run your newly built container with this command:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，您可以使用以下命令运行您新构建的容器：
- en: '[PRE52]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `fedora-moo` container name was set in the `ansible_bender` variable structure
    in the playbook file previously, whilst the `-d` flag is used to detach from the
    container and run it in the background. Similar to Docker, you can query the running
    containers on your system with this command:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`fedora-moo`容器名称是在之前的playbook文件中的`ansible_bender`变量结构中设置的，而`-d`标志用于从容器中分离并在后台运行。与Docker类似，您可以使用以下命令查询系统上正在运行的容器：'
- en: '[PRE53]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output from this process will look somewhat like that shown in *Figure
    12.23*:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的输出看起来有点像*图12.23*所示：
- en: '![Figure 12.23 – Running and querying our newly built container in Podman'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.23 - 运行和查询我们新构建的Podman容器'
- en: '](Images/B17462_12_23.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_23.jpg)'
- en: Figure 12.23 – Running and querying our newly built container in Podman
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.23 - 运行和查询我们新构建的Podman容器
- en: 'Finally, let''s see if we can actually retrieve our `cowsay` web page from
    our container. Unlike our Docker example, we have not instructed Podman to redirect
    the web server port to a port on our build machine, so we will need to query the
    IP address of the container itself. Having obtained the `CONTAINER ID` or `NAMES`
    from the output of `sudo podman ps`, we can query this with a command such as
    this (be sure to replace the container ID with the one from your system):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看我们是否可以从容器中实际检索到我们的`cowsay`网页。与我们的Docker示例不同，我们没有指示Podman将Web服务器端口重定向到构建机器上的端口，因此我们需要查询容器本身的IP地址。在获得`sudo
    podman ps`输出中的`CONTAINER ID`或`NAMES`后，我们可以使用以下命令查询这个（确保用您系统中的ID替换容器ID）：
- en: '[PRE54]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As with Docker, you can abbreviate your container ID provided the characters
    you enter are unique in the list of running containers. Once you have retrieved
    the IP address, you can use `curl` to download the web page, just as we did before
    – for example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 与Docker一样，只要您输入的字符在正在运行的容器列表中是唯一的，您就可以缩写您的容器ID。一旦获得了IP地址，您就可以使用`curl`下载网页，就像我们之前做的那样
    - 例如：
- en: '[PRE55]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This whole process should look like that shown in *Figure 12.24*:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程应该看起来像*图12.24*所示：
- en: '![Figure 12.24 – Downloading our cowsay web page from our Podman container
    build with ansible-bender'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.24 - 从使用ansible-bender构建的Podman容器中下载我们的cowsay网页'
- en: '](Images/B17462_12_24.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_12_24.jpg)'
- en: Figure 12.24 – Downloading our cowsay web page from our Podman container build
    with ansible-bender
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24 - 从使用ansible-bender构建的Podman容器中下载我们的cowsay网页
- en: That's all there is to it! The `ansible-bender` tool shows great promise in
    providing an automation framework for building container images with one common
    language – our own favorite, Ansible! As the tool develops, hopefully, some of
    the rough edges (such as the false `ERROR` statements) will be resolved, and the
    addition of support for more container platforms will truly make this a valuable
    automation tool for container images. That concludes our look at infrastructure
    provisioning with Ansible – hopefully, you have found it valuable.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样了！`ansible-bender`工具在使用一种通用语言 - 我们自己喜欢的Ansible来构建容器映像方面显示出了巨大的潜力！随着工具的发展，希望一些粗糙的地方（比如虚假的`ERROR`语句）将得到解决，并且对更多容器平台的支持的添加将真正使其成为一个有价值的容器映像自动化工具。这就结束了我们对使用Ansible进行基础架构提供的介绍
    - 希望您觉得有价值。
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: DevOps has pushed automation in many new directions, including the containerization
    of applications, and even the creation of infrastructure itself. Cloud computing
    services enable self-service management of fleets of servers for running services.
    Ansible can easily interact with these services to provide the automation and
    orchestration engine.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps已经推动了许多新方向的自动化，包括应用程序的容器化，甚至基础架构本身的创建。云计算服务使得可以自助管理用于运行服务的服务器群。Ansible可以轻松地与这些服务进行交互，提供自动化和编排引擎。
- en: In this chapter, you learned how to manage on-premises cloud infrastructures,
    such as OpenStack, using Ansible. We then extended this with examples of public
    cloud infrastructure provision on both AWS and Microsoft Azure. Finally, you learned
    how to interact with Docker using Ansible, and how to neatly package Docker service
    definitions using Ansible Container.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用Ansible管理本地云基础架构，例如OpenStack。然后，我们通过AWS和Microsoft Azure的公共云基础架构提供示例进行了扩展。最后，您学习了如何使用Ansible与Docker进行交互，以及如何使用Ansible
    Container整洁地打包Docker服务定义。
- en: Ansible can start just about any host, except for the one that it is running
    on, and with proper credentials, it can create the infrastructure that it wants
    to manage, either for one-off actions or to deploy a new version of an application
    into a production container management system. The end result is that once your
    hardware is in place and your service providers are configured, you can manage
    your entire infrastructure through Ansible, if you so desire!
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible可以启动几乎任何主机，除了正在运行的主机之外，并且在具有适当凭据的情况下，它可以创建它想要管理的基础架构，无论是一次性操作还是将应用程序的新版本部署到生产容器管理系统中。
    最终结果是，一旦硬件就位并且服务提供商已配置，如果您愿意，您可以通过Ansible管理整个基础架构！
- en: 'In the final chapter of this book, we will look at a new and rapidly growing
    area of automation: network provisioning with Ansible.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章中，我们将研究自动化的一个新且迅速增长的领域：使用Ansible进行网络配置。
- en: Questions
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: When creating or deleting VM instances on OpenStack, which inventory host should
    you reference in your play?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenStack上创建或删除VM实例时，在您的播放中应该引用哪个清单主机？
- en: a) The OpenStack host
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: a) OpenStack主机
- en: b) localhost
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: b) 本地主机
- en: c) The VM Floating IP address
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: c) VM浮动IP地址
- en: d) None of the above
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: d) 以上都不是
- en: How would you reference a newly created virtual machine in a second play without
    having to use a dynamic inventory script?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在第二个播放中引用新创建的虚拟机，而无需使用动态清单脚本？
- en: a) Use `ansible.builtin.raw` commands.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: a) 使用`ansible.builtin.raw`命令。
- en: b) Use `ansible.builtin.shell` commands.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: b) 使用`ansible.builtin.shell`命令。
- en: c) Use `ansible.builtin.add_host` to add the new VM to the in-memory inventory.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: c) 使用`ansible.builtin.add_host`将新的VM添加到内存清单中。
- en: d) You need to use the dynamic inventory plugin.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: d) 您需要使用动态清单插件。
- en: You can still run dynamic inventory scripts directly in Ansible 4.x and newer,
    just as you could in Ansible 2.x releases.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您仍然可以直接在Ansible 4.x及更高版本中运行动态清单脚本，就像在Ansible 2.x版本中一样。
- en: a) True
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: a) 正确
- en: b) False
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: b) 错误
- en: 'To use a dynamic inventory script, and set its parameters, you would now (assuming
    the collection is already installed):'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用动态清单脚本，并设置其参数，您现在可以（假设集合已安装）：
- en: a) Define a YAML inventory file with the plugin name and parameters.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: a) 使用插件名称和参数定义YAML清单文件。
- en: b) Reference the dynamic inventory script in the `-i` parameter of `ansible`/`ansible-playbook`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: b) 在`ansible`/`ansible-playbook`的`-i`参数中引用动态清单脚本。
- en: c) Put the plugin name in your play definition itself.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: c) 将插件名称放在播放定义中。
- en: 'When using a new module from a collection for the first time (for example,
    with a cloud provider), you should:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一次使用集合中的新模块（例如，与云提供商一起），您应该：
- en: a) Always read the documentation to check for known issues.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: a) 始终阅读文档，检查已知问题。
- en: b) Always read the documentation to see if you need to install additional Python
    modules.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: b) 始终阅读文档，查看是否需要安装其他Python模块。
- en: c) Always read the documentation see how you should define your authentication
    parameters.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: c) 始终阅读文档，查看应如何定义您的身份验证参数。
- en: d) All of the above.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: d) 以上所有
- en: Ansible cannot function on a target host if there is no Python environment (this
    is sometimes the case on minimal cloud operating system images). If this is the
    case, you can still install Python from a playbook task with which module?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果目标主机上没有Python环境，Ansible无法运行（这在最小的云操作系统映像上有时是这样）。 如果是这种情况，您仍然可以使用哪个模块从playbook任务中安装Python？
- en: a) `ansible.builtin.python`
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: a) `ansible.builtin.python`
- en: b) `ansible.builtin.raw`
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: b) `ansible.builtin.raw`
- en: c) `ansible.builtin.command`
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: c) `ansible.builtin.command`
- en: d) `ansible.builtin.shell`
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: d) `ansible.builtin.shell`
- en: All cloud provider modules will wait for a VM instance to come up before the
    play is allowed to move on to the next task.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有云提供商模块都将等待VM实例启动，然后才允许播放继续执行下一个任务。
- en: a) True
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: a) 正确
- en: b) False
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: b) 错误
- en: If you want to wait to ensure a host is accessible over SSH before you perform
    additional tasks, you can use which module?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要等待确保主机在执行其他任务之前可以通过SSH访问，可以使用哪个模块？
- en: a) `ansible.builtin.wait_for`
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: a) `ansible.builtin.wait_for`
- en: b) `ansible.builtin.ssh`
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: b) `ansible.builtin.ssh`
- en: c) `ansible.builtin.test_connection`
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: c) `ansible.builtin.test_connection`
- en: d) `ansible.builtin.connect`
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: d) `ansible.builtin.connect`
- en: Ansible can build Docker containers both with and without a Dockerfile.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible可以使用Dockerfile构建Docker容器，也可以不使用Dockerfile。
- en: a) True
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: a) 正确
- en: b) False
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: b) 错误
- en: The `ansible-bender` tool currently supports which build environment?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible-bender`工具目前支持哪种构建环境？'
- en: a) Docker
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: a) Docker
- en: b) LXC
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: b) LXC
- en: c) Podman/Buildah
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: c) Podman/Buildah
- en: d) All of the above
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: d) 以上所有
