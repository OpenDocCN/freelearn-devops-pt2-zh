- en: Defining Your Inventory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义您的清单
- en: As we have already discussed in the first two chapters, Ansible cannot do anything
    until you tell it what hosts it is responsible for. This is, of course, logical—you
    wouldn't want any automation tool, regardless of how easy it is to use and set
    up, to simply go out and take control of every single device on your network.
    Hence, at the bare minimum, you must tell Ansible what hosts it is going to automate
    tasks on, and this, in the most fundamental terms, is what an inventory is.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前两章中已经讨论过的，除非告诉它负责哪些主机，否则Ansible无法做任何事情。这当然是合乎逻辑的——无论自动化工具有多容易使用和设置，你都不希望它简单地控制网络上的每个设备。因此，至少，您必须告诉Ansible它将自动化任务的主机是哪些，这在最基本的术语中就是清单。
- en: However, there is so much more to inventories than just a list of automation
    targets. Ansible inventories can be provided in several formats; they can be either
    static or dynamic, and they can contain important variables that define how Ansible
    interacts with each host (or groups of hosts). Hence, they deserve a chapter to
    themselves, and in this chapter, we shall perform a practical exploration of inventories
    and how to use them to your best advantage as you automate your infrastructure
    with Ansible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，清单中有很多东西不仅仅是自动化目标的列表。Ansible清单可以以几种格式提供；它们可以是静态的或动态的，并且它们可以包含定义Ansible与每个主机（或主机组）交互的重要变量。因此，它们值得有一个章节来讨论，而在本章中，我们将对清单进行实际探索，以及如何在使用Ansible自动化基础设施时充分利用它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating an inventory file and adding hosts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建清单文件并添加主机
- en: Generating a dynamic inventory file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成动态清单文件
- en: Special host management using patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模式进行特殊主机管理
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [Chapter 1](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml), *Getting
    Started with Ansible*, and you are using the most recent version available—the
    examples in this chapter were tested with Ansible 2.9\. This chapter also assumes
    that you have at least one additional host to test against, and ideally this should
    be Linux-based. Although we will give specific examples of hostnames in this chapter,
    you are free to substitute them with your own hostname and/or IP addresses, and
    details of how to do this will be provided in the appropriate places.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经按照[第1章](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml) *开始使用Ansible*中详细说明的设置了控制主机，并且您正在使用最新版本——本章的示例是使用Ansible
    2.9进行测试的。本章还假设您至少有一个额外的主机进行测试，并且最好是基于Linux的。尽管本章将给出主机名的具体示例，但您可以自由地用自己的主机名和/或IP地址替换它们，如何做到这一点的详细信息将在适当的地方提供。
- en: The code bundle for this chapter is available here: [https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%203](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%203).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包在此处可用：[https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%203](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%203)。
- en: Creating an inventory file and adding hosts
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建清单文件并添加主机
- en: Whenever you see a reference to "creating an inventory" in Ansible, you are
    normally quite safe to assume that it is a static inventory. Ansible supports
    two types of inventory—static and dynamic, and we will cover the latter of these
    two later in this chapter. Static inventories are by their very nature static;
    they are unchanging unless a human being goes and manually edits them. This is
    great when you are starting out and testing Ansible, as it provides you with a
    very quick and easy way to get up and running quickly. Even in small, closed environments,
    static inventories are a great way to manage your environment, especially when
    changes to the infrastructure are infrequent.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您在Ansible中看到“创建清单”的参考时，通常可以安全地假定它是一个静态清单。Ansible支持两种类型的清单——静态和动态，我们将在本章后面讨论后者。静态清单本质上是静态的；除非有人去手动编辑它们，否则它们是不会改变的。当您开始测试Ansible时，这是一个很好的选择，因为它为您提供了一个非常快速和简单的方法来快速启动和运行。即使在小型封闭环境中，静态清单也是管理环境的好方法，特别是在基础设施的更改不频繁时。
- en: 'Most Ansible installations will look for a default inventory file in `/etc/ansible/hosts`
    (though this path is configurable in the Ansible configuration file, as discussed
    in [Chapter 2](da04dfe7-d42f-41dd-93a2-c1db97a7fbb1.xhtml), *Understanding the
    Fundamentals of Ansible*). You are welcome to populate this file or to provide
    your own inventory for each playbook run, and it is commonplace to see inventories
    provided alongside playbooks. After all, there''s rarely a "one size fits all"
    playbook, and although you can subdivide your inventory with groups (more on this
    later), it can often be just as easy to provide a smaller static inventory file
    alongside a given playbook. As you will have seen in the earlier chapters of this
    book, most Ansible commands use the `-i` flag to specify the location of the inventory
    file if not using the default. Hypothetically, this might look like the following
    example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Ansible安装将在`/etc/ansible/hosts`中寻找默认的清单文件（尽管这个路径在Ansible配置文件中是可配置的，如[第2章](da04dfe7-d42f-41dd-93a2-c1db97a7fbb1.xhtml)
    *理解Ansible的基础知识*中所讨论的）。您可以填充此文件，或为每个playbook运行提供自己的清单，通常可以看到清单与playbooks一起提供。毕竟，很少有“一刀切”的playbook，尽管您可以使用组来细分您的清单（稍后会详细介绍），但通常提供一个较小的静态清单文件与特定的playbook一起提供也同样容易。正如您在本书的前几章中所看到的，大多数Ansible命令在不使用默认值时使用`-i`标志来指定清单文件的位置。假设情况下，这可能看起来像以下示例：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Most static inventory files you will come across are created in INI format,
    though it is important to note that other formats are possible. The most common
    format you will find after INI-formatted files are YAML ones—more details of the
    types of inventory files you can work with may be found here: [https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html](https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会遇到的大多数静态清单文件都是以INI格式创建的，尽管重要的是要注意其他格式也是可能的。在INI格式的文件之后，您将发现的最常见格式是YAML格式
    - 您可以在这里找到更多关于您可以使用的清单文件类型的详细信息：[https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html](https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html)。
- en: In this chapter, we will provide some examples of both INI and YAML formatted
    inventory files for you to consider, as you must have an awareness of both. Personally,
    I have worked with Ansible for many years and worked with either INI-formatted
    files or dynamic inventories, but they say knowledge is power and so it will do
    no harm to learn a little about both formats.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为您提供一些INI和YAML格式的清单文件示例，供您考虑，因为您必须对两者都有所了解。就我个人而言，我已经使用Ansible工作了很多年，使用过INI格式的文件或动态清单，但他们说知识就是力量，所以了解一下这两种格式也无妨。
- en: Let's start by creating a static inventory file. This inventory file will be
    separate from the default inventory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个静态清单文件开始。这个清单文件将与默认清单分开。
- en: 'Create an inventory file in `/etc/ansible/my_inventory` using the following
    INI-formatted code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/etc/ansible/my_inventory`中创建一个清单文件，使用以下格式化的INI代码：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The blank lines between inventory hosts are not required—they have been inserted
    simply to make the inventory more readable in this book. This inventory file is
    very simple and does not include any grouping; however, when referencing the inventory,
    you can still refer to all the hosts together using the special `all` group, which
    is implicitly defined regardless of how you format and divide your inventory file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 清单主机之间的空行不是必需的 - 它们只是为了使本书中的清单更易读而插入的。这个清单文件非常简单，不包括任何分组；但是，在引用清单时，您仍然可以使用特殊的`all`组来引用所有主机，这个组是隐式定义的，无论您如何格式化和划分您的清单文件。
- en: Each line in the preceding file contains one inventory host. The first column
    contains the inventory hostname that Ansible will use (and can be accessed through
    the `inventory_hostname` magic variable we discussed in [Chapter 2](da04dfe7-d42f-41dd-93a2-c1db97a7fbb1.xhtml),
    *Understanding the Fundamentals of Ansible*). All parameters on the same line
    after that are variables that are assigned to the host. These can be user-defined
    variables or special Ansible variables as we have set here.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件中的每一行都包含一个清单主机。第一列包含Ansible将使用的清单主机名（并且可以通过我们在[第2章](da04dfe7-d42f-41dd-93a2-c1db97a7fbb1.xhtml)中讨论的`inventory_hostname`魔术变量来访问）。之后同一行上的所有参数都是分配给主机的变量。这些可以是用户定义的变量或特殊的Ansible变量，就像我们在这里设置的一样。
- en: 'There are many such variables, but the preceding examples specifically include
    the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多这样的变量，但前面的例子特别包括以下内容：
- en: '`ansible_host`: If the inventory hostname cannot be accessed directly—perhaps
    because it is not in DNS, for example, this variable contains the hostname or
    IP address that Ansible will connect to instead.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_host`：如果无法直接访问清单主机名 - 例如，因为它不在DNS中，那么这个变量包含Ansible将连接的主机名或IP地址。'
- en: '`ansible_port`: By default, Ansible attempts all communication over port 22
    for SSH—if you have an SSH daemon running on another port, you can tell Ansible
    about it using this variable.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_port`：默认情况下，Ansible尝试通过SSH的22端口进行所有通信 - 如果您在另一个端口上运行SSH守护程序，可以使用此变量告诉Ansible。'
- en: '`ansible_user`: By default, Ansible will attempt to connect to the remote host
    using the current user account you are running the Ansible command from—you can
    override this in several ways, of which this is one.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_user`：默认情况下，Ansible将尝试使用您从中运行Ansible命令的当前用户帐户连接到远程主机 - 您可以以多种方式覆盖这一点，其中之一就是这个。'
- en: 'Hence, the preceding three hosts can be summarized as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的三个主机可以总结如下：
- en: The `target1.example.com` host should be connected to using the `192.168.81.142` IP
    address, on port `3333`.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target1.example.com`主机应该使用`192.168.81.142`IP地址连接，端口为`3333`。'
- en: The `target2.example.com` host should be connected to on port `3333` also, but
    this time using the `danieloh` user rather than the account running the Ansible
    command.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target2.example.com`主机也应该连接到端口`3333`，但这次使用`danieloh`用户，而不是运行Ansible命令的帐户。'
- en: The `target3.example.com` host should be connected to using the `192.168.81.143` IP
    address, on port `5555`.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target3.example.com`主机应该使用`192.168.81.143`IP地址连接，端口为`5555`。'
- en: In this way, even with no further constructs, you can begin to see the power
    of static INI-formatted inventories.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，即使没有进一步的构造，您也可以开始看到静态的INI格式的清单的强大之处。
- en: 'Now, if you wanted to create exactly the same inventory as the preceding, but
    this time, format it as YAML, you would specify it as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您想要创建与前面完全相同的清单，但这次以YAML格式进行格式化，您可以指定如下：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You may come across inventory file examples containing parameters such as `ansible_ssh_port`,
    `ansible_ssh_host`, and `ansible_ssh_user`–these variable names (and others like
    them) were used in Ansible versions before 2.0\. Backward compatibility has been
    maintained for many of these, but you should update them where possible as this
    compatibility may be removed at some point in the future.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会遇到包含参数如`ansible_ssh_port`、`ansible_ssh_host`和`ansible_ssh_user`的清单文件示例 -
    这些变量名称（以及类似的其他变量）在2.0版本之前的Ansible版本中使用。对许多这些变量已经保持了向后兼容性，但在可能的情况下，您应该更新它们，因为这种兼容性可能在将来的某个时候被移除。
- en: 'Now if you were to run the preceding inventory within Ansible, using a simple
    `shell` command, the result would appear as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您在Ansible中运行上述清单，使用一个简单的`shell`命令，结果将如下所示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That covers the basics of creating a simple static inventory file. Let's now
    expand upon this by adding host groups into the inventory in the next part of
    this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了创建一个简单静态清单文件的基础知识。现在让我们通过在本章的下一部分将主机组添加到清单中来扩展这一点。
- en: Using host groups
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用主机组
- en: There is rarely one playbook that will suit an entire infrastructure, and although
    it is easy to tell Ansible to use an alternate inventory for a different playbook,
    this could get very messy, very quickly, with potentially hundreds of small inventory
    files dotted around your network. You can imagine how quickly this would get unmanageable,
    and Ansible is supposed to make things more manageable, not the opposite. One
    possible simple solution to this is to start adding groups into your inventories.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有一个playbook适用于整个基础架构，尽管很容易告诉Ansible为不同的playbook使用备用清单，但这可能会变得非常混乱，非常快速，潜在地在你的网络中散布了数百个小清单文件。你可以想象这会变得多么难以管理，而Ansible的目的是使事情更容易管理，而不是相反。这个问题的一个可能简单的解决方案是开始在你的清单中添加组。
- en: 'Let''s assume you have a simple three-tier web architecture, with multiple
    hosts in each tier for high availability and/or load balancing. The three tiers
    in this architecture might be the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个简单的三层Web架构，每层都有多个主机以实现高可用性和/或负载平衡。这种架构中的三个层可能是以下内容：
- en: Frontend servers
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端服务器
- en: Application servers
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用服务器
- en: Database servers
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库服务器
- en: With this architecture set out, let's set about creating an inventory for it,
    again mixing up the YAML and INI formats to give you experience in both. To keep
    the examples clear and concise, we'll assume that you can access all servers using
    their **Fully Qualified Domain Names** (**FQDNs**), and hence won't add any host
    variables into these inventory files. There is nothing to stop you from doing
    this of course, and every example is different.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个架构，让我们开始创建一个清单，再次混合使用YAML和INI格式，以便你在两种格式中都有经验。为了使示例清晰简洁，我们假设你可以使用它们的**完全限定域名**（**FQDNs**）访问所有服务器，因此不会在这些清单文件中添加任何主机变量。当然，没有什么能阻止你这样做，每个示例都是不同的。
- en: 'Let''s, first of all, create the inventory for the three-tier frontend using
    the INI format. We will call this file `hostsgroups-ini`, and the contents of
    this file should look something like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用INI格式为三层前端创建清单。我们将称此文件为`hostsgroups-ini`，此文件的内容应该如下所示：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding inventory, we have created three groups called `frontends`,
    `apps`, and `databases`. Note that, in INI-formatted inventories, group names
    go inside square braces. Under each group name goes the server names that belong
    in each group, so the preceding example shows two servers in each group. Notice
    the outlier at the top, `loadbalancer.example.com`—this host isn't in any group.
    All ungrouped hosts must go at the very top of an INI-formatted file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的清单中，我们创建了三个名为`frontends`、`apps`和`databases`的组。请注意，在INI格式的清单中，组名放在方括号内。在每个组名下面是属于每个组的服务器名，因此前面的示例显示了每个组中的两个服务器。请注意顶部的异常值`loadbalancer.example.com`
    - 这个主机不属于任何组。所有未分组的主机必须放在INI格式文件的顶部。
- en: Before we proceed any further, it's worth noting that inventories can also contain
    groups of groups, which is incredibly useful for processing certain tasks by a
    different division. The preceding inventory stands in its own right, but what
    if our frontend servers are built on Ubuntu, and the app and database servers
    are built on CentOS? There will be some fundamental differences in the ways we
    handle these hosts—for example, we might use the `apt` module to manage packages
    on Ubuntu and the `yum` module on CentOS.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步进行之前，值得注意的是，清单也可以包含组的组，这对于通过不同的部门处理某些任务非常有用。前面的清单是独立的，但如果我们的前端服务器是建立在Ubuntu上，而应用和数据库服务器是建立在CentOS上呢？在处理这些主机的方式上会有一些根本的不同
    - 例如，我们可能会在Ubuntu上使用`apt`模块来管理软件包，在CentOS上使用`yum`模块。
- en: 'We could, of course, handle this case using facts gathered from each host as
    these will contain the operating system details. We could also create a new version
    of the inventory, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用从每个主机收集的事实来处理这种情况，因为这些事实将包含操作系统的详细信息。我们还可以创建清单的新版本，如下所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the use of the `children` keyword in the group definition (inside the square
    braces), we can create groups of groups; hence, we can perform clever groupings
    to help our playbook design without having to specify each host more than once.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在组定义中使用`children`关键字（在方括号内），我们可以创建组的组；因此，我们可以进行巧妙的分组，以帮助我们的playbook设计，而无需多次指定每个主机。
- en: 'This structure in INI format is quite readable but takes some getting used
    to when it is converted into YAML format. The code listed next shows the YAML
    version of the preceding inventory—the two are identical as far as Ansible is
    concerned, but it is left to you to decide which format you prefer working with:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: INI格式中的这种结构相当易读，但当转换为YAML格式时需要一些时间来适应。下面列出的代码显示了前面清单的YAML版本 - 就Ansible而言，两者是相同的，但你可以决定你更喜欢使用哪种格式：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can see that the `children` keyword is still used in the YAML-formatted
    inventory, but now the structure is more hierarchical than it was in the INI format.
    The indentation might be easier for you to follow, but note how the hosts are
    ultimately defined at quite a high level of indentation—this format could be more
    difficult to extend depending on your desired approach.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`children`关键字仍然在YAML格式的清单中使用，但现在结构比INI格式更加分层。缩进可能更容易让你理解，但请注意主机最终是在相当高层次的缩进下定义的
    - 这种格式可能更难扩展，取决于你希望采用的方法。
- en: 'When you want to work with any of the groups from the preceding inventory,
    you would simply reference it either in your playbook or on the command line.
    For example, in the last section we ran, we can use the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要使用前面清单中的任何组时，你可以在你的playbook或命令行中简单地引用它。例如，在上一节中我们运行的，我们可以使用以下命令：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note the `all` keyword in the middle of that line. That is the special `all`
    group that is implicit in all inventories and is explicitly mentioned in your
    previous YAML example. If we wanted to run the same command, but this time on
    just the `centos` group hosts from the previous YAML inventory, we would run this
    variation of the command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意该行中间的`all`关键字。这是所有库存中都隐含的特殊`all`组，并且在你之前的YAML示例中明确提到。如果我们想运行相同的命令，但这次只在之前的YAML库存中的`centos`组主机上运行，我们将运行这个命令的变体：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, this is a powerful way of managing your inventory and making
    it easy to run commands on just the hosts you want to. The possibility of creating
    multiple groups makes life simple and easy, especially when you want to run different
    tasks on different groups of servers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这是一种管理库存并轻松运行命令的强大方式。创建多个组的可能性使生活变得简单和容易，特别是当你想在不同的服务器组上运行不同的任务时。
- en: 'As an aside to developing your inventories, it is worth noting that there is
    a quick shorthand notation that you can use to create multiple hosts. Let''s assume
    you have 100 app servers, all named sequentially, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发库存的一部分，值得注意的是，有一种快速的简写表示法，可以用来创建多个主机。假设你有100个应用服务器，所有的名称都是顺序的，如下所示：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is entirely possible, but would be tedious and error-prone to create by
    hand and would produce some very hard to read and interpret inventories. Luckily,
    Ansible provides a quick shorthand notation to achieve this, and the following
    inventory snippet actually produces an inventory with the same 100 app servers
    that we could create manually:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完全可能的，但手工创建将是乏味和容易出错的，并且会产生一些非常难以阅读和解释的库存。幸运的是，Ansible提供了一种快速的简写表示法来实现这一点，以下库存片段实际上产生了一个与我们可以手动创建的相同的100个应用服务器的库存：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It is also possible to use alphabetic ranges as well as numeric ones—extending
    our example to add some cache servers, you might have the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用字母范围以及数字范围——扩展我们的示例以添加一些缓存服务器，你可能会有以下内容：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is the same as manually creating the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这与手动创建以下内容相同：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we've completed our exploration of the various static inventory formats
    and how to create groups (and indeed, child groups), let's expand in the next
    section on our previously brief look at host variables.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对各种静态库存格式的探索以及如何创建组（甚至是子组），让我们在下一节中扩展我们之前简要介绍的主机变量。
- en: Adding host and group variables to your inventory
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向库存添加主机和组变量
- en: We have already touched upon host variables—we saw them earlier in this chapter
    when we used them to override connection details such as the user account to connect
    with, the address to connect to, and the port to use. However, there is so much
    more you can do with Ansible and inventory variables, and it is important to note
    that they can be defined not only at the host level but also at the group level,
    which again provides you with some incredibly powerful ways in which to efficiently
    manage your infrastructure from one central inventory.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了主机变量——在本章的前面部分，当我们用它们来覆盖连接细节时，比如要连接的用户帐户、要连接的地址和要使用的端口。然而，你可以在Ansible和库存变量中做的事情远不止这些，重要的是要注意，它们不仅可以在主机级别定义，还可以在组级别定义，这再次为你提供了一些非常强大的方式来高效地管理你的基础设施。
- en: 'Let''s build on our previous three-tier example and suppose that we need to
    set two variables for each of our two frontend servers. These are not special
    Ansible variables, but instead are variables entirely of our own choosing, which
    we will use later on in the playbooks that run against this server. Suppose that
    these variables are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在之前的三层示例基础上继续建设，并假设我们需要为我们的两个前端服务器中的每一个设置两个变量。这些不是特殊的Ansible变量，而是完全由我们自己选择的变量，我们将在稍后运行对这台服务器的playbook中使用。假设这些变量如下：
- en: '`https_port`, which defines the port that the frontend proxy should listen
    on'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https_port`，定义了前端代理应该监听的端口'
- en: '`lb_vip`, which defines the FQDN of the load-balancer in front of the frontend
    servers'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lb_vip`，定义了前端服务器前面的负载均衡器的FQDN'
- en: 'Let''s see how this is done:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何完成的：
- en: 'We could simply add these to each of the hosts in the `frontends` part of our
    inventory file, just as we did before with the Ansible connection variables. In
    this case, a portion of our INI-formatted inventory might look like this:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以简单地将这些添加到我们库存文件中`frontends`部分的每个主机中，就像我们之前用Ansible连接变量做的那样。在这种情况下，我们的INI格式的库存的一部分可能是这样的：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we run an ad hoc command against this inventory, we can see the contents
    of both of these variables:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对这个库存运行一个临时命令，我们可以看到这两个变量的内容：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This has worked just as we desired, but the approach is inefficient as you have
    to add the same variables to every single host.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经按我们的期望工作了，但这种方法效率低下，因为你必须将相同的变量添加到每个主机。
- en: 'Luckily, you can assign variables to a host group as well as to hosts individually.
    If we edited the preceding inventory to achieve this, the `frontends` section
    would now look like this:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幸运的是，你可以将变量分配给主机组以及单独的主机。如果我们编辑前面的库存以实现这一点，`frontends`部分现在看起来像这样：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice how much more readable that is? Yet, if we run the same command as before
    against our newly organized inventory, we see that the result is the same:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这种方式更易读？然而，如果我们对新组织的库存运行与之前相同的命令，我们会发现结果是一样的：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There will be times when you want to work with host variables for individual
    hosts, and times when group variables are more relevant. It is up to you to determine
    which is better for your scenario; however, remember that host variables can be
    used in combination. It is also worth noting that host variables override group
    variables, so if we need to change the connection port to `8444` on the `frt01.example.com`
    one, we could do this as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时候你会想要为单个主机使用主机变量，有时候组变量更相关。由你来决定哪个对你的情况更好；然而，请记住主机变量可以组合使用。值得注意的是主机变量会覆盖组变量，所以如果我们需要将连接端口更改为`8444`，我们可以这样做：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now if we run our ad hoc command again with the new inventory, we can see that
    we have overridden the variable on one host:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次使用新的清单运行我们的临时命令，我们可以看到我们已经覆盖了一个主机上的变量：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Of course, doing this for one host alone when there are only two might seem
    a little pointless, but when you have an inventory with hundreds of hosts in it,
    this method of overriding one host will suddenly become very valuable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当只有两个主机时，仅为一个主机执行此操作可能看起来有点无意义，但当你的清单中有数百个主机时，覆盖一个主机的这种方法突然变得非常有价值。
- en: 'Just for completeness, if we were to add the host variables we defined previously
    to our YAML version of the inventory, the `frontends` section would appear as
    follows (the rest of the inventory has been removed to save space):'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完整起见，如果我们要将之前定义的主机变量添加到我们的清单的YAML版本中，`frontends`部分将如下所示（其余清单已被删除以节省空间）：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Running the same ad hoc command as before, you can see that the result is the
    same as for our INI-formatted inventory:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行与之前相同的临时命令，你会看到结果与我们的INI格式的清单相同：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So far, we have covered several ways of providing host variables and group variables
    to your inventory; however, there is another way that deserves special mention
    and will become valuable to you as your inventory becomes larger and more complex.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了几种向清单提供主机变量和组变量的方法；然而，还有一种方法值得特别提及，并且在你的清单变得更大更复杂时会变得有价值。
- en: Right now, our examples are small and compact and only contain a handful of
    groups and variables; however, when you scale this up to a full infrastructure
    of servers, using a single flat inventory file could, once again, become unmanageable.
    Luckily, Ansible also provides a solution to this. Two specially-named directories,
    `host_vars` and `group_vars`, are automatically searched for appropriate variable
    content if they exist within the playbook directory. We can test this out by recreating
    the preceding frontend variables example using this special directory structure,
    rather than putting the variables into the inventory file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的示例很小很简洁，只包含少数组和变量；然而，当你将其扩展到一个完整的服务器基础设施时，再次使用单个平面清单文件可能会变得难以管理。幸运的是，Ansible也提供了解决方案。两个特别命名的目录`host_vars`和`group_vars`，如果它们存在于剧本目录中，将自动搜索适当的变量内容。我们可以通过使用这种特殊的目录结构重新创建前面的前端变量示例来测试这一点，而不是将变量放入清单文件中。
- en: 'Let''s start by creating a new directory structure for this purpose:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先为此目的创建一个新的目录结构：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, under this directory, we''ll create two more directories for the variables:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在这个目录下，我们将为变量创建两个更多的目录：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, under the `host_vars` directory, we''ll create a file with the name of
    our host that needs the proxy setting, with `.yml` appended to it (that is, `frt01.example.com.yml`).
    This file should contain the following:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`host_vars`目录下，我们将创建一个文件，文件名为需要代理设置的主机名，后面加上`.yml`（即`frt01.example.com.yml`）。这个文件应该包含以下内容：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Similarly, under the `group_vars` directory, create a YAML file named after
    the group to which we want to assign variables (that is, `frontends.yml`) with
    the following contents:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在`group_vars`目录下，创建一个名为要分配变量的组的YAML文件（即`frontends.yml`），内容如下：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we will create our inventory file as before, except that it contains
    no variables:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将像以前一样创建我们的清单文件，只是它不包含变量：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Just for clarity, your final directory structure should look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，你的最终目录结构应该是这样的：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s try running our familiar ad hoc command and see what happens:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试运行我们熟悉的临时命令，看看会发生什么：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, this works exactly as before, and without further instruction,
    Ansible has traversed the directory structure and ingested all of the variable
    files.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这与以前完全一样，而且在没有进一步的指示的情况下，Ansible已经遍历了目录结构并摄取了所有的变量文件。
- en: 'If you have many hundreds of variables (or need an even finer-grained approach),
    you can replace the YAML files with directories named after the hosts and groups.
    Let''s recreate the directory structure but now with directories instead:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你有数百个变量（或需要更精细的方法），你可以用主机和组的名字命名目录来替换YAML文件。现在，我们重新创建目录结构，但现在用目录代替：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice how we now have directories named after the `frontends` group and the
    `frt01.example.com` host? Inside the `frontends` directory, we have split the
    variables into two files, and this can be incredibly useful for logically organizing
    variables in groups, especially as your playbooks get bigger and more complex.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们现在有了以`frontends`组和`frt01.example.com`主机命名的目录？在`frontends`目录中，我们将变量分成了两个文件，这对于在组中逻辑地组织变量尤其有用，特别是当你的剧本变得更大更复杂时。
- en: 'The files themselves are simply an adaptation of our previous ones:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件本身只是我们之前的文件的一种改编：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Even with this more finely divided directory structure, the result of running
    the ad hoc command is still the same:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用这种更细分的目录结构，运行临时命令的结果仍然是相同的：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'One final thing of note before we conclude this chapter is if you define the
    same variable at both a group level and a child group level, the variable at the
    child group level takes precedence. This is not as obvious to figure out as it
    first sounds. Consider our earlier inventory where we used child groups to differentiate
    between CentOS and Ubuntu hosts—if we add a variable with the same name to both
    the `ubuntu` child group and the `frontends` group (which is a **child** of the `ubuntu` group)
    as follows, what will the outcome be? The inventory would look like this:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，还有一件事需要注意，即如果您在组级别和子组级别同时定义了相同的变量，则子组级别的变量优先。这并不像听起来那么明显。考虑我们之前的清单，我们在其中使用子组来区分CentOS和Ubuntu主机——如果我们在`ubuntu`子组和`frontends`组（`ubuntu`组的**子组**）中都添加了同名的变量，结果会是什么？清单将如下所示：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let''s run an ad hoc command to see what value of `testvar` is actually
    set:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行一个临时命令，看看`testvar`的实际设置值是多少：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It's important to note that the `frontends` group is a child of the `ubuntu`
    group in this inventory (hence, the group definition is `[ubuntu:children]`),
    and so the variable value we set at the `frontends` group level wins as this is
    the child group in this scenario.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在这个清单中，`frontends`组是`ubuntu`组的子组（因此，组定义是`[ubuntu:children]`），因此在这种情况下，我们在`frontends`组级别设置的变量值会胜出。
- en: By now, you should have a pretty good idea of how to work with static inventory
    files. No look at Ansible's inventory capabilities is complete, however, without
    a look at dynamic inventories, and we shall do exactly this in the next section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经对如何使用静态清单文件有了相当好的了解。然而，没有查看动态清单的Ansible清单功能是完整的，我们将在下一节中做到这一点。
- en: Generating a dynamic inventory file
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成动态清单文件
- en: In these days of cloud computing and infrastructure-as-code, the hosts you may
    wish to automate could change on a daily if not hourly basis! Keeping a static
    Ansible inventory up to date could become a full-time job, and hence, in many
    large-scale scenarios, it becomes unrealistic to attempt to use a static inventory
    on an ongoing basis.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在云计算和基础设施即代码的今天，您可能希望自动化的主机每天甚至每小时都会发生变化！保持静态的Ansible清单最新可能会成为一项全职工作，在许多大规模的场景中，因此，尝试在持续基础上使用静态清单变得不切实际。
- en: This is where Ansible's dynamic inventory support comes in. In short, Ansible
    can gather its inventory data from just about any executable file (though you
    will find that most dynamic inventories are written in Python)—the only requirement
    is that the executable returns the inventory data in a specified JSON format.
    You are free to create your own inventory scripts if you wish, but thankfully,
    many have been created already for you to use that cover a multitude of potential
    inventory sources including Amazon EC2, Microsoft Azure, Red Hat Satellite, LDAP
    directories, and many more systems.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Ansible的动态清单支持发挥作用的地方。简而言之，Ansible可以从几乎任何可执行文件中收集其清单数据（尽管您会发现大多数动态清单都是用Python编写的）——唯一的要求是可执行文件以指定的JSON格式返回清单数据。如果愿意，您可以自己创建清单脚本，但值得庆幸的是，已经有许多可供您使用的脚本，涵盖了许多潜在的清单来源，包括Amazon
    EC2、Microsoft Azure、Red Hat Satellite、LDAP目录等等。
- en: When writing a book, it is difficult to know for certain which dynamic inventory
    script to use as an example as it is not a given that everyone will have an Amazon
    EC2 account they can freely use to test against (for example). As a result, we
    will use the Cobbler provisioning system by way of example, as this is freely
    available and easy to roll out on a CentOS system. For those interested, Cobbler
    is a system for dynamically provisioning and building Linux systems, and it can
    handle all aspects of this including DNS, DHCP, PXE booting, and so on. Hence,
    if you were to use this to provision virtual or physical machines in your infrastructure,
    it would make sense to also use this as your inventory source as Cobbler was responsible
    for building the systems in the first place, and so knows all of the system names.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写书籍时，很难确定要使用哪个动态清单脚本作为示例，因为并不是每个人都有一个可以自由使用来进行测试的Amazon EC2帐户（例如）。因此，我们将以Cobbler配置系统作为示例，因为这是免费提供的，并且在CentOS系统上很容易部署。对于感兴趣的人来说，Cobbler是一个用于动态配置和构建Linux系统的系统，它可以处理包括DNS、DHCP、PXE引导等在内的所有方面。因此，如果您要使用它来配置基础架构中的虚拟或物理机器，那么使用它作为清单来源也是有道理的，因为Cobbler负责首次构建系统，因此了解所有系统名称。
- en: 'This example will demonstrate for you the fundamentals of working with a dynamic
    inventory, which you can then take forward to use the dynamic inventory scripts
    for other systems. Let''s get started with this process by first of all installing
    Cobbler—the process outlined here was tested on CentOS 7.8:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将为您演示使用动态清单的基本原理，然后您可以将其应用到其他系统的动态清单脚本中。让我们开始这个过程，首先安装Cobbler——这个过程在CentOS
    7.8上进行了测试：
- en: 'Your first task is to install the relevant Cobbler packages using `yum`. Note
    that, at the time of writing, the SELinux policy provided with CentOS 7 did not
    support Cobbler''s functionality and blocks some aspects from working. Although
    this is not something you should do in a production environment, your simplest
    path to getting this demo up and running is to simply disable SELinux:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的第一个任务是使用`yum`安装相关的Cobbler软件包。请注意，在撰写本文时，CentOS 7提供的SELinux策略不支持Cobbler的功能，并阻止了一些方面的工作。尽管这不是您在生产环境中应该做的事情，但让这个演示快速运行的最简单方法是简单地禁用SELinux：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, ensure that the `cobblerd` service is configured to listen on the loopback
    address by checking the settings in `/etc/cobbler/settings`—the relevant snippet
    of the file is shown here and should appear as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，请确保`cobblerd`服务已配置为在环回地址上监听，方法是检查`/etc/cobbler/settings`中的设置——文件的相关片段如下所示：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is not a public listening address, so please *do not use* `0.0.0.0`. You
    can also set it to the IP address of the Cobbler server.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个公共监听地址，请*不要使用*`0.0.0.0`。您也可以将其设置为Cobbler服务器的IP地址。
- en: 'With this step complete, you can start the `cobblerd` service using `systemctl`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这一步后，您可以使用`systemctl`启动`cobblerd`服务。
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With the Cobbler service up and running, we''ll now step through the process
    of adding a distribution to Cobbler to create some hosts off of. This process
    is fairly simple, but you do need to add a kernel file and an initial RAM disk
    file. The easiest source to obtain these from is your `/boot` directory, assuming
    you have installed Cobbler on CentOS 7\. On the test system used for this demo,
    the following commands were used—however, you must replace the version number
    in the `vmlinuz` and `initramfs` filenames with the appropriate version numbers
    from your system''s `/boot` directory:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cobbler服务已经启动运行，现在我们将逐步介绍向Cobbler添加发行版的过程，以创建一些主机。这个过程非常简单，但您需要添加一个内核文件和一个初始RAM磁盘文件。获取这些文件的最简单来源是您的`/boot`目录，假设您已在CentOS
    7上安装了Cobbler。在用于此演示的测试系统上使用了以下命令，但是，您必须将`vmlinuz`和`initramfs`文件名中的版本号替换为您系统`/boot`目录中的适当版本号：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This definition is quite rudimentary and would not necessarily be able to produce
    working server images; however, it will suffice for our simple demo as we can
    add some systems based on this notional CentOS-based image. Note that the profile
    name we are creating, `webservers`, will later become our inventory group name
    in our dynamic inventory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义非常基础，可能无法生成可用的服务器镜像；但是，对于我们的简单演示来说，它足够了，因为我们可以基于这个假设的基于CentOS的镜像添加一些系统。请注意，我们正在创建的配置文件名`webservers`将在我们的动态清单中成为我们的清单组名。
- en: 'Let''s now add those systems to Cobbler. The following two commands will add
    two hosts called `frontend01` and `frontend02` to our Cobbler system, using the
    `webservers` profile we created previously:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们将这些系统添加到Cobbler中。以下两个命令将向我们的Cobbler系统添加两个名为`frontend01`和`frontend02`的主机，使用我们之前创建的`webservers`配置文件：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that, for Ansible to work, it must be able to reach these FQDNs specified
    in the `--dns-name` parameter. To achieve this, I am also adding entries to `/etc/hosts`
    on the Cobbler system for these two machines to ensure we can reach them later.
    These entries can point to any two systems of your choosing as this is just a
    test.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了使Ansible工作，它必须能够到达`--dns-name`参数中指定的这些FQDN。为了实现这一点，我还在Cobbler系统的`/etc/hosts`中添加了这两台机器的条目，以确保我们以后可以到达它们。这些条目可以指向您选择的任何两个系统，因为这只是一个测试。
- en: 'At this point, you have successfully installed Cobbler, created a profile,
    and added two hypothetical systems to this profile. The next stage in our process
    is to download and configure the Ansible dynamic inventory scripts to work with
    these entries. To achieve this, let''s get started on the process given here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您已成功安装了Cobbler，创建了一个配置文件，并向该配置文件添加了两个假设系统。我们过程的下一阶段是下载并配置Ansible动态清单脚本，以便与这些条目一起使用。为了实现这一点，让我们开始执行以下给出的过程：
- en: 'Download the Cobbler dynamic inventory file from the GitHub Ansible repository
    and the associated configuration file template. Note that most dynamic inventory
    scripts provided with Ansible also have a templated configuration file, which
    will contain parameters that you may need to set to get the dynamic inventory
    script working. For our simple example, we will download these files into our
    current working directory:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GitHub Ansible存储库下载Cobbler动态清单文件以及相关的配置文件模板。请注意，大多数由Ansible提供的动态清单脚本也有一个模板化的配置文件，其中包含您可能需要设置的参数，以使动态清单脚本工作。对于我们的简单示例，我们将把这些文件下载到我们当前的工作目录中：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It is important to remember to make whatever dynamic inventory script you download
    executable, as shown previously; if you don't do this, then Ansible won't be able
    to run the script even if everything else is set up perfectly.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，要使您下载的任何动态清单脚本可执行，就像之前展示的那样；如果您不这样做，那么即使其他一切都设置得完美，Ansible也无法运行该脚本。
- en: 'Edit the `cobbler.ini` file and ensure that it points to the localhost as,
    for this example, we are going to run Ansible and Cobbler on the same system.
    In real life, you would point it at the remote URL of your Cobbler system. A snippet
    of the configuration file is shown here to give you an idea of what to configure:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`cobbler.ini`文件，并确保它指向本地主机，因为在本例中，我们将在同一系统上运行Ansible和Cobbler。在现实生活中，您会将其指向Cobbler系统的远程URL。以下是配置文件的一部分，以便让您了解如何配置：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can now run an Ansible ad hoc command in the manner you are used to—the
    only difference this time is that you will specify the filename of the dynamic
    inventory script rather than the name of the static inventory file. Assuming you
    have set up hosts at the two addresses we entered into Cobbler earlier, your output
    should look something like that shown here:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以按照您习惯的方式运行Ansible的临时命令——这次唯一的区别是，您将指定动态清单脚本的文件名，而不是静态清单文件的名称。假设您已经在Cobbler中输入了两个地址的主机，您的输出应该看起来像这样：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'That''s it! You have just implemented your first dynamic inventory in Ansible.
    Of course, we know that many readers won''t be using Cobbler, and some of the
    other dynamic inventory plugins are a little more complex to get going. For example,
    the Amazon EC2 dynamic inventory script requires your authentication details for
    Amazon Web Services (or a suitable IAM account) and the installation of the Python
    `boto` and `boto3` libraries. How would you know to do all of this? Luckily, it
    is all documented in the headers of either the dynamic inventory script or the
    configuration file, so the most fundamental piece of advice I can give is this:
    whenever you download a new dynamic inventory script, be sure to check out the
    files themselves in your favorite editor as their requirements have most likely
    been documented for you.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！您刚刚在Ansible中实现了您的第一个动态清单。当然，我们知道许多读者不会使用Cobbler，一些其他动态清单插件更复杂。例如，Amazon
    EC2动态清单脚本需要您的Amazon Web Services的身份验证详细信息（或适当的IAM帐户）以及Python `boto`和`boto3`库的安装。您怎么知道要做所有这些？幸运的是，所有这些都在动态清单脚本或配置文件的头部有记录，所以我能给出的最基本的建议是：每当您下载新的动态清单脚本时，请务必在您喜欢的编辑器中查看文件本身，因为它们的要求很可能已经为您记录了。
- en: Before we end this section of this book, let's have a look at a few other handy
    hints for working with inventories, starting with the use of multiple inventory
    sources in the next section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一节结束之前，让我们看一下使用多个清单来源的其他一些方便提示，从下一节开始。
- en: Using multiple inventory sources in the inventory directories
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在清单目录中使用多个清单来源
- en: So far in this book, we have been specifying our inventory file (either static
    or dynamic) using the `-i` switch in our Ansible commands. What might not be apparent
    is that you can specify the `-i` switch more than once and so use multiple inventories
    at the same time. This enables you to perform tasks such as running a playbook
    (or ad hoc command) across hosts from both static and dynamic inventories at the
    same time. Ansible will work out what needs to be done—static inventories should
    not be marked as executable and so will not be processed as such, whereas dynamic
    inventories will be. This small but clever trick enables you to combine multiple
    inventory sources with ease. Let's move on in the next section to looking at the
    use of static inventory groups in combination with dynamic ones, an extension
    of this multiple-inventory functionality.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们一直在使用我们的Ansible命令中的`-i`开关来指定我们的清单文件（静态或动态）。可能不明显的是，您可以多次指定`-i`开关，因此同时使用多个清单。这使您能够执行跨静态和动态清单的主机的任务，例如运行一个playbook（或临时命令）。Ansible将会计算出需要做什么——静态清单不应标记为可执行，因此不会被处理为这样，而动态清单将会被处理。这个小巧但聪明的技巧使您能够轻松地结合多个清单来源。让我们在下一节中继续看一下静态清单组与动态清单组的使用，这是多清单功能的扩展。
- en: Using static groups with dynamic groups
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在动态组中使用静态组
- en: Of course, the possibility of mixing inventories brings with it an interesting
    question—what happens to the groups from a dynamic inventory and a static inventory
    if you define both? The answer is that Ansible combines both, and this leads to
    an interesting possibility. As you will have observed, our Cobbler inventory script
    produced an Ansible group called `webservers` from a Cobbler profile that we called
    `webservers`. This is common for most dynamic inventory providers; most inventory
    sources (for example, Cobbler and Amazon EC2) are not Ansible-aware and so do
    not offer groups that Ansible can directly use. As a result, most dynamic inventory
    scripts will use some facet of information from the inventory source to produce
    groupings, the Cobbler machine profile being one such example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，混合清单的可能性带来了一个有趣的问题——如果您同时定义动态清单和静态清单中的组，会发生什么？答案是Ansible会将两者结合起来，这带来了一个有趣的可能性。正如您所看到的，我们的Cobbler清单脚本从我们称为`webservers`的Cobbler配置文件中产生了一个名为`webservers`的Ansible组。这对于大多数动态清单提供者来说很常见；大多数清单来源（例如Cobbler和Amazon
    EC2）都不是Ansible感知的，因此不提供Ansible可以直接使用的组。因此，大多数动态清单脚本将使用清单来源的某些信息来产生分组，Cobbler机器配置文件就是一个例子。
- en: Let's extend our Cobbler example from the preceding section by mixing a static
    inventory. Suppose that we want to make our `webservers` machines a child group
    of a group called `centos` so that we can, in the future, group all CentOS machines
    together. We know that we only have a Cobbler profile called `webservers`, and
    ideally, we don't want to start messing with the Cobbler setup to do something
    solely Ansible-related.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过混合静态清单来扩展前一节中的Cobbler示例。假设我们想要将我们的`webservers`机器作为名为`centos`的组的子组，以便我们将来可以将所有CentOS机器分组在一起。我们知道我们只有一个名为`webservers`的Cobbler配置文件，理想情况下，我们不想开始干扰Cobbler设置，只是为了做一些与Ansible相关的事情。
- en: The answer to this is to create a static inventory file with two group definitions.
    The first must be the same name as the group you are expecting from the dynamic
    inventory, except that you should leave it blank. When Ansible combines the static
    and dynamic inventory contents, it will overlap the two groups and so add the
    hosts from Cobbler to these `webservers` groups.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是创建一个具有两个组定义的静态清单文件。第一个必须与您从动态清单中期望的组的名称相同，只是您应该将其留空。当Ansible组合静态和动态清单内容时，它将重叠这两个组，因此将Cobbler的主机添加到这些`webservers`组中。
- en: 'The second group definition should state that `webservers` is a child group
    of the `centos` group. The resulting file should look something like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个组定义应该说明`webservers`是`centos`组的子组。生成的文件应该看起来像这样：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now let''s run a simple ad hoc `ping` command in Ansible to see how it evaluates
    the two inventories together. Notice how we will specify the `centos` group to
    run `ping` against, instead of the `webservers` group. We know that Cobbler has
    no `centos` group because we never created one, and we know that any hosts in
    this group must come via the `webservers` group when you combine the two inventories,
    as our static inventory has no hosts in it. The results will look something like
    this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在Ansible中运行一个简单的临时`ping`命令，以查看它如何评估两个清单。请注意，我们将指定`centos`组来运行`ping`，而不是`webservers`组。我们知道Cobbler没有`centos`组，因为我们从未创建过，我们知道当您组合两个清单时，此组中的任何主机必须通过`webservers`组来，因为我们的静态清单中没有主机。结果将看起来像这样：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see from the preceding output, we have referenced two different inventories,
    one static and the other dynamic. We have combined groups, taking hosts that only
    exist in one inventory source, and combining them with a group that only exists
    in another. As you can see, this is an incredibly simple example, and it would
    be easy to extend this to combine lists of static and dynamic hosts or to add
    a custom variable to a host that comes from a dynamic inventory.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看出，我们引用了两个不同的清单，一个是静态的，另一个是动态的。我们已经组合了组，将仅存在于一个清单源中的主机与仅存在于另一个清单源中的组合在一起。正如您所看到的，这是一个非常简单的例子，很容易将其扩展为组合静态和动态主机的列表，或者向来自动态清单的主机添加自定义变量。
- en: This is a trick of Ansible that is little known but can be very powerful as
    your inventories expand and grow. As we have worked through this chapter, you
    will have observed that we have been very precise about specifying our inventory
    hosts either individually or by group; for example, we explicitly told `ansible`
    to run the ad hoc command against all hosts in the `webservers` group. In the
    next section, we will build on this to look at how Ansible can manage a set of
    hosts specified using patterns.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Ansible的一个鲜为人知的技巧，但在清单扩展和增长时可以非常强大。当我们通过本章工作时，您会注意到我们非常精确地指定了我们的清单主机，要么是单独的，要么是通过组；例如，我们明确告诉`ansible`对`webservers`组中的所有主机运行临时命令。在下一节中，我们将继续探讨Ansible如何管理使用模式指定的一组主机。
- en: Special host management using patterns
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模式进行特殊主机管理
- en: We have already established that you will often want to run either an ad hoc
    command or a playbook against only a subsection of your inventory. So far, we
    have been quite precise in doing that, but let's now expand upon this by looking
    at how Ansible can work with patterns to figure out which hosts a command (or
    playbook) should be run against.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定，您经常会想要针对清单的一个子部分运行一个临时命令或一个playbook。到目前为止，我们一直在做得很精确，但现在让我们通过查看Ansible如何使用模式来确定应该针对哪些主机运行命令（或playbook）来扩展这一点。
- en: 'As a starting point, let''s consider again an inventory that we defined earlier
    in this chapter for the purposes of exploring host groups and child groups. For
    your convenience, the inventory contents are provided again here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，让我们再次考虑本章早些时候定义的清单，以便探索主机组和子组。为了方便起见，清单内容再次提供如下：
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To demonstrate host/group selection by pattern, we shall use the `--list-hosts`
    switch with the `ansible` command to see which hosts Ansible would operate on.
    You are welcome to expand the example to use the `ping` module, but we''ll use
    `--list-hosts` here in the interests of space and keeping the output concise and
    readable:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示通过模式进行主机/组选择，我们将使用`ansible`命令的`--list-hosts`开关来查看Ansible将对哪些主机进行操作。您可以扩展示例以使用`ping`模块，但出于空间和输出简洁可读的考虑，我们将在这里使用`--list-hosts`：
- en: 'We have already mentioned the special `all` group to specify all hosts in the
    inventory:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经提到了特殊的`all`组来指定清单中的所有主机：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The asterisk character has the same effect as `all`, but needs to be quoted
    in single quotes for the shell to interpret the command properly:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 星号字符具有与`all`相同的效果，但需要在shell中用单引号引起来，以便shell正确解释命令：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Use `:` to specify a logical `OR`, meaning "apply to hosts either in this group
    or that group," as in this example:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`:`来指定逻辑`OR`，意思是“应用于这个组或那个组中的主机”，就像这个例子中一样：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Use `!` to exclude a specific group—you can combine this with other characters
    such as `:` to show (for example) all hosts except those in the `apps` group.
    Again, `!` is a special character in the shell and so you must quote your pattern
    string in single quotes for it to work, as in this example:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`!`来排除特定组——您可以将其与其他字符（例如`:`）结合使用，以显示（例如）除`apps`组中的所有主机之外的所有主机。同样，`!`是shell中的特殊字符，因此您必须在单引号中引用模式字符串，以使其正常工作，就像这个例子中一样：
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Use `:&` to specify a logical `AND` between two groups, for example, if we
    want all hosts that are in the `centos` group and the `apps` group (again, you
    must use single quotes in the shell):'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`:&`来指定两个组之间的逻辑`AND`，例如，如果我们想要在`centos`组和`apps`组中的所有主机（再次，您必须在shell中使用单引号）：
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Use `*` wildcards in a similar manner to what you would use in the shell, as
    in this example:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`*`通配符的方式与在shell中使用的方式类似，就像这个例子中一样：
- en: '[PRE49]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Another way you can limit which hosts a command is run on is to use the `--limit`
    switch with Ansible. This uses exactly the same syntax and pattern notation as
    in the preceding but has the advantage that you can use it with the `ansible-playbook`
    command, where specifying a host pattern on the command line is only supported
    for the `ansible` command itself. Hence, for example, you could run the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种限制命令运行的主机的方法是使用Ansible的`--limit`开关。这与前面的语法和模式表示完全相同，但它的优势在于您可以在`ansible-playbook`命令中使用它，而在命令行上指定主机模式仅支持`ansible`命令本身。因此，例如，您可以运行以下命令：
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Patterns are a very useful and important part of working with inventories, and
    something you will no doubt find invaluable going forward. That concludes our
    chapter on Ansible inventories; however, it is hoped that this has given you everything
    you need to work confidently with Ansible inventories.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 模式是处理清单的非常有用和重要的部分，您无疑会发现它们非常有价值。这结束了我们关于Ansible清单的章节；但是，希望这为您提供了一切您需要自信地使用Ansible清单。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Creating and managing Ansible inventories is a crucial part of your work with
    Ansible, and hence we have covered this fundamental concept early in this book.
    They are vital as without them Ansible would have no knowledge of what hosts it
    is to run automation tasks against, yet they provide so much more than this. They
    provide an integration point with configuration management systems, they provide
    a sensible source for host-specific (or group-specific) variables to be stored,
    and they provide you with a flexible way of running this playbook.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和管理Ansible清单是您使用Ansible的工作的重要部分，因此我们在本书的早期阶段就介绍了这个基本概念。它们至关重要，因为没有它们，Ansible将不知道要针对哪些主机运行自动化任务，但它们提供的远不止这些。它们为配置管理系统提供了一个集成点，它们为存储主机特定（或组特定）变量提供了一个明智的来源，并且它们为您提供了运行此playbook的灵活方式。
- en: In this chapter, you learned about creating simple static inventory files and
    adding hosts to them. We then extended this by learning how to add host groups
    and assign variables to hosts. We also looked at how to organize your inventories
    and variables when a single flat inventory file becomes too much to handle. We
    then learned how to make use of dynamic inventory files, before concluding with
    a look at useful tips and tricks such as combining inventory sources and using
    patterns to specify hosts, all of which will make how you work with inventories
    easier and yet simultaneously more powerful.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何创建简单的静态清单文件并向其中添加主机。然后，我们通过学习如何添加主机组并为主机分配变量来扩展了这一点。我们还研究了在单个平面清单文件变得太难处理时如何组织您的清单和变量。然后，我们学习了如何利用动态清单文件，最后通过查看有用的技巧和诀窍，如组合清单来源和使用模式来指定主机，使您处理清单更加容易，同时更加强大。
- en: In the next chapter, we will learn how to develop playbooks and roles to configure,
    deploy, and manage remote machines using Ansible.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何开发playbooks和roles来使用Ansible配置，部署和管理远程机器。
- en: Questions
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do you add the `frontends` group variables to your inventory?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将`frontends`组变量添加到您的清单中？
- en: A) `[frontends::]`
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: A) `[frontends::]`
- en: B) `[frontends::values]`
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: B) `[frontends::values]`
- en: C) `[frontends:host:vars]`
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: C) `[frontends:host:vars]`
- en: D) `[frontends::variables]`
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: D) `[frontends::variables]`
- en: E) `[frontends:vars]`
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: E) `[frontends:vars]`
- en: What enables you to automate Linux tasks such as provisioning DNS, managing
    DHCP, updating packages, and configuration management?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么使您能够自动执行Linux任务，如提供DNS，管理DHCP，更新软件包和配置管理？
- en: A) Playbook
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: A) 播放书
- en: B) Yum
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: B) Yum
- en: C) Cobbler
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: C) 修鞋匠
- en: D) Bash
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: D) Bash
- en: E) Role
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: E) 角色
- en: Ansible allows you to specify an inventory file location by using the `-i` option
    on the command line.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible允许您使用命令行上的`-i`选项来指定清单文件位置。
- en: A) True
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: A) 真
- en: B) False
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: B) 错误
- en: Further reading
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: All common dynamic inventories of Ansible from the GitHub repository are here: [https://github.com/ansible/ansible/tree/devel/contrib/inventory](https://github.com/ansible/ansible/tree/devel/contrib/inventory).
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible的所有常见动态清单都在GitHub存储库中：[https://github.com/ansible/ansible/tree/devel/contrib/inventory](https://github.com/ansible/ansible/tree/devel/contrib/inventory)。
