- en: Deploying Your First Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署您的第一个应用程序
- en: In the previous chapters, we covered Kubernetes key operation principles and
    deployment strategies for Windows/Linux hybrid clusters. Now it is time to focus
    more on deploying and working with Kubernetes applications. To demonstrate the
    essential operations for Kubernetes applications, we will use the AKS Engine hybrid
    Kubernetes cluster that we created in [Chapter 8](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml), *Deploying
    Hybrid Azure Kubernetes Service Engine Cluster*. You can use the on-premises hybrid
    cluster as well, but you should expect limited functionality; for example, services
    of the LoadBalancer type will not be available.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们介绍了Kubernetes的关键操作原则和Windows/Linux混合集群的部署策略。现在是时候更专注于部署和使用Kubernetes应用程序了。为了演示Kubernetes应用程序的基本操作，我们将使用在[第8章](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml)中创建的AKS
    Engine混合Kubernetes集群，*部署混合Azure Kubernetes服务引擎集群*。您也可以使用本地混合集群，但您应该期望功能有限；例如，LoadBalancer类型的服务将不可用。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Imperatively deploying an application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令式部署应用程序
- en: Using Kubernetes manifest files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes清单文件
- en: Scheduling Pods on Windows nodes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows节点上调度Pods
- en: Accessing your application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问您的应用程序
- en: Scaling the application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展应用程序
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，您将需要以下内容：
- en: Windows 10 Pro, Enterprise, or Education (version 1903 or later, 64-bit) installed
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装Windows 10 Pro、企业版或教育版（1903版本或更高版本，64位）
- en: An Azure account
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure帐户
- en: Windows/Linux Kubernetes cluster deployed using AKS Engine
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AKS Engine部署的Windows/Linux Kubernetes集群
- en: To follow along, you will need your own Azure account to create Azure resources
    for the Kubernetes cluster. If you haven't already created the account for the
    previous chapters, you can read more about how to obtain a limited free account
    for personal use here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟着做，您需要自己的Azure帐户来为Kubernetes集群创建Azure资源。如果您之前还没有为前几章创建帐户，您可以在这里阅读更多关于如何获得个人使用的有限免费帐户：[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)。
- en: Deploying a Kubernetes cluster using AKS Engine has been covered in [Chapter
    8](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml), *Deploying Hybrid Azure Kubernetes
    Service Engine Cluster*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AKS Engine部署Kubernetes集群已在[第8章](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml)中介绍过，*部署混合Azure
    Kubernetes服务引擎集群*。
- en: You can download the latest code samples for this chapter from the official
    GitHub repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter09).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从官方GitHub存储库下载本章的最新代码示例：[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter09)。
- en: Imperatively deploying an application
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令式部署应用程序
- en: 'In the Kubernetes world, you can choose from two approaches when managing your
    applications: imperative management and declarative management. The imperative
    approach consists of executing imperative kubectl commands, such as `kubectl run`
    or `kubectl expose`, and imperative object configuration management, where you
    use commands such as `kubectl create` or `kubectl replace`. In short, you manage
    the cluster by executing ad-hoc commands that modify the Kubernetes objects and
    result in a changed desired state for the cluster—sometimes, you may not even
    know how the desired state has exactly changed after an imperative command. By
    contrast, in the declarative approach, you modify object configurations (manifest
    files) and create or update them in the cluster using the `kubectl apply` command
    (alternatively, you can use Kustomization files).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes世界中，管理应用程序时可以选择两种方法：命令式管理和声明式管理。命令式方法包括执行命令式kubectl命令，例如`kubectl
    run`或`kubectl expose`，以及命令式对象配置管理，其中您使用命令，如`kubectl create`或`kubectl replace`。简而言之，您通过执行临时命令来管理集群，这些命令修改Kubernetes对象并导致集群的期望状态发生变化
    - 有时，您甚至可能不知道命令式命令之后期望状态的确切变化。相比之下，在声明式方法中，您修改对象配置（清单文件），并使用`kubectl apply`命令在集群中创建或更新它们（或者，您可以使用Kustomization文件）。
- en: Using declarative management is, in general, more close to the spirit of Kubernetes—the
    whole architecture is focused on persisting the desired cluster state and constantly
    performing operations that change the current cluster state to the desired state.
    A general rule of thumb is that in production environments, you should always
    use declarative management, either using standard manifest files or Kustomization
    files. You can easily provide source control for your object configurations and
    integrate this into continuous integration/deployment pipelines. Imperative management
    is useful for development and proof-of-concept scenarios—the operations are performed
    directly on a live cluster.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用声明性管理通常更接近Kubernetes的精神 - 整个架构都专注于保持期望的集群状态，并不断执行操作，将当前集群状态更改为期望的状态。一个经验法则是，在生产环境中，您应该始终使用声明性管理，无论是使用标准清单文件还是Kustomization文件。您可以轻松为对象配置提供源代码控制，并将其集成到持续集成/部署流水线中。命令式管理对于开发和概念验证场景非常有用
    - 操作直接在活动集群上执行。
- en: Remember that, for this approach, you will not have an easy way of knowing the
    history of the previous configurations!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对于这种方法，您将无法轻松地了解先前配置的历史！
- en: 'Now, let''s first try the imperative approach for deploying a simple web application.
    We will perform the following operations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们首先尝试使用命令式方法部署一个简单的Web应用程序。我们将执行以下操作：
- en: Create a single bare Pod or a ReplicationController.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个单独的裸Pod或ReplicationController。
- en: Expose it using a Service (LoadBalancer type).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Service（LoadBalancer类型）来公开它。
- en: To create imperatively a pod or a ReplicationController, we will use the `kubectl
    run` command. This command allows you to create different container-management
    objects using generators. You can find the complete list of generators in the
    official documentation: [https://kubernetes.io/docs/reference/kubectl/conventions/#generators](https://kubernetes.io/docs/reference/kubectl/conventions/#generators)—since
    Kubernetes 1.12, all generators apart from `run-pod/v1` are deprecated. The main
    reason for this is the relatively high complexity of the `kubectl run` command
    and the encouragement of a proper, declarative approach for advanced scenarios.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要命令式地创建一个pod或ReplicationController，我们将使用`kubectl run`命令。此命令允许您使用生成器创建不同的容器管理对象。您可以在官方文档中找到生成器的完整列表：[https://kubernetes.io/docs/reference/kubectl/conventions/#generators](https://kubernetes.io/docs/reference/kubectl/conventions/#generators)——自Kubernetes
    1.12以来，除了`run-pod/v1`之外的所有生成器都已被弃用。这样做的主要原因是`kubectl run`命令的相对复杂性，以及鼓励在高级场景中采用适当的声明性方法。
- en: 'To deploy a sample application based on the `mcr.microsoft.com/dotnet/core/samples:aspnetapp`
    Docker image, perform the following steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署基于`mcr.microsoft.com/dotnet/core/samples:aspnetapp` Docker映像的示例应用程序，请执行以下步骤：
- en: Open a PowerShell window and ensure that you are using the `kubeconfig` file,
    which allows you to connect to your AKS Engine hybrid cluster.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开PowerShell窗口，并确保您正在使用`kubeconfig`文件，该文件允许您连接到您的AKS Engine混合集群。
- en: 'Determine which version of the Windows Server operating system is available
    on the nodes in your cluster.For example, for Windows Server 2019 Datacenter nodes,
    you need to use container images that have base layer version 1809\. This means
    that we have to use the `mcr.microsoft.com/dotnet/core/samples:aspnetapp-nanoserver-1809` Docker
    image in our example:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定集群中的节点上可用的Windows Server操作系统的版本。例如，对于Windows Server 2019 Datacenter节点，您需要使用具有基础层版本1809的容器映像。这意味着在我们的示例中，我们必须使用`mcr.microsoft.com/dotnet/core/samples:aspnetapp-nanoserver-1809`
    Docker映像：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Execute the `kubectl run` command with the `run-pod/v1` generator to run a
    single pod, `windows-example`, for the sample application with `nodeSelector`
    set to nodes and the OS type,and `windows`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`run-pod/v1`生成器执行`kubectl run`命令以运行单个pod，`windows-example`，用于具有节点选择器和操作系统类型以及`windows`的示例应用程序：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The pod will be scheduled on one of the Windows nodes, and you can monitor
    the progress of pod creation using the following command:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: pod将被调度到Windows节点之一，并且您可以使用以下命令监视pod创建的进度：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When the pod changes its status to `Running`, you can continue with exposing
    the pod using  the LoadBalancer Service:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当pod将其状态更改为`Running`时，您可以继续使用LoadBalancer服务暴露pod：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Wait for `EXTERNAL-IP` of the service to be available:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待服务的`EXTERNAL-IP`可用：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now you can use the external IP of the service and port `8080` to access the
    application running in the pod. For example, in the web browser, navigate to `http://213.199.135.14:8080/`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以使用服务的外部IP和端口`8080`来访问在pod中运行的应用程序。例如，在Web浏览器中，导航到`http://213.199.135.14:8080/`。
- en: 'Alternatively, the preceding procedure can be performed in only one `kubectl
    run` command, which will create the pod and expose it immediately using the LoadBalancer
    Service:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，前面的步骤可以在一个`kubectl run`命令中完成，该命令将创建pod并立即使用LoadBalancer服务进行暴露：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that this command exposes the service using port `80`, not `8080`. Using
    service port `80` and target port `8080` requires another layer of complexity
    in the `--service-overrides` flag.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此命令使用端口`80`而不是`8080`来暴露服务。使用服务端口`80`和目标端口`8080`需要在`--service-overrides`标志中增加另一层复杂性。
- en: 'For the sake of completeness, let''s run our `mcr.microsoft.com/dotnet/core/samples:aspnetapp-nanoserver-1809`
    container behind a Kubernetes ReplicationController object. You can learn more
    about ReplicationControllers, ReplicaSets, and Deployments in [Chapter 4](118e3c89-786e-4718-ba67-6c38928e2a42.xhtml), *Kubernetes
    Concepts and Windows Support*—in general, it is not advisable to run bare Pods
    in your cluster; you should always manage Pods using at least ReplicaSets or,
    preferably, Deployments. In Kubernetes 1.17, it is still possible to create a
    ReplicationController using `kubectl run`—the generator is deprecated but not
    removed yet. Creating a ReplicationController imperatively requires using a different
    `--generator` flag with the value `run/v1`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，让我们在Kubernetes ReplicationController对象后面运行我们的`mcr.microsoft.com/dotnet/core/samples:aspnetapp-nanoserver-1809`容器。您可以在[第4章](118e3c89-786e-4718-ba67-6c38928e2a42.xhtml)中了解有关ReplicationControllers、ReplicaSets和Deployments的更多信息，*Kubernetes概念和Windows支持*——通常情况下，在集群中运行裸Pods并不明智；您应该始终使用至少ReplicaSets或更好地使用Deployments来管理Pods。在Kubernetes
    1.17中，仍然可以使用`kubectl run`创建ReplicationController——生成器已被弃用，但尚未删除。使用命令来声明式地创建ReplicationController需要使用不同的`--generator`标志，其值为`run/v1`：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Even if this approach is quick and does not require any configuration files,
    you can clearly see that using `kubectl run` for anything else than simple operations
    is getting complex and error-prone. In most cases, you will be using imperative
    commands for the following operations:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这种方法快捷且不需要任何配置文件，你可以清楚地看到，除了简单操作之外，使用`kubectl run`变得复杂且容易出错。在大多数情况下，您将使用命令来执行以下操作：
- en: Quickly creating Pods in your development clusters
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发集群中快速创建Pods
- en: Creating ad hoc interactive Pods for debugging purposes
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了调试目的创建临时交互式Pods
- en: Predictably deleting Kubernetes resources—more on this in the next section
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可预测地删除Kubernetes资源——在下一节中会详细介绍
- en: Let's now perform similar Deployment by using Kubernetes manifest files and
    the declarative management approach.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过使用Kubernetes清单文件和声明式管理方法来执行类似的部署。
- en: Using Kubernetes manifest files
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes清单文件
- en: Declarative management of Kubernetes objects is much closer to the spirit of
    Kubernetes—you focus on telling Kubernetes what you want (describing the desired
    state) instead of directly telling it what to do. As your application grows and
    has more components, managing the cluster using imperative commands becomes impossible.
    It is a much better idea to use imperative commands for read-only operations,
    such as `kubectl describe`, `kubectl get`, and `kubectl logs`, and perform all
    modifications to the clusters desired state using the `kubectl apply` command
    and Kubernetes object configuration files (also known as manifest files).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes对象的声明式管理更接近于Kubernetes的精神——您专注于告诉Kubernetes您想要什么（描述所需状态），而不是直接告诉它要做什么。随着应用程序的增长和组件的增加，使用命令来管理集群变得不可能。最好使用命令来进行只读操作，例如`kubectl
    describe`、`kubectl get`和`kubectl logs`，并使用`kubectl apply`命令和Kubernetes对象配置文件（也称为清单文件）对集群的期望状态进行所有修改。
- en: 'There are a couple of recommended practices when using manifest files:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用清单文件时有一些推荐的做法：
- en: It's preferable to use YAML manifest files over JSON manifest files. YAML is
    easier to manage and more commonly used by Kubernetes community.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最好使用YAML清单文件而不是JSON清单文件。 YAML更容易管理，而且在Kubernetes社区中更常用。
- en: Store your manifest files in source control such as Git. Before applying any
    configuration changes to the cluster, push the changes to the source control first—this
    will make rollbacks and configuration restoration much easier. Eventually, you
    should automate this process as part of your CI/CD pipeline.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的清单文件存储在 Git 等源代码控制中。在将任何配置更改应用到集群之前，先将更改推送到源代码控制中——这将使回滚和配置恢复变得更加容易。最终，您应该将此过程自动化为
    CI/CD 流水线的一部分。
- en: Grouping multiple manifest files into a single file is recommended, whenever
    it makes sense. The official Kubernetes examples repository provides a good demonstration
    of this approach: [https://github.com/kubernetes/examples/blob/master/guestbook/all-in-one/guestbook-all-in-one.yaml](https://github.com/kubernetes/examples/blob/master/guestbook/all-in-one/guestbook-all-in-one.yaml).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个清单文件组合成单个文件是推荐的，只要有意义。官方 Kubernetes 示例存储库提供了这种方法的很好演示：[https://github.com/kubernetes/examples/blob/master/guestbook/all-in-one/guestbook-all-in-one.yaml](https://github.com/kubernetes/examples/blob/master/guestbook/all-in-one/guestbook-all-in-one.yaml).
- en: If you have multiple manifest files for your cluster, you can use `kubectl apply`
    to recursively apply all manifest files in a given directory.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的集群有多个清单文件，您可以使用 `kubectl apply` 递归地应用给定目录中的所有清单文件。
- en: Use `kubectl diff` to understand what changes will be applied to the current
    cluster configuration.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `kubectl diff` 来了解将应用到当前集群配置的变化。
- en: When deleting Kubernetes objects, use the imperative `kubectl delete` command
    as it gives predictable results. You can learn more about the declarative deleting
    of resources in the official documentation but in practice, it is a more risky
    approach: [https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/#how-to-delete-objects](https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/#how-to-delete-objects.).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在删除 Kubernetes 对象时，请使用命令式的 `kubectl delete` 命令，因为它能给出可预测的结果。您可以在官方文档中了解更多关于资源声明式删除的信息，但在实践中，这是一种更具风险的方法：[https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/#how-to-delete-objects](https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/#how-to-delete-objects.).
- en: Use labels whenever possible to semantically describe your components: [https://kubernetes.io/docs/concepts/configuration/overview/#using-labels](https://kubernetes.io/docs/concepts/configuration/overview/#using-labels.).
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用标签来语义化地描述您的组件：[https://kubernetes.io/docs/concepts/configuration/overview/#using-labels](https://kubernetes.io/docs/concepts/configuration/overview/#using-labels.).
- en: More best practices regarding manifest files can be found in the official documentation: [https://kubernetes.io/docs/concepts/configuration/overview/](https://kubernetes.io/docs/concepts/configuration/overview/).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 关于清单文件的更多最佳实践可以在官方文档中找到：[https://kubernetes.io/docs/concepts/configuration/overview/](https://kubernetes.io/docs/concepts/configuration/overview/).
- en: 'Now, let''s try demonstrating this approach by deploying an application similar
    to the one in the last section. This time, we will use Deployment and service
    objects, which will be defined in separate manifest files—in a real-world scenario,
    you would group these two manifest files into a single file, but for demonstration
    purposes, it makes sense to separate them. Follow these steps to deploy the application:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试通过部署一个类似上一节中的应用程序来演示这种方法。这次，我们将使用 Deployment 和 service 对象，它们将在单独的清单文件中定义——在实际场景中，您可能会将这两个清单文件组合成一个文件，但出于演示目的，将它们分开是有意义的。按照以下步骤部署应用程序：
- en: Open a PowerShell window.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 PowerShell 窗口。
- en: Ensure that your cluster is not running resources from the previous section—you
    can check that using the `kubectl get all` command and delete them using the `kubectl
    delete` command.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的集群没有运行上一节中的资源——您可以使用 `kubectl get all` 命令来检查并使用 `kubectl delete` 命令来删除它们。
- en: 'Create a directory for your manifest files, for example, `declarative-demo`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为清单文件创建一个目录，例如`declarative-demo`：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create the `windows-example-deployment.yaml` manifest file, which contains
    the Deployment definition:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含部署定义的`windows-example-deployment.yaml`清单文件：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create the `windows-example-service.yaml` manifest file, which contains the
    LoadBalancer Service definition:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含LoadBalancer服务定义的`windows-example-service.yaml`清单文件：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Apply the manifest files in the current directory using the `kubectl apply`
    command. Note that if you had a multi-level directory hierarchy, you could use
    the `-R` flag for recursive processing:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl apply`命令在当前目录中应用清单文件。请注意，如果您有多级目录层次结构，您可以使用`-R`标志进行递归处理：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use the following command to wait for the service''s external IP to be available:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令等待服务的外部IP可用：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Use your web browser to navigate to the external IP and port `8080`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的网络浏览器导航到外部IP和端口`8080`。
- en: 'Now, let''s see how you can apply a simple change to your application using
    the declarative approach—we would like to change the LoadBalancer port to `9090`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用声明式方法对应用程序进行简单更改——我们想将LoadBalancer端口更改为`9090`：
- en: Open the `windows-example-service.yaml` manifest file.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开包含LoadBalancer服务定义的`windows-example-service.yaml`清单文件。
- en: Modify the `spec.ports[0].port` value to `9090`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`spec.ports[0].port`值修改为`9090`。
- en: Save the manifest file.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存清单文件。
- en: '(Optional but recommended) Verify your changes using the `kubectl diff` command.
    Remember that you need to have an appropriate *diff* tool installed and defined
    in the `$env:KUBECTL_EXTERNAL_DIFF` environment variable; you can learn more about
    this in [Chapter 6](791e78c0-f625-4232-9907-36e25ec2767d.xhtml), *Interacting
    with Kubernetes Clusters*:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选但建议）使用`kubectl diff`命令验证您的更改。请记住，您需要安装并在`$env:KUBECTL_EXTERNAL_DIFF`环境变量中定义适当的*diff*工具；您可以在[第6章](791e78c0-f625-4232-9907-36e25ec2767d.xhtml)中了解更多信息，*与Kubernetes集群交互*：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Apply the manifest files again:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次应用清单文件：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that only `service/windows-example` has been detected as changed in the
    desired configuration.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，只有`service/windows-example`被检测为所需配置中的更改。
- en: Now, you can navigate in the web browser to the external IP address and port
    `9090` to verify the changes.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以在网络浏览器中导航到外部IP地址和端口`9090`以验证更改。
- en: 'If you want to delete all of the resources that have been created by manifest
    files in the current directory, you can use the following command:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想删除当前目录中由清单文件创建的所有资源，可以使用以下命令：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That's it! As you can see, declarative management may require a bit more of
    boilerplate configuration but, in the end, managing the applications using this
    approach is much more predictable and easier to track.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！正如您所看到的，声明式管理可能需要更多的样板配置，但最终，使用这种方法管理应用程序更加可预测和易于跟踪。
- en: When managing complex applications running in multiple environments, consider
    using Kustomization files (which can be used with the `kubectl apply` command)
    or Helm Charts. For example, with Kustomization files, you can organize the configuration
    files in a convention-friendly directory structure: [https://kubectl.docs.kubernetes.io/pages/app_composition_and_deployment/structure_directories.html](https://kubectl.docs.kubernetes.io/pages/app_composition_and_deployment/structure_directories.html).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理在多个环境中运行的复杂应用程序时，考虑使用Kustomization文件（可与`kubectl apply`命令一起使用）或Helm Charts。例如，使用Kustomization文件，您可以将配置文件组织在一个符合约定的目录结构中：[https://kubectl.docs.kubernetes.io/pages/app_composition_and_deployment/structure_directories.html](https://kubectl.docs.kubernetes.io/pages/app_composition_and_deployment/structure_directories.html)。
- en: In the next section, we will take a quick look at the recommended practices
    regarding scheduling Pods on Windows nodes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将简要介绍关于在Windows节点上调度Pod的推荐做法。
- en: Scheduling Pods on Windows nodes
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows节点上调度Pods
- en: 'To schedule Pods on nodes with specific properties, Kubernetes gives you a
    few possible options:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要在具有特定属性的节点上调度Pods，Kubernetes为您提供了一些可能的选项：
- en: Using `nodeName` in the Pod specification. This is the simplest form of statically
    scheduling Pods on a given node and is generally not recommended.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Pod规范中使用`nodeName`。这是在给定节点上静态调度Pods的最简单形式，通常不建议使用。
- en: Using `nodeSelector` in the pod specification. This gives you the possibility
    to schedule your pod only on nodes that have certain label values. We have been
    already using this approach in the previous section.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Pod规范中使用`nodeSelector`。这使您有可能仅在具有特定标签值的节点上调度您的Pod。我们在上一节中已经使用了这种方法。
- en: 'Node affinity and anti-affinity: These concepts expand the `nodeSelector` approach
    and provide a richer language of defining which nodes are preferred or avoided
    for your pod. You can read more about the possibilities in the official documentation: [https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity](https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点亲和性和反亲和性：这些概念扩展了`nodeSelector`方法，并提供了更丰富的语言来定义哪些节点是首选或避免为您的Pod。您可以在官方文档中了解更多可能性：[https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity](https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity)。
- en: 'Node taints and pod tolerations: They provide an opposite functionality to
    node affinity—you apply a taint to a given node (which describes some kind of
    limitation) and the pod must have a specific toleration defined to be schedulable
    on the tainted node.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点污点和Pod容忍度：它们提供了与节点亲和性相反的功能-您将一个污点应用于给定节点（描述某种限制），Pod必须具有特定的容忍度才能在被污染的节点上调度。
- en: 'Scheduling Pods in hybrid Windows/Linux clusters requires at least using `nodeSelector`
    or a combination of node taints with `nodeSelector`. Every Kubernetes node comes
    by default with a set of labels, which include the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在混合Windows/Linux集群中调度Pods至少需要使用`nodeSelector`或一组带有`nodeSelector`的节点污点的组合。每个Kubernetes节点默认都带有一组标签，其中包括以下内容：
- en: '`kubernetes.io/arch`, which describes the node''s processor architecture, for
    example, `amd64` or `arm`: This is also defined as `beta.kubernetes.io/arch`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubernetes.io/arch`，描述节点的处理器架构，例如`amd64`或`arm`：这也被定义为`beta.kubernetes.io/arch`。'
- en: '`kubernetes.io/os`, which has a value of `linux` or `windows`: This is also
    defined as `beta.kubernetes.io/os`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubernetes.io/os`，其值为`linux`或`windows`：这也被定义为`beta.kubernetes.io/os`。'
- en: 'You can check the default labels for your Windows node (for example, `7001k8s011`)
    in your AKS Engine cluster using the following command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令在AKS Engine集群中检查Windows节点（例如`7001k8s011`）的默认标签：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If your pod does not contain `nodeSelector` in the specification, it can be
    scheduled on both Windows and Linux nodes— this is a problem as Windows containers
    will not start on Linux nodes and vice versa. The recommended practice is using
    `nodeSelector` for the predictable scheduling of your Pods for both Windows and
    Linux containers. For example, in the Deployment definition, the pod template
    may contain the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Pod规范中不包含`nodeSelector`，它可以在Windows和Linux节点上都可以调度-这是一个问题，因为Windows容器不会在Linux节点上启动，反之亦然。建议的做法是使用`nodeSelector`来可预测地调度您的Pods，无论是Windows还是Linux容器。例如，在部署定义中，Pod模板可能包含以下内容：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Alternatively, you can use, in the latest versions of Kubernetes, the `"kubernetes.io/os":
    windows` selector. For Linux containers, you need to specify `"beta.kubernetes.io/os":
    linux` or `"kubernetes.io/os": linux`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '或者，您可以在Kubernetes的最新版本中使用`"kubernetes.io/os": windows`选择器。对于Linux容器，您需要指定`"beta.kubernetes.io/os":
    linux`或`"kubernetes.io/os": linux`。'
- en: 'This approach may cause problems when you are adding Windows nodes to existing
    large, Linux-only clusters, using Helm Charts or Kubernetes Operators—such workloads
    may not have the Linux node selector specified out of the box. To solve this issue,
    you can use taints and tolerations: mark your Windows nodes with a specific `NoSchedule`
    taints and use matching toleration for your Pods. We will use taint with the `os` key and
    a value of `Win1809`  for this purpose.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将Windows节点添加到现有的大型Linux-only集群中时，这种方法可能会导致问题，使用Helm Charts或Kubernetes Operators
    - 这些工作负载可能没有默认指定Linux节点选择器。为了解决这个问题，您可以使用污点和容忍：使用特定的`NoSchedule`污点标记您的Windows节点，并为您的Pod使用匹配的容忍。我们将使用带有`os`键和值`Win1809`的污点来实现这个目的。
- en: 'To taint Windows nodes, you have two possibilities:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于污点Windows节点，您有两种可能性：
- en: Taint the node at registration level using the `--register-with-taints='os=Win1809:NoSchedule'`
    flag for kubelet. Note that this approach is currently not available in AKS Engine
    as `--register-with-taints` is not user-configurable—you can read more in the
    documentation: [https://github.com/Azure/aks-engine/blob/master/docs/topics/clusterdefinitions.md#kubeletconfig](https://github.com/Azure/aks-engine/blob/master/docs/topics/clusterdefinitions.md#kubeletconfig).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在kubelet的注册级别上使用`--register-with-taints='os=Win1809:NoSchedule'`标志对节点进行污点。请注意，这种方法目前在AKS
    Engine中不可用，因为`--register-with-taints`不是用户可配置的 - 您可以在文档中阅读更多信息：[https://github.com/Azure/aks-engine/blob/master/docs/topics/clusterdefinitions.md#kubeletconfig](https://github.com/Azure/aks-engine/blob/master/docs/topics/clusterdefinitions.md#kubeletconfig)。
- en: Taint the node using kubectl. You can add a taint using the following command: `kubectl
    taint nodes <nodeName> os=Win1809:NoSchedule` and remove it using `kubectl taint
    nodes 7001k8s011 os:NoSchedule-`.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用kubectl对节点进行污点。您可以使用以下命令添加一个污点：`kubectl taint nodes <nodeName> os=Win1809:NoSchedule`，并使用`kubectl
    taint nodes 7001k8s011 os:NoSchedule-`来删除它。
- en: 'Then, your Deployment definition would have to specify the appropriate pod
    node selector for Windows and taint toleration, which allows scheduling on Windows
    nodes:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您的部署定义将不得不为Windows指定适当的Pod节点选择器和污点容忍，以允许在Windows节点上调度：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this approach, for Linux containers, you do not need to specify any node
    selector or taint toleration. However, if possible, it is recommended to use the
    node selector approach without node taints, especially if you are building a new
    cluster.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，对于Linux容器，您不需要指定任何节点选择器或污点容忍。但是，如果可能的话，建议使用节点选择器方法而不使用节点污点，特别是如果您正在构建一个新的集群。
- en: In the next section, we will take a look at how you can access your application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何访问您的应用程序。
- en: Accessing your application
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问您的应用程序
- en: 'For accessing your application running in a pod, you have a few possibilities
    depending on your scenario. In debugging and testing scenarios, you can access
    your application in the following simple ways:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问在Pod中运行的应用程序，根据您的情况，您有一些可能性。在调试和测试场景中，您可以通过以下简单的方式访问您的应用程序：
- en: Use `kubectl exec` to create an ad hoc, interactive pod. We used this approach
    in the previous chapters.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`kubectl exec`来创建一个临时的交互式Pod。我们在之前的章节中使用了这种方法。
- en: Use `kubectl proxy` to access any service type. This approach works only for
    HTTP(S) endpoints as it uses proxy functionality provided by Kubernetes API Server.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`kubectl proxy`来访问任何服务类型。这种方法仅适用于HTTP(S)端点，因为它使用Kubernetes API服务器提供的代理功能。
- en: Use `kubectl port-forward`. You can use this approach to access individual Pods
    or Pods running in a Deployment or behind a service.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`kubectl port-forward`。您可以使用这种方法来访问单个Pod或在部署或服务后面运行的Pod。
- en: 'If you would like to expose the application for end users in production, you
    can use the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要为生产环境的最终用户公开应用程序，您可以使用以下方法：
- en: 'A service object with the LoadBalancer or NodePort type: We have already demonstrated
    how to use the LoadBalancer Service in the previous section.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有LoadBalancer或NodePort类型的服务对象：我们已经在上一节中演示了如何使用LoadBalancer服务。
- en: 'Using an Ingress Controller together with a service of the ClusterIP type:
    This approach reduces the number of cloud load balancers used (resulting in reduced
    operational costs) and performs load balancing and routing inside the Kubernetes
    cluster. Note that this approach uses L7 load balancing so it can be used for
    exposing HTTP(S) endpoints only.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ingress Controller与ClusterIP类型的服务一起使用：这种方法减少了使用的云负载均衡器的数量（从而降低了运营成本），并在Kubernetes集群内执行负载均衡和路由。请注意，这种方法使用L7负载均衡，因此只能用于暴露HTTP（S）端点。
- en: You can learn in detail about services and Ingress Controllers in [Chapter 5](da2ee6af-a754-4fc8-ae62-86d8e68f0bd0.xhtml), *Kubernetes
    Networking*. Later in this section, we will demonstrate how to use an Ingress
    Controller for the demo application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在《Kubernetes网络》[第5章](da2ee6af-a754-4fc8-ae62-86d8e68f0bd0.xhtml)中详细了解服务和Ingress
    Controller。在本节的后面，我们将演示如何为演示应用程序使用Ingress Controller。
- en: You can read more about accessing applications running in the cluster in various
    scenarios in the official documentation: [https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-services/#accessing-services-running-on-the-cluster](https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-services/#accessing-services-running-on-the-cluster).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中了解有关在集群中运行的应用程序的访问的更多信息：[https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-services/#accessing-services-running-on-the-cluster](https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-services/#accessing-services-running-on-the-cluster)。
- en: 'Let''s first demonstrate how to use `kubectl proxy` and `kubectl port-forward`.
    Perform the following steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先演示如何使用`kubectl proxy`和`kubectl port-forward`。执行以下步骤：
- en: Open a Powershell window.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个Powershell窗口。
- en: Ensure that the demonstration application from the previous sections is deployed
    and has a `windows-example` service with port `8080` deployed in the cluster.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保之前部分中的演示应用程序已部署，并且在集群中部署了一个端口为`8080`的`windows-example`服务。
- en: 'Run the `kubectl proxy` command:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`kubectl proxy`命令：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will expose a simple proxy server on your localhost machine on port `8001`
    to the remote Kubernetes API Server. You can freely use the API using this endpoint,
    without additional authentication. Note that using a raw API without a proxy is
    also possible but then you have to handle the authentication yourself ([https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/](https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/)).
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在本地主机的端口`8001`上暴露一个简单的代理服务器到远程Kubernetes API服务器。您可以自由地使用此端点使用API，无需额外的身份验证。请注意，也可以使用原始API而不使用代理，但那样您就必须自己处理身份验证（[https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/](https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/)）。
- en: Your service will be available at `http://<proxyEndpoint>/api/v1/namespaces/<namespaceName>/services/[https:]<serviceName>[:portName]/proxy`.
    In our case, navigate to `http://127.0.0.1:8001/api/v1/namespaces/default/services/windows-example/proxy/`.
    This approach works for any service type, including just internal ClusterIPs.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的服务将在`http://<proxyEndpoint>/api/v1/namespaces/<namespaceName>/services/[https:]<serviceName>[:portName]/proxy`上可用。在我们的情况下，导航到`http://127.0.0.1:8001/api/v1/namespaces/default/services/windows-example/proxy/`。这种方法适用于任何服务类型，包括仅内部ClusterIPs。
- en: Terminate the `kubectl proxy` process.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终止`kubectl proxy`进程。
- en: 'Now, execute the following `kubectl port-forward` command:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行以下`kubectl port-forward`命令：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will forward any network traffic from your localhost `5000` port to `8080`
    on the `windows-example` service. For example, you can navigate to `http://127.0.0.1:5000/`
    in your web browser. Note that this approach will also work for different protocols
    than HTTP(S).
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将把来自您的本地主机`5000`端口的任何网络流量转发到`windows-example`服务的`8080`端口。例如，您可以在Web浏览器中导航到`http://127.0.0.1:5000/`。请注意，这种方法也适用于HTTP(S)以外的不同协议。
- en: Terminate the `kubectl port-forward` process.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终止`kubectl port-forward`进程。
- en: 'Now, let''s see how to use Ingress Controller to access the demo application.
    Using Ingress is highly customizable and there are multiple Ingress Controllers
    available—we will demonstrate the quickest way to get up and running on AKS Engine
    hybrid cluster using `ingress-nginx` ([https://www.nginx.com/products/nginx/kubernetes-ingress-controller](https://www.nginx.com/products/nginx/kubernetes-ingress-controller)).
    Please note that this approach limits the Deployment of Ingress Controllers to
    Linux nodes only—you will be able to create Ingress objects for services running
    on Windows nodes but all of the load balancing will be performed on Linux nodes.
    Follow these steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用Ingress Controller来访问演示应用程序。使用Ingress是高度可定制的，有多个可用的Ingress Controllers——我们将演示在AKS
    Engine混合集群上快速启动和运行`ingress-nginx`（[https://www.nginx.com/products/nginx/kubernetes-ingress-controller](https://www.nginx.com/products/nginx/kubernetes-ingress-controller)）。请注意，这种方法将Ingress
    Controllers的部署限制在Linux节点上——您将能够为运行在Windows节点上的服务创建Ingress对象，但所有的负载均衡将在Linux节点上执行。按照以下步骤：
- en: 'Modify the `windows-example-service.yaml` manifest file so that it has `type:
    ClusterIP`, `port: 80`, and no `targetPort`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '修改`windows-example-service.yaml`清单文件，使其具有`type: ClusterIP`，`port: 80`，并且没有`targetPort`：'
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Apply your modifications to the cluster:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的修改应用到集群中：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Apply the official generic manifest file for ingress-nginx, which creates a
    Deployment with one replica running on Linux nodes:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用官方的通用清单文件用于ingress-nginx，它在Linux节点上创建一个具有一个副本的部署：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Apply the official cloud-specific manifest file for ingress-nginx. This will
    create a service of the LoadBalancer type, which will be used for the Ingress
    Controller:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 申请官方的云特定清单文件用于ingress-nginx。这将创建一个LoadBalancer类型的服务，用于Ingress Controller：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Wait for the Ingress Controller service to receive an external IP address.The
    external IP address `104.40.133.125` will be used for all services that are configured
    to run behind this Ingress Controller:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待Ingress Controller服务接收外部IP地址。外部IP地址`104.40.133.125`将用于所有配置在此Ingress Controller后运行的服务：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create the `windows-example-ingress.yaml` manifest file and define the Ingress
    object. The `windows-example` service for our application will be registered under
    the `<ingressLoadBalancerIp>/windows-example` path:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`windows-example-ingress.yaml`清单文件并定义Ingress对象。我们的应用程序的`windows-example`服务将在`<ingressLoadBalancerIp>/windows-example`路径下注册：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Apply the changes:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用更改：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Navigate to `http://104.40.133.125/windows-example` to test the Ingress definition.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`http://104.40.133.125/windows-example`来测试Ingress定义。
- en: Of course, you can create multiple Ingress objects with complex rules for different
    services. A general rule of thumb is that you should use an Ingress Controller
    to expose your HTTP(S) endpoints whenever possible and use dedicated LoadBalancer
    services for other protocols.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以为不同的服务创建多个Ingress对象，具有复杂的规则。一个经验法则是，尽可能使用Ingress Controller来公开您的HTTP(S)端点，并为其他协议使用专用的LoadBalancer服务。
- en: Now, let's take a look at how you can scale your application!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何扩展您的应用程序！
- en: Scaling the application
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展应用程序
- en: 'In production scenarios, you will definitely need to scale your application—this
    is where Kubernetes is powerful; you can either manually scale your application
    or use autoscaling. Let''s first take a look at how to perform the manual scaling
    of your Deployment. You can do it either imperatively or declaratively. To perform
    scaling by using an imperative command in PowerShell, perform these steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产场景中，您肯定需要扩展您的应用程序 - 这就是 Kubernetes 强大之处；您可以手动扩展您的应用程序，也可以使用自动缩放。让我们首先看看如何执行部署的手动扩展。您可以通过命令或声明性地执行。要使用
    PowerShell 中的命令执行扩展操作，请执行以下步骤：
- en: 'Execute the `kubectl scale` command, which will scale the `windows-example` Deployment
    to three replicas:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `kubectl scale` 命令，将 `windows-example` 部署扩展到三个副本：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now watch how the Pods are being added to your Deployment:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在观察 Pods 如何被添加到您的部署中：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can perform a similar operation in a declarative manner, which is generally
    recommended. Let''s scale the application further to four replicas:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以以声明性的方式执行类似的操作，这通常是推荐的。让我们进一步将应用程序扩展到四个副本：
- en: Edit the `windows-example-deployment.yaml` manifest file and modify `replicas`
    to `4`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `windows-example-deployment.yaml` 清单文件，并将 `replicas` 修改为 `4`。
- en: 'Save the manifest file and apply the changes:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存清单文件并应用更改：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Again, use the `kubectl get pods -w` command to observe how the application
    is scaled up.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用 `kubectl get pods -w` 命令观察应用程序如何扩展。
- en: 'The true power of Kubernetes comes with autoscaling. We will cover autoscaling
    in more detail in [Chapter 11](9ad8c38e-6d0d-435b-a46c-82a468f18007.xhtml), *Configuring
    Applications to Use Kubernetes Features*, so in this section, we will give only
    a short overview of how to do it using an imperative command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的真正力量在于自动缩放。我们将在[第 11 章](9ad8c38e-6d0d-435b-a46c-82a468f18007.xhtml)
    *配置应用程序使用 Kubernetes 功能* 中更详细地介绍自动缩放，因此在本节中，我们只会简要概述如何使用命令来执行它：
- en: 'First, you need to configure the CPU resource limits for the pod template in
    the Deployment—set this to a small value, for example, `100m`. Without CPU resource
    limits, autoscaling will be not able to apply the scaling policy properly:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要为部署中的 pod 模板配置 CPU 资源限制 - 将其设置为一个小值，例如 `100m`。如果没有 CPU 资源限制，自动缩放将无法正确应用扩展策略：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Apply the modifications:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用修改：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Execute the following `kubectl autoscale` command:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下 `kubectl autoscale` 命令：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will create a **Horizontal Pod Autoscaler** (**HPA**) object in the cluster
    with the default algorithm, a minimum of 1 replica, a maximum of 5 replicas, and
    configuration based on a target CPU usage of 15% of the limit.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在集群中创建一个**水平 Pod 自动缩放器**（HPA）对象，采用默认算法，最少 1 个副本，最多 5 个副本，并基于目标 CPU 使用率的 15%
    的限制进行配置。
- en: 'Use the following command to check the state of the HPA:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令来检查 HPA 的状态：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can try to add some CPU load to your Pods by frequently refreshing the application
    web page. Note that if you are using Ingress, you will hit the cache at the Ingress
    Controller so the CPU usage may not increase in such a scenario.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以尝试通过频繁刷新应用程序网页向您的 Pod 添加一些 CPU 负载。请注意，如果您使用 Ingress，您将命中 Ingress 控制器的缓存，因此在这种情况下
    CPU 使用率可能不会增加。
- en: 'After some time, you will see that autoscaling kicks in and adds more replicas.
    When you decrease the load, the Deployment will be scaled down. You can check
    the timeline using the `kubectl describe` command:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过一段时间，您会看到自动缩放开始并添加更多副本。当您减少负载时，部署将被缩减。您可以使用 `kubectl describe` 命令来检查时间线：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Delete the HPA object to turn off autoscaling using this command:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此命令删除 HPA 对象以关闭自动缩放：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For managed AKS instances, it is possible to leverage the **node-level** autoscaling
    feature ([https://docs.microsoft.com/en-us/azure/aks/cluster-autoscaler](https://docs.microsoft.com/en-us/azure/aks/cluster-autoscaler)),
    which brings another dimension of scalability for your workloads. Additionally,
    you can consider using AKS workloads with Azure Container Instances ([https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/scale-using-aks-with-aci](https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/scale-using-aks-with-aci)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于托管的AKS实例，可以利用**节点级**自动缩放功能（[https://docs.microsoft.com/en-us/azure/aks/cluster-autoscaler](https://docs.microsoft.com/en-us/azure/aks/cluster-autoscaler)），为您的工作负载带来了另一个可伸缩性维度。此外，您可以考虑使用Azure容器实例（ACI）与AKS工作负载（[https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/scale-using-aks-with-aci](https://docs.microsoft.com/en-us/azure/architecture/solution-ideas/articles/scale-using-aks-with-aci)）。
- en: Congratulations! You have successfully deployed and autoscaled your first application
    on an AKS Engine hybrid Kubernetes cluster.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功在AKS Engine混合Kubernetes集群上部署和自动缩放了您的第一个应用程序。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has given a brief introduction to how to deploy and manage Windows
    container applications running on an AKS Engine hybrid cluster. You learned  the
    differences between imperative and declarative management of cluster configuration
    and when to use each of them. We have used both approaches to deploy a demonstration
    application—now you know that the recommended declarative approach is easier and
    less error-prone than using imperative commands. Next, you learned how to predictably
    schedule Pods on Windows nodes and how to approach adding Windows container workloads
    to existing Kubernetes clusters. And lastly, we have shown how to access applications
    running in Kubernetes both for end users and developers and how to scale applications
    manually and automatically.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了如何在AKS Engine混合集群上部署和管理运行Windows容器应用程序。您学会了命令式和声明式集群配置管理的区别以及何时使用它们。我们已经使用了这两种方法来部署演示应用程序-现在您知道推荐的声明式方法比使用命令式命令更容易，更不容易出错。接下来，您将学习如何可预测地在Windows节点上安排Pod，并如何处理将Windows容器工作负载添加到现有Kubernetes集群。最后，我们展示了如何访问在Kubernetes中运行的应用程序，供最终用户和开发人员使用，以及如何手动和自动扩展应用程序。
- en: In the next chapter, we will utilize all of this new knowledge to deploy a real
    .NET Framework application to our Kubernetes cluster!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将利用所有这些新知识来将一个真正的.NET Framework应用程序部署到我们的Kubernetes集群！
- en: Questions
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between imperative and declarative management for Kubernetes
    objects?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes对象的命令式和声明式管理有什么区别？
- en: When is using imperative commands  recommended?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时推荐使用命令式命令？
- en: How do you see the changes between local manifest files and the current cluster
    state?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何查看本地清单文件和当前集群状态之间的更改？
- en: What is the recommended practice to schedule Pods in hybrid clusters?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在混合集群中安排Pod的推荐做法是什么？
- en: What is the difference between the `kubectl proxy` and `kubectl port-forward`
    commands?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl proxy`和`kubectl port-forward`命令之间有什么区别？'
- en: When can you use an Ingress Controller?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时可以使用Ingress Controller？
- en: How do you scale a deployment manually?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何手动扩展部署？
- en: You can find answers to these questions in *Assessments* of this book.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的*评估*中找到这些问题的答案。
- en: Further reading
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about Kubernetes applications management, please refer
    to the following Packt books:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Kubernetes应用程序管理的更多信息，请参考以下Packt图书：
- en: '*The Complete Kubernetes Guide* ([https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide))'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《完整的Kubernetes指南》（[https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide)）
- en: '*Getting Started with Kubernetes -Third Editi*on ([https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition))'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes入门-第三版（[https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition)）
- en: '*Kubernetes for Developers* ([https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers))'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向开发人员的Kubernetes*（[https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers)）'
- en: 'Currently, most of the resources regarding hybrid Windows/Linux clusters running
    on AKS Engine are available online. Please check the official documentation on
    GitHub for more details:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，关于在AKS Engine上运行的混合Windows/Linux集群的大多数资源都可以在线获得。请查看GitHub上的官方文档以获取更多详细信息：
- en: '[https://github.com/Azure/aks-engine/blob/master/docs/topics/windows.md](https://github.com/Azure/aks-engine/blob/master/docs/topics/windows.md)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/Azure/aks-engine/blob/master/docs/topics/windows.md](https://github.com/Azure/aks-engine/blob/master/docs/topics/windows.md)'
- en: '[https://github.com/Azure/aks-engine/blob/master/docs/topics/windows-and-kubernetes.md](https://github.com/Azure/aks-engine/blob/master/docs/topics/windows-and-kubernetes.md)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/Azure/aks-engine/blob/master/docs/topics/windows-and-kubernetes.md](https://github.com/Azure/aks-engine/blob/master/docs/topics/windows-and-kubernetes.md)'
- en: 'In general, many of the topics concerning AKS (the managed Kubernetes Azure
    offering, not AKS Engine itself) are useful, as they touch on how to integrate
    Kubernetes with the Azure ecosystem. You can find more about AKS itself in the
    following Packt book:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般来说，许多关于AKS（托管的Kubernetes Azure提供的内容，而不是AKS Engine本身）的主题都很有用，因为它们涉及如何将Kubernetes与Azure生态系统集成。您可以在以下Packt书籍中找到有关AKS本身的更多信息：
- en: '*DevOps with Kubernetes – Second Edition* ([https://www.packtpub.com/virtualization-and-cloud/devops-kubernetes-second-edition](https://www.packtpub.com/virtualization-and-cloud/devops-kubernetes-second-edition))'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Kubernetes进行DevOps-第二版*（[https://www.packtpub.com/virtualization-and-cloud/devops-kubernetes-second-edition](https://www.packtpub.com/virtualization-and-cloud/devops-kubernetes-second-edition)）'
