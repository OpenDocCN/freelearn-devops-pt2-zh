- en: Understanding the Fundamentals of Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Ansible的基础知识
- en: 'Ansible is, at its heart, a simple framework that pushes a small program called
    an **Ansible module** to target nodes. Modules are at the heart of Ansible and
    are responsible for performing all of the automation''s hard work. The Ansible
    framework goes beyond this, however, and also includes plugins and dynamic inventory
    management, as well as tying all of this together with playbooks to automate infrastructure
    provisioning, configuration management, application deployment, network automation,
    and much more, as shown:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Ansible是一个简单的框架，它将一个称为**Ansible模块**的小程序推送到目标节点。模块是Ansible的核心，负责执行所有自动化的繁重工作。然而，Ansible框架不仅限于此，还包括插件和动态清单管理，以及使用playbooks将所有这些内容与一起自动化基础设施的配置管理、应用部署、网络自动化等联系起来，如下所示：
- en: '![](Images/075a1fbf-b62c-4730-8456-c81515ebb75c.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/075a1fbf-b62c-4730-8456-c81515ebb75c.png)'
- en: Ansible only needs to be installed on the management node; from there, it distributes
    the required modules over the network's transport layer (usually SSH or WinRM)
    to perform tasks and deletes them once the tasks are complete. In this way, Ansible
    retains its agentless architecture and does not clutter up your target nodes with
    code that might be required for a one-off automation task.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible只需要安装在管理节点上；从那里，它通过网络传输层（通常是SSH或WinRM）分发所需的模块来执行任务，并在任务完成后删除它们。通过这种方式，Ansible保持了无代理的架构，并且不会用可能需要进行一次性自动化任务的代码来混淆目标节点。
- en: In this chapter, you will learn more about the composition of the Ansible framework
    and its various components, as well as how to use them together in playbooks written
    in YAML syntax. So, you will learn how to create automation code for your IT operations
    tasks and learn how to apply this using both ad hoc tasks and more complex playbooks.
    Finally, you will learn how Jinja2 templating allows you to repeatably build dynamic
    configuration files using variables and dynamic expressions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将更多地了解Ansible框架的组成及其各个组件，以及如何在使用YAML语法编写的playbooks中将它们结合在一起。因此，您将学习如何为IT操作任务创建自动化代码，并学习如何使用临时任务和更复杂的playbooks应用它们。最后，您将学习Jinja2模板如何允许您使用变量和动态表达式重复构建动态配置文件。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting familiar with the Ansible framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉Ansible框架
- en: Exploring the configuration file
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索配置文件
- en: Command-line arguments
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行参数
- en: Defining variables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义变量
- en: Understanding Jinja2 filters
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Jinja2过滤器
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have successfully installed the latest version
    of Ansible (2.9, at the time of writing) onto a Linux node, as discussed in [Chapter
    1](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml), *Getting Started with Ansible*.
    It also assumes that you have at least one other Linux host to test automation
    code on; the more hosts you have available, the more you will be able to develop
    the examples in this chapter and learn about Ansible. SSH communication between
    the Linux hosts is assumed, as is a working knowledge of them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已成功将最新版本的Ansible（在撰写本文时为2.9）安装到Linux节点上，如[第1章](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml)中所讨论的*开始使用Ansible*。它还假设您至少有另一台Linux主机用于测试自动化代码；您拥有的主机越多，您就能够开发本章中的示例并了解Ansible的内容就越多。假定Linux主机之间存在SSH通信，并且对它们有一定的了解。
- en: The code bundle for this chapter is available at [https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%202](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%202).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包可在[https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%202](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%202)获取。
- en: Getting familiar with the Ansible framework
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉Ansible框架
- en: In this section, you will understand how the Ansible framework fits into IT
    operations automation. We will explain how to start Ansible for the first time.
    Once you understand this framework, you will be ready to start learning more advanced
    concepts, such as creating and running playbooks with your own inventory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解Ansible框架如何适用于IT操作自动化。我们将解释如何首次启动Ansible。一旦您了解了这个框架，您就准备好开始学习更高级的概念，比如创建和运行自己清单的playbooks。
- en: 'In order to run Ansible''s ad hoc commands via an SSH connection from your
    Ansible control machine to multiple remote hosts, you need to ensure you have
    the latest Ansible version installed on the control host. Use the following command
    to confirm the latest Ansible version:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过SSH连接从Ansible控制机器运行Ansible的临时命令到多个远程主机，您需要确保控制主机上安装了最新的Ansible版本。使用以下命令确认最新的Ansible版本：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You also need to ensure SSH connectivity with each remote host that you will
    define in the inventory. You can use a simple, manual SSH connection on each of
    your remote hosts to test the connectivity, as Ansible will make use of SSH during
    all remote Linux-based automation tasks:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要确保与清单中定义的每个远程主机建立SSH连接。您可以在每个远程主机上使用简单的手动SSH连接来测试连接性，因为在所有远程基于Linux的自动化任务中，Ansible将使用SSH：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this section, we will walk you through how Ansible works, starting with
    some simple connectivity testing. You can learn how the Ansible framework accesses
    multiple host machines to execute your tasks by following this simple procedure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将带您了解Ansible的工作原理，从一些简单的连接测试开始。您可以通过以下简单步骤了解Ansible框架如何访问多个主机来执行您的任务：
- en: 'Create or edit your default inventory file, `/etc/ansible/hosts` (you can also
    specify the path with your own inventory file by passing options such as `–-inventory=/path/inventory_file`).
    Add some example hosts to your inventory—these must be the IP addresses or hostnames
    of real machines for Ansible to test against. The following are examples from
    my network, but you need to substitute these for your own devices. Add one hostname
    (or IP address) per line:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或编辑您的默认清单文件`/etc/ansible/hosts`（您也可以通过传递选项，如`--inventory=/path/inventory_file`来指定自己的清单文件的路径）。在清单中添加一些示例主机——这些必须是Ansible要测试的真实机器的IP地址或主机名。以下是我网络中的示例，但您需要用自己的设备替换这些。每行添加一个主机名（或IP地址）：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'All hosts should be specified with a resolvable address—that is, a **Fully
    Qualified Domain Name** (**FQDN**)—if your hosts have DNS entries (or are in `/etc/hosts`
    on your Ansible control node). This can be IP addresses if you do not have DNS
    or host entries set up. Whatever format you choose for your inventory addresses,
    you should be able to successfully ping each host. See the following output as
    an example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主机都应该使用可解析的地址来指定——即**完全合格的域名**（**FQDN**）——如果您的主机有DNS条目（或者在您的Ansible控制节点上的`/etc/hosts`中）。如果您没有设置DNS或主机条目，这可以是IP地址。无论您选择哪种格式作为清单地址，您都应该能够成功地对每个主机进行ping。以下输出是一个例子：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To make the automation process seamless, we''ll generate an SSH authentication
    key pair so that we don''t have to type in a password every time we want to run
    a playbook. If you do not already have an SSH key pair, you can generate one using
    the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使自动化过程更加无缝，我们将生成一个SSH认证密钥对，这样我们就不必每次运行playbook时都输入密码。如果您还没有SSH密钥对，可以使用以下命令生成一个：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you run the `ssh-keygen` tool, you will see an output similar to the following.
    Note that you should leave the `passphrase` variable blank when prompted; otherwise,
    you will need to enter a passphrase every time you want to run an Ansible task,
    which removes the convenience of authenticating with SSH keys:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行`ssh-keygen`工具时，您将看到类似以下的输出。请注意，当提示时，您应该将`passphrase`变量留空；否则，您每次想运行Ansible任务时都需要输入一个密码，这将取消使用SSH密钥进行认证的便利性：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Although there are conditions that your SSH keys are automatically picked up
    with, it is recommended that you make use of `ssh-agent` as this allows you to
    load multiple keys to authenticate against a variety of targets. This will be
    very useful to you in the future, even if it isn''t right now. Start `ssh-agent` and
    add your new authentication key, as follows (note that you will need to do this
    for every shell that you open):'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然有条件可以自动选择您的SSH密钥，但建议您使用`ssh-agent`，因为这样可以加载多个密钥来对抗各种目标进行认证。即使现在用不上，将来这对您也会非常有用。启动`ssh-agent`并添加您的新认证密钥，如下（请注意，您需要为每个打开的shell执行此操作）：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '4\. Before you can perform key-based authentication with your target hosts,
    you need to apply the public key from the key pair you just generated to each
    host. You can copy the key to each host, in turn, using the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 在您可以对目标主机执行基于密钥的认证之前，您需要将刚刚生成的密钥对的公钥应用到每个主机上。您可以使用以下命令依次将密钥复制到每个主机：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '5\. With this complete, you should now be able to perform an Ansible `ping` command
    on the hosts you put in your inventory file. You will find that you are not prompted
    for a password at any point as the SSH connections to all the hosts in your inventory
    are authenticated with your SSH key pair. So, you should see an output similar
    to the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 完成后，您现在应该能够对清单文件中放入的主机执行Ansible的`ping`命令。您会发现在任何时候都不需要输入密码，因为对清单中所有主机的SSH连接都使用您的SSH密钥对进行了认证。因此，您应该会看到类似以下的输出：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This example output is generated with Ansible''s default level of verbosity.
    If you run into problems during this process, you can increase Ansible''s level
    of verbosity by passing one or more `-v` switches to the `ansible` command when
    you run it. For most issues, it is recommended that you use `-vvvv`, which gives
    you ample debugging information, including the raw SSH commands and the output
    from them. For example, assume that a certain host (such as `backend2.example.com`)
    can''t be connected to and you receive an error similar to the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例输出是使用Ansible的默认详细级别生成的。如果在此过程中遇到问题，您可以通过在运行时向`ansible`命令传递一个或多个`-v`开关来增加Ansible的详细级别。对于大多数问题，建议您使用`-vvvv`，这会为您提供丰富的调试信息，包括原始SSH命令和来自它们的输出。例如，假设某个主机（例如`backend2.example.com`）无法连接，并且您收到类似以下的错误：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that even Ansible recommends the use of the `-vvvv` switch for debugging.
    This could potentially produce pages of output but will include many useful details,
    such as the raw SSH command that was used to generate the connection to the target
    host in the inventory, along with any error messages that may have resulted from
    that call. This can be incredibly useful when debugging connectivity or code issues,
    although the output might be a little overwhelming at first. However, with some
    practice, you will quickly learn to interpret it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使Ansible也建议使用`-vvvv`开关进行调试。这可能会产生大量输出，但会包括许多有用的细节，例如用于生成与清单中目标主机的连接的原始SSH命令，以及可能由此调用产生的任何错误消息。在调试连接或代码问题时，这可能非常有用，尽管一开始输出可能有点压倒性。但是，通过一些实践，您将很快学会如何解释它。
- en: By now, you should have a good idea of how Ansible communicates with its clients
    over SSH. Let's proceed to the next section, where we will look in more detail
    at the various components that make up Ansible, as this will help us understand
    how to work with it better.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经对Ansible如何通过SSH与其客户端进行通信有了一个很好的了解。让我们继续进行下一部分，我们将更详细地了解组成Ansible的各个组件，因为这将帮助我们更好地理解如何使用它。
- en: Breaking down the Ansible components
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解Ansible组件
- en: Ansible allows you to define policies, configurations, task sequences, and orchestration
    steps in playbooks—the limit is really only your imagination. A playbook can be
    executed to manage your tasks either synchronously or asynchronously on a remote
    machine, although you will find that most examples are synchronous. In this section,
    you will learn about the main components of Ansible and understand how Ansible
    employs those components to communicate with remote hosts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible允许您在playbooks中定义策略、配置、任务序列和编排步骤，限制只在于您的想象力。可以同步或异步地在远程机器上执行playbook来管理任务，尽管大多数示例都是同步的。在本节中，您将了解Ansible的主要组件，并了解Ansible如何利用这些组件与远程主机通信。
- en: 'In order to understand the various components, we first need an inventory to
    work from. Let''s create an example one, ideally with multiple hosts in it—this
    could be the same as the one you created in the previous section. As discussed
    in that section, you should populate the inventory with the hostnames or IP addresses
    of the hosts that you can reach from the control host itself:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解各个组件，我们首先需要一个清单来进行工作。让我们创建一个示例清单，最好其中包含多个主机，这可能与您在上一节中创建的相同。如上一节所述，您应该使用主机名或IP地址填充清单，这些主机可以从控制主机本身访问到：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To really understand how Ansible—as well as its various components—works, we
    first need to create an Ansible playbook. While the ad hoc commands that we have
    experimented with so far are just single tasks, playbooks are organized groups
    of tasks that are (usually) run in sequence. Conditional logic can be applied
    and in any other programming language, they would be considered your code. At
    the head of the playbook, you should specify the name of your play—although this
    is not mandatory, it is good practice to name all your plays and tasks as without
    this, it would be quite hard for someone else to interpret what the playbook does,
    or even for you to if you come back to it after a period of time. Let''s get started
    with building our first example playbook:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正了解Ansible以及其各个组件的工作原理，我们首先需要创建一个Ansible playbook。尽管迄今为止我们尝试过的临时命令只是单个任务，但playbooks是组织良好的任务组，通常按顺序运行。可以应用条件逻辑，在任何其他编程语言中，它们都将被视为您的代码。在playbook的开头，您应该指定play的名称，尽管这不是强制性的，但将所有play和任务命名是一个良好的做法，没有这一点，其他人很难解释playbook的作用，即使您在一段时间后回来也是如此。让我们开始构建我们的第一个示例playbook：
- en: 'Specify the play name and inventory hosts to run your tasks against at the
    very top of your playbook. Also, note the use of `---`, which denotes the beginning
    of a YAML file (Ansible playbooks that are written in YAML):'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在playbook的顶部指定play名称和清单主机以运行您的任务。还要注意使用`---`，它表示一个YAML文件的开始（用YAML编写的Ansible
    playbook）：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After this, we will tell Ansible that we want to perform all the tasks in this
    playbook as a superuser (usually `root`). We do this with the following statement
    (to aid your memory, think of `become` as shorthand for `become superuser`):'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将告诉Ansible，我们希望将此playbook中的所有任务都作为超级用户（通常为`root`）执行。我们使用以下语句来实现这一点（为了帮助您记忆，将`become`视为`become
    superuser`的缩写）：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After this header, we will specify a task block that will contain one or more
    tasks to be run in sequence. For now, we will simply create one task to update
    the version of Apache using the `yum` module (because of this, this playbook is
    only suitable for running against RHEL-, CentOS-, or Fedora-based hosts). We will
    also specify a special element of the play called a handler. Handlers will be
    covered in greater detail in [Chapter 4](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml),
    *Playbooks and Roles*, so don''t worry too much about them for now. Simply put,
    a handler is a special type of task that is called only if something changes.
    So, in this example, it restarts the web server, but only if it changes, preventing
    unnecessary restarts if the playbook is run several times and there are no updates
    for Apache. The following code performs these functions exactly and should form
    the basis of your first playbook:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此标题之后，我们将指定一个任务块，其中将包含一个或多个要按顺序运行的任务。现在，我们将简单地创建一个任务，使用`yum`模块更新Apache的版本（因此，此playbook仅适用于针对基于RHEL、CentOS或Fedora的主机运行）。我们还将指定play的一个特殊元素，称为处理程序。处理程序将在第4章《Playbooks
    and Roles》中详细介绍，所以现在不要太担心它们。简而言之，处理程序是一种特殊类型的任务，仅在某些内容更改时才会调用。因此，在此示例中，它会重新启动Web服务器，但仅在更改时才会重新启动，如果多次运行playbook并且没有Apache的更新，则可以防止不必要的重新启动。以下代码完全执行了这些功能，并应成为您的第一个playbook的基础：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Congratulations, you now have your very first Ansible playbook! If you run
    this now, you should see it iterate through all the hosts in your inventory, as
    well as on each update in the Apache package, and then restart the service where
    the package was updated. Your output should look something as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您现在拥有了您的第一个Ansible playbook！如果您现在运行此playbook，您应该会看到它在清单中的所有主机上进行迭代，以及在Apache软件包的每次更新时，然后重新启动服务。您的输出应该如下所示：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you examine the output from the playbook, you can see the value in naming
    not only the play but also each task that is executed, as it makes interpreting
    the output of the run a very simple task. You will also see that there are multiple
    possible results from running a task; in the preceding example, we can see two
    of these results—`ok` and `changed`. Most of these results are fairly self-explanatory,
    with `ok` meaning the task ran successfully and that nothing changed as a result
    of the run. An example of this in the preceding playbook is the `Gathering Facts`
    stage, which is a read-only task that gathers information about the target hosts.
    As a result, it can only ever return `ok` or a failed status, such as `unreachable`,
    if the host is down. It should never return `changed`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查playbook的输出，您会发现不仅play的名称很重要，每个执行的任务也很重要，因为这使得解释运行的输出变得非常简单。您还会看到运行任务有多种可能的结果；在前面的示例中，我们可以看到两种结果——“ok”和“changed”。这些结果大多都很容易理解，“ok”表示任务成功运行，并且由于运行的结果没有发生任何变化。在前面的playbook中，“Gathering
    Facts”阶段就是一个只读任务，用于收集有关目标主机的信息。因此，它只能返回“ok”或失败的状态，比如如果主机宕机，则返回“unreachable”。它不应该返回“changed”。
- en: However, you can see in the preceding output that all three hosts need to upgrade
    their Apache package and, as a result of this, the results from the `Update the
    latest of an Apache Web Server` task is `changed` for all the hosts. This `changed`
    result means that our `handler` variable is notified and the web server service
    is restarted.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以在前面的输出中看到，所有三个主机都需要升级其Apache软件包，因此，“更新Apache Web服务器的最新版本”任务的结果对所有主机都是“更改”。这个“更改”结果意味着我们的“处理程序”变量被通知，Web服务器服务被重新启动。
- en: 'If we run the playbook a second time, we know that it is very unlikely that
    the Apache package will need upgrading again. Notice how the playbook output differs this
    time:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们第二次运行playbook，我们知道Apache软件包很可能不需要再次升级。请注意这次playbook输出的不同之处：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see that this time, the output from the `Update the latest of an Apache
    Web Server` task is `ok` for all three hosts, meaning no changes were applied
    (the package was not updated). As a result of this, our handler is not notified
    and does not run—you can see that it does not even feature in the preceding playbook
    output. This distinction is important—the goal of an Ansible playbook (and the
    modules that underpin Ansible) should be to only make changes when they need to
    be made. If everything is all up to date, then the target host should not be altered.
    Unnecessary restarts to services should be avoided, as should unnecessary alterations
    to files. In short, Ansible playbooks are (and should be) designed to be efficient
    and to achieve a target machine state.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，这次“更新Apache Web服务器的最新版本”任务的输出对所有三个主机都是“ok”，这意味着没有应用任何更改（软件包未更新）。因此，我们的处理程序没有收到通知，也没有运行——您可以看到它甚至没有出现在前面的playbook输出中。这种区别很重要——Ansible
    playbook（以及支持Ansible的模块）的目标应该是只在需要时才进行更改。如果一切都是最新的，那么目标主机就不应该被更改。应该避免不必要地重新启动服务，也应该避免对文件进行不必要的更改。简而言之，Ansible
    playbook被设计为高效实现目标机器状态。
- en: This has very much been a crash course on writing your first playbook, but hopefully,
    it gives you a taste of what Ansible can do when you move from single ad hoc commands
    through to more complex playbooks. Before we explore the Ansible language and
    components any further, let's take a more in-depth look at the YAML language that
    playbooks are written in.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个关于编写您的第一个playbook的速成课程，但希望它能让您对Ansible从单个临时命令到更复杂的playbook时可以做些什么有所了解。在我们进一步探索Ansible语言和组件之前，让我们更深入地了解一下playbook所写的YAML语言。
- en: Learning the YAML syntax
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习YAML语法
- en: In this section, you will learn how to write a YAML file with the correct syntax
    and best practices and tips for running a playbook on multiple remote machines. Ansible
    uses YAML because it is easier for humans to read and write than other common
    data formats, such as XML or JSON. There are no commas, curly braces, or tags
    to worry about, and the enforced indentation in the code ensures that it is tidy
    and easy on the eye. In addition, there are libraries available in most programming
    languages for working with YAML.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何以正确的语法编写YAML文件，并了解在多个远程机器上运行playbook的最佳实践和技巧。Ansible使用YAML是因为它比其他常见的数据格式（如XML或JSON）更容易阅读和编写。不需要担心逗号、花括号或标签，代码中强制的缩进确保了代码的整洁和易读。此外，大多数编程语言都有可用于处理YAML的库。
- en: This reflects one of the core goals of Ansible—to produce easy-to-read (and
    write) code that described the target state of a given host. Ansible playbooks
    are (ideally) supposed to be self-documenting, as documentation is often an afterthought
    in busy technology environments—so, what better way to document than through the
    automation system responsible for deploying code?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这反映了Ansible的核心目标之一——产生易于阅读（和编写）的代码，描述给定主机的目标状态。Ansible playbook（理想情况下）应该是自我记录的，因为在繁忙的技术环境中，文档通常是一个事后想法——那么，有什么比通过负责部署代码的自动化系统更好的记录方式呢？
- en: Before we dive into YAML structure, a word on the files themselves. Files written
    in YAML can optionally begin with `---` (as seen in the example playbook in the
    previous section) and end with `...`. This applies to all files in YAML, regardless
    of whether it is employed by Ansible or another system, and indicates that the
    file is in the YAML language. You will find that most examples of Ansible playbooks
    (as well as roles and other associated YAML files) start with `---` but do not
    end with `...`—the header is sufficient to clearly denote that the file uses the
    YAML format.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解YAML结构之前，先说一下文件本身。以YAML编写的文件可以选择性地以“---”开头（如前一节中示例playbook中所见）并以“...”结尾。这适用于YAML中的所有文件，无论是由Ansible还是其他系统使用，都表示文件是使用YAML语言编写的。您会发现，大多数Ansible
    playbook的示例（以及角色和其他相关的YAML文件）都以“---”开头，但不以“...”结尾——标题足以清楚地表示文件使用YAML格式。
- en: 'Let''s explore the YAML language through the example playbook we created in
    the preceding section:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过前面部分创建的示例playbook来探索YAML语言：
- en: 'Lists are an important construct in the YAML language—in fact, although it
    might not be obvious, the `tasks:` block of the playbook is actually a YAML list.
    A list in YAML lists all of its items at the same indentation level, with each
    line starting with `-`. For example, we updated the `httpd` package from the preceding
    playbook using the following code:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表是YAML语言中的一个重要构造——实际上，尽管可能不太明显，playbook的`tasks:`块实际上是一个YAML列表。YAML中的列表将所有项目列在相同的缩进级别上，每行以`-`开头。例如，我们使用以下代码更新了前面playbook中的`httpd`软件包：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, we could have specified a list of packages to be upgraded as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以指定要升级的软件包列表如下：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, rather than passing a single value to the `name:` key, we pass a YAML-formatted
    list containing the names of two packages to be updated.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再将单个值传递给`name:`键，而是传递一个包含要更新的两个软件包名称的YAML格式列表。
- en: 'Dictionaries are another important concept in YAML—they are represented by
    a `key: value` format, as we have already extensively seen, but all of the items
    in the dictionary are indented by one more level. This is easiest explained by
    an example, so consider the following code from our example playbook:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '字典是YAML中的另一个重要概念——它们由`key: value`格式表示，正如我们已经广泛看到的那样，但字典中的所有项目都缩进了一个更高的级别。这最容易通过一个例子来解释，因此考虑我们示例playbook中的以下代码：'
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example (from `handler`), the `service` definition is actually a dictionary
    and both the `name` and `state` keys are indented with two more spaces than the
    `service` key. This higher level of indentation means that the `name` and `state`
    keys are associated with the `service` key, therefore, in this case, telling the
    `service` module which service to operate on (`httpd`) and what to do with it
    (restart it).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中（来自`handler`），`service`定义实际上是一个字典，`name`和`state`键的缩进比`service`键多两个空格。这种更高级别的缩进意味着`name`和`state`键与`service`键相关联，因此，在这种情况下，告诉`service`模块要操作哪个服务（`httpd`）以及对其执行什么操作（重新启动）。
- en: Already, we have observed in these two examples that you can produce quite complicated
    data structures by mixing lists and dictionaries.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 已经在这两个例子中观察到，通过混合列表和字典，您可以制作相当复杂的数据结构。
- en: 'As you become more advanced at playbook design (we will see examples of this
    later on in this book), you may very well start to produce quite complicated variable
    structures that you will put into their own separate files to keep your playbook
    code readable. The following is an example of a `variables` file that provides
    the details of two employees of a company:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着您在playbook设计方面变得更加高级（我们将在本书的后面看到这方面的例子），您可能会开始制作相当复杂的变量结构，并将它们放入自己的单独文件中，以保持playbook代码的可读性。以下是一个提供公司两名员工详细信息的`variables`文件示例：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, you can see that we have a dictionary containing the details
    of each employee. The employees themselves are list items (you can spot this because
    the lines start with `-`) and equally, the employee skills are denoted as list
    items. You will notice the `fullname`, `role`, `level`, and `skills` keys are
    at the same indentation level as `name` but do not feature `-` before them. This
    tells you that they are in the dictionary with the list item itself, and so they
    represent the details of the employee.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您可以看到我们有一个包含每个员工详细信息的字典。员工本身是列表项（您可以通过行首的`-`来识别），同样，员工技能也被表示为列表项。您会注意到`fullname`、`role`、`level`和`skills`键与`name`处于相同的缩进级别，但它们之前没有`-`。这告诉您它们与列表项本身在同一个字典中，因此它们代表员工的详细信息。
- en: 'YAML is very literal when it comes to parsing the language and a new line always
    represents a new line of code. What if you actually need to add a block of text
    (for example, to a variable)? In this case, you can use a literal block scalar,
    `|`, to write multiple lines and YAML will faithfully preserve the new lines,
    carriage returns, and all the whitespace that follows each line (note, however,
    that the indentation at the beginning of each line is part of the YAML syntax):'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: YAML在解析语言时非常字面，每个新行始终代表着新的代码行。如果您确实需要添加一块文本（例如，到一个变量）怎么办？在这种情况下，您可以使用一个文字块标量`|`来写多行，YAML将忠实地保留新行、回车和每行后面的所有空格（但请注意，每行开头的缩进是YAML语法的一部分）：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, if we were to get Ansible to print the preceding contents to the screen,
    it would display as follows (note that the preceding two spaces have gone—they
    were interpreted correctly as part of the YAML language and not printed):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们让Ansible将前面的内容打印到屏幕上，它将显示如下（请注意，前面的两个空格已经消失——它们被正确解释为YAML语言的一部分，而没有被打印出来）：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Similar to the preceding is the folded block scalar, `>`, which does the same
    as the literal block scalar but does not preserve line endings. This is useful
    for very long strings that you want to print on a single line, but also want to
    wrap across multiple lines in your code for the purpose of readability. Take the
    following variation on our example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面类似的是折叠块标量`>`，它与文字块标量相同，但不保留行结束。这对于您想要在单行上打印的非常长的字符串很有用，但又想要为了可读性的目的将其跨多行包装在代码中。考虑我们示例的以下变化：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, if we were to print this, we would see the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们要打印这个，我们会看到以下内容：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We could add trailing spaces to the preceding example to stop the words from
    running into each other, but I have not done this here as I wanted to provide
    you with an easy-to-interpret example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的示例中添加尾随空格，以防止单词之间相互重叠，但我在这里没有这样做，因为我想为您提供一个易于解释的例子。
- en: 'As you review playbooks, variable files, and so on, you will see these structures
    used over and over again. Although simple in definition, they are very important—a
    missed level of indentation or a missing `-` instance at the start of a list item
    can cause your entire playbook to fail to run. As we discovered, you can put all
    of these various constructs together. One additional example is provided in the
    following code block of a `variables` file for you to consider, which shows the
    various examples we have covered all in one place:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当您审查playbooks、变量文件等时，您会看到这些结构一次又一次地被使用。尽管定义简单，但它们非常重要——缩进级别的遗漏或列表项开头缺少`-`实例都会导致整个playbook无法运行。正如我们发现的，您可以将所有这些不同的结构组合在一起。以下代码块中提供了一个`variables`文件的额外示例供您考虑，其中显示了我们已经涵盖的各种示例：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can also express both dictionaries and lists in an abbreviated form, known
    as **flow collections**. The following example shows exactly the same data structure
    as our original `employees` variable file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以用缩写形式表示字典和列表，称为**流集合**。以下示例显示了与我们原始的`employees`变量文件完全相同的数据结构：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Although this displays exactly the same data structure, you can see how difficult
    it is to read with the naked eye. Flow collections are not used extensively in
    YAML and I would not recommend you to make use of them yourself, but it is important
    to understand them in case you come across them. You will also notice that although
    we''ve started talking about variables in YAML, we haven''t expressed any variable
    types. YAML tries to make assumptions about variable types based on the data they
    contain, so if you want assign `1.0` to a variable, YAML will assume it is a floating-point
    number. If you need to express it as a string (perhaps because it is a version
    number), you need to put quotation marks around it, which causes the YAML parser
    to interpret it as a string instead, such as in the following example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这显示了完全相同的数据结构，但您可以看到肉眼很难阅读。在YAML中并不广泛使用流集合，我不建议您自己使用它们，但了解它们是很重要的。您还会注意到，尽管我们已经开始讨论YAML中的变量，但我们并没有表达任何变量类型。YAML尝试根据它们包含的数据对变量类型进行假设，因此如果您想将`1.0`赋给一个变量，YAML会假设它是一个浮点数。如果您需要将其表示为字符串（也许是因为它是一个版本号），您需要在其周围加上引号，这会导致YAML解析器将其解释为字符串，例如以下示例：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This completes our look at the YAML language syntax. Now that's complete, in
    the next section, let's take a look at ways that you can organize your automation
    code to keep it manageable and tidy.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对YAML语言语法的介绍。现在完成了，在下一节中，让我们看看如何组织您的自动化代码以使其易于管理和整洁。
- en: Organizing your automation code
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织您的自动化代码
- en: As you can imagine, if you were to write all of your required Ansible tasks
    in one massive playbook, it would quickly become unmanageable—that is to say,
    it would be difficult to read, difficult for someone else to pick up and understand,
    and—most of all—difficult to debug when things go wrong. Ansible provides a number
    of ways for you to divide your code into manageable chunks; perhaps the most important
    of these is the use of roles. Roles (for the sake of a simple analogy) behave
    like a library in a conventional high-level programming language. We will go into
    more detail about roles in [Chapter 4](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml),
    *Playbooks and Roles*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可以想象，如果您将所有所需的Ansible任务都写在一个庞大的playbook中，它将很快变得难以管理——也就是说，它将难以阅读，难以让其他人理解，并且——最重要的是——当出现问题时难以调试。Ansible提供了许多将代码分割成可管理块的方法；其中最重要的可能是使用角色。角色（简单类比）就像传统高级编程语言中的库。我们将在[第4章](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml)
    *Playbooks and Roles*中更详细地讨论角色。
- en: There are, however, other ways that Ansible supports splitting your code into
    manageable chunks, which we will explore briefly in this section as a precursor
    to the more in-depth exploration of roles later in this book.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Ansible支持将代码分割成可管理的块的其他方法，我们将在本节简要探讨，作为本书后面更深入探讨角色的先导。
- en: 'Let''s build up a practical example. To start, we know that we need to create
    an inventory for Ansible to run against. In this instance, we''ll create four
    notional groups of servers, with each group containing two servers. Our hypothetical
    example will contain a frontend server and application servers for a fictional
    application, located in two different geographic locations. Our inventory file
    will be called `production-inventory` and the example contents are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个实际的例子。首先，我们知道我们需要为Ansible运行创建清单。在这种情况下，我们将创建四个虚构的服务器组，每个组包含两台服务器。我们的假设示例将包含一个前端服务器和位于两个不同地理位置的虚构应用程序的应用程序服务器。我们的清单文件将被称为`production-inventory`，示例内容如下：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, obviously, we could just write one massive playbook to address the required
    tasks on these different hosts, but as we have already discussed, this would be
    cumbersome and inefficient. Let''s instead break the task of automating these
    different hosts down into smaller playbooks:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以编写一个庞大的playbook来处理这些不同主机上所需的任务，但正如我们已经讨论过的那样，这将是繁琐和低效的。让我们将自动化这些不同主机的任务分解成更小的playbook：
- en: 'Create a playbook to run a connection test on a specific host group, such as `frontends_na_zone`.
    Put the following contents into the playbook:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个playbook来对特定主机组（例如`frontends_na_zone`）运行连接测试。将以下内容放入playbook中：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, try running this playbook against the hosts (note that we have configured
    it to connect to a remote user on the inventory system, called `danieloh`, so
    you will either need to create this user and set up the appropriate SSH keys or
    change the user in the `remote_user` line of your playbook). When you run the
    playbook after setting up the authentication, you should see an output similar
    to the following:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试运行此playbook以针对主机（请注意，我们已配置它连接到名为`danieloh`的清单系统上的远程用户，因此您需要创建此用户并设置适当的SSH密钥，或者更改playbook中`remote_user`行中的用户）。在设置身份验证后运行playbook时，您应该会看到类似以下的输出：
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s extend our simple example by creating a playbook that will only run
    on the application servers. Again, we will use the Ansible `ping` module to perform
    a connection test, but in a real-world situation, you would perform more complex
    tasks, such as installing packages or modifying files. Specify that this playbook
    is run against this host group from the `appservers_emea_zone` inventory. Add
    the following contents to the playbook:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过创建一个只在应用服务器上运行的playbook来扩展我们的简单示例。同样，我们将使用Ansible的`ping`模块来执行连接测试，但在实际情况下，您可能会执行更复杂的任务，比如安装软件包或修改文件。指定此playbook针对`appservers_emea_zone`清单中的主机组运行。将以下内容添加到playbook中：
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As before, you need to ensure you can access these servers, so either create
    the `danieloh` user and set up authentication to that account or change the `remote_user`
    line in the example playbook. Once you have done this, you should be able to run
    the playbook and you will see an output similar to the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，您需要确保可以访问这些服务器，因此要么创建`danieloh`用户并设置对该帐户的身份验证，要么更改示例playbook中的`remote_user`行。完成这些操作后，您应该能够运行playbook，并且会看到类似以下的输出：
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'So far, so good. However, we now have two playbooks that we need to run manually,
    which only addresses two of our inventory host groups. If we want to address all
    four groups, we need to create a total of four playbooks, all of which need to
    be run manually. This is hardly reflective of best automation practices. What
    if there was a way to take these individual playbooks and run them together from
    one top-level playbook? This would enable us to divide our code to keep it manageable,
    but also prevents a lot of manual effort when it comes to running the playbooks.
    Fortunately, we can do exactly that by taking advantage of the `import_playbook`
    directive in a top-level playbook that we will call `site.yml`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好。然而，现在我们有两个需要手动运行的playbook，只涉及到我们清单中的两个主机组。如果我们想要处理所有四个组，我们需要创建总共四个playbook，所有这些都需要手动运行。这几乎不符合最佳的自动化实践。如果有一种方法可以将这些单独的playbook合并在一个顶级playbook中一起运行呢？这将使我们能够分割我们的代码以保持可管理性，但在运行playbook时也可以防止大量的手动工作。幸运的是，我们可以通过利用`import_playbook`指令在一个名为`site.yml`的顶级playbook中实现这一点：
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, when you run this single playbook using the (by now, familiar) `ansible-playbook`
    command, you will see that the effect is the same as if we had actually run both
    playbooks back to back. In this way, even before we explore the concept of roles,
    you can see that Ansible supports splitting up your code into manageable chunks
    without needing to run each chunk manually:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您使用（现在已经熟悉的）`ansible-playbook`命令运行这个单个playbook时，您会发现效果与我们实际上连续运行两个playbook的效果相同。这样，即使在我们探索角色的概念之前，您也可以看到Ansible支持将您的代码分割成可管理的块，而无需手动运行每个块：
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There's much more that you can do with geographically diverse environments,
    such as our simple example here, as we have not even touched on things such as
    placing variables in your inventory (which, for example, associates different
    parameters with different environments). We will explore this in more detail in
    [Chapter 3](1bbd0c5e-1eb1-4521-b84d-16cc07083f64.xhtml), *Defining Your Inventory*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在地理多样化的环境中，您可以做的远不止我们这里的简单示例，因为我们甚至还没有涉及将变量放入清单中的事情（例如，将不同的参数与不同的环境关联）。我们将在[第3章](1bbd0c5e-1eb1-4521-b84d-16cc07083f64.xhtml)中更详细地探讨这个问题，*定义您的清单*。
- en: However, hopefully that has armed with enough knowledge so that you can start
    making informed choices about how to organize the code for your playbooks. As
    you complete further chapters of this book, you will be able to establish whether
    you wish to make use of roles or the `import_playbook` directive (or perhaps even
    both) as part of your playbook organization.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，希望这已经为您提供了足够的知识，以便您可以开始对如何组织playbooks的代码做出明智的选择。随着您完成本书的进一步章节，您将能够确定您是否希望利用角色或`import_playbook`指令（或者甚至两者都使用）作为playbook组织的一部分。
- en: Let's carry on with our crash course on Ansible, in the next section, with a
    look at the configuration file and some of the key directives that you might find
    valuable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节继续进行Ansible的速成课程，看看配置文件和一些您可能发现有价值的关键指令。
- en: Exploring the configuration file
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索配置文件
- en: Ansible's behavior is, in part, defined by its configuration file. The central
    configuration file (which impacts the behavior of Ansible for all users on the
    system) can be found at `/etc/ansible/ansible.cfg`. However, this is not the only
    place Ansible will look for its configuration; in fact, it will look in the following
    locations, from the top to the bottom.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的行为在一定程度上由其配置文件定义。中央配置文件（影响系统上所有用户的Ansible行为）可以在`/etc/ansible/ansible.cfg`找到。然而，这并不是Ansible寻找其配置的唯一位置；事实上，它将从顶部到底部查找以下位置。
- en: 'The first instance of the file is the configuration it will use; all of the
    others are ignored, even if they are present:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的第一个实例是它将使用的配置；所有其他实例都将被忽略，即使它们存在：
- en: '`ANSIBLE_CONFIG`: The file location specified by the value of this environment
    variable, if set'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ANSIBLE_CONFIG`：由此环境变量的值指定的文件位置，如果设置'
- en: '`ansible.cfg`: In the current working directory'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible.cfg`：在当前工作目录'
- en: '`~/.ansible.cfg`: In the home directory of the user'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`~/.ansible.cfg`：在用户的主目录中'
- en: '`/etc/ansible/ansible.cfg`: The central configuration that we previously mentioned'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/etc/ansible/ansible.cfg`：我们之前提到的中央配置'
- en: If you installed Ansible through a package manager, such as `yum` or `apt`,
    you will almost always find a default configuration file called `ansible.cfg` in
    `/etc/ansible`. However, if you built Ansible from the source or installed it
    via `pip`, the central configuration file will not exist and you will need to
    create it yourself. A good starting point is to reference the example Ansible
    configuration file that is included with the source code, a copy of which can
    be found on GitHub at [https://raw.githubusercontent.com/ansible/ansible/devel/examples/ansible.cfg](https://raw.githubusercontent.com/ansible/ansible/devel/examples/ansible.cfg).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过`yum`或`apt`等软件包管理器安装了Ansible，您几乎总是会在`/etc/ansible`中找到名为`ansible.cfg`的默认配置文件。但是，如果您从源代码构建了Ansible或通过`pip`安装了它，则中央配置文件将不存在，您需要自己创建。一个很好的起点是参考包含在源代码中的示例Ansible配置文件，可以在GitHub上找到其副本，网址为[https://raw.githubusercontent.com/ansible/ansible/devel/examples/ansible.cfg](https://raw.githubusercontent.com/ansible/ansible/devel/examples/ansible.cfg)。
- en: In this section, we will detail how to locate Ansible's running configuration
    and how to manipulate it. Most people who install Ansible through a package find
    that they can get a long way with Ansible before they have to modify the default
    configuration, as it has been carefully designed to work in a great many scenarios.
    However, it is important to know a little about configuring Ansible in case you
    come across an issue in your environment that can only be changed by modifying
    the configuration.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细介绍如何定位Ansible的运行配置以及如何操作它。大多数通过软件包安装Ansible的人发现，在修改默认配置之前，他们可以在很多情况下使用Ansible，因为它经过精心设计，可以在许多场景中工作。然而，重要的是要了解一些关于配置Ansible的知识，以防您在环境中遇到只能通过修改配置来更改的问题。
- en: 'Obviously, if you don''t have Ansible installed, there''s little point in exploring
    its configuration, so let''s just check whether you have Ansible installed and
    working by issuing a command such as the following (the output shown is from the
    latest version of Ansible at the time of writing, installed on macOS with Homebrew):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果您没有安装Ansible，探索其配置就没有意义，因此让我们通过发出以下命令来检查您是否已安装并运行Ansible（所示的输出是在撰写时安装在macOS上的最新版本的Ansible的输出）：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s get started by exploring the default configuration that is provided
    with Ansible:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索Ansible提供的默认配置：
- en: 'The command in the following code block lists the current configuration parameters
    supported by Ansible. It is incredibly useful because it tells you both the environment
    variable that can be used to change the setting (see the `env` field) as well
    as the configuration file parameter and section that can be used (see the `ini`
    field). Other valuable information, including the default configuration values
    and a description of the configuration, is given (see the `default` and `description`
    fields, respectively). All of the information is sourced from `lib/constants.py`. Run
    the following command to explore the output:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块中的命令列出了Ansible支持的当前配置参数。这非常有用，因为它告诉您可以用来更改设置的环境变量（请参阅`env`字段），以及可以使用的配置文件参数和部分（请参阅`ini`字段）。其他有价值的信息，包括默认配置值和配置的描述，也会给出（请参阅`default`和`description`字段）。所有信息均来自`lib/constants.py`。运行以下命令来探索输出：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following is an example of the kind of output you will see. There are,
    of course, many pages to it, but a snippet is shown here as an example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您将看到的输出的示例。当然，它有很多页面，但这里只是一个片段示例：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you want to see a straightforward display of all the possible configuration
    parameters, along with their current values (regardless of whether they are configured
    from environment variables or a configuration file in one of the previously listed
    locations), you can run the following command:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想看到所有可能的配置参数以及它们的当前值的简单显示（无论它们是从环境变量还是配置文件中的一个配置的），您可以运行以下命令：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output shows all the configuration parameters (in an environment variable
    format), along with the current settings. If the parameter is configured with
    its default value, you are told so (see the `(default)` element after each parameter
    name):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了所有配置参数（以环境变量格式），以及当前的设置。如果参数配置为其默认值，则会告诉您（请参阅每个参数名称后的`(default)`元素）：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s see the effect on this output by editing one of the configuration parameters.
    Let''s do this by setting an environment variable, as follows (this command has
    been tested in the `bash` shell, but may differ for other shells):'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编辑其中一个配置参数，让我们看看这个输出的影响。通过设置环境变量来实现这一点，如下所示（此命令已在`bash` shell中进行了测试，但对于其他shell可能有所不同）：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, let''s re-run the `ansible-config` command, but this time get it to tell
    us only the parameters that have been changed from their default values:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新运行`ansible-config`命令，但这次让它告诉我们只有从默认值更改的参数：
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, you can see that `ansible-config` tells us that we have only changed `ANSIBLE_FORCE_COLOR`
    from the default value, that it is set to `True`, and that we set it through an
    `env` variable. This is incredibly valuable, especially if you have to debug configuration
    issues.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到`ansible-config`告诉我们，我们只更改了`ANSIBLE_FORCE_COLOR`的默认值，它设置为`True`，并且我们通过`env`变量设置了它。这非常有价值，特别是如果您必须调试配置问题。
- en: 'When working with the Ansible configuration file itself, you will note that
    it is in INI format, meaning it has sections such as `[defaults]`, parameters
    in the format `key = value`, and comments beginning with either `#` or `;`. You
    only need to place the parameters you wish to change from their defaults in your
    configuration file, so if you wanted to create a simple configuration to change
    the location of your default inventory file, it might look as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理Ansible配置文件本身时，您会注意到它是INI格式，意味着它有`[defaults]`等部分，格式为`key = value`的参数，以及以`#`或`;`开头的注释。您只需要在配置文件中放置您希望从默认值更改的参数，因此，如果您想要创建一个简单的配置来更改默认清单文件的位置，它可能如下所示：
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As discussed earlier, one of the possible valid locations for the `ansible.cfg`
    configuration file is in your current working directory. It is likely that this
    is within your home directory, so on a multi-user system, we strongly recommend
    you restrict access to the Ansible configuration file to your user account alone.
    You should take all the usual precautions when it comes to securing important
    configuration files on a multi-user system, especially as Ansible is normally
    used to configure multiple remote systems and so, a lot of damage could be done
    if a configuration file is inadvertently compromised!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面讨论的那样，`ansible.cfg`配置文件的可能有效位置之一是您当前的工作目录。很可能这是在您的主目录中，因此在多用户系统上，我们强烈建议您将对Ansible配置文件的访问权限限制为仅限于您的用户帐户。在多用户系统上保护重要配置文件时，您应该采取所有通常的预防措施，特别是因为Ansible通常用于配置多个远程系统，因此如果配置文件被意外损坏，可能会造成很大的损害！
- en: Of course, Ansible's behavior is not just controlled by the configuration files
    and switches—the command-line arguments that you pass to the various Ansible executables
    are also of vital importance. In fact, we have already worked with one already—in
    the preceding example, we showed you how to change where Ansible looks for its
    inventory file using the `inventory` parameter in `ansible.cfg`. However, in many
    of the examples that we previously covered in this book, we overrode this with
    the `-i` switch when running Ansible. So, let's proceed to the next section to
    look at the use of command-line arguments when running Ansible.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Ansible的行为不仅由配置文件和开关控制，您传递给各种Ansible可执行文件的命令行参数也非常重要。实际上，我们已经在先前的示例中使用了其中一个——在前面的示例中，我们向您展示了如何使用`ansible.cfg`中的`inventory`参数更改Ansible查找清单文件的位置。然而，在本书先前介绍的许多示例中，我们使用`-i`开关覆盖了这一点。因此，让我们继续下一节，看看在运行Ansible时使用命令行参数的用法。
- en: Command-line arguments
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行参数
- en: 'In this section, you will learn about the use of command-line arguments for
    playbook execution and how to employ some of the more commonly used ones to your
    advantage. We are already very familiar with one of these arguments, the `--version`
    switch, which we use to confirm that Ansible is installed (and which version is
    installed):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习有关使用命令行参数执行playbook以及如何将一些常用的参数应用到您的优势中。我们已经非常熟悉其中一个参数，即`--version`开关，我们用它来确认Ansible是否已安装（以及安装的版本）：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Just as we were able to learn about the various configuration parameters directly
    through Ansible, we can also learn about the command-line arguments. Almost all
    of the Ansible executables have a `--help` option that you can run to display
    the valid command-line parameters. Let''s try this out now:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们能够直接通过Ansible了解各种配置参数一样，我们也可以了解命令行参数。几乎所有的Ansible可执行文件都有一个`--help`选项，您可以运行它来显示有效的命令行参数。现在让我们试一试：
- en: 'You can view all the options and arguments when you execute the `ansible` command
    line. Use the following command:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您执行`ansible`命令行时，您可以查看所有选项和参数。使用以下命令：
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You will see a great deal of helpful output when you run the preceding command;
    an example of this is shown in the following code block (you might want to pipe
    this into a pager, such as `less`, so that you can read it all easily):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令时，您将看到大量有用的输出；以下代码块显示了一个示例（您可能希望将其导入到分页器中，例如`less`，以便您可以轻松阅读所有内容）：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We could take one example from the preceding code to build on our previous
    use of `ansible`; so far, we have almost exclusively used it to run ad hoc tasks
    with the `-m` and `-a` parameters. However, `ansible` can also perform useful
    tasks such as telling us about the hosts in a group within our inventory. We could
    explore this using the `production-inventory` file we used earlier in this chapter:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从前面的代码中选取一个示例来扩展我们之前对`ansible`的使用；到目前为止，我们几乎完全使用它来使用`-m`和`-a`参数运行临时任务。但是，`ansible`还可以执行有用的任务，例如告诉我们清单中组的主机。我们可以使用本章前面使用的`production-inventory`文件来探索这一点：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When you run this, you should see the members of the `appservers_emea_zone`
    inventory group listed. Although perhaps a little contrived, this example is incredibly
    valuable when you start working with dynamic inventory files and you can no longer
    just `cat` your inventory file to the terminal to view the contents:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令时，您应该会看到列出`appservers_emea_zone`清单组的成员。尽管这个例子可能有点牵强，但当您开始使用动态清单文件并且不能再简单地将清单文件传输到终端以查看内容时，这个例子是非常有价值的：
- en: '[PRE46]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The same is true for the `ansible-playbook` executable file, too. We have already
    seen a few of these in the previous examples of this book and there''s more that
    we can do. For example, earlier, we discussed the use of `ssh-agent` to manage
    multiple SSH authentication keys. While this makes running playbooks simple (as
    you don''t have to pass any authentication parameters to Ansible), it is not the
    only way of doing this. You can use one of the command-line arguments for `ansible-playbook`
    to specify the private SSH key file, instead, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible-playbook`可执行文件也是如此。我们已经在本书的先前示例中看到了其中一些，并且还有更多可以做的。例如，前面我们讨论了使用`ssh-agent`来管理多个SSH身份验证密钥。虽然这使运行playbook变得简单（因为您不必向Ansible传递任何身份验证参数），但这并不是唯一的方法。您可以使用`ansible-playbook`的命令行参数之一来指定私有SSH密钥文件，如下所示：'
- en: '[PRE47]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Similarly, in the preceding section, we specified the `remote_user` variable
    for Ansible to connect with in the playbook. However, command-line arguments can
    also set this parameter for the playbook; so, rather than editing the `remote_user`
    line in the playbook, we could remove it altogether and instead have run it using
    the following command-line string:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在前一节中，我们在playbook中指定了`remote_user`变量以便Ansible连接。然而，命令行参数也可以为playbook设置此参数；因此，我们可以完全删除`remote_user`行，并改用以下命令行字符串运行它：
- en: '[PRE48]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The ultimate aim of Ansible is to make your life simpler and to remove mundane
    day-to-day tasks from your list. As a result, there is no right or wrong way to
    do this—you can specify your private SSH key using a command-line argument or
    make it available using `ssh-agent`. Similarly, you can put the `remote_user`
    line in your playbook or user the `--user` parameter on the command line. Ultimately,
    the choice is yours, but it is important to consider that if you are distributing
    a playbook to multiple users and they all have to remember to specify the remote
    user on the command line, will they actually remember to do it? What will the
    consequences be if they don't? If the `remote_user` line is present in the playbook,
    will that make their lives easier and be less prone to error because the user
    account has been set in the playbook itself?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的最终目标是使您的生活更简单，并从您的清单中删除单调的日常任务。因此，没有正确或错误的方法来做到这一点——您可以使用命令行参数指定您的私有SSH密钥，也可以使用`ssh-agent`使其可用。同样，您可以在playbook中放置`remote_user`行，也可以在命令行上使用`--user`参数。最终，选择权在您手中，但重要的是要考虑，如果您将playbook分发给多个用户，并且他们都必须记住在命令行上指定远程用户，他们是否会真的记得这样做？如果他们不这样做会有什么后果？如果`remote_user`行存在于playbook中，是否会使他们的生活更轻松，并且更不容易出错，因为用户帐户已在playbook中设置？
- en: As with the configuration of Ansible, you will use a small handful of the command-line
    arguments frequently and there will be many that you may never touch. The important
    thing is that you know they are there and how to find out about them, and you
    can make informed decisions about when to use them. Let's proceed to the next
    section, where we will look in a bit more detail at ad hoc commands with Ansible.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与Ansible的配置一样，您将经常使用一小部分命令行参数，而您可能永远不会接触到许多命令行参数。重要的是您知道它们的存在以及如何了解它们，并且您可以对何时使用它们做出明智的决定。让我们继续到下一节，在那里我们将更详细地查看使用Ansible的临时命令。
- en: Understanding ad hoc commands
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解临时命令
- en: We have already seen a handful of ad hoc commands so far in this book, but to
    recap, they are single commands you can run with Ansible, making use of Ansible
    modules without the need to create or save playbooks. They are very useful for
    performing quick, one-off tasks on a number of remote machines or for testing
    and understanding the behavior of the Ansible modules that you intend to use in
    your playbooks. They are both a great learning tool and a quick and dirty (because
    you never document your work with a playbook!) automation solution.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在本书中看到了一些临时命令，但是为了回顾，它们是您可以使用Ansible运行的单个命令，利用Ansible模块而无需创建或保存playbook。它们非常有用，可以在许多远程机器上执行快速的一次性任务，也可以用于测试和了解您打算在playbook中使用的Ansible模块的行为。它们既是一个很好的学习工具，也是一个快速而肮脏（因为您从不使用playbook记录您的工作！）的自动化解决方案。
- en: 'As with every Ansible example, we need an inventory to run against. Let''s
    reuse our `production-inventory` file from before:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个Ansible示例一样，我们需要一个清单来运行。让我们重用之前的`production-inventory`文件：
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, let''s start with perhaps the quickest and dirtiest of ad hoc commands—running
    a raw shell command on a group of remote machines. Suppose that you want to check
    that the date and time of all the frontend servers in EMEA are in sync—you could
    do this by using a monitoring tool or by manually logging into each server in
    turn and checking the date and time. However, you can also use an Ansible ad hoc
    command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从可能是最快最肮脏的临时命令开始——在一组远程机器上运行原始shell命令。假设您想要检查EMEA地区所有前端服务器的日期和时间是否同步——您可以使用监控工具或手动依次登录到每台服务器并检查日期和时间来执行此操作。但是，您也可以使用Ansible的临时命令：
- en: 'Run the following ad hoc command to retrieve the current date and time from
    all of the `frontends_emea_zone` servers:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下临时命令，从所有`frontends_emea_zone`服务器检索当前日期和时间：
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You will see that Ansible faithfully logs in to each machine in turn and runs
    the `date` command, returning the current date and time. Your output will look
    something as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到Ansible忠实地依次登录到每台机器并运行`date`命令，返回当前日期和时间。您的输出将如下所示：
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This command is run with the user account you are logged in to when the command
    is run. You can use a command-line argument (discussed in the previous section)
    to run as a different user:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该命令是在您登录时运行的用户帐户中运行的。您可以使用命令行参数（在前一节中讨论）作为不同的用户运行：
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here, we can see that the `danieloh` user account does not have the privileges
    required to successfully run the `pvs` command. However, we can fix this by adding
    the `--become` command-line argument, which tells Ansible to become `root` on
    the remote systems:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`danieloh`用户帐户没有成功运行`pvs`命令所需的权限。但是，我们可以通过添加`--become`命令行参数来解决这个问题，该参数告诉Ansible在远程系统上成为`root`：
- en: '[PRE53]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can see that the command still fails because although `danieloh` is in `/etc/sudoers`,
    it is not allowed to run commands as `root` without entering a `sudo` password.
    Luckily, there''s a switch to get Ansible to prompt us for this at run time, meaning
    we don''t need to edit our `/etc/sudoers` file:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到，该命令仍然失败，因为虽然`danieloh`在`/etc/sudoers`中，但是不允许以`root`身份运行命令而不输入`sudo`密码。幸运的是，有一个开关可以让Ansible在运行时提示我们，这意味着我们不需要编辑我们的`/etc/sudoers`文件：
- en: '[PRE54]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'By default, if you don''t specify a module using the `-m` command-line argument,
    Ansible assumes you want to use the `command` module (see [https://docs.ansible.com/ansible/latest/modules/command_module.html](https://docs.ansible.com/ansible/latest/modules/command_module.html)).
    If you wish to use a specific module, you can add the `-m` switch to the command-line
    arguments and then specify the module arguments under the `-a` switch, as in the
    following example:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，如果您不使用`-m`命令行参数指定模块，Ansible会假定您想要使用`command`模块（参见[https://docs.ansible.com/ansible/latest/modules/command_module.html](https://docs.ansible.com/ansible/latest/modules/command_module.html)）。如果您希望使用特定模块，可以在命令行参数中添加`-m`开关，然后在`-a`开关下指定模块参数，如下例所示：
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The preceding output not only shows that the copy was performed successfully
    to both hosts but also all the output values from the `copy` module. This, again,
    can be very helpful later when you are developing playbooks as it enables you
    to understand exactly how the module works and what output it produces in cases
    where you need to perform further work with that output. This is a more advanced
    topic, however, that is beyond the scope of this introductory chapter.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出不仅显示了成功将复制到两个主机的操作，还显示了`copy`模块的所有输出值。这在以后开发playbook时非常有帮助，因为它使您能够准确了解模块的工作原理以及在需要进一步处理输出的情况下产生的输出。然而，这是一个更高级的话题，超出了本章的范围。
- en: You will also note that all arguments passed to the module must be enclosed
    in quotation marks (`"`). All arguments are specified as `key=value` pairs and
    no spaces should be added between `key` and `value` (for example, `key = value`
    is not acceptable). If you need to place quotation marks around one of your argument
    values, you can escape them using the backslash character (for example, `-a "src=/etc/yum.conf
    dest=\"/tmp/yum file.conf\""`)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到，传递给模块的所有参数都必须用引号括起来（`"`）。所有参数都被指定为`key=value`对，`key`和`value`之间不应添加空格（例如，`key
    = value`是不可接受的）。如果您需要在一个参数值周围放置引号，可以使用反斜杠字符进行转义（例如，`-a "src=/etc/yum.conf dest=\"/tmp/yum
    file.conf\""`）
- en: All examples we have performed so far are very quick to execute and run, but
    this is not always the case with computing tasks. When you have to run an operation
    for a long time, say more than two hours, you should consider running it as a
    background process. In this instance, you can run the command asynchronously and
    confirm the result of that execution later.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们执行的所有示例都非常快速，但这并不总是计算任务的情况。当您需要长时间运行操作时，比如超过两个小时，您应该考虑将其作为后台进程运行。在这种情况下，您可以异步运行命令，并稍后确认执行的结果。
- en: 'For example, to execute `sleep 2h` asynchronously in the background with a
    timeout of 7,200 seconds (`-B`) and without polling (`-P`), use this command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在后台异步执行`sleep 2h`，并设置超时为7,200秒（`-B`），并且不进行轮询（`-P`），请使用以下命令：
- en: '[PRE56]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Note that the output from this command gives a unique job ID for each task
    on each host. Let''s now say that we want to see how this task proceeds on the
    second frontend server. Simply issue the following command from your Ansible control
    machine:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此命令的输出为每个主机上的每个任务提供了唯一的作业ID。现在假设我们想要查看第二个前端服务器上的任务进展。只需从您的Ansible控制机发出以下命令：
- en: '[PRE57]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here, we can see that the job has started but not finished. If we now kill
    the `sleep` command that we issued and check on the status again, we can see the
    following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到作业已经开始但尚未完成。如果我们现在终止我们发出的`sleep`命令并再次检查状态，我们可以看到以下内容：
- en: '[PRE58]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, we see a `FAILED` status result because the `sleep` command was killed;
    it did not exit cleanly and returned a `-15` code (see the `rc` parameter). When
    it was killed, no output was sent to either `stdout` or `stderr`, but if it had
    been, Ansible would have captured it and displayed it in the preceding code, which
    would aid you in debugging the failure. Lots of other useful information is included,
    including how long the task actually ran for, the end time, and so on. Similarly,
    the useful output is returned when the task exits cleanly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了一个`FAILED`状态的结果，因为`sleep`命令被终止；它没有干净地退出，并返回了一个`-15`的代码（请参阅`rc`参数）。当它被终止时，没有输出被发送到`stdout`或`stderr`，但如果有的话，Ansible会捕获它并在前面的代码中显示它，这将有助于您调试失败。还包括了许多其他有用的信息，包括任务实际运行的时间、结束时间等。同样，当任务干净地退出时，也会返回有用的输出。
- en: That concludes our look at ad hoc commands in Ansible. By now, you should have
    a fairly solid grasp of the fundamentals of Ansible, but there's one important
    thing we haven't looked at yet, even though we briefly touched on it—variables
    and how to define them. We'll proceed to look at this in the next section.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对Ansible中的临时命令的介绍。到目前为止，您应该对Ansible的基本原理有了相当扎实的掌握，但还有一件重要的事情我们还没有看到，即使我们简要提到过——变量以及如何定义它们。我们将在下一节继续讨论这个问题。
- en: Defining variables
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义变量
- en: In this section, we will cover the topic of variables and how they can be defined
    in Ansible. You will learn how variables should be defined step by step and understand
    how to work with them in Ansible.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍变量的主题以及如何在Ansible中定义它们。您将逐步学习变量应该如何定义，并了解如何在Ansible中使用它们。
- en: Although automation removes much of the repetition from previously manual tasks,
    not every single system is identical. If two systems differ in some minor way,
    you could write two unique playbooks—one for each system. However, this would
    be inefficient and wasteful, as well as difficult to manage as time goes on (for
    example, if the code in one playbook is changed, how can you ensure that it is
    updated in the second variant?).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管自动化消除了以前手动任务中的大部分重复，但并非每个系统都是相同的。如果两个系统在某些细微的方式上不同，您可以编写两个独特的playbook——一个用于每个系统。然而，这将是低效和浪费的，随着时间的推移也很难管理（例如，如果一个playbook中的代码发生了变化，您如何确保它在第二个变体中得到更新？）。
- en: Equally, you might need to use a value from one system in another—perhaps you
    need to obtain the hostname of a database server and make it available to another.
    All of these issues can be addressed with variables as they allow the same automation
    code to run with parameter variations, as well as values to pass from one system
    to another (although this must be handled with some care).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可能需要在一个系统中使用另一个系统的值——也许您需要获取数据库服务器的主机名并使其可用于另一个系统。所有这些问题都可以通过变量来解决，因为它们允许相同的自动化代码以参数变化的方式运行，以及将值从一个系统传递到另一个系统（尽管这必须小心处理）。
- en: Let's get started with a practical look at defining variables in Ansible.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实际看一下在Ansible中定义变量。
- en: 'Variables in Ansible should have well-formatted names that adhere to the following
    rules:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible中的变量应具有格式良好的名称，符合以下规则：
- en: The name of the variable must only include letters, underscores, and numbers—spaces
    are not allowed.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的名称只能包含字母、下划线和数字，不允许包含空格。
- en: The name of the variable can only begin with a letter—they can contain numbers,
    but cannot start with one.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的名称只能以字母开头，可以包含数字，但不能以数字开头。
- en: 'For example, the following are good variable names:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是良好的变量名称：
- en: '`external_svc_port`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`external_svc_port`'
- en: '`internal_hostname_ap1`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`internal_hostname_ap1`'
- en: 'The following examples are all invalid, however, and cannot be used:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下示例都是无效的，不能使用：
- en: '`appserver-zone-na`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appserver-zone-na`'
- en: '`cache server ip`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache server ip`'
- en: '`dbms.server.port`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbms.server.port`'
- en: '`01appserver`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`01appserver`'
- en: 'As discussed in the *Learning the YAML syntax* section, variables can be defined
    in a dictionary structure, such as the following. All values are declared in key-value
    pairs:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如在*学习YAML语法*部分中讨论的，变量可以以字典结构定义，例如以下方式。所有值都以键值对的形式声明：
- en: '[PRE59]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In order to retrieve a specific field from the preceding dictionary structure,
    you can use either one of the following notations:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从前面的字典结构中检索特定字段，您可以使用以下任一表示法：
- en: '[PRE60]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'There are some exceptions to this; for example, you should use `bracket notation`
    if the variable name starts and ends with two underscores (for example, `__variable__`)
    or contains known public attributes, such as the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些例外情况；例如，如果变量名以两个下划线开头和结尾（例如`__variable__`），或包含已知的公共属性，您应该使用`括号表示法`：
- en: '`as_integer_ratio`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`as_integer_ratio`'
- en: '`symmetric_difference`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symmetric_difference`'
- en: You can find more information on this at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#creating-valid-variable-names](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#creating-valid-variable-names).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#creating-valid-variable-names](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#creating-valid-variable-names)找到更多信息。
- en: 'This dictionary structure is valuable when defining host variables; although
    earlier in this chapter we worked with a fictional set of employee records defined
    as an Ansible `variables` file, you could use this to specify something, such
    as some `redis` server parameters:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义主机变量时，这种字典结构是有价值的；尽管在本章的早些时候，我们使用了一个定义为Ansible `variables`文件的虚构员工记录集，但您可以使用它来指定一些`redis`服务器参数等内容：
- en: '[PRE61]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: These could then be applied through your playbook and one common playbook could
    be used for all `redis` servers, regardless of their configuration, as changeable
    parameters such as the `port` and `master` servers are all contained in the variables.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这些可以通过您的playbook应用，并且一个通用的playbook可以用于所有`redis`服务器，而不管它们的配置如何，因为可变的参数，如`port`和`master`服务器都包含在变量中。
- en: 'You can also pass set variables directly in a playbook, and even pass them
    to roles that you call. For example, the following playbook code calls four hypothetical
    roles and each assigns a different value to the `username` variable for each one.
    These roles could be used to set up various administration roles on a server (or
    multiple servers), with each passing a changing list of usernames as people come
    and go from the company:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以直接在playbook中传递设置变量，并将它们传递给您调用的角色。例如，以下playbook代码调用了四个假设的角色，并且每个角色为`username`变量分配了不同的值。这些角色可以用于在服务器上设置各种管理角色（或多个服务器），每个角色都传递一个不断变化的用户名列表，因为公司的人员来来去去：
- en: '[PRE62]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To access variables from within a playbook, you simply place the variable name
    inside quoted pairs of curly braces. Consider the following example playbook (based
    loosely on our previous `redis` example):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要从playbook中访问变量，只需将变量名放在引号括号中。考虑以下示例playbook（基于我们之前的`redis`示例）：
- en: '[PRE63]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, we define a variable in the playbook itself called `redis`. This variable
    is a dictionary, containing a number of parameters that might be important for
    our server. To access the contents of these variables, we use pairs of curly braces
    around them (as described previously) and the entire string is encased in quotation
    marks, which means we don''t have to individually quote the variables. If you
    run the playbook on a local machine, you should see an output that looks as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在playbook中定义了一个名为`redis`的变量。这个变量是一个字典，包含了一些对我们的服务器可能很重要的参数。为了访问这些变量的内容，我们使用花括号对它们进行配对（如前面所述），并且整个字符串被引号括起来，这意味着我们不必单独引用这些变量。如果您在本地机器上运行playbook，您应该会看到以下输出：
- en: '[PRE64]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Although we are accessing these variables here to print them in a debug message,
    you could use the same curly brace notation to assign them to module parameters,
    or for any other purpose that your playbook requires them for.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这里访问这些变量以在调试消息中打印它们，但您可以使用相同的花括号表示法将它们分配给模块参数，或者用于playbook需要它们的任何其他目的。
- en: 'Ansible, just like many languages, has specially reserved variables that take
    on particular meaning in playbooks. In Ansible, these are known as magic variables
    and you can find a full list of them at [https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html](https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html).
    Needless to say, you should not attempt to use any magic variable names for your
    own variables. Some common magic variables you might come across are as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多语言一样，Ansible也有特殊保留的变量，在playbooks中具有特定含义。在Ansible中，这些被称为魔术变量，您可以在[https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html](https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html)找到完整的列表。不用说，您不应该尝试使用任何魔术变量名称作为您自己的变量。您可能会遇到的一些常见的魔术变量如下：
- en: '`inventory_hostname`: The hostname for the current host that is iterated over
    in the play'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inventory_hostname`：在播放中迭代的当前主机的主机名'
- en: '`groups`: A dictionary of the host groups in the inventory, along with the
    host membership of each group'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groups`：清单中主机组的字典，以及每个组的主机成员资格'
- en: '`group_names`: A list of the groups the current host (specified by `inventory_hostname`)
    is part of'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group_names`：当前主机（由`inventory_hostname`指定）所属的组的列表'
- en: '`hostvars`: A dictionary of all the hosts in the inventory and the variables
    assigned to each of them'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hostvars`：清单中所有主机和分配给它们的变量的字典'
- en: For example, the host variables for all the hosts can be accessed at any point
    in the playbook using `hostvars`, even if you are only operating on one particular
    host. Magic variables are surprisingly useful in playbooks and you will rapidly
    start to find yourself using them, so it is important to be aware of their existence.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以在播放中的任何时候使用`hostvars`访问所有主机的主机变量，即使您只对一个特定主机进行操作。在playbook中，魔术变量非常有用，您将迅速开始发现自己在使用它们，因此了解它们的存在非常重要。
- en: You should also note that you can specify Ansible variables in multiple locations.
    Ansible has a strict order of variable precedence and you can take advantage of
    this by setting default values for variables in a place that has low precedence
    and then overriding them later in the play. This is useful for a variety of reasons,
    especially where an undefined variable could cause havoc when a playbook is run
    (or even when the playbook would fail as a result of this). We have not yet discussed
    all of the places that variables can be stored, so the full list of variable precedence
    order is not given here.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该注意，您可以在多个位置指定Ansible变量。 Ansible具有严格的变量优先级顺序，您可以利用这一点，在优先级较低的位置设置变量的默认值，然后在播放中稍后覆盖它们。这对于各种原因都很有用，特别是当未定义的变量可能在运行playbook时造成混乱（甚至当playbook由于此原因失败时）。我们尚未讨论变量可以存储的所有位置，因此此处未给出变量优先级顺序的完整列表。
- en: In addition, it can change between Ansible releases, so it is important that
    you refer to the documentation when working with and understanding variable precedence—go
    to [https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable) for
    more information.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它可能会在Ansible版本之间发生变化，因此在处理和理解变量优先级时，重要的是参考文档——请访问[https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable)获取更多信息。
- en: That concludes our brief overview of variables in Ansible, although we will
    see them used again in later examples in this book. Let's now round off this chapter
    with a look at Jinja2 filters, which add a whole world of power to your variable
    definitions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对Ansible中变量的简要概述，尽管我们将在本书的后续示例中再次看到它们的使用。现在让我们通过查看Jinja2过滤器来结束本章，它为您的变量定义增添了无限的力量。
- en: Understanding Jinja2 filters
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Jinja2过滤器
- en: As Ansible is written in Python, it inherits an incredibly useful and powerful
    templating engine called Jinja2\. We will look at the concept of templating later
    in this book, so for now, we will focus on one particular aspect of Jinja2 known
    as filtering. Jinja2 filters provide an incredibly powerful framework that you
    can use to manipulate and transform your data. Perhaps you have a string that
    you need to convert to lowercase, for example—you could apply a Jinja2 filter
    to achieve this. You can also use it to perform pattern matching, search and replace
    operations, and much more. There are many hundreds of filters for you to work
    with and in this section, we hope to empower you with a basic understanding of
    Jinja2 filters and some practical knowledge about how to apply them, as well as
    show you where to get more information about them if you wish to explore the subject
    further.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ansible是用Python编写的，它继承了一个非常有用和强大的模板引擎，称为Jinja2。我们将在本书的后面看到模板化的概念，因此现在我们将专注于Jinja2的一个特定方面，即过滤器。
    Jinja2过滤器提供了一个非常强大的框架，您可以使用它来操作和转换数据。也许您有一个需要转换为小写的字符串，例如-您可以应用Jinja2过滤器来实现这一点。您还可以使用它来执行模式匹配、搜索和替换操作等等。有数百种过滤器供您使用，在本节中，我们希望为您提供对Jinja2过滤器的基本理解以及如何应用它们的实际知识，并向您展示如何获取更多关于它们的信息，如果您希望进一步探索这个主题。
- en: It is worth noting that Jinja2 operations are performed on the Ansible control
    host and only the results of the filter operation are sent to the remote hosts.
    This is done by design, both for consistency and to reduce the workload on the
    individual nodes as much as possible.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Jinja2操作是在Ansible控制主机上执行的，只有过滤器操作的结果被发送到远程主机。这是出于设计考虑，既为了一致性，也为了尽可能减少各个节点的工作量。
- en: Let's explore this through a practical example. Suppose we have a YAML file
    containing some data that we want to parse. We can quite easily read a file from
    the machine filesystem and capture the result using the `register` keyword (`register`
    captures the result of the task and stores it in a variable—in the case of running
    the `shell` module, it captures all the output from the command that was run).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个实际的例子来探讨这个。假设我们有一个包含一些我们想要解析的数据的YAML文件。我们可以很容易地从机器文件系统中读取文件，并使用`register`关键字来捕获结果（`register`捕获任务的结果并将其存储在一个变量中——在运行`shell`模块的情况下，它会捕获命令的所有输出）。
- en: 'Our YAML data file might look as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的YAML数据文件可能如下所示：
- en: '[PRE65]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, we could create a playbook to read this file and register the result,
    but how can we actually turn it into a variable structure that Ansible can understand
    and work with? Let''s consider the following playbook:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个playbook来读取这个文件并注册结果，但是我们如何将其实际转换为Ansible可以理解和使用的变量结构呢？让我们考虑下面的playbook：
- en: '[PRE66]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `shell` module does not necessarily run from the directory that the playbook
    is stored in, so we cannot guarantee that it will find our `multiple-document-strings.yaml`
    file. The `copy` module does, however, source the file from the current directory,
    so it is useful to use it to copy it to a known location (such as `/tmp`) for
    the `shell` module to read the file from. The `debug` module is then run in a
    `loop` module. The `loop` module is used to iterate over all of the lines of `stdout`
    from the `shell` command, as we are using two Jinja2 filters—`from_yaml_all` and
    `list`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`shell`模块不一定是从playbook所在的目录运行的，所以我们不能保证它会找到我们的`multiple-document-strings.yaml`文件。然而，`copy`模块会从当前目录中获取文件，所以可以使用它将文件复制到一个已知的位置（比如`/tmp`），以便`shell`模块从中读取文件。然后在`loop`模块中运行`debug`模块。`loop`模块用于遍历`shell`命令的所有`stdout`行，因为我们使用了两个Jinja2过滤器——`from_yaml_all`和`list`。'
- en: 'The `from_yaml_all` filter parses the source document lines as YAML and then
    the `list` filter converts the parsed data into a valid Ansible list. If we run
    the playbook, we should see Ansible''s representation of the data structure from
    within our original file:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`from_yaml_all`过滤器解析源文档行为YAML，然后`list`过滤器将解析后的数据转换为有效的Ansible列表。如果我们运行playbook，我们应该能够看到Ansible对原始文件中的数据结构的表示。'
- en: '[PRE67]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, we have generated a list of dictionaries that in themselves
    contain the key-value pairs.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们生成了一个包含`key-value`对的字典列表。
- en: 'If this data structure was already stored in our playbook, we could take this
    one step further and use the `items2dict` filter to turn the list into true `key:
    value` pairs, removing the `key` and `value` items from the data structure. For
    example, consider this second playbook:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '如果这个数据结构已经存储在我们的playbook中，我们可以再进一步使用`items2dict`过滤器将列表转换为真正的`key: value`对，从数据结构中移除`key`和`value`项。例如，考虑下面的第二个playbook：'
- en: '[PRE68]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, if we run this, we can see that our data is converted into a nice neat
    set of `key: value` pairs:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，如果我们运行这个，我们可以看到我们的数据被转换成了一组漂亮整洁的`key: value`对。'
- en: '[PRE69]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Observe the warning at the top of the playbook. Ansible displays a warning if
    you attempt to use a reserved name for a variable, as we did here. Normally, you
    should not create a variable with a reserved name, but the example here demonstrates
    both how the filter works and how Ansible will attempt to warn you if you do something
    that might cause problems.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 观察一下playbook顶部的警告。如果你尝试使用保留名称作为变量，Ansible会显示警告，就像我们在这里做的一样。通常情况下，你不应该使用保留名称创建变量，但是这个例子展示了过滤器的工作原理，以及如果你做一些可能会引起问题的事情，Ansible会尝试警告你。
- en: 'Earlier in this section, we used the `shell` module to read a file and used
    `register` to store the result in a variable. This is perfectly fine, if a little
    inelegant. Jinja2 contains a series of `lookup` filters that, among other things,
    can read the contents of a given file. Let''s examine the behavior of this following
    playbook::'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的早些时候，我们使用了`shell`模块来读取文件，并使用`register`将结果存储在一个变量中。这是完全可以的，虽然有点不够优雅。Jinja2包含一系列`lookup`过滤器，其中包括读取给定文件内容的功能。让我们来看看下面的playbook的行为：
- en: '[PRE70]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'When we run this, we can see that Ansible has captured the contents of the
    `/etc/hosts` file for us, without us needing to resort to the `copy` and `shell`
    modules as we did earlier:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个时，我们可以看到Ansible已经为我们捕获了`/etc/hosts`文件的内容，而不需要我们像之前那样使用`copy`和`shell`模块。
- en: '[PRE72]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'There are many other filters that you might be interested in exploring and
    a full list can be found in the official Jinja2 documentation ([https://jinja.palletsprojects.com/en/2.11.x/](https://jinja.palletsprojects.com/en/2.11.x/)).
    The following are a handful of other examples that will give you an idea of the
    kinds of things that Jinja2 filters can achieve for you, from quoting strings
    to concatenating lists to obtaining useful path information for a file:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他过滤器可能会让你感兴趣，完整列表可以在官方的Jinja2文档中找到（[https://jinja.palletsprojects.com/en/2.11.x/](https://jinja.palletsprojects.com/en/2.11.x/)）。以下是一些其他示例，可以让你了解Jinja2过滤器可以为你实现的功能，从引用字符串到连接列表，再到获取文件的有用路径信息：
- en: '[PRE73]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: That concludes our look at Jinja2 filtering. It is a massive topic that deserves
    a book all to itself, but, as ever, I hope that this practical guide has given
    you some pointers on how to get started and where to find information.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对Jinja2过滤器的介绍。这是一个庞大的主题，值得有一本专门的书来讲解，但是，我希望这个实用指南能给你一些开始和寻找信息的指引。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Ansible is a very powerful and versatile automation engine that can be used
    for a wide variety of tasks. Understanding the basics of how to work it is of
    paramount importance, before addressing the more complex challenges of playbook
    creation and large-scale automation. Ansible relies on a language called YAML,
    a simple-to-read (and write) syntax that supports the rapid development of easy-to-read
    and easy-to-maintain code and inherits a number of valuable features from the
    Python language that it is written in, including Jinja2 filtering.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个非常强大和多功能的自动化引擎，可用于各种任务。在解决playbook创建和大规模自动化的更复杂挑战之前，了解如何使用它的基础知识至关重要。Ansible依赖一种称为YAML的语言，这是一种简单易读（和写）的语法，支持快速开发易于阅读和易于维护的代码，并从其编写的Python语言中继承了许多有价值的特性，包括Jinja2过滤器。
- en: In this chapter, you learned the fundamentals of working with various Ansible
    programs. You then learned about the YAML syntax and the ways that you can break
    down your code into manageable chunks to make it easier to read and maintain.
    We explored the use of ad hoc commands in Ansible, variable definition and structure,
    and how to make use of Jinja2 filters to manipulate the data in your playbooks.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了使用各种Ansible程序的基础知识。然后，您了解了YAML语法以及将代码分解为可管理的块的方法，以便更容易阅读和维护。我们探讨了在Ansible中使用临时命令、变量定义和结构，以及如何利用Jinja2过滤器来操作playbooks中的数据。
- en: In the next chapter, we will take a more in-depth look at Ansible inventories
    and explore some of the more advanced concepts of working with them that you may
    find useful.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地了解Ansible清单，并探索一些更高级的概念，这些概念在处理它们时可能会对您有用。
- en: Questions
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which component of Ansible allows you to define a block to execute task groups
    as a play?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible的哪个组件允许您定义一个块以执行任务组作为play？
- en: A) `handler`
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: A) `handler`
- en: B) `service`
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: B) `service`
- en: C) `hosts`
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: C) `hosts`
- en: D) `tasks`
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: D) `tasks`
- en: E) `name`
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: E) `name`
- en: Which basic syntax from the YAML format do you use to start a file?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您使用YAML格式的哪种基本语法来开始一个文件？
- en: A) `###`
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: A) `###`
- en: B) `---`
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: B) `---`
- en: C) `%%%`
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: C) `%%%`
- en: D) `===`
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: D) `===`
- en: E) `***`
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: E) `***`
- en: True or false – in order to interpret and transform output data in Ansible,
    you need to use Jinja2 templates.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假 - 为了解释和转换Ansible中的输出数据，您需要使用Jinja2模板。
- en: A) True
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: A) True
- en: B) False
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: B) False
- en: Further reading
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To find out about more configuration variables, go to [https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings).
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多配置变量，请转到[https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings)。
