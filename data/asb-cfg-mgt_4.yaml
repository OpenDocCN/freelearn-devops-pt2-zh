- en: Chapter 4. Larger Projects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。更大的项目
- en: 'Until now we have been looking at single plays in one playbook file. This approach
    will work for simple infrastructures, or when using Ansible as a simple deployment
    mechanism. However, if you have a large and complicated infrastructure, then you
    will need to take actions to prevent things from going out of control. This chapter
    will include the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在一个playbook文件中查看单个play。这种方法适用于简单的基础设施，或者在使用Ansible作为简单的部署机制时。然而，如果您有一个庞大而复杂的基础设施，那么您将需要采取措施防止事情失控。本章将包括以下主题：
- en: Separating your playbooks into different files, and including them from some
    other location
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的playbooks分成不同的文件，并从其他位置包括它们
- en: Using roles to include multiple files that perform a similar function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用角色包括执行类似功能的多个文件
- en: Methods for increasing the speed at which Ansible configures your machines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加Ansible配置机器速度的方法
- en: Includes
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包括
- en: One of the first issues you will face with a complex infrastructure is that
    your playbooks will rapidly increase in size. Large playbooks can become difficult
    to read and maintain. Ansible allows you to combat this problem by way of includes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您将面临的第一个问题之一是，您的playbooks将迅速增加。大型playbooks可能变得难以阅读和维护。Ansible允许您通过包括来解决这个问题。
- en: Includes allow you to split your plays into multiple sections. You can then
    include each section from other plays. This allows you to have several different
    parts built for a different purpose, all included in a main play.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 包括允许您将您的plays分成多个部分。然后您可以从其他plays中包括每个部分。这使您可以为不同的目的构建几个不同的部分，全部包括在一个主要play中。
- en: 'There are four types of includes, namely, variable includes, playbook includes,
    task includes, and handler includes. Including variables from an external `vars_file`
    files has been discussed already in [Chapter 2](ch02.html "Chapter 2. Simple Playbooks"),
    *Simple Playbooks*. The following is a description of what each includes does:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种包括，即变量包括，playbook包括，任务包括和处理程序包括。从外部`vars_file`文件中包括变量已经在[第2章](ch02.html "第2章。简单Playbooks")中讨论过了，*简单Playbooks*。以下是每个包括的描述：
- en: '**Variable includes**: They allow you to put your variables in external YAML
    files'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量包括**：它们允许您将变量放在外部的YAML文件中'
- en: '**Playbook includes**: They are used to include plays from other files in a
    single play'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Playbook包括**：它们用于在单个play中包括其他文件中的plays'
- en: '**Task includes**: They let you put common tasks in other files and include
    them wherever required'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务包括**：它们让您将常见任务放在其他文件中，并在需要时包括它们'
- en: '**Handler includes**: They let you put all your handlers at one place'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理程序包括**：它们让您将所有处理程序放在一个地方'
- en: We will be looking at these includes in the following section; however, including
    variables from an external `vars_file` files has been discussed already in [Chapter
    2](ch02.html "Chapter 2. Simple Playbooks"), *Simple Playbooks*, so we will not
    be discussing it in detail.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中讨论这些包括；然而，从外部`vars_file`文件中包括变量已经在[第2章](ch02.html "第2章。简单Playbooks")中讨论过了，*简单Playbooks*，所以我们不会详细讨论它。
- en: Task includes
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务包括
- en: Task includes can be used when you have a lot of common tasks that will be repeated.
    For example, you may have a set of tasks that removes a machine from monitoring
    and a load balancer before you can configure it. You can put these tasks in a
    separate YAML file, and then include them from your main task.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 任务包括可用于重复的许多常见任务。例如，您可能有一组任务，它们在配置之前从监视器和负载均衡器中删除一个机器。您可以将这些任务放在一个单独的YAML文件中，然后从主任务中包括它们。
- en: Task includes inherit the facts from the play they are included from. You can
    also provide your own variables, which are passed into the task and are available
    for use.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 任务包括继承自它们所包含的play的事实。您还可以提供自己的变量，这些变量被传递到任务中并可供使用。
- en: Finally, task includes can have conditionals applied to them. If you do this,
    conditionals will separately be added to each included task by Ansible automatically.
    The tasks are all still included. In most cases, this is not an important distinction;
    however, in circumstances where variables may change, it is.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，任务包括可以对它们应用条件。如果这样做，条件将由Ansible自动分别添加到每个包含的任务中。任务仍然都包括在内。在大多数情况下，这不是一个重要的区别；然而，在变量可能改变的情况下，这是重要的。
- en: The file to include as a task includes contains a list of tasks. If you assume
    the existence of any variables, hosts, or groups, then you should state them in
    comments at the top of the file. This makes it easier for people who wish to reuse
    the file later.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为任务包括的文件包含了一系列任务。如果您假设任何变量、主机或组的存在，那么您应该在文件顶部的注释中说明它们。这样可以更容易地供希望以后重用文件的人使用。
- en: 'So, if you wanted to create a bunch of users and set up their environment with
    their public keys, you would split out the tasks that do a single user to one
    file. This file will look similar to the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您想创建一堆用户并设置他们的环境与他们的公钥，您将把执行单个用户的任务拆分到一个文件中。这个文件看起来类似于以下代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We expect that a variable named `user` will be passed to us, and that their
    public key will be in the `keys` directory. The account is created, the `ssh config`
    directory is made, and finally we can copy this in their public key. The easiest
    way to use this `config` file would be to include it with the `with_items` keyword
    you learned about in [Chapter 3](ch03.html "Chapter 3. Advanced Playbooks"), *Advanced
    Playbooks*. This will look similar to the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望一个名为`user`的变量将被传递给我们，并且他们的公钥将在`keys`目录中。账户被创建，`ssh config`目录被创建，最后我们可以将这个公钥复制进去。使用这个`config`文件的最简单方法是使用您在[第3章](ch03.html
    "第3章。高级Playbooks")中学到的`with_items`关键字。这将类似于以下代码：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Handler includes
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理程序包括
- en: 'When writing Ansible playbooks, you will constantly find yourself reusing the
    same handlers multiple times. For instance, a handler used to restart MySQL is
    going to look the same everywhere. To make this easier, Ansible allows you to
    include other files in the handlers section. Handler includes look the same as
    task includes. You should make sure to include a name on each of your handlers;
    otherwise, you will not be able to refer to them easily in your tasks. A handler
    includes file looks similar to the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Ansible playbooks时，你会不断发现自己多次重复使用相同的处理程序。例如，用于重新启动MySQL的处理程序在任何地方看起来都是一样的。为了使这更容易，Ansible允许你在处理程序部分包含其他文件。处理程序包含看起来与任务包含相同。你应该确保在每个处理程序上包含一个名称；否则，你将无法在任务中轻松地引用它们。处理程序包含文件看起来类似于以下代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This file provides several common tasks that you would want to handle after
    configuring `sendmail`. By including the following handlers in their own files,
    you can easily reuse them whenever you need to change the `sendmail` configuration:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件提供了在配置`sendmail`后你想要处理的几个常见任务。通过在它们自己的文件中包含以下处理程序，你可以在需要更改`sendmail`配置时轻松重用它们。
- en: The first handler regenerates the `sendmail` database's `config` file and triggers
    a `reload` file of `sendmail` later
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个处理程序重新生成`sendmail`数据库的`config`文件，并稍后触发`sendmail`的`reload`文件
- en: The second handler initializes the `aliases` database, and also schedules a
    `reload` file of `sendmail`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个处理程序初始化`aliases`数据库，并安排`sendmail`的`reload`文件
- en: The third handler reloads `sendmail`; it may be triggered by the previous two
    jobs, or it may be triggered directly from a task
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个处理程序重新加载`sendmail`；它可以由前两个作业触发，也可以直接从任务触发
- en: The fourth handler restarts `sendmail` when triggered; this is useful if you
    upgrade `sendmail` to a new version
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个处理程序在触发时重新启动`sendmail`；如果你将`sendmail`升级到新版本，这将很有用
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Handlers can trigger other handlers provided they only trigger the ones specified
    later, instead of the triggered ones. This means you can set up a series of cascading
    handlers that call each other. This saves you from having long lists of handlers
    in the notify section of tasks.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序可以触发其他处理程序，前提是它们只触发稍后指定的处理程序，而不是被触发的处理程序。这意味着你可以设置一系列互相调用的处理程序。这样可以避免在任务的通知部分中有长长的处理程序列表。
- en: 'Using the preceding handler file is easy now. We simply need to remember that
    if we change a `sendmail` configuration file, then we should trigger `config sendmail`,
    and if we change the `aliases` file, we should trigger `config aliases`. The following
    code shows us an example of this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的处理程序文件现在很容易。我们只需要记住，如果我们更改了`sendmail`配置文件，那么我们应该触发`config sendmail`，如果我们更改了`aliases`文件，我们应该触发`config
    aliases`。以下代码向我们展示了一个例子：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This playbook makes sure `sendmail` is installed. If it isn't installed, or
    if it isn't running the latest version, then it installs it or updates it. After
    it is updated, it schedules a restart so that we can be confident that the latest
    version will be running once the playbook is done. In the next step, we replace
    the `sendmail` configuration file with our template. If the `config` file was
    changed by the template, then the `sendmail` configuration files will be regenerated,
    and finally `sendmail` will be reloaded.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个playbook确保`sendmail`已安装。如果它没有安装，或者没有运行最新版本，那么它会安装或更新它。更新后，它会安排重新启动，以便我们可以确信最新版本在playbook完成后运行。在下一步中，我们用我们的模板替换`sendmail`配置文件。如果`config`文件被模板更改，那么`sendmail`配置文件将被重新生成，最后`sendmail`将被重新加载。
- en: Playbook includes
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Playbook includes
- en: Playbook includes should be used when you want to include a whole set of tasks
    designated for a set of machines. For example, you may have a play that gathers
    the host keys of several machines and builds a `known_hosts` file to copy to all
    the machines.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要包含一整套为一组机器指定的任务时，应该使用Playbook includes。例如，你可能有一个play，收集几台机器的主机密钥，并构建一个`known_hosts`文件复制到所有机器上。
- en: While task includes allows you to include tasks, playbook includes allows you
    to include whole plays. This allows you to select the hosts you wish to run on,
    and provide handlers for notify events. Because you are including whole playbook
    files, you can also include multiple plays.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然任务包含允许你包含任务，但playbook包含允许你包含整个plays。这允许你选择你希望运行的主机，并为通知事件提供处理程序。因为你包含整个playbook文件，所以你也可以包含多个plays。
- en: Playbook includes allows you to embed fully self-contained files. It is for
    this reason that you should provide any variables that it requires. If they depend
    on any particular set of hosts or groups, this should be noted in a comment at
    the top of the file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Playbook includes允许你嵌入完全独立的文件。因此，你应该提供它所需的任何变量。如果它依赖于任何特定的主机或组，这应该在文件顶部的注释中注明。
- en: 'This is handy when you wish to run multiple different actions at once. For
    example, let''s say we have a playbook that switches to our DR site, named `drfailover.yml`,
    another named `upgradeapp.yml` that upgrades the app, another named `drfailback.yml`
    that fails back, and finally `drupgrade.yml`. All these playbooks might be valid
    to use separately; however, when performing a site upgrade, you will probably
    want to perform them all at once. You can do this as shown in the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望同时运行多个不同的操作时，这是很方便的。例如，假设我们有一个名为`drfailover.yml`的playbook，用于切换到我们的DR站点，另一个名为`upgradeapp.yml`用于升级应用程序，另一个名为`drfailback.yml`用于失败回退，最后是`drupgrade.yml`。所有这些playbooks可能分别使用有效；然而，在执行站点升级时，你可能希望一次执行它们所有。你可以像下面的代码中所示那样做：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, you can put full plays in the playbooks that you are including
    other playbooks into.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你可以在包含其他playbooks的playbooks中放置完整的plays。
- en: Roles
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色
- en: If your playbooks start expanding beyond what includes can help you solve, or
    you start gathering a large number of templates, you may want to use roles. Roles
    in Ansible allow you to group files together in a defined structure. They are
    essentially an extension to includes that handles a few things automatically,
    and this helps you organize them inside your repository.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的playbooks开始扩展超出了包含可以帮助你解决的范围，或者你开始收集大量模板，你可能想要使用角色。Ansible中的角色允许你以定义的结构将文件组合在一起。它们本质上是包含的扩展，可以自动处理一些事情，这有助于你在存储库中组织它们。
- en: Roles allow you to place your variables, files, tasks, templates, and handlers
    in a folder, and then easily include them. You can also include other roles from
    within roles, which effectively creates a tree of dependencies. Similar to task
    includes, they can have variables passed to them. Using these features, you should
    be able to build self-contained roles that are easy to share with others.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 角色允许你将变量、文件、任务、模板和处理程序放在一个文件夹中，然后轻松地包含它们。你还可以在角色内包含其他角色，这实际上创建了一个依赖树。与任务包含类似，它们可以接收传递给它们的变量。使用这些功能，你应该能够构建自包含的角色，方便与他人分享。
- en: 'Roles are commonly set up to manage services provided by machines, but they
    can also be daemons, options, or simply characteristics. Things you may want to
    configure in a role are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 角色通常用于管理机器提供的服务，但它们也可以是守护进程、选项或简单的特性。你可能想要在角色中配置的内容如下：
- en: Web servers, such as Nginx or Apache
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器，如Nginx或Apache
- en: Messages of the day customized for the security level of the machine
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据机器的安全级别定制的每日消息
- en: Database servers running PostgreSQL or MySQL
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行PostgreSQL或MySQL的数据库服务器
- en: 'To manage roles in Ansible, perform the following steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理Ansible中的角色，请执行以下步骤：
- en: Create a folder named roles with your playbooks.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为roles的文件夹，其中包含你的playbooks。
- en: In the `roles` folder, make a folder for each role that you would like.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`roles`文件夹中，为每个你想要的角色创建一个文件夹。
- en: In the folder for each role, make folders named `files`, `handlers`, `meta`,
    `tasks`, `templates`, and finally `vars`. If you aren't going to use all these,
    you can leave out the ones you don't need. Ansible will silently ignore any missing
    files or directories when using roles.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个角色的文件夹中，创建名为`files`、`handlers`、`meta`、`tasks`、`templates`和最后`vars`的文件夹。如果你不打算使用所有这些，可以省略你不需要的部分。当使用角色时，Ansible会默默地忽略任何缺少的文件或目录。
- en: In your playbooks, add the keyword roles followed by a list of roles that you
    would like to apply to the hosts.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的playbooks中，添加关键字`roles`，后面跟着你想应用到主机的角色列表。
- en: For example, if you had the `common`, `apache`, `website1`, and `website2` roles,
    your directory structure would look similar to the following example. The `site.yml`
    file is for reconfiguring the entire site, and the `webservers1.yml` and `webservers2.yml`
    files are for configuring each web server farm.![Roles](graphics/4267_04_01.jpg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，如果你有`common`、`apache`、`website1`和`website2`角色，你的目录结构将类似于以下示例。`site.yml`文件用于重新配置整个站点，`webservers1.yml`和`webservers2.yml`文件用于配置每个Web服务器群。![Roles](graphics/4267_04_01.jpg)
- en: 'The following file is what could be in `website1.yml`. It shows a playbook
    that applies the `common`, `apache`, and `website1` roles to the `website1` group
    in the inventory. The `website1` role is included using a more verbose format
    that allows us to pass variables to the role, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文件是`website1.yml`中可能包含的内容。它显示了一个应用`common`、`apache`和`website1`角色到清单中的`website1`组的playbook。`website1`角色使用了更详细的格式，允许我们向角色传递变量，如下所示：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For the role named `common`, Ansible will then try to load `roles/common/tasks/main.yml`
    as a task include, `roles/common/handlers/main.yml` as a handler include, and
    `roles/common/vars/main.yml` as a variable file include. If all of these files
    are missing, Ansible will throw an error; however, if one of the files exists,
    then the others, if missing, will be ignored. The following directories are used
    by a default install of Ansible (other directories may be used by different modules):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于名为`common`的角色，Ansible将尝试加载`roles/common/tasks/main.yml`作为任务包含，`roles/common/handlers/main.yml`作为处理程序包含，`roles/common/vars/main.yml`作为变量文件包含。如果所有这些文件都缺失，Ansible将抛出错误；但是，如果其中一个文件存在，那么其他缺失的文件将被忽略。默认安装的Ansible使用以下目录（其他目录可能由不同的模块使用）：
- en: '| Directory | Description |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 目录 | 描述 |'
- en: '| --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `tasks` | The `tasks` folder should contain a `main.yml` file, which should
    include a list of the tasks for this role. Any task includes that are contained
    in these roles will look for their files in this folder also. This allows you
    to split a large number of tasks into separate files, and use other features of
    task includes. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `tasks` | `tasks`文件夹应包含一个`main.yml`文件，其中应包含此角色的任务列表。这些角色中包含的任何任务都将在此文件夹中查找它们的文件。这使你可以将大量任务拆分成单独的文件，并使用任务包含的其他功能。'
- en: '| `files` | The `files` folder is the default location for files in the roles
    that are used by the copy or the script module. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `files` | `files`文件夹是角色中由`copy`或`script`模块使用的文件的默认位置。|'
- en: '| `templates` | The `templates` directory is the location where the template
    module will automatically look for the jinja2 templates included in the roles.
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `templates` | `templates`目录是模板模块自动查找角色中包含的jinja2模板的位置。|'
- en: '| `handlers` | The `handlers` folder should contain a `main.yml` file, which
    specifies the handlers for the roles, and any includes in that folder will also
    look for the files in the same location. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `handlers` | `handlers`文件夹应包含一个`main.yml`文件，指定角色的处理程序，该文件夹中的任何包含也将在相同位置查找文件。|'
- en: '| `vars` | The `vars` folder should contain a `main.yml` file, which contains
    the variables for this role. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `vars` | `vars`文件夹应包含一个`main.yml`文件，其中包含此角色的变量。|'
- en: '| `meta` | The `meta` folder should contain a `main.yml` file. This file can
    contain settings for the role, and a list of its dependencies. This feature is
    available only in Ansible 1.3 and above. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `meta` | `meta`文件夹应包含一个`main.yml`文件。该文件可以包含角色的设置和其依赖项列表。此功能仅在Ansible 1.3及以上版本中可用。|'
- en: '| `default` | You should use the `default` folder if you are expecting variables
    to be sent to this role, and you want to make them optional. A `main.yml` file
    in this folder is read, to get the initial values for variables that can be overridden
    by variables, which are passed from the playbook calling the role. This feature
    is only available in Ansible 1.3 and above. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `default` | 如果您希望将变量发送到此角色，并且希望使它们可选，则应使用`default`文件夹。此文件夹中的`main.yml`文件将被读取，以获取可以被从playbook调用角色的变量覆盖的变量的初始值。此功能仅在Ansible
    1.3及以上版本中可用。|'
- en: 'When using roles, the behavior of the copy, the template, and the script modules
    is slightly altered. In addition to searching for files by looking from the directory
    in which the playbook file is located, Ansible will also look for the files in
    the location of the role. For example, if you are using a role named `common`,
    these modules will change to the following behavior:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用角色时，复制、模板和脚本模块的行为会略有改变。除了通过查找位于playbook文件所在目录中的文件来搜索文件外，Ansible还将在角色的位置中查找文件。例如，如果您使用名为`common`的角色，这些模块的行为将更改为以下行为：
- en: The copy module will look for files in `roles/common/files`.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制模块将在`roles/common/files`中查找文件。
- en: The template module will first look for templates in `roles/common/templates`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板模块将首先在`roles/common/templates`中查找模板。
- en: The script module will first look for files in `roles/common/files`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本模块首先会在`roles/common/files`中查找文件。
- en: The other modules might decide to look for their data in other folders inside
    `roles/common/`. The documentation for modules can be retrieved using `ansible-doc`,
    as was discussed in the *Module help* section of [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Ansible"), *Getting Started with Ansible*.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他模块可能决定在`roles/common/`内的其他文件夹中查找它们的数据。模块的文档可以使用`ansible-doc`检索，就像在[第1章](ch01.html
    "第1章。开始使用Ansible")的*模块帮助*部分中讨论的那样，*开始使用Ansible*。
- en: Role metadata
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色元数据
- en: Using role metadata allows us to specify that our role depends on other roles.
    For example, if the application you are deploying needs to send an e-mail, your
    role could depend on a Postfix role. This would mean that before the application
    is set up and installed, Postfix will be installed and set up.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用角色元数据允许我们指定我们的角色依赖于其他角色。例如，如果您部署的应用程序需要发送电子邮件，则您的角色可以依赖于Postfix角色。这意味着在设置和安装应用程序之前，将安装和设置Postfix。
- en: 'The `meta/main.yml` file will look similar to the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`meta/main.yml`文件将类似于以下代码：'
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `allow_duplicates` line is set to `no`, which is the default. If you set
    this to `no`, Ansible will not run a role the second time, if it is included twice
    with the same arguments. If you set it to `yes`, it will repeat the role even
    if it has run before. You can leave it `off` instead of setting it to `no`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`allow_duplicates`行设置为`no`，这是默认值。如果将其设置为`no`，则Ansible不会第二次运行角色，如果使用相同的参数两次。如果将其设置为`yes`，即使之前已经运行过，它也会重复运行角色。您可以将其设置为`off`而不是设置为`no`。'
- en: Dependencies are specified in the same format as roles. This means you can pass
    variables here; either static values or variables that are passed to the current
    role.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项的格式与角色相同。这意味着您可以在这里传递变量；可以是静态值，也可以是传递给当前角色的变量。
- en: Role defaults
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色默认值
- en: 'The second feature included with Ansible 1.3 is variable default values. If
    you place a `main.yml` file in the defaults directory for the role, these variables
    will be read into the role; however, they can be overridden by variables in the
    `vars/main.yml` file, or the variables that are passed to the role when it is
    included. This allows you to make passing variables to the role optional. These
    files look exactly like other variable files. For example, if you used a variable
    named `port` in your role, and you want to default it to port `80`, your `defaults/main.yml`
    file will look similar to the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与Ansible 1.3一起包含的第二个功能是变量默认值。如果在角色的默认目录中放置`main.yml`文件，则这些变量将被读入角色；但是，它们可以被`vars/main.yml`文件中的变量或包含角色时传递的变量覆盖。这允许您将传递给角色的变量设置为可选。这些文件看起来与其他变量文件完全相同。例如，如果在角色中使用名为`port`的变量，并且要将其默认为端口`80`，则`defaults/main.yml`文件将类似于以下代码：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Speeding things up
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加快速度
- en: As you add more and more machines and services to your Ansible configuration,
    you will find things getting slower and slower. Fortunately, there are several
    tricks you can use to make Ansible work on a bigger scale.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您向Ansible配置中添加越来越多的机器和服务，您会发现事情变得越来越慢。幸运的是，有几个技巧可以让您在更大的规模上使用Ansible。
- en: Provisioning
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: Ansible isn't just limited to being able to configure our machines; we can also
    use it to create the machines that we will be configuring. We are also not limited
    to just making the machines to be configured, we can also make networks, load
    balancers, DNS entries, or even your whole infrastructure. You can even have this
    automatically happen before you provision the machine by using the `group`, `group_by`
    and `add_host` modules.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible不仅仅局限于能够配置我们的机器；我们还可以使用它来创建我们将要配置的机器。我们不仅仅局限于制作将要配置的机器，还可以制作网络、负载均衡器、DNS条目，甚至整个基础架构。您甚至可以在配置机器之前自动执行此操作，方法是使用`group`、`group_by`和`add_host`模块。
- en: 'In the following example, we use Google Compute to create two machines, and
    then install and start MySQL server on them:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用Google Compute创建两台机器，然后在它们上安装并启动MySQL服务器：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tags
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签
- en: Ansible tags are features that allow you to select the parts of a playbook that
    you need to run, and which should be skipped. While Ansible modules are idempotent
    and will automatically skip if there are no changes, this often requires a connection
    to the remote hosts. The yum module is often quite slow in determining whether
    a module is the latest, as it will need to refresh all the repositories.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible标签是一种功能，允许您选择需要运行的playbook的部分，以及应该跳过的部分。虽然Ansible模块是幂等的，如果没有更改，它们将自动跳过，但这通常需要连接到远程主机。yum模块通常在确定模块是否最新时速度相当慢，因为它需要刷新所有存储库。
- en: If you know you don't need certain actions to be run, you can select to run
    only those tasks that have been tagged with a particular tag. This doesn't even
    try to run the tasks, it simply skips over it. This will save time on almost all
    the modules even if there is nothing to be done.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道不需要运行某些操作，可以选择仅运行已标记特定标签的任务。这甚至不会尝试运行任务，它只是简单地跳过。即使没有任何操作要执行，这将节省几乎所有模块的时间。
- en: Let's say you have a machine that has a large number of shell accounts, but
    also several services set up to run on it. Now, imagine that a single user's SSH
    key has been compromised and needs to be removed immediately. Instead of running
    the entire playbook, or rewriting the playbooks to only include the steps necessary
    to remove that key, you could simply run the existing playbooks with the SSH keys
    tag, and it would only run the steps necessary to copy out the new keys, instantly
    skipping anything else.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一台拥有大量shell帐户的机器，但也设置了几个服务来运行。现在，想象一下一个用户的SSH密钥已经被泄露，需要立即删除。您可以简单地运行现有的playbooks，带有SSH密钥标签，它只会运行必要的步骤来复制新密钥，立即跳过其他任何操作。
- en: This is particularly useful if you have a playbook with playbook includes in
    it that covers your whole infrastructure. With this setup, you can quickly deploy
    security patches, change passwords, and revoke keys across your entire infrastructure
    as quickly as possible.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个包含整个基础架构的playbook，并且其中包含playbook包含，这将特别有用。通过这种设置，您可以尽快部署安全补丁，更改密码，并在整个基础架构中撤销密钥。
- en: 'Tagging tasks is really easy; simply add a key named `tag`, and set its value
    to a list of the tags you want to give it. The following code shows us how to
    do this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 标记任务非常简单；只需添加一个名为`tag`的键，并将其值设置为您想要赋予它的标签列表。以下代码向我们展示了如何做到这一点：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This play defines the `patch`, `deploy`, and `config` tags. If you know which
    operation you wish to do in advance, you can run Ansible with the correct argument,
    only running the operations you choose. If you don''t supply a tag on the command
    line, the default is to run every task. For example, if you want Ansible to only
    run the tasks tagged as `deploy`, you will run the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此play定义了`patch`、`deploy`和`config`标签。如果您事先知道要执行的操作，可以使用正确的参数运行Ansible，仅运行您选择的操作。如果您在命令行上没有提供标签，则默认情况下会运行每个任务。例如，如果您希望Ansible仅运行标记为`deploy`的任务，您将运行以下命令：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In addition to working on discrete tasks, tags are also available to roles,
    which make Ansible apply only the roles for the tags that have been supplied on
    the command line. You apply them similarly to the way they are applied to tasks.
    For example, refer to the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了处理离散任务外，角色也可以使用标签，这使得Ansible仅应用于在命令行上提供的标签的角色。您可以类似地应用它们，就像它们应用于任务一样。例如，请参考以下代码：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, the `common` role does not get any tags, and will not
    be run if there are any tags applied. If the `patch` tag is applied, the `apache`
    and `website2` roles will be applied, but not `common`. If the `deploy` tag is
    applied; only the `website2` tag will be run. This will shorten the time required
    to patch servers or run deployments, as the unnecessary steps will be completely
    skipped.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`common`角色不会得到任何标签，并且如果应用了任何标签，它将不会运行。如果应用了`patch`标签，则将应用`apache`和`website2`角色，但不会应用`common`。如果应用了`deploy`标签；只有`website2`标签将被运行。这将缩短打补丁服务器或运行部署所需的时间，因为不必要的步骤将被完全跳过。
- en: Ansible's pull mode
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible的拉模式
- en: Ansible includes a pull mode that can drastically improve the scalability of
    your playbooks. So far we have only covered using Ansible to configure another
    machine over SSH. This is a contrast to Ansible's pull mode, which runs on the
    host that you wish to configure. Since `ansible-pull` runs on the machine that
    it is configuring, it doesn't need to make connections to other machines and runs
    much faster. In this mode, you provide your configuration in a git repository
    that Ansible downloads and uses to configure your machine.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible包含了一个拉模式，可以显著提高playbook的可扩展性。到目前为止，我们只讨论了使用Ansible通过SSH配置另一台机器。这与Ansible的拉模式形成对比，后者在您希望配置的主机上运行。由于`ansible-pull`在配置它的机器上运行，它不需要与其他机器建立连接，并且运行速度更快。在这种模式下，您可以在git存储库中提供配置，Ansible会下载并用于配置您的机器。
- en: 'You should use Ansible''s pull mode in the following situations:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在以下情况下使用Ansible的拉模式：
- en: Your node might not be available when configuring them, such as members of auto-scaling
    server farms
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在配置节点时，您的节点可能不可用，比如自动扩展服务器群的成员
- en: You have a large amount of machines to configure and even with large values
    of forks, it would take a long time to configure them all
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有大量的机器需要配置，即使使用大量的forks值，也需要很长时间来配置它们
- en: You want machines to update their configuration automatically when the repository
    changes
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望机器在存储库更改时自动更新其配置
- en: You want to run Ansible on a machine that may not have network access yet, such
    as in a kick start post install
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望在可能没有网络访问权限的机器上运行Ansible，比如在kick start后安装
- en: 'However, the pull mode does have the following disadvantages that make it unsuitable
    for certain circumstances:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，拉模式确实具有以下缺点，使其不适用于某些情况：
- en: To connect to other machines and gather variables, or to copy a file, you need
    to have credentials on the managed nodes
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要连接到其他机器并收集变量，或者复制文件，您需要在受控节点上拥有凭据
- en: You need to co-ordinate the running of the playbook across a server farm; for
    example, if you could only take three servers offline at a time
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要协调服务器群上的playbook运行；例如，如果一次只能使三台服务器脱机
- en: The servers are behind strict firewalls that don't allow incoming SSH connections
    from the nodes you used to configure them for Ansible
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器位于严格的防火墙后，不允许来自用于为Ansible配置它们的节点的传入SSH连接
- en: 'The pull mode doesn''t require anything special in your playbooks, but it does
    require some setup on the nodes you want configured. In some circumstances, you
    can do this using Ansible''s normal push mode. Here is a small play to setup pull
    mode on a machine:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取模式在您的playbook中不需要任何特殊设置，但是需要在要配置的节点上进行一些设置。在某些情况下，您可以使用Ansible的正常推送模式来执行此操作。以下是在机器上设置拉取模式的小玩法：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, we performed the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们执行了以下步骤：
- en: First we installed and set up **EPEL**. This is a repository with extra software
    for CentOS. Ansible is available in the EPEL repository.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们安装并设置了**EPEL**。这是一个为CentOS提供额外软件的存储库。Ansible可在EPEL存储库中获得。
- en: Next we installed Ansible, making sure to enable the EPEL repository.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们安装了Ansible，并确保启用了EPEL存储库。
- en: Then we created a directory for Ansible's pull mode to put the playbooks in.
    Keeping these files around means you don't need to download the whole git repository
    all the time; only updates are required.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们为Ansible的拉取模式创建了一个目录，以放置playbooks。保留这些文件意味着您不需要一直下载整个git存储库；只需要更新即可。
- en: Finally we set up a cron job that will try to run the `ansible-pull` mode config
    every five minutes.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们设置了一个定时任务，每五分钟尝试运行`ansible-pull`模式配置。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding code downloads the repository off an internal HTTPS git server.
    If you want to download the repository instead of SSH, you will need to add a
    step to install SSH keys, or generate keys and copy them to the git machine.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码从内部HTTPS git服务器下载存储库。如果您想要下载存储库而不是SSH，则需要添加一步来安装SSH密钥，或者生成密钥并将其复制到git机器上。
- en: Storing secrets
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储机密信息
- en: Eventually, you will need to include sensitive data in your Ansible recipes.
    All the recipes that we have discussed so far have to be stored on the disk in
    plain text; if you are also storing it in source control, then third parties may
    even have access to this data. This is risky and may be in violation of your corporate
    policies.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，您将需要在您的Ansible配方中包含敏感数据。到目前为止，我们讨论过的所有配方都必须以纯文本形式存储在磁盘上；如果您还将其存储在源代码控制中，则第三方甚至可能访问这些数据。这是有风险的，可能违反您的公司政策。
- en: This can be avoided using Ansible vaults. Vaults are files that are encrypted
    and can be decrypted by Ansible transparently. You can use them for includes,
    variable files, tasks lists in roles and any other YAML formatted file that Ansible
    uses. You can also use it with both JSON and YAML files included with the `-e`
    command-line argument to ansible-playbook. Vault files are managed with the `ansible-vault`
    command and can be used as if they were not encrypted at all.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Ansible保险库来避免这种情况。保险库是加密的文件，可以由Ansible透明地解密。您可以将它们用于包含、变量文件、角色中的任务列表以及Ansible使用的任何其他YAML格式文件。您还可以将其与包含在`ansible-playbook`的`-e`命令行参数中的JSON和YAML文件一起使用。保险库文件由`ansible-vault`命令管理，并且可以像未加密的文件一样使用。
- en: 'The `ansible-vault` command has several modes, which are given as the first
    argument. This table describes the modes:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible-vault`命令有几种模式，这些模式作为第一个参数给出。此表描述了这些模式：'
- en: '| Mode | Action |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 操作 |'
- en: '| --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Create` | This starts your default editor to create a new encrypted file
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `创建` | 这将启动您的默认编辑器以创建一个新的加密文件 |'
- en: '| `Encrypt` | This encrypts an existing file, turning it into a vault |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `加密` | 这将加密现有文件，将其转换为保险库 |'
- en: '| `Edit` | This edits a vault allowing you to change the content |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `编辑` | 这将编辑一个保险库，允许您更改内容 |'
- en: '| `Rekey` | This changes the password that is used to encrypt the vault |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `重新设置密码` | 这将更改用于加密保险库的密码 |'
- en: '| `Decrypt` | This decrypts the vault turning it back into a regular file |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `解密` | 这将解密保险库，将其转换回常规文件 |'
- en: 'For example, to create a new variable file for your staging environment you
    would run:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要为您的暂存环境创建一个新的变量文件，您将运行：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This command will prompt you for a password, ask you to confirm it, and then
    open your editor so that you can add the content; finally, the encrypted content
    will be saved in `vars/staging.yml`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将提示您输入密码，要求您确认密码，然后打开您的编辑器，以便您添加内容；最后，加密的内容将保存在`vars/staging.yml`中。
- en: When using a vault file, you need to provide the password so that they can be
    decrypted. This can be done in one of three ways. You can give the `--ask-vault-pass`
    argument to Ansible, which will cause Ansible to prompt for the password every
    time it starts. You can also use the `--vault-password-file` argument, which points
    to a file containing the password. Finally, you can add `vault_password_file`
    to the `ansible.cfg` file to automatically make Ansible use the vault password
    file for every command. It is important to note that only one password can be
    supplied for each Ansible run, so you can't include several different files with
    different passwords.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用保险库文件时，您需要提供密码以便进行解密。有三种方法可以做到这一点。您可以给Ansible提供`--ask-vault-pass`参数，这将导致Ansible每次启动时提示输入密码。您还可以使用`--vault-password-file`参数，该参数指向包含密码的文件。最后，您可以将`vault_password_file`添加到`ansible.cfg`文件中，以便每次命令都自动使用保险库密码文件。重要的是要注意，每次Ansible运行只能提供一个密码，因此您不能包含具有不同密码的几个不同文件。
- en: 'In order to have Ansible prompt for a password to run a playbook that is encrypted,
    you will do the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Ansible提示输入密码来运行加密的playbook，您需要执行以下操作：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The password file can also be an executable. To print to the screen print to
    standard error, to read from the user you can use `stdin` as usual and finally
    the script needs to print the password to `stdout` before it exits.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 密码文件也可以是可执行文件。要打印到屏幕，请打印到标准错误，要从用户那里读取，您可以像往常一样使用`stdin`，最后脚本需要在退出之前将密码打印到`stdout`。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have covered the techniques required when moving from a
    simple setup to a larger deployment. We discussed how to separate your playbook
    into multiple parts using includes. We then looked at how we can package related
    includes and automatically include them all at once using roles. Finally, we discussed
    the pull mode, which allows you to automate the deployment of playbooks on the
    remote node itself.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经介绍了从简单设置转移到更大规模部署时所需的技术。我们讨论了如何使用包含来将你的playbook分成多个部分。然后，我们看了一下如何打包相关的包含，并使用角色自动全部包含它们。最后，我们讨论了拉取模式，它允许你在远程节点上自动化部署playbook。
- en: In the next chapter, we will cover writing your own modules. We start this by
    building a simple module using bash scripting. We then look at how Ansible searches
    for modules, and how to make it find your own custom ones. Then, we take a look
    at how you can use Python to write more advanced modules using features that Ansible
    provides. Finally we will write a script that configures Ansible to pull its inventory
    from an external source.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何编写自己的模块。我们首先通过使用bash脚本构建一个简单的模块来开始。然后，我们将看看Ansible是如何搜索模块的，以及如何让它找到你自己定制的模块。接下来，我们将介绍如何使用Python编写更高级的模块，利用Ansible提供的功能。最后，我们将编写一个脚本，配置Ansible从外部来源获取清单。
