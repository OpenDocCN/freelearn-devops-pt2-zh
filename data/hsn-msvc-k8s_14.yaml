- en: The Future of Microservices and Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务和Kubernetes的未来
- en: The software systems of tomorrow will be bigger, more complicated, will be able
    to handle more data, and will have an even bigger impact on our world. Just think
    about self-driving cars and ubiquitous robots. The human capacity to deal with
    complexity will not scale. That means that we will have to use a divide-and-conquer
    approach to build those complex software systems. Microservice-based architectures
    will continue to replace monoliths. Then, the challenge will shift into coordinating
    all those microservices into a coherent whole. This is where Kubernetes comes
    in as the standard orchestration solution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 明天的软件系统将会更大、更复杂，能够处理更多的数据，并且对我们的世界产生更大的影响。想想无人驾驶汽车和无处不在的机器人。人类处理复杂性的能力不会扩展。这意味着我们将不得不采用分而治之的方法来构建这些复杂的软件系统。基于微服务的架构将继续取代单体架构。然后，挑战将转移到协调所有这些微服务成为一个连贯整体。这就是Kubernetes作为标准编排解决方案的作用所在。
- en: In this chapter, we will discuss the near future of microservices and Kubernetes.
    We will focus on the near future, because the innovation pace is amazing and trying
    to look much further ahead is futile. The long-term vision is that AI will probably
    advance to the point where most software development can be automated. At this
    point, human limits of handling complexity may not apply, and the software developed
    by AI will not be understandable by humans.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论微服务和Kubernetes的近期发展。我们将关注近期的发展，因为创新的速度令人惊叹，试图展望更远的未来是徒劳的。长期愿景是，人工智能可能会进步到大部分软件开发可以自动化的程度。在这一点上，人类处理复杂性的限制可能不适用，而由人工智能开发的软件将无法被人类理解。
- en: So, let's leave the far future alone and, in the spirit of being hands-on, discuss
    the emerging technologies, standards, and trends that will be relevant in the
    next few years, of which you may want to become aware.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们把遥远的未来放在一边，以亲身实践的精神讨论新兴技术、标准和趋势，这些将在未来几年内变得相关，你可能想要了解。
- en: 'The topics we will cover include some microservices themes, such as the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖一些微服务主题，例如以下内容：
- en: Microservices versus serverless functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务与无服务器函数
- en: Microservices, containers, and orchestration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务、容器和编排
- en: gRPC/gRPC-Web
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC/gRPC-Web
- en: HTTP/3
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP/3
- en: GraphQL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL
- en: 'We will also discuss some Kubernetes themes:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论一些Kubernetes主题：
- en: Kubernetes extensibility
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes的可扩展性
- en: Service mesh integration
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务网格集成
- en: Serverless computing on Kubernetes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Kubernetes的无服务器计算
- en: Kubernetes and VMs
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes和虚拟机
- en: Cluster autoscaling
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群自动缩放
- en: Using operators
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用操作员
- en: Let's start with microservices.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从微服务开始。
- en: The future of microservices
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的未来
- en: Microservices are the dominant approach for building modern, large-scale systems
    today. But, are they going to remain the top choice? Let's find out.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是构建现代大规模系统的主要方法。但是，它们是否会继续是首选？让我们找出答案。
- en: Microservices versus serverless functions
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务与无服务器函数
- en: One of the biggest questions regarding the future of microservices is whether
    serverless functions are going to make microservices obsolete. The answer is absolutely
    not. There are are many great benefits to serverless functions, as well as some
    serious limitations, such as cold start and time limits. Those limitations accumulate
    when you have functions invoking other functions. The execution time limits for
    function are very problematic if you want to apply retry logic with exponential
    backoff. A long-running service can keep local state and connections to data stores,
    and respond quicker to requests. But, for me, the biggest issue with serverless
    functions is that they represent a single function, which equates to a single
    endpoint of a service. I find a lot of value in the abstraction of a service that
    encapsulates a complete domain. If you try to port a service with 10 methods to
    serverless functions, then you'll run into management issues.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关于微服务的未来最大的问题之一是，无服务器函数是否会使微服务过时。答案绝对是否定的。无服务器函数有许多很好的优点，以及一些严重的限制，比如冷启动和时间限制。当你的函数调用其他函数时，这些限制会累积。如果你想应用指数退避的重试逻辑，函数的执行时间限制就会成为一个很大的问题。一个长时间运行的服务可以保持本地状态和与数据存储的连接，并更快地响应请求。但对我来说，无服务器函数最大的问题是它们代表一个单一的函数，相当于一个服务的单一端点。我发现将一个封装完整领域的服务抽象出来是非常有价值的。如果你试图将一个有10个方法的服务转移到无服务器函数，那么你将遇到管理问题。
- en: All those 10 functions will need access to the same data store, and multiple
    functions might need to be modified. All the functions will need similar access,
    configuration, and credentials to access various dependencies. Microservices will
    remain the backbone of large, cloud-native distributed systems. However, a lot
    of work will be offloaded to serverless functions, which makes sense. We will
    probably see some systems composed solely from serverless functions, but these
    will be forced and will have to make compromises.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些10个功能都需要访问相同的数据存储，并且可能需要修改多个功能。所有这些功能都需要类似的访问、配置和凭据来访问各种依赖关系。微服务将继续是大型、云原生分布式系统的支柱。然而，很多工作将被转移到无服务器函数，这是有道理的。我们可能会看到一些系统完全由无服务器函数组成，但这将是被迫的，并且必须做出妥协。
- en: Let's see the symbiotic relationship between microservices and containers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看微服务和容器之间的共生关系。
- en: Microservices, containers, and orchestration
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务、容器和编排
- en: When you break up a monolith into microservices, or start building a microservice-based
    system from scratch, you end up with a lot of services. You need to package, deploy,
    upgrade, and configure all those microservices. Containers address the packaging
    problem. Without containers, it is very difficult to scale microservice-based
    systems. As the number of microservices in the system grows orchestrating, the
    various containers and optimal scheduling requires a dedicated solution. This
    is where Kubernetes excels. The future of distributed systems is more microservices,
    packaged into more containers, which require Kubernetes to manage them. I say
    Kubernetes here, because in 2019, Kubernetes won the container orchestration wars.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个单体应用程序分解成微服务，或者从头开始构建一个基于微服务的系统时，你最终会得到很多服务。你需要打包、部署、升级和配置所有这些微服务。容器解决了打包问题。没有容器，很难扩展基于微服务的系统。随着系统中微服务数量的增加，需要一个专门的解决方案来编排各种容器和进行最佳调度。这就是Kubernetes的优势所在。分布式系统的未来是更多的微服务，打包成更多的容器，需要Kubernetes来管理它们。我在这里提到Kubernetes，是因为在2019年，Kubernetes赢得了容器编排之战。
- en: Another aspect of many microservices is that they need to communicate with each
    other over a network. Where as in a monolith, most interactions are just function
    calls, in a microservice environment, a lot of interactions require hitting an
    endpoint or making a remote procedure call. Enter gRPC.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 许多微服务的另一个方面是它们需要通过网络相互通信。在单体架构中，大多数交互只是函数调用，但在微服务环境中，许多交互需要命中端点或进行远程过程调用。这就是gRPC的作用。
- en: gRPC and gRPC-Web
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC和gRPC-Web
- en: gRPC is Google's remote procedure call protocol. Over the years, there were
    many RPC protocols. I still remember the days of CORBA and DCOM, and Java RMI.
    Fast-forward to the modern web, where REST beat SOAP to become the big gorilla
    in the arena of web APIs. But, these days, gRPC is beating REST. gRPC provides
    a contract-based model with strong typing, efficient payload based on protobuf,
    and is automatically generating client code. The combination is very powerful.
    The last refuge of REST was its ubiquity and the ease of calling REST APIs bearing
    JSON payloads from web applications running in the browser.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC是谷歌的远程过程调用协议。多年来，出现了许多RPC协议。我仍然记得CORBA和DCOM以及Java RMI的日子。快进到现代网络，REST击败了SOAP成为Web
    API领域的大猩猩。但是，如今，gRPC正在击败REST。gRPC提供了基于契约的模型，具有强类型、基于protobuf的高效负载，并自动生成客户端代码。这种组合非常强大。REST的最后避难所是其无处不在和从浏览器中运行的Web应用程序调用携带JSON负载的REST
    API的便利性。
- en: But, even this advantage is fading away. You could always put a REST-compatible
    gRPC gateway in front of your gRPC service, but I consider it a kludge. On the
    other hand, gRPC-web is a full-fledged JavaScript library that lets web applications
    simply invoke gRPC services. See [https://github.com/grpc/grpc-web/tree/master/packages/grpc-web](https://github.com/grpc/grpc-web/tree/master/packages/grpc-web).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，即使这种优势正在消失。您始终可以在gRPC服务前面放置一个与REST兼容的gRPC网关，但我认为这是一种权宜之计。另一方面，gRPC-web是一个完整的JavaScript库，可以让Web应用程序简单地调用gRPC服务。参见[https://github.com/grpc/grpc-web/tree/master/packages/grpc-web](https://github.com/grpc/grpc-web/tree/master/packages/grpc-web)。
- en: GraphQL
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL
- en: If gRPC is the REST killer inside the cluster, then GraphQL is the REST killer
    at the edge. GraphQL is simply a superior paradigm. It gives the frontend developers
    a lot of freedom to evolve their designs. It decouples the needs of the frontend
    from the rigid APIs of the backend and serves as the perfect BFF (backends-for-frontends)
    pattern. See [https://samnewman.io/patterns/architectural/bff/](https://samnewman.io/patterns/architectural/bff/).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果gRPC是集群内的REST杀手，那么GraphQL就是边缘的REST杀手。GraphQL只是一种更优越的范例。它给前端开发人员很大的自由来发展他们的设计。它将前端的需求与后端的严格API解耦，并作为完美的BFF（面向前端的后端）模式。参见[https://samnewman.io/patterns/architectural/bff/](https://samnewman.io/patterns/architectural/bff/)。
- en: Similar to gRPC contracts, the structured schema of a GraphQL service is very
    enticing for large-scale systems.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与gRPC合同类似，GraphQL服务的结构化模式对于大规模系统非常诱人。
- en: In addition, GraphQL solves the dreaded *N+1* problems of traditional REST APIs,
    where you first fetch a list of *N* resources from a REST endpoint and then you
    have to make *N* more calls (one per resource) to get related resources on each
    of the *N* items in the list.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，GraphQL解决了传统REST API中可怕的*N+1*问题，其中您首先从REST端点获取*N*个资源列表，然后您必须进行*N*次更多的调用（每个资源一个）以获取列表中每个*N*项的相关资源。
- en: I expect GraphQL to gain more and more mindshare as developers become more comfortable,
    awareness grows, tooling improves, and learning materials become more available.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计随着开发人员变得更加舒适，意识增强，工具改进和学习材料变得更加可用，GraphQL将获得越来越多的关注。
- en: HTTP/3 is coming
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP/3即将到来
- en: 'The web is built on HTTP. There is no question about it. It''s pretty amazing
    how well this protocol fared. Here is a quick recap: in 1991, Tim-Berneres-Lee
    proposes HTTP 0.9 to support his idea for a World Wide Web. In 1996, The HTTP
    Working Group publishes HTTP 1.0 as the informational RFC 1945 to enable the internet
    boom of the late 1990s.  In 1997, the first official RFC 2068 for HTTP 1.1 is
    published. In 1999, RFC 2616 adds a number of improvements to HTTP 1.1 and remains
    the dominant standard for two decades. In 2015, HTTP/2 is published, based on
    the SPDY protocol by Google, and all major browsers add support for it.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Web是建立在HTTP之上的。毫无疑问。这个协议的表现非常出色。以下是一个快速回顾：1991年，Tim-Berneres-Lee提出了HTTP 0.9来支持他对万维网的构想。1996年，HTTP工作组发布了信息性RFC
    1945，推出了HTTP 1.0，以促进20世纪90年代末的互联网繁荣。1997年，发布了HTTP 1.1的第一个官方RFC 2068。1999年，RFC
    2616对HTTP 1.1进行了一些改进，并成为了两个十年的主要标准。2015年，基于Google的SPDY协议发布了HTTP/2，并且所有主要浏览器都支持它。
- en: 'gRPC is built on top of HTTP/2, which fixes a lot of issues with previous revisions
    of the HTTP and provides the following features:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC建立在HTTP/2之上，修复了以前版本的HTTP中的许多问题，并提供了以下功能：
- en: Binary framing and compression
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制帧和压缩
- en: Multiplexing using streams (multiple requests on the same TCP connection)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流进行多路复用（在同一个TCP连接上进行多个请求）
- en: Better flow control
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的流量控制
- en: Server push
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器推送
- en: That sounds great. What will HTTP/3 give us? It offers the same feature set
    of HTTP/2\. However, HTTP/2 is based on TCP, which doesn't offer streams. That
    means that streams are implemented at the HTTP/2 level. HTTP/3 is based on QUIC,
    a reliable transport over UDP. The details are out of scope, but the bottom line
    is that HTTP/3 will have much better performance and is always secure.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很不错。HTTP/3会给我们带来什么？它提供了与HTTP/2相同的功能集。然而，HTTP/2基于TCP，不支持流。这意味着流是在HTTP/2级别实现的。HTTP/3基于QUIC，这是一种基于UDP的可靠传输。细节超出了范围，但底线是HTTP/3将具有更好的性能，并且始终是安全的。
- en: It may still take a while for broad HTTP/3 adoption, because many enterprises
    block or rate limit UDP on their networks. However, the benefits are compelling
    and gRPC over HTTP/3 will have even a bigger edge in performance compared to REST
    APIs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛采用HTTP/3可能仍需要一段时间，因为许多企业会在其网络上阻止或限制UDP。然而，其优势是令人信服的，而且相比REST API，基于HTTP/3的gRPC将具有更大的性能优势。
- en: Those are the primary future trends that will impact microservices. Let's see
    what is next for Kubernetes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是将影响微服务的主要未来趋势。让我们看看Kubernetes的下一步发展。
- en: The future of Kubernetes
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes的未来
- en: Kubernetes is here to stay. I will make a bold prediction and say that it will
    be around for decades. It is undeniably the current leader in the container orchestration
    space, but more importantly, it is designed in a super-extensible way. Any potential
    improvement can be built on top of the nice building blocks that Kubernetes provides
    (for example, service mesh) or replace those building blocks (such as network
    plugins, storage plugins, and custom schedulers). It is hard to imagine a brand
    new platform that will make Kubernetes obsolete, as opposed to improving and integrating
    it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是不可或缺的。我敢做一个大胆的预测，说它将在未来几十年内一直存在。它无可否认地是容器编排领域的当前领导者，但更重要的是，它的设计方式非常可扩展。任何潜在的改进都可以建立在Kubernetes提供的良好基础之上（例如服务网格），或者替换这些基础（如网络插件、存储插件和自定义调度器）。很难想象会有一个全新的平台能够使Kubernetes过时，而不是改进和整合它。
- en: In addition, the industry momentum behind Kubernetes and the way it is developed
    in the open and managed by the CNCF is inspiring. Even though it originated from
    Google, there is no sentiment that it is Google's project. It is perceived as
    a true open source project that benefits everyone.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Kubernetes背后的行业动力以及它在CNCF的开放开发和管理方式都很鼓舞人心。尽管它起源于谷歌，但没有人认为它是谷歌的项目。它被视为一个真正使每个人受益的开源项目。
- en: Now, consider that Kubernetes caters to the needs of the entire spectrum, from
    hobbyists playing with local Kubernetes on their laptops, through developers,
    testing locally or in the cloud, all the way to large enterprises that require
    certification and support for their own on-premises data centers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑到Kubernetes满足了整个领域的需求，从业余爱好者在笔记本电脑上玩转本地Kubernetes，到在本地或云端进行测试的开发人员，一直到需要对其自己的本地数据中心进行认证和支持的大型企业。
- en: Pretty much the only criticism there is against Kubernetes is that it is hard
    to learn. This is true at the moment, but it will get easier and easier. There
    is a lot of good training material. Developers and operators will gain experience.
    It's easy to find information and the community is large and vibrant.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对Kubernetes唯一的批评就是它很难学。目前是这样，但它会变得越来越容易。有很多好的培训材料。开发人员和运维人员会获得经验。很容易找到信息，社区也很大且充满活力。
- en: A lot of people say that Kubernetes will become boring soon and will become
    an invisible infrastructure layer. I don't subscribe to this point of view. Some
    hard parts of the Kubernetes experience, such as setting up a cluster and installing
    a lot of additional software into the cluster, will become boring, but I think
    we'll see a lot of innovation across the board in the next 5 years.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人说Kubernetes很快就会变得无聊，并成为一个看不见的基础设施层。我不认同这个观点。Kubernetes体验中的一些难点，比如设置集群和在集群中安装大量额外软件，会变得无聊，但我认为在未来5年里我们会看到各个方面的创新。
- en: Let's dive into specific technologies and trends.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解具体的技术和趋势。
- en: Kubernetes extensibility
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes的可扩展性
- en: This is an easy call. Kubernetes was always designed as an extensible platform.
    But, some of the extension mechanisms required merging into the main Kubernetes
    repository. The Kubernetes developers recognized early the limitations and, across
    the board, introduced more loosely coupled mechanisms to extend Kubernetes and
    replace pieces that were considered core components in the past.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很容易的选择。Kubernetes一直被设计为一个可扩展的平台。但是，一些扩展机制需要合并到主Kubernetes存储库中。Kubernetes开发人员早早地意识到了这些限制，并在各个方面引入了更松散耦合的机制来扩展Kubernetes，并替换过去被视为核心组件的部分。
- en: Abstracting the container runtime
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象容器运行时
- en: 'Docker used to be the only container runtime that Kubernetes supported. Then
    it added special support to the now-defunct RKT runtime. However, later, it introduced
    the **Container Runtime Interface** (**CRI**) as a way to integrate any container
    runtime through a standard interface. Here are some of the runtimes that implement
    CRI and can be used in Kubernetes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Docker曾经是Kubernetes支持的唯一容器运行时。然后它为现在已废弃的RKT运行时添加了特殊支持。然而，后来，它引入了**容器运行时接口**（**CRI**）作为通过标准接口集成任何容器运行时的方法。以下是一些实现CRI并可在Kubernetes中使用的运行时：
- en: Docker (of course)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker（当然）
- en: CRI-O (supports any OCI image)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CRI-O（支持任何OCI镜像）
- en: Containerd (became an CNCF graduate in February 2019)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Containerd（于2019年2月成为CNCF毕业生）
- en: Frakti (Kata containers)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Frakti（Kata容器）
- en: PouchContainer (P2P image distribution, optional VM-based)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PouchContainer（P2P镜像分发，可选的基于VM）
- en: Abstracting networking
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象网络
- en: Kubernetes networking always required a **Container Networking Interface** (**CNI**)
    plugin. It is yet another CNCF project. It allows a lot of innovation in the networking
    and network security space.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes网络始终需要Container Networking Interface（CNI）插件。这是另一个CNCF项目。它允许在网络和网络安全领域进行大量创新。
- en: You can find here a long list of platforms that support CNI (beyond Kubernetes)
    and an even longer list of plugins at [https://github.com/containernetworking/cni.](https://github.com/containernetworking/cni)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到支持CNI（超出Kubernetes范围）的平台的长列表，以及更长的插件列表[https://github.com/containernetworking/cni.](https://github.com/containernetworking/cni)
- en: I expect the CNI to remain the standard interface for networking solutions.
    A very interesting project is Cilium, which utilizes the **extended Berkeley Packet
    Filter** (**eBPF**) to provide very high-performance networking and security at
    the Linux-kernel level, which may offset some of the overhead of service mesh
    sidecar proxies.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我期望CNI仍然是网络解决方案的标准接口。一个非常有趣的项目是Cilium，它利用扩展的伯克利数据包过滤器（eBPF）在Linux内核级别提供非常高性能的网络和安全性，这可能抵消一些服务网格边车代理的开销。
- en: Abstracting storage
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象存储
- en: Kubernetes has an abstract storage model, based on volumes and persistent volume
    claims. It supports a large number of storage solution in-trees. This means those
    storage solutions had to be built into the Kubernetes code base.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes具有基于卷和持久卷索赔的抽象存储模型。它支持大量的内部存储解决方案。这意味着这些存储解决方案必须内置到Kubernetes代码库中。
- en: Early on (in Kubernetes 1.2), the Kubernetes team introduced a special type
    of plugin called FlexVolume that provided an interface for out-of-tree plugins.
    Storage providers could provide their own drivers that implement the FlexVolume
    interface and could serve as a storage layer without modifying Kubernetes itself.
    But, the FlexVolume approach was still pretty clunky. It required installing special
    drivers on each node and, in some cases, on the master too.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 早期（在Kubernetes 1.2中），Kubernetes团队引入了一种特殊类型的插件，称为FlexVolume，它提供了一个用于out-of-tree插件的接口。存储提供商可以提供实现FlexVolume接口的自己的驱动程序，并且可以作为存储层而不修改Kubernetes本身。但是，FlexVolume方法仍然相当笨拙。它需要在每个节点上安装特殊的驱动程序，并且在某些情况下还需要在主节点上安装。
- en: In Kubernetes 1.13, the **Container Storage Interface** (**CSI**) matured to
    **generally available** (**GA**) status and provides a modern gRPC-based interface
    for implementing out-of-tree storage plugins. Soon, Kubernetes will even support
    raw block storage via CSI (introduced as beta in Kubernetes 1.14).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes 1.13中，容器存储接口（CSI）成熟到了一般可用（GA）状态，并提供了一个基于现代gRPC的接口，用于实现out-of-tree存储插件。很快，Kubernetes甚至将通过CSI支持原始块存储（在Kubernetes
    1.14中引入为beta）。
- en: 'The following diagram illustrates the place of CSI in the Kubernetes cluster
    and how it neatly isolates storage providers:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了CSI在Kubernetes集群中的位置，以及它如何整洁地隔离存储提供商：
- en: '![](assets/3676e7ad-049a-4841-8362-bdfc53134579.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/3676e7ad-049a-4841-8362-bdfc53134579.png)
- en: Container Storage Interface
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 容器存储接口
- en: The trend is to replace all the in-tree and FlexVolume plugins with CSI-based
    implementations, which will allow removing a significant chunk of functionality
    from the core Kubernetes code base.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 趋势是用基于CSI的实现替换所有in-tree和FlexVolume插件，这将允许从核心Kubernetes代码库中删除大部分功能。
- en: The cloud provider interface
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云提供商接口
- en: Kubernetes has seen a lot of success with cloud platforms, such as Google's
    GKE, Microsoft's AKS, Amazon's EKS, Alibaba's AliCloud, IBM's cloud Kubernetes
    service, DigitalOcean's Kubernetes service, VMware's Cloud PKS, and Oracle's container
    engine for Kubernetes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes在云平台（如Google的GKE，微软的AKS，亚马逊的EKS，阿里巴巴的AliCloud，IBM的云Kubernetes服务，DigitalOcean的Kubernetes服务，VMware的Cloud
    PKS和甲骨文的Kubernetes容器引擎）中取得了很大成功。
- en: In the early days, integrating Kubernetes into a cloud platform required a lot
    of effort and involved customizing multiple Kubernetes control plane components,
    such as the API server, the kubelet, and the controller manager.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期，将Kubernetes集成到云平台需要大量的工作，并涉及定制多个Kubernetes控制平面组件，如API服务器、kubelet和控制器管理器。
- en: 'To make things easier on cloud platform providers, Kubernetes introduced the
    **Cloud Controller Manager** (**CCM**). The CCM abstracts away, through a set
    of stable interfaces, all the parts that a cloud provider needs to implement.
    Now, the touch points between Kubernetes and the cloud provider are formalized
    and it''s simpler to reason about and ensure that the integration is successful.
    Let''s have a look at the following diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让云平台提供商更容易，Kubernetes引入了**云控制器管理器**（**CCM**）。CCM通过一组稳定的接口将云提供商需要实现的所有部分抽象出来。现在，Kubernetes与云提供商之间的接触点被正式化，更容易理解并确保集成成功。让我们看看以下图表：
- en: '![](assets/c15d71e6-a1fe-458b-aae3-345691eebbc4.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c15d71e6-a1fe-458b-aae3-345691eebbc4.png)'
- en: Cloud Controller Manager
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 云控制器管理器
- en: The preceding diagram illustrates the interactions between a Kubernetes cluster
    and a host cloud platform.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表说明了Kubernetes集群与主机云平台之间的交互。
- en: Service mesh integration
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务网格集成
- en: I mentioned at the end of the [Chapter 13](b39834c8-859c-42a5-846a-e48b76dfd6cc.xhtml),* Service
    Mesh - Working with Istio*, that service meshes are important. They complement
    Kubernetes and add a lot of value. While Kubernetes provides the management and
    scheduling of resources and the extensible API, a service mesh provides the next
    layer of managing the traffic flowing between the containers in the cluster.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第13章](b39834c8-859c-42a5-846a-e48b76dfd6cc.xhtml)的结尾提到过，*服务网格-使用Istio*，服务网格非常重要。它们补充了Kubernetes并增加了很多价值。虽然Kubernetes提供了资源的管理和调度以及可扩展的API，但服务网格提供了管理集群中容器之间流量的下一层。
- en: This symbiosis is very powerful. On GKE, Istio is already just a button-click
    away. I expect most Kubernetes distribution to provide the option to install Istio
    (or maybe the AWS app mesh, in the case of EKS) as part of the initial setup.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种共生关系非常强大。在GKE上，Istio已经只需点击一个按钮即可。我预计大多数Kubernetes发行版都会提供安装Istio（或者在EKS的情况下可能是AWS应用程序网格）作为初始设置的选项。
- en: 'At this point, I expect a lot of other solutions to consider Istio as a standard
    component and build on top of it. An interesting project to watch in this space
    is Kyma ([https://kyma-project.io/](https://kyma-project.io/)), which aims to
    easily install a slew of best-of-breed cloud-native components. Kyna takes the
    extensible and open Kubernetes and adds an opinionated set of well-integrated
    components, such as the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我预计很多其他解决方案会将Istio视为标准组件并在其基础上构建。在这个领域值得关注的一个有趣项目是Kyma（[https://kyma-project.io/](https://kyma-project.io/)），它旨在轻松安装一系列最佳的云原生组件。Kyna采用可扩展和开放的Kubernetes，并添加了一套有见地的、良好集成的组件，例如以下内容：
- en: Helm
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm
- en: Dex
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dex
- en: Istio
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istio
- en: Knative
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knative
- en: Prometheus
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus
- en: Grafana
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grafana
- en: Jeager
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jeager
- en: Kubeless
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubeless
- en: Loki
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Loki
- en: Velero (formerly, Ark)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Velero（前身为Ark）
- en: Minio
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minio
- en: Serverless computing on Kubernetes
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes上的无服务器计算
- en: 'As we discussed in [Chapter 9](eae34b9d-8cc9-484a-87b1-82487d0a30dc.xhtml),
    *Running Serverless Tasks on Kubernetes*, serverless computing is all the rage.
    There are many solutions out there. Let''s distinguish between two separate solutions
    here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第9章](eae34b9d-8cc9-484a-87b1-82487d0a30dc.xhtml)中讨论的，*在Kubernetes上运行无服务器任务*，无服务器计算非常流行。市面上有很多解决方案。让我们在这里区分两个不同的解决方案：
- en: '**Function as a Service** (**FaaS**)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数即服务**（**FaaS**）'
- en: '**Server as a Service** (**SaaS**)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器即服务**（**SaaS**）'
- en: '| **FaaS** | **SaaS** |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **FaaS** | **SaaS** |'
- en: '| **FaaS** means that you launch a function either as source code that gets
    packaged into an image, or as a pre-packaged image you build. This image then
    gets scheduled on your cluster and it runs to completion. You still need to manage
    and scale the nodes in your cluster and make sure you have enough capacity for
    your long-running services and your functions. | **SaaS** means that you don''t
    need to provision and manage the nodes in your cluster. Your cluster auto-magically
    grows and shrinks according to the load. The Kubernetes cluster autoscaler provides
    this capability on Kubernetes. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '**FaaS**意味着您可以启动一个函数，无论是作为打包成镜像的源代码，还是作为预打包的镜像。然后，这个镜像被安排在您的集群上，并运行到完成。您仍然需要管理和扩展集群中的节点，并确保您有足够的容量来运行长时间运行的服务和函数。'
- en: Obviously, you can mix and match, and run the Kubernetes cluster autoscaler
    and also run some function as a service framework to get the benefits of both.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，您可以混合搭配，并运行Kubernetes集群自动缩放器，也可以运行一些函数作为服务框架，以获得两者的好处。
- en: So far, so good. But, Kubernetes is often deployed on public cloud platforms
    that have their own non-Kubernetes solutions to the same problem. For example,
    in AWS, you have Lambda functions (FaaS) as well as Fargate (SaaS). Microsoft
    Azure has Azure Functions and container instances that use a virtual kubelet and
    you can elastically grow your AKS cluster. Google has Cloud Functions and Cloud
    Run.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好。但是，Kubernetes通常部署在具有自己非Kubernetes解决方案的公共云平台上。例如，在AWS中，您有Lambda函数（FaaS）以及Fargate（SaaS）。Microsoft
    Azure拥有Azure Functions和使用虚拟kubelet的容器实例，您可以弹性地扩展您的AKS集群。谷歌有Cloud Functions和Cloud
    Run。
- en: It will interesting to see how the public cloud providers integrate their offerings
    with Kubernetes. Google Cloud Run is built on top on Knative and can already run
    either on your GKE cluster or on Google's infrastructure (so it's independent
    of Kubernetes).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 看到公共云提供商如何将他们的产品与Kubernetes集成将会很有趣。Google Cloud Run是建立在Knative之上的，并且已经可以在您的GKE集群或Google的基础设施上运行（因此它独立于Kubernetes）。
- en: I predict that Knative will become yet another standard component that other
    FaaS solutions use as a building block on Kubernetes because it is so portable
    and supported by major players, such as Google and Pivotal. It is designed from
    the get-go as a loosely coupled collection of pluggable components that let you
    swap in your preferred components.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我预测Knative将成为另一个标准组件，其他FaaS解决方案将在Kubernetes上使用它作为构建块，因为它非常便携，并得到谷歌和Pivotal等主要参与者的支持。它从一开始就被设计为一组松散耦合的可插拔组件，让您可以替换您喜欢的组件。
- en: Kubernetes and VMs
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes最初是Docker容器的编排平台。许多特定于Docker的假设被构建进去。Kubernetes 1.3添加了对CoreOS rkt的特殊支持，并开始了朝向解耦的运行时体验的旅程。Kubernetes
    1.5引入了CRI，其中kubelet通过gRPC与容器运行时引擎通信。CRI在Kubernetes 1.6中稳定。
- en: Kubernetes started as an orchestration platform for Docker containers. A lot
    of Docker-specific assumptions were built in. Kubernetes 1.3 added special support
    for CoreOS rkt and started the journey toward a decoupled runtime experience.
    Kubernetes 1.5 introduced the CRI, where the kubelet talks to the container runtime
    engine via gRPC. The CRI graduated to stable in Kubernetes 1.6.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**SaaS**意味着您不需要预配和管理集群中的节点。您的集群会根据负载自动增长和缩小。Kubernetes集群自动缩放器在Kubernetes上提供了这种能力。'
- en: As I mentioned earlier when discussing the abstraction of the container runtime,
    the CRI opened the door to multiple runtime implementations. One class of runtime
    extensions are lightweight or micro VMs. This may seem a little counter-productive
    because one of the biggest motivations for the container movement was that VMs
    are too heavyweight for dynamic cloud applications.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前在讨论容器运行时的抽象时提到的，CRI为多个运行时实现打开了大门。一类运行时扩展是轻量级或微型虚拟机。这似乎有点适得其反，因为容器运动最大的动机之一是虚拟机对于动态云应用来说太过沉重。
- en: It turned out that containers are not fool-proof when it comes to isolation.
    Security concerns override any other concern for many use cases. The solution
    is to bring back VMs, but with a lighter touch. Now that the industry has some
    decent experience with containers, it is possible to design the next generation
    of VMs that will find the sweet spot between iron-clad isolation and high performance/low
    resource.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，容器在隔离方面并不是百分之百可靠。对于许多用例来说，安全性问题比其他任何问题都更重要。解决方案是重新引入虚拟机，但轻量化。现在，行业已经积累了一些与容器相关的经验，可以设计下一代虚拟机，找到铁壁般的隔离和高性能/低资源之间的平衡点。
- en: 'The following are some of the most prominent projects:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些最重要的项目：
- en: gVisor
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gVisor
- en: Firecracker
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firecracker
- en: Kata containers
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kata containers
- en: gVisor
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gVisor
- en: gVisor is an open source project from Google. It is a user-space kernel sandbox
    that sits in front of the host kernel. It exposes an **Open Container Initiative**
    (**OCI**) interface called runsc. It also has a CRI plugin to interface directly
    with Kubernetes. The protection offered by gVisor is only partial. If there is
    a container breach, then the user kernel and a special secomp policy provide extra
    layers of security, but it is not a complete isolation. gVisor is used by Google
    AppEngine.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: gVisor是谷歌的一个开源项目。它是一个位于主机内核前面的用户空间内核沙箱。它公开了一个名为runsc的**Open Container Initiative**（**OCI**）接口。它还有一个CRI插件，可以直接与Kubernetes接口。gVisor提供的保护只是部分的。如果容器被入侵，用户内核和特殊的secomp策略提供额外的安全层，但这并不是完全隔离。gVisor被谷歌AppEngine使用。
- en: Firecracker
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firecracker
- en: Firecracker is an open source project from AWS. It is a VM monitor using KVM
    to manage micro VMs. It is designed specifically to run secure multi-tenant containers
    and functions as as a service. It currently runs only on Intel CPUs, but support
    is planned for AMD and ARM.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Firecracker是AWS的一个开源项目。它是一个使用KVM管理微型虚拟机的虚拟机监视器。它专门设计用于运行安全的多租户容器和函数作为服务。它目前只能在英特尔CPU上运行，但计划支持AMD和ARM。
- en: AWS Lambda and AWS Fargate use Firecracker already. Currently, Firecracker can't
    be used easily on Kubernetes. The plan is to provide container integration via
    containerd. Refer to the link: [https://github.com/firecracker-microvm/firecracker-containerd/](https://github.com/firecracker-microvm/firecracker-containerd/).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda和AWS Fargate已经在使用Firecracker。目前，Firecracker在Kubernetes上不能轻松使用。计划通过containerd提供容器集成。参考链接：[https://github.com/firecracker-microvm/firecracker-containerd/](https://github.com/firecracker-microvm/firecracker-containerd/)。
- en: Kata containers
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kata containers
- en: This is another open source solution managed by the **OpenStack Foundation**
    (**OSF**), in the form of Kata containers. It combines technology from Intel's
    clear containers and Hyper.sh RunV. It supports multiple hypervisors, such QEMU,
    NEMU, and even Firecracker. The goal of the Kata containers is to build a secure
    container runtime based on hardware virtualization for workload isolation. Kata
    containers can already be used on Kubernetes via containerd.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个由**OpenStack基金会**（**OSF**）管理的开源解决方案，即Kata容器。它结合了英特尔的clear容器和Hyper.sh RunV的技术。它支持多个虚拟化程序，如QEMU、NEMU，甚至Firecracker。Kata容器的目标是构建基于硬件虚拟化的安全容器运行时，用于工作负载隔离。Kata容器已经可以通过containerd在Kubernetes上使用。
- en: It's hard to tell how it will all shake up. There was already some consolidation.
    There is strong demand for safe and secure container runtimes. All the projects
    can either be used on Kubernetes already, or there are plans to integrate them
    soon. This will probably be one of the most important, yet invisible, improvements
    to the cloud-native landscape. The main concern is that those lightweight VMs
    might introduce too much of a performance overhead for some use cases.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 很难说它会如何摇摆。已经有一些整合。对安全和可靠的容器运行时有很强的需求。所有项目都可以在Kubernetes上使用，或者计划很快将它们集成起来。这可能是云原生领域最重要但又看不见的改进之一。主要问题是那些轻量级虚拟机可能会为某些用例引入太多性能开销。
- en: Cluster autoscaling
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群自动缩放
- en: 'If you deal with fluctuating load (and it''s safe to say that any non-trivial
    system does), then you have three options:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您处理波动负载（可以肯定地说任何非平凡系统都是如此），那么您有三个选择：
- en: Over provision your cluster.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度配置您的集群。
- en: Try to find a magic ideal size and deal with outages, timeout, and slow performance.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试找到一个理想的大小并处理停机，超时和性能慢。
- en: Grow and shrink your cluster based on demand.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需求扩大和缩小您的集群。
- en: 'Let''s discuss the preceding options in more detail:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论前述选项：
- en: Option 1 is expensive. You pay for resources, you don't fully utilize most of
    the time. It does buy you some peace and quiet, but eventually, you may run into
    a spike of demand that temporarily exceeds even your over provisioned capacity.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项1很昂贵。您支付资源，大部分时间都没有充分利用。它确实给您带来了一些宁静，但最终，您可能会遇到需求暂时超过甚至超过您过度配置的容量的情况。
- en: Option 2 is not really an option. You may find yourself there if you opted for
    over provisioning and underestimated.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项2实际上不是一个选项。如果您选择了过度配置并低估了，您可能会发现自己在那里。
- en: Option 3 is where you want to be. Your cluster's capacity matches your workload.
    You can always satisfy your SLOs and SLAs and you don't pay for unused capacity.
    However, trying to elastically manage your cluster manually is a no-starter.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项3是您想要的地方。您的集群容量与您的工作负载相匹配。您始终可以满足您的SLO和SLA，并且不必支付未使用的容量。但是，尝试手动弹性地管理您的集群是行不通的。
- en: The solution is to do it automatically. This is where the cluster autoscaler
    comes in. I believe that, for large-scale clusters, the cluster autoscaler will
    become a standard component. There may be additional custom controllers that also
    adjust the cluster size based on custom metrics, or adjust other resources beyond
    nodes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是自动执行。这就是集群自动缩放器的作用。我相信，对于大规模集群，集群自动缩放器将成为标准组件。可能会有其他自定义控制器，根据自定义指标调整集群大小，或者调整节点以外的其他资源。
- en: I fully expect all the large cloud providers to invest and address all the current
    gotchas and issues related to the cluster autoscaler and ensure it works flawlessly
    on their platforms.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我完全期待所有大型云提供商投资并解决与集群自动缩放相关的所有当前问题，并确保它在其平台上无缝运行。
- en: Another prominent trend in the Kubernetes community that became a best practice
    is to provide complex components through Kubernetes operators.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes社区中另一个突出的趋势是通过Kubernetes操作员提供复杂组件，这已成为最佳实践。
- en: Using operators
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用操作员
- en: A Kubernetes operator is a controller that encapsulates operational knowledge
    of some application. It can manage installation, configuration, updates, fail-overs,
    and more. Operators often rely on CRDs to keep their own state and can automatically
    respond to events. Providing an operator is quickly becoming the way to release
    new, complicated software.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes操作员是封装了某些应用程序的操作知识的控制器。它可以管理安装、配置、更新、故障转移等。操作员通常依赖于CRD来保持自己的状态，并可以自动响应事件。提供操作员正在迅速成为发布新的复杂软件的方式。
- en: Helm charts are fine for installing the bits onto the cluster (and operators
    may use Helm charts for that purpose), but there is a lot of ongoing management
    associated with complex components, such as data stores, monitoring solutions,
    CI/CD pipelines, message brokers, and serverless frameworks.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表适用于将位安装到集群上（操作员可能会使用Helm图表进行此操作），但与复杂组件相关的持续管理很多，如数据存储、监控解决方案、CI/CD流水线、消息代理和无服务器框架。
- en: 'The trend here is very clear: complex projects will provide operators as a
    standard feature.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的趋势非常明显：复杂的项目将提供操作员作为标准功能。
- en: There are two interesting projects that support this trend.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个支持这一趋势的有趣项目。
- en: 'OperatorHub ([https://operatorhub.io/](https://operatorhub.io/)) is a curated
    index of Kubernetes operators, where people can go and find well-packaged software
    to install on their cluster. OperatorHub was started by RedHat (now part of IBM),
    Amazon, Microsoft, and Google. It is very well-organized by category and provider
    and is easily searchable. Here is a screenshot of the main page:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: OperatorHub（[https://operatorhub.io/](https://operatorhub.io/)）是一个经过筛选的Kubernetes操作员索引，人们可以在那里找到精心打包的软件来安装到他们的集群上。OperatorHub由RedHat（现在是IBM的一部分）、亚马逊、微软和谷歌发起。它按类别和提供商进行了很好的组织，并且易于搜索。以下是主页的截图：
- en: '![](assets/f41b2327-e9ac-4389-9524-55f84386c6ab.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f41b2327-e9ac-4389-9524-55f84386c6ab.png)'
- en: Operator hub
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员中心
- en: Operators are very useful, but they require pretty good knowledge of how Kubernetes
    works, controllers, the concept of reconciliation logic, how to create CRDs, and
    how to interact with the Kubernetes API server. It is not rocket science, but
    it's not trivial either. If you want to develop your own operators, there is a
    project called the Operator Framework ([https://github.com/operator-framework](https://github.com/operator-framework)).
    The Operator Framework provides an SDK to make it easy to start with your operators.
    There are guides for writing operators in Go, using Ansible or Helm.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员非常有用，但他们需要对Kubernetes的工作原理、控制器、协调逻辑的概念、如何创建CRD以及如何与Kubernetes API服务器交互有相当好的了解。这并不是什么难事，但也不是微不足道的。如果你想开发自己的操作员，有一个名为Operator
    Framework的项目（[https://github.com/operator-framework](https://github.com/operator-framework)）。Operator
    Framework提供了一个SDK，可以让您轻松开始使用您的操作员。有关使用Go编写操作员、使用Ansible或Helm的指南。
- en: Operators significantly reduce complexity, but what if you need to manage many
    clusters? This is where cluster federation comes in.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员显著减少了复杂性，但如果您需要管理多个集群怎么办？这就是集群联邦的用武之地。
- en: Federation
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦
- en: Managing a single large Kubernetes cluster is not simple. Managing multiple
    geo-distributed clusters is much harder. It is especially difficult if you try
    to treat multiple clusters as one big logical cluster. Many challenges arise around
    high availability, fail-over, load balancing, security, and latency.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 管理单个大型Kubernetes集群并不简单。管理多个地理分布式集群要困难得多。特别是如果您试图将多个集群视为一个大的逻辑集群。在高可用性、故障转移、负载平衡、安全性和延迟方面会出现许多挑战。
- en: 'For many very large systems, multiple clusters are a necessity. Sometimes,
    it is necessary for smaller systems too. The following are some use cases:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多非常庞大的系统，多个集群是必需的。有时，对于较小的系统也是必需的。以下是一些用例：
- en: Hybrid on-premises/cloud
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合式本地/云
- en: Geo-distributed redundancy and availability
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理分布式冗余和可用性
- en: Multi-provider redundancy and availability
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多提供商冗余和可用性
- en: Very large systems (more nodes than a single Kubernetes cluster can handle)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常庞大的系统（节点比单个Kubernetes集群能处理的要多）
- en: Kubernetes attempted to address the problem with the Kubernetes Federation V1
    proposal and implementation. It failed and never made it to GA. But, then came
    V2, at [https://github.com/kubernetes-sigs/federation-v2.](https://github.com/kubernetes-sigs/federation-v2)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes尝试通过Kubernetes联邦V1提案和实施来解决这个问题。但它失败了，从未达到GA。但是，然后出现了V2，网址是[https://github.com/kubernetes-sigs/federation-v2.](https://github.com/kubernetes-sigs/federation-v2)
- en: 'All big cloud providers have products for a hybrid on-premises/cloud systems.
    These include the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所有大型云提供商都有混合本地/云系统的产品。这些包括以下内容：
- en: Google Anthos
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Anthos
- en: 'GKE on-premises - AWS Outposts: Microsoft Azure Stack'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GKE本地 - AWS Outposts：Microsoft Azure Stack
- en: In addition, many third-party Kubernetes solutions offer cross-cloud and even
    bare-metal management of multiple clusters. One of the most promising projects
    in this area is Gardener ([https://gardener.cloud/](https://gardener.cloud/))
    that lets you manage potentially thousands of clusters. It operates by having
    a garden cluster that manages many seed clusters (as custom resources) that can
    have shoot clusters.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多第三方Kubernetes解决方案提供跨云甚至裸金属管理多个集群。在这方面最有前途的项目之一是Gardener（[https://gardener.cloud/](https://gardener.cloud/)），它可以让您管理数千个集群。它通过拥有一个管理许多种子集群（作为自定义资源）的花园集群来运行，这些种子集群可以有射击集群。
- en: I see it as a natural progression. Once the industry masters the art of managing
    a single cluster, then mastering a collection of clusters will become the next
    challenge.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这是一个自然的进步。一旦行业掌握了管理单个集群的艺术，那么掌握一系列集群将成为下一个挑战。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at where microservices and Kubernetes are going next.
    All the indicators show that both microservices and Kubernetes will continue to
    be major factors when designing, building, evolving, and operating cloud-native,
    large-scale, distributed systems. This is good news. Small programs, scripts,
    and mobile apps will not disappear, but the backend systems will become large,
    deal with more data, and be responsible for managing larger and larger aspects
    of our lives. Technologies such as virtual reality, sensors, and AI will require
    ever-growing amounts of data to be processed and stored.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一下微服务和Kubernetes接下来的发展方向。所有指标显示，无论是微服务还是Kubernetes，在设计、构建、演进和操作云原生、大规模、分布式系统时都将继续发挥重要作用。这是个好消息。小型程序、脚本和移动应用不会消失，但后端系统将变得更大，处理更多数据，并负责管理我们生活中越来越多的方面。虚拟现实、传感器和人工智能等技术将需要处理和存储越来越多的数据。
- en: The short-term development in the microservices world will see gRPC emerge as
    a popular transport for inter-service communication, as well as a public interface.
    Web clients will be able to consume gRPC via the gRPC for web. GraphQL is another
    innovation that is a major improvement compared to the REST API. The industry
    still needs some time to understand how to design and build microservice-based
    architectures. Building a single microservice is simple. Building a whole system
    of coordinated microservices is a whole other story.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务世界的短期发展中，gRPC将成为一种流行的服务间通信和公共接口传输方式。Web客户端将能够通过gRPC for web消费gRPC。GraphQL是另一项创新，与REST
    API相比是一项重大改进。行业仍需要一些时间来理解如何设计和构建基于微服务的架构。构建单个微服务很简单。构建一整套协调的微服务系统则是另一回事。
- en: Containers and Kubernetes solve some of the hard problems that microservice-based
    architectures present. New technologies, such as service mesh, will gain mindshare
    very quickly. Serverless computing (both SaaS and FaaS) will help developers to
    deploy and update applications even faster. The merging of containers and virtualization
    will result in more secure systems. Operators will make bigger and more useful
    building blocks a reality. Cluster federation will be the new frontier of scalable
    systems.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和Kubernetes解决了基于微服务的架构所面临的一些难题。新技术，如服务网格，将迅速获得关注。无服务器计算（SaaS和FaaS）将帮助开发人员更快地部署和更新应用程序。容器和虚拟化的融合将导致更安全的系统。运维人员将使更大更有用的构建块成为现实。集群联邦将成为可扩展系统的新前沿。
- en: At this point, you should have a good idea of what is coming down the line and
    what to expect. This knowledge will allow you to plan ahead and make your own
    assessments regarding which technologies to invest in right now, and which technologies
    need to mature some more.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该对即将到来的情况有一个很好的了解，知道可以预期什么。这些知识将使您能够提前规划，并对现在应该投资哪些技术以及哪些技术需要更多成熟进行自己的评估。
- en: In short, we are at the beginning of an exciting, new era, where we will learn
    how to create reliable systems at an unprecedented scale. Keep learning, stay
    on top of all the amazing technologies available to you, build your own systems,
    and contribute back to the community.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们正处在一个激动人心的新时代的开端，我们将学会如何在前所未有的规模上创建可靠的系统。继续学习，掌握所有可用的惊人技术，构建自己的系统，并回馈社区。
- en: Further reading
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The reading list is quite extensive because we discussed a lot of up-and-coming
    projects and technologies that are worth monitoring and following up on:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读列表非常广泛，因为我们讨论了许多值得关注和跟进的新项目和技术：
- en: '**gRPC**: [https://grpc.io/](https://grpc.io/)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC： [https://grpc.io/](https://grpc.io/)
- en: '**The Frakti runtime**: [https://github.com/kubernetes/frakti](https://github.com/kubernetes/frakti)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Frakti运行时：[https://github.com/kubernetes/frakti](https://github.com/kubernetes/frakti)
- en: '**Containerd**: [https://containerd.io/](https://containerd.io/)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Containerd：[https://containerd.io/](https://containerd.io/)
- en: '**PouchContainer**: [https://github.com/alibaba/pouch](https://github.com/alibaba/pouch)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PouchContainer：[https://github.com/alibaba/pouch](https://github.com/alibaba/pouch)
- en: '**Kata Containers**: [https://katacontainers.io/](https://katacontainers.io/)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kata容器：[https://katacontainers.io/](https://katacontainers.io/)
- en: '**Kubernetes and Cloud Providers**: [https://medium.com/@the.gigi/kubernetes-and-cloud-providers-b7a6227d3198](https://medium.com/@the.gigi/kubernetes-and-cloud-providers-b7a6227d3198)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes和云提供商：[https://medium.com/@the.gigi/kubernetes-and-cloud-providers-b7a6227d3198](https://medium.com/@the.gigi/kubernetes-and-cloud-providers-b7a6227d3198)
- en: '**Extending Kubernetes**: [https://www.youtube.com/watch?v=qVZnU8rXAEU](https://www.youtube.com/watch?v=qVZnU8rXAEU)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展Kubernetes：[https://www.youtube.com/watch?v=qVZnU8rXAEU](https://www.youtube.com/watch?v=qVZnU8rXAEU)
- en: '**Azure Functions**: [https://azure.microsoft.com/en-us/services/functions/](https://azure.microsoft.com/en-us/services/functions/)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions：[https://azure.microsoft.com/en-us/services/functions/](https://azure.microsoft.com/en-us/services/functions/)
- en: '**Azure Container Instances**: [https://azure.microsoft.com/en-us/services/container-instances/](https://azure.microsoft.com/en-us/services/container-instances/)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure容器实例：[https://azure.microsoft.com/en-us/services/container-instances/](https://azure.microsoft.com/en-us/services/container-instances/)
- en: '**Google Cloud Run**: [https://cloud.google.com/blog/products/serverless/announcing-cloud-run-the-newest-member-of-our-serverless-compute-stack](https://cloud.google.com/blog/products/serverless/announcing-cloud-run-the-newest-member-of-our-serverless-compute-stack)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud Run：[https://cloud.google.com/blog/products/serverless/announcing-cloud-run-the-newest-member-of-our-serverless-compute-stack](https://cloud.google.com/blog/products/serverless/announcing-cloud-run-the-newest-member-of-our-serverless-compute-stack)
- en: '**gVisor**: [https://gvisor.dev/](https://gvisor.dev/)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'gVisor: [https://gvisor.dev/](https://gvisor.dev/)'
- en: '**Firecracker:** [https://firecracker-microvm.github.io/](https://firecracker-microvm.github.io/)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Firecracker: [https://firecracker-microvm.github.io/](https://firecracker-microvm.github.io/)'
- en: '**Kata Containers**: [https://katacontainers.io/](https://katacontainers.io/)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kata Containers: [https://katacontainers.io/](https://katacontainers.io/)'
- en: '**Gardener**: [https://gardener.cloud/](https://gardener.cloud/)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Gardener: [https://gardener.cloud/](https://gardener.cloud/)'
- en: '**The Operator Framework**: [https://github.com/operator-framework/operator-sdk](https://github.com/operator-framework/operator-sdk)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Operator Framework: [https://github.com/operator-framework/operator-sdk](https://github.com/operator-framework/operator-sdk)'
- en: '**HTTP/3 explained**: [https://http3-explained.haxx.se](https://http3-explained.haxx.se)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'HTTP/3 explained: [https://http3-explained.haxx.se](https://http3-explained.haxx.se)'
