- en: '[*Chapter 1*](B17385_01_Final_PD_ePub.xhtml#_idTextAnchor015): Code, Build,
    Test, and Repeat – The Application Development Inner Loop'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第1章*](B17385_01_Final_PD_ePub.xhtml#_idTextAnchor015)：编码、构建、测试和重复 - 应用程序开发内部循环'
- en: Building and deploying cloud-native applications can be cumbersome for local
    and remote development if you are not using the appropriate tools. Developers
    go through a lot of pain to automate the build, push, and deploy steps. In this
    book, we will introduce you to **Skaffold**, which helps automate these development
    workflow steps. You will learn how to use the Skaffold CLI to accelerate the inner
    development loop and how to create effective **continuous integration**/**continuous
    deployment** (**CI/CD**) pipelines and perform build and deployment to manage
    Kubernetes instances such as **Google Kubernetes Engine** (**GKE**), **Microsoft's
    Azure Kubernetes Service** (**AKS**), and Amazon's **Elastic Kubernetes Service**
    (**EKS**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和部署云原生应用程序可能会对本地和远程开发造成麻烦，如果您没有使用适当的工具。开发人员经历了很多痛苦来自动化构建、推送和部署步骤。在本书中，我们将向您介绍**Skaffold**，它可以帮助自动化这些开发工作流程步骤。您将学习如何使用Skaffold
    CLI来加速内部开发循环，以及如何创建有效的**持续集成**/**持续部署**（**CI/CD**）流水线，并执行构建和部署以管理Kubernetes实例，如**Google
    Kubernetes Engine**（**GKE**）、**Microsoft的Azure Kubernetes Service**（**AKS**）和Amazon的**Elastic
    Kubernetes Service**（**EKS**）。
- en: This chapter will define the inner loop for application development and its
    importance, comparing the inner with the outer development loops, and cover the
    typical development workflows for a traditional monolith application and a container-native
    microservices application. We will have an in-depth discussion about the differences
    between these two approaches.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将定义应用程序开发的内部循环及其重要性，比较内部与外部开发循环，并涵盖传统单体应用程序和容器本地微服务应用程序的典型开发工作流程。我们将深入讨论这两种方法之间的差异。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding what the application development inner loop is
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解应用程序开发内部循环是什么
- en: Inner versus outer development loops
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部与外部开发循环
- en: Exploring the traditional application development inner loop
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索传统应用程序开发内部循环
- en: Checking out the container-native application development inner loop
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查容器本地应用程序开发内部循环
- en: By the end of this chapter, you will understand the traditional and container-native
    application inner development loops.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解传统和容器本地应用程序内部开发循环。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, you need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟着本章的示例进行，您需要以下内容：
- en: Eclipse ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/))
    or IntelliJ IDEA ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/))
    or IntelliJ IDEA ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
- en: Git ([https://git-scm.com/downloads](https://git-scm.com/downloads))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git ([https://git-scm.com/downloads](https://git-scm.com/downloads))
- en: Spring Boot 2.5 ([https://start.spring.io](https://start.spring.io))
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 2.5 ([https://start.spring.io](https://start.spring.io))
- en: minikube ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
    or Docker Desktop for macOS and Windows ([https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop))
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: minikube ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
    或 Docker Desktop for macOS 和 Windows ([https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop))
- en: OpenJDK 16 ([https://jdk.java.net/16/](https://jdk.java.net/16/))
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenJDK 16 ([https://jdk.java.net/16/](https://jdk.java.net/16/))
- en: You can download the code examples for this chapter from the GitHub repository
    at [https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/tree/main/Chapter01](https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/tree/main/Chapter01)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub存储库[https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/tree/main/Chapter01](https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/tree/main/Chapter01)下载本章的代码示例
- en: Understanding the application development inner loop
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解应用程序开发的内部循环
- en: The **application development inner loop** is an iterative process in which
    a developer changes the code, starts a build, runs the application, and then tests
    it. If something goes wrong, then we repeat the entire cycle.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序开发的内部循环**是一个迭代过程，在这个过程中，开发人员更改代码，开始构建，运行应用程序，然后测试它。如果出了问题，那么我们就重复整个循环。'
- en: 'So basically, it is the phase before a developer shares the changes done locally
    with others. Irrespective of your technology stack, the tools used, and personal
    preferences, the inner loop process may vary, but ideally, it could be summarized
    into the following three steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，这是开发人员在本地完成更改之前与他人分享更改的阶段。无论您的技术堆栈、使用的工具和个人偏好如何，内部循环过程可能会有所不同，但理想情况下，可以总结为以下三个步骤：
- en: Code
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码
- en: Build
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建
- en: Test
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试
- en: 'Here is a quick visual representation of the inner development loop:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是内部开发循环的快速可视化表示：
- en: '![Figure 1.1 – Inner loop'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1 - 内部循环'
- en: '](image/Figure_1.1_B17385.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.1_B17385.jpg)'
- en: Figure 1.1 – Inner loop
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 - 内部循环
- en: If you think about it, coding is the only step that adds value, and the rest
    of the steps are like a validation of your work, that is, confirming whether your
    code is compiling and tests are passing or not. Since developers spend most of
    their time on the inner loop, they don't like spending too much time on any of
    the steps. It should be swift. Moreover, as developers, we thrive on fast feedback.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细想想，编码是唯一增加价值的步骤，其余步骤都像是对您的工作进行验证，即确认您的代码是否正在编译和测试是否通过。由于开发人员大部分时间都花在内部循环上，他们不喜欢在任何步骤上花费太多时间。它应该迅速。此外，作为开发人员，我们渴望快速反馈。
- en: 'All the steps that we have defined until now are happening locally on a developer''s
    machine before committing the code to a source code repository. Once a developer
    commits and pushes changes to the source code repository, it typically starts
    their CI/CD pipeline, called the **outer development loop** (pull request, CI,
    deployment, and so on). Whether you are developing traditional monolith or container-native
    microservices applications, you should not neglect the importance of your inner
    development loop. Here is why you should care about your inner development loop:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们定义的所有步骤都是在开发人员的机器上本地发生的，然后再将代码提交到源代码存储库。一旦开发人员提交并推送更改到源代码存储库，通常会启动他们的CI/CD管道，称为**外部开发循环**（拉取请求、CI、部署等）。无论您是开发传统的单体应用程序还是容器化的微服务应用程序，都不应忽视内部开发循环的重要性。以下是您应该关注内部开发循环的原因：
- en: If your inner development loop is slow and lacks automation, then the developer's
    productivity will plunge.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的内部开发循环缓慢且缺乏自动化，那么开发人员的生产力将会下降。
- en: It would be best if you always aimed to optimize it because a slow inner loop
    will affect other dependent teams, and it will take much longer to deliver a new
    feature to your users.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最好始终致力于优化它，因为慢的内部循环会影响其他依赖团队，并且将需要更长的时间将新功能交付给用户。
- en: Now that we've had a quick overview of the application development inner loop,
    let's compare the inner and outer development loops.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经快速概述了应用程序开发的内部循环，让我们比较一下内部和外部开发循环。
- en: Inner versus outer development loops
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部与外部开发循环
- en: 'As discussed earlier, as long as the developer works in their local environment
    to test things, they are in the inner loop. In general, a developer spends most
    of their time in the inner loop because it''s fast and gives instant feedback.
    It usually involves the following steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面讨论的那样，只要开发人员在本地环境中测试，他们就处于内部循环中。一般来说，开发人员大部分时间都在内部循环中，因为它快速并且能够立即反馈。通常涉及以下步骤：
- en: A developer starts working on a new feature request. Some code changes are done
    at this point.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发人员开始处理新的功能请求。此时进行一些代码更改。
- en: Once the developer feels confident about the changes, a build is started.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦开发人员对更改感到自信，就会启动构建。
- en: If the build is successful, then the developer runs the unit tests.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果构建成功，开发人员将运行单元测试。
- en: If the test passes, then the developer starts an instance of the application
    locally.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果测试通过，开发人员将在本地启动应用程序的一个实例。
- en: They will switch to the browser to verify the changes.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们将切换到浏览器验证更改。
- en: The developer will then trace logs or attach a debugger.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发人员将跟踪日志或附加调试器。
- en: If something breaks, then the developer will repeat the preceding steps.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果出现问题，开发人员将重复前面的步骤。
- en: 'But as soon as a developer commits and pushes the code to a source code repository,
    it triggers the outer development loop. The outer development loop is closely
    related to the CI/CD process. It involves steps such as the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一旦开发人员提交并将代码推送到源代码存储库，就会触发外部开发循环。外部开发循环与CI/CD流程密切相关。它涉及以下步骤：
- en: CI checking out the source code
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI检出源代码
- en: Building the project
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目
- en: Running functional and integration test suites
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行功能和集成测试套件
- en: Creating runtime artifacts (JAR, WAR, and so on)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建运行时构件（JAR、WAR等）
- en: Deploying to the target environment
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署到目标环境
- en: Testing and repeating
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试和重复
- en: 'All the preceding steps are typically automated and require minimal to no involvement
    on the part of a developer. When the CI/CD pipeline breaks because of a test failure
    or compilation issue, the developer should get notified and then start working
    again on the inner development loop to fix this issue. Here is a visualization
    of the inner loop versus the outer loop:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的步骤通常都是自动化的，开发人员几乎不需要参与。当CI/CD流水线因测试失败或编译问题而中断时，开发人员应该收到通知，然后开始在内部开发循环上再次工作以解决这个问题。以下是内循环与外循环的可视化：
- en: '![Figure 1.2 – Inner loop versus outer loop'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 - 内循环与外循环'
- en: '](image/Figure_1.2_B17385.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.2_B17385.jpg)'
- en: Figure 1.2 – Inner loop versus outer loop
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 - 内循环与外循环
- en: It's very tempting to use CI/CD as a replacement for your inner development
    loop. Let's discuss whether this is a good approach or not.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易将CI/CD用作内部开发循环的替代品。让我们讨论一下这是否是一个好方法。
- en: Why not use CI/CD?
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么不使用CI/CD？
- en: Contrary to what we just discussed about the inner loop, some developers may
    say that they don't care about their inner development loop because they have
    a CI/CD process for it, which should suffice. They are not entirely wrong as these
    pipelines are purpose-built to make the process of modern application development
    repeatable and straightforward. Still, your CI/CD process only solves a unique
    set of problems.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们刚讨论的内循环相反，一些开发人员可能会说他们不关心他们的内部开发循环，因为他们有一个CI/CD流程，这应该足够了。他们并不完全错误，因为这些流水线是为了使现代应用程序开发过程可重复和简单而构建的。但是，您的CI/CD流程只能解决一组独特的问题。
- en: Using CI/CD as a replacement for your inner development loop will make the entire
    process even slower. Imagine having to wait for the whole CI/CD system to run
    your build and test suite, and then deploy only to find out that you made a small
    mistake; it would be quite aggravating. Now, you would have to wait and repeat
    the entire process just because of some silly mistake. It would be much easier
    if we can avoid unnecessary iterations. For your inner development loop, you must
    iterate quickly and preview changes as if they are happening on a live cluster.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CI/CD替代你的内部开发循环将使整个过程变得更慢。想象一下，不得不等待整个CI/CD系统运行你的构建和测试套件，然后部署，只发现你犯了一个小错误；这将是相当恼人的。现在，你必须等待并重复整个过程，只是因为一些愚蠢的错误。如果我们可以避免不必要的迭代，那将会更容易。对于你的内部开发循环，你必须快速迭代并预览更改，就好像它们发生在一个实时集群上一样。
- en: We have covered enough basics about the application development inner loop,
    and now we will cover the traditional application development inner loop for Java
    developers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了关于应用程序开发内部循环的足够基础知识，现在我们将介绍Java开发人员的传统应用程序开发内部循环。
- en: Exploring the traditional application development inner loop
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索传统应用程序开发内部循环
- en: 'Before containers were cool, we were spoilt by the choices we have for the
    inner development loop. Your IDE can run builds for you in the background, and
    then you can deploy your application and test your changes locally. A typical
    traditional application development inner loop involves steps such as the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器变得流行之前，我们被内部开发循环的选择所宠坏。你的集成开发环境可以在后台运行构建，然后你可以部署你的应用程序并在本地测试你的更改。典型的传统应用程序开发内部循环涉及以下步骤：
- en: A developer making code changes in an IDE
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发人员在集成开发环境中进行代码更改
- en: Building and packaging the application
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建和打包应用程序
- en: Deploying and then running locally on a server
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署，然后在本地服务器上运行
- en: Finally, testing the changes and repeating the step
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，测试更改并重复步骤
- en: 'Here is a visualization of the traditional application development inner loop:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是传统应用程序开发内部循环的可视化。
- en: '![Figure 1.3 – Traditional application development inner loop'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3 - 传统应用程序开发内部循环'
- en: '](image/Figure_1.3_B17385.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.3_B17385.jpg)'
- en: Figure 1.3 – Traditional application development inner loop
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 - 传统应用程序开发内部循环
- en: 'For Java developers, there are many options available to automate this process.
    Some of the most popular options are as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Java开发人员，有许多选项可用于自动化此过程。其中一些最受欢迎的选项如下：
- en: Spring Boot Developer Tools
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot开发者工具
- en: JRebel
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JRebel
- en: Let's discuss these options briefly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论这些选项。
- en: Spring Boot Developer Tools
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring Boot开发者工具
- en: 'Spring Boot first introduced developer tools in version 1.3\. Spring Boot Developer
    Tools provide fast feedback loops and automatic restart of the application for
    any code changes done. It provides the following functionalities:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot首次在1.3版中引入了开发者工具。Spring Boot开发者工具提供快速反馈循环和自动重新启动应用程序以适应任何代码更改。它提供以下功能：
- en: It provides a **hot reloading** feature. As soon as any file changes are done
    on `classpath`, it will automatically reboot the application. The automatic restart
    may differ based on your IDE. Please check the official documentation ([https://docs.spring.io/spring-boot/docs/1.5.16.RELEASE/reference/html/using-boot-devtools.html#using-boot-devtools-restart](https://docs.spring.io/spring-boot/docs/1.5.16.RELEASE/reference/html/using-boot-devtools.html#using))
    for more details on this.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了**热重载**功能。一旦在`classpath`上进行了任何文件更改，它将自动重新启动应用程序。自动重新启动可能会根据你的集成开发环境而有所不同。请查看官方文档（[https://docs.spring.io/spring-boot/docs/1.5.16.RELEASE/reference/html/using-boot-devtools.html#using-boot-devtools-restart](https://docs.spring.io/spring-boot/docs/1.5.16.RELEASE/reference/html/using-boot-devtools.html#using)）以获取更多关于此的详细信息。
- en: It provides integration with the **LiveReload** plugin ([http://livereload.com](http://livereload.com))
    so that it can refresh the browser automatically whenever a resource is changed.
    Internally, Spring Boot will start an embedded LiveReload server, which will trigger
    a browser refresh whenever a resource is changed. The plugin is available for
    most popular browsers, such as Chrome, Firefox, and Safari.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供与**LiveReload**插件（[http://livereload.com](http://livereload.com)）的集成，以便在资源更改时自动刷新浏览器。在内部，Spring
    Boot将启动一个嵌入式LiveReload服务器，每当资源更改时都会触发浏览器刷新。该插件适用于大多数流行的浏览器，如Chrome、Firefox和Safari。
- en: It not only supports the local development process, but you can opt-in for updating
    and restarting your application running remotely on a server or cloud. You can
    enable remote debugging as well if you like. However, there is a security risk
    involved in using this feature in production.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不仅支持本地开发过程，还可以选择更新并重新启动远程在服务器或云上运行的应用程序。您也可以选择启用远程调试。但是，在生产中使用此功能存在安全风险。
- en: 'The following is a short snippet of how to add relevant dependencies to your
    Maven and Gradle projects to add support for Spring Boot Developer Tools. Maven/Gradle
    should have an introduction section first:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何向Maven和Gradle项目添加相关依赖项以添加对Spring Boot开发工具的支持的简短片段。Maven/Gradle应该首先有一个介绍部分：
- en: Maven pom.xml
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Maven pom.xml
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Gradle build.gradle
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle build.gradle
- en: 'Here is the code for Gradle:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Gradle的代码：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But this is not how we will add dependencies to test the auto-reload feature
    of developer tools. We will use the **Spring Initializr** website ([https://start.spring.io/](https://start.spring.io/))
    to generate the project stub based on the options you choose. Here are the steps
    we''ll follow:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不是我们将如何添加依赖项来测试开发工具的自动重新加载功能。我们将使用**Spring Initializr**网站（[https://start.spring.io/](https://start.spring.io/)）根据您选择的选项生成项目存根。以下是我们将遵循的步骤：
- en: You can go ahead with default options or make your own choices. You can select
    the build tools (Maven or Gradle), language (Java, Kotlin, or Groovy), and Spring
    Boot version of your choice.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以选择默认选项，也可以自行选择。您可以选择构建工具（Maven或Gradle）、语言（Java、Kotlin或Groovy）和您选择的Spring
    Boot版本。
- en: After that, you can add necessary dependencies by clicking on the **ADD DEPENDENCIES…**
    button and selecting the dependencies required for your application.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您可以通过点击“**ADD DEPENDENCIES…**”按钮并选择应用程序所需的依赖项来添加必要的依赖项。
- en: I have chosen the default options and added `spring-boot-starter-web`, `spring-boot-dev-tools`,
    and Thymeleaf as dependencies for my demo Hello World Spring Boot application.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我选择了默认选项，并将`spring-boot-starter-web`、`spring-boot-dev-tools`和Thymeleaf作为我的演示Hello
    World Spring Boot应用程序的依赖项。
- en: Now, go ahead and click on the **GENERATE** button to download the generated
    source code on your computer. Here is the screen you should see:![Figure 1.4 –
    Spring Initializr home page
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，继续点击“**GENERATE**”按钮，以下载在您的计算机上生成的源代码。这是您应该看到的屏幕：![图1.4 – Spring Initializr首页
- en: '](image/Figure_1.4_B17385.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.4_B17385.jpg)'
- en: Figure 1.4 – Spring Initializr home page
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – Spring Initializr首页
- en: After the download, you can import the project to your IDE.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载后，您可以将项目导入到您的IDE中。
- en: The next logical step is to build a simple Hello World Spring Boot web application.
    Let's begin.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个逻辑步骤是构建一个简单的Hello World Spring Boot web应用程序。让我们开始吧。
- en: Anatomy of the Spring Boot web application
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spring Boot web应用程序的解剖
- en: 'The best way to understand the working parts of the Spring Boot application
    is by taking a look at an example. In this example, we will create a simple **Spring
    Web MVC** application that will accept HTTP GET requests at `http://localhost:8080/hello`.
    We will get an HTML web page with "Hello, John!" in the HTML body in response.
    We will allow the user to customize the default response by entering the query
    string in the `http://localhost:8080/hello?name=Jack` URL so that we can change
    the default message. Let''s begin:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Spring Boot应用程序的工作部分的最佳方法是看一个例子。在这个例子中，我们将创建一个简单的**Spring Web MVC**应用程序，它将在`http://localhost:8080/hello`接受HTTP
    GET请求。我们将得到一个HTML网页，其中响应中的HTML主体中有"Hello, John!"。我们将允许用户通过在`http://localhost:8080/hello?name=Jack`
    URL中输入查询字符串来自定义默认响应，以便我们可以更改默认消息。让我们开始：
- en: 'First, let''s create a `HelloController` bean using the `@Controller` annotation
    for handling incoming HTTP requests. The `@GetMapping` annotation binds the HTTP
    GET request to the `hello()` method:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用`@Controller`注解创建一个`HelloController` bean来处理传入的HTTP请求。`@GetMapping`注解将HTTP
    GET请求绑定到`hello()`方法：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This controller returns the name of the view, which is `index` in our case.
    The view technology we have used here is Thymeleaf, which is responsible for server-side
    rendering of the HTML content.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器返回视图的名称，在我们的例子中是`index`。我们在这里使用的视图技术是Thymeleaf，它负责服务器端渲染HTML内容。
- en: 'In the source code template, `index.html` is available under the templates
    folder in `src/main/resources/`. Here are the contents of the file:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源代码模板中，`index.html`位于`src/main/resources/`的templates文件夹中。以下是文件的内容：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Spring Boot provides an opinionated setup for your application, which includes
    a `main` class as well:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Boot为您的应用程序提供了一个默认的设置，其中包括一个`main`类：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will run our application using `mvn` `spring-boot:run maven goal`, which
    is provided by `spring-boot-maven-plugin`:![Figure 1.5 – Output of the application
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`mvn` `spring-boot:run maven goal`来运行我们的应用程序，这是由`spring-boot-maven-plugin`提供的：![图1.5
    - 应用程序的输出
- en: '](image/Figure_1.5_B17385.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.5_B17385.jpg)'
- en: Figure 1.5 – Spring Boot application startup logs
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 - Spring Boot应用程序启动日志
- en: Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To reduce the verbosity of the logs, we have trimmed them down to show only
    the parts that are relevant to our discussion.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少日志的冗长，我们已经将它们缩减到只显示与我们讨论相关的部分。
- en: If you observe the logs carefully, we have developer tools support enabled,
    an embedded Tomcat server listening at port `8080`, and an embedded LiveReload
    server running on port `35279`. So far, this looks good. Once the application
    is started, you can access the http://localhost:8080/hello URL.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察日志，我们已经启用了开发者工具支持，一个嵌入式的Tomcat服务器在端口`8080`上监听，并且一个运行在端口`35279`上的嵌入式LiveReload服务器。到目前为止，看起来很不错。一旦应用程序启动，您可以访问http://localhost:8080/hello
    URL。
- en: '![Figure 1.6 – REST endpoint response'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6 - REST端点响应'
- en: '](image/Figure_1.6_B17385.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.6_B17385.jpg)'
- en: Figure 1.6 – REST endpoint response
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 - REST端点响应
- en: 'Now we will do a small code change in the Java file and save it and you can
    see from the logs that the embedded Tomcat server was restarted. In the logs,
    you can also see that the thread that has spawned the application is not a main
    thread instead of a `restartedMain` thread:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在Java文件中进行一个小的代码更改并保存，您可以从日志中看到嵌入式Tomcat服务器已经重新启动。在日志中，您还可以看到生成应用程序的线程不是主线程，而是一个`restartedMain`线程：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This completes the demo of the auto-restart feature of the Spring Boot Developer
    Tools. We have not covered the LiveReload feature for brevity as it would be difficult
    to explain here because it all happens in real time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了Spring Boot开发者工具自动重启功能的演示。出于简洁起见，我们没有涵盖LiveReload功能，因为在这里很难解释，因为这一切都是实时发生的。
- en: JRebel
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JRebel
- en: '**JRebel** ([https://www.jrebel.com/products/jrebel](https://www.jrebel.com/products/jrebel))
    is another option for Java developers for accelerating their inner loop development
    process. It is a JVM plugin, and it helps in reducing time for local development
    steps such as building and deploying. It is a paid tool developed by a company
    named *Perforce*. However, there is a free trial for 10 days if you would like
    to play with it. It provides the following functionalities:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**JRebel** ([https://www.jrebel.com/products/jrebel](https://www.jrebel.com/products/jrebel))
    是Java开发人员加速内部循环开发过程的另一个选择。它是一个JVM插件，有助于减少本地开发步骤的时间，如构建和部署。这是一个由名为*Perforce*的公司开发的付费工具。但是，如果您想尝试一下，有10天的免费试用期。它提供以下功能：'
- en: It allows developers to skip rebuild and redeploys and see live updates of their
    changes by just refreshing the browser.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许开发人员跳过重建和重新部署，并通过刷新浏览器即可看到其更改的实时更新。
- en: It will enable developers to be more productive while maintaining the state
    of their application.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将使开发人员在保持应用程序状态的同时更加高效。
- en: It provides an instant feedback loop, which allows you to test and fix your
    issues early in your development.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了即时反馈循环，允许您在开发过程中早期测试和修复问题。
- en: It has good integration with popular frameworks, application servers, build
    tools, and IDEs.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与流行的框架、应用服务器、构建工具和IDE有良好的集成。
- en: There are many different ways to enable support for JRebel to your development
    process. We will consider the possibility of using it with an IDE such as Eclipse
    or IntelliJ. For both IDEs, you can install the plugin, and that's it. As I said
    earlier, this is a paid option, and you can only use it for free for 10 days.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的方法可以使JRebel支持您的开发过程。我们将考虑使用它与Eclipse或IntelliJ这样的IDE的可能性。对于这两个IDE，您可以安装插件，就这样。正如我之前所说，这是一个付费选项，您只能免费试用10天。
- en: For IntelliJ IDEA, you can install the plugin from the marketplace.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于IntelliJ IDEA，您可以从市场安装插件。
- en: '![Figure 1.7 – IntelliJ IDEA installing JRebel'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.7 – IntelliJ IDEA安装JRebel'
- en: '](image/Figure_1.7_B17385.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.7_B17385.jpg)'
- en: Figure 1.7 – IntelliJ IDEA installing JRebel
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – IntelliJ IDEA安装JRebel
- en: For the Eclipse IDE, you can install the plugin from Eclipse Marketplace.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Eclipse IDE，您可以从Eclipse Marketplace安装插件。
- en: '![Figure 1.8 – Eclipse IDE installing JRebel'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.8 – Eclipse IDE安装JRebel'
- en: '](image/Figure_1.8_B17385.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.8_B17385.jpg)'
- en: Figure 1.8 – Eclipse IDE installing JRebel
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – Eclipse IDE安装JRebel
- en: Since JRebel is a paid option, we will not be exploring it in this book, but
    you are free to test it yourself.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JRebel是一个付费选项，我们将不会在本书中探讨它，但您可以自行测试。
- en: We have covered the traditional application development inner loop life cycle
    and tools such as Spring Boot Developer Tools and JRebel, which allow rapid application
    development. Let's now go through the container-native application development
    inner loop life cycle.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了传统应用程序开发内部循环生命周期和工具，如Spring Boot Developer Tools和JRebel，它们允许快速应用程序开发。现在让我们来看一下基于容器的应用程序开发内部循环生命周期。
- en: Checking out the container-native application development inner loop
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查基于容器的应用程序开发内部循环
- en: Kubernetes and containers have introduced a new set of challenges and complexities
    to the inner development loop. Now there are an additional set of steps added
    to the inner loop while developing applications, which is time-consuming. A developer
    would prefer to spend time solving business problems rather than waiting for the
    build process to complete.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes和容器为内部开发循环引入了一系列新的挑战和复杂性。现在在开发应用程序时，内部循环中添加了一组额外的步骤，这是耗时的。开发人员更愿意花时间解决业务问题，而不是等待构建过程完成。
- en: 'It involves steps such as the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 它涉及以下步骤：
- en: A developer making code changes in an IDE
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IDE中进行代码更改的开发人员
- en: Building and packaging the application
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建和打包应用程序
- en: Creating a container image
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个容器镜像
- en: Pushing the image to a container registry
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将镜像推送到容器注册表
- en: Kubernetes pulling the image from the registry
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes从注册表中拉取镜像
- en: Kubernetes creating and deploying the pod
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes创建和部署pod
- en: Finally, testing and repeating
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，测试和重复
- en: 'Engineers at Google call this an *infinite loop of pain and suffering*. Here
    is a visualization of the container-native application development inner loop:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌的工程师称之为“无尽的痛苦和苦难”。这是一个容器本地应用开发内部循环的可视化：
- en: '![Figure 1.9 – Container-native application development inner loop'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.9 - 容器本地应用开发内部循环'
- en: '](image/Figure_1.9_B17385.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_1.9_B17385.jpg)'
- en: Figure 1.9 – Container-native application development inner loop
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 - 容器本地应用开发内部循环
- en: As you can see, we now have three more steps added to the inner development
    loop, that is, creating a container image of your application, pushing it to a
    container registry, and finally, pulling the image while deploying to a container
    orchestration tool such as Kubernetes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们现在在内部开发循环中增加了三个步骤，即创建应用程序的容器镜像，将其推送到容器注册表，最后，在部署到Kubernetes等容器编排工具时拉取镜像。
- en: The container image could be a Docker or OCI format image, depending on the
    tool you use to build your images. You have options such as Docker Hub, AWS Container
    Registry, Google Container Registry, or Azure Container Registry for the container
    registry. Then, finally, in deployment, for your container orchestration, you
    have tools such as Kubernetes, which will first pull the image from the container
    registry and deploy your application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像可以是Docker或OCI格式的镜像，这取决于您用来构建镜像的工具。您可以选择Docker Hub、AWS容器注册表、谷歌容器注册表或Azure容器注册表作为容器注册表。然后，在部署时，对于容器编排，您可以使用Kubernetes等工具，它将首先从容器注册表中拉取镜像并部署您的应用程序。
- en: 'There are many manual steps involved here. It also depends on what tools you
    have used for the local development workflow. For instance, you will use commands
    such as the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涉及许多手动步骤。这也取决于您在本地开发工作流程中使用了什么工具。例如，您将使用以下命令：
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following are the detailed steps that a developer has to go through while
    developing container-native applications:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是开发人员在开发容器本地应用程序时必须经历的详细步骤：
- en: Defining how to configure the OS for your container with a Dockerfile
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Dockerfile定义如何配置容器的操作系统
- en: Defining the packaging of your application into a container image by adding
    instructions to the Dockerfile
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向Dockerfile添加指令来定义将应用程序打包成容器镜像
- en: Creating a container image with Docker commands such as `docker build` and `docker
    tag`
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Docker命令（如`docker build`和`docker tag`）创建一个容器镜像
- en: Uploading the container image to a container registry with a command such as
    `docker push`
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令（如`docker push`）将容器镜像上传到容器注册表
- en: Writing one or more Kubernetes resource files in YAML
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在YAML中编写一个或多个Kubernetes资源文件
- en: Deploying your application to the cluster with commands such as `kubectl apply
    -f myapp.yaml`
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令（如`kubectl apply -f myapp.yaml`）将应用程序部署到集群
- en: Deploying services to the cluster with commands such as `kubectl apply -f mysvc.yaml`
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令（如`kubectl apply -f mysvc.yaml`）将服务部署到集群
- en: Writing the config so that apps can work together with commands such as `kubectl
    create configmap`
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写配置，使应用程序可以通过命令（如`kubectl create configmap`）协同工作
- en: Configuring apps to work together correctly with commands such as `kubectl apply
    -f myappconfigmap.yaml`
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令（如`kubectl apply -f myappconfigmap.yaml`）配置应用程序以正确地协同工作
- en: Wooh!!! That's a lot of steps and a time-consuming process. You can use scripting
    or `docker compose` to automate it to some extent, but soon you will realize that
    it cannot be fully automated without a tool such as Skaffold, which can abstract
    away many things related to building and deployment.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！这是很多步骤和耗时的过程。您可以使用脚本或`docker compose`来在一定程度上自动化它，但很快您会意识到，如果没有Skaffold这样的工具，它是无法完全自动化的，Skaffold可以抽象出许多与构建和部署相关的事情。
- en: In [*Chapter 3*](B17385_03_Final_PD_ePub.xhtml#_idTextAnchor034), *Skaffold
    – Easy-Peasy Cloud-Native Kubernetes Application Development*, we will cover Skaffold,
    which simplifies the process we have covered here with a single command. My only
    intention here was to give you an idea of the steps involved. We will cover these
    steps with some hands-on examples in the next chapter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B17385_03_Final_PD_ePub.xhtml#_idTextAnchor034)中，*Skaffold – 简单易用的云原生Kubernetes应用开发*，我们将介绍Skaffold，它可以用单个命令简化我们在这里涵盖的过程。我在这里的唯一目的是让您了解涉及的步骤。我们将在下一章中通过一些实际示例来介绍这些步骤。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered many topics, such as what a typical inner development
    loop is and its importance. We have also discussed how both the inner and outer
    development loops are different, and then we explored whether the CI/CD process
    can act as a replacement for the inner development loop.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了许多主题，比如典型的内部开发循环及其重要性。我们还讨论了内部和外部开发循环的不同之处，然后探讨了CI/CD过程是否可以替代内部开发循环。
- en: We then discussed the steps involved in the traditional application development
    inner loop and we covered tools such as Spring Developer Tools and JRebel, which
    make the application development a lot easier. To explain this further, we created
    a simple Spring Boot web MVC application. Finally, in the last section, we covered
    the container-native application development inner loop. We also covered the steps
    involved in container-native application development.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了传统应用程序开发内部循环涉及的步骤，并介绍了诸如Spring开发者工具和JRebel之类的工具，这些工具使应用程序开发变得更加容易。为了进一步解释这一点，我们创建了一个简单的Spring
    Boot web MVC应用程序。最后，在最后一节中，我们涵盖了容器本地应用程序开发内部循环。我们还介绍了容器本地应用程序开发涉及的步骤。
- en: In this chapter, the focus was on introducing you to concepts such as inner
    and outer development. You can use Spring Boot Developer Tools and JRebel to accelerate/automate
    your traditional application development life cycle.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，重点是向您介绍内部和外部开发等概念。您可以使用Spring Boot开发者工具和JRebel来加速/自动化传统应用程序开发生命周期。
- en: In the next chapter, we will cover the problems a developer faces while developing
    an application with Kubernetes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍开发人员在使用Kubernetes开发应用程序时面临的问题。
- en: Further reading
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Learn more about Spring Boot Developer Tools at [https://docs.spring.io/spring-boot/docs/1.5.16.RELEASE/reference/html/using-boot-devtools.html](https://docs.spring.io/spring-boot/docs/1.5.16.RELEASE/reference/html/using-boot-devtools.html).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解有关Spring Boot开发者工具的更多信息，请访问[https://docs.spring.io/spring-boot/docs/1.5.16.RELEASE/reference/html/using-boot-devtools.html](https://docs.spring.io/spring-boot/docs/1.5.16.RELEASE/reference/html/using-boot-devtools.html)。
- en: More information on JRebel is available at [https://www.jrebel.com/](https://www.jrebel.com/).
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关JRebel的更多信息，请访问[https://www.jrebel.com/](https://www.jrebel.com/)。
- en: Learn more about Docker from *Docker for Developers,* published by Packt ([https://www.packtpub.com/product/docker-for-developers/9781789536058](https://www.packtpub.com/product/docker-for-developers/9781789536058)).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Packt出版的*Docker for Developers*中了解更多有关Docker的信息([https://www.packtpub.com/product/docker-for-developers/9781789536058](https://www.packtpub.com/product/docker-for-developers/9781789536058))。
- en: Learn more about Kubernetes from *Mastering Kubernetes,* published by Packt ([https://www.packtpub.com/product/mastering-kubernetes/9781786461001](https://www.packtpub.com/product/mastering-kubernetes/9781786461001))
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Packt出版的《精通Kubernetes》了解更多关于Kubernetes的信息（https://www.packtpub.com/product/mastering-kubernetes/9781786461001）.
