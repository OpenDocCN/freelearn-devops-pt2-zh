- en: '2'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: 2\. Introduction to Serverless in the Cloud
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 介绍云中的无服务器
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Evaluate the criteria for choosing the best serverless FaaS provider
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估选择最佳无服务器FaaS提供商的标准
- en: Identify the supported languages, trigger types, and cost structure of major
    cloud service providers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别主要云服务提供商支持的语言、触发类型和成本结构
- en: Deploy serverless functions to cloud providers and integrate functions with
    other cloud services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将无服务器函数部署到云提供商并将函数与其他云服务集成
- en: In this chapter, we will explain the serverless FaaS products of cloud providers,
    create our first serverless functions in the cloud, and integrate with other cloud
    services.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释云提供商的无服务器FaaS产品，创建我们在云中的第一个无服务器函数，并与其他云服务集成。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, the architectural evolution of traditional architectures
    to serverless designs was discussed. In addition, the origin and benefits of serverless
    were presented to explain its high adoption and success in the industry. In this
    chapter, the focus will be on the serverless platforms of cloud providers. Let's
    start with the evolution of cloud technology offerings over the years.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，讨论了传统架构向无服务器设计的架构演变。此外，介绍了无服务器的起源和好处，以解释其在行业中的高采用率和成功。在本章中，重点将放在云提供商的无服务器平台上。让我们从多年来云技术提供的演变开始。
- en: At the start of cloud computing, the primary offering of cloud providers was
    its provisioned and ready-to-use hardware, namely the **infrastructure**. Cloud
    providers manage hardware and networking operations, and therefore, the product
    they were offering was **Infrastructure-as-a-Service** (**IaaS**), as illustrated
    in the following diagram. All cloud providers are still offering IaaS products
    as their core functionality, such as **Amazon Elastic Compute Cloud (Amazon EC2)**
    in AWS and **Google Compute Engine** in GCP.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在云计算开始时，云提供商的主要提供是其预配和可立即使用的硬件，即**基础设施**。云提供商管理硬件和网络操作，因此，他们提供的产品是**基础设施即服务**（**IaaS**），如下图所示。所有云提供商仍然将IaaS产品作为其核心功能，比如AWS的**Amazon弹性计算云（Amazon
    EC2）**和GCP的**Google计算引擎**。
- en: In the following years, cloud providers started to offer platforms where developers
    could only run their applications. With this abstraction, manual server provisioning,
    security updates, and server failures became the concerns of the cloud provider.
    These offerings are known as **Platform-as-a-Service** (**PaaS**) since they only
    focus on running applications and their data on their platforms. **Heroku** is
    the most popular PaaS provider, although each cloud provider has its own PaaS
    products, such as **AWS Elastic Beanstalk** or **Google App Engine**. Similar
    to IaaS, PaaS is still in use in software development.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几年里，云提供商开始提供平台，开发人员只能在其上运行他们的应用程序。通过这种抽象，手动服务器配置、安全更新和服务器故障成为了云提供商的关注点。这些提供被称为**平台即服务**（**PaaS**），因为它们只专注于在其平台上运行应用程序和数据。**Heroku**是最受欢迎的PaaS提供商，尽管每个云提供商都有自己的PaaS产品，比如**AWS弹性Beanstalk**或**Google
    App Engine**。与IaaS类似，PaaS在软件开发中仍在使用。
- en: 'In the top-level abstraction, the functions of the applications operate as
    the unit of control in serverless architectures. This known as **Function-as-a-Service**
    (**FaaS**) and is offered by all the significant cloud providers in recent years.
    The abstraction levels from IaaS to PaaS, and finally to FaaS, can be seen in
    the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶层抽象中，应用程序的功能作为无服务器架构中的控制单元。这被称为**函数即服务**（**FaaS**），近年来所有重要的云提供商都提供了这种抽象。从IaaS到PaaS，最终到FaaS的抽象层次可以在下图中看到：
- en: '![Figure 2.1: IaaS to PaaS and FaaS transition'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1：从IaaS到PaaS和FaaS的转变'
- en: '](image/C12607_02_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_01.jpg)'
- en: 'Figure 2.1: IaaS to PaaS and FaaS transition'
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.1：从IaaS到PaaS和FaaS的转变
- en: Serverless and the Cloud Evaluation Criteria
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无服务器和云评估标准
- en: 'In order to analyze the FaaS products on the market, it is beneficial to define
    some criteria so that we can compare products in a structured way. The following
    topics are essential for every FaaS platform and need detailed investigation before
    you choose a cloud provider:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析市场上的FaaS产品，定义一些标准是有益的，这样我们就可以以结构化的方式比较产品。在选择云提供商之前，以下主题对于每个FaaS平台都是必不可少的，并需要进行详细调查：
- en: '**Programming languages**: Functions are deployed and managed inside the cloud
    provider environments. Therefore, cloud providers define the programming languages
    that are supported. It is one of the most significant decision factors since implementing
    the functions in another language is not feasible in most circumstances.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编程语言：** 函数部署和管理在云提供商的环境中。因此，云提供商定义支持的编程语言。这是最重要的决策因素之一，因为在大多数情况下，使用其他语言实现函数是不可行的。'
- en: '**Function triggers:** Functions are designed to be triggered by cloud provider
    services and external methods. The conventional techniques are scheduled calls,
    on-demand calls, and integration with other cloud services, such as databases,
    queues, and API gateways.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能触发器：** 函数设计为由云提供商服务和外部方法触发。传统的技术包括定时调用、按需调用以及与其他云服务（如数据库、队列和API网关）的集成。'
- en: '**Cost:** The most compelling characteristic of the serverless architecture
    is its cost-effectiveness and the mainstream way of calculating the price, that
    is, pay per request. It is essential to calculate the actual and projected costs
    for the feasibility of long-running projects.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本：** 无服务器架构最具吸引力的特点是其成本效益和主流的价格计算方式，即按请求付费。对于长期运行的项目的可行性，计算实际和预期成本是至关重要的。'
- en: 'Cloud providers are expected to be cost-effective, provide as many programming
    languages as possible, and support various function triggers. There are also additional
    criteria, such as monitoring, operations, and in-house knowledge level, but these
    are not directly related to the serverless products of cloud providers. In the
    upcoming sections, the three most dominant cloud providers will be discussed in
    terms of their serverless platforms: Amazon Web Services, Google Cloud Platform,
    and Microsoft Azure.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 云提供商应该具有成本效益，尽可能提供多种编程语言，并支持各种功能触发器。还有其他标准，如监控、运维和内部知识水平，但这些与云提供商的无服务器产品并不直接相关。在接下来的章节中，将讨论三个最主要的云提供商的无服务器平台：亚马逊云服务、谷歌云平台和微软Azure。
- en: AWS Lambda
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AWS Lambda
- en: '**AWS Lambda** is the first FaaS offering, and it also created the serverless
    hype in the industry. It was made public in 2014 and has been widely adopted in
    the cloud computing world by all levels of organizations. It made it possible
    for start-ups to create new products in a short amount of time. It also enabled
    large enterprises such as **Netflix** to move event-based triggers to serverless
    functions. With the opportunity of removing the server operation burden, AWS Lambda
    and serverless became the next trend in the industry. In this section, we will
    discuss AWS Lambda for programming language support, trigger types, and cost structure.
    In addition, our very first serverless function will be deployed.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda是第一个FaaS提供，也在行业中引起了无服务器的热潮。它于2014年公开，并被各级组织广泛采用于云计算世界。它使初创公司能够在短时间内创建新产品。它还使像Netflix这样的大型企业能够将基于事件的触发器转移到无服务器功能上。通过消除服务器操作负担的机会，AWS
    Lambda和无服务器成为了行业的下一个趋势。在本节中，我们将讨论AWS Lambda的编程语言支持、触发器类型和成本结构。此外，我们将部署我们的第一个无服务器函数。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The official website of AWS Lambda can be found here if you wish to find out
    more: [https://aws.amazon.com/lambda](https://aws.amazon.com/lambda).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多信息，可以在此处找到AWS Lambda的官方网站：[https://aws.amazon.com/lambda](https://aws.amazon.com/lambda)。
- en: AWS Lambda supports the **Java**, **Python**, **Node.js**, **C#**, **Ruby**,
    and **Go** programming languages when it comes to serverless functions. Furthermore,
    AWS Lambda provides an API called AWS Lambda Runtime Interface to enable the integration
    of any language as a custom runtime. Therefore, it could be stated that AWS Lambda
    natively supports a rich set of popular languages while allowing an extension
    to other programming languages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda在无服务器函数方面支持Java、Python、Node.js、C#、Ruby和Go编程语言。此外，AWS Lambda提供了一个名为AWS
    Lambda Runtime Interface的API，以实现任何语言作为自定义运行时的集成。因此，可以说AWS Lambda本地支持一组流行的语言，同时允许扩展到其他编程语言。
- en: 'AWS Lambda is designed to have event-triggered functions. This is where the
    functions process the events that have been retrieved from event sources. Within
    the AWS ecosystem, various services can be an event source, including the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda旨在具有事件触发功能。这是函数处理从事件源检索到的事件的地方。在AWS生态系统中，各种服务都可以是事件源，包括以下内容：
- en: '**Amazon S3** file storage for instances when new files are added'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊S3文件存储用于添加新文件时
- en: '**Amazon Alexa** to implement new skills for voice assistance'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊Alexa用于实现语音助手的新技能
- en: '**Amazon CloudWatch Events** for the events that occur in the state changes
    of cloud resources'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊CloudWatch Events用于云资源状态更改时发生的事件
- en: '**Amazon CodeCommit** for when developers push new commits to the code repository'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊CodeCommit用于开发人员向代码存储库推送新提交时
- en: In addition to these services, the essential AWS service for the serverless
    event source is the **Amazon API Gateway**. It has the REST API ability to invoke
    Lambda functions over HTTPS, and it permits the management of multiple Lambda
    functions for different methods, such as `GET`, `POST`, `PATCH`, and `DELETE`.
    In other words, API Gateway creates a layer between the serverless functions and
    the outside world. This layer also handles the security of the Lambda functions
    by protecting them against **Distributed Denial of Service** (**DDoS**) attacks
    and defining throttles. The trigger types and the environment are highly configurable
    for AWS Lambda functions if you want to integrate with other AWS services or make
    them public via the API Gateway.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些服务之外，无服务器事件源的基本AWS服务是**Amazon API Gateway**。它具有通过HTTPS调用Lambda函数的REST API功能，并允许管理多个Lambda函数以用于不同的方法，如`GET`、`POST`、`PATCH`和`DELETE`。换句话说，API
    Gateway在无服务器函数和外部世界之间创建了一个层。这一层还通过保护Lambda函数免受**分布式拒绝服务**（**DDoS**）攻击和定义节流来处理Lambda函数的安全性。如果要与其他AWS服务集成或通过API
    Gateway公开它们，AWS Lambda函数的触发器类型和环境是高度可配置的。
- en: 'For the pricing of AWS Lambda, there are two critical points to take note of:
    the first one is the **request charges** and the second one is the **compute charges**.
    Request charges are based on the number of function invocations, while compute
    charges are calculated as GB per second. The compute charge is the multiplication
    of memory size and execution time:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AWS Lambda的定价，有两个关键点需要注意：第一个是**请求费用**，第二个是**计算费用**。请求费用是基于函数调用次数计算的，而计算费用是按每秒GB计算的。计算费用是内存大小和执行时间的乘积：
- en: '**Memory Size (GB):** This is the configured allocated memory for the functions.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存大小（GB）**：这是函数配置的分配内存。'
- en: '**Execution time (ms):** This is the realized execution time that the functions
    will be running for.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行时间（毫秒）**：这是函数实际运行的执行时间。'
- en: In addition, there is a free tier where the first 1 million request charges
    and 400,000 GB per second of compute charges are waived monthly. A simple calculation,
    including the free tier, can show how cheap running a serverless function could
    be.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个免费套餐，其中每月免除前100万次请求费用和每秒400,000 GB的计算费用。包括免费套餐在内的简单计算可以显示运行无服务器函数的成本是多么便宜。
- en: 'Let''s assume that your function is called 30 million times in a month. You
    have allocated 128 MB of memory, and on average, the function runs for 200 ms:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的函数一个月被调用了3000万次。您已经分配了128 MB的内存，平均来说，函数运行了200毫秒：
- en: '*Request charges:*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*请求费用：*'
- en: '**Price**: $0.20 per 1 M requests'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**价格**：每100万次请求$0.20'
- en: '**Free tier**: 1 M'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**免费套餐**：100万次'
- en: '**Monthly request**: 30 M'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**月请求**：30 M'
- en: '**Monthly request charge**: 29 M x $0.20 / M = $5.80'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**月请求费用**：29 M x $0.20 / M = $5.80'
- en: '*Compute charges:*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算费用：*'
- en: '**Price**: $0.0000166667 per GB per second'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**价格**：每GB每秒$0.0000166667'
- en: '**Free tier**: 400,000 GB per second'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**免费套餐**：每秒400,000 GB'
- en: '**Monthly compute**: 30 M x 0.2 second x 128 MB / 1024 = 750,000 GB per second'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**月计算**：30 M x 0.2 秒 x 128 MB / 1024 = 750,000 GB每秒'
- en: '**Monthly compute charge**: 350,000 x $0.0000166667 = $5.83'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**月计算费用**：350,000 x $0.0000166667 = $5.83'
- en: '**Monthly total cost**: $5.80 + $5.83 = $11.63'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**月总成本**：$5.80 + $5.83 = $11.63'
- en: This calculation shows that it is possible to run a serverless AWS Lambda environment
    where you receive *1 million daily function calls at a monthly cost of $11.63*.
    This indicates both how cheap it is to run serverless workloads and the essential
    characteristics to consider in serverless economics. In the following exercise,
    our very first serverless function will be deployed to AWS Lambda and will be
    invoked to show the operational view of the platform.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算表明，在运行一个无服务器的AWS Lambda环境中，每天接收*100万次函数调用的月成本为11.63美元*。这表明了运行无服务器工作负载的成本是多么便宜，以及在无服务器经济中需要考虑的基本特征。在接下来的练习中，我们的第一个无服务器函数将部署到AWS
    Lambda，并将被调用以显示平台的操作视图。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In order to complete this exercise, you will need to have an active Amazon Web
    Services account. You can create an account at [https://aws.amazon.com/](https://aws.amazon.com/).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个练习，您需要拥有一个活跃的亚马逊网络服务账户。您可以在[https://aws.amazon.com/](https://aws.amazon.com/)上创建一个账户。
- en: 'Exercise 4: Creating a Function in AWS Lambda and Invoking It via the AWS Gateway
    API'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习4：在AWS Lambda中创建函数并通过AWS Gateway API调用它
- en: In this exercise, we will be creating our first AWS Lambda function and connecting
    it to AWS Gateway API so that we can invoke over its HTTP endpoint.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建我们的第一个AWS Lambda函数，并将其连接到AWS Gateway API，以便我们可以通过其HTTP端点调用。
- en: 'To successfully complete this exercise, we need to ensure that the following
    steps are executed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功完成此练习，我们需要确保执行以下步骤：
- en: 'Open the AWS Management Console, write **Lambda** in the **Find Services**
    search box, and click **Lambda - Run Code without Thinking about Servers**. The
    console will look as follows:![Figure 2.2: AWS Management Console'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开AWS管理控制台，在**查找服务**搜索框中输入**Lambda**，然后单击**Lambda - Run Code without Thinking
    about Servers**。控制台将如下所示：![图2.2：AWS管理控制台
- en: '](image/C12607_02_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_02.jpg)'
- en: 'Figure 2.2: AWS Management Console'
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.2：AWS管理控制台
- en: 'Click on **Create function** in the Lambda functions list, as shown in the
    following screenshot:![Figure 2.3: AWS Lambda – functions list'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击Lambda函数列表中的**创建函数**，如下截图所示：![图2.3：AWS Lambda - 函数列表
- en: '](image/C12607_02_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_03.jpg)'
- en: 'Figure 2.3: AWS Lambda – functions list'
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.3：AWS Lambda - 函数列表
- en: 'Select **Author from scratch** in the **Create function** view. Write `hello-from-lambda`
    as the function name and `Python 3.7` as the runtime. Click **Create function**
    at the bottom of the screen, as shown in the following screenshot:![Figure 2.4:
    AWS Lambda – Create function view'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**创建函数**视图中选择**从头开始**。将`hello-from-lambda`作为函数名称，`Python 3.7`作为运行时。单击屏幕底部的**创建函数**，如下截图所示：![图2.4：AWS
    Lambda - 创建函数视图
- en: '](image/C12607_02_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_04.jpg)'
- en: 'Figure 2.4: AWS Lambda – Create function view'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.4：AWS Lambda - 创建函数视图
- en: You will be directed to the **hello-from-lambda** function view, which is where
    you
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被引导到**hello-from-lambda**函数视图，这是您
- en: 'can edit the **Function code**, as shown in the following screenshot:![Figure
    2.5: AWS Lambda – hello-from-lambda'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以编辑**函数代码**，如下截图所示：![图2.5：AWS Lambda - hello-from-lambda
- en: '](image/C12607_02_05.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_05.jpg)'
- en: 'Figure 2.5: AWS Lambda – hello-from-lambda'
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.5：AWS Lambda - hello-from-lambda
- en: 'Change the `lambda_handler` function as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`lambda_handler`函数如下：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Click **Save** at the top of the screen, as shown in the following screenshot:![Figure
    2.6: AWS Lambda – hello-from-lambda function code'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击屏幕顶部的**保存**，如下截图所示：![图2.6：AWS Lambda - hello-from-lambda函数代码
- en: '](image/C12607_02_06.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_06.jpg)'
- en: 'Figure 2.6: AWS Lambda – hello-from-lambda function code'
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.6：AWS Lambda - hello-from-lambda函数代码
- en: 'Open the **Designer** view and click **Add trigger**, as shown in the following
    screenshot:![Figure 2.7: AWS Lambda – hello-from-lambda designer view'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**设计**视图，点击**添加触发器**，如下面的屏幕截图所示：![图2.7：AWS Lambda – hello-from-lambda设计视图
- en: '](image/C12607_02_07.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_07.jpg)'
- en: 'Figure 2.7: AWS Lambda – hello-from-lambda designer view'
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.7：AWS Lambda – hello-from-lambda设计视图
- en: 'Select **API Gateway** from the triggers list, as shown in the following screenshot:![Figure
    2.8: AWS Lambda – trigger list'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从触发器列表中选择**API Gateway**，如下面的屏幕截图所示：![图2.8：AWS Lambda – 触发器列表
- en: '](image/C12607_02_08.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_08.jpg)'
- en: 'Figure 2.8: AWS Lambda – trigger list'
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.8：AWS Lambda – 触发器列表
- en: 'Select **Create a new API** for the API and **Open** for the **Security** configurations
    on the trigger configuration screen, as shown in the following screenshot:![Figure
    2.9: AWS Lambda – Trigger configuration'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在触发器配置屏幕上选择**创建新的API**作为API，并且选择**开放**作为**安全**配置，如下面的屏幕截图所示：![图2.9：AWS Lambda
    – 触发器配置
- en: '](image/C12607_02_09.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_09.jpg)'
- en: 'Figure 2.9: AWS Lambda – Trigger configuration'
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.9：AWS Lambda – 触发器配置
- en: On this screen, a new API has been defined in the API Gateway with open security
    for the `hello-from-lambda` function. This configuration ensures that an endpoint
    will be created and that it will be accessible without any authentication.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕上，已经在API Gateway中为`hello-from-lambda`函数定义了一个新的API，并且开放了安全性。这个配置确保了一个端点将被创建，并且它将可以在没有任何身份验证的情况下访问。
- en: Click **Add** at the bottom of the screen.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕底部点击**添加**。
- en: 'You will be redirected to the `hello-from-lambda` function, with a notification
    saying **The function is now receiving events from the trigger**. In the **Designer**
    view, the function from Lambda is connected to the API Gateway for triggering
    and Amazon CloudWatch Logs for logging. In other words, it is now possible to
    trigger functions via the API Gateway endpoint and check their outputs in CloudWatch,
    as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被重定向到`hello-from-lambda`函数，通知显示**该函数现在正在接收来自触发器的事件**。在**设计**视图中，Lambda函数连接到API
    Gateway以进行触发，并连接到Amazon CloudWatch Logs以进行日志记录。换句话说，现在可以通过API Gateway端点触发函数，并在CloudWatch中检查它们的输出，如下面的屏幕截图所示：
- en: '![Figure 2.10: AWS Lambda – trigger added'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.10：AWS Lambda – 添加触发器'
- en: '](image/C12607_02_10.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_10.jpg)'
- en: 'Figure 2.10: AWS Lambda – trigger added'
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.10：AWS Lambda – 添加触发器
- en: 'Get the API Gateway endpoint from the API Gateway section, as shown in the
    following screenshot:![Figure 2.11: AWS Lambda – trigger URL'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从API Gateway部分获取API Gateway端点，如下面的屏幕截图所示：![图2.11：AWS Lambda – 触发器URL
- en: '](image/C12607_02_11.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_11.jpg)'
- en: 'Figure 2.11: AWS Lambda – trigger URL'
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.11：AWS Lambda – 触发器URL
- en: 'Open the URL in a new tab to trigger the function and get the response, as
    shown in the following screenshot:![Figure 2.12: AWS Lambda – function response'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新标签页中打开URL来触发函数并获取响应，如下面的屏幕截图所示：![图2.12：AWS Lambda – 函数响应
- en: '](image/C12607_02_12.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_12.jpg)'
- en: 'Figure 2.12: AWS Lambda – function response'
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.12：AWS Lambda – 函数响应
- en: This JSON response indicates that the AWS Lambda function is connected via the
    API Gateway and working as expected.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JSON响应表明AWS Lambda函数通过API Gateway连接并且按预期工作。
- en: 'Return to the **Functions** list from Step 2, select `hello-from-lambda`, and
    choose **Delete** from **Actions**. Then, click **Delete** in the pop-up window
    to remove the function from Lambda, as shown in the following screenshot:![Figure
    2.13: AWS Lambda – function deletion'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第2步返回到**函数**列表，选择`hello-from-lambda`，并从**操作**中选择**删除**。然后，点击弹出窗口中的**删除**以从Lambda中删除该函数，如下面的屏幕截图所示：![图2.13：AWS
    Lambda – 函数删除
- en: '](image/C12607_02_13.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_13.jpg)'
- en: 'Figure 2.13: AWS Lambda – function deletion'
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.13：AWS Lambda – 函数删除
- en: In this exercise, the general flow of creating an AWS Lambda function and connecting
    to the AWS Gateway API for HTTP access was shown. In less than 10 steps, it is
    possible to have running production-ready services in an AWS Lambda cloud environment.
    This exercise has shown you how serverless platforms can make software development
    fast and easy. In the following section, the analysis of cloud provider serverless
    platforms will continue with Azure Functions by Microsoft.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，展示了创建AWS Lambda函数并连接到AWS Gateway API以进行HTTP访问的一般流程。在不到10个步骤的时间内，就可以在AWS
    Lambda云环境中运行生产就绪的服务。这个练习向您展示了无服务器平台如何使软件开发变得快速简单。在接下来的部分中，将继续分析云提供商的无服务器平台，其中包括Microsoft的Azure
    Functions。
- en: Azure Functions
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure Functions
- en: Microsoft announced **Azure Functions** in 2016 as the serverless platform in
    the **Microsoft Azure** cloud. Azure Functions extends its cloud platform with
    event triggers from Azure or external services to run serverless workloads. It
    differentiates by focusing on the Microsoft supported programming languages and
    tools that are highly prevalent in the industry. In this section, Azure Functions
    will be discussed in terms of the supported programming languages, trigger types,
    and cost. Finally, we will deploy a function that takes parameters from endpoints
    to Azure Functions to illustrate its operational side.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 微软于2016年宣布了**Azure Functions**，作为**Microsoft Azure**云中的无服务器平台。Azure Functions通过来自Azure或外部服务的事件触发器来运行无服务器工作负载，从而扩展了其云平台。它的特色在于专注于行业中广泛使用的Microsoft支持的编程语言和工具。在本节中，将从支持的编程语言、触发器类型和成本方面讨论Azure
    Functions。最后，我们将部署一个从端点接收参数的函数到Azure Functions，以说明其操作方面。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The official website of Azure Functions can be found here if you wish to find
    out more: [https://azure.microsoft.com/en-us/services/functions/](https://azure.microsoft.com/en-us/services/functions/).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多信息，可以在这里找到Azure Functions的官方网站：[https://azure.microsoft.com/en-us/services/functions/](https://azure.microsoft.com/en-us/services/functions/)。
- en: The latest version of Azure Functions supports **C#**, **JavaScript** in the
    **Node.js** runtime, **F#**, **Java**, **PowerShell**, **Python**, and **Typescript**,
    which is transpired into **JavaScript**. In addition, a language extensibility
    interface is provided for the communication between the functions runtime and
    the worker processes over **gRPC** as a messaging layer. It is valuable to check
    the generally available, experimental, and extendible programming languages supported
    by Azure Functions before we start utilizing it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions的最新版本支持**C#**，**JavaScript**（在**Node.js**运行时），**F#**，**Java**，**PowerShell**，**Python**和**Typescript**，它会被转译成**JavaScript**。此外，提供了一种语言可扩展性接口，用于在**gRPC**作为消息层的函数运行时和工作进程之间进行通信。在开始使用之前，了解Azure
    Functions支持的普遍可用的、实验性的和可扩展的编程语言是很有价值的。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`gRPC` is a **remote procedure call** (**RPC**) system that was initially developed
    at Google. It is an open source system that enables cross-platform communication
    without language or platform limitations.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`gRPC`是一个最初由Google开发的**远程过程调用**（**RPC**）系统。它是一个开源系统，可以实现跨平台通信，没有语言或平台限制。'
- en: Azure Functions are designed to be triggered by various types, such as timers,
    HTTP, file operations, queue messages, and events. In addition, input and output
    bindings can be specified for functions. These bindings define the input arguments
    for the functions and output values to send other services. For instance, it is
    possible to create a scheduled function to read files from Blob Storage and create
    Cosmos DB documents as outputs. In this example, the function could be defined
    with a **timer trigger**, **Blob Storage** input binding, and **Cosmos DB** output
    binding. Triggers and bindings make Azure Functions easily integrate to Azure
    services and the external world.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Functions旨在由各种类型触发，例如定时器、HTTP、文件操作、队列消息和事件。此外，可以为函数指定输入和输出绑定。这些绑定定义了函数的输入参数和要发送到其他服务的输出值。例如，可以创建一个定时函数来从Blob
    Storage中读取文件，并将Cosmos DB文档创建为输出。在这个例子中，函数可以使用**定时器触发器**、**Blob Storage**输入绑定和**Cosmos
    DB**输出绑定进行定义。触发器和绑定使Azure Functions轻松集成到Azure服务和外部世界中。
- en: There are two differences between the cost calculation method and the current
    prices of Azure Functions compared to AWS Lambda. The first difference is that
    the current computation price of Azure Functions is slightly cheaper, at $0.000016/GB
    per second. The second difference is that Azure Functions calculates using observed
    memory consumption while the memory limit is preconfigured in AWS Lambda.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与AWS Lambda相比，Azure Functions的成本计算方法和当前价格有两个不同之处。第一个区别是Azure Functions的当前计算价格略低，为每秒$0.000016/GB。第二个区别是Azure
    Functions使用观察到的内存消耗进行计算，而AWS Lambda中内存限制是预先配置的。
- en: In the following exercise, the very first serverless function will be deployed
    to Azure Functions and will be invoked to show the operational view of the platform.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，第一个无服务器函数将被部署到Azure Functions，并将被调用以显示平台的操作视图。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In order to complete this exercise, you need to have an active Azure account.
    You can create an account at [https://signup.azure.com/](https://signup.azure.com/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这项练习，您需要拥有一个活跃的Azure账户。您可以在[https://signup.azure.com/](https://signup.azure.com/)上创建一个账户。
- en: 'Exercise 5: Creating a Parameterized Function in Azure Functions'
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习5：在Azure Functions中创建一个带参数的函数
- en: In this exercise, we aim to create a parameterized function in Azure and invoke
    it over its HTTP endpoint with different parameters.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们的目标是在Azure中创建一个带参数的函数，并通过其HTTP端点以不同的参数进行调用。
- en: 'To successfully complete this exercise, we need to ensure the following steps
    are executed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功完成这项练习，我们需要确保执行以下步骤：
- en: 'Click on **Function App** in the left menu of the **Azure** home page, as shown
    in the following screenshot:![Figure 2.14: Azure home page'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Azure**首页的左侧菜单中点击**Function App**，如下截图所示：![图2.14：Azure首页
- en: '](image/C12607_02_14.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_14.jpg)'
- en: 'Figure 2.14: Azure home page'
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.14：Azure首页
- en: 'Click on **Create Function App** from the **Function App** list, as shown in
    the following screenshot:![Figure 2.15: Function App list'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Function App**列表中点击**创建函数应用**，如下截图所示：![图2.15：函数应用列表
- en: '](image/C12607_02_15.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_15.jpg)'
- en: 'Figure 2.15: Function App list'
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.15：函数应用列表
- en: 'Give the app a unique name, such as `hello-from-azure`, and select **Node.js**
    as the **Runtime Stack**. Click on **Create** at the bottom of the page, as shown
    in the following screenshot:![Figure 2.16: Creating a Function App'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给应用取一个唯一的名称，比如`hello-from-azure`，并选择**Node.js**作为**Runtime Stack**。点击页面底部的**创建**，如下截图所示：![图2.16：创建一个函数应用
- en: '](image/C12607_02_16.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_16.jpg)'
- en: 'Figure 2.16: Creating a Function App'
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.16：创建一个函数应用
- en: 'You will be redirected to the **Function App** list view. Check for a notification
    at the top of the menu. You will see **Deployment to resource group ''hello-from-azure''
    is in progress**, as shown in the following screenshot:![Figure 2.17: Deployment
    in progress'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被重定向到**函数应用**列表视图。检查菜单顶部是否有通知。您将看到**正在部署到资源组'hello-from-azure'**，如下图所示：![图2.17：部署正在进行中
- en: '](image/C12607_02_17.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_17.jpg)'
- en: 'Figure 2.17: Deployment in progress'
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.17：部署正在进行中
- en: 'Wait a couple of minutes until the deployment is complete:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几分钟，直到部署完成：
- en: '![Figure 2.18: Successful deployment'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.18：成功部署'
- en: '](image/C12607_02_18.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_18.jpg)'
- en: 'Figure 2.18: Successful deployment'
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.18：成功部署
- en: 'Click on **+ New Function** in the `hello-from-azure` function app view, as
    shown in the following screenshot:![Figure 2.19: hello-from-azure function app'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`hello-from-azure`函数应用视图中点击**+新函数**，如下图所示：![图2.19：hello-from-azure函数应用
- en: '](image/C12607_02_19.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_19.jpg)'
- en: 'Figure 2.19: hello-from-azure function app'
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.19：hello-from-azure函数应用
- en: 'Select **In-portal** for function creation inside the Azure web portal as a
    development environment and click **Continue**, as shown in the following screenshot:![Figure
    2.20: Function development environment'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**In-portal**作为开发环境，在Azure Web门户内创建函数，并单击**继续**，如下图所示：![图2.20：函数开发环境
- en: '](image/C12607_02_20.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_20.jpg)'
- en: 'Figure 2.20: Function development environment'
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.20：函数开发环境
- en: 'Select **Webhook + API** and click **Create**, as shown in the following screenshot:![Figure
    2.21: Function trigger types'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Webhook + API**，然后单击**创建**，如下图所示：![图2.21：函数触发器类型
- en: '](image/C12607_02_21.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_21.jpg)'
- en: 'Figure 2.21: Function trigger types'
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.21：函数触发器类型
- en: In this view, it is possible to create functions from templates such as webhooks,
    timers, or collaborative templates from the marketplace.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在此视图中，可以从模板创建函数，例如webhooks、定时器或来自市场的协作模板。
- en: 'Write the following function into `index.js` and click **Save**:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数写入`index.js`，然后单击**保存**：
- en: '[PRE1]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code exports a function that accepts parameters from the request. The
    function creates a personalized message and sends it as output to the users. The
    code should be inserted into the code editor, as shown in the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码导出一个接受来自请求的参数的函数。该函数创建一个个性化消息，并将其作为输出发送给用户。代码应该插入到代码编辑器中，如下图所示：
- en: '![Figure 2.22: index.js of the hello-from-azure function'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.22：hello-from-azure函数的index.js'
- en: '](image/C12607_02_22.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_22.jpg)'
- en: 'Figure 2.22: index.js of the hello-from-azure function'
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.22：hello-from-azure函数的index.js
- en: Click on **Get function URL** and copy the URL inside the popup, as shown in
    the
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**获取函数URL**并复制弹出窗口中的URL，如下图所示
- en: 'following screenshot:![Figure 2.23: Function URL'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的屏幕截图：![图2.23：函数URL
- en: '](image/C12607_02_23.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_23.jpg)'
- en: 'Figure 2.23: Function URL'
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.23：函数URL
- en: 'Open the URL you copied in *Step 7* into a new tab in the browser, as shown
    in the following screenshot:![Figure 2.24: Function response without parameter'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开您在*步骤7*中复制的URL，如下面的屏幕截图所示：![图2.24：没有参数的函数响应
- en: '](image/C12607_02_24.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_24.jpg)'
- en: 'Figure 2.24: Function response without parameter'
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.24：没有参数的函数响应
- en: 'Add **&name=** and your name to the end of the URL and reload the tab, for
    example, `https://hello-from-azure.azurewebsites.net/api/HttpTrigger?code=nNrck...&name=Onur`,
    as shown in the following screenshot:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在URL的末尾添加**&name=**和您的名字，然后重新加载选项卡，例如`https://hello-from-azure.azurewebsites.net/api/HttpTrigger?code=nNrck...&name=Onur`，如下面的屏幕截图所示：
- en: '![Figure 2.25: Function response with parameter'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.25：带参数的函数响应'
- en: '](image/C12607_02_25.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_25.jpg)'
- en: 'Figure 2.25: Function response with parameter'
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.25：带参数的函数响应
- en: These responses show that it is possible to validate and pass parameters to
    functions. Passing parameters and their validation is essential for serverless
    functions and when considering the possibility of various integration points as
    triggers and bindings.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些响应表明可以验证和传递参数给函数。对于无服务器函数以及考虑各种触发器和绑定的可能性时，传递参数及其验证是至关重要的。
- en: 'Return to the **Function App** list from *Step 2*, click **...** alongside
    the new function we''ve created, and select **Delete**, as shown in the following
    screenshot:![Figure 2.26: Deleting a function'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*步骤2*返回**函数应用**列表，单击我们创建的新函数旁边的**...**，然后选择**删除**，如下面的屏幕截图所示：![图2.26：删除函数
- en: '](image/C12607_02_26.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_26.jpg)'
- en: 'Figure 2.26: Deleting a function'
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.26：删除函数
- en: 'Type the name of the function into the pop-up view and click **Delete** to
    delete all the resources. In the confirmation view, a warning indicates that deletion
    of the function application is irreversible, as you can see in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹出视图中输入函数名称，然后单击**删除**以删除所有资源。在确认视图中，警告指示函数应用的删除是不可逆的，如下面的屏幕截图所示：
- en: '![Figure 2.27: Deleting the function and its resources'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.27：删除函数及其资源'
- en: '](image/C12607_02_27.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_27.jpg)'
- en: 'Figure 2.27: Deleting the function and its resources'
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.27：删除函数及其资源
- en: In the following section, Google Cloud Functions will be discussed in a similar
    way, and a more complicated function will be deployed to the cloud provider.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，将以类似的方式讨论谷歌云函数，并将更复杂的函数部署到云提供商。
- en: Google Cloud Functions
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 谷歌云函数
- en: Google Cloud Functions was made public in 2017 just after AWS Lambda and Azure
    Functions. Serverless functions were already available for the PaaS product of
    Google, namely **Firebase**, before the release of Google Cloud Functions. However,
    Google Cloud Functions was made available to all the services inside the Google
    Cloud Platform as its core serverless cloud product. In this section, Google Cloud
    Functions will be discussed in terms of the supported programming languages, trigger
    types, and cost. Finally, we will deploy a function that is periodically invoked
    by cloud services to Google Cloud Functions to illustrate its operational side.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌云函数于2017年公开发布，就在AWS Lambda和Azure Functions之后。在谷歌云函数发布之前，PaaS产品谷歌的**Firebase**已经支持无服务器函数。然而，谷歌云函数作为其核心无服务器云产品，已经对谷歌云平台内的所有服务开放。在本节中，将讨论谷歌云函数支持的编程语言、触发器类型和成本。最后，我们将部署一个定期被云服务调用的函数到谷歌云函数，以展示其操作方面。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The official website of Google Cloud Functions can be found here if you wish
    to find out more: [https://cloud.google.com/functions/](https://cloud.google.com/functions/).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多信息，可以在谷歌云函数的官方网站找到：[https://cloud.google.com/functions/](https://cloud.google.com/functions/)。
- en: '**Google Cloud Functions** (**GCF**) can be developed in **Node.js**, **Python**,
    and **Go**. Compared to the other major cloud providers, GCF supports a small
    subset of languages. In addition, there are no publicly available language extension
    or APIs supported by GCF. Thus, it is essential to evaluate whether the languages
    supported by GCF are feasible for the functions you will develop.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**谷歌云函数**（**GCF**）可以使用**Node.js**、**Python**和**Go**进行开发。与其他主要云提供商相比，GCF支持的语言范围较小。此外，GCF不支持公开可用的语言扩展或API。因此，评估GCF支持的语言是否适用于您将开发的函数至关重要。'
- en: Google Cloud Functions are designed to be associated with triggers and events.
    Events happen within your cloud services, such as database changes, new files
    in the storage system, or when provisioning new virtual machines. Triggers are
    the declaration of the services and related events as inputs to functions. It
    is possible to create triggers as **HTTP** endpoints, **Cloud Pub/Sub** queue
    messages, or storage services such as **Cloud Storage** and **Cloud Firestore**.
    In addition, functions can be connected to the big data and machine learning services
    that are provided in the Google Cloud Platform.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Functions旨在与触发器和事件相关联。事件发生在您的云服务中，例如数据库更改、存储系统中的新文件，或者在提供新虚拟机时。触发器是将服务和相关事件声明为函数输入的声明。可以创建触发器作为**HTTP**端点、**Cloud
    Pub/Sub**队列消息，或存储服务，如**Cloud Storage**和**Cloud Firestore**。此外，函数可以连接到Google Cloud
    Platform提供的大数据和机器学习服务。
- en: 'The cost calculation of Google Cloud Platform is slightly complex compared
    to other cloud providers. This is because it takes the invocations, computation
    time, and outbound network data into consideration, while other cloud providers
    focus only on invocations and compute time:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他云提供商相比，Google Cloud Platform的成本计算略微复杂。这是因为它考虑了调用、计算时间和出站网络数据，而其他云提供商只关注调用和计算时间：
- en: '**Invocations:** Function invocations are charged $0.40 for every one million
    requests.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用**：每一百万请求收取0.40美元。'
- en: '**Compute time:** The computation times of the functions are measured from
    the time of invocation to their completion in 100 ms increments. For instance,
    if your function takes 240 ms to complete, you will be charged for 300 ms of computation
    time. There are two units that are used in this calculation – **GB per second**
    and **GHz per second**. 1 GB of memory is provisioned for a function running for
    1 second, and the price of 1 GB per second is $0.0000025\. Also, 1 GHz of CPU
    is provisioned for a function running for 1 second, and the price of 1 GHz per
    second is $0.0000100\.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算时间**：函数的计算时间从调用开始到完成，以100毫秒为增量计算。例如，如果您的函数完成需要240毫秒，您将被收取300毫秒的计算时间费用。在这个计算中使用了两个单位
    - **每秒GB** 和 **每秒GHz**。为运行1秒的函数提供1GB内存，每秒1GB的价格为0.0000025美元。此外，为运行1秒的函数提供1GHz的CPU，每秒1GHz的价格为0.0000100美元。'
- en: '**Outbound network data:** Data that''s transferred from the function to the
    outside is measured in GB and charged at $0.12 for every GB of data.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**出站网络数据**：从函数传输到外部的数据以GB计量，每GB数据收取0.12美元。'
- en: GCF's free tier provides 2 million invocations, 400,000 GB per second, 200,000
    GHz per second of computation time, and 5 GB of outbound network traffic per month.
    Compared to AWS or Azure, GCP will cost slightly more since it has higher prices
    and more sophisticated calculation methods.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: GCF的免费套餐提供了200万次调用、每秒400,000GB、每秒200,000GHz的计算时间，以及每月5GB的出站网络流量。与AWS或Azure相比，GCP的成本会略高，因为它的价格更高，计算方法更复杂。
- en: 'Let''s assume that your function is called 30 million times in a month. You
    have allocated 128 MB of memory, 200 MHz CPU, and on average, the function runs
    for 200 ms, similar to the example for AWS Lambda:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的函数一个月被调用了3000万次。您已经分配了128MB内存，200MHz的CPU，并且平均来说，函数运行时间为200毫秒，类似于AWS Lambda的例子：
- en: '*Request charges:*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*请求费用*'
- en: '**Price**: $0.40 per 1 M request'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**价格**：每1百万请求0.40美元'
- en: '**Free tier**: 2 M'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**免费套餐**：2百万'
- en: '**Monthly request**: 30 M'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**每月请求**：30百万'
- en: '**Monthly request charge** = 28 M x $0.40 / M = $11.2'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**每月请求费用** = 28百万 x 0.40 / 百万 = 11.2美元'
- en: '*Compute charges - Memory:*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算费用 - 内存：*'
- en: '**Price**: $0.0000025 per GB-second'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**价格**：每GB秒0.0000025美元'
- en: '**Free tier**: 400,000 GB-Seconds'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**免费套餐**：400,000GB秒'
- en: '**Monthly compute**: 30 M x 0.2 second x 128 MB / 1024 = 750,000 GB-second'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**每月计算**：30 M x 0.2秒 x 128 MB / 1024 = 750,000 GB秒'
- en: '**Monthly memory charge**: 350,000 x $0.0000025 = $0.875'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**每月内存费用**：350,000 x $0.0000025 = $0.875'
- en: '*Compute charges - CPU:*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算费用 - CPU：*'
- en: '**Price**: $0.0000100 per GHz-second'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**价格**：每GHz秒$0.0000100'
- en: '**Free tier**: 200,000 GB-Seconds'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**免费套餐**：200,000 GB秒'
- en: '**Monthly compute**: 30 M x 0.2 second x 200 MHz / 1000 GHz = 1,200,000 GHz-second'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**每月计算**：30 M x 0.2秒 x 200 MHz / 1000 GHz = 1,200,000 GHz秒'
- en: '**Monthly CPU charge**: 1,000,000 x $0.0000100 = $10'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**每月CPU费用**：1,000,000 x $0.0000100 = $10'
- en: '**Monthly total cost**= $11.2 + $0.875 + $10 = $22.075'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**每月总费用**= $11.2 + $0.875 + $10 = $22.075'
- en: Since the unit prices are slightly higher than AWS and Azure, the total monthly
    cost of running the same function is more than $22 in GCP, while it was around
    $11 for AWS and Azure. Also, any outbound network from the functions to the outside
    world is critical when it comes to potential extra costs. Therefore, pricing methods
    and unit prices should be analyzed in depth before you choose a serverless cloud
    platform.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单位价格略高于AWS和Azure，运行相同函数的总月费用在GCP中超过$22，而在AWS和Azure中约为$11。此外，从函数到外部世界的任何出站网络在潜在的额外成本方面都是至关重要的。因此，在选择无服务器云平台之前，应深入分析定价方法和单位价格。
- en: In the following exercise, our very first serverless function will be deployed
    to GCF and will be invoked by a scheduled trigger to show the operational view
    of the platform.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的练习中，我们的第一个无服务器函数将部署到GCF，并将被定时触发器调用，以显示平台的运行视图。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In order to complete this exercise, you need to have an active Google account.
    You can create an account at [https://console.cloud.google.com/start](https://console.cloud.google.com/start).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个练习，您需要拥有一个活跃的Google账户。您可以在[https://console.cloud.google.com/start](https://console.cloud.google.com/start)上创建一个账户。
- en: 'Exercise 6: Creating a Scheduled Function in GCF'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习6：在GCF中创建一个定时函数
- en: In this exercise, we aim to create a scheduled function in Google Cloud Platform
    and check its invocation by using cloud scheduler services.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们的目标是在Google Cloud Platform中创建一个定时函数，并使用云调度器服务来检查其调用。
- en: 'To successfully complete this exercise, we need to ensure the following steps
    are executed:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功完成这个练习，我们需要确保执行以下步骤：
- en: 'Click on **Cloud Functions** in the left menu, which can be found in the **Compute**
    group on the Google Cloud Platform home page, as shown in the following screenshot:![Figure
    2.28: Google Cloud Platform home page'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧菜单中的**云函数**，它可以在Google Cloud Platform主页的**计算**组中找到，如下面的屏幕截图所示：![图2.28：Google
    Cloud Platform主页
- en: '](image/C12607_02_28.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_28.jpg)'
- en: 'Figure 2.28: Google Cloud Platform home page'
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.28：Google Cloud Platform主页
- en: 'Click on **Create function** on the **Cloud Functions** page, as shown in the
    following screenshot:![Figure 2.29: Cloud Functions page'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Cloud Functions**页面上的**创建函数**，如下面的屏幕截图所示：![图2.29：云函数页面
- en: '](image/C12607_02_29.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_29.jpg)'
- en: 'Figure 2.29: Cloud Functions page'
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.29：云函数页面
- en: 'In the function creation form, change the function name to `HelloWorld` and
    select 128 MB for the memory allocation. Ensure that **HTTP** is selected as the
    trigger method and that **Go 1.11** is selected as the runtime, as shown in the
    following screenshot:![Figure 2.30: Function creation form'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数创建表单中，将函数名称更改为`HelloWorld`，并选择128 MB的内存分配。确保选择**HTTP**作为触发方法，并选择**Go 1.11**作为运行时，如下面的屏幕截图所示：![图2.30：函数创建表单
- en: '](image/C12607_02_30.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_30.jpg)'
- en: 'Figure 2.30: Function creation form'
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.30：函数创建表单
- en: 'Change `function.go` using the inline editor inside the browser so that it
    has the following content:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用浏览器内联编辑器更改`function.go`，使其具有以下内容：
- en: '[PRE2]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code segment creates a `HelloWorld` function with a static message printed
    to the output. The code should be inserted into `function.go` in the code editor,
    as shown in the following screenshot:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码段创建一个带有静态消息打印到输出的“HelloWorld”函数。代码应插入到代码编辑器中的“function.go”中，如下截图所示：
- en: '![Figure 2.31: Function inline editor'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.31：函数内联编辑器'
- en: '](image/C12607_02_31.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_31.jpg)'
- en: 'Figure 2.31: Function inline editor'
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.31：函数内联编辑器
- en: 'Copy the URL in the form below the **Trigger** selection box to invoke the
    function, as shown in the following screenshot:![Figure 2.32: Function trigger
    URL'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制“触发器”选择框下方表单中的URL以调用函数，如下截图所示：![图2.32：函数触发URL
- en: '](image/C12607_02_32.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_32.jpg)'
- en: 'Figure 2.32: Function trigger URL'
  id: totrans-218
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.32：函数触发URL
- en: 'Click on the **Create** button at the end of the form. With this configuration,
    the code from step 4 will be packaged and deployed to Google Cloud Platform. In
    addition, a trigger URL will be assigned to the function to be reachable from
    outside, as shown in the following screenshot:![Figure 2.33: Function creation'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击表单末尾的“创建”按钮。使用此配置，将打包并部署第4步的代码到Google Cloud Platform。此外，将为函数分配一个触发器URL，以便从外部访问，如下截图所示：![图2.33：函数创建
- en: '](image/C12607_02_33.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_33.jpg)'
- en: 'Figure 2.33: Function creation'
  id: totrans-221
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.33：函数创建
- en: 'Wait a couple of minutes until the `HelloWorld` function in the function list
    has a green check icon next to it, as shown in the following screenshot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几分钟，直到函数列表中的“HelloWorld”函数旁边有一个绿色的勾号图标，如下截图所示：
- en: '![Figure 2.34: Function deployment'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.34：功能部署'
- en: '](image/C12607_02_34.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_34.jpg)'
- en: 'Figure 2.34: Function deployment'
  id: totrans-225
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.34：功能部署
- en: 'Open the URL you copied in step 5 into a new tab in your browser, as shown
    in the following screenshot:![Figure 2.35: Function response'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开您在第5步中复制的URL，如下截图所示：![图2.35：函数响应
- en: '](image/C12607_02_35.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_35.jpg)'
- en: 'Figure 2.35: Function response'
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.35：函数响应
- en: The response shows that the function has been successfully deployed and is running
    as expected.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 响应显示函数已成功部署并按预期运行。
- en: 'Click on **Cloud Scheduler** in the left menu, under **TOOLS**, as shown in
    the following screenshot:![Figure 2.36: Google Cloud Tools Menu'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中单击“TOOLS”下的“Cloud Scheduler”，如下截图所示：![图2.36：Google Cloud工具菜单
- en: '](image/C12607_02_36.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_36.jpg)'
- en: 'Figure 2.36: Google Cloud Tools Menu'
  id: totrans-232
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.36：Google Cloud工具菜单
- en: 'Click on **Create job** on the **Cloud Scheduler** page, as shown in the following
    screenshot:![Figure 2.37: Cloud Scheduler page'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Cloud Scheduler”页面上单击“创建作业”，如下截图所示：![图2.37：Cloud Scheduler页面
- en: '](image/C12607_02_37.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_37.jpg)'
- en: 'Figure 2.37: Cloud Scheduler page'
  id: totrans-235
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.37：Cloud Scheduler页面
- en: 'Select a region if you are using **Cloud Scheduler** for the first time in
    your Google Cloud project and click **Next**, as shown in the following screenshot:![Figure
    2.38: Cloud Scheduler – region selection'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在Google Cloud项目中首次使用Cloud Scheduler，请选择一个区域，然后单击“下一步”，如下截图所示：![图2.38：Cloud
    Scheduler – 区域选择
- en: '](image/C12607_02_38.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_38.jpg)'
- en: 'Figure 2.38: Cloud Scheduler – region selection'
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.38：Cloud Scheduler – 区域选择
- en: 'Wait for a couple of minutes if you see the following notification:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果看到以下通知，请等待几分钟：
- en: '**We are initializing Cloud Scheduler in your selected region. This usually
    takes about a minute**.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们正在初始化您选择的区域中的Cloud Scheduler。这通常需要大约一分钟**。'
- en: 'Set the job name as `HelloWorldEveryMinute` and the frequency as `* * * * *`,
    which means the job will be triggered every minute. Select HTTP as the target
    and paste the URL you copied in step 5 into the URL box, as shown in the following
    screenshot:![Figure 2.39: Scheduler job creation'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将作业名称设置为`HelloWorldEveryMinute`，频率设置为`* * * * *`，这意味着作业将每分钟触发一次。选择HTTP作为目标，并将在步骤5中复制的URL粘贴到URL框中，如下面的屏幕截图所示：![图2.39：调度程序作业创建
- en: '](image/C12607_02_39.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_39.jpg)'
- en: 'Figure 2.39: Scheduler job creation'
  id: totrans-243
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.39：调度程序作业创建
- en: 'You will be redirected to the **Cloud Scheduler** list, as shown in the following
    screenshot:![Figure 2.40: Cloud Scheduler page'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被重定向到**Cloud Scheduler**列表，如下面的屏幕截图所示：![图2.40：云调度程序页面
- en: '](image/C12607_02_40.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_40.jpg)'
- en: 'Figure 2.40: Cloud Scheduler page'
  id: totrans-246
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.40：云调度程序页面
- en: 'Wait for a couple of minutes and click the **Refresh** button. The list will
    show the **Last run** timestamp and its result for `HelloWorldEveryMinute`, as
    shown in the following screenshot:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几分钟，然后单击**刷新**按钮。列表将显示`HelloWorldEveryMinute`的**最后运行**时间戳及其结果，如下面的屏幕截图所示：
- en: '![Figure 2.41: Cloud Scheduler page with run information'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.41：带有运行信息的云调度程序页面'
- en: '](image/C12607_02_41.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_41.jpg)'
- en: 'Figure 2.41: Cloud Scheduler page with run information'
  id: totrans-250
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.41：带有运行信息的云调度程序页面
- en: This indicates that the cloud scheduler triggered our function at `Aug 13, 2019,
    3:44:00 PM` and that the result was successful.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明云调度程序在`2019年8月13日下午3:44:00`触发了我们的函数，并且结果是成功的。
- en: 'Return to the function list from step 7 and click **…** for the `HelloWorld`
    function. Then, click **Logs**, as shown in the following screenshot:![Figure
    2.42: Settings menu for the function'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第7步返回到函数列表，然后单击`HelloWorld`函数的**...**，然后单击**日志**，如下面的屏幕截图所示：![图2.42：函数的设置菜单
- en: '](image/C12607_02_42.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_42.jpg)'
- en: 'Figure 2.42: Settings menu for the function'
  id: totrans-254
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.42：函数的设置菜单
- en: 'You will be redirected to the logs of the function, where you will see that,
    every minute, `Function execution started` and the corresponding success logs
    are listed, as shown in the following screenshot:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被重定向到函数的日志，您将看到，每分钟，`函数执行开始`和相应的成功日志被列出，如下面的屏幕截图所示：
- en: '![Figure 2.43: Function logs'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.43：函数日志'
- en: '](image/C12607_02_43.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_43.jpg)'
- en: 'Figure 2.43: Function logs'
  id: totrans-258
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.43：函数日志
- en: As you can see, the cloud scheduler is invoking the function as planned and
    that the function is running successfully.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，云调度程序正在按计划调用函数，并且函数正在成功运行。
- en: 'Return to the Cloud Scheduler page from Step 13, choose `HelloWorldEveryMinute`,
    click **Delete** on the menu, and then confirm this in the popup, as shown in
    the following screenshot:![Figure 2.44: Cloud Scheduler – job deletion'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第13步返回到云调度程序页面，选择`HelloWorldEveryMinute`，在菜单上单击**删除**，然后在弹出窗口中确认，如下面的屏幕截图所示：![图2.44：云调度程序-作业删除
- en: '](image/C12607_02_44.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_44.jpg)'
- en: 'Figure 2.44: Cloud Scheduler – job deletion'
  id: totrans-262
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.44：云调度程序-作业删除
- en: 'Return to the **Cloud Functions** page from step 7, choose `HelloWorld`, click
    **Delete** on the menu, and then confirm this in the popup, as shown in the following
    screenshot:![Figure 2.45: Cloud Functions – function deletion'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第7步返回到**Cloud Functions**页面，选择`HelloWorld`，在菜单上单击**删除**，然后在弹出窗口中确认，如下面的屏幕截图所示：![图2.45：云函数-函数删除
- en: '](image/C12607_02_45.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_45.jpg)'
- en: 'Figure 2.45: Cloud Functions – function deletion'
  id: totrans-265
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.45：云函数-函数删除
- en: In this exercise, we created a `Hello World` function and deployed it to GCF.
    In addition, a cloud scheduler job was created to trigger the function with specific
    intervals such as every minute. Now, the function is connected to another cloud
    service so that the function can trigger the service. It is essential to integrate
    functions with other cloud services and evaluate their integration capabilities
    prior to choosing a cloud FaaS provider.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建了一个`Hello World`功能并将其部署到GCF。此外，还创建了一个云调度程序作业，以特定的间隔触发该功能，比如每分钟一次。现在，该功能已连接到另一个云服务，以便该功能可以触发该服务。在选择云FaaS提供商之前，将功能与其他云服务集成并评估其集成能力是至关重要的。
- en: In the following activity, you will develop a real-life daily stand-up reminder
    function. You will connect a function and function trigger service you wish to
    invoke on your specific stand-up meeting time. In addition, this reminder will
    send a specific message to a cloud-based collaboration tool, namely *Slack*.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下活动中，您将开发一个真实的每日站立提醒功能。您将连接一个您希望在特定站立会议时间调用的功能和功能触发服务。此外，这个提醒将发送一个特定的消息到一个基于云的协作工具，即*Slack*。
- en: 'Activity 2: Daily Stand-Up Meeting Reminder Function for Slack'
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动2：Slack每日站立会议提醒功能
- en: The aim of this activity is to create a real-life function for stand-up meeting
    reminders in Slack. This reminder function will be invoked at specific times for
    your team to remind everyone in your team about the next stand-up meeting. The
    reminder will work with Slack since it is a popular collaboration tool that's
    been adopted by numerous organizations worldwide.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的目的是在Slack中创建一个真实的站立会议提醒功能。这个提醒功能将在特定时间被调用，以提醒您团队中的每个人下一次站立会议。提醒将与Slack一起工作，因为它是一种受到全球许多组织采用的流行协作工具。
- en: Note
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In order to complete this activity, you need to access a Slack workplace. You
    can use your existing Slack workspace or create a new one for free at [https://slack.com/create](https://slack.com/create).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个活动，您需要访问Slack的工作区。您可以在[https://slack.com/create](https://slack.com/create)免费使用现有的Slack工作区或创建一个新的。
- en: 'Once completed, you will have deployed a daily stand-up reminder function to
    GCF, as shown in the following screenshot:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您将部署每日站立提醒功能到GCF，如下截图所示：
- en: '![Figure 2.46: Daily reminder function'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.46：每日提醒功能'
- en: '](image/C12607_02_46.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_46.jpg)'
- en: 'Figure 2.46: Daily reminder function'
  id: totrans-275
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.46：每日提醒功能
- en: 'In addition, you will need an integration environment for invoking the function
    at specified meeting times. Stand-up meetings generally take place at a specific
    time on workdays. Thus, a scheduler job will be connected to trigger your function
    according to your meeting time, as shown in the following screenshot:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还需要一个集成环境来在指定的会议时间调用该功能。站立会议通常在工作日的特定时间举行。因此，调度程序作业将被连接以根据您的会议时间触发您的功能，如下截图所示：
- en: '![Figure 2.47: Daily reminder scheduler'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.47：每日提醒调度程序'
- en: '](image/C12607_02_47.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_47.jpg)'
- en: 'Figure 2.47: Daily reminder scheduler'
  id: totrans-279
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.47：每日提醒调度程序
- en: 'Finally, when the scheduler invokes the function, you will have reminder messages
    in your Slack channel, as shown in the following screenshot:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当调度程序调用该功能时，您将在Slack频道中收到提醒消息，如下截图所示：
- en: '![Figure 2.48: Slack message for meeting reminder'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.48：Slack会议提醒消息'
- en: '](image/C12607_02_48.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_02_48.jpg)'
- en: 'Figure 2.48: Slack message for meeting reminder'
  id: totrans-283
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2.48：Slack会议提醒消息
- en: Note
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In order to complete this activity, you should configure Slack by following
    the Slack Setup steps.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个活动，您应该按照Slack设置步骤配置Slack。
- en: '**Slack Setup**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**Slack设置**'
- en: 'Execute the following steps to configure Slack:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤配置Slack：
- en: In the **Slack** workspace, click on your username and select **Customize Slack**.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Slack工作区中，点击您的用户名，然后选择自定义Slack。
- en: Click on **Configure apps** in the open window.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的窗口中点击**配置应用**。
- en: Click on **Browse the App Directory** to add a new application from the directory.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**浏览应用目录**以从目录中添加新应用。
- en: Find **Incoming WebHooks** from the search box in **App Directory**.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**应用目录**的搜索框中找到**传入WebHooks**。
- en: Click on **Add Configuration** for the **Incoming WebHooks** application.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加配置**以添加**传入WebHooks**应用。
- en: Fill in the configuration for the incoming webhook with your specific channel
    name and icon.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写传入Webhook的配置，包括您特定的频道名称和图标。
- en: Open your Slack workspace and channel. You will see an integration message.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的Slack工作区和频道。您会看到一个集成消息。
- en: Note
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Detailed screenshots of the Slack setup steps can be found on page 376.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在第376页可以找到Slack设置步骤的详细截图。
- en: 'Execute the following steps to complete this activity:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此活动：
- en: Create a new function in GCF to call the Slack webhook when it is invoked.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GCF中创建一个新函数，在调用时调用Slack Webhook。
- en: 'The code should send a JSON request to the Slack webhook URL with a similar
    object: `{"text": "Time for a stand-up meeting"}`. You can implement the code
    in any language that''s supported by GCF. The code snippet is as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '代码应该向Slack Webhook URL发送一个类似的JSON请求对象：`{"text": "Time for a stand-up meeting"}`。您可以使用GCF支持的任何语言来实现代码。代码片段如下：'
- en: '[PRE3]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Create a scheduler job in **GCP** with the trigger URL of the function and specify
    the schedule based on your stand-up meeting times.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GCP中使用函数的触发URL创建一个调度程序作业，并根据您的站立会议时间指定调度。
- en: Check the Slack channel when the time that's been defined with the schedule
    has arrived for the reminder message.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在提醒消息的预定时间到达时，检查Slack频道。
- en: Delete the schedule job and function from the cloud provider.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从云提供商中删除调度作业和函数。
- en: Note
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 376.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第376页找到。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we described the evolution of cloud technology offerings, including
    how the cloud products have changed over the years and how responsibilities are
    distributed among organizations, starting with IaaS and PaaS and, finally, FaaS.
    Following that, criteria were presented for evaluating serverless cloud offerings.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了云技术产品的演变，包括云产品多年来的变化以及责任如何在组织之间分配，从IaaS和PaaS开始，最终到FaaS。随后，介绍了评估无服务器云产品的标准。
- en: Programming language support, function triggers, and the cost structure of serverless
    products were listed so that we could compare the various cloud providers, that
    is, AWS Lambda, Azure Functions, and GCF. In addition, we deployed a serverless
    function to all three cloud providers. This showed you how cloud functions can
    be integrated with other cloud services, such as the AWS API Gateway for REST
    API operations. Furthermore, a parameterized function was deployed to Azure Functions
    to show how we can process inputs from users or other systems. Finally, we deployed
    a scheduled function to GCF to show integration with other cloud services. At
    the end of this chapter, we implemented a real-life Slack reminder using serverless
    functions and cloud schedulers.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言支持、函数触发器和无服务器产品的成本结构被列出，以便我们可以比较各个云提供商，即AWS Lambda、Azure Functions和GCF。此外，我们将无服务器函数部署到了所有三个云提供商。这展示了云函数如何与其他云服务集成，比如用于REST
    API操作的AWS API Gateway。此外，我们部署了一个参数化函数到Azure Functions，以展示我们如何处理来自用户或其他系统的输入。最后，我们部署了一个定时函数到GCF，以展示与其他云服务的集成。在本章末尾，我们使用无服务器函数和云调度程序实现了一个真实的Slack提醒。
- en: In the next chapter, we will cover serverless frameworks and learn how to work
    with them.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍无服务器框架，并学习如何与它们一起工作。
