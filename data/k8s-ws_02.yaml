- en: 2\. An Overview of Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. Kubernetes概述
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will have our first hands-on introduction to Kubernetes.
    This chapter will give you a brief overview of the different components of Kubernetes
    and how they work together. We will also try our hand at working with some fundamental
    Kubernetes components.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首次介绍Kubernetes。本章将为您简要介绍Kubernetes的不同组件以及它们如何协同工作。我们还将尝试使用一些基本的Kubernetes组件。
- en: By the end of this chapter, you will have a single-node Minikube environment
    set up where you can run many of the exercises and activities in this book. You
    will be able to understand the high-level architecture of Kubernetes and identify
    the roles of the different components. You will also learn the basics required
    to migrate containerized applications to a Kubernetes environment.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将拥有一个设置好的单节点Minikube环境，可以在其中运行本书中的许多练习和活动。您将能够理解Kubernetes的高层架构，并确定不同组件的角色。您还将学会将容器化应用程序迁移到Kubernetes环境所需的基础知识。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: We ended the previous chapter by providing a brief and abstract introduction
    to Kubernetes, as well as some of its advantages. In this chapter, we will provide
    you with a much more concrete high-level understanding of how Kubernetes works.
    First, we will walk you through how to install Minikube, which is a handy tool
    that creates a single-node cluster and provides a convenient learning environment
    for Kubernetes. Then, we will take a 10,000-foot overview of all the components,
    including their responsibilities and how they interact with each other. After
    that, we will migrate the Docker application that we built in the previous chapter
    to Kubernetes and illustrate how it can enjoy the benefits afforded by Kubernetes,
    such as creating multiple replicas, and version updates. Finally, we will explain
    how the application responds to external and internal traffic.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中通过提供简要和抽象的介绍以及一些优势来结束了对Kubernetes的介绍。在本章中，我们将为您提供对Kubernetes工作方式的更具体的高层次理解。首先，我们将带您了解如何安装Minikube，这是一个方便的工具，可以创建单节点集群，并为Kubernetes提供便捷的学习环境。然后，我们将对所有组件进行一次总览，包括它们的职责以及它们如何相互交互。之后，我们将把我们在上一章中构建的Docker应用迁移到Kubernetes，并说明它如何享受Kubernetes所提供的好处，比如创建多个副本和版本更新。最后，我们将解释应用程序如何响应外部和内部流量。
- en: Having an overview of Kubernetes is important before we dive deeper into the
    different aspects of it so that when we learn more specifics about the different
    aspects, you will have an idea of where they fit in the big picture. Also, when
    we go even further and explore how to use Kubernetes to deploy applications in
    a production environment, you will have an idea of how everything is taken care
    of in the background. This will also help you with optimization and troubleshooting.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解Kubernetes的不同方面之前，了解Kubernetes的概述是很重要的，这样当我们学习更多关于不同方面的具体内容时，您将知道它们在整体中的位置。此外，当我们进一步探索如何使用Kubernetes在生产环境中部署应用程序时，您将了解到后台是如何处理一切的。这也将帮助您进行优化和故障排除。
- en: Setting up Kubernetes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Kubernetes
- en: Had you asked the question, "*How do you easily install Kubernetes?*" three
    years ago, it would have been hard to give a compelling answer. Embarrassing,
    but true. Kubernetes is a sophisticated system, and getting it installed and managing
    it well isn't an easy task.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果三年前你问这样一个问题：“*如何轻松安装Kubernetes？*”，那么很难给出一个令人信服的答案。尴尬但却是事实。Kubernetes是一个复杂的系统，安装和有效管理它并不是一件容易的事。
- en: 'However, as the Kubernetes community has expanded and matured, more and more
    user-friendly tools have emerged. As of today, based on your requirements, there
    are a lot of options to choose from:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着Kubernetes社区的扩大和成熟，出现了越来越多用户友好的工具。截至今天，根据您的需求，有很多选择：
- en: If you are using physical (bare-metal) servers or **virtual machines** (**VMs**),
    Kubeadm is a good fit.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在使用物理（裸机）服务器或虚拟机（VMs），Kubeadm是一个很好的选择。
- en: If you're running on cloud environments, Kops and Kubespray can ease Kubernetes
    installation, as well as integration with the cloud providers. In fact, we will
    teach you how to deploy Kubernetes on AWS using Kops in *Chapter 11*, *Build Your
    Own HA Cluster*, and we will take another look at the various options we can use
    to set up Kubernetes.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在云环境中运行，Kops和Kubespray可以简化Kubernetes的安装，以及与云提供商的集成。事实上，我们将教您如何在AWS上使用Kops部署Kubernetes，*第11章*，*构建您自己的HA集群*，我们将再次看看我们可以使用的各种选项来设置Kubernetes。
- en: If you want to drop the burden of managing the Kubernetes control plane (which
    we will learn about later in this chapter), almost all cloud providers have their
    Kubernetes managed services, such as **Google Kubernetes Engine** (**GKE**), **Amazon
    Elastic Kubernetes Service** (**EKS**), **Azure Kubernetes Service** (**AKS**),
    and **IBM Kubernetes Service** (**IKS**).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想摆脱管理Kubernetes控制平面的负担（我们将在本章后面学习），几乎所有的云提供商都有他们的Kubernetes托管服务，如Google Kubernetes
    Engine（GKE）、Amazon Elastic Kubernetes Service（EKS）、Azure Kubernetes Service（AKS）和IBM
    Kubernetes Service（IKS）。
- en: If you just want a playground to study Kubernetes in, Minikube and Kind can
    help you spin up a Kubernetes cluster in minutes.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您只是想要一个用来学习Kubernetes的游乐场，Minikube和Kind可以帮助您在几分钟内建立一个Kubernetes集群。
- en: We will use Minikube extensively throughout this book as a convenient learning
    environment. But before we proceed to the installation process, let's take a closer
    look at Minikube itself.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将广泛使用Minikube作为一个方便的学习环境。但在我们继续安装过程之前，让我们更仔细地看一下Minikube本身。
- en: An Overview of Minikube
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Minikube概述
- en: 'Minikube is a tool that can be used to set up a single-node cluster, and it
    provides handy commands and parameters to configure the cluster. It primarily
    aims to provide a local testing environment. It packs a VM containing all the
    core components of Kubernetes that get installed onto your host machine, all at
    once. This allows it to support any operating system, as long as there is a virtualization
    tool (also known as a Hypervisor) pre-installed. The following are the most common
    Hypervisors supported by Minikube:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube是一个用于设置单节点集群的工具，它提供了方便的命令和参数来配置集群。它的主要目标是提供一个本地测试环境。它打包了一个包含所有Kubernetes核心组件的虚拟机，一次性安装到您的主机上。这使得它能够支持任何操作系统，只要预先安装了虚拟化工具（也称为Hypervisor）。以下是Minikube支持的最常见的Hypervisors：
- en: VirtualBox (works for all operating systems)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VirtualBox（适用于所有操作系统）
- en: KVM (Linux-specific)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KVM（特定于Linux）
- en: Hyperkit (macOS-specific)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hyperkit（特定于macOS）
- en: Hyper-V (Windows-specific)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hyper-V（特定于Windows）
- en: Regarding the required hardware resources, the minimum requirement is 2 GB RAM
    and any dual-core CPU that supports virtualization (Intel VT or AMD-V), but you
    will, of course, need a more powerful machine if you are trying out heavier workloads.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所需的硬件资源，最低要求是2GB RAM和任何支持虚拟化的双核CPU（Intel VT或AMD-V），但如果您要尝试更重的工作负载，当然需要一台更强大的机器。
- en: Just like any other modern software, Kubernetes provides a handy command-line
    client called kubectl that allows users to interact with the cluster conveniently.
    In the next exercise, we will set up Minikube and use some basic kubectl commands.
    We will go into more detail about kubectl in the next chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他现代软件一样，Kubernetes提供了一个方便的命令行客户端，称为kubectl，允许用户方便地与集群交互。在下一个练习中，我们将设置Minikube并使用一些基本的kubectl命令。我们将在下一章更详细地介绍kubectl。
- en: 'Exercise 2.01: Getting Started with Minikube and Kubernetes Clusters'
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.01：开始使用Minikube和Kubernetes集群
- en: 'In this exercise, we will use Ubuntu 20.04 as the base operating system to
    install Minikube, using which we can start a single-node Kubernetes cluster easily.
    Once the Kubernetes cluster has been set up, you should be able to check its status
    and use `kubectl` to interact with it:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用Ubuntu 20.04作为基本操作系统来安装Minikube，使用它可以轻松启动单节点Kubernetes集群。一旦Kubernetes集群设置好了，你应该能够检查它的状态并使用`kubectl`与之交互：
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Since this exercise deals with software installations, you will need to be
    logged in as root/superuser. A simple way to switch to being a root user is to
    run the following command: `sudo su -`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个练习涉及软件安装，你需要以root/superuser身份登录。切换到root用户的简单方法是运行以下命令：`sudo su -`。
- en: In *step 9* of this exercise, we will create a regular user and then switch
    back to it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习的第9步中，我们将创建一个普通用户，然后切换回该用户。
- en: 'First, ensure that VirtualBox is installed. You can confirm this by using the
    following command:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先确保VirtualBox已安装。你可以使用以下命令确认：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should see the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If VirtualBox has been successfully installed, the `which` command should show
    the path of the executable, as shown in the preceding screenshot. If not, then
    please ensure that you have installed VirtualBox as per the instructions provided
    in the *Preface*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果VirtualBox已成功安装，`which`命令应该显示可执行文件的路径，就像前面的截图中显示的那样。如果没有，那么请确保你已按照*前言*中提供的说明安装了VirtualBox。
- en: 'Download the Minikube standalone binary by using the following command:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令下载Minikube独立二进制文件：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this command, `<version>` should be replaced with a specific version, such
    as `v1.5.2` (which is the version we will use in this chapter) or the `latest`.
    Depending on your host operating system, `<ostype-arch>` should be replaced with
    `linux-amd64` (for Ubuntu) or `darwin-amd64` (for macOS).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，`<version>`应该被替换为一个特定的版本，比如`v1.5.2`（这是本章中我们将使用的版本）或者`latest`。根据你的主机操作系统，`<ostype-arch>`应该被替换为`linux-amd64`（对于Ubuntu）或者`darwin-amd64`（对于macOS）。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To ensure compatibility with the commands provided in this book, we recommend
    that you install Minikube version `v1.5.2`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保与本书提供的命令兼容，我们建议安装Minikube版本`v1.5.2`。
- en: 'You should see the following output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![Figure 2.1: Downloading the Minikube binary'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1：下载Minikube二进制文件'
- en: '](image/B14870_02_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_01.jpg)'
- en: 'Figure 2.1: Downloading the Minikube binary'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：下载Minikube二进制文件
- en: 'The preceding command contains two parts: the first command, `curl`, downloads
    the Minikube binary, while the second command, `chmod`, changes the permission
    to make it executable.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令包含两部分：第一个命令`curl`下载Minikube二进制文件，而第二个命令`chmod`更改权限以使其可执行。
- en: 'Move the binary into the system path (in the example, it''s `/usr/local/bin`)
    so that we can directly run Minikube, regardless of which directory the command
    is run in:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将二进制文件移动到系统路径（在本例中是`/usr/local/bin`），这样我们可以直接运行Minikube，而不管命令在哪个目录中运行：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When executed successfully, the move (`mv`) command does not give a response
    in the terminal.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当成功执行时，移动（`mv`）命令不会在终端中给出响应。
- en: 'After running the move command, we need to confirm that the Minikube executable
    is now in the correct location:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行移动命令后，我们需要确认Minikube可执行文件现在位于正确的位置：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should see the following output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the `which minikube` command doesn't give you the expected result, you may
    need to explicitly add `/usr/local/bin` to your system path by running `export
    PATH=$PATH:/usr/local/bin`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`which minikube`命令没有给出预期的结果，您可能需要通过运行`export PATH=$PATH:/usr/local/bin`来显式将`/usr/local/bin`添加到系统路径。
- en: 'You can check the version of Minikube using the following command:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令检查Minikube的版本：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should see the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s download kubectl version `v1.16.2` (so that it''s compatible with
    the version of Kubernetes that our setup of Minikube will create later) and make
    it executable by using the following command:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们下载kubectl版本`v1.16.2`（以便与稍后我们的Minikube设置创建的Kubernetes版本兼容），并使用以下命令使其可执行：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As mentioned earlier, `<ostype>` should be replaced with `linux` (for Ubuntu)
    or `darwin` (for macOS).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`<ostype>`应替换为`linux`（对于Ubuntu）或`darwin`（对于macOS）。
- en: 'You should see the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 2.2: Downloading the kubectl binary'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2：下载kubectl二进制文件'
- en: '](image/B14870_02_02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_02.jpg)'
- en: 'Figure 2.2: Downloading the kubectl binary'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：下载kubectl二进制文件
- en: 'Then, move it to the system path, just like we did for the executable of Minikube
    earlier:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将其移动到系统路径，就像我们之前为Minikube的可执行文件所做的那样：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s check whether the executable for kubectl is at the correct path:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们检查kubectl的可执行文件是否在正确的路径上：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should see the following response:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since we are currently logged in as the `root` user, let''s create a regular
    user called `k8suser` by running the following command:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们当前以`root`用户登录，让我们通过运行以下命令创建一个名为`k8suser`的常规用户：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Enter your desired password when you are prompted for it. You will also be
    prompted to enter other details, such as your full name. You may choose to skip
    those details by simply pressing *Enter*. You should see an output similar to
    the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示时输入您想要的密码。您还将被提示输入其他详细信息，例如您的全名。您可以选择通过简单地按*Enter*来跳过这些细节。您应该看到类似于以下的输出：
- en: '![Figure 2.3: Creating a new Linux user'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3：创建新的Linux用户'
- en: '](image/B14870_02_03.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_03.jpg)'
- en: 'Figure 2.3: Creating a new Linux user'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：创建一个新的Linux用户
- en: Enter `Y` and hit *Enter* to confirm the final prompt for creating a user, as
    shown at the end of the previous screenshot.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`Y`并按*Enter*确认创建用户的最终提示，如前一个屏幕截图的末尾所示。
- en: 'Now, switch user from `root` to `k8suser`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从`root`切换用户到`k8suser`：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should see the following output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we can create a Kubernetes cluster using `minikube start`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`minikube start`创建一个Kubernetes集群：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to manage multiple clusters, Minikube provides a `--profile <profile
    name>` parameter to each cluster.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想管理多个集群，Minikube为每个集群提供了一个`--profile <profile name>`参数。
- en: 'It will take a few minutes to download the VM images and get everything set
    up. After Minikube has started up successfully, you should see a response that
    looks similar to the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下载VM镜像并进行所有设置需要几分钟时间。Minikube成功启动后，您应该看到类似于以下的响应：
- en: '![Figure 2.4: Minikube first startup'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4：Minikube首次启动'
- en: '](image/B14870_02_04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_04.jpg)'
- en: 'Figure 2.4: Minikube first startup'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：Minikube首次启动
- en: As we mentioned earlier, Minikube starts up a VM instance with all the components
    of Kubernetes inside it. By default, it uses VirtualBox, and you can use the `--vm-driver`
    flag to specify a particular hypervisor driver (such as `hyperkit` for macOS).
    Minikube also provides the `--kubernetes-version` flag so you can specify the
    Kubernetes version you want to use. If not specified, it will use the latest version
    that was available when the Minikube release was finalized. In this chapter, to
    ensure compatibility of the Kubernetes version with the kubectl version, we have
    specified Kubernetes version `v1.16.2` explicitly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Minikube在一个VM实例中启动了所有Kubernetes的组件。默认情况下，它使用VirtualBox，并且您可以使用`--vm-driver`标志来指定特定的hypervisor驱动程序（例如`hyperkit`用于macOS）。Minikube还提供了`--kubernetes-version`标志，因此您可以指定要使用的Kubernetes版本。如果未指定，它将使用Minikube发布时可用的最新版本。在本章中，为了确保Kubernetes版本与kubectl版本的兼容性，我们明确指定了Kubernetes版本`v1.16.2`。
- en: The following commands should help establish that the Kubernetes cluster that
    was started by Minikube is running properly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令应该有助于建立Minikube启动的Kubernetes集群是否正常运行。
- en: 'Use the following command to get the basic status of the various components
    of the cluster:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用以下命令获取集群各个组件的基本状态： '
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should see the following response:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s look at the version of the kubectl client and Kubernetes server:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看一下kubectl客户端和Kubernetes服务器的版本：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should see the following response:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s learn how many machines comprise the cluster and get some basic information
    about them:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们了解一下集群由多少台机器组成，并获取一些关于它们的基本信息：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should see a response similar to the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的响应：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After finishing this exercise, you should have Minikube set up with a single-node
    Kubernetes cluster. In the next section, we will enter the Minikube VM to take
    a look at how the cluster is composed and the various components of Kubernetes
    that make it work.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，您应该已经设置好了一个单节点的Kubernetes集群。在下一节中，我们将进入Minikube虚拟机，看看集群是如何组成的，以及使其工作的Kubernetes的各个组件。
- en: Kubernetes Components Overview
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes组件概述
- en: By completing the previous exercise, you have a single-node Kubernetes cluster
    up and running. Before playing your first concert, let's hold on a second and
    pull the curtains aside to take a look backstage to see how Kubernetes is architected
    behind the scenes, and then check how Minikube glues its various components together
    inside its VM.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成上一个练习，您已经拥有一个单节点的Kubernetes集群正在运行。在开始您的第一场音乐会之前，让我们等一下，拉开帷幕，看看Kubernetes在幕后是如何架构的，然后检查Minikube是如何在其虚拟机内将其各个组件粘合在一起的。
- en: 'Kubernetes has several core components that make the wheels of the machine
    turn. They are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes有几个核心组件，使机器的轮子转动。它们如下：
- en: API server
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API服务器
- en: etcd
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: etcd
- en: Controller manager
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器管理器
- en: Scheduler
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度器
- en: Kubelet
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubelet
- en: These components are critical for the functioning of a Kubernetes cluster.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件对于Kubernetes集群的运行至关重要。
- en: Besides these core components, you would deploy your applications in containers,
    which are bundled together as pods. We will learn more about pods in *Chapter
    5*, *Pods*. These pods, and several other resources, are defined by something
    called API objects.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些核心组件，您将在容器中部署您的应用程序，这些应用程序被捆绑在一起作为pod。我们将在*第5章* *Pods*中更多地了解pod。这些pod和其他几个资源是由称为API对象的东西定义的。
- en: An **API object** describes how a certain resource should be honored in Kubernetes.
    We usually define API objects using a human-readable manifest file, and then use
    a tool (such as kubectl) to parse it and hand it over to a Kubernetes API server.
    Kubernetes then tries to create the resource specified in the object and match
    its state to the desired state in the object definition, as mentioned in the manifest
    file. Next, we will walk you through how these components are organized and behave
    in a single-node cluster created by Minikube.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**API对象**描述了在Kubernetes中应该如何尊重某个资源。我们通常使用人类可读的清单文件来定义API对象，然后使用工具（如kubectl）来解析它并将其交给Kubernetes
    API服务器。然后，Kubernetes尝试创建对象中指定的资源，并将其状态与清单文件中指定的期望状态匹配。接下来，我们将带您了解Minikube创建的单节点集群中这些组件是如何组织和行为的。'
- en: 'Minikube provides a command called `minikube ssh` that''s used to gain SSH
    access from the host machine (in our machine, it''s the physical machine running
    Ubuntu 20.04) to the `minikube` virtual machine, which serves as the sole node
    in our Kubernetes cluster. Let''s see how that works:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube提供了一个名为`minikube ssh`的命令，用于从主机（在我们的机器上，它是运行Ubuntu 20.04的物理机）到`minikube`虚拟机的SSH访问，后者作为我们Kubernetes集群中唯一的节点。让我们看看它是如何工作的：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You will see the following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![Figure 2.5: Accessing the Minikube VM via SSH'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5：通过SSH访问Minikube虚拟机'
- en: '](image/B14870_02_05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_05.jpg)'
- en: 'Figure 2.5: Accessing the Minikube VM via SSH'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：通过SSH访问Minikube虚拟机
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All the commands that will be shown later in this section are presumed to have
    been run inside the Minikube VM, after running `minikube ssh`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中将显示的所有命令都假定已在Minikube虚拟机内运行`minikube ssh`之后运行。
- en: Container technology brings the convenience of encapsulating your application.
    Minikube is no exception – it leverages containers to glue the Kubernetes components
    together. In the Minikube VM, Docker is pre-installed so that it can manage the
    core Kubernetes components. You can take a look at this by running `docker ps`;
    however, the result may be overwhelming as it includes all the running containers
    – both the core Kubernetes components and add-ons, as well as all the columns
    – which will output a very large table.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术带来了封装应用程序的便利。Minikube也不例外 - 它利用容器将Kubernetes组件粘合在一起。在Minikube虚拟机中，Docker预先安装，以便它可以管理核心Kubernetes组件。您可以通过运行`docker
    ps`来查看这一点；但是，结果可能会让人不知所措，因为它包括所有正在运行的容器 - 包括核心Kubernetes组件和附加组件，以及所有列 - 这将输出一个非常大的表格。
- en: 'To simplify the output and make it easier to read, we will pipe the output
    from `docker ps` into two other Bash commands:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化输出并使其更易于阅读，我们将把`docker ps`的输出传输到另外两个Bash命令中：
- en: '`grep -v pause`: This will filter the results by not displaying the "sandbox"
    containers.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`grep -v pause`：这将通过不显示“沙盒”容器来过滤结果。'
- en: Without `grep -v pause`, you would find that each container is "paired" with
    a "sandbox" container (in Kubernetes, it's implemented as a `pause` image). This
    is because, as mentioned in the previous chapter, Linux containers can be associated
    (or isolated) by joining the same (or different) Linux namespace. In Kubernetes,
    a "sandbox" container is used to bootstrap a Linux namespace, and then the containers
    that run the real application are able to join that namespace. Finer details about
    how all this works under the hood have been left out of scope for the sake of
    brevity.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`grep -v pause`，您会发现每个容器都与一个“沙盒”容器（在Kubernetes中，它被实现为`pause`镜像）“配对”。这是因为，如前一章所述，Linux容器可以通过加入相同（或不同）的Linux命名空间来关联（或隔离）。在Kubernetes中，“沙盒”容器用于引导Linux命名空间，然后运行真实应用程序的容器可以加入该命名空间。为了简洁起见，关于所有这些是如何在幕后工作的细节已被忽略。
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If not specified explicitly, the term "namespace" is used interchangeably with
    "Kubernetes namespace" across this book. In terms of "Linux namespace", "Linux"
    would not be omitted to avoid confusion.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有明确指定，本书中术语“命名空间”与“Kubernetes命名空间”可以互换使用。在“Linux命名空间”方面，“Linux”不会被省略以避免混淆。
- en: '`awk ''{print $NF}''`: This will only print the last column with a container
    name.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`awk ''{print $NF}''`：这将只打印最后一列的容器名称。'
- en: 'Thus, the final command is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终命令如下：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should see the following output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 2.6: Getting the list of containers by running the Minikube VM'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6：通过运行Minikube VM获取容器列表'
- en: '](image/B14870_02_06.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_06.jpg)'
- en: 'Figure 2.6: Getting the list of containers by running the Minikube VM'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：通过运行Minikube VM获取容器列表
- en: The highlighted containers shown in the preceding screenshot are basically the
    core components of Kubernetes. We'll discuss each of these in detail in the following
    sections.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中显示的突出显示的容器基本上是Kubernetes的核心组件。我们将在接下来的章节中详细讨论每一个。
- en: etcd
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: etcd
- en: A distributed system may face various kinds of failures (network, storage, and
    so on) at any moment. To ensure it still works properly when failures arise, critical
    cluster metadata and state must be stored in a reliable way.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统可能在任何时刻面临各种故障（网络、存储等）。为了确保在出现故障时仍能正常工作，关键的集群元数据和状态必须以可靠的方式存储。
- en: Kubernetes abstracts the cluster metadata and state as a series of API objects.
    For example, the node API object represents a Kubernetes worker node's specification,
    as well as its latest status.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes将集群元数据和状态抽象为一系列API对象。例如，节点API对象代表了Kubernetes工作节点的规范，以及其最新状态。
- en: Kubernetes uses **etcd** as the backend key-value database to persist the API
    objects during the life cycle of a Kubernetes cluster. It is important to note
    that nothing (internal cluster resources or external clients) is allowed to talk
    to etcd without going through the API server. Any updates to or requests from
    etcd are made only via calls to the API server.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用**etcd**作为后端键值数据库，在Kubernetes集群的生命周期中持久化API对象。重要的是要注意，没有任何东西（内部集群资源或外部客户端）被允许直接与etcd通信，而必须通过API服务器。对etcd的任何更新或请求都只能通过对API服务器的调用来进行。
- en: In practice, etcd is usually deployed with multiple instances to ensure the
    data is persisted in a secure and fault-tolerant manner.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，etcd通常部署多个实例，以确保数据以安全和容错的方式持久化。
- en: API Server
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API服务器
- en: The API server allows standard APIs to access Kubernetes API objects. It is
    the only component that talks to backend storage (etcd).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: API服务器允许标准API访问Kubernetes API对象。它是唯一与后端存储（etcd）通信的组件。
- en: Additionally, by leveraging the fact that it is the single point of contact
    for communicating to etcd, it provides a convenient interface for clients to "watch"
    any API objects that they may be interested in. Once the API object has been created,
    updated, or deleted, the client that is "watching" will get instant notifications
    so they can act upon those changes. The "watching" client is also known as the
    "controller", which has become a very popular entity that's used in both built-in
    Kubernetes objects and Kubernetes extensions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过利用它作为与etcd通信的唯一接触点，它为客户端提供了一个方便的接口，以“监视”它们可能感兴趣的任何API对象。一旦API对象被创建、更新或删除，正在“监视”的客户端将立即收到通知，以便他们可以对这些更改采取行动。正在“监视”的客户端也被称为“控制器”，它已经成为内置Kubernetes对象和Kubernetes扩展中广受欢迎的实体。
- en: Note
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will learn more about the API server in *Chapter 4*, *How to Communicate
    with Kubernetes* *(API Server)*, and about controllers in *Chapter 7*, *Kubernetes
    Controllers*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在*第4章*“如何与Kubernetes通信”（API服务器）中了解更多关于API服务器的信息，并在*第7章*“Kubernetes控制器”中了解有关控制器的信息。
- en: Scheduler
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调度器
- en: The scheduler is responsible for distributing the incoming workloads to the
    most suitable node. The decision regarding distribution is made by the scheduler's
    understanding of the whole cluster, as well as a series of scheduling algorithms.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 调度程序负责将传入的工作负载分配给最合适的节点。关于分配的决定是由调度程序对整个集群的理解以及一系列调度算法来做出的。
- en: Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will learn more about the scheduler in *Chapter 17*, *Advanced Scheduling
    in Kubernetes*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在《第17章》《Kubernetes高级调度》中了解更多关于调度程序的信息。
- en: Controller Manager
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器管理器
- en: As we mentioned earlier in the *API Server* subsection, the API server exposes
    ways to "watch" almost any API object and notify the watchers about the changes
    in the API objects being watched.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在《API服务器》小节中提到的，API服务器公开了几乎任何API对象的“监视”方式，并通知观察者有关正在观察的API对象的更改。
- en: It works pretty much like a Publisher-Subscriber pattern. The controller manager
    acts as a typical subscriber and watches the only API objects that it is interested
    in, and then attempts to make appropriate changes to move the current state toward
    the desired state described in the object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式几乎与发布者-订阅者模式相似。控制器管理器充当典型的订阅者，监视它感兴趣的唯一API对象，然后尝试进行适当的更改，以将当前状态移向对象中描述的期望状态。
- en: For example, if it gets an update from the API server saying that an application
    claims two replicas, but right now there is only one living in the cluster, it
    will create the second one to make the application adhere to its desired replica
    number. The reconciliation process keeps running across the controller manager's
    life cycle to ensure that all applications stay in their expected state.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果它从API服务器那里得到一个更新，说一个应用程序要求两个副本，但是现在集群中只有一个副本，它将创建第二个副本，以使应用程序符合其期望的副本数量。协调过程在控制器管理器的生命周期中持续运行，以确保所有应用程序保持在预期状态。
- en: The controller manager aggregates various kinds of controllers to honor the
    semantics of API objects, such as Deployments and Services, which we will introduce
    later in this chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器管理器聚合各种类型的控制器，以遵守API对象的语义，例如部署和服务，我们将在本章后面介绍。
- en: Where Is the kubelet?
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kubelet在哪里？
- en: Note that etcd, the API server, the scheduler, and the controller manager comprise
    the control plane of Kubernetes. A machine that runs these components is called
    a master node. The kubelet, on the other hand, is deployed on each worker machine.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，etcd、API服务器、调度程序和控制器管理器组成了Kubernetes的控制平面。运行这些组件的机器称为主节点。另一方面，kubelet部署在每台工作节点上。
- en: In our single-node Minikube cluster, the kubelet is deployed on the same node
    that carries the control plane components. However, in most production environments,
    it is not deployed on any of the master nodes. We will learn more about production
    environments when we deploy a multi-node cluster in *Chapter 11*, *Build Your
    Own HA Cluster*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的单节点Minikube集群中，kubelet部署在携带控制平面组件的同一节点上。然而，在大多数生产环境中，它不会部署在任何主节点上。当我们在《第11章》《构建您自己的HA集群》中部署多节点集群时，我们将了解更多关于生产环境的信息。
- en: The kubelet primarily aims at talking to the underlying container runtime (for
    example, Docker, containerd, or cri-o) to bring up the containers and ensure that
    the containers are running as expected. Also, it's responsible for sending the
    status update back to the API server.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: kubelet主要是与底层容器运行时（例如Docker、containerd或cri-o）进行通信，以启动容器并确保容器按预期运行。此外，它负责将状态更新发送回API服务器。
- en: 'However, as shown in the preceding screenshot, the `docker ps` command doesn''t
    show anything named `kubelet`. To start, stop, or restart any software and make
    it auto-restart upon failure, usually, we need a tool to manage its life cycle.
    In Linux, systemd has that responsibility. In Minikube, the kubelet is managed
    by systemd and runs as a native binary instead of a Docker container. We can run
    the following command to check its status:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如前面的屏幕截图所示，`docker ps`命令并没有显示任何名为`kubelet`的内容。通常，为了启动、停止或重新启动任何软件并使其在失败时自动重新启动，我们需要一个工具来管理其生命周期。在Linux中，systemd负责这个责任。在Minikube中，kubelet由systemd管理，并作为本地二进制文件而不是Docker容器运行。我们可以运行以下命令来检查其状态：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You should see an output similar to the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '![Figure 2.7: Status of kubelet'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7：kubelet的状态'
- en: '](image/B14870_02_07.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_07.jpg)'
- en: 'Figure 2.7: Status of kubelet'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：kubelet的状态
- en: 'By default, the kubelet has the configuration for `staticPodPath` in its config
    file (which is stored at `/var/lib/kubelet/config.yaml`). kubelet is instructed
    to continuously watch the changes in files under that path, and each file under
    that path represents a Kubernetes component. Let''s understand what this means
    by first finding `staticPodPath` in the kubelet''s `config` file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，kubelet在其配置文件中（存储在`/var/lib/kubelet/config.yaml`）具有`staticPodPath`的配置。kubelet被指示持续监视该路径下文件的更改，该路径下的每个文件代表一个Kubernetes组件。让我们首先找到kubelet的`config`文件中的`staticPodPath`，以了解这意味着什么：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You should see the following output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s see the contents of this path:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个路径的内容：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You should see the following output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As shown in the list of files, the core components of Kubernetes are defined
    by objects that have a definition specified in YAML files. In the Minikube environment,
    in addition to managing the user-created pods, the kubelet also serves as a systemd
    equivalent in order to manage the life cycle of Kubernetes system-level components,
    such as the API server, the scheduler, the controller manager, and other add-ons.
    Once any of these YAML files is changed, the kubelet auto-detects that and updates
    the state of the cluster so that it matches the desired state defined in the updated
    YAML configuration.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如文件列表所示，Kubernetes的核心组件由在YAML文件中指定定义的对象定义。在Minikube环境中，除了管理用户创建的pod之外，kubelet还充当systemd的等效物，以管理Kubernetes系统级组件的生命周期，如API服务器、调度程序、控制器管理器和其他附加组件。一旦这些YAML文件中的任何一个发生变化，kubelet会自动检测到并更新集群的状态，使其与更新后的YAML配置中定义的期望状态相匹配。
- en: We will stop here without diving deeper into the design of Minikube. In addition
    to "static components", the kubelet is also the manager of "regular applications"
    to ensure that they're running as expected on the node and evicts pods according
    to the API specification or upon resource shortage.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里停下，不深入探讨Minikube的设计。除了“静态组件”之外，kubelet还是“常规应用程序”的管理者，以确保它们在节点上按预期运行，并根据API规范或资源短缺驱逐pod。
- en: kube-proxy
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kube-proxy
- en: kube-proxy appears in the output of the `docker ps` command, but it was not
    present at `/etc/kubernetes/manifests` when we explored that directory in the
    previous subsection. This implies its role – it's positioned more as an add-on
    component instead of a core one.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: kube-proxy出现在`docker ps`命令的输出中，但在我们在上一小节中探索该目录时，它并不存在于`/etc/kubernetes/manifests`中。这意味着它的角色——它更多地被定位为一个附加组件，而不是核心组件。
- en: kube-proxy is designed as a distributed network router that runs on every node.
    Its ultimate goal is to ensure that inbound traffic to a **Service** (this is
    an API object that we will introduce later) endpoint can be routed properly. Moreover,
    if multiple containers are serving one application, it is able to balance the
    traffic in a round-robin manner by leveraging the underlying Linux iptables/IPVS
    technology.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: kube-proxy被设计为在每个节点上运行的分布式网络路由器。它的最终目标是确保流入到Service（这是我们稍后将介绍的一个API对象）端点的流量能够正确路由。此外，如果多个容器提供一个应用程序，它可以通过利用底层的Linux
    iptables/IPVS技术以循环方式平衡流量。
- en: There are also some other add-ons such as CoreDNS, though we will skip those
    so that we can focus on the core components and get a high-level picture.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他附加组件，比如CoreDNS，但我们将跳过它们，以便我们可以专注于核心组件并获得高层次的图像。
- en: Note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes, kube-proxy and CoreDNS are also considered core components of a Kubernetes
    installation. To some extent, that's technically true as they're mandatory in
    most cases; otherwise, the Service API object won't work. However, in this book,
    we're leaning more toward categorizing them as "add-ons" as they focus on the
    implementation of one particular Kubernetes API resource instead of general workflow.
    Also, kube-proxy and CoreDNS are defined in `addon-manager.yaml.tmpl` instead
    of being portrayed on the same level as the other core Kubernetes components.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，kube-proxy和CoreDNS也被认为是Kubernetes安装的核心组件。在某种程度上，从技术上讲，这是正确的，因为它们在大多数情况下是必需的；否则，Service
    API对象将无法工作。然而，在本书中，我们更倾向于将它们归类为“附加组件”，因为它们侧重于实现特定的Kubernetes API资源，而不是一般的工作流程。此外，kube-proxy和CoreDNS是在`addon-manager.yaml.tmpl`中定义的，而不是被描绘在与其他核心Kubernetes组件同一级别。
- en: Kubernetes Architecture
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes架构
- en: 'In the previous section, we gained a first impression of the core Kubernetes
    components: etcd, the API server, the scheduler, the controller manager, and the
    kubelet. These components, plus other add-ons, comprise the Kubernetes architecture,
    which can be seen in the following diagram:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们对核心Kubernetes组件有了初步印象：etcd、API服务器、调度器、控制器管理器和kubelet。这些组件，加上其他附加组件，构成了Kubernetes架构，可以在以下图表中看到：
- en: '![Figure 2.8: Kubernetes architecture'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8：Kubernetes架构'
- en: '](image/B14870_02_08.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_08.jpg)'
- en: 'Figure 2.8: Kubernetes architecture'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：Kubernetes架构
- en: At this point, we won't look at each component in too much detail. However,
    at a high-level view, it's critical to understand how the components communicate
    with each other and why they're designed in that way.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们不会过多地查看每个组件。然而，在高层次上，理解组件如何相互通信以及它们为什么以这种方式设计是至关重要的。
- en: The first thing to understand is which components the API server can interact
    with. From the preceding diagram, we can easily tell that the API server can talk
    to almost every other component (except the container runtime, which is handled
    by the kubelet) and that it also serves to interact with end-users directly. This
    design makes the API server act as the "heart" of Kubernetes. Additionally, the
    API server also scrutinizes incoming requests and writes API objects into the
    backend storage (etcd). This, in other words, makes the API server the throttle
    of security control measures such as authentication, authorization, and auditing.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要理解的是API服务器可以与哪些组件进行交互。从前面的图表中，我们可以很容易地看出API服务器几乎可以与每个其他组件进行通信（除了容器运行时，由kubelet处理），它还可以直接与最终用户进行交互。这种设计使API服务器充当Kubernetes的“心脏”。此外，API服务器还会审查传入的请求，并将API对象写入后端存储（etcd）。换句话说，这使得API服务器成为安全控制措施（如身份验证、授权和审计）的节流阀。
- en: The second thing to understand is how the different Kubernetes components (except
    for the API server) interact with each other. It turns out that there is no explicit
    connection among them – the controller manager doesn't talk to the scheduler,
    nor does the kubelet talk to kube-proxy.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 理解的第二件事是不同的Kubernetes组件（除了API服务器）如何相互交互。事实证明它们之间没有明确的连接 - 控制器管理器不与调度程序交谈，kubelet也不与kube-proxy交谈。
- en: You read that right – they do need to work in coordination with each other to
    accomplish many functionalities, but they never directly talk to each other. Instead,
    they communicate implicitly via the API server. More precisely, they communicate
    by watching, creating, updating, or deleting corresponding API objects. This is
    also known as the controller/operator pattern.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 没错 - 他们确实需要协调工作来完成许多功能，但它们从不直接交谈。相反，它们通过API服务器隐式通信。更准确地说，它们通过观察、创建、更新或删除相应的API对象进行通信。这也被称为控制器/操作员模式。
- en: Container Network Interface
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器网络接口
- en: There are several networking aspects to take into consideration, such as how
    a pod communicates with its host machine's network interface, how a node communicates
    with other nodes, and, eventually, how a pod communicates with any pod across
    different nodes. As the network infrastructure differs vastly in the cloud or
    on-premises environments, Kubernetes chooses to solve those problems by defining
    a specification called the **Container Network Interface** (**CNI**). Different
    CNI providers can follow the same interface and implement their logic that adheres
    to the Kubernetes standards to ensure that the whole Kubernetes network works.
    We will revisit the idea of the CNI in *Chapter 11*, *Build Your Own HA Cluster*.
    For now, let's return to our discussion of how the different Kubernetes components
    work.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个网络方面需要考虑，比如一个pod如何与其主机的网络接口通信，一个节点如何与其他节点通信，最终一个pod如何与不同节点上的任何pod通信。由于云端或本地环境中的网络基础设施差异巨大，Kubernetes选择通过定义一个称为**容器网络接口**（**CNI**）的规范来解决这些问题。不同的CNI提供者可以遵循相同的接口并实现符合Kubernetes标准的逻辑，以确保整个Kubernetes网络运行。我们将在*第11章*，*构建您自己的HA集群*中重新讨论CNI的概念。现在，让我们回到讨论不同的Kubernetes组件如何工作。
- en: Later in this chapter, *Exercise 2.05*, *How Kubernetes Manages a Pod's Life
    Cycle*, will help you consolidate your understanding of this and clarify a few
    things, such as how the different Kubernetes components operate synchronously
    or asynchronously to ensure a typical Kubernetes workflow, and what would happen
    if one or more of these components malfunctions. The exercise will help you better
    understand the overall Kubernetes architecture. But before that, let's introduce
    our containerized application from the previous chapter to the Kubernetes world
    and explore a few benefits of Kubernetes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，*练习2.05*，*Kubernetes如何管理Pod的生命周期*，将帮助您巩固对此的理解，并澄清一些问题，比如不同的Kubernetes组件如何同步或异步地操作，以确保典型的Kubernetes工作流程，以及如果其中一个或多个组件发生故障会发生什么。这个练习将帮助您更好地理解整体的Kubernetes架构。但在那之前，让我们把我们在上一章中介绍的容器化应用引入到Kubernetes世界中，并探索Kubernetes的一些好处。
- en: Migrating Containerized Application to Kubernetes
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将容器化应用迁移到Kubernetes
- en: In the previous chapter, we built a simple HTTP server called `k8s-for-beginners`,
    and it runs as a Docker container. It works perfectly for a sample application.
    However, what if you have to manage thousands of containers, and coordinate and
    schedule them properly? How can you upgrade a service without downtime? How do
    you keep a service healthy upon unexpected failure? These problems exceed the
    abilities of a system that simply uses containers alone. What we need is a platform
    that can orchestrate, as well as manage, our containers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了一个名为`k8s-for-beginners`的简单HTTP服务器，并且它作为一个Docker容器运行。对于一个示例应用程序来说，它运行得很完美。但是，如果你需要管理成千上万个容器，并且正确协调和调度它们，该怎么办？你如何在没有停机的情况下升级一个服务？在意外故障时如何保持服务的健康？这些问题超出了仅仅使用容器的系统的能力。我们需要的是一个可以编排和管理我们的容器的平台。
- en: We have told you that Kubernetes is the solution that we need. Next, we will
    walk you through a series of exercises regarding how to orchestrate and run containers
    in Kubernetes using a Kubernetes native approach.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经告诉过你，Kubernetes是我们需要的解决方案。接下来，我们将带你进行一系列关于如何使用Kubernetes本地方法编排和运行容器的练习。
- en: Pod Specification
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod规范
- en: A straightforward thought is that we wish to see what the equivalent API call
    or command to run a container in Kubernetes is. As explained in *Chapter 1*, *Introduction
    to Kubernetes and Containers*, a container can join another container's namespace
    so that they can access each other's resources (for example, network, storage,
    and so on) without additional overhead. In the real world, some applications may
    need several containers working closely, either in parallel or in a particular
    order (the output of one will be processed by another). Also, some generic containers
    (for example, logging agent, network throttling agent, and so on) may need to
    work closely with their target containers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一个直观的想法是，我们希望看到在Kubernetes中运行容器的等效API调用或命令是什么。正如*第1章* *Kubernetes和容器简介*中所解释的，一个容器可以加入另一个容器的命名空间，以便它们可以访问彼此的资源（例如网络、存储等），而无需额外的开销。在现实世界中，一些应用程序可能需要多个容器密切合作，无论是并行工作还是按特定顺序工作（一个的输出将由另一个处理）。此外，一些通用容器（例如日志代理、网络限速代理等）可能需要与它们的目标容器密切合作。
- en: Since an application may often need several containers, a container is not the
    minimum operational unit in Kubernetes; instead, it introduces a concept called
    **pods** to bundle one or multiple containers. Kubernetes provides a series of
    specifications to describe how this pod is supposed to be, including several specifics
    such as images, resource requests, startup commands, and more. To send this pod
    spec to Kubernetes, particularly to the Kubernetes API server, we're going to
    use kubectl.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个应用程序通常可能需要多个容器，容器不是Kubernetes中的最小操作单元；相反，它引入了一个称为**pods**的概念来捆绑一个或多个容器。Kubernetes提供了一系列规范来描述这个pod应该是什么样的，包括诸如镜像、资源请求、启动命令等几个具体的内容。为了将这个pod规范发送给Kubernetes，特别是Kubernetes
    API服务器，我们将使用kubectl。
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We will learn more about pods in *Chapter 5*, *Pods*, but we will use them
    in this chapter for the purpose of simple demonstrations. You can refer to the
    complete list of available pod specifications at this link: [https://godoc.org/k8s.io/api/core/v1#PodSpec](https://godoc.org/k8s.io/api/core/v1#PodSpec).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第5章* *Pods*中了解更多关于Pods的内容，但在本章中，我们将使用它们进行简单演示。您可以在此链接查看可用Pod规范的完整列表：[https://godoc.org/k8s.io/api/core/v1#PodSpec](https://godoc.org/k8s.io/api/core/v1#PodSpec)。
- en: Next, let's learn how to run a single container in Kubernetes by composing the
    pod spec file (also called the specification, manifest, config, or configuration
    file). In Kubernetes, you can use YAML or JSON to write this specification file,
    though YAML is commonly used since it is more human-readable and editable.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何通过编写 pod 规范文件（也称为规范、清单、配置或配置文件）在 Kubernetes 中运行单个容器。在 Kubernetes
    中，您可以使用 YAML 或 JSON 来编写此规范文件，尽管 YAML 通常更常用，因为它更易读和可编辑。
- en: 'Consider the following YAML spec for a very simple pod:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下用于一个非常简单的 pod 的 YAML 规范：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s go through the different fields briefly:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地浏览一下不同的字段：
- en: '`kind` tells Kubernetes which type of object you want to create. Here, we are
    creating a `Pod`. In later chapters, you will see many other kinds, such as Deployment,
    StatefulSet, ConfigMap, and so on.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind` 告诉 Kubernetes 您想要创建哪种类型的对象。在这里，我们正在创建一个 `Pod`。在后面的章节中，您将看到许多其他类型，比如
    Deployment、StatefulSet、ConfigMap 等等。'
- en: '`apiVersion` specifies a particular version of an API object. Different versions
    may behave a bit differently.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiVersion` 指定 API 对象的特定版本。不同版本可能会有一些不同的行为。'
- en: '`metadata` includes some attributes that can be used to uniquely identify the
    pod, such as name and namespace. If we don''t specify a namespace, it goes in
    the `default` namespace.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata` 包括一些属性，可以用来唯一标识 pod，比如名称和命名空间。如果我们不指定命名空间，它就会放在 `default` 命名空间中。'
- en: '`spec` contains a series of fields describing the pod. In this example, there
    is one container that has its image URL and name specified.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec` 包含一系列描述 pod 的字段。在这个例子中，有一个容器，它有指定的镜像 URL 和名称。'
- en: Pods are one of the simplest Kubernetes objects to deploy, so we will use them
    to learn how to deploy objects using YAML manifests in the following exercise.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 是部署的最简单的 Kubernetes 对象之一，因此我们将使用它们来学习如何使用 YAML 清单部署对象。
- en: Applying a YAML Manifest
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用 YAML 清单
- en: Once we have a YAML manifest ready, we can use `kubectl apply -f <yaml file>`
    or `kubectl create -f <yaml file>` to instruct the API server to persist the API
    resources defined in this manifest. When you create a pod from scratch for the
    first time, it doesn't make much difference which of the two commands you use.
    However, we may often need to modify the YAML (let's say, for example, if we want
    to upgrade the image version) and reapply it. If we use the `kubectl create` command,
    we have to delete and recreate it. However, with the `kubectl apply` command,
    we can rerun the same command and the delta change will be calculated and applied
    automatically by Kubernetes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好一个 YAML 清单，我们可以使用 `kubectl apply -f <yaml file>` 或 `kubectl create -f
    <yaml file>` 来指示 API 服务器持久化在此清单中定义的 API 资源。当您首次从头开始创建一个 pod 时，您使用这两个命令之一并没有太大的区别。然而，我们经常需要修改
    YAML（比如说，如果我们想要升级镜像版本），然后重新应用它。如果我们使用 `kubectl create` 命令，我们必须删除并重新创建它。但是，使用 `kubectl
    apply` 命令，我们可以重新运行相同的命令，Kubernetes 会自动计算并应用增量变化。
- en: This is very convenient from an operational point of view. For example, if we
    use some form of automation, it is much simpler to repeat the same command. So,
    we will use `kubectl apply` across the following exercise, regardless of whether
    it's the first time it's being applied or not.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从运维的角度来看，这非常方便。例如，如果我们使用某种形式的自动化，重复相同的命令会更简单。因此，我们将在接下来的练习中使用 `kubectl apply`，无论是第一次应用还是不是。
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A detailed on kubectl can be obtained in *Chapter 4*, *How to Communicate with
    Kubernetes (API Server)*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 *第 4 章* *如何与 Kubernetes（API 服务器）通信* 中获取有关 kubectl 的详细信息。
- en: 'Exercise 2.02: Running a Pod in Kubernetes'
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.02：在 Kubernetes 中运行一个 Pod
- en: 'In the previous exercise, we started up Minikube and looked at the various
    Kubernetes components running as pods. Now, in this exercise, we shall deploy
    our pod. Follow these steps to complete this exercise:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们启动了Minikube，并查看了各种作为pod运行的Kubernetes组件。现在，在这个练习中，我们将部署我们的pod。按照以下步骤完成这个练习：
- en: Note
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you have been trying out the commands from the *Kubernetes Components Overview*
    section, don't forget to leave the SSH session by using the `exit` command before
    beginning this exercise. Unless otherwise specified, all commands using `kubectl`
    should run on the host machine and not inside the Minikube VM.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直在尝试*Kubernetes组件概述*部分的命令，请不要忘记在开始这个练习之前使用`exit`命令离开SSH会话。除非另有说明，所有使用`kubectl`的命令应该在主机上运行，而不是在Minikube
    VM内部。
- en: 'In Kubernetes, we use a spec file to describe an API object such as a pod.
    As mentioned earlier, we will stick to YAML as it is more human-readable and editable
    friendly. Create a file named `k8s-for-beginners-pod.yaml` (using any text editor
    of your choice) with the following content:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kubernetes中，我们使用一个spec文件来描述一个API对象，比如一个pod。如前所述，我们将坚持使用YAML，因为它更易读和易编辑。创建一个名为`k8s-for-beginners-pod.yaml`的文件（使用你选择的任何文本编辑器），内容如下：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please replace the image path in the last line of the preceding YAML file with
    the path to your image that you created in the previous chapter.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请用前面YAML文件中最后一行的路径替换成您在上一章中创建的图像的路径。
- en: 'On the host machine, run the following command to create this pod:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主机上运行以下命令来创建这个pod：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should see the following output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can use the following command to check the pod''s status:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令来检查pod的状态：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You should see the following response:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: By default, `kubectl get pod` will list all the pods using a table format. In
    the preceding output, we can see the `k8s-for-beginners` pod is running properly
    and that it has one container that is ready (`1/1`). Moreover, kubectl provides
    an additional flag called `-o` so we can adjust the output format. For example,
    `-o yaml` or `-o json` will return the full output of the pod API object in YAML
    or JSON format, respectively, as it's stored version in Kubernetes' backend storage
    (etcd).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`kubectl get pod`将以表格格式列出所有的pod。在前面的输出中，我们可以看到`k8s-for-beginners` pod正常运行，并且它有一个容器是就绪的（`1/1`）。此外，kubectl提供了一个额外的标志叫做`-o`，这样我们可以调整输出格式。例如，`-o
    yaml`或`-o json`将分别以YAML或JSON格式返回pod API对象的完整输出，因为它存储在Kubernetes的后端存储（etcd）中。
- en: 'You can use the following command to get more information about the pod:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令获取有关pod的更多信息：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You should see the following output:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 2.9: Getting more information about pods'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9：获取有关pod的更多信息'
- en: '](image/B14870_02_09.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_09.jpg)'
- en: 'Figure 2.9: Getting more information about pods'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：获取有关pod的更多信息
- en: As you can see, the output is still in the table format and we get additional
    information such as `IP` (the internal pod IP) and `NODE` (which node the pod
    is running on).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，输出仍然是表格格式，我们得到了额外的信息，比如`IP`（内部pod IP）和`NODE`（pod所在的节点）。
- en: 'You can get the list of nodes in our cluster by running the following command:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令来获取我们集群中节点的列表：
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You should see the following response:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The IP listed in *Figure 2.9* refers to the internal IP Kubernetes assigned
    for this pod, and it''s used for pod-to-pod communication, not for routing external
    traffic to pods. Hence, if you try to access this IP from outside the cluster,
    you will get nothing. You can try that using the following command from the host
    machine, which will fail:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*图2.9*中列出的IP是Kubernetes为此pod分配的内部IP，用于pod之间的通信，而不是用于将外部流量路由到pod。因此，如果您尝试从集群外部访问此IP，您将得到空白。您可以尝试使用以下命令从主机上执行，但会失败：'
- en: '[PRE38]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to change `172.17.0.4` to the value you get for your environment in
    *step 4*, as seen in *Figure 2.9*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请记得将`172.17.0.4`更改为您在*步骤4*中获得的值，如*图2.9*所示。
- en: 'The `curl` command will just hang and return nothing, as shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl`命令将会挂起并返回空白，如下所示：'
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You will need to press *Ctrl* + *C* to abort it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要按下*Ctrl* + *C*来中止它。
- en: 'In most cases, end-users don''t need to interact with the internal pod IP.
    However, just for observation purposes, let''s SSH into the Minikube VM:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在大多数情况下，最终用户不需要与内部pod IP进行交互。但是，仅出于观察目的，让我们SSH进入Minikube VM：
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You will see the following response in the terminal:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在终端中看到以下响应：
- en: '![Figure 2.10: Accessing the Minikube VM via SSH'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.10：通过SSH访问Minikube VM'
- en: '](image/B14870_02_10.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_10.jpg)'
- en: 'Figure 2.10: Accessing the Minikube VM via SSH'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：通过SSH访问Minikube VM
- en: 'Now, try calling the IP from inside the Minikube VM to verify that it works:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试从Minikube VM内部调用IP以验证其是否有效：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You should get a successful response:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会收到一个成功的响应：
- en: '[PRE42]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With this, we have successfully deployed our application in a pod on the Kubernetes
    cluster. We can confirm that it is working since we get a response when we call
    the application from inside the cluster. Now, you may end the Minikube SSH session
    using the `exit` command.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经成功在Kubernetes集群上部署了我们的应用程序。我们可以确认它正在工作，因为当我们从集群内部调用应用程序时，我们会得到一个响应。现在，您可以使用`exit`命令结束Minikube
    SSH会话。
- en: Service Specification
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Service规范
- en: The last part of the previous section proves that network communication works
    great among different components inside the cluster. But in the real world, you
    would not expect users of your application to gain SSH access into your cluster
    to use your applications. So, you would want your application to be accessed externally.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节的最后部分证明了集群内不同组件之间的网络通信非常顺畅。但在现实世界中，您不希望应用程序的用户获得SSH访问权限来使用您的应用程序。因此，您希望您的应用程序可以从外部访问。
- en: To facilitate just that, Kubernetes provides a concept called a **Service**
    to abstract the network access to your application's pods. A Service acts as a
    network proxy to accept network traffic from external users and then distributes
    it to internal pods. However, there should be a way to describe the association
    rule between the Service and the corresponding pods. Kubernetes uses labels, which
    are defined in the pod definitions, and label selectors, which are defined in
    the Service definition, to describe this relationship.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，Kubernetes提供了一个称为**Service**的概念，用于抽象应用程序pod的网络访问。Service充当网络代理，接受来自外部用户的网络流量，然后将其分发到内部pod。但是，应该有一种方法来描述Service和相应pod之间的关联规则。Kubernetes使用标签（在pod定义中定义）和标签选择器（在Service定义中定义）来描述这种关系。
- en: Note
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will learn more about labels and label selectors in *Chapter 6*, *Labels
    and Annotations*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在*第6章*，*标签和注释*中了解更多关于标签和标签选择器的内容。
- en: 'Let''s consider the following sample spec for a Service:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下Service的样本规范：
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Similar to a pod spec, here, we define `kind` and `apiVersion`, while `name`
    is defined under the `metadata` field. Under the `spec` field, there are several
    critical fields to take note of:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Pod 规范类似，在这里，我们定义了 `kind` 和 `apiVersion`，而 `name` 是在 `metadata` 字段下定义的。在 `spec`
    字段下，有几个关键字段需要注意：
- en: '`selector` defines the labels to be selected to match a relationship with the
    corresponding pods, which, as you will see in the following exercise, are supposed
    to be labeled properly.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selector` 定义要选择的标签，以便与相应的 pod 匹配关系，正如您将在接下来的练习中看到的，这些标签应该被正确地标记。'
- en: '`type` defines the type of Service. If not specified, the default type is `ClusterIP`,
    which means it''s only used within the cluster, that is, internally. Here, we
    specify it as `NodePort`. This means the Service will expose a port in each node
    of the cluster and associate the port with the corresponding pods. Another well-known
    type is called `LoadBalancer`, which is typically not implemented in a vanilla
    Kubernetes offering. Instead, Kubernetes delegates the implementation to each
    cloud provider, such as GKE, EKS, and so on.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type` 定义了服务的类型。如果未指定，默认类型为 `ClusterIP`，这意味着它仅在集群内部使用。在这里，我们将其指定为 `NodePort`。这意味着服务将在集群的每个节点上公开一个端口，并将该端口与相应的
    pod 关联起来。另一个众所周知的类型称为 `LoadBalancer`，通常不在原始的 Kubernetes 提供中实现。相反，Kubernetes 将实现委托给每个云提供商，例如
    GKE、EKS 等。'
- en: '`ports` include a series of `port` fields, each with a `targetPort` field.
    The `targetPort` field is the actual port that''s exposed by the destination pod.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports` 包括一系列 `port` 字段，每个字段都有一个 `targetPort` 字段。`targetPort` 字段是目标 pod 公开的实际端口。'
- en: Thus, the Service can be accessed internally via `<service ip>:<port>`. Now,
    for example, if you have an NGINX pod running internally and listening on port
    8080, then you should define `targetPort` as `8080`. You can specify any arbitrary
    number for the `port` field, such as `80` in this case. Kubernetes will set up
    and maintain the mapping between `<service IP>:<port>` and `<pod IP>:<targetPort>`.
    In the following exercise, we will learn how to access the Service from outside
    the cluster and bring external traffic inside the cluster via the Service.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以通过 `<service ip>:<port>` 内部访问服务。现在，例如，如果您有一个在内部运行并在端口 8080 上侦听的 NGINX pod，则应将
    `targetPort` 定义为 `8080`。您可以在此案例中为 `port` 字段指定任意数字，例如 `80`。Kubernetes 将建立并维护 `<service
    IP>:<port>` 与 `<pod IP>:<targetPort>` 之间的映射。在接下来的练习中，我们将学习如何从集群外访问服务，并通过服务将外部流量带入集群。
- en: In the following exercise, we will define Service manifests and create them
    using `kubectl apply` commands. You will learn that the common pattern for resolving
    problems in Kubernetes is to find out the proper API objects, then compose the
    detailed specs using YAML manifests, and finally create the objects to bring them
    into effect.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将定义服务清单并使用 `kubectl apply` 命令创建它们。您将了解到在 Kubernetes 中解决问题的常见模式是找到适当的
    API 对象，然后使用 YAML 清单组合详细规范，最后创建对象以使其生效。
- en: 'Exercise 2.03: Accessing a Pod via a Service'
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.03：通过服务访问 Pod
- en: 'In the previous exercise, we observed that an internal pod IP doesn''t work
    for anyone outside the cluster. In this exercise, we will create Services that
    will act as connectors to map the external requests to the destination pods so
    that we can access the pods externally without entering the cluster. Follow these
    steps to complete this exercise:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，我们观察到内部 pod IP 对于集群外部的任何人都不起作用。在这个练习中，我们将创建服务，这些服务将充当连接器，将外部请求映射到目标
    pod，以便我们可以在不进入集群的情况下外部访问 pod。按照以下步骤完成这个练习：
- en: 'Firstly, let''s tweak the pod spec from *Exercise 2.02*, *Running a Pod in
    Kubernetes*, to apply some labels. Modify the contents of the `k8s-for-beginners-pod1.yaml`
    file, as follows:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们调整来自 *练习 2.02*，*在 Kubernetes 中运行一个 Pod* 的 pod 规范，以应用一些标签。修改 `k8s-for-beginners-pod1.yaml`
    文件的内容如下：
- en: '[PRE44]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here, we added a label pair, `tier: frontend`, under the `labels` field.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们在 `labels` 字段下添加了一个标签对，`tier: frontend`。'
- en: 'Because the pod name remains the same, let''s rerun the `apply` command so
    that Kubernetes knows that we''re trying to update the pod''s spec, instead of
    creating a new pod:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为 pod 名称保持不变，让我们重新运行 `apply` 命令，这样 Kubernetes 就知道我们正在尝试更新 pod 的规范，而不是创建一个新的
    pod：
- en: '[PRE45]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You should see the following response:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Behind the scenes, for the `kubectl apply` command, kubectl generates the difference
    of the specified YAML and the stored version in the Kubernetes server-side storage
    (that is, etcd). If the request is valid (that is, we have not made any errors
    in the specification format or the command), kubectl will send an HTTP patch to
    the Kubernetes API server. Hence, only the delta changes will be applied. If you
    look at the message that's returned, you'll see it says `pod/k8s-for-beginners
    configured` instead of `created`, so we can be sure it's applying the delta changes
    and not creating a new pod.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `kubectl apply` 命令背后，kubectl 生成指定 YAML 和 Kubernetes 服务器端存储（即 etcd）中存储版本的差异。如果请求有效（即，我们在规范格式或命令中没有出现任何错误），kubectl
    将向 Kubernetes API 服务器发送 HTTP 补丁。因此，只会应用增量更改。如果查看返回的消息，你会看到它说 `pod/k8s-for-beginners
    configured` 而不是 `created`，所以我们可以确定它正在应用增量更改，而不是创建一个新的 pod。
- en: 'You can use the following command to explicitly display the labels that have
    been applied to existing pods:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用以下命令显式显示已应用到现有 pod 的标签：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You should see the following response:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now that the pod has the `tier: frontend` attribute, we''re ready to create
    a Service and link it to the pods.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，pod 具有 `tier: frontend` 属性，我们准备创建一个服务并将其链接到这些 pod。'
- en: 'Create a file named `k8s-for-beginners-svc.yaml` with the following content:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `k8s-for-beginners-svc.yaml` 的文件，内容如下：
- en: '[PRE49]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, let''s create the Service using the following command:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令创建服务：
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You should see the following response:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Use the `get` command to return the list of created Services and confirm whether
    our Service is online:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `get` 命令返回已创建服务的列表，并确认我们的服务是否在线：
- en: '[PRE52]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You should see the following response:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '![Figure 2.11: Getting the list of Services'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.11：获取服务列表'
- en: '](image/B14870_02_11.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_11.jpg)'
- en: 'Figure 2.11: Getting the list of Services'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11：获取服务列表
- en: So, you may have noticed that the `PORT(S)` column outputs `80:32571/TCP`. Port
    `32571` is an auto-generated port that's exposed on every node, which is done
    intentionally so that external users can access it. Now, before moving on to the
    next step, exit the SSH session.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你可能已经注意到 `PORT(S)` 列输出 `80:32571/TCP`。端口 `32571` 是在每个节点上暴露的自动生成的端口，这是有意为之，以便外部用户可以访问它。现在，在进行下一步之前，退出
    SSH 会话。
- en: 'Now, we have the "external port" as `32571`, but we still need to find the
    external IP. Minikube provides a utility we can use to easily access the `k8s-for-beginners`
    Service:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有了“外部端口”为 `32571`，但我们仍然需要找到外部 IP。Minikube 提供了一个实用程序，我们可以使用它轻松访问 `k8s-for-beginners`
    服务：
- en: '[PRE53]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You should see a response that looks similar to the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 应该看到类似以下的响应：
- en: '![Figure 2.12: Getting the URL and port to access the NodePort Service'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.12：获取访问 NodePort 服务的 URL 和端口'
- en: '](image/B14870_02_12.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_12.jpg)'
- en: 'Figure 2.12: Getting the URL and port to access the NodePort Service'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12：获取访问 NodePort 服务的 URL 和端口
- en: Depending on your environment, this may also automatically open a browser web
    page so you can access the Service. From the URL, you will be able to see that
    the Service port is `32571`. The external IP is actually the IP of the Minikube
    VM.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的环境，这可能还会自动打开一个浏览器页面，以便您可以访问服务。从URL中，您将能够看到服务端口是`32571`。外部IP实际上是Minikube
    VM的IP。
- en: 'You can also access our application from outside the cluster via the command
    line:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以通过命令行从集群外部访问我们的应用：
- en: '[PRE54]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You should see the following response:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE55]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As a summary, in this exercise, we created a `NodePort` Service to enable external
    users to access the internal pods without entering the cluster. Under the hood,
    there are several layers of traffic transitions that make this happen:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在这个练习中，我们创建了一个`NodePort`服务，以便外部用户可以访问内部的Pod，而不需要进入集群。在幕后，有几个层次的流量转换使这成为可能：
- en: The first layer is from the external user to the machine IP at the auto-generated
    random port (3XXXX).
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一层是从外部用户到机器IP的自动生成的随机端口（3XXXX）。
- en: The second layer is from the random port (3XXXX) to the Service IP (10.X.X.X)
    at port `80`.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二层是从随机端口（3XXXX）到服务IP（10.X.X.X）的端口`80`。
- en: The third layer is from the Service IP (10.X.X.X) ultimately to the pod IP at
    port `8080`.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三层是从服务IP（10.X.X.X）最终到端口`8080`的Pod IP。
- en: 'The following is a diagram illustrating these interactions:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个说明这些交互的图表：
- en: '![Figure 2.13: Routing traffic from a user outside the cluster'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.13：将来自集群外部用户的流量路由到运行我们应用的Pod'
- en: to the pod running our application
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 到运行我们应用的Pod
- en: '](image/B14870_02_13.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_13.jpg)'
- en: 'Figure 2.13: Routing traffic from a user outside the cluster to the pod running
    our application'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：将来自集群外部用户的流量路由到运行我们应用的Pod
- en: Services and Pods
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务和Pod
- en: In *step 3* of the previous exercise, you may have noticed that the Service
    tries to match pods by labels (the `selector` field under the `spec` section)
    instead of using a fixed pod name or something similar. From a pod's perspective,
    it doesn't need to know which Service is bringing traffic to it. (In some rare
    cases, it can even be mapped to multiple Services; that is, multiple Services
    may be sending traffic to a pod.)
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习的*步骤3*中，您可能已经注意到服务尝试通过标签（`spec`部分下的`selector`字段）来匹配Pod，而不是使用固定的Pod名称或类似的东西。从Pod的角度来看，它不需要知道哪个服务正在为其带来流量。（在一些罕见的情况下，它甚至可以映射到多个服务；也就是说，多个服务可能会向一个Pod发送流量。）
- en: 'This label-based matching mechanism is widely used in Kubernetes. It enables
    the API objects to be loosely coupled at runtime. For example, you can specify
    `tier: frontend` as the label selector, which will, in turn, be associated with
    the pods that are labeled as `tier: frontend`.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '这种基于标签的匹配机制在Kubernetes中被广泛使用。它使API对象在运行时松散耦合。例如，您可以指定`tier: frontend`作为标签选择器，这将与被标记为`tier:
    frontend`的Pod相关联。'
- en: Due to this, by the time the Service is created, it doesn't matter if the backing
    pods exist or not. It's totally acceptable for backing pods to be created later,
    and after they are created, the Service object will become associated with the
    correct pods. Internally, the whole mapping logic is implemented by the service
    controller, which is part of the controller manager component. It's also possible
    that a Service may have two matching pods at a time, and later a third pod is
    created with matching labels, or one of the existing pods gets deleted. In either
    case, the service controller can detect such changes and ensure that users can
    always access their application via the Service endpoint.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦创建了 Service，备份 pod 是否存在都无关紧要。备份 pod 后来创建也是完全可以接受的，创建后，Service 对象将与正确的 pod
    关联起来。在内部，整个映射逻辑是由服务控制器实现的，它是控制器管理器组件的一部分。Service 可能一次有两个匹配的 pod，并且后来创建了一个具有匹配标签的第三个
    pod，或者其中一个现有的 pod 被删除。在任何一种情况下，服务控制器都可以检测到这些更改，并确保用户始终可以通过 Service 端点访问其应用程序。
- en: It's a very commonly used pattern in Kubernetes to orchestrate your application
    using different kinds of API objects and then glue them together by using labels
    or other loosely coupled conventions. It's also the key part of container orchestration.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中使用不同类型的 API 对象来编排应用程序，然后通过使用标签或其他松散耦合的约定将它们粘合在一起是一个非常常见的模式。这也是容器编排的关键部分。
- en: Delivering Kubernetes-Native Applications
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交付 Kubernetes 原生应用程序
- en: In the previous sections, we migrated a Docker-based application to Kubernetes
    and successfully accessed it from inside the Minikube VM, as well as externally.
    Now, let's see what other benefits Kubernetes can provide if we design our application
    from the ground up so that it can be deployed using Kubernetes.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们将基于 Docker 的应用程序迁移到了 Kubernetes，并成功地从 Minikube VM 内部和外部访问了它。现在，让我们看看如果我们从头开始设计我们的应用程序，使其可以使用
    Kubernetes 进行部署，Kubernetes 还可以提供哪些其他好处。
- en: Along with the increasing usage of your application, it may be common to run
    several replicas of certain pods to serve a business functionality. In this case,
    grouping different containers in a pod alone is not sufficient. We need to go
    ahead and create groups of pods that are working together. Kubernetes provides
    several abstractions for groups of pods, such as Deployments, DaemonSets, Jobs,
    CronJobs, and so on. Just like the Service object, these objects can also be created
    by using a spec that's been defined in a YAML file.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的应用程序使用量增加，运行多个特定 pod 的副本以提供业务功能可能很常见。在这种情况下，仅仅将不同容器分组在一个 pod 中是不够的。我们需要继续创建一组共同工作的
    pod。Kubernetes 为 pod 组提供了几种抽象，例如 Deployments、DaemonSets、Jobs、CronJobs 等。就像 Service
    对象一样，这些对象也可以通过在 YAML 文件中定义的 spec 来创建。
- en: To start understanding the benefits of Kubernetes, let's use a Deployment to
    demonstrate how to replicate (scale up/down) an application in multiple pods.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始了解 Kubernetes 的好处，让我们使用 Deployment 来演示如何在多个 pod 中复制（扩展/缩减）应用程序。
- en: 'Abstracting groups of pods using Kubernetes gives us the following advantages:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 对 pod 组进行抽象化给我们带来了以下优势：
- en: '**Creating replicas of pods for redundancy**: This is the main advantage of
    abstractions of groups of pods such as Deployments. A Deployment can create several
    pods with the given spec. A Deployment will automatically ensure that the pods
    that it creates are online, and it will automatically replace any pods that fail.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建 pod 的副本以实现冗余**：这是使用 Deployments 等 pod 组抽象的主要优势。Deployment 可以根据给定的 spec
    创建多个 pod。Deployment 将自动确保它创建的 pod 处于在线状态，并将自动替换任何失败的 pod。'
- en: '**Easy upgrades and rollbacks**: Kubernetes provides different strategies that
    you can use to upgrade your applications, as well as rolling versions back. This
    is important because in modern software development, the software is often developed
    iteratively, and updates are released frequently. An upgrade can change anything
    in the Deployment specification. It can be an update of labels or any other field(s),
    an image version upgrade, an update on its embedded containers, and so on.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单的升级和回滚**：Kubernetes 提供了不同的策略，你可以使用这些策略来升级你的应用程序，以及回滚版本。这很重要，因为在现代软件开发中，软件经常是迭代开发的，更新频繁。升级可以改变部署规范中的任何内容。它可以是标签或任何其他字段的更新，镜像版本的升级，对其嵌入式容器的更新等等。'
- en: 'Let''s take a look at some notable aspects of the spec of a sample Deployment:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下样本部署规范的一些值得注意的方面：
- en: k8s-for-beginners-deploy.yaml
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: k8s-for-beginners-deploy.yaml
- en: '[PRE56]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In addition to wrapping the pod spec as a "template", a Deployment must also
    specify its kind (`Deployment`), as well as the API version (`apps/v1`).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将 pod 规范包装为 "template"，部署还必须指定其种类（`Deployment`），以及 API 版本（`apps/v1`）。
- en: Note
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For some historical reason, the spec name `apiVersion` is still being used.
    But technically speaking, it literally means `apiGroupVersion`. In the preceding
    Deployment example, it belongs to the `apps` group and is version `v1`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 出于某些历史原因，规范名称 `apiVersion` 仍在使用。但从技术上讲，它实际上意味着 `apiGroupVersion`。在前面的部署示例中，它属于
    `apps` 组，版本为 `v1`。
- en: In the Deployment spec, the `replicas` field instructs Kubernetes to start three
    pods using the pod spec defined in the `template` field. The `selector` field
    plays the same role as we saw in the case of the Service – it aims to associate
    the Deployment object with specific pods in a loosely coupled manner. This is
    particularly useful if you want to bring any preexisting pods under the management
    of your new Deployment.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署规范中，`replicas` 字段指示 Kubernetes 使用在 `template` 字段中定义的 pod 规范启动三个 pod。`selector`
    字段扮演了与服务案例中相同的角色 - 它旨在以一种松散耦合的方式将部署对象与特定的 pod 关联起来。如果你想要将任何现有的 pod 纳入新部署的管理，这将特别有用。
- en: The replica number defined in a Deployment or other similar API object represents
    the desired state of how many pods are supposed to be running continuously. If
    some of these pods fail for some unexpected reason, Kubernetes will automatically
    detect that and create a corresponding number of pods to take their place. We
    will explore that in the following exercise.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署或其他类似的 API 对象中定义的副本数量代表了持续运行的 pod 数量的期望状态。如果其中一些 pod 因某些意外原因而失败，Kubernetes
    将自动检测到并创建相应数量的 pod 来替代它们。我们将在接下来的练习中探讨这一点。
- en: We'll see a Deployment in action in the following exercise.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的练习中看到部署的实际操作。
- en: 'Exercise 2.04: Scaling a Kubernetes Application'
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.04：扩展 Kubernetes 应用程序
- en: 'In Kubernetes, it''s easy to increase the number of replicas running the application
    by updating the `replicas` field of a Deployment spec. In this exercise, we''ll
    experiment with how to scale a Kubernetes application up and down. Follow these
    steps to complete this exercise:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，通过更新部署规范的 `replicas` 字段，很容易增加运行应用程序的副本数量。在这个练习中，我们将尝试如何扩展 Kubernetes
    应用程序的规模。按照以下步骤完成这个练习：
- en: 'Create a file named `k8s-for-beginners-deploy.yaml` using the content shown
    here:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这里显示的内容创建一个名为 `k8s-for-beginners-deploy.yaml` 的文件：
- en: '[PRE57]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If you take a closer look, you'll see that this Deployment spec is largely based
    on the pod spec from earlier exercises (`k8s-for-beginners-pod1.yaml`), which
    you can see under the `template` field.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看，你会发现这个部署规范在很大程度上基于之前练习中的 pod 规范（`k8s-for-beginners-pod1.yaml`），你可以在 `template`
    字段下看到。
- en: 'Next, we can use kubectl to create the Deployment:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用 kubectl 来创建部署：
- en: '[PRE58]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You should see the following output:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下输出：
- en: '[PRE59]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Given that the Deployment has been created successfully, we can use the following
    command to show all the Deployment''s statuses, such as their names, running pods,
    and so on:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鉴于部署已经成功创建，我们可以使用以下命令来显示所有部署的状态，比如它们的名称、运行的pod等等：
- en: '[PRE60]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You should get the following response:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到以下响应：
- en: '[PRE61]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'As shown in the previous command, we are using `deploy` instead of `deployment`.
    Both of these will work and `deploy` is an allowed short name for `deployment`.
    You can find a quick list of some commonly used short names at this link: [https://kubernetes.io/docs/reference/kubectl/overview/#resource-types](https://kubernetes.io/docs/reference/kubectl/overview/#resource-types).'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的命令所示，我们使用的是`deploy`而不是`deployment`。这两者都可以使用，`deploy`是`deployment`的允许的简称。您可以在此链接找到一些常用的简称列表：[https://kubernetes.io/docs/reference/kubectl/overview/#resource-types](https://kubernetes.io/docs/reference/kubectl/overview/#resource-types)。
- en: You can also view the short names by running `kubectl api-resources`, without
    specifying the resource type.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过运行`kubectl api-resources`来查看短名称，而不指定资源类型。
- en: 'A pod called `k8s-for-beginners` exists that we created in the previous exercise.
    To ensure that we see only the pods being managed by the Deployment, let''s delete
    the older pod:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在上一个练习中创建的名为`k8s-for-beginners`的pod存在。为了确保我们只看到由部署管理的pod，让我们删除旧的pod：
- en: '[PRE62]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You should see the following response:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '[PRE63]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, get a list of all the pods:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，获取所有的pod列表：
- en: '[PRE64]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You should see the following response:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '![Figure 2.14: Getting the list of pods'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.14：获取pod列表'
- en: '](image/B14870_02_14.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_14.jpg)'
- en: 'Figure 2.14: Getting the list of pods'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：获取pod列表
- en: The Deployment has created three pods, and their labels (specified in the `labels`
    field in *step 1*) happen to match the Service we created in the previous section.
    So, what will happen if we try to access the Service? Will the network traffic
    going to the Service be smartly routed to the new three pods? Let's test this
    out.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 部署已经创建了三个pod，并且它们的标签（在*步骤1*中指定的`labels`字段）恰好与我们在上一节中创建的Service匹配。那么，如果我们尝试访问Service会发生什么呢？网络流量会聪明地路由到这三个新的pod吗？让我们来测试一下。
- en: 'To see how the traffic is distributed to the three pods, we can simulate a
    number of consecutive requests to the Service endpoint by running the `curl` command
    inside a Bash `for` loop, as follows:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看流量是如何分配到这三个pod的，我们可以通过在Bash的`for`循环中运行`curl`命令来模拟一系列连续的请求到Service端点，如下所示：
- en: '[PRE65]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this command, use the same IP and port that you used in the previous exercise
    if you are running the same instance of Minikube. If you have restarted Minikube
    or have made any other changes, please get the proper IP of your Minikube cluster
    by following *step 9* of the previous exercise.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，如果您正在运行相同的Minikube实例，请使用与上一个练习中相同的IP和端口。如果您重新启动了Minikube或进行了其他更改，请按照上一个练习的*步骤9*获取您的Minikube集群的正确IP。
- en: 'Once you''ve run the command with the proper IP and port, you should see the
    following output:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您使用正确的IP和端口运行了命令，您应该会看到以下输出：
- en: '![Figure 2.15: Repeatedly accessing our application'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.15：重复访问我们的应用'
- en: '](image/B14870_02_15.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_15.jpg)'
- en: 'Figure 2.15: Repeatedly accessing our application'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：重复访问我们的应用
- en: From the output, we can tell that all 30 requests get the expected response.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看出所有30个请求都得到了预期的响应。
- en: 'You can run `kubectl logs <pod name>` to check the log of each pod. Let''s
    go one step further and figure out the exact number of requests each pod has responded
    to, which might help us find out whether the traffic was evenly distributed. To
    do that, we can pipe the logs of each pod into the `wc` command to get the number
    of lines:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以运行`kubectl logs <pod name>`来检查每个pod的日志。让我们再进一步，找出每个pod实际响应的确切请求数，这可能有助于我们找出流量是否均匀分布。为此，我们可以将每个pod的日志传输到`wc`命令中以获取行数：
- en: '[PRE66]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Run the preceding command three times, copying the pod name you obtained, as
    shown in *Figure 2.16*:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令三次，复制您获得的pod名称，如*图2.16*所示：
- en: '![Figure 2.16: Getting the logs of each of the three pod replicas running our
    application'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.16：获取运行我们应用程序的三个pod副本的日志'
- en: '](image/B14870_02_16.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_16.jpg)'
- en: 'Figure 2.16: Getting the logs of each of the three pod replicas running our
    application'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16：获取运行我们应用程序的三个pod副本的日志
- en: The result shows that the three pods handled `9`, `10`, and `11` requests, respectively.
    Due to the small sample size, the distribution is not absolutely even (that is,
    `10` for each), but it is sufficient to indicate the default round-robin distribution
    strategy used by a Service.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，三个pod分别处理了`9`、`10`和`11`个请求。由于样本量较小，分布并不绝对均匀（即每个`10`），但足以表明服务使用的默认轮询分发策略。
- en: Note
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can read more about how kube-proxy leverages iptables to perform the internal
    load balancing by looking at the official documentation: [https://kubernetes.io/docs/concepts/services-networking/service/#proxy-mode-iptables](https://kubernetes.io/docs/concepts/services-networking/service/#proxy-mode-iptables).'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看官方文档了解kube-proxy如何利用iptables执行内部负载平衡：[https://kubernetes.io/docs/concepts/services-networking/service/#proxy-mode-iptables](https://kubernetes.io/docs/concepts/services-networking/service/#proxy-mode-iptables)。
- en: 'Next, let''s learn how to scale up a Deployment. There are two ways of accomplishing
    this: one way is to modify the Deployment''s YAML config, where we can set the
    value of `replicas` to another number (such as `5`), while the other way is to
    use the `kubectl scale` command, as follows:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何扩展部署。有两种方法可以实现这一点：一种方法是修改部署的YAML配置，我们可以将`replicas`的值设置为另一个数字（例如`5`），另一种方法是使用`kubectl
    scale`命令，如下所示：
- en: '[PRE67]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You should see the following response:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '[PRE68]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let''s verify whether there are five pods running:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们验证一下是否有五个pod在运行：
- en: '[PRE69]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You should see a response similar to the following:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到类似以下的响应：
- en: '![Figure 2.17: Getting the list of pods'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.17：获取pod列表'
- en: '](image/B14870_02_17.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_17.jpg)'
- en: 'Figure 2.17: Getting the list of pods'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17：获取pod列表
- en: The output shows that the existing three pods are kept and that two new pods
    are created.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示现有的三个pod被保留，另外创建了两个新的pod。
- en: 'Similarly, you can specify replicas that are smaller than the current number.
    In our example, let''s say that we want to shrink the replica''s number to `2`.
    The command for this would look as follows:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，您也可以指定小于当前数量的副本。在我们的示例中，假设我们想将副本数量缩减到`2`。此命令如下所示：
- en: '[PRE70]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You should see the following response:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '[PRE71]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, let''s verify the number of pods:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们验证一下pod的数量：
- en: '[PRE72]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You should see a response similar to the following:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到类似以下的响应：
- en: '![Figure 2.18: Getting the list of pods'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.18：获取pod列表'
- en: '](image/B14870_02_18.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_18.jpg)'
- en: 'Figure 2.18: Getting the list of pods'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18：获取pod列表
- en: As shown in the preceding screenshot, there are two pods, and they are both
    running as expected. Thus, in Kubernetes' terms, we can say, "the Deployment is
    in its desired state".
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，有两个pod，它们都按预期运行。因此，在Kubernetes术语中，我们可以说，“部署处于期望的状态”。
- en: 'We can run the following command to verify this:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以运行以下命令来验证这一点：
- en: '[PRE73]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You should see the following response:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '[PRE74]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, let''s see what happens if we delete one of the two pods:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果我们删除两个pod中的一个会发生什么：
- en: '[PRE75]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You should get the following response:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下响应：
- en: '[PRE76]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Check the status of the pods to see what has happened:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查pod的状态以查看发生了什么：
- en: '[PRE77]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You should see the following response:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '![Figure 2.19: Getting the list of pods'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.19：获取pod列表'
- en: '](image/B14870_02_19.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_19.jpg)'
- en: 'Figure 2.19: Getting the list of pods'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19：获取pod列表
- en: We can see that there are still two pods. From the output, it's worth noting
    that the first pod name is the same as the second pod in *Figure 2.18* (this is
    the one that was not deleted), but that the highlighted pod name is different
    from any of the pods in *Figure 2.18*. This indicates that the highlighted one
    is the pod that was newly created to replace the deleted one. The Deployment created
    a new pod so that the number of running pods satisfies the desired state of the
    Deployment.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到仍然有两个pod。从输出中值得注意的是，第一个pod的名称与*图2.18*中的第二个pod的名称相同（这是未被删除的那个），但是突出显示的pod名称与*图2.18*中的任何一个pod的名称都不同。这表明突出显示的那个是新创建的用来替换已删除的pod。部署创建了一个新的pod，以使运行中的pod数量满足部署的期望状态。
- en: In this exercise, we have learned how to scale a deployment up and down. You
    can scale other similar Kubernetes objects, such as DaemonSets and StatefulSets,
    in the same way. Also, for such objects, Kubernetes will try to auto-recover the
    failed pods.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何扩展部署的规模。您可以以相同的方式扩展其他类似的Kubernetes对象，例如DaemonSets和StatefulSets。此外，对于这样的对象，Kubernetes将尝试自动恢复失败的pod。
- en: Pod Life Cycle and Kubernetes Components
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pod生命周期和Kubernetes组件
- en: The previous sections in this chapter briefly described the Kubernetes components
    and how they work internally with each other. On the other hand, we also demonstrated
    how to use some Kubernetes API objects (Pods, Services, and Deployments) to compose
    your applications.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前几节简要描述了Kubernetes组件以及它们如何在内部相互工作。另一方面，我们还演示了如何使用一些Kubernetes API对象（Pods、Services和Deployments）来组合您的应用程序。
- en: 'But how is a Kubernetes API object managed by different Kubernetes components?
    Let''s consider a pod as an example. Its life cycle can be illustrated as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 但是Kubernetes API对象如何由不同的Kubernetes组件管理呢？让我们以pod为例。其生命周期可以如下所示：
- en: '![Figure 2.20: The process behind the creation of a pod'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.20：创建pod的过程'
- en: '](image/B14870_02_20.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_20.jpg)'
- en: 'Figure 2.20: The process behind the creation of a pod'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20：创建pod的过程
- en: 'This entire process can be broken down as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程可以分解如下：
- en: A user starts to deploy an application by sending a Deployment YAML manifest
    to the Kubernetes API server. The API server verifies the request and checks whether
    it's valid. If it is, it persists the Deployment API object to its backend datastore
    (etcd).
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户通过向Kubernetes API服务器发送部署Deployment YAML清单来部署应用程序。API服务器验证请求并检查其是否有效。如果有效，它将持久化部署API对象到其后端数据存储（etcd）。
- en: Note
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For any step that evolves by modifying API objects, interactions have to happen
    between etcd and the API server, so we don't list the interactions as extra steps
    explicitly.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通过修改API对象演变的任何步骤，etcd和API服务器之间必须发生交互，因此我们不会将交互列为额外的步骤。
- en: By now, the pod hasn't been created yet. The controller manager gets a notification
    from the API server that a Deployment has been created.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，pod还没有被创建。控制器管理器从API服务器那里收到通知，部署已经被创建。
- en: Then, the controller manager checks whether the desired number of replica pods
    are running already.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，控制器管理器会检查所需数量的副本pod是否已经在运行。
- en: If there are not enough pods running, it creates the appropriate number of pods.
    The creation of pods is accomplished by sending a request with the pod spec to
    the API server. It's quite similar to how a user would apply the Deployment YAML,
    but with the major difference being that this happens inside the controller manager
    in a programmatic manner.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果正在运行的Pod数量不足，它会创建适当数量的Pod。创建Pod是通过向API服务器发送具有Pod规范的请求来完成的。这与用户应用部署YAML的方式非常相似，但主要区别在于这是以编程方式在控制器管理器内部发生的。
- en: Although pods have been created, they're nothing but some API objects stored
    in etcd. Now, the scheduler gets a notification from the API server saying that
    new pods have been created and no node has been assigned for them to run.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管Pod已经被创建，但它们只是存储在etcd中的一些API对象。现在，调度器从API服务器那里收到通知，称新的Pod已被创建，但尚未分配节点来运行它们。
- en: The scheduler checks the resource usage, as well as existing pods allocation,
    and then calculates the node that fits best for each new pod. At the end of this
    step, the scheduler sends an update request to the API server by setting the pod's
    `nodeName` spec to the chosen node.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调度器检查资源使用情况，以及现有的Pod分配情况，然后计算最适合每个新Pod的节点。在这一步结束时，调度器通过将Pod的`nodeName`规范设置为所选节点，向API服务器发送更新请求。
- en: By now, the pods have been assigned a proper node to run on. However, no physical
    containers are running. In other words, the application doesn't work yet. Each
    kubelet (running on different worker nodes) gets notifications, indicating that
    some pods are expected to be run. Each kubelet will then check whether the pods
    to be run have been assigned the node that a kubelet is running on.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，Pod已被分配到适当的节点上运行。然而，没有运行实际的容器。换句话说，应用程序还没有运行。每个kubelet（运行在不同的工作节点上）都会收到通知，指示某些Pod应该被运行。然后，每个kubelet将检查将要运行的Pod是否已被分配到kubelet正在运行的节点。
- en: Once the kubelet determines that a pod is supposed to be on its node, it calls
    the underlying container runtime (Docker, containerd, or cri-o, for instance)
    to spin up the containers on the host. Once the containers are up, the kubelet
    is responsible for reporting its status back to the API server.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦kubelet确定一个Pod应该在其节点上，它会调用底层的容器运行时（例如Docker、containerd或cri-o）在主机上启动容器。一旦容器启动，kubelet负责向API服务器报告其状态。
- en: 'With this basic flow in mind, you should now have a vague understanding of
    the answers to the following questions:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个基本流程，现在你应该对以下问题的答案有一个模糊的理解：
- en: Who is in charge of pod creation? What's the state of the pod upon creation?
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁负责创建Pod？创建后Pod的状态是什么？
- en: Who is responsible for placing a pod? What's the state of the pod after placement?
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁负责放置Pod？放置后Pod的状态是什么？
- en: Who brings up the concrete containers?
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁启动具体的容器？
- en: Who is in charge of the overall message delivery process to ensure that all
    components work together?
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁负责整体消息传递过程，以确保所有组件协同工作？
- en: In the following exercise, we will use a series of concrete experiments to help
    you solidify this understanding. This will allow you to see how things work in
    practice.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将使用一系列具体的实验来帮助您巩固这一理解。这将让您看到事情在实践中是如何运作的。
- en: 'Exercise 2.05: How Kubernetes Manages a Pod''s Life Cycle'
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.05：Kubernetes如何管理Pod的生命周期
- en: 'As a Kubernetes cluster comprises multiple components, and each component works
    simultaneously, it''s usually difficult to know what''s exactly happening in each
    phase of a pod''s life cycle. To solve this problem, we will use a film editing
    technique to "play the whole life cycle in slow motion", so as to observe each
    phase. We will turn off the master plane components and then attempt to create
    a pod. Then, we will respond to the errors that we see, and slowly bring each
    component online, one by one. This will allow us to slow down and examine each
    stage of the process of pod creation step-by-step. Follow these steps to complete
    this exercise:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Kubernetes集群包括多个组件，并且每个组件同时工作，通常很难知道每个pod生命周期的每个阶段发生了什么。为了解决这个问题，我们将使用电影剪辑技术来“以慢动作播放整个生命周期”，以便观察每个阶段。我们将关闭主平面组件，然后尝试创建一个pod。然后，我们将响应我们看到的错误，并逐步将每个组件逐个上线。这将使我们能够放慢速度，逐步检查pod创建过程的每个阶段。按照以下步骤完成此练习：
- en: 'First, let''s delete the Deployment and Service we created earlier by using
    the following command:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下命令删除之前创建的部署和服务：
- en: '[PRE78]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You should see the following response:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE79]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Prepare two terminal sessions: one (host terminal) to run commands on your
    host machine and another (Minikube terminal) to pass commands inside the Minikube
    VM via SSH. Thus, your Minikube session will be initiated like this:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备两个终端会话：一个（主机终端）用于在主机上运行命令，另一个（Minikube终端）用于通过SSH在Minikube VM内部传递命令。因此，您的Minikube会话将像这样启动：
- en: '[PRE80]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You will see the following output:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![Figure 2.21: Accessing the Minikube VM via SSH'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.21：通过SSH访问Minikube VM'
- en: '](image/B14870_02_21.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_21.jpg)'
- en: 'Figure 2.21: Accessing the Minikube VM via SSH'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21：通过SSH访问Minikube VM
- en: Note
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All `kubectl` commands are expected to be run in the host terminal session,
    while all `docker` commands are to be run in the Minikube terminal session.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`kubectl`命令都应在主机终端会话中运行，而所有`docker`命令都应在Minikube终端会话中运行。
- en: 'In the Minikube session, clean up all stopped Docker containers:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Minikube会话中，清理所有已停止的Docker容器：
- en: '[PRE81]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You should see the following output:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 2.22: Cleaning up all stopped Docker containers'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.22：清理所有已停止的Docker容器'
- en: '](image/B14870_02_22.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_22.jpg)'
- en: 'Figure 2.22: Cleaning up all stopped Docker containers'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22：清理所有已停止的Docker容器
- en: You may see some error messages such as "You cannot remove a running container
    ...". This is because the preceding `docker rm` command runs against all containers
    (`docker ps -a -q`), but it won't stop any running containers.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会看到一些错误消息，比如“您无法删除正在运行的容器...”。这是因为前面的`docker rm`命令针对所有容器（`docker ps -a -q`）运行，但不会停止任何正在运行的容器。
- en: 'In the Minikube session, stop the kubelet by running the following command:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Minikube会话中，通过运行以下命令停止kubelet：
- en: '[PRE82]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This command does not show any response upon successful execution.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在成功执行后不会显示任何响应。
- en: Note
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Later in this exercise, we will manually stop and start other Kubernetes components,
    such as the API server, that are managed by the kubelet in a Minikube environment.
    Hence, it's required that you stop the kubelet first in this exercise; otherwise,
    the kubelet will automatically restart its managed components.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将手动停止和启动其他由kubelet在Minikube环境中管理的Kubernetes组件，例如API服务器。因此，在本练习中，需要先停止kubelet；否则，kubelet将自动重新启动其管理的组件。
- en: Note that in typical production environments, unlike Minikube, it's not necessary
    to run the kubelet on the master node to manage the master plane components; the
    kubelet is only a mandatory component on worker nodes.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在典型的生产环境中，与Minikube不同，不需要在主节点上运行kubelet来管理主平面组件；kubelet只是工作节点上的一个强制组件。
- en: 'After 30 seconds, check the cluster''s status by running the following command
    in your host terminal session:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 30秒后，在主机终端会话中运行以下命令来检查集群的状态：
- en: '[PRE83]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'You should see the following response:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE84]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: It's expected that the status of the `minikube` node is changed to `NotReady`
    because the kubelet has been stopped.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 预计`minikube`节点的状态将更改为`NotReady`，因为kubelet已停止。
- en: 'In your Minikube session, stop `kube-scheduler`, `kube-controller-manager`,
    and `kube-apiserver`. As we saw earlier, all of these are running as Docker containers.
    Hence, you can use the following commands, one after the other:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Minikube会话中，停止`kube-scheduler`、`kube-controller-manager`和`kube-apiserver`。正如我们之前所看到的，所有这些都作为Docker容器运行。因此，您可以依次使用以下命令：
- en: '[PRE85]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'You should see the following responses:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 2.23: Stopping the containers running Kubernetes components'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.23：停止运行Kubernetes组件的容器'
- en: '](image/B14870_02_23.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_23.jpg)'
- en: 'Figure 2.23: Stopping the containers running Kubernetes components'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23：停止运行Kubernetes组件的容器
- en: As we explained in the *Kubernetes Components Overview* section, the `grep -v
    pause | awk '{print $1}'` command can fetch the exact container ID (`$1` = the
    first column) of the required Docker containers. Then, the `docker pause` command
    can pause that running Docker container.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*Kubernetes组件概述*部分所解释的，`grep -v pause | awk '{print $1}'`命令可以获取所需Docker容器的确切容器ID（`$1`
    = 第一列）。然后，`docker pause`命令可以暂停正在运行的Docker容器。
- en: Now, the three major Kubernetes components have been stopped.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，三个主要的Kubernetes组件已经停止。
- en: 'Now, you need to create a Deployment spec on your host machine. Create a file
    named `k8s-for-beginners-deploy2.yaml` with the following content:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要在主机机器上创建一个部署规范。创建一个名为`k8s-for-beginners-deploy2.yaml`的文件，内容如下：
- en: '[PRE86]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Try to create the Deployment by running the following command on your host
    session:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在主机会话中运行以下命令来创建部署：
- en: '[PRE87]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You should see a response similar to this:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于以下内容的响应：
- en: '![Figure 2.24: Trying to create a new Deployment'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.24：尝试创建新的部署'
- en: '](image/B14870_02_24.jpg)'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_24.jpg)'
- en: 'Figure 2.24: Trying to create a new Deployment'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24：尝试创建新的部署
- en: 'Unsurprisingly, we got a network timeout error since we intentionally stopped
    the Kubernetes API server. If the API server is down, you cannot run any `kubectl`
    commands or use any equivalent tools (such as Kubernetes Dashboard) that rely
    on API requests:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，我们收到了网络超时错误，因为我们有意停止了Kubernetes API服务器。如果API服务器宕机，您将无法运行任何`kubectl`命令或使用任何依赖API请求的等效工具（例如Kubernetes仪表板）：
- en: '[PRE88]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Let''s see what happens if we restart the API server and try to create the
    Deployment once more. Restart the API server container by running the following
    command in your Minikube session:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看如果重新启动API服务器并尝试再次创建部署会发生什么。通过在Minikube会话中运行以下命令来重新启动API服务器容器：
- en: '[PRE89]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This command tries to find the container ID of the stopped container carrying
    the API server, and then it starts it. You should get a response like this:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令尝试查找携带API服务器的停止容器的容器ID，然后启动它。您应该得到类似于这样的响应：
- en: '[PRE90]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Wait for 10 seconds. Then, check whether the API server is online. You can
    run any simple kubectl command for this. Let''s try getting the list of nodes
    by running the following command in the host session:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待10秒。然后，检查API服务器是否在线。您可以在主机会话中运行任何简单的kubectl命令来进行此操作。让我们尝试通过运行以下命令来获取节点列表：
- en: '[PRE91]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'You should see the following response:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE92]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: As you can see, we are able to get a response without errors.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们能够得到一个没有错误的响应。
- en: 'Let''s try to create the Deployment again:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次尝试创建部署：
- en: '[PRE93]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'You should see the following response:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE94]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Let''s check whether the Deployment has been created successfully by running
    the following command:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令来检查部署是否已成功创建：
- en: '[PRE95]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'You should see the following response:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE96]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: From the preceding screenshot, there seems to be something wrong as in the `READY`
    column, we can see `0/1`, which indicates that there are 0 pods associated with
    this Deployment, while the desired number is 1 (which we specified in the `replicas`
    field in the Deployment spec).
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，似乎有些问题，因为在`READY`列中，我们可以看到`0/1`，这表明与此部署关联的pod数量为0，而期望的数量是1（我们在部署规范中指定的`replicas`字段）。
- en: 'Let''s check that all the pods that are online:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查所有在线的pod：
- en: '[PRE97]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You should get a response similar to the following:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE98]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We can see that our pod has not been created. This is because the Kubernetes
    API server only creates the API objects; the implementation of any API object
    is carried out by other components. For example, in the case of Deployment, it's
    `kube-controller-manager` that creates the corresponding pod(s).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的pod尚未创建。这是因为Kubernetes API服务器只创建API对象；任何API对象的实现都是由其他组件执行的。例如，在部署的情况下，是`kube-controller-manager`创建相应的pod。
- en: 'Now, let''s restart the `kube-controller-manager`. Run the following command
    in your Minikube session:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们重新启动`kube-controller-manager`。在Minikube会话中运行以下命令：
- en: '[PRE99]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'You should see a response similar to the following:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的响应：
- en: '[PRE100]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'After waiting for a few seconds, check the status of the Deployment by running
    the following command in the host session:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几秒钟后，在主机会话中运行以下命令来检查部署的状态：
- en: '[PRE101]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'You should see the following response:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE102]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: As we can see, the pod that we are looking for is still not online.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们正在寻找的pod仍然没有上线。
- en: 'Now, check the status of the pod:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查pod的状态：
- en: '[PRE103]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'You should see the following response:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 2.25: Getting the list of pods'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.25：获取pod列表'
- en: '](image/B14870_02_25.jpg)'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_25.jpg)'
- en: 'Figure 2.25: Getting the list of pods'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.25：获取pod列表
- en: The output is different from the one in *step 15*, as in this case, one pod
    was created by `kube-controller-manager`. However, we can see `Pending` under
    the `STATUS` column. This is because assigning a pod to a suitable node is not
    the responsibility of `kube-controller-manager`; it's the responsibility of `kube-scheduler`.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与*步骤15*中的输出不同，因为在这种情况下，一个pod是由`kube-controller-manager`创建的。但是，在`STATUS`列下我们可以看到`Pending`。这是因为将pod分配给适当的节点不是`kube-controller-manager`的责任；这是`kube-scheduler`的责任。
- en: 'Before starting `kube-scheduler`, let''s take a look at some additional information
    about the pod:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动`kube-scheduler`之前，让我们看一下有关pod的一些额外信息：
- en: '[PRE104]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'You should see the following response:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 2.26: Getting more information about the pod'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.26：获取有关pod的更多信息'
- en: '](image/B14870_02_26.jpg)'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_26.jpg)'
- en: 'Figure 2.26: Getting more information about the pod'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.26：获取有关pod的更多信息
- en: The highlighted `NODE` column indicates that no node has been assigned to this
    pod. This proves that the scheduler is not working properly, which we know because
    we took it offline. If the scheduler were to be online, this response would indicate
    that there is no place to land this pod.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的`NODE`列表明尚未为此pod分配节点。这证明了调度程序没有正常工作，我们知道这是因为我们将其下线。如果调度程序在线，此响应将表明没有地方可以放置此pod。
- en: Note
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will learn a lot more about pod scheduling in *Chapter 17*, *Advanced Scheduling
    in Kubernetes*.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在*第17章*，*Kubernetes中的高级调度*中学到更多关于pod调度的知识。
- en: 'Let''s restart `kube-scheduler` by running the following command in the Minikube
    session:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过在Minikube会话中运行以下命令来重新启动`kube-scheduler`：
- en: '[PRE105]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'You should see a response similar to the following:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的响应：
- en: '[PRE106]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We can verify that `kube-scheduler` is working by running the following command
    in the host session:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在主机会话中运行以下命令来验证`kube-scheduler`是否工作：
- en: '[PRE107]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Please get the pod name from the response you get at *step 17*, as seen in
    *Figure 2.26*. You should see the following output:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 请从*步骤17*中获得响应中的pod名称，如*图2.26*中所示。您应该看到以下输出：
- en: '[PRE108]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We are truncating the output screenshots for a better presentation. Please
    take a look at the following excerpt, highlighting the `Events` section:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在截断输出截图以便更好地展示。请看以下摘录，重点是`Events`部分：
- en: '![Figure 2.27: Examining the events reported by the pod'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.27：检查pod报告的事件'
- en: '](image/B14870_02_27.jpg)'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_27.jpg)'
- en: 'Figure 2.27: Examining the events reported by the pod'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.27：检查pod报告的事件
- en: In the `Events` section, we can see that the `kube-scheduler` has tried scheduling,
    but it reports that there is no node available. Why is that?
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Events`部分，我们可以看到`kube-scheduler`尝试调度，但它报告没有可用的节点。为什么会这样？
- en: This is because, earlier, we stopped the kubelet, and the Minikube environment
    is a single-node cluster, so there is no available node(s) with a functioning
    kubelet for the pod to be placed.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们之前停止了kubelet，并且Minikube环境是一个单节点集群，因此没有可用的带有运行kubelet的节点，可以放置pod。
- en: 'Let''s restart the kubelet by running the following command in the Minikube
    session:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过在Minikube会话中运行以下命令来重新启动kubelet：
- en: '[PRE109]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This should not give any response in the terminal upon successful execution.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 成功执行后，终端不应该给出任何响应。
- en: 'In the host terminal, verify the status of the Deployment by running the following
    command in the host session:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主机终端中，通过在主机会话中运行以下命令来验证部署的状态：
- en: '[PRE110]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'You should see the following response:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE111]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Now, everything looks healthy as the Deployment shows `1/1` under the `READY`
    column, which means that the pod is online.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切看起来都很健康，因为部署在`READY`列下显示`1/1`，这意味着pod在线。
- en: 'Similarly, verify the status of the pod:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，验证pod的状态：
- en: '[PRE112]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'You should get an output similar to the following:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到类似以下的输出：
- en: '![Figure 2.28: Getting more information about the pod'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.28：获取有关pod的更多信息'
- en: '](image/B14870_02_28.jpg)'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_28.jpg)'
- en: 'Figure 2.28: Getting more information about the pod'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.28：获取有关pod的更多信息
- en: We can see `Running` under `STATUS` and that it's been assigned to the `minikube`
    node.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`STATUS`下是`Running`，并且它已被分配给`minikube`节点。
- en: 'In this exercise, we traced each phase of a pod''s life cycle by breaking the
    Kubernetes components and then recovering them one by one. Now, based on the observations
    we made about this exercise; we have better clarity regarding the answers to the
    questions that were raised before this exercise:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们通过逐个破坏Kubernetes组件然后逐个恢复它们来追踪pod生命周期的每个阶段。现在，基于我们对这个练习所做的观察，我们对在这个练习之前提出的问题有了更清晰的认识：
- en: '**Steps 12 – 16**: We saw that in the case of a Deployment, a controller manager
    is responsible for requesting the creation of pods.'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤12 – 16**：我们看到在部署的情况下，控制器管理器负责请求创建pod。'
- en: '**Steps 17 – 19**: The scheduler is responsible for choosing a node to place
    in the pod. It assigns the node by setting a pod''s `nodeName` spec to the desired
    node. Associating a pod to a node, at this moment, merely happened at the level
    of the API object.'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤17 – 19**：调度程序负责选择要放置在pod中的节点。它通过将pod的`nodeName`规范设置为所需的节点来分配节点。此时，将pod关联到节点仅仅发生在API对象的级别。'
- en: '**Steps 20 – 22**: The kubelet actually brings up the containers to get our
    pod running.'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤20 – 22**：kubelet实际上会启动容器来运行我们的pod。'
- en: Throughout a pod's life cycle, Kubernetes components cooperate by updating a
    pod's spec properly. The API server serves as the key component that accepts pod
    update requests, as well as to report pod changes to interested parties.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个Pod的生命周期中，Kubernetes组件通过适当地更新Pod的规范来合作。API服务器作为接受Pod更新请求的关键组件，同时向感兴趣的方报告Pod的变化。
- en: In the following activity, we will bring together the skills we learned in the
    chapter to find out how we can migrate from a container-based environment to a
    Kubernetes environment in order to run our application.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的活动中，我们将汇集本章学到的技能，以找出如何从基于容器的环境迁移到Kubernetes环境，以便运行我们的应用程序。
- en: 'Activity 2.01: Running the Pageview App in Kubernetes'
  id: totrans-582
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动2.01：在Kubernetes中运行Pageview应用程序
- en: 'In *Activity 1.01*, *Creating a Simple Page Count Application*, in the previous
    chapter, we built a web application called Pageview and connected it to a Redis
    backend datastore. So, here is a question: without making any changes to the source
    code, can we migrate the Docker-based application to Kubernetes and enjoy Kubernetes''
    benefits immediately? Try it out in this activity with the guidelines given.'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Activity 1.01*中，*创建一个简单的页面计数应用程序*，在上一章中，我们构建了一个名为Pageview的Web应用程序，并将其连接到了一个Redis后端数据存储。所以，这里有一个问题：在不对源代码进行任何更改的情况下，我们能否将基于Docker的应用程序迁移到Kubernetes，并立即享受Kubernetes的好处？根据给定的指导方针，在这个活动中尝试一下。
- en: 'This activity is divided into two parts: in the first part, we will create
    a simple pod with our application that is exposed to traffic outside the cluster
    by a Service and connected to a Redis datastore running as another pod. In the
    second part, we will scale the application to three replicas.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动分为两个部分：在第一部分中，我们将创建一个简单的Pod，其中包含我们的应用程序，通过一个Service暴露给集群外的流量，并连接到另一个作为另一个Pod运行的Redis数据存储。在第二部分中，我们将将应用程序扩展到三个副本。
- en: '**Connecting the Pageview App to a Redis Datastore Using a Service**'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Service将Pageview应用程序连接到Redis数据存储**'
- en: 'Similar to the `--link` option in Docker, Kubernetes provides a Service that
    serves as an abstraction layer to expose one application (let''s say, a series
    of pods tagged with the same set of labels) that can be accessed internally or
    externally. For example, as we discussed in this chapter, a frontend app can be
    exposed via a `NodePort` Service so that it can be accessed by external users.
    In addition to that, in this activity, we need to define an internal Service in
    order to expose the backend application to the frontend application. Follow these
    steps:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Docker中的`--link`选项，Kubernetes提供了一个Service，作为一个抽象层来暴露一个应用程序（比如，一系列带有相同标签集的Pod）可以在内部或外部访问。例如，正如我们在本章中讨论的那样，前端应用程序可以通过`NodePort`
    Service暴露，以便外部用户访问。除此之外，在这个活动中，我们需要定义一个内部Service，以便将后端应用程序暴露给前端应用程序。按照以下步骤进行：
- en: In *Activity 1.01*, *Creating a Simple Page Count Application*, we built two
    Docker images – one for the frontend Pageview web app and another for the backend
    Redis datastore. You can use the skills we learned in this chapter to migrate
    them into Kubernetes YAMLs.
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*Activity 1.01*中，*创建一个简单的页面计数应用程序*，我们构建了两个Docker镜像——一个用于前端Pageview Web应用程序，另一个用于后端Redis数据存储。您可以使用本章学到的技能将它们迁移到Kubernetes
    YAML中。
- en: Two pods (each managed by a Deployment) for the application is not enough. We
    also have to create the Service YAML to link them together.
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为该应用程序创建两个Pod（每个由一个Deployment管理）是不够的。我们还必须创建Service YAML来将它们连接在一起。
- en: Ensure that the `targetPort` field in the manifest is consistent with the exposed
    port that was defined in the Redis image, which was `6379` in this case. In terms
    of the `port` field, theoretically, it can be any port, as long as it's consistent
    with the one specified in the Pageview application.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 确保清单中的`targetPort`字段与Redis镜像中定义的暴露端口一致，在这种情况下是`6379`。就`port`字段而言，理论上它可以是任何端口，只要它与Pageview应用程序中指定的端口一致即可。
- en: The other thing worth mentioning here is the `name` field of the pod for Redis
    datastore. It's the symbol that's used in the source code of the Pageview app
    to reference the Redis datastore.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得一提的另一件事是Redis数据存储的pod的`name`字段。这是Pageview应用程序源代码中用来引用Redis数据存储的符号。
- en: Now, you should have three YAMLs – two pods and a Service. Apply them using
    `kubectl -f <yaml file name>`, and then use `kubectl get deploy,service` to ensure
    that they're created successfully.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该有三个YAML文件 - 两个pod和一个Service。使用`kubectl -f <yaml文件名>`应用它们，然后使用`kubectl
    get deploy,service`来确保它们被成功创建。
- en: At this stage, the Pageview app should function well since it's connected to
    the Redis app via the Service. However, the Service only works as the internal
    connector to ensure they can talk to each other inside the cluster.
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，Pageview应用程序应该能够正常运行，因为它通过Service与Redis应用程序连接在一起。然而，Service只能作为内部连接器工作，以确保它们可以在集群内部相互通信。
- en: To access the Pageview app externally, we need to define a `NodePort` Service.
    Unlike the internal Service, we need to explicitly specify the `type` as `NodePort`.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 要从外部访问Pageview应用程序，我们需要定义一个`NodePort` Service。与内部Service不同，我们需要明确指定`type`为`NodePort`。
- en: Apply the external Service YAML using `kubectl -f <yaml file name>`.
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl -f <yaml文件名>`应用外部Service YAML。
- en: Run `minikube service <external service name>` to fetch the Service URL.
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`minikube service <外部service名称>`来获取Service URL。
- en: Access the URL multiple times to ensure that the Pageview number gets increased
    by one each time.
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多次访问URL，确保Pageview数量每次增加一个。
- en: With that, we have successfully run the Pageview application in Kubernetes.
    But what if the Pageview app is down? Although Kubernetes can create a replacement
    pod automatically, there is still downtime between when the failure is detected
    and when the new pod is ready.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们成功地在Kubernetes中运行了Pageview应用程序。但是如果Pageview应用程序宕机怎么办？尽管Kubernetes可以自动创建替代的pod，但在故障被检测到和新的pod准备就绪之间仍然存在停机时间。
- en: A common solution is to increase the replica number of the application so that
    the whole application is available as long as there is at least one replica running.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的解决方案是增加应用程序的副本数量，以便只要至少有一个副本在运行，整个应用程序就是可用的。
- en: '**Running the Pageview App in Multiple Replicas**'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '**在多个副本中运行Pageview应用程序**'
- en: The Pageview app can certainly work with a single replica. However, in a production
    environment, high availability is essential and is achieved by maintaining multiple
    replicas across nodes to avoid single points of failure. (This will be covered
    in detail in upcoming chapters.)
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: Pageview应用程序当然可以使用单个副本运行。然而，在生产环境中，高可用性是必不可少的，并且通过在节点之间维护多个副本来避免单点故障来实现。（这将在接下来的章节中详细介绍。）
- en: 'In Kubernetes, to ensure the high availability of an application, we can simply
    increase the replica number. Follow these steps to do so:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，为了确保应用程序的高可用性，我们可以简单地增加副本数量。按照以下步骤来做：
- en: Modify the Pageview YAML to change `replicas` to `3`.
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改Pageview YAML将`replicas`更改为`3`。
- en: Apply these changes by running `kubectl apply -f <pageview app yaml>`.
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`kubectl apply -f <pageview应用yaml>`来应用这些更改。
- en: By running `kubectl get pod`, you should be able to see three Pageview pods
    running.
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`kubectl get pod`，您应该能够看到三个Pageview pod正在运行。
- en: Access the URL shown in the output of the `minikube service` command multiple
    times.
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`minikube service`命令输出中显示的URL多次访问。
- en: Check the logs of each pod to see whether the requests are handled evenly among
    the three pods.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 检查每个pod的日志，看看请求是否均匀地分布在三个pod之间。
- en: Now, let's verify the high availability of the Pageview app. Terminate any arbitrary
    pods continuously while keeping one healthy pod. You can achieve this manually
    or automatically by writing a script. Alternatively, you can open another terminal
    and check whether the Pageview app is always accessible.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们验证Pageview应用程序的高可用性。在保持一个健康的pod的同时连续终止任意的pod。您可以通过手动或编写脚本来实现这一点。或者，您可以打开另一个终端，检查Pageview应用程序是否始终可访问。
- en: 'If you opt for writing scripts to terminate the pods, you will see results
    similar to the following:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择编写脚本来终止pod，您将看到类似以下的结果：
- en: '![Figure 2.29: Killing pods via a script'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.29：通过脚本杀死pod'
- en: '](image/B14870_02_29.jpg)'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_29.jpg)'
- en: 'Figure 2.29: Killing pods via a script'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.29：通过脚本杀死pod
- en: 'Assuming that you take a similar approach and write a script to check whether
    the application is online, you should see an output similar to the following:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您采用类似的方法并编写脚本来检查应用程序是否在线，您应该会看到类似以下的输出：
- en: '![Figure 2.30: Repeatedly accessing the application via the script'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.30：通过脚本重复访问应用程序'
- en: '](image/B14870_02_30.jpg)'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_02_30.jpg)'
- en: 'Figure 2.30: Repeatedly accessing the application via the script'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.30：通过脚本重复访问应用程序
- en: Note
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下地址找到：[https://packt.live/304PEoD](https://packt.live/304PEoD)。
- en: A Glimpse into the Advantages of Kubernetes for Multi-Node Clusters
  id: totrans-618
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes多节点集群优势一览
- en: You can only truly appreciate the advantages of Kubernetes after seeing it in
    the context of a multi-node cluster. This chapter, like many of the other chapters
    in this book, uses a single-node cluster (Minikube environment) to demonstrate
    the features that Kubernetes provides. However, in a real-world production environment,
    Kubernetes is deployed with multiple workers and master nodes. Only then can you
    ensure that a fault in a single node won't impact the general availability of
    the application. And reliability is just one of the many benefits that a multi-node
    Kubernetes cluster can bring to us.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在多节点集群的环境中才能真正体会到Kubernetes的优势。本章以单节点集群（Minikube环境）来演示Kubernetes提供的功能，就像本书的许多其他章节一样。然而，在真实的生产环境中，Kubernetes是部署在多个工作节点和主节点上的。只有这样，您才能确保单个节点的故障不会影响应用程序的一般可用性。可靠性只是多节点Kubernetes集群可以为我们带来的众多好处之一。
- en: But wait – isn't it true that we can implement applications and deploy them
    in a highly available manner *without using Kubernetes*? That's true, but that
    usually comes with a lot of management hassle, both in terms of managing the application
    as well as the infrastructure. For example, during the initial Deployment, you
    may have to intervene manually to ensure that all redundant containers are not
    running on the same machine. In the case of a node failure, you will have to not
    only ensure that a new replica is respawned properly but to guarantee high availability,
    you also need to ensure that the new one doesn't land on the nodes that are already
    running existing replicas. This can be achieved either by using a DevOps tool
    or injecting logic on the application side. However, either way is very complex.
    Kubernetes provides a unified platform that we can use to wire apps to proper
    nodes by describing the high availability features we want using Kubernetes primitives
    (API objects). This pattern frees the minds of application developers, as they
    only need to consider how to build their applications. Features that are required
    for high availability, such as failure detection and recovery, are taken care
    of by Kubernetes under the hood.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等 - 难道我们不是可以在*不使用Kubernetes*的情况下实现应用程序并以高可用的方式部署它们吗？这是真的，但通常会伴随着大量的管理麻烦，无论是在管理应用程序还是基础设施方面。例如，在初始部署期间，您可能需要手动干预，以确保所有冗余容器不在同一台机器上运行。在节点故障的情况下，您不仅需要确保新的副本被正确地重新生成，还需要确保新的副本不会落在已经运行现有副本的节点上。这可以通过使用DevOps工具或在应用程序端注入逻辑来实现。然而，无论哪种方式都非常复杂。Kubernetes提供了一个统一的平台，我们可以使用它来通过描述我们想要的高可用特性（Kubernetes原语（API对象））将应用程序连接到适当的节点。这种模式使应用程序开发人员的思维得到解放，因为他们只需要考虑如何构建他们的应用程序。Kubernetes在幕后处理了高可用性所需的功能，如故障检测和恢复。
- en: Summary
  id: totrans-621
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we used Minikube to provision a single-node Kubernetes cluster
    and gave a high-level overview of Kubernetes' core components, as well as its
    key design rationale. After that, we migrated an existing Docker container to
    Kubernetes and explored some basic Kubernetes API objects, such as pods, Services,
    and Deployments. Lastly, we intentionally broke a Kubernetes cluster and restored
    it one component at a time, which allowed us to understand how the different Kubernetes
    components work together to get a pod up and running on a node.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用Minikube来提供单节点Kubernetes集群，并对Kubernetes的核心组件以及其关键设计原理进行了高层概述。之后，我们将现有的Docker容器迁移到Kubernetes，并探索了一些基本的Kubernetes
    API对象，如pod、服务和部署。最后，我们有意破坏了一个Kubernetes集群，并逐个恢复了它的组件，这使我们能够了解不同的Kubernetes组件是如何协同工作的，以便在节点上启动和运行一个pod。
- en: Throughout this chapter, we have used kubectl to manage our cluster. We provided
    a quick introduction to this tool, but in the following chapter, we will take
    a closer look at this powerful tool and explore the various ways in which we can
    use it.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个本章中，我们使用kubectl来管理我们的集群。我们对这个工具进行了快速介绍，但在接下来的章节中，我们将更仔细地了解这个强大的工具，并探索我们可以使用它的各种方式。
