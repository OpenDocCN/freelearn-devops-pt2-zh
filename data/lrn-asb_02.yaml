- en: Installing and Running Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和运行Ansible
- en: Now that we know a little about the background of Ansible, we will work on installing
    it and, once installed, we will run our first set of playbooks against a test
    virtual machine running CentOS 7\.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Ansible的背景有了一些了解，我们将开始安装它，并且一旦安装完成，我们将对运行CentOS 7的测试虚拟机运行我们的第一组playbooks。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to install Ansible on macOS and Linux
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在macOS和Linux上安装Ansible
- en: Running Ansible on Windows 10 Professional using the Linux subsystem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows 10专业版上使用Linux子系统运行Ansible
- en: Launching a test virtual machine
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动一个测试虚拟机
- en: An introduction to playbooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: playbooks简介
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be installing Ansible, so you will need a machine capable
    of running it. I will go into more details about these requirements in the next
    part of the chapter. We will also be using Vagrant to launch a virtual machine
    locally. There is a section that walks through installing Vagrant as well as downloading
    a CentOS 7 Vagrant box, which is around 400 MB.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将安装Ansible，因此您需要一台能够运行它的机器。我将在本章的下一部分详细介绍这些要求。我们还将使用Vagrant在本地启动一个虚拟机。有一节介绍了安装Vagrant以及下载一个大小约为400
    MB的CentOS 7 Vagrant box。
- en: You can find complete versions of all of the playbooks in the GitHub repository
    that accompanies this book at [https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter02](https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter02).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书附带的GitHub存储库中找到所有playbooks的完整版本[https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter02](https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter02)。
- en: 'You can also find the code bundle in author''s repository: [https://github.com/russmckendrick/learn-ansible-fundamentals-of-ansible-2x](https://github.com/russmckendrick/learn-ansible-fundamentals-of-ansible-2x).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在作者的存储库中找到代码包：[https://github.com/russmckendrick/learn-ansible-fundamentals-of-ansible-2x](https://github.com/russmckendrick/learn-ansible-fundamentals-of-ansible-2x)。
- en: Installing Ansible
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Ansible
- en: Let's dive straight in and install Ansible. Throughout this book, I will be
    assuming that you are running a macOS host machine running macOS High Sierra or
    a Linux machine with Ubuntu 18.04 LTS installed. While we will cover running Ansible
    on Windows 10 Professional using the Linux subsystem for Windows, using Windows
    as a host machine will not be supported in this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接开始安装Ansible。在本书中，我将假设您正在运行macOS High Sierra的macOS主机机器，或者安装了Ubuntu 18.04
    LTS的Linux机器。虽然我们将涵盖在Windows 10专业版上使用Linux子系统运行Ansible，但本书不支持使用Windows作为主机机器。
- en: Installing on macOS
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在macOS上安装
- en: There are a few different ways you can install Ansible on your macOS High Sierra
    host machine. I will cover them both.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在macOS High Sierra主机上以几种不同的方式安装Ansible。我将涵盖它们两种。
- en: As we are discussing two different ways of installing Ansible, I would recommend
    reading through this section and also the *Pros and cons* section at the end before
    choosing which installation method to use on your own machine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在讨论两种不同的安装方式，我建议在选择自己机器上的安装方法之前，先阅读本节以及最后的*优缺点*部分。
- en: Homebrew
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Homebrew
- en: The first installation method is to use a package called Homebrew.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种安装方法是使用一个叫做Homebrew的软件包。
- en: Homebrew is a package manager of macOS. It can be used to install command-line
    tools and also desktop packages. It describes itself as *The missing package manager
    for macOS* and it is normally one of the first tools I install after a clean installation
    or when getting a new computer. You can find out more about the project at [https://brew.sh/](https://brew.sh/).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Homebrew是macOS的软件包管理器。它可以用来安装命令行工具和桌面软件包。它自称为*macOS的缺失软件包管理器*，通常是我在干净安装或获得新电脑后安装的第一个工具之一。您可以在[https://brew.sh/](https://brew.sh/)找到更多关于该项目的信息。
- en: 'To install Ansible using Homebrew, you first need to install Homebrew. To do
    this, run the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Homebrew安装Ansible，您首先需要安装Homebrew。要做到这一点，请运行以下命令：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At each step of the installation process, the installer will tell you exactly
    what it is going to do and also prompt you for any additional information it needs
    from you in order to complete the installation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程的每个步骤，安装程序都会告诉您它将要做什么，并提示您提供任何它需要的额外信息，以便完成安装。
- en: 'Once installed, or if you already have Homebrew installed, run the following
    commands to update your list of packages and also check that your Homebrew installation
    is optimal:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，或者如果您已经安装了Homebrew，请运行以下命令来更新软件包列表，并检查您的Homebrew安装是否最佳：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Depending on how new your installation is, or when you last used it, you might
    see a different output to the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的安装时间或上次使用的时间，您可能会看到与以下截图不同的输出：
- en: '![](assets/e7098ac5-a5b9-4284-a9c4-0f78833b94a4.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e7098ac5-a5b9-4284-a9c4-0f78833b94a4.png)'
- en: 'Next, we can check what packages Homebrew provides for Ansible by running the
    following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过运行以下命令来检查Homebrew为Ansible提供了哪些软件包：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see from the results in the following screenshot, there are several
    packages returned in the search:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下截图中看到的结果，搜索返回了几个软件包：
- en: '![](assets/4f75c86c-ed03-493a-ab3a-d81ceb483151.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4f75c86c-ed03-493a-ab3a-d81ceb483151.png)'
- en: 'We just want the Ansible package. You can find out more about the package by
    running the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要Ansible软件包。您可以通过运行以下命令了解更多关于该软件包的信息：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can see the results of the command in the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下截图中看到命令的结果：
- en: '![](assets/f2f7ce93-575f-4e4b-bafc-6d183b63b066.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f2f7ce93-575f-4e4b-bafc-6d183b63b066.png)'
- en: As you can see, the command returns information on the version of the package
    that will be installed, as well as details on where you can see the code for the
    formula that installs the package. In our case, you can view details of the formula
    at [https://github.com/Homebrew/homebrew-core/blob/master/Formula/ansible.rb](https://github.com/Homebrew/homebrew-core/blob/master/Formula/ansible.rb).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该命令返回将要安装的软件包的版本信息，以及有关在哪里可以查看安装软件包的公式代码的详细信息。在我们的情况下，您可以在[https://github.com/Homebrew/homebrew-core/blob/master/Formula/ansible.rb](https://github.com/Homebrew/homebrew-core/blob/master/Formula/ansible.rb)上查看公式的详细信息。
- en: 'To install Ansible using Homebrew, we simply have to run the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Homebrew安装Ansible，我们只需运行以下命令：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will download and install all of the dependencies and then the Ansible
    package itself. Depending on how much of the dependencies are already installed
    on your machine, this may take a few minutes. Once installed, you should see something
    like the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载并安装所有依赖项，然后安装Ansible软件包本身。根据您的计算机上已安装的依赖项数量，这可能需要几分钟。安装完成后，您应该看到类似以下屏幕截图的内容：
- en: '![](assets/20eedb32-0c65-4c4a-aca8-739c34af7c30.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/20eedb32-0c65-4c4a-aca8-739c34af7c30.png)'
- en: As you can see from the preceding screenshot, Homebrew is quite verbose in its
    output, giving you both feedback on what it is doing and details on how to use
    the packages it installs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的屏幕截图中所见，Homebrew在输出中非常详细，为您提供了它正在做什么以及如何使用它安装的软件包的详细信息。
- en: The pip method
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pip方法
- en: The second method, `pip`, is a more traditional approach to installing and configuring
    a Python package.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法`pip`是一种更传统的安装和配置Python软件包的方法。
- en: '`pip` is a package manager for Python software. It is a recursive acronym for
    **pip install packages**. It is a good frontend for installing packages from the
    **Python Package Index** (**PyPI**). You can find the index at [https://pypi.python.org/pypi/](https://pypi.python.org/pypi/).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip`是Python软件的软件包管理器。这是**pip install packages**的递归缩写。这是从**Python Package Index**
    (**PyPI**)安装软件包的良好前端。您可以在[https://pypi.python.org/pypi/](https://pypi.python.org/pypi/)上找到索引。'
- en: 'Depending on what you have installed on your machine, you may have to install
    `pip`. To do this, run the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您在计算机上安装了什么，您可能需要安装`pip`。要做到这一点，请运行以下命令：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will install `pip` using the `easy_install` installer, which ships with
    macOS by default. Once installed, you can install Ansible by running the following
    command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用macOS默认附带的`easy_install`安装程序安装`pip`。安装完成后，您可以通过运行以下命令安装Ansible：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will be prompted for your password, as we are using the `sudo` command,
    like Homebrew. This command will download and install all of the prerequisites
    needed to run Ansible on your system. While it is as verbose as Homebrew, its
    output contains information on what it has done, rather than hints on what do
    to next:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了`sudo`命令，因此系统会提示您输入密码，就像Homebrew一样。此命令将下载并安装运行Ansible所需的所有先决条件。虽然它与Homebrew一样详细，但其输出包含有关其所做的工作的信息，而不是下一步该做什么的提示：
- en: '![](assets/18f6320e-0289-407a-a27f-61c8b0f0ed55.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/18f6320e-0289-407a-a27f-61c8b0f0ed55.png)'
- en: As you can see, a lot of the requirements were already satisfied.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，许多要求已经得到满足。
- en: Pros and cons
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优缺点
- en: So, now that we have covered some of the different ways of installing Ansible
    on macOS, which is best? Well, there is no real answer to this as it comes down
    to personal preference. Both methods will install the latest versions of Ansible.
    However, Homebrew tends to be a week or two behind the current release.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经介绍了在macOS上安装Ansible的一些不同方法，哪种方法最好？嗯，这没有真正的答案，因为这取决于个人偏好。这两种方法都将安装最新版本的Ansible。但是，Homebrew往往会比当前版本晚一两周。
- en: 'If you have a lot of packages already installed using Homebrew, then you will
    already be used to running the following commands:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经使用Homebrew安装了许多软件包，那么您已经习惯于运行以下命令：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Every once in a while, do update your installed packages to the latest. If you
    already do this, then it would make sense to use Homebrew to manage your Ansible
    installation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔更新已安装的软件包到最新版本。如果您已经这样做了，那么使用Homebrew来管理您的Ansible安装就是有意义的。
- en: 'If you are not a Homebrew user and want to make sure that you immediately have
    the latest version installed, then use the `pip` command to install Ansible. Upgrading
    to the latest version of Ansible is as simple as running the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不是Homebrew用户，并且想要确保立即安装最新版本，则使用`pip`命令安装Ansible。升级到最新版本的Ansible就像运行以下命令一样简单：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I have found that I need to use the `--ignore-installed setuptools` flag, as
    there are problems and conflicts with the version managed by macOS and the one
    which is part of Ansible updates. I have not known this to cause any problems.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现我需要使用`--ignore-installed setuptools`标志，因为macOS管理的版本与Ansible更新的版本存在问题和冲突。我没有发现这会引起任何问题。
- en: 'Should you need to, then you can install older versions of Ansible using both
    Homebrew and `pip`. To do this using Homebrew, you just need to remove the current
    version by running the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要的话，您可以使用Homebrew和`pip`安装旧版本的Ansible。要使用Homebrew进行此操作，只需运行以下命令来删除当前版本：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, you can install an earlier version of the package by running the following
    command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过运行以下命令安装软件包的早期版本：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Or, for an even earlier version, you can use the command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，要安装更早的版本，您可以使用以下命令：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For details on exactly which version of the package is going to be installed,
    you can run one of the following two commands:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解要安装的软件包的确切版本的详细信息，您可以运行以下两个命令中的一个：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'While this will install an earlier version, you do not get much choice in which
    version is installed. If you really need an exact version, you can use the `pip`
    command to install it. For example, to install Ansible 2.3.1.0, you would need
    to run:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这将安装一个早期版本，但您在安装哪个版本方面没有太多选择。如果您确实需要一个确切的版本，可以使用`pip`命令进行安装。例如，要安装Ansible
    2.3.1.0，您需要运行：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You should never need to do this. However, I have found that on some occasions,
    I have had to downgrade to help debug *quirks* in my playbooks introduced by upgrading
    to a later version.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不应该需要这样做。但是，我发现在某些情况下，我不得不降级来帮助调试由升级到较新版本引入的*怪癖*。
- en: As mentioned, I spend the bulk of my time in front of a macOS machine in some
    form or other, so which of the two methods do I use? Primarily, I use Homebrew,
    as I have several other tools installed using Homebrew. However, if I need to
    roll back to a previous version, I use `pip` and then return to Homebrew once
    the issue is resolved.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，我大部分时间都是在macOS机器前度过的，所以我使用哪种方法呢？主要是使用Homebrew，因为我安装了几个其他工具。但是，如果我需要回滚到以前的版本，我会使用`pip`，然后问题解决后再返回到Homebrew。
- en: Installing on Linux
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上安装
- en: There are a few different ways of installing Ansible on Ubuntu 18.04\. However,
    I am only going to cover one of them here. While there are packages available
    for Ubuntu from which you can install with `apt`, they tend to quickly become
    out of date and are typically behind the current release.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu 18.04上安装Ansible有几种不同的方法。然而，我这里只会介绍其中一种。虽然Ubuntu有可用的软件包可以使用`apt`安装，但它们往往很快就会过时，并且通常落后于当前版本。
- en: '**Advanced Packaging Tool**  (**APT**) is the package manager that ships with
    Debian-based systems, including Ubuntu. It is used to manage `.deb` files.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级打包工具**（**APT**）是Debian系统的软件包管理器，包括Ubuntu。它用于管理`.deb`文件。'
- en: 'Because of this, we will be using `pip`. The first thing to do is install `pip`,
    and this can be done by running the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用`pip`。首先要做的是安装`pip`，可以通过运行以下命令来完成：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once `pip` is installed, the instructions for installing Ansible are the same
    as installing on macOS. Simply run the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了`pip`，安装Ansible的说明与在macOS上安装相同。只需运行以下命令：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will download and then install Ansible and its requirements, as shown
    in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载并安装Ansible及其要求，如下截图所示：
- en: '![](assets/80c75687-b413-4b5d-8198-80961d084820.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/80c75687-b413-4b5d-8198-80961d084820.png)'
- en: 'Once installed, you can upgrade it by using the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以使用以下命令升级它：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that this time, we do not have to ignore anything as there shouldn''t
    be any problems with the default installation. Also, downgrading Ansible is the
    same command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这一次我们不需要忽略任何内容，因为默认安装不应该有任何问题。此外，降级Ansible是相同的命令：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding commands should work on most Linux distributions, such as CentOS,
    Red Hat Enterprise Linux, Debian, and, Linux Mint.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令应该适用于大多数Linux发行版，如CentOS、Red Hat Enterprise Linux、Debian和Linux Mint。
- en: Installing on Windows 10 Professional
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows 10专业版上安装
- en: The last platform we are going to cover is Windows 10 Professional; well, sort
    of. There is no supported way of running an Ansible controller on a Windows machine
    natively. Because of this, we will be using the Windows subsystem for Linux.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要介绍的最后一个平台是Windows 10专业版；嗯，有点像。没有支持的方法可以在Windows机器上本地运行Ansible控制器。因此，我们将使用Windows的Linux子系统。
- en: This is a feature, which, at the time of writing, is in beta, and is only available
    to Windows 10 Professional users. To enable it, you first need to enable developer
    mode. To do this, open the Windows 10 Settings app and then toggle Developer mode,
    which can be found under UPDATE & SECURITY, and then For Developers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个功能，在撰写本文时，它处于测试版，只适用于Windows 10专业版用户。要启用它，首先需要启用开发人员模式。要做到这一点，打开Windows
    10设置应用，然后切换到开发人员模式，可以在更新和安全下找到，然后点击开发人员。
- en: 'Once Developer mode has been enabled, you will be able to enable the shell.
    To do this, open Control Panel, then click on Programs and Features, and then
    on Turn Windows features on or off. In the list of features, you should see Windows
    Subsystem for Linux (Beta) listed. Tick the box next to it and then OK. You will
    be prompted to reboot your machine. Following the reboot, click on the Start menu
    and type `bash`. This will trigger the installation process. You should see something
    like the following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 启用开发人员模式后，您将能够启用shell。要做到这一点，打开控制面板，然后点击程序和功能，然后点击打开或关闭Windows功能。在功能列表中，您应该看到列出了Windows子系统的Linux（Beta）。选中它旁边的框，然后点击确定。您将被提示重新启动计算机。重新启动后，点击开始菜单，然后键入`bash`。这将触发安装过程。您应该看到类似以下截图的内容：
- en: '![](assets/948c2393-4d7e-4297-b4eb-9b0aecb6b589.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/948c2393-4d7e-4297-b4eb-9b0aecb6b589.png)'
- en: 'Once downloaded, it will extract and install the subsystem. You will be asked
    a few questions. As needed, the entire process will take between 5 and 10 minutes.
    Once installed, you should now have a full Ubuntu 16.04 system running on your
    Windows machine. You can check this by running the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，它将提取并安装子系统。您将被问到一些问题。根据需要，整个过程将需要5到10分钟。安装完成后，您现在应该在Windows机器上运行一个完整的Ubuntu
    16.04系统。您可以通过运行以下命令来检查：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following screenshot shows the output for the preceding command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了上述命令的输出：
- en: '![](assets/375eaa66-603d-42ec-bf86-2c3a6f7bd8ad.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/375eaa66-603d-42ec-bf86-2c3a6f7bd8ad.png)'
- en: 'From here, you can run the following commands to install Ansible:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，您可以运行以下命令来安装Ansible：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following screenshot shows the output for the preceding command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了上述命令的输出：
- en: '![](assets/d8aef965-0e43-4577-80f1-cb3e6de99982.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d8aef965-0e43-4577-80f1-cb3e6de99982.png)'
- en: As you can see, everything works as if you were running an Ubuntu machine, allowing
    you to run and maintain your Ansible installation in exactly the same way.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一切都像在运行Ubuntu机器一样工作，使您能够以完全相同的方式运行和维护您的Ansible安装。
- en: The **Windows Subsystem for Linux** (**WSL**) is not running on a virtual machine.
    It is a full native Linux experience baked right into Windows 10 Professional.
    It is targeted at developers who need to run Linux tools as part of their toolchain.
    While the overall support for Linux commands is excellent, I would recommend reading
    through the FAQs written and maintained by Microsoft to get an idea of the limits
    and also any quirks of the subsystem. The FAQs can be found at [https://docs.microsoft.com/en-us/windows/wsl/faq/](https://docs.microsoft.com/en-us/windows/wsl/faq/).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows子系统Linux**（**WSL**）并不是在虚拟机上运行。它是完全嵌入到Windows 10专业版中的本机Linux体验。它针对需要作为工具链一部分运行Linux工具的开发人员。虽然对Linux命令的整体支持非常出色，但我建议阅读由微软撰写和维护的FAQ，以了解子系统的限制和任何怪癖。FAQ可以在[https://docs.microsoft.com/en-us/windows/wsl/faq/](https://docs.microsoft.com/en-us/windows/wsl/faq/)找到。'
- en: As already mentioned, while this is a viable way of running an Ansible control
    node on a Windows-based machine, some of the other tools we will be covering in
    future chapters may not work with Windows. So while you may follow along using
    the Ubuntu instructions, some parts may not work. Where possible, I will add a
    note saying that it may not work on Windows-based systems.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，虽然这是在Windows机器上运行Ansible控制节点的一种可行方式，但我们将在未来的章节中涵盖的一些其他工具可能无法在Windows上运行。因此，虽然您可以按照Ubuntu的说明进行操作，但某些部分可能无法正常工作。在可能的情况下，我会添加一条说明，说明它可能无法在基于Windows的系统上运行。
- en: Launching a virtual machine
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动虚拟机
- en: In order to launch a virtual machine to run our first set of Ansible commands
    against, we are going to use Vagrant.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动一个虚拟机来运行我们的第一组Ansible命令，我们将使用Vagrant。
- en: Please note that these instructions may not work if you are running WSL.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您正在运行WSL，这些说明可能不起作用。
- en: Vagrant is a virtual machine manager developed by HashiCorp. It can manage both
    local and remote virtual machines, and supports hypervisors, such as VirtualBox,
    VMware, and Hyper-V.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant是由HashiCorp开发的虚拟机管理器。它可以管理本地和远程虚拟机，并支持诸如VirtualBox、VMware和Hyper-V之类的hypervisors。
- en: 'To install Vagrant on macOS, we can use Homebrew along with cask. To install
    cask, run the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要在macOS上安装Vagrant，我们可以使用Homebrew和cask。要安装cask，运行以下命令：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: VirtualBox is an open source hypervisor for x86-based computers. It is currently
    being developed by Oracle and supports both software- and hardware-based virtualization.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: VirtualBox是面向基于x86的计算机的开源hypervisor。它目前由Oracle开发，并支持软件和硬件虚拟化。
- en: 'By default, Vagrant uses VirtualBox. Once cask is installed, you can use VirtualBox
    and Vagrant by running the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Vagrant使用VirtualBox。安装了cask后，您可以通过运行以下命令来使用VirtualBox和Vagrant：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To install on Ubuntu, you can run the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Ubuntu上安装，可以运行以下命令：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next up, if you don''t already have one, we need to generate a private and
    public key for your user. To do this, run the following command, but if you already
    have a key, you can skip this part:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果您还没有，我们需要为您的用户生成一个私钥和公钥。要做到这一点，运行以下命令，但如果您已经有一个密钥，可以跳过这部分：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will create a key and store it in the `.ssh` folder in your user directory.
    We will use this key to inject into our Vagrant managed CentOS 7 virtual machine.
    To launch the virtual machine or box, as Vagrant calls it, we need a `Vagrantfile`.
    This is the configuration that Vagrant uses to create and boot the box.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个密钥并将其存储在您的用户目录中的`.ssh`文件夹中。我们将使用此密钥注入到我们的Vagrant管理的CentOS 7虚拟机中。要启动虚拟机或box（正如Vagrant所称），我们需要一个`Vagrantfile`。这是Vagrant用来创建和启动box的配置。
- en: 'The `Vagrantfile` we are going to be using is shown in the following code.
    You can also find a copy in the `Chapter02` folder in the code examples that accompany
    this book and also in the GitHub repository, which can be found at [https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter02](https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter02):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的`Vagrantfile`如下所示。您还可以在本书附带的代码示例的`Chapter02`文件夹中找到副本，也可以在GitHub存储库中找到，地址为[https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter02](https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter02)：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see from the preceding file, there are a few things going on. First
    of all, in the top section, we are defining a few variables for the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的文件中可以看出，有一些事情正在进行。首先，在顶部部分，我们正在为以下内容定义一些变量：
- en: '`API_VERSION`: This is the Vagrant API version to use. This should stay at
    `2`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`API_VERSION`：这是要使用的Vagrant API版本。这应该保持为`2`。'
- en: '`BOX_NAME`: This is the base image we want to use. In our case, this is the
    official CentOS 7 Vagrant box image, which can be found at [https://app.vagrantup.com/centos/boxes/7](https://app.vagrantup.com/centos/boxes/7).'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOX_NAME`：这是我们想要使用的基本镜像。在我们的情况下，这是官方的CentOS 7 Vagrant box镜像，可以在[https://app.vagrantup.com/centos/boxes/7](https://app.vagrantup.com/centos/boxes/7)找到。'
- en: '`BOX_IP`: This is the private IP address of the machine we are launching. Typically,
    you shouldn''t need to hardcode the IP address, but in our case, we will need
    a resolvable hostname and also a fixed IP address for the examples in the next
    section of the chapter.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOX_IP`：这是我们要启动的机器的私有IP地址。通常情况下，您不应该需要硬编码IP地址，但在我们的情况下，我们将需要一个可解析的主机名和一个固定的IP地址，以便在本章的下一节中的示例中使用。'
- en: '`DOMAIN`: This is the domain name that is used to configure the hostname on
    the machine. We are using the [http://nip.io/](http://nip.io/) service. This provides
    free wildcard DNS entries. This means that our domain `192.168.50.4.nip.io` will
    resolve to `192.168.50.4`.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOMAIN`：这是用于配置机器主机名的域名。我们使用[http://nip.io/](http://nip.io/)服务。这提供了免费的通配符DNS条目。这意味着我们的域名`192.168.50.4.nip.io`将解析为`192.168.50.4`。'
- en: '`PRIVATE_KEY`: This is the path to your private key. This will be used to SSH
    into the virtual machine once launched.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRIVATE_KEY`：这是您的私钥的路径。一旦启动虚拟机，将用它来SSH进入虚拟机。'
- en: '`PUBLIC_KEY`:This is the path to your public key. When the machine is being
    launched, this will be injected into the host, which means that we can access
    it using our private key.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUBLIC_KEY`：这是你的公钥的路径。当机器正在启动时，这将被注入到主机中，这意味着我们可以使用我们的私钥访问它。'
- en: The next section takes the preceding values and configures the Vagrant box.
    We then define settings that are just for the two providers that the `Vagrantfile`
    supports. As you can see, the file will launch a box using either VirtualBox or,
    if you have it installed, VMware Fusion.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将采用前面的值并配置Vagrant框。然后我们定义了仅适用于`Vagrantfile`支持的两个提供者的设置。正如你所看到的，该文件将使用VirtualBox或者，如果你已经安装了它，VMware
    Fusion来启动一个框。
- en: For more information on the VMware provider plugin for Vagrant, visit [https://www.vagrantup.com/vmware/](https://www.vagrantup.com/vmware/).
    Please note that this part of Vagrant requires a license, which is chargeable,
    as well as requiring you to have VMware Fusion or Workstation installed on your
    host machine.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Vagrant的VMware提供者插件的更多信息，请访问[https://www.vagrantup.com/vmware/](https://www.vagrantup.com/vmware/)。请注意，Vagrant的这一部分需要许可证，需要收费，并且需要在主机机器上安装VMware
    Fusion或Workstation。
- en: 'Now that we have our `Vagrantfile`, we just need to run the following command
    to launch the Vagrant box:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`Vagrantfile`，我们只需要运行以下命令来启动Vagrant框：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you do not pass a provider along, it will default to using VirtualBox. If
    you have the VMware plugin, like me, you can run the following command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有传递提供者，它将默认使用VirtualBox。如果你像我一样有VMware插件，你可以运行以下命令：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It will take a few minutes while the appropriate box file is downloaded and
    the virtual machine is configured:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下载适当的框文件并配置虚拟机需要几分钟的时间：
- en: '![](assets/9749465b-0285-464c-a1d9-405f1a4dbb69.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9749465b-0285-464c-a1d9-405f1a4dbb69.png)'
- en: As you can see from the Terminal output, the launch process is very verbose
    and you receive informative feedback at each stage.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从终端输出中所看到的，启动过程非常详细，并且在每个阶段都会收到有用的反馈。
- en: 'Once the Vagrant box is launched, you can check connectivity to it by running
    the following commands. This will log you into the Vagrant box as the Vagrant
    user and check the details on the hostname and kernel:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Vagrant框被启动，你可以通过运行以下命令来检查与它的连接。这将以Vagrant用户的身份登录到Vagrant框，并检查主机名和内核的详细信息：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Your Terminal should look like the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你的终端应该看起来像这样：
- en: '![](assets/e847bd68-9500-4410-9e25-7b6cf0c52211.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e847bd68-9500-4410-9e25-7b6cf0c52211.png)'
- en: 'As you can see, because we have told Vagrant which private key to use when
    accessing the box, we have been let straight into the box and can run the commands
    without issue. However, we won''t be using the `vagrant ssh` command in the next
    section, which is why we needed to inject our public key into the host. Instead,
    we will be SSHing directly into the machine from our host machine. To test this,
    you should be able to run the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，因为我们已经告诉Vagrant在访问该框时使用哪个私钥，我们已经直接进入了该框，并且可以运行命令而没有问题。然而，在下一节中，我们将不会使用`vagrant
    ssh`命令，这就是为什么我们需要将我们的公钥注入到主机中。相反，我们将直接从我们的主机机器通过SSH连接到该机器。为了测试这一点，你应该能够运行以下命令：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should be asked to establish the authenticity of the host by typing `yes`.
    Once you are logged in, you will be able to run the following commands:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该被要求通过输入`yes`来建立主机的真实性。一旦你登录，你就可以运行以下命令：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Your Terminal should look like the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你的终端应该看起来像这样：
- en: '![](assets/690c1845-96f9-4f30-b298-193c874fe3b1.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/690c1845-96f9-4f30-b298-193c874fe3b1.png)'
- en: As you can see, we have resolved and connected to `192.168.50.4.nip.io` using
    the Vagrant user and have authenticated using our private key. Before we move
    on to the next section and try running Ansible for the first time, we should discuss
    Vagrant provisioners.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经使用Vagrant用户解析并连接到`192.168.50.4.nip.io`，并且已经使用我们的私钥进行了身份验证。在我们进入下一节并尝试第一次运行Ansible之前，我们应该讨论一下Vagrant
    provisioners。
- en: No doubt you will have already looked at the Vagrant website, which can be found
    at [http://vagrantup.com/](http://vagrantup.com/), and may have spotted that Vagrant
    actually supports Ansible out of the box. If we were to use the Ansible provisioner,
    then Vagrant would dynamically create a host inventory and run our playbook against
    the box as part of the launch process. Before we look at this, I believe it is
    important for us to understand how the host inventory works, so we will look at
    the Ansible provisioner in the next chapter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，你可能已经查看了Vagrant网站，网址是[http://vagrantup.com/](http://vagrantup.com/)，并且可能已经注意到Vagrant实际上支持Ansible。如果我们使用Ansible
    provisioner，那么Vagrant将动态创建一个主机清单，并在启动过程中针对该框运行我们的playbook。在我们看这个之前，我认为我们理解主机清单的工作方式是很重要的，所以我们将在下一章中看一下Ansible
    provisioner。
- en: Before then, however, let's take a look at some basic playbooks and how we can
    interact with our Vagrant box using Ansible.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在那之前，让我们来看一些基本的playbook以及我们如何使用Ansible与我们的Vagrant框进行交互。
- en: An introduction to playbooks
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: playbook简介
- en: Normally in IT, a playbook is a set of instructions run by someone when something
    happens; a little vague, I know, but stay with me. These range from everything
    to building and configuring new server instances, to how to deploy code updates
    and how to deal with problems when they occur.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在IT中，playbook通常是发生某事时由某人运行的一组指令；有点模糊，我知道，但请跟着我。这些范围从构建和配置新的服务器实例，到如何部署代码更新以及如何在出现问题时处理问题。
- en: In the traditional sense, a playbook is typically a collection of scripts or
    instructions for a user to follow and, while they are meant to introduce consistency
    and conformity across systems, even with the best intentions, this is almost never
    the case.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统意义上，playbook通常是用户遵循的一组脚本或指令，虽然它们旨在引入系统的一致性和一致性，但即使怀着最好的意图，这几乎从来没有发生过。
- en: This is where Ansible comes in. Using an Ansible playbook, you are basically
    saying apply these changes and commands against these sets of hosts rather than
    someone having to log in and start working their way through the runbook manually.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Ansible的用武之地。使用Ansible playbook，您基本上是在说应用这些更改和命令对这些主机集合，而不是让某人登录并手动开始运行操作手册。
- en: Before we run a playbook, let's discuss how we provide Ansible with a list of
    hosts to target. To do this, we will be using the `setup` command. This simply
    connects to a host and then fetches as much information on the host as it can.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行playbook之前，让我们讨论如何向Ansible提供要定位的主机列表。为此，我们将使用`setup`命令。这只是简单地连接到一个主机，然后尽可能多地获取有关主机的信息。
- en: Host inventories
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机清单
- en: To provide a list of hosts, we need to provide an inventory list. This is in
    the form of a hosts file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要提供主机列表，我们需要提供一个清单列表。这是以hosts文件的形式。
- en: 'In its simplest form, our hosts file could contain a single line:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，我们的hosts文件可以包含一行：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What this is telling Ansible is that the host we want to contact is `192.168.50.4.nip.io`
    and to use the username of `vagrant`. If we didn't provide the username, it would
    fall back to the user you are logged into your Ansible control host as, which
    in my case is simple—the user `russ`, which does not exist on the Vagrant box.
    There is a copy of the hosts file called `hosts-simple` in the `Chapter02` folder
    of the repository alongside the `Vagrantfile` we used to launch the Vagrant box.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Ansible的是，我们要联系的主机是`192.168.50.4.nip.io`，并且要使用用户名`vagrant`。如果我们没有提供用户名，它将退回到您作为Ansible控制主机登录的用户，就像在我的情况下一样——用户`russ`，这个用户在Vagrant框中不存在。在存储库的`Chapter02`文件夹中有一个名为`hosts-simple`的hosts文件的副本，与我们用来启动Vagrant框的`Vagrantfile`一起。
- en: 'To run the `setup` command, we need to run the following command from within
    the same folder where `hosts-simple` is stored:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`setup`命令，我们需要从存储`hosts-simple`的相同文件夹中运行以下命令：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should see some output which looks like the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一些类似以下的输出：
- en: '![](assets/8cf0984f-f09a-49ba-a141-12e7bad49015.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8cf0984f-f09a-49ba-a141-12e7bad49015.png)'
- en: As you can see from the preceding screenshot, Ansible has quickly found out
    a lot of information on our Vagrant box. From the screenshot, you can see both
    of the IP addresses configured on the machine, along with the IPv6 addresses.
    It has recorded the time and date and, if you scroll through your own output,
    you will see that there is a lot of information returned detailing the host.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从前面的屏幕截图中所看到的，Ansible很快就找到了我们的Vagrant框的大量信息。从屏幕截图中，您可以看到机器上配置的两个IP地址，以及IPv6地址。它记录了时间和日期，如果您滚动查看自己的输出，您将看到返回了大量详细的主机信息。
- en: 'Going back to the command we ran:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们运行的命令：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, we are loading the `hosts-simple` file using the `-i` flag.
    We could have also used `--inventory=hosts-simple`, which loads our inventory
    file. The next part of the command is the host to target. In our case, this is`192.168.50.4.nip.io`.
    The final part of the command, `-m`, tells Ansible to use the `setup` module.
    We could have also used `--module-name=setup`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们正在使用`-i`标志加载`hosts-simple`文件。我们也可以使用`--inventory=hosts-simple`，这样就加载了我们的清单文件。命令的下一部分是要目标主机。在我们的情况下，这是`192.168.50.4.nip.io`。命令的最后一部分`-m`告诉Ansible使用`setup`模块。我们也可以使用`--module-name=setup`。
- en: 'This means that the full command, if we didn''t use shorthand, would be:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果我们没有使用简写，完整的命令将是：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As already mentioned, the `hosts-simple` file is as basic as we can get it.
    The following is a more common host inventory file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`hosts-simple`文件是我们可以得到的最基本的。以下是一个更常见的主机清单文件：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There is a copy of the file, called just `hosts`, in the same folder as the
    `hosts-simple` file. As you can see, there is a lot more going on, so let's quickly
    work through it from top to bottom.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在与`hosts-simple`文件相同的文件夹中有一个名为`hosts`的文件的副本。正如您所看到的，有很多事情要做，所以让我们快速地从上到下地进行一下工作。
- en: 'The first line defines our individual host. Unlike the simple example, we are
    going to be calling our `hosts box` and using `ansible_host`, so we are giving
    Ansible details of where it can SSH to. This means that we can now use the name
    box when referring to `192.168.50.4.nip.io`. This means our command would now
    look something like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了我们的单个主机。与简单示例不同，我们将称呼我们的`hosts box`并使用`ansible_host`，因此我们正在向Ansible提供它可以SSH到的详细信息。这意味着我们现在可以在引用`192.168.50.4.nip.io`时使用名称box。这意味着我们的命令现在看起来像这样：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next up in the file, we are creating a group of hosts called `boxes` and, in
    that group, we are adding our single host `box`. This means that we can also run:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的下一步是创建一个名为`boxes`的主机组，在该组中，我们添加了我们的单个主机`box`。这意味着我们也可以运行：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If we had more than just a single host in the group, then the preceding command
    would have looped through all of them. The final section of the `hosts` file sets
    up some common configuration options for all of the hosts in the `boxes` group.
    In this case, we are telling Ansible that all of the hosts in the group are using
    SSH, the user is `vagrant`, the private key at `~/.ssh/id_rsa` should be used,
    and also to not check the host key when connecting.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的组中有不止一个主机，那么前面的命令将循环遍历所有这些主机。`hosts`文件的最后一部分为`boxes`组中的所有主机设置了一些常见的配置选项。在这种情况下，我们告诉Ansible该组中的所有主机都在使用SSH，用户是`vagrant`，应该使用`~/.ssh/id_rsa`的私钥，还告诉不要在连接时检查主机密钥。
- en: We will be revisiting the inventory host files in later chapters. From now on,
    we will be using the `hosts` file to target the `boxes` group.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中重新访问清单主机文件。从现在开始，我们将使用`hosts`文件来定位`boxes`组。
- en: Playbooks
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Playbooks
- en: 'In the previous section, running the `ansible` command allowed us to call a
    single module. In this section, we are going to look at calling several modules.
    The following playbook is called `playbook.yml`. It calls the `setup` module we
    called in the previous section and then uses the `debug` module to print a message
    to the screen:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，运行`ansible`命令允许我们调用单个模块。在本节中，我们将看看如何调用多个模块。以下playbook称为`playbook.yml`。它调用了我们在上一节中调用的`setup`模块，然后使用`debug`模块将消息打印到屏幕上：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before we start to break the configuration down, let''s take a look at the
    results of running the playbook. To do this, use the following command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始分解配置之前，让我们看一下运行playbook的结果。为此，请使用以下命令：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will connect to our Vagrant box, gather information on the system, and
    then return just the information we want in a message:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将连接到我们的Vagrant box，在系统上收集信息，然后以消息的形式返回我们想要的信息：
- en: '![](assets/3d8e67b7-be81-44c0-9ba5-0083ee8f84fb.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3d8e67b7-be81-44c0-9ba5-0083ee8f84fb.png)'
- en: The first thing you will notice about the playbook is that it is written in
    **YAML**, which is a recursive acronym that stands for **YAML Ain't Markup Language**.
    YAML was designed to be a human-readable data serialization standard that can
    be used by all programming languages. It is commonly used to help define configurations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您将注意到playbook的第一件事是它是用**YAML**编写的，这是一个递归缩写，代表**YAML不是标记语言**。YAML旨在成为一个可供所有编程语言使用的人类可读的数据序列化标准。它通常用于帮助定义配置。
- en: 'The indentation is very important in YAML as it is used to nest and define
    areas of the file. Let''s look at our playbook in more detail:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在YAML中缩进非常重要，因为它用于嵌套和定义文件的区域。让我们更详细地看一下我们的playbook：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: While these lines might not seem like much, they are used as document separators,
    as Ansible compiles all of the YAML files into a single file; more on that later.
    It is important to Ansible to know where one document ends and another begins.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些行看起来可能不多，但它们被用作文档分隔符，因为Ansible将所有YAML文件编译成单个文件；稍后会详细介绍。对于Ansible来说，知道一个文档何时结束，另一个文档何时开始是很重要的。
- en: 'Next up, we have the configuration for the playbook. As you can see, this is
    where the indentation starts to come into play:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有playbook的配置。正如您所看到的，这是缩进开始发挥作用的地方：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `-` tells Ansible that this is the start of a section. From there, key-value
    pairs are used. These are:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`-`告诉Ansible这是一个部分的开始。然后使用键值对。这些是：'
- en: '`hosts`: This tells Ansible the host or host group to target in the playbook.
    This must be defined in a host inventory like the ones we covered in the previous
    section.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hosts`: 这告诉Ansible在playbook中目标主机或主机组。这必须在主机清单中定义，就像我们在上一节中介绍的那样。'
- en: '`gather_facts`: This tells Ansible to run the `setup` module when it first
    connects to the host. This information is then available to the playbook during
    the remainder of the run.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gather_facts`: 这告诉Ansible在首次连接到主机时运行`setup`模块。然后在运行的其余时间内，此信息对playbook可用。'
- en: '`become`: This is present because we are connecting to our host as a basic
    user. In this case, the Vagrant user. Ansible may not have enough access privileges
    to execute some of the commands we are telling it to so this instructs Ansible
    to execute all of its commands as the root user.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`become`: 这是因为我们连接到主机时作为基本用户存在的。在这种情况下，Vagrant用户。Ansible可能没有足够的访问权限来执行我们告诉它的一些命令，因此这指示Ansible以root用户的身份执行其所有命令。'
- en: '`become_method`: This tells Ansible how to become the root user; in our case,
    we have a passwordless `sudo` configured by Vagrant so we are using `sudo`.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`become_method`: 这告诉Ansible如何成为root用户；在我们的情况下，Vagrant配置了无密码的`sudo`，所以我们使用`sudo`。'
- en: '`tasks`: These are the tasks we can tell Ansible to run when connected to the
    target host.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasks`: 这些是我们可以告诉Ansible在连接到目标主机时运行的任务。'
- en: 'You will notice that from here, we move the indentation across again. This
    defines another section of the configuration. This time it is for the tasks:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，您会注意到我们再次移动了缩进。这定义了配置的另一部分。这次是为了任务：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As we have already seen, the only task we are running is the `debug` module.
    This module allows us to display output in the Ansible playbook run stream you
    saw when we ran the playbook.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，我们正在运行的唯一任务是`debug`模块。此模块允许我们在运行playbook时显示输出。
- en: You may have already noticed that the information between the curly brackets
    are the keys from the `setup` module. Here, we are telling Ansible to substitute
    the value of each key wherever we use the key—we will be using this a lot in our
    playbooks. We will also be defining our own key values to use as part of our playbook
    runs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到花括号之间的信息是来自`setup`模块的键。在这里，我们告诉Ansible在使用键的任何地方替换每个键的值——我们将在我们的playbook中经常使用这个。我们还将定义自己的键值，以便在playbook运行中使用。
- en: 'Let''s extend our playbook by adding another task. The following can be found
    as `playbook02.yml`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加另一个任务来扩展我们的playbook。以下内容可以在`playbook02.yml`中找到：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As you can see, we have added a second task which calls the `yum` module. This
    module is designed to help us interact with the package manager used by CentOS
    and other Red Hat-based operating systems called `yum`. We are setting two key
    values here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们添加了第二个调用`yum`模块的任务。该模块旨在帮助我们与CentOS和其他基于Red Hat的操作系统使用的软件包管理器`yum`进行交互。我们在这里设置了两个关键值：
- en: '`name`: This is a wildcard. It tells Ansible to use all of the installed packages
    rather than just a single named package. For example, we could have just used
    something like HTTPD here to target just Apache.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 这是一个通配符。它告诉Ansible使用所有安装的软件包，而不仅仅是单个命名的软件包。例如，我们可以在这里只使用HTTPD来仅针对Apache。'
- en: '`state`: Here, we are telling Ansible to ensure the package we have defined
    in the name key is the `latest` version. As we have named all of the installed
    packages, this will update everything we have installed.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`: 在这里，我们告诉Ansible确保我们在名称键中定义的软件包是`latest`版本。由于我们已经命名了所有安装的软件包，这将更新我们安装的所有内容。'
- en: 'Run the playbook using:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行playbook：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will give us the following results:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下结果：
- en: '![](assets/8b59dcc9-f7f7-4c0f-b30f-21e34df5e69e.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8b59dcc9-f7f7-4c0f-b30f-21e34df5e69e.png)'
- en: 'The `yum` task has been marked as `changed` on the host `box`. This means that
    packages were updated. Running the same command again shows the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`yum`任务在主机`box`上被标记为`changed`。这意味着软件包已经更新。再次运行相同的命令会显示以下内容：'
- en: '![](assets/07d0d0b9-b6f0-40aa-8e1c-5f867cb1418a.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/07d0d0b9-b6f0-40aa-8e1c-5f867cb1418a.png)'
- en: As you can see, the `yum` task is now showing as `ok` on our host. This is because
    there are currently no longer any packages requiring updating.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`yum`任务现在在我们的主机上显示为`ok`。这是因为当前没有需要更新的软件包。
- en: 'Before we finish this quick look at playbooks, let''s do something more interesting.
    The following playbook, called `playbook03.yml`, adds installing, configuring,
    and starting the NTP service to our Vagrant box. It also adds a few new sections
    to our playbook as well as using a template:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成对playbooks的快速查看之前，让我们做一些更有趣的事情。下面的playbook，名为`playbook03.yml`，将安装、配置和启动NTP服务到我们的Vagrant
    box。它还向我们的playbook添加了一些新的部分，并使用了一个模板：
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Before we work through the additions to our playbook, let''s run it to get
    an idea of the feedback you get from Ansible:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过playbook的添加之前，让我们运行它，以了解你从Ansible那里得到的反馈：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following screenshot shows the output for the preceding command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前面命令的输出：
- en: '![](assets/db4b6a60-68a5-4f4f-8fea-3d589806a565.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/db4b6a60-68a5-4f4f-8fea-3d589806a565.png)'
- en: 'This time, we have three `changed` tasks. Running the playbook again shows
    the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们有三个`changed`任务。再次运行playbook会显示以下内容：
- en: '![](assets/92319ee8-6dec-4398-a651-359b21420272.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/92319ee8-6dec-4398-a651-359b21420272.png)'
- en: As expected, because we haven't changed the playbook or anything on the Vagrant
    box, there are no changes and Ansible is reporting everything as `ok`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，因为我们没有改变playbook或Vagrant box上的任何东西，所以没有任何变化，Ansible报告一切都是`ok`。
- en: Let's go back to our playbook and discuss the additions. You will notice that
    we have added two new sections, `vars` and `handlers`, as well as two new tasks,
    a second task which uses the `yum` module and the final task, which utilizes the
    `template` module.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的playbook并讨论这些添加。你会注意到我们添加了两个新的部分，`vars`和`handlers`，以及两个新的任务，第二个任务使用了`yum`模块，最后一个任务使用了`template`模块。
- en: 'The `vars` section allows us to configure our own key-value pairs. In this
    case, we are providing a list of NTP servers, which we will be using later in
    the playbook:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`vars`部分允许我们配置自己的键值对。在这种情况下，我们提供了一个NTP服务器列表，稍后将在playbook中使用：'
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see, we are actually providing four different values for the same
    key. These will be used in the `template` task. We could have also written this
    as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们实际上为相同的键提供了四个不同的值。这些将用于`template`任务。我们也可以这样写：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'However, this is a little more difficult to read. The new next section is `handlers`.
    A handler is a task that is assigned a name and called at the end of a playbook
    run depending on what tasks have changed:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这有点难以阅读。新的下一部分是`handlers`。处理程序是分配了一个名称的任务，并且根据任务的变化在playbook运行结束时调用：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In our case, the `restart ntp` handler uses the `service` module to restart
    `ntpd`. Next up, we have the two new tasks, starting with one which installs the
    NTP service and also the `ntpdate` package using `yum`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，`restart ntp`处理程序使用`service`模块来重新启动`ntpd`。接下来，我们有两个新任务，首先是一个安装NTP服务和`ntpdate`软件包的任务，使用`yum`：
- en: '[PRE49]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As we are installing two packages, we need a way to provide two different package
    names to the `yum` module so that we don't have to have two different tasks for
    each of the package installations. To achieve this, we are using the `with_items`
    command, as part of the task section. Note that this is in addition to the `yum`
    module and is not part of the module—you can tell this by the indentation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在安装两个软件包，我们需要一种方法来为`yum`模块提供两个不同的软件包名称，这样我们就不必为每个软件包安装编写两个不同的任务。为了实现这一点，我们使用了`with_items`命令，作为任务部分的一部分。请注意，这是`yum`模块的附加部分，并不是模块的一部分——你可以通过缩进来判断。
- en: The `with_items` command allows you to provide a variable or list of items to
    the task. Wherever `{{ item }}` is used, it will be replaced with the content
    of the `with_items` value.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`with_items`命令允许你为任务提供一个变量或项目列表。无论`{{ item }}`在哪里使用，它都将被`with_items`值的内容替换。'
- en: 'The final addition to the playbook is the following task:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: playbook的最后一个添加是以下任务：
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This task uses the `template` module. To read a template file from our Ansible
    controller, process it and upload the processed template to the host machine.
    Once uploaded, we are telling Ansible to notify the `restart ntp` handler if there
    have been any changes to the configuration file we are uploading.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务使用了`template`模块。从我们的Ansible控制器读取一个模板文件，处理它并上传处理后的模板到主机。一旦上传，我们告诉Ansible，如果配置文件有任何更改，就通知`restart
    ntp`处理程序。
- en: 'In this case, the template file is the `ntp.conf.j2` file in the same folder
    as the playbooks, as defined in the `src` option. This file looks like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，模板文件是与playbooks相同文件夹中的`ntp.conf.j2`文件，如`src`选项中定义的。这个文件看起来是这样的：
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The bulk of the file is the standard NTP configuration file, with the addition
    of a few Ansible parts. The first addition is the very first line:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的大部分是标准的NTP配置文件，还添加了一些Ansible部分。第一个添加是第一行：
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If this line wasn't there every time we ran Ansible, the file would be uploaded,
    which would count as a change and the `restart ntp` handler would be called, meaning
    that even if there were no changes, NTP would be restarted.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这一行，每次我们运行Ansible时，文件都会被上传，这将被视为一次变更，并且`restart ntp`处理程序将被调用，这意味着即使没有任何变化，NTP也会被重新启动。
- en: 'The next part loops through the `ntp_servers` values we defined in the `vars`
    section of the playbook:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分循环遍历了我们在playbook的`vars`部分中定义的`ntp_servers`值：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For each of the values, add a line that contains the server, then the value,
    and then `iburst`. You can see the output of this by SSHing into the Vagrant machine
    and opening `/etc/ntp.conf`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个值，添加一行包含服务器、然后是值，然后是`iburst`。您可以通过SSH连接到Vagrant机器并打开`/etc/ntp.conf`来查看此输出：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following screenshot shows the output for the preceding command:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前述命令的输出：
- en: '![](assets/1b5665fd-615b-479b-9087-f1652aa728ec.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1b5665fd-615b-479b-9087-f1652aa728ec.png)'
- en: As you can see from the preceding screenshot of the fully rendered file, we
    have the comment on the first line noting that the file is managed by Ansible
    and also the four lines containing the NTP servers to use.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 从完全呈现的文件的前述截图中可以看出，我们在第一行上有注释，指出该文件由Ansible管理，还有四行包含要使用的NTP服务器的内容。
- en: 'Finally, you can check that NTP is running as expected by running the following
    commands:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，您可以通过运行以下命令检查NTP是否按预期运行： '
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The following screenshot shows the output for the preceding command:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前述命令的输出：
- en: '![](assets/bf97de68-1d85-49c9-9183-50853e18938f.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bf97de68-1d85-49c9-9183-50853e18938f.png)'
- en: 'As you can see from the preceding output, NTP is loaded and running as expected.
    Let''s remove our Vagrant box and launch a fresh one by running the following
    command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 从前述输出中可以看出，NTP已加载并按预期运行。让我们通过运行以下命令删除Vagrant框架并启动一个新的框架：
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then launch the box again by running one of the following two commands:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过运行以下两个命令之一再次启动该框：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Once the box is up and running, we can run the final playbook with:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦框架启动运行，我们可以使用以下命令运行最终的playbook：
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'After a minute or two, you should receive the results of the playbook run.
    You should see five `changed` and six `ok`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一两分钟后，您应该会收到playbook运行的结果。您应该会看到五个`changed`和六个`ok`：
- en: '![](assets/375b83d8-6fe7-48c7-aece-748000af3802.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/375b83d8-6fe7-48c7-aece-748000af3802.png)'
- en: 'Running for the second time will just show five `ok`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次运行只会显示五个`ok`：
- en: '![](assets/eb40006e-dc8a-43bc-832a-bf17a0dec629.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/eb40006e-dc8a-43bc-832a-bf17a0dec629.png)'
- en: The reason why we got six `ok` on the first run and five `ok` on the second
    run is that nothing has changed since the first run. Therefore, the handler to
    restart NTP is never being notified so that task to restart the service never
    executes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次运行时得到六个`ok`，第二次运行时得到五个`ok`的原因是自第一次运行以来没有发生任何变化。因此，重启NTP的处理程序从未被通知，因此重新启动服务的任务从未执行。
- en: 'Once you have finished with the example playbooks, you can terminate the running
    box using:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 完成示例playbook后，您可以使用以下命令终止正在运行的框架：
- en: '[PRE59]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We will be using the box again in the following chapter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中再次使用该框。
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have taken our first steps with Ansible by installing locally
    and then, using Vagrant, launching a virtual machine to interact with. We learned
    about basic host inventory files and we used the Ansible command to execute a
    single task against our virtual machine.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过本地安装Ansible，然后使用Vagrant启动虚拟机进行了第一步。我们了解了基本的主机清单文件，并使用Ansible命令针对我们的虚拟机执行了单个任务。
- en: We then looked at playbooks, starting out with a basic playbook that returned
    some information on our target before then progressing to a playbook that updates
    all of the installed operating system packages before installing and configuring
    the NTP service.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们查看了playbooks，首先是一个基本的playbook，返回了有关我们目标的一些信息，然后进展到一个更新所有已安装的操作系统包并安装和配置NTP服务的playbook。
- en: In the next chapter, we are going to take a look at other Ansible commands we
    can use.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看其他可以使用的Ansible命令。
- en: Questions
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the command to install Ansible using `pip`?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pip`安装Ansible的命令是什么？
- en: 'True or false: You can choose exactly which version of Ansible to install or
    roll back to when using Homebrew.'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：在使用Homebrew时，您可以选择要安装或回滚到哪个版本的Ansible。
- en: 'True or false: The Windows Subsystem for Linux runs in a virtual machine.'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：Windows子系统运行在虚拟机中。
- en: Name three hypervisors that are supported by Vagrant.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出三个Vagrant支持的hypervisors。
- en: State and explain what a host inventory is.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 说明主机清单是什么。
- en: 'True or false: Indentation in YAML files is extremely important to their execution
    and isn''t just cosmetic.'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：YAML文件中的缩进对于它们的执行非常重要，而不仅仅是装饰性的。
- en: Update the final playbook to install a service of your choice and have it notify
    a handler to start the service with its default configuration.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新最终的playbook以安装您选择的服务，并通知处理程序以其默认配置启动服务。
- en: Further reading
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'In this chapter, we used the following Ansible modules, and you can find out
    more information on each module in the following links:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们使用了以下Ansible模块，你可以在以下链接中找到每个模块的更多信息：
- en: '`setup`: [http://docs.ansible.com/ansible/latest/setup_module.html](http://docs.ansible.com/ansible/latest/setup_module.html)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup`: [http://docs.ansible.com/ansible/latest/setup_module.html](http://docs.ansible.com/ansible/latest/setup_module.html)'
- en: '`debug`[:](http://docs.ansible.com/ansible/latest/setup_module.html) [http://docs.ansible.com/ansible/latest/debug_module.html](http://docs.ansible.com/ansible/latest/debug_module.html)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug`[:](http://docs.ansible.com/ansible/latest/setup_module.html) [http://docs.ansible.com/ansible/latest/debug_module.html](http://docs.ansible.com/ansible/latest/debug_module.html)'
- en: '`yum`: [http://docs.ansible.com/ansible/latest/yum_module.html](http://docs.ansible.com/ansible/latest/yum_module.html)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yum`: [http://docs.ansible.com/ansible/latest/yum_module.html](http://docs.ansible.com/ansible/latest/yum_module.html)'
- en: '`service`: [http://docs.ansible.com/ansible/latest/service_module.html](http://docs.ansible.com/ansible/latest/service_module.html)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service`: [http://docs.ansible.com/ansible/latest/service_module.html](http://docs.ansible.com/ansible/latest/service_module.html)'
