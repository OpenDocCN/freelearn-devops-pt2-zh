- en: Running Kubernetes on Multiple Clouds and Cluster Federation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多个云上运行Kubernetes和集群联邦
- en: 'In this chapter we''ll take it to the next level, and look at running Kubernetes
    on multiple clouds and cluster federation. A Kubernetes cluster is a close-knit
    unit in which all the components run in relative proximity and are connected by
    a fast network (a physical data center or cloud provider availability zone). This
    is great for many use cases, but there are several important use cases where systems
    need to scale beyond a single cluster. Kubernetes federation is a methodical way
    to combine multiple Kubernetes clusters and interact with them as a single entity.
    The topics we will cover include the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步探讨在多个云上运行Kubernetes和集群联邦。Kubernetes集群是一个紧密结合的单元，其中所有组件都在相对接近的地方运行，并通过快速网络（物理数据中心或云提供商可用区）连接。这对许多用例来说非常好，但有一些重要的用例需要系统扩展到超出单个集群的范围。Kubernetes联邦是一种系统化的方法，可以将多个Kubernetes集群组合在一起，并将它们视为单个实体进行交互。我们将涵盖的主题包括以下内容：
- en: A deep dive into what cluster federation is all about
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解集群联邦的全部内容
- en: How to prepare, configure, and manage a cluster federation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何准备、配置和管理集群联邦
- en: How to run a federated workload across multiple clusters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在多个集群上运行联合工作负载
- en: Understanding cluster federation
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解集群联邦
- en: Cluster federation is conceptually simple. You aggregate multiple Kubernetes
    clusters and treat them as a single logical cluster. There is a federation control
    plane that presents to clients a single unified view of the system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 集群联邦在概念上很简单。您可以聚合多个Kubernetes集群，并将它们视为单个逻辑集群。有一个联邦控制平面，向客户端呈现系统的单一统一视图。
- en: 'The following diagram demonstrates the big picture of Kubernetes cluster federation:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了Kubernetes集群联邦的整体情况：
- en: '![](Images/20ec9f25-71e9-4c28-b26c-bbb521b2dd32.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/20ec9f25-71e9-4c28-b26c-bbb521b2dd32.png)'
- en: 'The federation control plane consists of a federation API server and a federation
    controller manager that collaborate. The federated API server forwards requests
    to all the clusters in the federation. In addition, the federated controller manager
    performs the duties of the controller manager across all clusters by routing requests
    to the individual federation cluster members'' changes. In practice, cluster federation
    is not trivial and can''t be totally abstracted away. Cross-pod communication
    and data transfer may suddenly incur a massive latency and cost overhead. Let''s
    look at the use cases for cluster federation first, understand how the federated
    components and resources work, and then examine the hard parts: location affinity,
    cross-cluster scheduling, and federated data access.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦控制平面由联邦API服务器和联邦控制器管理器共同协作。联邦API服务器将请求转发到联邦中的所有集群。此外，联邦控制器管理器通过将请求路由到各个联邦集群成员的更改来执行控制器管理器的职责。实际上，集群联邦并不是微不足道的，也不能完全抽象化。跨Pod通信和数据传输可能会突然产生大量的延迟和成本开销。让我们首先看一下集群联邦的用例，了解联合组件和资源的工作方式，然后再来研究难点：位置亲和性、跨集群调度和联邦数据访问。
- en: Important use cases for cluster federation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群联邦的重要用例
- en: There are four categories of use cases that benefit from cluster federation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有四类用例受益于集群联邦。
- en: Capacity overflow
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容量溢出
- en: The public cloud platforms, such as AWS, GCE, and Azure, are great and provide
    many benefits, but they are not cheap. Many large organizations have invested
    a lot in their own data centers. Other organizations work with private service
    providers such as OVS, Rackspace, or Digital Ocean. If you have the operational
    capacity to manage and operate infrastructure on your own, it makes a lot of economic
    sense to run your Kubernetes cluster on your infrastructure rather than in the
    cloud. But what if some of your workloads fluctuate and require a lot more capacity
    for a relatively short amount of time?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 公共云平台，如AWS、GCE和Azure，非常好，并提供许多好处，但它们并不便宜。许多大型组织在自己的数据中心投入了大量资金。其他组织与私人服务提供商合作，如OVS、Rackspace或Digital
    Ocean。如果您有能力自行管理和操作基础设施，那么在自己的基础设施上运行Kubernetes集群比在云中运行更经济。但是，如果您的一些工作负载波动并且在相对短的时间内需要更多的容量呢？
- en: For example, your system may be hit especially hard on the weekends or maybe
    during holidays. The traditional approach is to just provision extra capacity.
    But in many dynamic situations, it is not easy. With capacity overflow, you can
    run the bulk of your work in a Kubernetes cluster running on an on-premise data
    center or with a private service provider and have a secondary cloud-based Kubernetes
    cluster running on one of the big platform providers. Most of the time, the cloud-based
    cluster will be shut down (stopped instances), but when the need arises you can
    elastically add capacity to your system by starting some stopped instances. Kubernetes
    cluster federation can make this configuration relatively straightforward. It
    eliminates a lot of headaches about capacity planning and paying for hardware
    that's not used most of the time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您的系统可能在周末或节假日受到特别严重的打击。传统方法是只是提供额外的容量。但在许多动态情况下，这并不容易。通过容量溢出，您可以在本地数据中心或私人服务提供商上运行Kubernetes集群中运行大部分工作，并在其中一个大型平台提供商上运行基于云的Kubernetes集群。大部分时间，基于云的集群将被关闭（停止实例），但在需要时，您可以通过启动一些停止的实例来弹性地为系统增加容量。Kubernetes集群联合可以使这种配置相对简单。它消除了许多关于容量规划和支付大部分时间未使用的硬件的头疼。
- en: This approach is sometimes called **cloud bursting**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有时被称为**云爆发**。
- en: Sensitive workloads
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敏感工作负载
- en: This is almost the opposite of capacity overflow. Maybe you've embraced the
    cloud-native lifestyle and your entire system runs on the cloud, but some data
    or workloads deal with sensitive information. Regulatory compliance or your organization's
    security policies may dictate that the data and workloads must run in an environment
    that's fully controlled by you. Your sensitive data and workloads may be subject
    to external auditing. It may be critical to ensure no information ever leaks from
    the private Kubernetes cluster to the cloud-based Kubernetes cluster. But it may
    be desirable to have visibility into the public cluster and the ability to launch
    non-sensitive workloads from the private cluster to the cloud-based cluster. If
    the nature of a workload can change dynamically from non-sensitive to sensitive
    then it needs to be addressed by coming up with a proper policy and implementation.
    For example, you may prevent workloads from changing their nature. Alternatively,
    you may migrate a workload that suddenly became sensitive and ensure that it doesn't
    run on the cloud-based cluster anymore. Another important instance is national
    compliance, where certain data is required by law to remain in and be accessed
    only from a designated geographical region (typically a country). In this case,
    a cluster must be created in that geographical region.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎是容量溢出的相反情况。也许您已经接受了云原生的生活方式，整个系统都在云上运行，但是一些数据或工作负载涉及敏感信息。监管合规性或您组织的安全政策可能要求数据和工作负载必须在完全由您控制的环境中运行。您的敏感数据和工作负载可能会受到外部审计。确保私有Kubernetes集群中的信息永远不会泄漏到基于云的Kubernetes集群可能至关重要。但是，希望能够查看公共集群并能够从私有集群启动非敏感工作负载可能是可取的。如果工作负载的性质可以动态地从非敏感变为敏感，那么就需要通过制定适当的策略和实施来解决。例如，您可以阻止工作负载改变其性质。或者，您可以迁移突然变得敏感的工作负载，并确保它不再在基于云的集群上运行。另一个重要的例子是国家合规性，根据法律要求，某些数据必须保留在指定的地理区域（通常是一个国家）内，并且只能从该地区访问。在这种情况下，必须在该地理区域创建一个集群。
- en: Avoiding vendor lock-in
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免供应商锁定
- en: Large organizations often prefer to have options and not be tied to a single
    provider. The risk is often too great, because the provider may shut down or be
    unable to provide the same level of service. Having multiple providers is often
    good for negotiating prices, too. Kubernetes is designed to be vendor-agnostic.
    You can run it on different cloud platforms, private service providers, and on-premises
    data centers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大型组织通常更喜欢有选择，并不希望被绑定在单一供应商上。风险往往太大，因为供应商可能会关闭或无法提供相同级别的服务。拥有多个供应商通常也有利于谈判价格。Kubernetes旨在成为供应商无关的。您可以在不同的云平台、私有服务提供商和本地数据中心上运行它。
- en: However, this is not trivial. If you want to be sure that you are able to switch
    providers quickly or shift some workloads from one provider to the next, you should
    already be running your system on multiple providers. You can do it yourself or
    there are some companies that provide the service of running Kubernetes transparently
    on multiple providers. Since different providers run different data centers, you
    automatically get some redundancy and protection from vendor-wide outages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是微不足道的。如果您想确保能够快速切换供应商或将一些工作负载从一个供应商转移到另一个供应商，您应该已经在多个供应商上运行系统。您可以自己操作，或者有一些公司提供在多个供应商上透明运行Kubernetes的服务。由于不同的供应商运行不同的数据中心，您自动获得了一些冗余和对供应商范围内的故障的保护。
- en: Geo-distributing high availability
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理分布的高可用性
- en: High availability means that a service will remain available to users even when
    some parts of the system fail. In the context of a federated Kubernetes cluster,
    the scope of failure is an entire cluster, which is typically due to problems
    with the physical data center hosting the cluster, or perhaps a wider issue with
    the platform provider. The key to high availability is redundancy. Geo-distributed
    redundancy means having multiple clusters running in different locations. It may
    be different availability zones of the same cloud provider, different regions
    of the same cloud provider, or even different cloud providers altogether (see
    the *Avoiding vendor lock-in* section). There are many issues to address when
    it comes to running a cluster federation with redundancy. We'll discuss some of
    these issues later. Assuming that the technical and organizational issues have
    been resolved, high availability will allow the switching of traffic from a failed
    cluster to another cluster. This should be transparent to the users up to a point
    (delay during switchover, and some in-flight requests or tasks may disappear or
    fail). The system administrators may need to take extra steps to support the switchover
    and to deal with the original cluster failure.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 高可用性意味着即使系统的某些部分出现故障，服务仍将对用户保持可用。在联邦Kubernetes集群的背景下，故障的范围是整个集群，这通常是由于托管集群的物理数据中心出现问题，或者可能是平台提供商出现更广泛的问题。高可用性的关键是冗余。地理分布式冗余意味着在不同位置运行多个集群。这可能是同一云提供商的不同可用区，同一云提供商的不同地区，甚至完全不同的云提供商（参见“避免供应商锁定”部分）。在运行具有冗余的集群联邦时，有许多问题需要解决。我们稍后将讨论其中一些问题。假设技术和组织问题已经解决，高可用性将允许将流量从失败的集群切换到另一个集群。这对用户来说应该是透明的（切换期间的延迟，以及一些正在进行的请求或任务可能会消失或失败）。系统管理员可能需要采取额外步骤来支持切换和处理原始集群的故障。
- en: The federation control plane
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦控制平面
- en: The federation control plane consists of two components that together enable
    a federation of Kubernetes clusters to appear and function as a single unified
    Kubernetes cluster.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦控制平面由两个组件组成，共同使得Kubernetes集群的联邦可以看作和作为一个统一的Kubernetes集群。
- en: Federation API server
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦API服务器
- en: 'The federation API server is managing the Kubernetes clusters that together
    comprise the federation. It manages the federation state (that is, which clusters
    are part of the federation) in an `etcd` database the same as a regular Kubernetes
    cluster, but the state it keeps is just which clusters are members of the federation.
    The state of each cluster is stored in the `etcd` database of that cluster. The
    main purpose of the federation API server is to interact with the federation controller
    manager and route requests to the federation member clusters. The federation members
    don''t need to know they are part of a federation: they work in just the same
    way.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦API服务器正在管理组成联邦的Kubernetes集群。它在`etcd`数据库中管理联邦状态（即哪些集群是联邦的一部分），与常规Kubernetes集群一样，但它保持的状态只是哪些集群是联邦的成员。每个集群的状态存储在该集群的`etcd`数据库中。联邦API服务器的主要目的是与联邦控制器管理器进行交互，并将请求路由到联邦成员集群。联邦成员不需要知道它们是联邦的一部分：它们的工作方式完全相同。
- en: 'The following diagram demonstrates the relationships between the federation
    API server, the federation replication controllers, and the Kubernetes clusters
    in the federation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了联邦API服务器、联邦复制控制器和联邦中的Kubernetes集群之间的关系：
- en: '![](Images/e89605d4-6f49-4385-87e2-6bf824bfb661.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e89605d4-6f49-4385-87e2-6bf824bfb661.png)'
- en: Federation controller manager
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦控制器管理器
- en: 'The federation controller manager makes sure the federation''s desired state
    matches the actual state. It forwards any necessary changes to the relevant cluster
    or clusters. The federated controller manager binary contains multiple controllers
    for all the different federated resources we''ll cover later in the chapter. The
    control logic is similar, though: it observes changes and brings the clusters''
    states to the desired state when they deviate. This is done for each member in
    the cluster federation.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦控制器管理器确保联邦的期望状态与实际状态匹配。它将任何必要的更改转发到相关的集群或集群。联邦控制器管理器二进制文件包含多个控制器，用于本章后面将介绍的所有不同的联邦资源。尽管控制逻辑相似：它观察变化并在集群状态偏离时将集群状态带到期望状态。这是针对集群联邦中的每个成员进行的。
- en: 'The following diagram demonstrates this perpetual control loop:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了这个永久控制循环：
- en: '![](Images/6c1f2b1b-0bfc-4849-939c-3659eb76d1ab.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6c1f2b1b-0bfc-4849-939c-3659eb76d1ab.png)'
- en: Federated resources
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦资源
- en: Kubernetes federation is still a work in progress. As of Kubernetes 1.10, only
    some of the standard resources can be federated. We'll cover them here. To create
    a federated resource, you use the `--context=federation-cluster` command-line
    argument from Kubectl. When you use `--context=federation-cluster`, the command
    goes to the federation API server, which takes care of sending it to all the member
    clusters.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes联邦仍在不断发展中。截至Kubernetes 1.10，只有一些标准资源可以进行联邦。我们将在这里介绍它们。要创建联邦资源，您可以使用Kubectl的`--context=federation-cluster`命令行参数。当您使用`--context=federation-cluster`时，该命令将发送到联邦API服务器，该服务器负责将其发送到所有成员集群。
- en: Federated ConfigMap
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦ConfigMap
- en: Federated ConfigMaps are very useful because they help centralize the configuration
    of applications that may be spread across multiple clusters.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦ConfigMaps非常有用，因为它们帮助集中配置可能分布在多个集群中的应用程序。
- en: Creating a federated ConfigMap
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建联邦ConfigMap
- en: 'Here is an example of creating a federated ConfigMap:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建联邦ConfigMap的示例：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the only difference when creating a ConfigMap in a single Kubernetes
    cluster is the context. When a federated ConfigMap is created, it is stored in
    the control plane's `etcd` database, but a copy is also stored in each member
    cluster. This way, each cluster can operate independently and doesn't need to
    access the control plane.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，创建单个Kubernetes集群中的ConfigMap时唯一的区别是上下文。创建联邦ConfigMap时，它存储在控制平面的`etcd`数据库中，但每个成员集群中也存储了一份副本。这样，每个集群可以独立运行，不需要访问控制平面。
- en: Viewing a federated ConfigMap
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看联邦ConfigMap
- en: 'You can view a ConfigMap by accessing the control plane or by accessing a member
    cluster. To access a ConfigMap in a member cluster, specify the federation cluster
    member name in the context:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问控制平面或访问成员集群来查看ConfigMap。要访问成员集群中的ConfigMap，请在上下文中指定联邦集群成员名称：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Updating a federated ConfigMap
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新联邦ConfigMap
- en: It's important to note that, when created through the control plane, the ConfigMap
    will be identical across all member clusters. However, since it is stored separately
    in each cluster in addition to the control plane cluster, there is no single source
    of `true`. It is possible (although not recommended) to later modify the ConfigMap
    of each member cluster independently. That leads to non-uniform configuration
    across the federation. There are valid use cases for different configurations
    for different clusters in the federation, but in those cases I suggest just configuring
    each cluster directly. When you create a federated ConfigMap, you make a statement
    that means whole clusters should share this configuration. However, you would
    usually want to update the ConfigMap across all the federation clusters by specifying
    `--context=federation-cluster.`
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，通过控制平面创建时，ConfigMap 将在所有成员集群中都是相同的。然而，由于它除了在控制平面集群中存储外，还在每个集群中单独存储，因此没有单一的“真实”来源。可以（尽管不建议）稍后独立修改每个成员集群的
    ConfigMap。这会导致联邦中的配置不一致。联邦中不同集群的不同配置有有效的用例，但在这些情况下，我建议直接配置每个集群。当你创建一个联邦 ConfigMap
    时，你是在表明整个集群应该共享这个配置。然而，通常情况下，你会希望通过指定 `--context=federation-cluster` 来更新联邦集群中的所有
    ConfigMap。
- en: Deleting a federated ConfigMap
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除联邦 ConfigMap
- en: 'That''s right, you guessed it. You delete as usual, but specify the context:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，你猜对了。你像往常一样删除，但指定上下文：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There is just one little twist. As of Kubernetes 1.10, when you delete a federated
    ConfigMap, the individual ConfigMaps that were created automatically in each cluster
    remain. You must delete them separately in each cluster. That is, if you have
    three clusters in your federation called `cluster-1`, `cluster-2`, and `cluster-3`,
    you''ll have to run these extra three commands to get rid of the ConfigMap across
    the federation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个小小的变化。从 Kubernetes 1.10 开始，当你删除一个联邦 ConfigMap 时，每个集群中自动创建的单独的 ConfigMap
    仍然存在。你必须在每个集群中分别删除它们。也就是说，如果你的联邦中有三个集群分别叫做 `cluster-1`、`cluster-2` 和 `cluster-3`，你将不得不运行这额外的三个命令来摆脱联邦中的
    ConfigMap：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will be rectified in the future.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在将来得到纠正。
- en: Federated DaemonSet
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦守护进程
- en: A federated DaemonSet is pretty much the same as a regular Kubernetes DaemonSet.
    You create it and interact with it through the control plane (by specifying `--context=federation-cluster`),
    and the control plane propagates it to all the member clusters. At the end of
    the day, you can be sure that your Daemons run on every node in every cluster
    of the federation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦守护进程基本上与常规的 Kubernetes 守护进程相同。你通过控制平面创建它并与之交互（通过指定 `--context=federation-cluster`），控制平面将其传播到所有成员集群。最终，你可以确保你的守护程序在联邦的每个集群的每个节点上运行。
- en: Federated Deployment
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦部署
- en: 'Federated deployments are a little smarter. When you create a federated deployment
    with X replicas and you have *N* clusters, the replicas will be distributed evenly
    between the clusters by default. If you have 3 clusters and the federated deployment
    has 15 pods, then each cluster will run 5 replicas. As with other federated resources,
    the control plane will store the federated deployment with 15 replicas and then
    create 3 deployments (1 for each cluster) with 5 replicas each. You can control
    the number of replicas per cluster by adding an annotation: `federation.kubernetes.io/deployment-preferences`.
    Federated deployment is still in Alpha as of Kubernetes 1.10\. In the future,
    the annotation will become a proper field in federated deployment configuration.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦部署更加智能。当您创建一个具有X个副本的联邦部署，并且您有*N*个集群时，默认情况下副本将在集群之间均匀分布。如果您有3个集群，并且联邦部署有15个pod，那么每个集群将运行5个副本。与其他联邦资源一样，控制平面将存储具有15个副本的联邦部署，然后创建3个部署（每个集群一个），每个部署都有5个副本。您可以通过添加注释`federation.kubernetes.io/deployment-preferences`来控制每个集群的副本数量。截至Kubernetes
    1.10，联邦部署仍处于Alpha阶段。在将来，该注释将成为联邦部署配置中的一个正确字段。
- en: Federated Events
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦事件
- en: Federated events are different than the other federated resources. They are
    only stored in the control plane and are not propagated to the underlying Kubernetes
    member clusters.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦事件与其他联邦资源不同。它们仅存储在控制平面中，不会传播到底层Kubernetes成员集群。
- en: 'You can query the federation events with `--context=federation-cluster` as
    usual:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像往常一样使用`--context=federation-cluster`查询联邦事件：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Federated Horizontal Pod Scaling
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦水平Pod扩展
- en: 'Federated **Horizontal Pod Scaling** (**HPA**) was added recently as an Alpha
    feature in Kubernetes 1.9\. In order to use it, you must provide the following
    flag when starting the API server:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最近在Kubernetes 1.9中作为Alpha功能添加了联邦**水平Pod扩展**（**HPA**）。为了使用它，您必须在启动API服务器时提供以下标志：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is a major feature because one of the primary motivations of cluster federation
    is fluidly shifting workloads across multiple clusters without manual intervention.
    Federated HPA utilizes the in-cluster HPA controllers. The federated HPA evenly
    distributes the load across member clusters based on the requested max and min
    replicas. In the future, users will be able to specify more advanced HPA policies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的功能，因为集群联合的主要动机之一是在没有手动干预的情况下在多个集群之间流畅地转移工作负载。联邦HPA利用了集群内的HPA控制器。联邦HPA根据请求的最大和最小副本数量在成员集群之间均匀分配负载。在将来，用户将能够指定更高级的HPA策略。
- en: 'For example, consider a federation with 4 clusters; we want to ensure there
    are always at least 6 pods and at most 16 pods running. The following manifest
    will get the work done:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个具有4个集群的联邦；我们希望始终至少有6个pod和最多有16个pod在运行。以下清单将完成工作：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use the following command to initiate the federated HPA:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动联邦HPA：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What happens now? The federation control plane will create a standard HPA in
    each of the 4 clusters with a maximum of 4 replicas and a minimum of 2 replicas.
    The reason is that this is the setting that most economically accomplishes the
    federated requirement. Let's understand why. If each cluster has at most 4 replicas,
    then we'll have at most 4 x 4 = 16 replicas, which meets our requirements. The
    guarantee of at least 2 replicas means that we will have at least 4 x 2 = 8 replicas.
    This meets the requirement that we will have at least 6 replicas. Note that even
    if there is zero load on the system, we will always have at least 8 replicas even
    though we specified that 6 is fine. There is no way around it, given the constraint
    of even distribution across clusters. If the cluster HPAs had `minReplicas=1`
    then the total number of replicas in the cluster could be 4 x 1 = 4, which is
    less than the federated minimum of 6 that's required. In the future, users may
    be able to specify more sophisticated distribution schemes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在会发生什么？联邦控制平面将在4个集群中的每个集群中创建标准HPA，最多有4个副本和最少有2个副本。原因是这是最经济地满足联邦要求的设置。让我们了解一下为什么。如果每个集群最多有4个副本，那么我们最多会有4
    x 4 = 16个副本，这符合我们的要求。至少2个副本的保证意味着我们至少会有4 x 2 = 8个副本。这满足了我们至少会有6个副本的要求。请注意，即使系统上没有负载，我们也将始终至少有8个副本，尽管我们指定6个也可以。鉴于跨集群的均匀分布的限制，没有其他办法。如果集群HPA的`minReplicas=1`，那么集群中的总副本数可能是4
    x 1 = 4，这少于所需的联邦最小值6。未来，用户可能可以指定更复杂的分布方案。
- en: It is possible, to use cluster selectors (introduced in Kubernetes 1.7) to restrict
    federated object to a subset of members. So, if we want to a minimum of 6 and
    maximum of 15, it is possible to evenly distribute it among 3 clusters instead
    of 4, and each cluster will have a minimum of 2 and maximum of 5.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用集群选择器（在Kubernetes 1.7中引入）来将联邦对象限制为成员的子集。因此，如果我们想要至少6个最多15个，可以将其均匀分布在3个集群中，而不是4个，每个集群将至少有2个最多5个。
- en: Federated ingress
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦入口
- en: The federated ingress does more than just create matching ingress objects in
    each cluster. One of the main features of federated ingress is that if a whole
    cluster goes down it can direct traffic to other clusters. As of Kubernetes 1.4,
    federated ingress is supported on Google Cloud Platform, both on GKE and GCE.
    In the future, hybrid cloud support for federated ingress will be added.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦入口不仅在每个集群中创建匹配的入口对象。联邦入口的主要特点之一是，如果整个集群崩溃，它可以将流量引导到其他集群。从Kubernetes 1.4开始，联邦入口在Google
    Cloud Platform上得到支持，包括GKE和GCE。未来，联邦入口将增加对混合云的支持。
- en: 'The federated ingress performs the following tasks:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦入口执行以下任务：
- en: Creates Kubernetes ingress objects in each cluster member of the federation
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在联邦的每个集群成员中创建Kubernetes入口对象
- en: Provides a one-stop logical L7 load balancer with a single IP address for all
    the cluster ingress objects
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有集群入口对象提供一个一站式逻辑L7负载均衡器，具有单个IP地址
- en: Monitors the health and capacity of the service backend pods behind the ingress
    object in each cluster
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视每个集群中入口对象后面的服务后端pod的健康和容量
- en: Makes sure to route client connections to a healthy service endpoint in the
    face of various failures, such as the failure of pod, cluster, availability zone,
    or a whole region, as long as there is one healthy cluster in the federation
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在各种故障情况下将客户端连接路由到健康的服务端点，例如pod、集群、可用区或整个区域的故障，只要联邦中有一个健康的集群
- en: Creating federated ingress
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建联邦入口
- en: 'You create federated ingress by addressing the federation control plane:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过寻址联邦控制平面来创建联邦入口
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The federation control plane will create the corresponding ingress in each
    cluster. All the clusters will share the same namespace and name for the `ingress`
    object:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 联合控制平面将在每个集群中创建相应的入口。所有集群将共享相同的命名空间和`ingress`对象的名称：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Request routing with federated ingress
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用联合入口进行请求路由
- en: The federated ingress controller will route requests to the closest cluster.
    Ingress objects expose one or more IP address (through the `Status.Loadbalancer.Ingress`
    field) that remain static for the lifetime of the ingress object. When an internal
    or external client connects to an IP address of a cluster-specific ingress object,
    it will be routed to one of the pods in that cluster. However, when a client connects
    to the IP address of a federated ingress object it will be automatically routed,
    via the shortest network path, to a healthy pod in the closest cluster to the
    origin of the request. So, for example, HTTP(S) requests from internet users in
    Europe will be routed directly to the closest cluster in Europe that has available
    capacity. If there are no such clusters in Europe, the request will be routed
    to the next closest cluster (often in the US).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 联合入口控制器将请求路由到最近的集群。入口对象通过`Status.Loadbalancer.Ingress`字段公开一个或多个IP地址，这些IP地址在入口对象的生命周期内保持不变。当内部或外部客户端连接到特定集群入口对象的IP地址时，它将被路由到该集群中的一个pod。然而，当客户端连接到联合入口对象的IP地址时，它将自动通过最短的网络路径路由到请求源最近的集群中的一个健康pod。因此，例如，来自欧洲互联网用户的HTTP(S)请求将直接路由到具有可用容量的欧洲最近的集群。如果欧洲没有这样的集群，请求将被路由到下一个最近的集群（通常在美国）。
- en: Handling failures with federated ingress
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用联合入口处理故障
- en: 'There are two broad categories of failure:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种广义的失败类别：
- en: Pod failure
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod故障
- en: Cluster failure
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群故障
- en: Pods might fail for many reasons. In a properly configured Kubernetes cluster
    (a cluster federation member or not), pods will be managed by services and ReplicaSets
    that can automatically handle pod failures. It shouldn't impact cross-cluster
    routing and load balancing done by the federated ingress. A whole cluster might
    fail due to problems with the data center or global connectivity. In this case,
    the federated services and federated ReplicaSets will ensure that the other clusters
    in the federation run enough pods to handle the workload, and the federated ingress
    will take care of routing client requests away from the failed cluster. To benefit
    from this auto-healing capability, clients must always connect to the federation
    ingress object and not to individual cluster members.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Pod可能因多种原因而失败。在正确配置的Kubernetes集群（无论是集群联合成员还是不是），pod将由服务和ReplicaSets管理，可以自动处理pod故障。这不应影响联合入口进行的跨集群路由和负载均衡。整个集群可能由于数据中心或全球连接的问题而失败。在这种情况下，联合服务和联合ReplicaSets将确保联合中的其他集群运行足够的pod来处理工作负载，并且联合入口将负责将客户端请求从失败的集群中路由出去。为了从这种自动修复功能中受益，客户端必须始终连接到联合入口对象，而不是单个集群成员。
- en: Federated job
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合作业
- en: Federated jobs work similarly to in-cluster jobs. The federation control plane
    creates jobs in the underlying clusters and evenly divides the load as far as
    the parallelism of tasks and keeping track of completions is concerned. For example,
    if the federation has 4 clusters and you create a federated job spec with parallelism=8
    and completions=24, then a job will be created in each cluster with parallelism=2
    and completions=6.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 联合作业与集群内作业类似。联合控制平面在基础集群中创建作业，并根据任务的并行性均匀分配负载，并跟踪完成情况。例如，如果联合有4个集群，并且您创建了一个并行性为8和完成数为24的联合作业规范，那么将在每个集群中创建一个并行性为2和完成数为6的作业。
- en: Federated namespace
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合命名空间
- en: Kubernetes namespaces are used within a cluster to isolate independent areas
    and support multi-tenant deployments. Federated namespaces provide the same capabilities
    across a cluster federation. The API is identical. When a client is accessing
    the federation control plane, they will only get access to the namespaces they
    requested and are authorized to access across all the clusters in the federation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 命名空间在集群内用于隔离独立区域并支持多租户部署。联合命名空间在整个集群联合中提供相同的功能。API 是相同的。当客户端访问联合控制平面时，他们只能访问他们请求的命名空间，并且被授权访问联合中所有集群的命名空间。
- en: 'You use the same commands and add `--context=federation-cluster`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用相同的命令并添加`--context=federation-cluster`：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Federated ReplicaSet
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合复制 ReplicaSet
- en: It is best to use deployments and federated deployments to manage the replicas
    in your cluster or federation. However, if for some reason you prefer to work
    directly with ReplicaSets, then Kubernetes supports a federated `ReplicaSet`.
    There is no federated replication controller because ReplicaSets supersede replication
    controllers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用部署和联合部署来管理集群或联合中的副本。但是，如果出于某种原因您更喜欢直接使用 ReplicaSets 进行工作，那么 Kubernetes 支持联合`ReplicaSet`。没有联合复制控制器，因为
    ReplicaSets 超越了复制控制器。
- en: When you create federated ReplicaSets, the job of the control plane is to ensure
    that the number of replicas across the cluster matches your federated ReplicaSets
    configuration. The control plane will create a regular ReplicaSet in each federation
    member. Each cluster will get, by default, an equal (or as close to equal as possible)
    number of replicas so that the total will add up to the specified number of replicas.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建联合 ReplicaSets 时，控制平面的工作是确保整个集群中的副本数量与您的联合 ReplicaSets 配置相匹配。控制平面将在每个联合成员中创建一个常规
    ReplicaSet。每个集群将默认获得相等（或尽可能接近相等）数量的副本，以便总数将达到指定的副本数量。
- en: 'You can control the number of replicas per cluster by using the following annotation:
    `federation.kubernetes.io/replica-set-preferences`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下注释来控制每个集群的副本数量：`federation.kubernetes.io/replica-set-preferences`。
- en: 'The corresponding data structure is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的数据结构如下：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If `Rebalance` is `true`, then running replicas may be moved between clusters
    as necessary. The clusters map determines the ReplicaSets preferences per cluster.
    If `*` is specified as the key, then all unspecified clusters will use that set
    of preferences. If there is no `*` entry, then replicas will only run on clusters
    that show up in the map. Clusters that belong to the federation but don't have
    an entry will not have pods scheduled (for that pod template).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Rebalance`为`true`，则正在运行的副本可能会根据需要在集群之间移动。集群映射确定每个集群的 ReplicaSets 偏好。如果将`*`指定为键，则所有未指定的集群将使用该偏好集。如果没有`*`条目，则副本将仅在映射中显示的集群上运行。属于联合但没有条目的集群将不会安排
    pod（对于该 pod 模板）。
- en: 'The individual ReplicaSets preferences per cluster are specified using the
    following data structure:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集群的单独 ReplicaSets 偏好使用以下数据结构指定：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`MinReplicas` is `0` by default. `MaxReplicas` is unbounded by default. Weight
    expresses the preference to add an additional replica to this ReplicaSets and
    defaults to `0`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`MinReplicas`默认为`0`。`MaxReplicas`默认情况下是无限制的。权重表示向这个ReplicaSets添加额外副本的偏好，默认为`0`。'
- en: Federated secrets
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合秘密
- en: Federated secrets are simple. When you create a federated secret as usual through
    the control plane it gets propagated to the whole cluster. That's it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 联合秘密很简单。当您通过控制平面像往常一样创建联合秘密时，它会传播到整个集群。就是这样。
- en: The hard parts
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 困难的部分
- en: So far, federation seems almost straightforward. You group a bunch of clusters
    together, access them through the control plane, and everything just gets replicated
    to all the clusters. But there are hard and difficult factors and basic concepts
    that complicate this simplified view. Much of the power of Kubernetes is derived
    from its ability to do a lot of work behind the scenes. Within a single cluster
    deployed fully in a single physical data center or availability zone, where all
    the components are connected to a fast network, Kubernetes is very effective on
    its own. In a Kubernetes cluster federation, the situation is different. Latency,
    data transfer costs, and moving pods between clusters all have different trade-offs.
    Depending on the use case, making federation work may require extra attention,
    planning, and maintenance on the part of the system designers and operators. In
    addition, some of the federated resources are not as mature as their local counterparts,
    and that adds more uncertainty.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，联邦似乎几乎是直截了当的。将一堆集群组合在一起，通过控制平面访问它们，一切都会被复制到所有集群。但是有一些困难因素和基本概念使这种简化的观点变得复杂。Kubernetes的许多功能来自于其在幕后执行大量工作的能力。在一个完全部署在单个物理数据中心或可用性区域的单个集群中，所有组件都连接到快速网络，Kubernetes本身非常有效。在Kubernetes集群联邦中，情况就不同了。延迟、数据传输成本以及在集群之间移动Pods都有不同的权衡。根据用例，使联邦工作可能需要系统设计师和运营商额外的注意、规划和维护。此外，一些联合资源不如其本地对应物成熟，这增加了更多的不确定性。
- en: Federated unit of work
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦工作单元
- en: The unit of work in a Kubernetes cluster is the pod. You can't break a pod in
    Kubernetes. The entire pod will always be deployed together and will be subject
    to the same life cycle treatment. Should the pod remain the unit of work for a
    cluster federation? Maybe it makes more sense to be able to associate a bigger
    unit, such as a whole ReplicaSet, deployment, or service with a specific cluster.
    If the cluster fails, the entire ReplicaSet, deployment, or service is scheduled
    to a different cluster. How about a collection of tightly coupled ReplicaSets?
    The answers to these questions are not always easy and may even change dynamically
    as the system evolves.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群中的工作单元是Pod。在Kubernetes中无法打破Pod。整个Pod将始终一起部署，并受到相同的生命周期处理。Pod是否应该保持集群联邦的工作单元？也许将更大的单元（如整个ReplicaSet、部署或服务）与特定集群关联起来会更有意义。如果集群失败，整个ReplicaSet、部署或服务将被调度到另一个集群。那么一组紧密耦合的ReplicaSets呢？这些问题的答案并不总是容易的，甚至可能随着系统的演变而动态改变。
- en: Location affinity
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置亲和性
- en: 'Location affinity is a major concern. When can pods be distributed across clusters?
    What is the relationships between those pods? Are there any requirements for affinity
    between pods or pods and other resources, such as storage? There are several major
    categories:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 位置亲和力是一个主要关注点。Pods何时可以分布在集群之间？这些Pods之间的关系是什么？是否有亲和力要求，比如Pods之间或Pods与其他资源（如存储）之间？有几个主要类别：
- en: Strictly-coupled
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格耦合
- en: Loosely-coupled
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松散耦合
- en: Preferentially-coupled
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先耦合
- en: Strictly-decoupled
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格解耦
- en: Uniformly-spread
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 均匀分布
- en: When designing the system and how to allocate and schedule services and pods
    across the federation, it's important to make sure the location affinity requirements
    are always respected.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计系统以及如何在联邦中分配和调度服务和Pods时，确保始终尊重位置亲和性要求非常重要。
- en: Strictly-coupled
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 严格耦合
- en: The strictly-coupled requirement applies to applications where the pods must
    be in the same cluster. If you partition the pods, the application will fail (perhaps
    due to real-time requirements that can't be met when networking across clusters)
    or the cost may be too high (pods may be accessing a lot of local data). The only
    way to move such tightly coupled applications to another cluster is to start a
    complete copy (including data) on another cluster and then shut down the application
    on the current cluster. If the amount of data is too large, the application may
    practically be immovable and sensitive to catastrophic failure. This is the most
    difficult situation to deal with, and if possible you should architect your system
    to avoid the strictly-coupled requirement.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 严格耦合的要求适用于必须在同一集群中的应用程序。如果对 pod 进行分区，应用程序将失败（可能是由于实时要求无法在集群间进行网络传输），或者成本可能太高（pod
    可能正在访问大量本地数据）。将这种紧密耦合的应用程序移动到另一个集群的唯一方法是在另一个集群上启动完整的副本（包括数据），然后关闭当前集群上的应用程序。如果数据量太大，该应用程序可能实际上无法移动，并对灾难性故障敏感。这是最难处理的情况，如果可能的话，您应该设计系统以避免严格耦合的要求。
- en: Loosely-coupled
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松耦合
- en: Loosely-coupled applications are best when the workload is embarrassingly parallel
    and each pod doesn't need to know about the other pods or access a lot of data.
    In these situations, pods can be scheduled to clusters just based on capacity
    and resource utilization across the federation. If necessary, pods can be moved
    from one cluster to another without problems. For example, a stateless validation
    service that performs some calculation and gets all its input in the request itself
    and doesn't query or write any federation-wide data. It just validates its input
    and returns a valid/invalid verdict to the caller.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 松耦合的应用程序在工作负载尴尬地并行时表现最佳，每个 pod 不需要了解其他 pod 或访问大量数据。在这些情况下，pod 可以根据联邦中的容量和资源利用率安排到集群中。必要时，pod
    可以在不出问题的情况下从一个集群移动到另一个集群。例如，一个无状态的验证服务执行一些计算，并在请求本身中获取所有输入，不查询或写入任何联邦范围的数据。它只验证其输入并向调用者返回有效/无效的判断。
- en: Preferentially-coupled
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先耦合
- en: Preferentially-coupled applications perform better when all the pods are in
    the same cluster or the pods and the data are co-located, but it is not a hard
    requirement. For example, it could work with applications that require only eventual
    consistency, where some federation-wide application periodically synchronizes
    the application state across all clusters. In these cases, allocation is done
    explicitly to one cluster, but leaves a safety hatch for running or migrating
    to other clusters under stress.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有 pod 都在同一集群中或 pod 和数据共同位于同一位置时，优先耦合的应用程序表现更好，但这不是硬性要求。例如，它可以与仅需要最终一致性的应用程序一起工作，其中一些联邦范围的应用程序定期在所有集群之间同步应用程序状态。在这些情况下，分配是明确地针对一个集群进行的，但在压力下留下了一个安全舱口，可以在其他集群中运行或迁移。
- en: Strictly-decoupled
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 严格解耦
- en: Some services have fault isolation or high availability requirements that force
    partitioning across clusters. There is no point running three replicas of a critical
    service if all replicas might end up scheduled to the same cluster, because that
    cluster just becomes an ad hoc **single point of failure** (**SPOF**).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一些服务具有故障隔离或高可用性要求，这要求在集群之间进行分区。如果所有副本最终可能被安排到同一集群中，那么运行关键服务的三个副本就没有意义，因为该集群只成为一个临时的单点故障（SPOF）。
- en: Uniformly-spread
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 均匀分布
- en: Uniformly-spread is when an instance of a service, ReplicaSet, or pod must run
    on each cluster. It is similar to DaemonSet, but instead of ensuring there is
    one instance on each node, it's one per cluster. A good example is a Redis cache
    backed up by some external persistent storage. The pods in each cluster should
    have their own cluster-local Redis cache to avoid accessing the central storage
    that may be slower or become a bottleneck. On the other hand, there is no need
    for more than one Redis service per cluster (it could be distributed across several
    pods in the same cluster).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 均匀分布是指服务、ReplicaSet或pod的实例必须在每个集群上运行。这类似于DaemonSet，但不是确保每个节点上有一个实例，而是每个集群一个实例。一个很好的例子是由一些外部持久存储支持的Redis缓存。每个集群中的pod应该有自己的集群本地Redis缓存，以避免访问可能更慢或成为瓶颈的中央存储。另一方面，每个集群不需要超过一个Redis服务（它可以分布在同一集群中的几个pod中）。
- en: Cross-cluster scheduling
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨集群调度
- en: Cross-cluster scheduling goes hand in hand with location affinity. When a new
    pod is created or an existing pod fails and a replacement needs to be scheduled,
    where should it go? The current cluster federation doesn't handle all the scenarios
    and options for location affinity we mentioned earlier. At this point, cluster
    federation handles the loosely-coupled (including weighted distribution) and strictly-coupled
    (by making sure the number of replicas matches the number of clusters) categories
    well. Anything else will require that you don't use cluster federation. You'll
    have to add your own custom federation layer that takes more specialized concerns
    into account and can accommodate more intricate scheduling use cases.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 跨集群调度与位置亲和力相辅相成。当创建新的pod或现有的pod失败并且需要安排替代时，它应该去哪里？当前的集群联邦不能处理我们之前提到的所有场景和位置亲和力的选项。在这一点上，集群联邦很好地处理了松散耦合（包括加权分布）和严格耦合（通过确保副本的数量与集群的数量相匹配）的类别。其他任何情况都需要您不使用集群联邦。您将不得不添加自己的自定义联邦层，以考虑更多专门的问题，并且可以适应更复杂的调度用例。
- en: Federated data access
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦数据访问
- en: 'This is a tough problem. If you have a lot of data and pods running in multiple
    clusters (possibly on different continents) and need to access it quickly, then
    you have several unpleasant options:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个棘手的问题。如果您有大量数据和在多个集群中运行的pod（可能在不同的大陆上），并且需要快速访问它，那么您有几个不愉快的选择：
- en: Replicate your data to each cluster (slow to replicate, expensive to transfer,
    expensive to store, and complicated to sync and deal with errors)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据复制到每个集群（复制速度慢，传输昂贵，存储昂贵，同步和处理错误复杂）
- en: Access the data remotely (slow to access, expensive on each access, and can
    be a SPOF)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程访问数据（访问速度慢，每次访问昂贵，可能成为单点故障）
- en: Make a sophisticated hybrid solution with per-cluster caching of some of the
    hottest data (complicated/stale data, and you still need to transfer a lot of
    data)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制定一个复杂的混合解决方案，对一些最热门的数据进行每个集群缓存（复杂/陈旧的数据，仍然需要传输大量数据）
- en: Federated auto-scaling
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦自动扩展
- en: 'There is currently no support for federated auto-calling. There are two dimensions
    of scaling that can be utilized, as well as a combination:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不支持联邦自动调用。可以利用两个维度的扩展，以及组合：
- en: Per-cluster scaling
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个集群的扩展
- en: Adding/removing clusters from the federation
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将集群添加/移除联邦
- en: Hybrid approach
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合方法
- en: Consider the relatively simple scenario of a loosely coupled application running
    on three clusters with five pods in each cluster. At some point, 15 pods can't
    handle the load anymore. We need to add more capacity. We can increase the number
    of pods per cluster, but if we do it at the federation level than we will have
    six pods running in each cluster. We've increased the federation capacity by three
    pods, when only one pod is needed. Of course, if you have more clusters the problem
    gets worse. Another option is to pick a cluster and just change its capacity.
    This is possible with annotations, but now we're explicitly managing capacity
    across the federation. It can get complicated very quickly if we have lots of
    clusters running hundreds of services with dynamically changing requirements.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个相对简单的场景，即在三个集群上运行一个松散耦合的应用程序，每个集群有五个pod。在某个时候，15个pod无法再处理负载。我们需要增加更多的容量。我们可以增加每个集群中的pod数量，但如果我们在联邦级别这样做，那么每个集群将有六个pod在运行。我们通过三个pod增加了联邦的容量，而只需要一个pod。当然，如果您有更多的集群，问题会变得更糟。另一个选择是选择一个集群并只改变其容量。这是可能的，但现在我们明确地在整个联邦中管理容量。如果我们有许多集群运行数百个具有动态变化需求的服务，情况会很快变得复杂。
- en: Adding a whole new cluster is even more complicated. Where should we add the
    new cluster? There is no requirement for extra availability that can guide the
    decision. It is just about extra capacity. Creating a new cluster also often requires
    complicated first-time setup and it may take days to approve various quotas on
    public cloud platforms. The hybrid approach increases the capacity of existing
    clusters in the federation until some threshold is reached and then starts adding
    new clusters. The benefit of this approach is that when you're getting closer
    to your capacity limit per cluster you start preparing new clusters that will
    be ready to go when necessary. Other than that, it requires a lot of effort and
    you pay in increased complexity for the flexibility and scalability.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个全新的集群更加复杂。我们应该在哪里添加新的集群？没有额外的可用性要求可以指导决策。这只是额外的容量问题。创建一个新的集群通常需要复杂的首次设置，并且可能需要几天来批准公共云平台上的各种配额。混合方法增加了联邦中现有集群的容量，直到达到某个阈值，然后开始添加新的集群。这种方法的好处是，当您接近每个集群的容量限制时，您开始准备新的集群，以便在必要时立即启动。除此之外，它需要大量的工作，并且您需要为灵活性和可伸缩性付出增加的复杂性。
- en: Managing a Kubernetes cluster federation
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理Kubernetes集群联邦
- en: Managing a Kubernetes cluster federation involves many activities above and
    beyond managing a single cluster. There are two ways to set up the federation.
    Then, you need to consider cascading resource deletion, load balancing across
    clusters, fail over across clusters, federated service discovery, and federated
    discovery. Let's go over each one in detail.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 管理Kubernetes集群联邦涉及许多超出管理单个集群的活动。有两种设置联邦的方式。然后，您需要考虑级联资源删除，跨集群负载平衡，跨集群故障转移，联邦服务发现和联邦发现。让我们详细讨论每一种。
- en: Setting up cluster federation from the ground up
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头开始设置集群联邦
- en: 'Note: this approach is now deprecated in favor of using `Kubefed`. I describe
    it here for the benefit of readers using older versions of Kubernetes.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这种方法现在已经不推荐使用`Kubefed`。我在这里描述它是为了让使用较旧版本Kubernetes的读者受益。
- en: 'To set up a Kubernetes cluster federation, we need to run the components of
    the control plane, which are as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 建立Kubernetes集群联邦，我们需要运行控制平面的组件，如下所示：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'One of the easiest ways to do that is to use the all-in-one hyperkube image:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个最简单的方法是使用全能的hyperkube镜像：
- en: '[https://github.com/kubernetes/kubernetes/tree/master/cluster/images/hyperkube](https://github.com/kubernetes/kubernetes/tree/master/cluster/images/hyperkube)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/kubernetes/kubernetes/tree/master/cluster/images/hyperkube](https://github.com/kubernetes/kubernetes/tree/master/cluster/images/hyperkube)'
- en: The federation API server and the federation controller manager can be run as
    pods in an existing Kubernetes cluster, but as discussed earlier, it is better
    from a fault tolerance and high availability point of view to run them in their
    own cluster.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦API服务器和联邦控制器管理器可以作为现有Kubernetes集群中的pod运行，但正如前面讨论的那样，最好从容错和高可用性的角度来看，将它们运行在自己的集群中。
- en: Initial setup
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始设置
- en: 'First, you must have Docker running and get a Kubernetes release that contains
    the scripts we will use in this guide. The current release is 1.5.3\. You can
    download the latest available version instead:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您必须运行Docker，并获取包含我们在本指南中将使用的脚本的Kubernetes版本。当前版本是1.5.3。您也可以下载最新可用版本：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We need to create a directory for the federation config files and set the `FEDERATION_OUTPUT_ROOT`
    environment variable to that directory. For easy cleanup, it''s best to create
    a new directory:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为联邦配置文件创建一个目录，并将`FEDERATION_OUTPUT_ROOT`环境变量设置为该目录。为了方便清理，最好创建一个新目录：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can initialize the federation:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以初始化联邦：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using the official Hyperkube image
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用官方的Hyperkube镜像
- en: As part of every Kubernetes release, official release images are pushed to `gcr.io/google_containers`.
    To use the images in this repository, you can set the container image fields in
    the config files in `${FEDERATION_OUTPUT_ROOT}` to point to the `gcr.io/google_containers/hyperkube`
    image, which includes both the `federation-apiserver` and `federation-controller-manager`
    binaries.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 作为每个Kubernetes版本的一部分，官方发布的镜像都被推送到`gcr.io/google_containers`。要使用该存储库中的镜像，您可以将配置文件中的容器镜像字段设置为`${FEDERATION_OUTPUT_ROOT}`指向`gcr.io/google_containers/hyperkube`镜像，其中包括`federation-apiserver`和`federation-controller-manager`二进制文件。
- en: Running the federation control plane
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行联邦控制平面
- en: 'We''re ready to deploy the federation control plane by running the following
    command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备通过运行以下命令部署联邦控制平面：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The command will launch the control plane components as pods and create a service
    of type `LoadBalancer` for the federation API server and a persistent volume claim
    backed up by a dynamic persistent volume for `etcd`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将启动控制平面组件作为pod，并为联邦API服务器创建一个`LoadBalancer`类型的服务，并为`etcd`创建一个由动态持久卷支持的持久卷索赔。
- en: 'To verify everything was created correctly in the federation namespace, type
    the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证联邦命名空间中的所有内容是否正确创建，请输入以下内容：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should see this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到这个：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can also check your `kubeconfig` file for new entries using the Kubectl
    config view. Note that dynamic provisioning works only for AWS and GCE at the
    moment.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用Kubectl config view检查`kubeconfig`文件中的新条目。请注意，动态配置目前仅适用于AWS和GCE。
- en: Registering Kubernetes clusters with the federation
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向联邦注册Kubernetes集群
- en: To register a cluster with the federation, we need a secret to talk to the cluster.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要向联邦注册集群，我们需要一个与集群通信的秘钥。
- en: Let's create the secret in the host Kubernetes cluster. Suppose `kubeconfig`
    of the target cluster is at `|cluster-1|kubeconfig`. You can run the following
    command
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在主机Kubernetes集群中创建秘钥。假设目标集群的`kubeconfig`位于`|cluster-1|kubeconfig`。您可以运行以下命令
- en: 'to create the `secret`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`secret`：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The configuration for the cluster looks the same as this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 集群的配置看起来和这个一样：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We need to set `<client-cidr>`, `<apiserver-address>`, and `<secret-name>`.
    `<secret-name>` here is name of the secret that you just created. `serverAddressByClientCIDRs`
    contains the various server addresses that clients can use as per their CIDR.
    We can set the server's public IP address with `CIDR 0.0.0.0/0`, which all clients
    will match. In addition, if you want internal clients to use the server's `clusterIP`,
    you can set that as `serverAddress`. The client CIDR in that case will be a CIDR
    that only matches the IPs of pods running in that cluster.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置`<client-cidr>`，`<apiserver-address>`和`<secret-name>`。这里的`<secret-name>`是您刚刚创建的秘密的名称。`serverAddressByClientCIDRs`包含客户端可以根据其CIDR使用的各种服务器地址。我们可以使用`CIDR
    0.0.0.0/0`设置服务器的公共IP地址，所有客户端都将匹配。此外，如果要内部客户端使用服务器的`clusterIP`，可以将其设置为`serverAddress`。在这种情况下，客户端CIDR将是仅匹配在该集群中运行的pod的IP的CIDR。
- en: 'Let''s register the cluster:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们注册集群：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s see if the cluster has been registered properly:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看集群是否已正确注册：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Updating KubeDNS
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新KubeDNS
- en: 'The cluster is registered with the federation. It''s time to update `kube-dns`
    so that your cluster can route federation service requests. As of Kubernetes 1.5
    or later, it''s done by passing the `--federations` flag to `kube-dns` through
    the `kube-dns ConfigMap` :'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 集群已注册到联邦。现在是时候更新`kube-dns`，以便您的集群可以路由联邦服务请求。从Kubernetes 1.5或更高版本开始，通过`kube-dns
    ConfigMap`传递`--federations`标志来完成：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is what the `ConfigMap` looks like:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigMap`的外观如下：'
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Replace the `federation-name` and the `federation-domain-name` with the correct
    values.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将`federation-name`和`federation-domain-name`替换为正确的值。
- en: Shutting down the federation
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭联邦
- en: 'If you want to shut down the federation, just run the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要关闭联邦，只需运行以下命令：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Setting up cluster federation with Kubefed
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubefed设置集群联合
- en: Kubernetes 1.5 introduced a new Alpha command-line tool called `Kubefed` to
    help you administrate your federated clusters. The job of `Kubefed` is to make
    it easy to deploy a new Kubernetes cluster federation control plane, and to add
    or remove clusters from an existing federation control plane. It has been in beta
    since Kubernetes 1.6.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 1.5引入了一个名为`Kubefed`的新的Alpha命令行工具，帮助您管理联合集群。`Kubefed`的工作是使部署新的Kubernetes集群联合控制平面变得容易，并向现有联合控制平面添加或删除集群。自Kubernetes
    1.6以来一直处于beta阶段。
- en: Getting Kubefed
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取Kubefed
- en: 'Until Kubernetes 1.9, Kubefed was part of the Kubernetes client binaries. You''ll
    get Kubectl and Kubefed. Here are the instructions for downloading and installing
    on Linux:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 直到Kubernetes 1.9，Kubefed是Kubernetes客户端二进制文件的一部分。您将获得Kubectl和Kubefed。以下是在Linux上下载和安装的说明：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Make the necessary adjustments if you''re using a different OS or want to install
    a different version. Since Kubernetes 1.9 Kubefed has been available in the dedicated
    federation repository:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用不同的操作系统或想安装不同的版本，则需要进行必要的调整。自Kubernetes 1.9以来，Kubefed已在专用联邦存储库中可用：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can install Kubectl separately following the instructions here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照此处的说明单独安装Kubectl：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Choosing a host cluster
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择主机集群
- en: The federation control plane can be its own dedicated cluster or hosted with
    an existing cluster. You need to make this decision. The host cluster hosts the
    components that make up your federation control plane. Ensure that you have a
    `kubeconfig` entry in your local `kubeconfig` that corresponds to the host cluster.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦控制平面可以是其自己的专用集群，也可以与现有集群一起托管。您需要做出这个决定。主机集群托管组成联邦控制平面的组件。确保您在本地`kubeconfig`中具有与主机集群对应的`kubeconfig`条目。
- en: 'To verify that you have the required `kubeconfig` entry, type the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证是否具有所需的`kubeconfig`条目，请键入以下内容：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should see something like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于这样的东西：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The context name, `cluster-1`, will be provided later when deploying the federation
    control plane.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署联邦控制平面时，将稍后提供上下文名称`cluster-1`。
- en: Deploying a federation control plane
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署联邦控制平面
- en: 'It''s time to start using Kubefed. The `kubefed init` command requires three
    arguments:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始使用Kubefed了。`kubefed init`命令需要三个参数：
- en: The federation name
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联邦名称
- en: The host cluster context
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机集群上下文
- en: A domain name suffix for your federated services
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于您的联邦服务的域名后缀
- en: The following example command deploys a federation control plane with the
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例命令部署了一个带有联邦控制平面的
- en: 'name federation; a host cluster context, `cluster-1`; a coredns DNS provider
    (`google-clouddns` and `aes-route53` are also valid); and the domain suffix, `kubernetes-ftw.com`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 名称联邦；一个主机集群上下文，`cluster-1`；一个coredns DNS提供程序（`google-clouddns`和`aes-route53`也是有效的）；和域后缀，`kubernetes-ftw.com`：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The DNS suffix should be for a DNS domain you manage, of course.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: DNS后缀应该是您管理的DNS域名。
- en: '`kubefed init` sets up the federation control plane in the host cluster and
    adds an entry for the federation API server in your local `kubeconfig`. Kubernetes
    might not create the default namespace due to a bug. In this case, you''ll have
    to do it yourself. Type the following command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubefed init`在主机集群中设置联邦控制平面，并在本地`kubeconfig`中为联邦API服务器添加条目。由于错误，Kubernetes可能不会创建默认命名空间。在这种情况下，您将不得不自己执行。键入以下命令：'
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Don''t forget to set the current context to federation, so that Kubectl targets
    the federation control plane:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将当前上下文设置为联邦，以便Kubectl将目标设置为联邦控制平面：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Federated service discovery
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦服务发现
- en: Federated service discovery is tightly coupled with federated load balancing.
    A pragmatic setup includes a global L7 load balancer that distributes requests
    to federated ingress objects in the federation clusters.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦服务发现与联邦负载平衡紧密耦合。一个实用的设置包括一个全局L7负载均衡器，将请求分发到联邦集群中的联邦入口对象。
- en: The benefit of this approach is that the control stays with the Kubernetes federation,
    which over time will able to work with more cluster types (currently just AWS
    and GCE) and understand cluster utilization and other constraints.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处是控制权留在Kubernetes联邦，随着时间的推移，它将能够与更多的集群类型（目前只有AWS和GCE）一起工作，并了解集群利用率和其他约束。
- en: The alternative of having a dedicated lookup service and let clients connect
    directly to services on individual clusters loses all these benefits.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有专用的查找服务并让客户端直接连接到各个集群上的服务的替代方案会失去所有这些好处。
- en: Adding a cluster to a federation
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将集群添加到联邦
- en: 'Once the control plane has been deployed successfully, we should add some Kubernetes
    clusters to the federation. Kubefed provides the `join` command exactly for this
    purpose. The `kubefed join` command requires the following arguments:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦控制平面成功部署，我们应该将一些Kubernetes集群添加到联邦中。Kubefed为此目的提供了`join`命令。`kubefed join`命令需要以下参数：
- en: The name of the cluster to add
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要添加的集群名称
- en: Host cluster context
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机集群上下文
- en: For example, to add a new cluster called `cluster-2` to the federation, type
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将名为`cluster-2`的新集群添加到联邦中，请键入
- en: 'the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下：
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Naming rules and customization
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名规则和自定义
- en: The cluster name you supply to `kubefed join` must be a valid RFC 1035 label.
    RFC 1035 allows only letters, digits, and hyphens, and the label must start with
    a letter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您提供给`kubefed join`的集群名称必须是有效的RFC 1035标签。RFC 1035只允许字母、数字和连字符，并且标签必须以字母开头。
- en: Furthermore, the federation control plane requires the credentials of the joined
    clusters to operate on them. These credentials are obtained from the local `kubeconfig`.
    The `Kubefed join` command uses the cluster name specified as the argument to
    look for the cluster's context in the local `kubeconfig`. If it fails to find
    a matching context, it exits with an error.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，联邦控制平面需要加入集群的凭据才能对其进行操作。这些凭据是从本地的`kubeconfig`中获取的。`Kubefed join`命令使用指定为参数的集群名称来查找本地`kubeconfig`中的集群上下文。如果它找不到匹配的上下文，它将以错误退出。
- en: 'This might cause issues in cases where context names for each cluster in the
    federation don''t follow RFC 1035 label naming rules. In such cases, you can specify
    a cluster name that conforms to the RFC 1035 label naming rules and specify the
    cluster context using the `--cluster-context` flag. For example, if the context
    of the cluster you are joining is `cluster-3` (an underscore is not allowed),
    you can join the cluster by running this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致问题，因为联邦中每个集群的上下文名称不遵循RFC 1035标签命名规则。在这种情况下，您可以指定符合RFC 1035标签命名规则的集群名称，并使用`--cluster-context`标志指定集群上下文。例如，如果您要加入的集群的上下文是`cluster-3`（不允许使用下划线），您可以通过运行此命令加入该集群：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Secret name
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 秘密名称
- en: Cluster credentials required by the federation control plane as described in
    the previous section are stored as a secret in the host cluster. The name of the
    secret is also derived from the cluster name.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦控制平面在上一节中描述的集群凭据作为主机集群中的一个秘密存储。秘密的名称也是从集群名称派生的。
- en: 'However, the name of a `secret` object in Kubernetes should conform to the
    DNS subdomain name specification described in RFC 1123\. If this isn''t the case,
    you can pass the `secret name` to `kubefed join` using the `--secret-name` flag.
    For example, if the cluster name is `cluster-4` and the `secret name` is `4secret`
    (starting with a letter is not allowed), you can join the cluster by running this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在Kubernetes中`secret`对象的名称应符合RFC 1123中描述的DNS子域名规范。如果不是这种情况，您可以使用`--secret-name`标志将`secret
    name`传递给`kubefed join`。例如，如果集群名称是`cluster-4`，`secret name`是`4secret`（不允许以字母开头），您可以通过运行此命令加入该集群：
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `kubefed join` command automatically creates the secret for you.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubefed join`命令会自动为您创建秘密。'
- en: Removing a cluster from a federation
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从联邦中删除一个集群
- en: 'To remove a cluster from a federation, run the `kubefed unjoin` command with
    the cluster name and the federation''s host cluster context:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要从联邦中删除一个集群，请使用集群名称和联邦主机集群上下文运行`kubefed unjoin`命令：
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Shutting down the federation
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭联邦
- en: 'Proper cleanup of the federation control plane is not fully implemented in
    this beta release of Kubefed. However, for the time being, deleting the federation
    system namespace should remove all the resources except the persistent storage
    volume dynamically provisioned for the federation control plane''s `etcd`. You
    can `delete` the federation namespace by running the following command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubefed的beta版本中，联邦控制平面的适当清理尚未完全实现。但是，暂时删除联邦系统命名空间应该会删除除联邦控制平面的`etcd`动态配置的持久存储卷之外的所有资源。您可以通过运行以下命令`delete`联邦命名空间来删除联邦命名空间：
- en: '[PRE39]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Cascading delete of resources
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源的级联删除
- en: The Kubernetes cluster federation often manages a federated object in the control
    plane, as well as corresponding objects in each member Kubernetes cluster. A cascading
    delete of a federated object means that the corresponding objects in the member
    Kubernetes clusters will also be deleted.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群联邦通常在控制平面中管理联合对象，以及每个成员Kubernetes集群中的相应对象。级联删除联合对象意味着成员Kubernetes集群中的相应对象也将被删除。
- en: 'This doesn''t happen automatically. By default, only the federation control
    plane object is deleted. To activate cascading delete, you need to set the following
    option:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会自动发生。默认情况下，只删除联合控制平面对象。要激活级联删除，您需要设置以下选项：
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In Kuberentes 1.5, only the following federated objects supported cascading
    delete:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kuberentes 1.5中，只有以下联合对象支持级联删除：
- en: Deployment
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署
- en: DaemonSets
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 守护进程集
- en: Ingress
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入口管理
- en: Namespaces
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: ReplicaSets
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副本集
- en: Secrets
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密
- en: For other objects, you have to go into each cluster and delete them explicitly.
    Fortunately, starting from Kubernetes 1.6, all the federated objects support cascading
    delete.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他对象，您必须进入每个集群并明确删除它们。幸运的是，从Kubernetes 1.6开始，所有联合对象都支持级联删除。
- en: Load balancing across multiple clusters
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨多个集群的负载均衡
- en: Dynamic load balancing across clusters is not trivial. The simplest solution
    is to just say that it is not Kubernetes's responsibility. Load balancing will
    be performed outside the Kubernetes cluster federation. But given the dynamic
    nature of Kubernetes, even an external load balancer will have to gather a lot
    of information about which services and backend pods are running on each cluster.
    An alternative solution is for the federation control plane to implement an L7
    load balancer that serves as traffic director for the entire federation. In one
    of the simpler use cases, each service runs on a dedicated cluster and the load
    balancer simply routes all traffic to that cluster. In case of cluster failure,
    the service is migrated to a different cluster and the load balancer now routes
    all traffic to the new cluster. This provides a coarse fail over and high-availability
    solution at the cluster level.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 跨集群的动态负载均衡并不是微不足道的。最简单的解决方案是说这不是Kubernetes的责任。负载均衡将在Kubernetes集群联合之外执行。但考虑到Kubernetes的动态特性，即使外部负载均衡器也必须收集关于每个集群上正在运行的服务和后端pod的大量信息。另一种解决方案是联合控制平面实现一个作为整个联合的流量导向器的L7负载均衡器。在较简单的用例中，每个服务在一个专用集群上运行，负载均衡器只是将所有流量路由到该集群。在集群故障的情况下，服务被迁移到另一个集群，负载均衡器现在将所有流量路由到新的集群。这提供了一个粗略的故障转移和集群级别的高可用性解决方案。
- en: 'The optimal solution will be able to support federated services and take into
    account additional factors, such as the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳解决方案将能够支持联合服务，并考虑其他因素，例如以下因素：
- en: Geo-location of client
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端的地理位置
- en: Resource utilization of each cluster
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个集群的资源利用率
- en: Resource quotas and auto-scaling
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源配额和自动扩展
- en: 'The following diagram shows how an L7 load balancer on GCE distributes client
    requests to the closest cluster:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了GCE上的L7负载均衡器如何将客户端请求分发到最近的集群：
- en: '![](Images/1add4f66-0a86-4972-a9b5-cc887d731c95.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1add4f66-0a86-4972-a9b5-cc887d731c95.png)'
- en: Failing over across multiple clusters
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨多个集群的故障转移
- en: Federated failover is tricky. Suppose a cluster in the federation fails; one
    option is to just have other clusters pick up the slack. Now, the question is,
    how do you distribute the load across other clusters?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 联合故障转移很棘手。假设联合中的一个集群失败；一个选择是让其他集群接管工作。现在的问题是，如何在其他集群之间分配负载？
- en: Uniformly?
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一吗？
- en: Launch a new cluster?
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动一个新的集群？
- en: Pick an existing cluster as close to this one as possible (maybe in the same
    region)?
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个尽可能接近的现有集群（可能在同一地区）？
- en: Each of these solutions has subtle interactions with federated load balancing,
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案与联合负载平衡有微妙的相互作用，
- en: geo-distributed high availability, cost management across different clusters,
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 地理分布的高可用性，跨不同集群的成本管理，
- en: and security.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 和安全。
- en: Now, the failed cluster comes back online. Should it gradually take over its
    original workload again? What if it comes back but with reduced capacity or sketchy
    networking? There are many combinations of failure modes that could make recovery
    complicated.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，失败的集群再次上线。它应该逐渐重新接管其原始工作负载吗？如果它回来了，但容量减少或网络不稳定怎么办？有许多故障模式的组合可能使恢复变得复杂。
- en: Federated migration
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦迁移
- en: 'Federated migration is related to several topics we discussed, such as location
    affinity, federated scheduling, and high availability. At its core, federated
    migration means moving a whole application or some part of it from one cluster
    to another (and more generally from M clusters to N clusters). Federation migration
    can happen in response to various events, such as the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦迁移与我们讨论过的几个主题相关，例如位置亲和性、联邦调度和高可用性。在其核心，联邦迁移意味着将整个应用程序或其部分从一个集群移动到另一个集群（更一般地从M个集群移动到N个集群）。联邦迁移可能是对各种事件的响应，例如以下事件：
- en: A low capacity event in a cluster (or a cluster failure)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群中的低容量事件（或集群故障）
- en: A change of scheduling policy (we no longer use cloud provider X)
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度策略的更改（我们不再使用云提供商X）
- en: A change of resource pricing (cloud provider Y dropped their prices, so let's
    migrate there)
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源定价的更改（云提供商Y降低了价格，所以让我们迁移到那里）
- en: A new cluster was added to or removed from the federation (let's rebalance the
    pods of the application)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联邦中添加或删除了一个新集群（让我们重新平衡应用程序的Pods）
- en: Strictly-coupled applications can be trivially moved, in part or in whole, one
    pod at a time, to one or more clusters (within applicable policy constraints,
    such as `PrivateCloudOnly`).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 严格耦合的应用程序可以轻松地一次移动一个Pod或整个Pod到一个或多个集群（在适用的策略约束条件下，例如“仅限私有云”）。
- en: For preferentially-coupled applications, the federation system must first locate
    a single cluster with sufficient capacity to accommodate the entire application,
    then reserve that capacity and incrementally move the application, one (or more)
    resource at a time, over to the new cluster within some bounded time period (and
    possibly within a predefined maintenance window).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于优先耦合的应用程序，联邦系统必须首先找到一个具有足够容量来容纳整个应用程序的单个集群，然后预留该容量，并逐步将应用程序的一个（或多个）资源在一定的时间段内移动到新集群中（可能在预定义的维护窗口内）。
- en: 'Strictly-coupled applications (with the exception of those deemed completely
    immovable) require the federation system to do the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 严格耦合的应用程序（除了被认为完全不可移动的应用程序）需要联邦系统执行以下操作：
- en: Start up an entire replica application in the destination cluster
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目标集群中启动整个副本应用程序
- en: Copy persistent data to the new application instance (possibly before
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将持久数据复制到新的应用程序实例（可能在之前
- en: starting pods)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Pods）
- en: Switch user traffic across
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换用户流量
- en: Tear down the original application instance
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆除原始应用程序实例
- en: Discovering a federated service
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现联邦服务
- en: Kubernetes provides KubeDNS as a built-in core component. KubeDNS uses a
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供KubeDNS作为内置核心组件。 KubeDNS使用
- en: '`cluster-local` DNS server as well as naming conventions to compose well-qualified'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`cluster-local` DNS服务器以及命名约定来组成合格的'
- en: (by namespace) DNS names conventions. For example, `the-service` is resolved
    to the `the-service` service in the default `namespace`, while `the-service.the-namespace`
    is resolved to the service called `the-service` in the `the-namespace namespace`,
    which is separate from the default `the-service`. Pods can find and access internal
    services easily with KubeDNS. Kubernetes cluster federation extends the mechanism
    to multiple clusters. The basic concept is the same, but another level of a federation
    is added. The DNS name of a service now consists of `<service name>.<namespace
    name>.<federation name>`. This way, internal service access is still usable using
    the original `<service name>.<namepace name>` naming convention. However, clients
    that want to access a federated service use the federated name that will be forwarded
    eventually to one of the federation member clusters to handle the request.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: （按命名空间）DNS名称约定。例如，“the-service”解析为默认“namespace”中的“the-service”服务，而“the-service.the-namespace”解析为“the-namespace
    namespace”中名为“the-service”的服务，该服务与默认的“the-service”不同。Pod可以使用KubeDNS轻松找到和访问内部服务。Kubernetes集群联邦将该机制扩展到多个集群。基本概念是相同的，但增加了另一级联邦。现在服务的DNS名称由“<service
    name>.<namespace name>.<federation name>”组成。这样，仍然可以使用原始的“<service name>.<namepace
    name>”命名约定来访问内部服务。但是，想要访问联邦服务的客户端使用联邦名称，最终将被转发到联邦成员集群中的一个来处理请求。
- en: This federation-qualified naming convention also helps prevent internal cluster
    traffic from reaching across to other clusters by mistake.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这种联邦限定的命名约定还有助于防止内部集群流量错误地到达其他集群。
- en: 'Using the preceding NGINX example service, and the federated service DNS name
    form just described, let''s consider an example: a pod in a cluster in the cluster-1
    availability zone needs to access the NGINX service. Rather than use the service''s
    traditional cluster-local DNS name (`nginx.the-namespace`, which is automatically
    expanded to `nginx.the-namespace.svc.cluster.local`), it can now use the service''s
    federated DNS name, which is `nginx.the-namespace.the-federation`. This will be
    automatically expanded and resolved to the closest healthy shard of the NGINX
    service, wherever in the world that may be. If a healthy shard exists in the local
    cluster, that service''s cluster-local (typically `10.x.y.z`) IP address will
    be returned (by the cluster-local KubeDNS). This is almost exactly equivalent
    to non-federated service resolution (almost because KubeDNS actually returns both
    a `CNAME` and an A record for local federated services, but applications will
    be oblivious to this minor technical difference).'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的NGINX示例服务和刚刚描述的联邦服务DNS名称形式，让我们考虑一个例子：位于cluster-1可用区的集群中的一个pod需要访问NGINX服务。它现在可以使用服务的联邦DNS名称，即“nginx.the-namespace.the-federation”，这将自动扩展并解析为NGINX服务的最近健康的分片，无论在世界的哪个地方。如果本地集群中存在健康的分片，该服务的集群本地（通常为“10.x.y.z”）IP地址将被返回（由集群本地的KubeDNS）。这几乎等同于非联邦服务解析（几乎因为KubeDNS实际上为本地联邦服务返回了CNAME和A记录，但应用程序对这种微小的技术差异是无感的）。
- en: However, if the service doesn't exist in the local cluster (or doesn't have
    healthy backend pods) the DNS query is expanded automatically.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果服务在本地集群中不存在（或者没有健康的后端pod），DNS查询会自动扩展。
- en: Running federated workloads
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行联邦工作负载
- en: Federated workloads are workloads that are processed on multiple Kubernetes
    clusters at the same time. This is relatively easy to do for loosely-coupled and
    embarrassingly-distributed applications. However, if most of the processing can
    be done in parallel, often there is a join point at the end, or at least a central
    persistent store that needs to be queried and updated. It gets more complicated
    if multiple pods of the same service need to cooperate across clusters, or if
    a collection of services (each one of them may be federated) must work together
    and be synchronized to accomplish something.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 联合工作负载是在多个Kubernetes集群上同时处理的工作负载。这对于松散耦合和分布式应用程序来说相对容易。然而，如果大部分处理可以并行进行，通常在最后会有一个连接点，或者至少需要查询和更新一个中央持久存储。如果同一服务的多个pod需要在集群之间合作，或者一组服务（每个服务可能都是联合的）必须共同工作并同步以完成某些任务，情况就会变得更加复杂。
- en: Kubernetes federation supports federated services that provide a great foundation
    for such federated workloads.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes联合支持提供了联合工作负载的良好基础的联合服务。
- en: Some key points for federated services are service discovery, cross-cluster
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 联合服务的一些关键点是服务发现，跨集群
- en: load-balancing, and availability zone fault tolerance.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡和可用性区容错。
- en: Creating a federated service
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建联合服务
- en: A federated service creates a corresponding service in the federation's member
    clusters.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 联合服务在联合成员集群中创建相应的服务。
- en: 'For example, to create a federated NGINX service (assuming you have the service
    configuration in `nginx.yaml`), type the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要创建一个联合NGINX服务（假设您在`nginx.yaml`中有服务配置），请输入以下内容：
- en: '[PRE41]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can verify a service was created in each cluster (for example, in `cluster-2`):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以验证每个集群中是否创建了一个服务（例如，在`cluster-2`中）：
- en: '[PRE42]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: All the created services in all the clusters will share the same namespace and
    service name, which makes sense since they are a single logical service.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 所有集群中创建的服务将共享相同的命名空间和服务名称，这是有道理的，因为它们是一个单一的逻辑服务。
- en: 'The status of your federated service will automatically reflect the real-time
    status of the underlying Kubernetes services:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您的联合服务的状态将自动反映基础Kubernetes服务的实时状态：
- en: '[PRE43]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Adding backend pods
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加后端pod
- en: 'As of Kubernetes 1.10, we still need to add backend pods to each federation
    member cluster. This can be done with the `kubectl run` command. In a future release,
    the Kubernetes federation API server will be able to do it automatically. This
    will save one more step. Note that when you use the `kubectl run` command, Kubernetes
    automatically adds the run label to the pod based on the image name. In the following
    example, which launches an NGINX backend pod on five Kubernetes clusters, the
    image name is `nginx` (ignoring the version), so the following label is added:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 截至Kubernetes 1.10，我们仍然需要将后端pod添加到每个联合成员集群。这可以通过`kubectl run`命令完成。在将来的版本中，Kubernetes联合API服务器将能够自动执行此操作。这将节省一步。请注意，当您使用`kubectl
    run`命令时，Kubernetes会根据镜像名称自动向pod添加运行标签。在下面的示例中，该示例在五个Kubernetes集群上启动了一个NGINX后端pod，镜像名称为`nginx`（忽略版本），因此将添加以下标签：
- en: '[PRE44]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is necessary because the service uses that label to identify its pods.
    If you use another label, you need to add it explicitly:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为服务使用该标签来识别其pod。如果使用另一个标签，需要显式添加它：
- en: '[PRE45]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Verifying public DNS records
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证公共DNS记录
- en: 'Once the preceding pods have successfully started and are listening for connections,
    Kubernetes will report them as healthy endpoints of the service in that cluster
    (through automatic health checks). The Kubernetes cluster federation will in turn
    consider each of these service shards to be healthy, and place them in service
    by automatically configuring corresponding public DNS records. You can use your
    preferred interface from your configured DNS provider to verify this. For example,
    your federation may be configured to use Google Cloud DNS and a managed DNS domain,
    `example.com`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦前面的pod成功启动并监听连接，Kubernetes将把它们报告为该集群中服务的健康端点（通过自动健康检查）。Kubernetes集群联邦将进一步考虑这些服务分片中的每一个为健康，并通过自动配置相应的公共DNS记录将它们放入服务中。你可以使用你配置的DNS提供商的首选界面来验证这一点。例如，你的联邦可能配置为使用Google
    Cloud DNS和一个托管的DNS域，`example.com`：
- en: '[PRE46]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Follow up with the following command to see the actual DNS records:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 跟进以下命令以查看实际的DNS记录：
- en: '[PRE47]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If your federation is configured to use the `aws route53` DNS service, use
    the following commands:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的联邦配置为使用`aws route53` DNS服务，请使用以下命令：
- en: '[PRE48]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then use this command:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用这个命令：
- en: '[PRE49]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can, of course, use standard DNS tools such as `nslookup` or `dig` to verify
    DNS records were updated properly. You may have to wait a little for your changes
    to propagate. Alternatively, you can point directly to your DNS provider:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以使用标准的DNS工具，比如`nslookup`或`dig`来验证DNS记录是否被正确更新。你可能需要等一会儿才能使你的更改传播开来。或者，你可以直接指向你的DNS提供商：
- en: '[PRE50]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: However, I always prefer to observe DNS changes in the wild after they were
    properly propagated, so I can inform users that everything is ready to go.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我总是更喜欢在DNS更改在正确传播后观察它们的变化，这样我就可以通知用户一切都准备就绪。
- en: DNS expansion
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS扩展
- en: If the service does not exist in the local cluster (or it exists but has no
    healthy backend pods), the DNS query is automatically expanded to find the external
    IP address closest to the requestor's availability zone. KubeDNS performs this
    automatically and returns the corresponding `CNAME`. That will get further resolved
    to the IP address of one of the service's backing pods.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务在本地集群中不存在（或者存在但没有健康的后端pod），DNS查询会自动扩展，以找到最接近请求者可用区域的外部IP地址。KubeDNS会自动执行这个操作，并返回相应的`CNAME`。这将进一步解析为服务的一个后备pod的IP地址。
- en: You don't have to rely on automatic DNS expansion. You can also provide the
    `CNAME` of a service in a particular cluster directly or in a particular region.
    For example, on GCE/GKE you can specify `nginx.the-namespace.svc.europe-west1.example.com`.
    That will get resolved to a backing pod of the service in one of the clusters
    in Europe (assuming there are clusters and healthy backing pods there).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必依赖自动DNS扩展。你也可以直接提供特定集群中或特定区域中服务的`CNAME`。例如，在GCE/GKE上，你可以指定`nginx.the-namespace.svc.europe-west1.example.com`。这将被解析为欧洲某个集群中服务的一个后备pod的IP地址（假设那里有集群和健康的后备pod）。
- en: 'External clients can''t utilize DNS expansion, but if they want to target some
    restricted subset of the federation (such as a particular region) then they can
    provide the service''s fully qualified `CNAME` just as the example. Since those
    names tend to be long and cumbersome, a good practice is to add some static convenience
    `CNAME` records:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 外部客户端无法使用DNS扩展，但如果他们想要针对联邦的某个受限子集（比如特定区域），他们可以提供服务的完全限定的`CNAME`，就像例子一样。由于这些名称往往又长又笨重，一个好的做法是添加一些静态方便的`CNAME`记录：
- en: '[PRE51]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following diagram shows how a federated lookup works across multiple clusters:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了联邦查找在多个集群中是如何工作的：
- en: '![](Images/07c14135-6427-484a-93c4-08f0e73fd168.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07c14135-6427-484a-93c4-08f0e73fd168.png)'
- en: Handling failures of backend pods and whole clusters
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理后端pod和整个集群的故障
- en: Kubernetes will take non-responsive pods out of service within a few seconds.
    The federation control plane monitors the health of clusters and the endpoints
    behind all of the shards of your federated service in the different clusters.
    It will take them in and out of service as required, for example, when all of
    the endpoints behind a service, an entire cluster, or a whole availability zone
    go down. The inherent latency of DNS caching (3 minutes for Federated Service
    DNS records by default), may send failover of clients to an alternative cluster
    in the case of catastrophic failure. However, given the number of discrete IP
    addresses that can be returned for each regional service endpoint (see, for example,
    `us-central1`, which has three alternatives), many clients will fail over automatically
    to one of the alternative IPs in less time than that, given the appropriate configuration.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes将在几秒内将无响应的Pod从服务中移除。联邦控制平面监视集群的健康状况，以及不同集群中联邦服务的所有分片后面的端点。根据需要，它将将它们加入或移出服务，例如当服务后面的所有端点、整个集群或整个可用区都宕机时。DNS缓存的固有延迟（默认情况下联邦服务DNS记录为3分钟），可能会在发生灾难性故障时将客户端的故障转移至另一个集群。然而，考虑到每个区域服务端点可以返回的离散IP地址数量（例如，`us-central1`有三个备用项），许多客户端将在比这更短的时间内自动切换到其中一个备用IP，前提是进行了适当的配置。
- en: Troubleshooting
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除
- en: When things go south, you need to be able to figure out what's wrong and how
    to fix it. Here are a few common problems and how to diagnose/fix them.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当事情出现问题时，您需要能够找出问题所在以及如何解决。以下是一些常见问题以及如何诊断/解决它们。
- en: Unable to connect to federation API server
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无法连接到联邦API服务器
- en: 'Refer to the following solution:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下解决方案：
- en: Verify the federation API server is running
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证联邦API服务器正在运行
- en: Verify the client (Kubectl) is configured correctly with proper API endpoints
    and credentials
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证客户端（Kubectl）是否正确配置了适当的API端点和凭据
- en: Federated service is created successfully but no service is created in the underlying
    clusters
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联邦服务成功创建，但基础集群中未创建服务
- en: Verify the clusters are registered with federation
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证集群是否已注册到联邦
- en: Verify the federation API server was able to connect and authenticate against
    all clusters
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证联邦API服务器能够连接并对所有集群进行身份验证
- en: Check quotas are sufficient
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查配额是否足够
- en: 'Check the logs for other problems:'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查日志是否有其他问题：
- en: '[PRE52]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Summary
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've covered the important topic of Kubernetes cluster federation.
    Cluster federation is still in beta and is a little raw, but it is already usable.
    There aren't a lot of deployments and the officially supported target platforms
    are currently AWS and GCE/GKE, but there is a lot of momentum behind cloud federation.
    It is a very important piece for building massively scalable systems on Kubernetes.
    We've discussed the motivation and use cases for Kubernetes cluster federation,
    the federation control plane components, and the federated Kubernetes objects.
    We also looked into the less supported aspects of federation, such as custom scheduling,
    federated data access, and auto-scaling. We then looked at how to run multiple
    Kubernetes clusters, which includes setting up a Kubernetes cluster federation,
    adding and removing clusters to the federation along with load balancing, federated
    failover when something goes wrong, service discovery, and migration. Then, we
    dived into running federated workloads across multiple clusters with federated
    services and the various challenges associated with this scenario.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经涵盖了Kubernetes集群联邦的重要主题。集群联邦仍处于测试阶段，有些粗糙，但已经可以使用。部署并不多，目前官方支持的目标平台是AWS和GCE/GKE，但云联邦背后有很大的动力。这对于在Kubernetes上构建大规模可扩展系统非常重要。我们讨论了Kubernetes集群联邦的动机和用例，联邦控制平面组件以及联邦Kubernetes对象。我们还研究了联邦的一些不太受支持的方面，比如自定义调度、联邦数据访问和自动扩展。然后，我们看了如何运行多个Kubernetes集群，包括设置Kubernetes集群联邦，向联邦添加和移除集群以及负载平衡、联邦故障转移、服务发现和迁移。然后，我们深入研究了在多个集群上运行联合工作负载的情况，包括联合服务以及与此场景相关的各种挑战。
- en: At this point, you should have a clear understanding of the current state of
    federation, what it takes to utilize the existing capabilities provided by Kubernetes,
    and what pieces you'll have to implement yourself to augment incomplete or immature
    features. Depending on your use case, you may decide that it's still too early
    or that you want to take the plunge. The developers working on Kubernetes federation
    are moving fast, so it's very likely that it will be much more mature and battle-tested
    by the time you need to make your decision.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该对联邦的当前状态有清晰的了解，知道如何利用Kubernetes提供的现有功能，并了解您需要自己实现哪些部分来增强不完整或不成熟的功能。根据您的用例，您可能会决定现在还为时过早，或者您想要冒险尝试。致力于Kubernetes联邦的开发人员行动迅速，因此很可能在您需要做出决定时，它将更加成熟和经过实战检验。
- en: In the next chapter, we'll dig into Kubernetes internals and how to customize
    it. One of the prominent architectural principles of Kubernetes is that it is
    accessible through a full-fledged REST API. The Kubectl command-line tool is built
    on top the Kubernetes API and provides interactivity to the full spectrum of Kubernetes.
    However, the programmatic API access gives you a lot of flexibility to enhance
    and extend Kubernetes. There are client libraries in many languages that allow
    you to leverage Kubernetes from the outside and integrate it into existing systems.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究Kubernetes的内部结构以及如何自定义它。Kubernetes的一个显著的架构原则是，它可以通过一个完整的REST API进行访问。Kubectl命令行工具是建立在Kubernetes
    API之上的，并为Kubernetes的整个范围提供交互性。然而，编程API访问为您提供了许多灵活性，以增强和扩展Kubernetes。许多语言中都有客户端库，允许您从外部利用Kubernetes并将其集成到现有系统中。
- en: In addition to its REST API, Kubernetes is a very modular platform by design.
    Many aspects of its core operation can be customized and/or extended. In particular,
    you can add user-defined resources and integrate them with the Kubernetes object
    model and benefit from the management services of Kubernetes, storage in `etcd`,
    exposure through the API, and uniform access to built-in and custom objects.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其REST API之外，Kubernetes在设计上是一个非常模块化的平台。它的核心操作的许多方面都可以定制和/或扩展。特别是，你可以添加用户定义的资源，并将它们与Kubernetes对象模型集成，并从Kubernetes的管理服务、`etcd`中的存储、通过API的暴露以及对内置和自定义对象的统一访问中受益。
- en: We've already seen various aspects that are extremely extensible, such as networking
    and access control through CNI plugins and custom storage classes. However, Kubernetes
    goes even further and lets you customize the scheduler itself, which controls
    pod assignment to nodes.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些非常可扩展的方面，比如通过CNI插件和自定义存储类进行网络和访问控制。然而，Kubernetes甚至可以让你定制调度器本身，这个调度器控制着pod分配到节点上。
