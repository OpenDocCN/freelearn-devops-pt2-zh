- en: 12\. Your Application and HA
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12\. 您的应用程序和HA
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will explore Kubernetes cluster life cycle management through
    the use of Terraform and Amazon **Elastic Kubernetes Service** (**EKS**). We will
    also deploy an application and learn some principles to make applications better
    suited to the Kubernetes environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将通过使用Terraform和Amazon **Elastic Kubernetes Service** (**EKS**)来探索Kubernetes集群的生命周期管理。我们还将部署一个应用程序，并学习一些原则，使应用程序更适合Kubernetes环境。
- en: This chapter will walk you through using Terraform to create a fully functioning,
    highly available Kubernetes environment. You will deploy an application to the
    cluster and modify its functionality to make it suitable for a highly available
    environment. We will also learn how to get traffic from the internet to an application
    running in a cluster by using a Kubernetes ingress resource.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将指导您如何使用Terraform创建一个功能齐全、高可用的Kubernetes环境。您将在集群中部署一个应用程序，并修改其功能，使其适用于高可用环境。我们还将学习如何通过使用Kubernetes入口资源将来自互联网的流量传输到集群中运行的应用程序。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we set up our first multi-node Kubernetes cluster in
    a cloud environment. In this section, we're going to talk about how we operationalize
    a Kubernetes cluster for our application—that is, we will use the cluster to run
    a containerized application other than the dashboard.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在云环境中设置了我们的第一个多节点Kubernetes集群。在本节中，我们将讨论如何为我们的应用程序操作Kubernetes集群，即我们将使用集群来运行除了仪表板之外的容器化应用程序。
- en: Since Kubernetes has as many uses as can be imagined by a cluster operator,
    no two use cases for Kubernetes are alike. So, we're going to make some assumptions
    about the type of application that we're operationalizing our cluster for. We're
    going to optimize a workflow for deploying a stateless web application with a
    stateful backend that has high-availability requirements in a cloud-based environment.
    In doing so, we're hopefully going to cover a large percentage of what people
    generally use Kubernetes clusters for.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Kubernetes的用途与集群操作员所能想象的一样多，因此Kubernetes的用例各不相同。因此，我们将对我们为集群操作的应用程序类型做一些假设。我们将优化一个工作流程，用于在基于云的环境中部署具有高可用性要求的具有有状态后端的无状态Web应用程序。通过这样做，我们希望能够涵盖人们通常使用Kubernetes集群的大部分内容。
- en: Kubernetes can be used for just about anything. Even if what we cover does not
    exactly match your use case for Kubernetes, it's worth studying since this point
    is important. What we're going to be doing in this chapter is merely running through
    an example workflow for running a web application on Kubernetes in the cloud.
    Once you have studied the principles that we will use for running the example
    workflow in this chapter, you can look up many other resources on the internet
    that can help you discover other ways of optimizing your workflow with Kubernetes
    if this doesn't fit your use case.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes可以用于几乎任何事情。即使我们所涵盖的内容与您对Kubernetes的用例不完全匹配，也值得研究，因为这一点很重要。在本章中，我们要做的只是在云中运行一个Web应用程序的示例工作流程。一旦您学习了本章中我们将用于运行示例工作流程的原则，您可以在互联网上查找许多其他资源，帮助您发现其他优化工作流程的方式，如果这不符合您的用例。
- en: But before we move on to ensure the high availability of the application that
    we will be running on the cluster, let's take a step back and consider the high-availability
    requirements for your cloud infrastructure. In order to maintain high availability
    at an application level, it is also imperative that we manage our infrastructure
    with the same goal in mind. This brings us to a discussion about infrastructure
    life cycle management.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们继续确保我们将在集群上运行的应用程序的高可用性之前，让我们退一步考虑一下你的云基础设施的高可用性要求。为了在应用程序级别保持高可用性，同样重要的是我们以同样的目标来管理我们的基础设施。这让我们开始讨论基础设施生命周期管理。
- en: An Overview of Infrastructure Life Cycle Management
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施生命周期管理概述
- en: In simple words, infrastructure life cycle management refers to how we manage
    our servers through each phase of its useful life. This involves provisioning,
    maintaining, and decommissioning physical hardware or cloud resources. Since we
    are leveraging cloud infrastructure, we should leverage infrastructure life cycle
    management tools to provision and de-provision resources programmatically. To
    understand why this is important, let's consider the following example.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，基础设施生命周期管理是指我们如何在服务器的有用生命周期的每个阶段管理我们的服务器。这涉及到提供、维护和 decommissioning 物理硬件或云资源。由于我们正在利用云基础设施，我们应该利用基础设施生命周期管理工具来以编程方式提供和取消资源。为了理解这一点为什么重要，让我们考虑以下例子。
- en: Imagine for a moment that you work as a system administrator, DevOps engineer,
    site reliability engineer, or any other role that requires you to deal with server
    infrastructure for a company that is in the digital news industry. What that means
    is that the primary output of the people who are working for this company is the
    information that they publish on their website. Now, imagine that the entirety
    of the website runs on one server in your company's server room. The application
    running on the server is a PHP blog site with a MySQL backend. One day, an article
    goes viral and suddenly you are handling an exponentially higher amount of traffic
    than you were handling the day before. What do you do? The website keeps crashing
    (if it loads at all) and your company is losing money while you try to figure
    out a solution.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你是一名系统管理员、DevOps工程师、站点可靠性工程师，或者其他需要处理公司服务器基础设施的角色，而这家公司是数字新闻行业的公司。这意味着，这家公司的员工主要输出的是他们在网站上发布的信息。现在，想象一下，整个网站都在你公司服务器房的一台服务器上运行。服务器上运行的应用程序是一个带有MySQL后端的PHP博客网站。有一天，一篇文章突然爆红，你突然要处理的流量比前一天多得多。你会怎么做？网站一直崩溃（如果加载的话），你的公司正在因为你试图找到解决方案而损失金钱。
- en: Your solution is to start separating concerns and isolating single points of
    failure. The first thing you do is buy a lot more hardware and start configuring
    it to hopefully scale the website horizontally. After doing this, you're running
    five servers, with one running HAProxy, which is load-balancing connections to
    your PHP application running on three servers and a database server. OK, now you
    think that you have it under control. However, not all of the server hardware
    is the same—they run different distributions of Linux, the resource requirements
    are different for each machine, and patching, upgrading, and maintaining each
    server individually becomes difficult. Well, as luck would have it, another article
    goes viral and suddenly you're experiencing five times more requests than the
    current hardware can handle. What do you do now? Keep scaling it out horizontally?
    You're only one person, though, so you're bound to make a mistake in configuring
    the next set of servers. Due to that mistake, you've crashed the website in new
    and exciting ways that no one in management is happy about. Are you feeling as
    stressed reading this as I was writing it?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你的解决方案是开始分离关注点并隔离单点故障。你首先要做的是购买更多的硬件并开始配置它，希望能够水平扩展网站。做完这些之后，你运行了五台服务器，其中一台运行着HAProxy，它负载均衡连接到运行在三台服务器上的PHP应用程序和一个数据库服务器上。好吧，现在你觉得你已经控制住了。然而，并非所有的服务器硬件都是一样的——它们运行着不同的Linux发行版，每台机器的资源需求也不同，对每台服务器进行补丁、升级和维护变得困难。好巧不巧，又一篇文章突然爆红，你突然面临着比当前硬件能处理的请求量多五倍的情况。现在你该怎么办？继续水平扩展？然而，你只是一个人，所以在配置下一组服务器时很可能会出错。由于这个错误，你以新颖的方式使网站崩溃了，管理层对此并不高兴。你读到这里是不是感到和我写这篇文章时一样紧张？
- en: It's because of misconfigurations that engineers began to leverage tools and
    configuration written in source code to define their topologies. That way, if
    a mutation in the infrastructure state is required, it can be tracked, controlled,
    and rolled out in a way that makes the code responsible for resolving differences
    between your declared infrastructure state and what it observes in reality.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为配置错误，工程师们开始利用工具和配置编写源代码来定义他们的拓扑结构。这样，如果需要对基础设施状态进行变更，就可以跟踪、控制并以一种使代码负责解决你声明的基础设施状态与实际观察到的状态之间差异的方式进行部署。
- en: Infrastructure is only as good as the life cycle management tools that surround
    it and the application that runs atop it. What this means is that if your cluster
    is well-built but there is no tool that exists to successfully update your application
    on that cluster, then it won't serve you well. In this chapter, we're going to
    take a look at an application-level view of how we can leverage a continuous integration
    build pipeline to be able to roll out new updates to our application in a zero-downtime,
    cloud-native manner.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施的好坏取决于围绕它的生命周期管理工具和运行在其之上的应用程序。这意味着，如果你的集群构建得很好，但没有工具可以成功地更新集群上的应用程序，那么它就不会为你服务。在本章中，我们将从应用程序级别的视角来看如何利用持续集成构建流水线以零停机、云原生的方式推出新的应用程序更新。
- en: In this chapter, we will provide a test application for you to manage. We will
    also be using an infrastructure life cycle management tool called **Terraform**
    in order to manage the Deployment of Kubernetes cloud infrastructure more efficiently.
    This chapter should help you develop an effective skill set that will allow you
    to begin creating your own application delivery pipeline in your own environment
    in Kubernetes very quickly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为您提供一个测试应用程序进行管理。我们还将使用一个名为**Terraform**的基础设施生命周期管理工具，以更有效地管理Kubernetes云基础设施的部署。本章应该能帮助您开发出一套有效的技能，让您能够在Kubernetes环境中快速开始创建自己的应用程序交付流水线。
- en: Terraform
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform
- en: In the last chapter, we used **kops** to create a Kubernetes cluster from scratch.
    However, this process can be viewed as tedious and difficult to replicate, which
    creates a high probability of misconfiguration, resulting in unexpected events
    at application runtime. Luckily, there is a very powerful community-supported
    tool that solves this issue very well for Kubernetes clusters running on **Amazon
    Web Services** (**AWS**), as well as several other cloud platforms, such as Azure,
    **Google Cloud Platform** (**GCP**), and many more.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用**kops**从头开始创建了一个Kubernetes集群。然而，这个过程可能被视为繁琐且难以复制，这会导致配置错误的高概率，从而在应用程序运行时导致意外事件。幸运的是，有一个非常强大的社区支持的工具，可以很好地解决这个问题，适用于在**亚马逊网络服务**（**AWS**）以及其他几个云平台上运行的Kubernetes集群，比如Azure、**谷歌云平台**（**GCP**）等。
- en: Terraform is a general-purpose infrastructure life cycle management tool; that
    is, Terraform can manage the state of your infrastructure as defined through code.
    The goal of Terraform, when it was initially created, was to create both a language
    (**HashiCorp Configuration Language** (**HCL**)) and runtime that can create infrastructure
    in a repeatable manner and control changes to that infrastructure in the same
    way that we control changes to application source code—through pull requests,
    reviews, and version control. Terraform has since grown considerably, and it is
    now a general-purpose configuration management tool. In this chapter, we will
    be using its original functionality of infrastructure life cycle management in
    its most classical sense.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform是一种通用的基础设施生命周期管理工具；也就是说，Terraform可以通过代码管理您的基础设施的状态。Terraform最初创建时的目标是创建一种语言（**HashiCorp配置语言**（**HCL**））和运行时，可以以可重复的方式创建基础设施，并以与我们控制应用程序源代码变更相同的方式控制对基础设施的变更——通过拉取请求、审查和版本控制。Terraform自那时以来已经有了相当大的发展，现在是一种通用的配置管理工具。在本章中，我们将使用其最经典的意义上的基础设施生命周期管理的原始功能。
- en: Terraform files are written in a language called HCL. HCL looks a lot like YAML
    and JSON, but with a few differences. For example, HCL supports the interpolation
    of references to other resources in its files and is capable of determining the
    order in which resources need to be created so as to ensure that resources that
    depend on the creation of other resources won't be created in the wrong order.
    Terraform files have the `.tf` file extension.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform文件是用一种叫做HCL的语言编写的。HCL看起来很像YAML和JSON，但有一些不同之处。例如，HCL支持在其文件中对其他资源的引用进行插值，并能够确定需要创建资源的顺序，以确保依赖于其他资源创建的资源不会以错误的顺序创建。Terraform文件的文件扩展名是`.tf`。
- en: You can think of a Terraform file as specifying the desired state of your entire
    infrastructure in a similar way as, for example, a Kubernetes YAML file would
    specify the desired state of a Deployment. This allows the declarative management
    of your entire infrastructure. So, we arrive at the idea of managing **Infrastructure
    as Code** (**IaC**).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将Terraform文件视为以类似的方式指定整个基础设施的期望状态，例如，Kubernetes YAML文件将指定部署的期望状态。这允许声明式地管理整个基础设施。因此，我们得到了**基础设施即代码**（**IaC**）的管理思想。
- en: Terraform works in two stages—**plan** and **apply**. This is to ensure that
    you have the chance to review infrastructure changes before making them. Terraform
    assumes that it alone is responsible for all state changes to your infrastructure.
    So, if you are using Terraform to manage your infrastructure, it would be inadvisable
    to make infrastructure changes by any other means (for example, by adding a resource
    via the AWS console). This is because if you make a change and don't make sure
    that it is updated in the Terraform file, then the next time the Terraform file
    is applied, it will remove your one-time change. It isn't a bug, it's a feature,
    for real this time. The reason for this is that when you track infrastructure
    as code, every change can be tracked, reviewed, and managed with automated tooling,
    such as a CI/CD pipeline. So, if the state of your system drifts away from what
    is written down, then Terraform will be responsible for reconciling your observed
    infrastructure to what you have written down.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform分为两个阶段——**计划**和**应用**。这是为了确保您有机会在进行更改之前审查基础设施更改。Terraform假设它独自负责对基础设施的所有状态更改。因此，如果您使用Terraform来管理基础设施，通过任何其他方式进行基础设施更改（例如，通过AWS控制台添加资源）是不明智的。这是因为如果您进行更改并且没有确保它在Terraform文件中得到更新，那么下次应用Terraform文件时，它将删除您一次性的更改。这不是一个错误，这是一个功能，这次是真的。这样做的原因是，当您跟踪基础设施作为代码时，每个更改都可以被跟踪、审查和使用自动化工具进行管理，例如CI/CD流水线。因此，如果您的系统状态偏离了书面状态，那么Terraform将负责将您观察到的基础设施与您书面记录的内容进行调和。
- en: In this chapter, we will introduce you to Terraform as it is very commonly used
    in the industry as a convenient way to manage infrastructure as code. However,
    we will not dive deep into creating every single AWS resource with Terraform to
    keep our discussion focused on Kubernetes. We will just carry out a quick demo
    to ensure that you understand some basic principles.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您介绍Terraform，因为它在行业中被广泛使用，作为管理基础设施的便捷方式。但是，我们不会深入到使用Terraform创建每一个AWS资源，以便让我们的讨论集中在Kubernetes上。我们只会进行一个快速演示，以确保您理解一些基本原则。
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more about using Terraform for AWS in this book: [https://www.packtpub.com/networking-and-servers/getting-started-terraform-second-edition](https://www.packtpub.com/networking-and-servers/getting-started-terraform-second-edition
    )'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书中了解有关在AWS中使用Terraform的更多信息：[https://www.packtpub.com/networking-and-servers/getting-started-terraform-second-edition](https://www.packtpub.com/networking-and-servers/getting-started-terraform-second-edition)
- en: 'Exercise 12.01: Creating an S3 Bucket with Terraform'
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.01：使用Terraform创建S3存储桶
- en: In this exercise, we will implement some common commands that you will use when
    working with Terraform and introduce you to a Terraform file that will be the
    definition of our infrastructure as code
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现一些常用的命令，这些命令在使用Terraform时会用到，并向您介绍一个Terraform文件，该文件将是我们基础设施的定义。
- en: Note
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Terraform will create resources on our behalf in AWS, which will cost you money.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform将代表我们在AWS上创建资源，这将花费你的钱。
- en: 'First, let''s make a directory where we''re going to make our Terraform changes,
    and then we will navigate to that directory:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个目录，我们将在其中进行Terraform更改，然后我们将导航到该目录：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we''re going to make our first Terraform file. Terraform files have a
    `.tf` file extension. Create a file named `main.tf` (there is no significance
    to the word `main`, unlike some other languages) with the following content:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们要创建我们的第一个Terraform文件。Terraform文件的扩展名是`.tf`。创建一个名为`main.tf`的文件（与其他一些语言不同，单词`main`没有特殊意义），内容如下：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This block has a definition called `aws_s3_bucket`, which means that it will
    create an Amazon S3 bucket with the name specified in the `bucket` field. The
    `acl="private"` line indicates that we are not allowing public access to this
    bucket. Be sure to replace `<<NAME>>` with a unique name of your own.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块有一个叫做`aws_s3_bucket`的定义，这意味着它将创建一个Amazon S3存储桶，其名称在`bucket`字段中指定。`acl="private"`行表示我们不允许公共访问这个存储桶。请确保用您自己的唯一名称替换`<<NAME>>`。
- en: 'To get started with Terraform, we need to initialize it. So, let''s do that
    with the following command:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始使用Terraform，我们需要初始化它。因此，让我们用以下命令来做到这一点：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see the following response:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 12.1: Initializing Terraform'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1：初始化Terraform'
- en: '](image/B14870_12_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_01.jpg)'
- en: 'Figure 12.1: Initializing Terraform'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：初始化Terraform
- en: 'Run the following command to have Terraform determine a plan to create resources
    defined by the `main.tf` file that we created earlier:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，让Terraform确定创建资源的计划，这些资源由我们之前创建的`main.tf`文件定义：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will be prompted to enter an AWS region. Use the one that''s closest to
    you. In the following screenshot, we are using `us-west-2`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被提示输入一个AWS区域。使用离您最近的一个。在下面的屏幕截图中，我们使用的是`us-west-2`：
- en: '![Figure 12.2: Calculating the required changes to the cluster resources'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2：计算集群资源所需的更改'
- en: for creating an S3 bucket
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建S3存储桶
- en: '](image/B14870_12_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_02.jpg)'
- en: 'Figure 12.2: Calculating the required changes to the cluster resources for
    creating an S3 bucket'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：计算创建S3存储桶所需的集群资源的必要更改
- en: So, we can see that Terraform has accessed our AWS account using the access
    keys that we set up in *Exercise 11.01, Setting Up Our Kubernetes Cluster* of
    the previous chapter and calculated what it will need to do in order to make our
    AWS environment look like what we have defined in our Terraform file. As we can
    see in the screenshot, it's planning to add an S3 bucket for us, which is what
    we want.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到Terraform已经使用我们在上一章*练习11.01，在我们的Kubernetes集群中设置AWS账户*中设置的访问密钥访问了我们的AWS账户，并计算了为使我们的AWS环境看起来像我们在Terraform文件中定义的那样需要做什么。正如我们在屏幕截图中看到的，它计划为我们添加一个S3存储桶，这正是我们想要的。
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Terraform will try to apply all the files with a `.tf` extension in your current
    working directory.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform将尝试应用当前工作目录中所有扩展名为`.tf`的文件。
- en: In the previous screenshot, we can see that the `terraform` command is indicating
    that we haven't specified an `-out` parameter, so it won't guarantee that the
    exact calculated plan will be applied. This is because something in your AWS infrastructure
    could have changed from the time of planning to the time of applying. Let's say
    that you calculate a plan today. Then, later, you add or remove a few resources.
    So, the required modifications to achieve the given state would be different.
    So, unless you specify the `-out` parameter, Terraform will recalculate its plan
    before applying it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个屏幕截图中，我们可以看到`terraform`命令指示我们没有指定`-out`参数，因此它不会保证精确计划将被应用。这是因为您的AWS基础设施中的某些内容可能已经从计划时发生了变化。假设您今天计划了一个计划。然后，稍后，您添加或删除了一些资源。因此，为了实现给定状态所需的修改将是不同的。因此，除非您指定`-out`参数，否则Terraform将在应用之前重新计算其计划。
- en: 'Run the following command to apply the configuration and create the resources
    specified in our Terraform file:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来应用配置并创建我们Terraform文件中指定的资源：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Terraform will give us one more chance to review the plan and decide what we
    want to do before making the changes to the AWS resources for us:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform将为我们提供一次机会来审查计划并在对AWS资源进行更改之前决定我们想要做什么：
- en: '![Figure 12.3: Calculation of the changes and confirmation prompt for creating
    an S3 bucket'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3：计算更改并确认创建S3存储桶的提示'
- en: '](image/B14870_12_03.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_03.jpg)'
- en: 'Figure 12.3: Calculation of the changes and confirmation prompt for creating
    an S3 bucket'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：计算更改并确认创建S3存储桶的提示
- en: 'As mentioned earlier, Terraform calculated the required changes even when we
    used the `apply` command. Confirm the actions displayed by Terraform, and then
    enter `yes` to proceed with the plan displayed. Now, Terraform has made an S3
    bucket for us:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，即使我们使用`apply`命令，Terraform也计算了所需的更改。确认Terraform显示的操作，然后输入`yes`以执行显示的计划。现在，Terraform已经为我们创建了一个S3存储桶：
- en: '![Figure 12.4: Creating an S3 bucket after confirmation'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4：确认后创建S3存储桶'
- en: '](image/B14870_12_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_04.jpg)'
- en: 'Figure 12.4: Creating an S3 bucket after confirmation'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：确认后创建S3存储桶
- en: 'Now, we''re going to destroy all the resources that we created to clean up
    before we move on to the next exercise. To destroy them, run the following command:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将销毁我们创建的所有资源，以便在进行下一个练习之前进行清理。要销毁它们，请运行以下命令：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Again, to confirm this action, you must explicitly allow Terraform to destroy
    your resources by entering `yes` when prompted, as in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，要确认此操作，您必须在提示时明确允许Terraform销毁您的资源，输入`yes`，如以下屏幕截图所示：
- en: '![Figure 12.5: Destroying resources created using Terraform'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5：使用Terraform销毁资源'
- en: '](image/B14870_12_05.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_05.jpg)'
- en: 'Figure 12.5: Destroying resources created using Terraform'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：使用Terraform销毁资源
- en: In this exercise, we demonstrated how to create a single resource (an S3 bucket)
    using Terraform, and also how to destroy a bucket. This should have familiarized
    you with the simple tooling of Terraform, and we will now expand on these concepts
    further.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们演示了如何使用Terraform创建单个资源（S3存储桶），以及如何销毁存储桶。这应该让您熟悉了Terraform的简单工具，并且我们现在将进一步扩展这些概念。
- en: Now, let's make a Kubernetes cluster with Terraform. Last time, we built and
    managed our own cluster control plane. Since almost every cloud provider provides
    this service to their customers, we will be leveraging Amazon **Elastic Kubernetes
    Service** (**EKS**), a **managed service** for Kubernetes provided by AWS.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Terraform创建一个Kubernetes集群。上次，我们构建并管理了自己的集群控制平面。由于几乎每个云提供商都为他们的客户提供此服务，我们将利用由AWS提供的Kubernetes的托管服务Amazon弹性Kubernetes服务（EKS）。
- en: 'When we use a managed Kubernetes service, the following is taken care of by
    the cloud service vendor:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用托管的Kubernetes服务时，以下内容由云服务供应商处理：
- en: Managing and securing etcd
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理和保护etcd
- en: Managing and securing user authentication
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理和保护用户身份验证
- en: Managing the control plane components, such as the controller manager(s), the
    scheduler, and the API server
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理控制平面组件，如控制器管理器、调度器和API服务器
- en: Provisioning the CNI running between Pods in your network
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的网络中运行的Pod之间进行CNI配置
- en: The control plane is exposed to your nodes through elastic network interfaces
    bound to your VPC. You still need to manage the worker nodes and they run as EC2
    instances in your account. So, using a managed service allows you to focus on
    the work that you want to get done using Kubernetes, but the drawback is not having
    very granular control of the control plane.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 控制平面通过绑定到您的VPC的弹性网络接口暴露给您的节点。您仍然需要管理工作节点，它们作为您帐户中的EC2实例运行。因此，使用托管服务允许您专注于使用Kubernetes完成的工作，但缺点是对控制平面没有非常精细的控制。
- en: Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since AWS handles user authentication for the cluster, we will have to use AWS
    IAM credentials to access our Kubernetes clusters. We can leverage the AWS IAM
    Authenticator binary on our machines to do that. More on this in the upcoming
    sections.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于AWS处理集群的用户身份验证，我们将不得不使用AWS IAM凭据来访问我们的Kubernetes集群。我们可以在我们的机器上利用AWS IAM Authenticator二进制文件来做到这一点。关于这一点，我们将在接下来的章节中详细介绍。
- en: 'Exercise 12.02: Creating a Cluster with EKS Using Terraform'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.02：使用Terraform创建EKS集群
- en: For this exercise, we will use the `main.tf` file that we have already provided
    to create a production-ready, highly available Kubernetes cluster.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我们将使用我们已经提供的`main.tf`文件来创建一个生产就绪、高可用的Kubernetes集群。
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This Terraform file is adapted from the examples available at [https://github.com/terraform-aws-modules/terraform-aws-eks/tree/master/examples](https://github.com/terraform-aws-modules/terraform-aws-eks/tree/master/examples).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Terraform文件是从[https://github.com/terraform-aws-modules/terraform-aws-eks/tree/master/examples](https://github.com/terraform-aws-modules/terraform-aws-eks/tree/master/examples)提供的示例进行了调整。
- en: 'This will enable Terraform to create the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使Terraform能够创建以下内容：
- en: A VPC with IP address space `10.0.0.0/16`. It will have three public subnets
    with `/24`s (`255`) worth of IP addresses each.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有IP地址空间`10.0.0.0/16`的VPC。它将有三个公共子网，每个子网都有`/24`（`255`）个IP地址。
- en: Route tables and an internet gateway for the VPC to work properly.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由表和VPC的互联网网关需要正常工作。
- en: Security groups for the control plane to communicate with the nodes, as well
    as to receive traffic from the outside world on the allowed and required ports.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制平面与节点通信的安全组，以及在允许和必需的端口上接收来自外部世界的流量。
- en: IAM roles for both the EKS control plane (to perform tasks such as creating
    **ELB** (**Elastic Load Balancer**) for services on your behalf) and the nodes
    (to handle EC2 API-related concerns).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EKS控制平面的IAM角色（执行诸如代表您创建服务的**ELB**（弹性负载均衡器）等任务）和节点（处理与EC2 API相关的问题）。
- en: The EKS control plane and a setup of all the necessary connections to your VPC
    and nodes.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EKS控制平面以及与您的VPC和节点的所有必要连接的设置。
- en: An **ASG** (**Autoscaling Group**) for nodes to join the cluster (it will provision
    two **m4.large** instances).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于节点加入集群的**ASG**（自动扩展组）（它将提供两个**m4.large**实例）。
- en: Generate both a kubeconfig file and a ConfigMap, which are necessary for the
    nodes to join the cluster and for you to communicate with the cluster.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成一个kubeconfig文件和一个ConfigMap，这对于节点加入集群以及与集群通信是必要的。
- en: 'This is a relatively secure and stable way for you to create a Kubernetes cluster
    that is capable of reliably handling production workloads. Let''s begin with the
    exercise:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对安全和稳定的方式，可以创建一个能够可靠处理生产工作负载的Kubernetes集群。让我们开始练习：
- en: 'Use the following command to fetch the `main.tf` file that we have provided:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令获取我们提供的`main.tf`文件：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will replace the existing `main.tf` file, if you still have it from the
    previous exercise. Note that you should not have any other Terraform files in
    the directory.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这将替换现有的`main.tf`文件，如果您仍然拥有来自上一个练习的文件。请注意，您的目录中不应该有任何其他Terraform文件。
- en: 'Now, we need Terraform to apply the state defined in the `main.tf` file to
    your cloud infrastructure. To do that, use the following command:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要Terraform将在`main.tf`文件中定义的状态应用到您的云基础设施上。为此，请使用以下命令：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You should not use the AWS IAM user we generated for kops in the previous chapter
    to execute these commands, but rather a user with Administrative access to your
    AWS account so there is no chance of accidental permissions issues.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不应该使用我们在上一章生成的用于kops的AWS IAM用户来执行这些命令，而是应该使用具有AWS账户管理员访问权限的用户，以确保没有意外的权限问题。
- en: 'This may take around 10 minutes to complete. You should see a very long output
    similar to the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要大约10分钟才能完成。您应该会看到一个非常长的输出，类似于以下内容：
- en: '![Figure 12.6: Creating resources for our EKS cluster'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6：为我们的EKS集群创建资源'
- en: '](image/B14870_12_06.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_06.jpg)'
- en: 'Figure 12.6: Creating resources for our EKS cluster'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：为我们的EKS集群创建资源
- en: 'Once this is done, there will be two terminal outputs—a ConfigMap for nodes
    and a kubeconfig file for accessing the cluster, as demonstrated in the following
    screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，将会有两个终端输出——一个用于节点的ConfigMap，一个用于访问集群的kubeconfig文件，如下截图所示：
- en: '![Figure 12.7: Getting the information required to access our cluster'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7：获取访问我们的集群所需的信息'
- en: '](image/B14870_12_07.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_07.jpg)'
- en: 'Figure 12.7: Getting the information required to access our cluster'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：获取访问我们的集群所需的信息
- en: Copy the ConfigMap to a file and name it `configmap.yaml`, and then copy the
    kubeconfig file and write it to the `~/.kube/config` file on your computer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将ConfigMap复制到一个文件中，并将其命名为`configmap.yaml`，然后将kubeconfig文件复制并写入计算机上的`~/.kube/config`文件。
- en: 'Now, we need to apply the changes to allow our worker nodes to communicate
    with the control plane. This is a YAML-formatted file for joining the worker nodes
    to your EKS cluster; we already saved this as `configmap.yaml`. Run the following
    command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要应用更改，以允许我们的工作节点与控制平面通信。这是一个用于将工作节点加入到您的EKS集群的YAML格式文件；我们已经将其保存为`configmap.yaml`。运行以下命令：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To run this command, you need the `aws-iam-authenticator` binary installed
    on your computer. To do that, follow the instructions here: [https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html](https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此命令，您需要在计算机上安装`aws-iam-authenticator`二进制文件。要执行此操作，请按照此处的说明操作：[https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html](https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html)。
- en: 'This applies the ConfigMap that allows the Kubernetes cluster to communicate
    with the nodes. You should see the following response:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将应用允许Kubernetes集群与节点通信的ConfigMap。您应该会看到以下响应：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s verify that everything is running OK. Run the following command
    in the terminal:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们验证一切是否正常运行。在终端中运行以下命令：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should see the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下输出：
- en: '![Figure 12.8: Checking whether our nodes are accessible'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8：检查我们的节点是否可访问'
- en: '](image/B14870_12_08.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_08.jpg)'
- en: 'Figure 12.8: Checking whether our nodes are accessible'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：检查我们的节点是否可访问
- en: At this stage, we have a running Kubernetes cluster using EKS as the control
    plane and two worker nodes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们使用EKS作为控制平面，有两个工作节点的运行中的Kubernetes集群。
- en: Note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that your cluster resources will stay online until you delete them.
    If you plan to come back to the following exercises later, you may want to delete
    your cluster to minimize your bill. To do that, run `terraform destroy`. To get
    your cluster back online, run this exercise again.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您的集群资源将保持在线，直到您删除它们。如果您计划稍后回到以下练习，您可能希望删除您的集群以减少账单。要执行此操作，请运行`terraform
    destroy`。要重新上线您的集群，请再次运行此练习。
- en: Now that we have our cluster set up, in the next section, let's take a look
    at an efficient and flexible way to bring traffic to any application to be run
    on our cluster.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了集群，在接下来的部分，让我们来看一下一个高效灵活的方法，将流量引导到集群上运行的任何应用程序。
- en: Kubernetes Ingress
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes Ingress
- en: In the early days of the Kubernetes project, the Service object was used to
    get traffic from outside the cluster to the running Pods. You had only two options
    to get that traffic from outside in—using either a NodePort service or a LoadBalancer
    service. The latter option was preferred in public cloud provider environments
    because the cluster would automatically manage setting up security groups/firewall
    rules and to point the LoadBalancer to the correct ports on your worker nodes.
    However, there is one slight problem with that approach, especially for those
    who are just getting started with Kubernetes or those who have tight cloud budgets.
    The problem is that one LoadBalancer can only point toward a single Kubernetes
    service object.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes项目的早期阶段，Service对象用于将外部流量传输到运行的Pod。您只有两种选择来从外部获取流量 - 使用NodePort服务或LoadBalancer服务。在公共云提供商环境中，后者是首选，因为集群会自动管理设置安全组/防火墙规则，并将LoadBalancer指向工作节点上的正确端口。但是，这种方法有一个小问题，特别是对于刚开始使用Kubernetes或预算紧张的人。问题是一个LoadBalancer只能指向单个Kubernetes服务对象。
- en: Now, imagine that you have 100 microservices running in Kubernetes, all of which
    need to be exposed publicly. In AWS, the average cost of an ELB (a load balancer
    provided by AWS) is roughly $20 per month. So, in this scenario, you're paying
    $2,000 per month just to have the option of getting traffic into your cluster,
    and we still have not factored in the additional costs for networking.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下您在Kubernetes中运行了100个微服务，所有这些微服务都需要公开。在AWS中，ELB（由AWS提供的负载均衡器）的平均成本大约为每月20美元。因此，在这种情况下，您每月支付2000美元，只是为了有获取流量进入您的集群的选项，并且我们还没有考虑网络的额外成本。
- en: Let's also understand another limitation of the one-to-one relationship between
    Kubernetes Service objects and AWS load balancers. Let's say that for your project,
    you need to have a path-based mapping to internal Kubernetes services from the
    same load-balancing endpoint. Let's suppose that you have a web service running
    at `api.example.io` and you want `api.example.io/users` to go to one microservice
    and `api.examples.io/weather` to go to another completely separate microservice.
    Before the arrival of Ingress, you would need to set up your own Kubernetes Service
    and do the internal path resolution to your app.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再了解一下Kubernetes服务对象和AWS负载均衡器之间的一对一关系的另一个限制。假设对于您的项目，您需要将内部Kubernetes服务的基于路径的映射到同一负载平衡端点。假设您在`api.example.io`上运行一个Web服务，并且希望`api.example.io/users`转到一个微服务，`api.examples.io/weather`转到另一个完全独立的微服务。在Ingress到来之前，您需要设置自己的Kubernetes服务并对应用进行内部路径解析。
- en: 'This is now no longer a problem due to the advent of the Kubernetes Ingress
    resource. The Kubernetes Ingress resource is meant to operate in conjunction with
    an Ingress controller (which is an application running in your cluster watching
    the Kubernetes API server for changes to the Ingress resource). Together, these
    two components allow you to define multiple Kubernetes services, which do not
    have to be exposed externally themselves to be routed through a single load-balancing
    endpoint. Let''s examine the following diagram to understand this a bit better:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在不再是一个问题，因为Kubernetes Ingress资源的出现。Kubernetes Ingress资源旨在与Ingress控制器一起运行（这是一个在您的集群中运行的应用程序，监视Kubernetes
    API服务器对Ingress资源的更改）。这两个组件一起允许您定义多个Kubernetes服务，它们本身不必被外部公开，也可以通过单个负载均衡端点进行路由。让我们看一下以下图表，以更好地理解这一点：
- en: '![Figure 12.9: Using Ingress to route traffic to our services'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.9：使用Ingress将流量路由到我们的服务'
- en: '](image/B14870_12_09.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_09.jpg)'
- en: 'Figure 12.9: Using Ingress to route traffic to our services'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：使用Ingress将流量路由到我们的服务
- en: In this example, all requests are being routed to `api.example.io` from the
    internet. One request is going to `api.example.io/a`, another is going to `api.example.io/b`,
    and the last to `api.example.io/c`. The requests are going to a single load balancer
    and a Kubernetes Service, which is controlled through a Kubernetes Ingress resource.
    This Ingress resource forwards the traffic from the single Ingress endpoint to
    the services it was configured to forward traffic to. In the following sections,
    we will set up the `ingress-nginx` Ingress controller, which is a commonly used
    open-source tool used in the Kubernetes community for ingress. Then, we will configure
    the Ingress to allow traffic into our cluster to access our highly available application.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有请求都是从互联网路由到`api.example.io`。一个请求将转到`api.example.io/a`，另一个将转到`api.example.io/b`，最后一个将转到`api.example.io/c`。这些请求都将发送到一个负载均衡器和一个Kubernetes服务，通过Kubernetes
    Ingress资源进行控制。这个Ingress资源将流量从单个Ingress端点转发到它配置为转发流量的服务。在接下来的章节中，我们将设置`ingress-nginx`
    Ingress控制器，这是Kubernetes社区中常用的开源工具用于Ingress。然后，我们将配置Ingress以允许流量进入我们的集群，以访问我们的高可用应用程序。
- en: Highly Available Applications Running on Top of Kubernetes
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes上运行的高可用应用程序
- en: Now that you've had a chance to spin up an EKS cluster and learn about Ingress,
    let's introduce you to our application. We have provided an example application
    that has a flaw that prevents it from being cloud-native and really being able
    to be horizontally scaled in Kubernetes. We will deploy this application in the
    following exercise and observe its behavior. Then, in the next section, we will
    deploy a modified version of this application and observe how it is more suited
    to achieve our stated objective of being highly available.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有机会启动一个EKS集群并了解Ingress，让我们向您介绍我们的应用程序。我们提供了一个示例应用程序，它有一个缺陷，阻止它成为云原生，并真正能够在Kubernetes中进行水平扩展。我们将在接下来的练习中部署这个应用程序并观察其行为。然后，在下一节中，我们将部署这个应用程序的修改版本，并观察它如何更适合实现我们所述的高可用目标。
- en: 'Exercise 12.03: Deploying a Multi-Replica Non-HA Application in Kubernetes'
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.03：在Kubernetes中部署多副本非高可用应用程序
- en: 'In this exercise, we will deploy a version of the application that''s not horizontally
    scalable. We will try to scale it and observe the problem that prevents it from
    being scaled horizontally:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将部署一个不具备水平扩展能力的应用程序版本。我们将尝试对其进行扩展，并观察阻止其水平扩展的问题：
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We have provided the source code for this application in the GitHub repository
    for reference. However, since our focus is on Kubernetes, we will use commands
    to fetch it directly from the repository in this exercise.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在GitHub存储库中提供了此应用程序的源代码以供参考。但是，由于我们的重点是Kubernetes，我们将在此练习中使用命令直接从存储库中获取它。
- en: 'Use the following command to get the manifest for all of the objects required
    to run the application:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令获取运行应用程序所需的所有对象的清单：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This should download the manifest to your current directory:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会将清单下载到您当前的目录中：
- en: '![Figure 12.10: Downloading the application manifest'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.10：下载应用程序清单'
- en: '](image/B14870_12_10.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_10.jpg)'
- en: 'Figure 12.10: Downloading the application manifest'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：下载应用程序清单
- en: If you take a look at the manifest, it has a Deployment running a single replica
    of a Pod and a Service of the ClusterIP type to route traffic to it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看清单，您会发现它包含一个运行单个Pod副本的部署和一个ClusterIP类型的服务，用于将流量路由到它。
- en: 'Then, create a Kubernetes Deployment and Service object so that we can run
    our application:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个Kubernetes部署和服务对象，以便我们可以运行我们的应用程序：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should see the following response:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '![Figure 12.11: Creating the resources for our application'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.11：创建我们的应用程序资源'
- en: '](image/B14870_12_11.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_11.jpg)'
- en: 'Figure 12.11: Creating the resources for our application'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：为我们的应用程序创建资源
- en: 'Now, we need to add a Kubernetes Ingress resource to be able to access this
    website. To get started with Kubernetes Ingress, we need to run the following
    commands:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一个Kubernetes Ingress资源，以便能够访问这个网站。要开始使用Kubernetes Ingress，我们需要运行以下命令：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These three commands will deploy the Nginx Ingress controller implementation
    for EKS. You should see the following response:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个命令将为EKS部署Nginx Ingress控制器实现。您应该看到以下响应：
- en: '![Figure 12.12: Implementing the Ingress controllers'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.12：实现Ingress控制器'
- en: '](image/B14870_12_12.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_12.jpg)'
- en: 'Figure 12.12: Implementing the Ingress controllers'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：实现Ingress控制器
- en: Note
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This command is to be run for the AWS cloud provider only. If you are running
    your cluster on another platform, you will need to find the appropriate link from
    [https://kubernetes.github.io/ingress-nginx/deploy/#aws](https://kubernetes.github.io/ingress-nginx/deploy/#aws).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令仅适用于AWS云提供商。如果您在另一个平台上运行集群，您需要从[https://kubernetes.github.io/ingress-nginx/deploy/#aws](https://kubernetes.github.io/ingress-nginx/deploy/#aws)找到适当的链接。
- en: 'Then, we need to create an Ingress for ourselves. In the same folder we are
    in, let''s create a file named `ingress.yaml` with the following content:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要为自己创建一个Ingress。在我们所在的同一文件夹中，让我们创建一个名为`ingress.yaml`的文件，内容如下：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, run the Ingress using the following command:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令运行Ingress：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should see the following response:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we will configure the Ingress controller such that when a request arrives
    at the load balancer that has a `Host:` header of `counter.com`, it should be
    forwarded to the `kubernetes-test-ha-application-without-redis` service on port
    `80`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将配置Ingress控制器，使得当请求到达具有`Host:`头部为`counter.com`的负载均衡器时，它应该转发到端口`80`上的`kubernetes-test-ha-application-without-redis`服务。
- en: 'First, let''s find the URL that we need to access:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们找到我们需要访问的URL：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see an output similar to the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '![Figure 12.13: Checking the URL to access the Ingress load balancer endpoint'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.13：检查访问Ingress负载均衡器端点的URL'
- en: '](image/B14870_12_13.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_13.jpg)'
- en: 'Figure 12.13: Checking the URL to access the Ingress load balancer endpoint'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：检查访问Ingress负载均衡器端点的URL
- en: 'From the preceding screenshot, note that the Ingress load balancer endpoint
    that Kubernetes created for us in AWS is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，注意Kubernetes在AWS为我们创建的Ingress负载均衡器端点如下：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Your value will likely be different from the preceding one and you should use
    the one that you get for your setup.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您的值可能与前面的值不同，您应该使用您设置的值。
- en: 'Now, let''s access the endpoint using `curl`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用`curl`访问端点：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should get a response similar to the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到类似以下的响应：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you run it multiple times, you''ll see that the number increases by 1 each
    time:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您多次运行它，您会看到每次数字增加1：
- en: '![Figure 12.14: Repeatedly accessing our application'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.14：重复访问我们的应用程序'
- en: '](image/B14870_12_14.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_14.jpg)'
- en: 'Figure 12.14: Repeatedly accessing our application'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：重复访问我们的应用程序
- en: 'Now, let''s discover the problem with the application. In order to make the
    application highly available, we need to have multiple replicas of it running
    simultaneously so that we can allow at least one replica to be unavailable. This,
    in turn, enables the app to tolerate failure. To scale the app, we''re going to
    run the following command:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们发现应用程序的问题。为了使应用程序具有高可用性，我们需要同时运行多个副本，以便至少允许一个副本不可用。这反过来使应用程序能够容忍故障。为了扩展应用程序，我们将运行以下命令：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should see the following response:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 12.15: Scaling the application Deployment'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.15：扩展应用部署'
- en: '](image/B14870_12_15.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_15.jpg)'
- en: 'Figure 12.15: Scaling the application Deployment'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15：扩展应用部署
- en: 'Now, try accessing the application again multiple times, as we did in *step
    7*:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试多次访问应用，就像我们在*步骤7*中所做的那样：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should see a response similar to the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的响应：
- en: '![Figure 12.16: Repeatedly accessing the scaled application to observe the
    behavior'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.16：重复访问扩展应用以观察行为'
- en: '](image/B14870_12_16.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_16.jpg)'
- en: 'Figure 12.16: Repeatedly accessing the scaled application to observe the behavior'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16：重复访问扩展应用以观察行为
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This output may not be exactly the same for you, but if you see the number increasing
    with the first few attempts, keep accessing the application again. You will be
    able to observe the problem behavior after a few attempts.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出可能对您来说并不完全相同，但如果您看到前几次尝试时数字在增加，请继续访问应用。您将能够在几次尝试后观察到问题行为。
- en: This output highlights the problem with our application—the number isn't always
    increasing. Why is that? That is because the load balancer may pass the request
    to any one of the replicas, and the replica that receives the request returns
    a response based on its local state.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出突出了我们应用的问题——数量并不总是增加。为什么呢？因为负载均衡器可能会将请求传递给任何一个副本，接收请求的副本会根据其本地状态返回响应。
- en: Working with Stateful Applications
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理有状态的应用
- en: The previous exercise demonstrates the challenge of working with stateful applications
    in a distributed context. As a brief overview, a stateless app is an application
    program that does not save client data generated in one session for use in the
    next session with that client. This means that in general, a stateless application
    depends entirely on the input to derive its output. Imagine a server displaying
    a static web page that does not need to change for any reason. In the real world,
    stateless applications typically need to be combined with stateful applications
    in order to create a useful experience for clients or consumers of the application.
    There are, of course, exceptions to this.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的练习展示了在分布式环境中处理有状态应用的挑战。简而言之，无状态应用是一种不保存客户端在一个会话中生成的数据以便在下一个会话中使用的应用程序。这意味着一般来说，无状态应用完全依赖于输入来推导其输出。想象一个服务器显示一个静态网页，不需要因任何原因而改变。在现实世界中，无状态应用通常需要与有状态应用结合，以便为客户或应用的消费者创建有用的体验。当然，也有例外。
- en: A stateful application is one whose output depends on multiple factors, such
    as user input, input from other applications, and past saved events. These factors
    are called the "state" of the application, which determines its behavior. One
    of the most important parts of creating distributed applications with multiple
    replicas is that any state that is used to generate output needs to be shared
    among all the replicas. If the different replicas of your application are working
    with different states, then your application is going to exhibit random behavior
    based on which replica your request is routed to. This effectively defeats the
    purpose of horizontally scaling an application using replicas.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态的应用是一种其输出取决于多个因素的应用，比如用户输入、来自其他应用的输入以及过去保存的事件。这些因素被称为应用的“状态”，它决定了应用的行为。创建具有多个副本的分布式应用最重要的部分之一是，用于生成输出的任何状态都需要在所有副本之间共享。如果您的应用的不同副本使用不同的状态，那么您的应用将会展现基于请求路由到哪个副本的随机行为。这实际上违背了使用副本水平扩展应用的目的。
- en: In the use case from the previous exercise, for each replica to respond with
    the correct number, we need to move the storage of that number outside each replica.
    To do this, we need to modify the application. Let's think for a second about
    how this can be done. Could we communicate the numbers between the replicas using
    another request? Could we assign each replica to only respond with multiples of
    the number it is assigned? (If we had three replicas, one would only respond with
    `1`, `4`, `7`…, while another would respond with `2`, `5`, `8`…, and the last
    one would respond with `3`, `6`, `9`….) Or, might we share the number in an external
    state store, such as a database? Regardless of what we choose, the path forward
    will involve updating our running application in Kubernetes. So, we will need
    to talk briefly about a strategy to do this.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的练习中，对于每个副本都能以正确的数字进行响应，我们需要将该数字的存储移到每个副本之外。为了做到这一点，我们需要修改应用程序。让我们想一想如何做到这一点。我们能否使用另一个请求在副本之间传递数字？我们能否指定每个副本只能以其分配的数字的倍数进行响应？（如果我们有三个副本，一个只会以`1`、`4`、`7`…进行响应，另一个会以`2`、`5`、`8`…进行响应，最后一个会以`3`、`6`、`9`…进行响应。）或者，我们可以将数字存储在外部状态存储中，比如数据库？无论我们选择什么，前进的道路都将涉及在Kubernetes中更新我们正在运行的应用程序。因此，我们需要简要讨论一下如何做到这一点。
- en: The CI/CD Pipeline
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI/CD流水线
- en: With the help of containerization technology and a container image tag revision
    policy, we can push an incremental update to our application in a fairly easy
    manner. Just as with source code and infrastructure as code, we can keep the scripts
    and Kubernetes manifests that execute steps of our build and deploy a pipeline
    versioned in a tool such as **git**. This allows us to have tremendous visibility
    into, and flexibility to control, how software updates happen in our cluster using
    approaches such as CI and CD.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 借助容器化技术和容器镜像标签修订策略的帮助，我们可以相对轻松地对我们的应用程序进行增量更新。就像源代码和基础设施代码一样，我们可以将执行构建和部署流水线步骤的脚本和Kubernetes清单版本化，存储在诸如**git**之类的工具中。这使我们能够对我们的集群中的软件更新发生的方式有极大的可见性和灵活性，使用CI和CD等方法来控制。
- en: 'For the uninitiated, **CI/CD** stands for **Continuous Integration and Continuous
    Deployment/Delivery**. The CI aspect uses tooling, such as Jenkins or Concourse
    CI, to integrate new changes to our source code in a repeatable process for testing
    and assembling our code into a final artifact for deployment. The goal of CI is
    manifold, but here are a few benefits:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉的人来说，**CI/CD**代表**持续集成和持续部署/交付**。CI方面使用工具，如Jenkins或Concourse CI，将新的更改集成到我们的源代码中，进行可重复的测试和组装我们的代码成最终的构件以进行部署。CI的目标是多方面的，但以下是一些好处：
- en: Defects in the software are found earlier in the process (if testing is adequate).
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果测试充分，软件中的缺陷会在流程的早期被发现。
- en: Repeatable steps create reproducible results when we are deploying to an environment.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重复的步骤在部署到环境时会产生可重复的结果。
- en: Visibility exists to communicate the status of a feature with stakeholders.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可见性存在是为了与利益相关者沟通功能的状态。
- en: It encourages frequent software updates to give developers confidence that their
    new code is not breaking existing functionality.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它鼓励频繁的软件更新，以使开发人员确信他们的新代码不会破坏现有的功能。
- en: The other part, CD, is the incorporation of automated mechanisms to constantly
    deliver small updates to end-users, such as updating Deployment objects in Kubernetes
    and tracking rollout statuses. The CI/CD pipeline is the prevalent DevOps model
    today.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: CD的另一部分是将自动化机制整合到不断向最终用户交付小型更新的过程中，例如在Kubernetes中更新部署对象并跟踪部署状态。CI/CD流水线是当前主流的DevOps模型。
- en: Ideally, a CI/CD pipeline should be able to reliably and predictably take code
    from a developer's machine and bring it all the way to a production environment
    with as few manual interventions as possible. A CI pipeline should ideally have
    components for compilation (where necessary), testing, and final application assembly
    (in the case of a Kubernetes cluster, this is a container).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，CI/CD流水线应该能够可靠地、可预测地将代码从开发人员的机器带到生产环境，尽量减少手动干预。CI流水线理想上应该包括编译（必要时）、测试和最终应用程序组装的组件（在Kubernetes集群的情况下，这是一个容器）。
- en: A CD pipeline should have some way of automating its interactions with an infrastructure
    to take the application revision and deploy it, along with any dependent configurations
    and one-off deployment tasks, in such a way that the desired version of the software
    becomes the running version of the software via some kind of strategy (such as
    using a Deployment object in Kubernetes). It should also include telemetry tooling
    to observe the immediate impact of the Deployment on the surrounding environment.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: CD流水线应该有一种自动化与基础设施交互的方式，以获取应用程序修订版并部署它，以及任何依赖配置和一次性部署任务，使得所需版本的软件成为软件的运行版本，通过某种策略（比如在Kubernetes中使用Deployment对象）。它还应该包括遥测工具，以观察部署对周围环境的即时影响。
- en: The problem that we observed in the previous section with our application is
    that each replica is working off of its local state to return a number via HTTP.
    To solve this problem, we propose that we should use an external state store (database)
    to manage the information (the number) shared between each replica of our application.
    We have several options of state stores to choose from. We chose Redis simply
    because it's easy to get started with and it's simple to understand. Redis is
    a high-performance key-value database, much like etcd. In our example refactor,
    we will be sharing the state between the replicas by setting a key with the `num`
    name and the value is the increasing integer value that we want to return. During
    each request, this value will be incremented and stored back into the database
    so that each replica can work off the most up-to-date information.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节观察到的问题是，我们的应用程序中的每个副本都是根据其本地状态返回一个数字通过HTTP。为了解决这个问题，我们建议使用外部状态存储（数据库）来管理应用程序的每个副本之间共享的信息（数字）。我们有几种状态存储的选择。我们选择Redis，只是因为它很容易上手，而且很容易理解。Redis是一个高性能的键值数据库，很像etcd。在我们的示例重构中，我们将通过设置一个名为`num`的键来在副本之间共享状态，值是我们想要返回的递增整数值。在每个请求期间，这个值将被递增并存储回数据库，以便每个副本都可以使用最新的信息。
- en: Every company and individual has a different process that they use to manage
    new versions of code being deployed. Therefore, we are going to use simple commands
    to perform our steps, which can be automated via Bash with the tool of your choice.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 每家公司和个人都有自己管理部署新代码版本的不同流程。因此，我们将使用简单的命令来执行我们的步骤，可以通过Bash和您选择的工具自动化。
- en: 'Exercise 12.04: Deploying an Application with State Management'
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.04：使用状态管理部署应用程序
- en: In this exercise, we will deploy a modified version of the application that
    we deployed in the previous exercise. As a reminder, this application counts how
    many times it has been accessed and returns that value in JSON format to the requestor.
    However, at the end of the previous exercise, we observed in *Figure 12.16* that
    when we scale this application horizontally with multiple replicas, we get numbers
    that are not always increasing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将部署一个修改过的应用程序版本，这是我们在上一个练习中部署的应用程序的修改版本。作为提醒，这个应用程序会计算它被访问的次数，并以JSON格式返回给请求者。然而，在上一个练习的结尾，我们观察到在*图12.16*中，当我们使用多个副本水平扩展这个应用程序时，我们得到的数字并不总是增加的。
- en: Note
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We have provided the source code for this application in the GitHub repository
    for your reference. However, since our focus is on Kubernetes, we will use commands
    to directly fetch it from the repository in this exercise.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在GitHub存储库中提供了这个应用程序的源代码供您参考。然而，由于我们的重点是Kubernetes，我们将在这个练习中使用命令直接从存储库中获取它。
- en: 'In this modified version of the application, we have refactored our code to
    add the capability of storing this increasing count in a Redis database. This
    allows us to have multiple replicas of our application, but always have the count
    increase each time we make a request to the endpoint:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修改后的应用程序版本中，我们重构了我们的代码，以添加将这个增长计数存储在Redis数据库中的功能。这允许我们拥有多个应用程序副本，但每次向端点发出请求时，计数都会增加：
- en: Note
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In our implementation of Redis, we are not using a transaction to set the count
    after getting it. So, there is a very small chance that we are getting and acting
    on old information when we update the value set in the database, which may lead
    to unexpected results.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Redis实现中，我们没有使用事务来设置获取后的计数。因此，当我们更新数据库中的值时，有很小的机会获取并处理旧信息，这可能导致意外的结果。
- en: 'Use the following command to get the manifest of all the objects required for
    this application:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令获取此应用程序所需的所有对象的清单：
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should see a response similar to the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的响应：
- en: '![Figure 12.17: Downloading the manifest for the modified application'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.17：下载修改后应用程序的清单'
- en: '](image/B14870_12_17.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_17.jpg)'
- en: 'Figure 12.17: Downloading the manifest for the modified application'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17：下载修改后应用程序的清单
- en: 'If you open this manifest, you will see that we have a Deployment for our app
    running three replicas: a ClusterIP Service to expose it, a Deployment for Redis
    running one replica, and another ClusterIP Service to expose Redis. We are also
    modifying the Ingress object created earlier to point to the new Service.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开这个清单，您会看到我们为我们的应用程序运行了三个副本的部署：一个ClusterIP服务来暴露它，一个运行一个副本的Redis部署，以及另一个ClusterIP服务来暴露Redis。我们还修改了之前创建的Ingress对象，指向新的服务。
- en: 'Now, it is time to deploy it on Kubernetes. We can run the following command:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候在Kubernetes上部署它了。我们可以运行以下命令：
- en: '[PRE24]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You should see a response similar to the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的响应：
- en: '![Figure 12.18: Creating the resources required for our cluster'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.18：创建集群所需的资源'
- en: '](image/B14870_12_18.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_18.jpg)'
- en: 'Figure 12.18: Creating the resources required for our cluster'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18：创建集群所需的资源
- en: 'Now, let''s see what this application gives us by using the following command:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个应用程序通过以下命令给我们带来了什么：
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run this command repeatedly. You should be able to see an increasing number,
    as shown:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 重复运行此命令。您应该能够看到一个递增的数字，如下所示：
- en: '![Figure 12.19: Predictable output with consistently increasing numbers'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.19：具有一致增长数字的可预测输出'
- en: '](image/B14870_12_19.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_19.jpg)'
- en: 'Figure 12.19: Predictable output with consistently increasing numbers'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19：具有一致增长数字的可预测输出
- en: As you can see in the preceding output, the program now outputs numbers in sequence
    because all of the replicas of our Deployment now share a single datastore responsible
    for managing the application state (Redis).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的输出中所看到的，程序现在按顺序输出数字，因为我们的Deployment的所有副本现在共享一个负责管理应用程序状态（Redis）的单个数据存储。
- en: 'There are a lot of other paradigms that need to be shifted if you want to create
    a truly highly available, fault-tolerant software system, and it is beyond the
    scope of this book to explore them in detail. However, for more information, you
    can check out Packt''s book on distributed systems at this link: [https://www.packtpub.com/virtualization-and-cloud/hands-microservices-kubernetes.](https://www.packtpub.com/virtualization-and-cloud/hands-microservices-kubernetes
    )'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建一个真正高可用、容错的软件系统，还有许多其他范式需要转变，这超出了本书详细探讨的范围。但是，您可以在此链接查看有关分布式系统的更多信息：[https://www.packtpub.com/virtualization-and-cloud/hands-microservices-kubernetes](https://www.packtpub.com/virtualization-and-cloud/hands-microservices-kubernetes)
- en: Note
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Again, remember that your cluster resources are still running at this point.
    Don't forget to tear down your cluster using `terraform destroy` if you expect
    to continue with the activity later.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 再次记住，此时您的集群资源仍在运行。如果您希望稍后继续进行活动，请不要忘记使用`terraform destroy`拆除您的集群。
- en: Now that we have built our application with the ability to persist and share
    its state among different replicas, we will expand it further in the following
    activity.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经构建了具有持久性和在不同副本之间共享其状态能力的应用程序，我们将在接下来的活动中进一步扩展它。
- en: 'Activity 12.01: Expanding the State Management of Our Application'
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动12.01：扩展我们应用程序的状态管理
- en: Right now, our application can leverage a shared Redis database running inside
    our Kubernetes cluster to manage the variable counter that we return to the user
    when it is fetched.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序可以利用运行在Kubernetes集群内部的共享Redis数据库来管理我们在获取时返回给用户的变量计数器。
- en: But let's suppose for a moment that we don't trust Kubernetes to reliably manage
    the Redis container (since it's a volatile in-memory datastore) and instead we
    want to use AWS ElastiCache to do so. Your goal in this activity is to use the
    tools we have learned in this chapter to modify our application to work with AWS
    ElastiCache.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，假设我们暂时不信任Kubernetes能够可靠地管理Redis容器（因为它是一个易失性的内存数据存储），而是希望使用AWS ElastiCache来管理。您在此活动中的目标是使用本章学习的工具修改我们的应用程序，使其与AWS
    ElastiCache配合使用。
- en: 'You can use the following guidelines to complete this activity:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下指南完成此活动：
- en: Use Terraform to provision ElastiCache.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Terraform来配置ElastiCache。
- en: 'You can find the required parameter values for provisioning ElastiCache at
    this link: [https://www.terraform.io/docs/providers/aws/r/elasticache_cluster.html#redis-instance](https://www.terraform.io/docs/providers/aws/r/elasticache_cluster.html#redis-instance).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此链接找到为配置ElastiCache所需的参数值：[https://www.terraform.io/docs/providers/aws/r/elasticache_cluster.html#redis-instance](https://www.terraform.io/docs/providers/aws/r/elasticache_cluster.html#redis-instance)。
- en: Change the application to connect to Redis. You will need to use an environment
    variable in your Kubernetes Deployment for that. You can find the required information
    in the `redis_address` field when you run the `terraform apply` command.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序更改为连接到Redis。您需要在Kubernetes Deployment中使用环境变量。当您运行`terraform apply`命令时，您可以在`redis_address`字段中找到所需的信息。
- en: Add the ElastiCache endpoint to the appropriate Kubernetes manifest environment
    variable.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ElastiCache端点添加到适当的Kubernetes清单环境变量中。
- en: Roll out the new version of code onto the Kubernetes cluster using any tool
    you want.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用任何您想要的工具在Kubernetes集群上推出新版本的代码。
- en: 'By the end, you should be able to observe the application responding similarly
    to what we saw in the previous exercise, but this time, it will use ElastiCache
    for its state management:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到最后，您应该能够观察到应用程序的响应类似于我们在上一个练习中看到的，但这一次，它将使用ElastiCache来进行状态管理：
- en: '![Figure 12.20: Expected output of the Activity 12.01'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.20：活动12.01的预期输出'
- en: '](image/B14870_12_20.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_12_20.jpg)'
- en: 'Figure 12.20: Expected output of the Activity 12.01'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20：活动12.01的预期输出
- en: Note
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).
    Remember that your cluster resources will stay online until you delete them. To
    delete the cluster, you need to run `terraform destroy`.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在以下地址找到：[https://packt.live/304PEoD](https://packt.live/304PEoD)。请记住，您的集群资源将保持在线，直到您删除它们。要删除集群，您需要运行`terraform
    destroy`。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In an earlier chapter of this book, we explored how Kubernetes works favorably
    with a declarative approach to application management; that is, you define your
    desired state and let Kubernetes take care of the rest. Throughout this chapter,
    we took a look at some tools that help us manage our cloud infrastructure in a
    similar way. We introduced Terraform as a tool that can help us manage the state
    of our infrastructure and introduced the idea of treating your infrastructure
    as code.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期章节中，我们探讨了Kubernetes如何与声明性应用程序管理方法相配合；也就是说，您定义所需的状态，然后让Kubernetes来处理其余的事情。在本章中，我们看了一些工具，这些工具可以帮助我们以类似的方式管理我们的云基础设施。我们介绍了Terraform作为一种可以帮助我们管理基础设施状态的工具，并介绍了将基础设施视为代码的概念。
- en: We then created a mostly secure, production-ready Kubernetes cluster using Terraform
    in Amazon EKS. We took a look at the Ingress object and learned about the major
    motivations for using it, as well as the various advantages that it provides.
    Then, we deployed two versions of an application on a highly available Kubernetes
    cluster and explored some concepts that allow us to improve at horizontally scaling
    stateful applications. This gave us a glimpse of the challenges that come with
    running stateful applications, and we will explore some more ways of dealing with
    them in *Chapter 14*, *Running Stateful Components in Kubernetes*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用Terraform在Amazon EKS中创建了一个基本安全、生产就绪的Kubernetes集群。我们研究了Ingress对象，并了解了使用它的主要动机，以及它提供的各种优势。然后，我们在一个高可用的Kubernetes集群上部署了两个应用程序版本，并探讨了一些允许我们改进水平扩展有状态应用程序的概念。这让我们一窥了运行有状态应用程序所面临的挑战，并且我们将在*第14章*中探讨更多处理这些挑战的方法，*在Kubernetes中运行有状态组件*。
- en: In the next chapter, we're going to take a look at continuing our production
    readiness by further securing our cluster.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续查看如何通过进一步保护我们的集群来继续准备生产。
