- en: Walking through Kubernetes Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Kubernetes概念
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Linking Pods and containers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接Pod和容器
- en: Managing Pods with ReplicaSets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ReplicaSets管理Pods
- en: Deployment API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署API
- en: Working with Services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理服务
- en: Working with Volumes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用卷
- en: Working with Secrets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理机密
- en: Working with names
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理名称
- en: Working with Namespaces
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名空间
- en: Working with labels and selectors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签和选择器
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will start by creating different kinds of resources on the
    Kubernetes system. In order to realize your application in a microservices structure,
    reading the recipes in this chapter will be a good start towards understanding
    the concepts of the Kubernetes resources and consolidating them. After you deploy
    applications in Kubernetes, you can work on its scalable and efficient container
    management, and also fulfill the DevOps delivering procedure of microservices.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先在Kubernetes系统上创建不同类型的资源。为了在微服务结构中实现您的应用程序，阅读本章中的配方将是理解Kubernetes资源概念并加以巩固的良好开端。在您在Kubernetes中部署应用程序之后，您可以开始进行可伸缩和高效的容器管理，并完成微服务的DevOps交付流程。
- en: An overview of Kubernetes
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes概述
- en: Working with Kubernetes is quite easy, using either a **Command Line Interface**
    (**CLI**) or API (RESTful). This section will describe Kubernetes control by CLI.
    The CLI we use in this chapter is version 1.10.2.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes非常容易，可以使用**命令行界面**（**CLI**）或API（RESTful）。本节将描述通过CLI控制Kubernetes。本章中使用的CLI版本为1.10.2。
- en: 'After you install Kubernetes master, you can run a `kubectl` command as follows.
    It shows the kubectl and Kubernetes master versions (both the API Server and CLI
    are v1.10.2):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Kubernetes主节点后，可以运行以下`kubectl`命令。它显示kubectl和Kubernetes主节点的版本（API服务器和CLI都是v1.10.2）：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`kubectl` connects the Kubernetes API server using the RESTful API. By default,
    it attempts to access the localhost if `.kube/config` is not configured, otherwise
    you need to specify the API server address using the `--server` parameter. Therefore,
    it is recommended to use `kubectl` on the API server machine for practice.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`使用RESTful API连接Kubernetes API服务器。默认情况下，如果未配置`.kube/config`，它会尝试访问localhost，否则您需要使用`--server`参数指定API服务器地址。因此，建议在API服务器机器上使用`kubectl`进行练习。'
- en: If you use kubectl over the network, you need to consider authentication and
    authorization for the API server. See [Chapter 7](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Building Kubernetes on GCP*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过网络使用kubectl，您需要考虑API服务器的身份验证和授权。请参阅[第7章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)，*在GCP上构建Kubernetes*。
- en: '`kubectl` is the only command for Kubernetes clusters, and it controls the
    Kubernetes cluster manager. Find more information at [http://kubernetes.io/docs/user-guide/kubectl-overview/](http://kubernetes.io/docs/user-guide/kubectl-overview/).
    Any container, or Kubernetes cluster operation, can be performed by a `kubectl`
    command.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`是Kubernetes集群的唯一命令，它控制Kubernetes集群管理器。在[http://kubernetes.io/docs/user-guide/kubectl-overview/](http://kubernetes.io/docs/user-guide/kubectl-overview/)找到更多信息。任何容器或Kubernetes集群操作都可以通过`kubectl`命令执行。'
- en: In addition, kubectl allows the inputting of information via either the command
    line's optional arguments or a file (use the `-f` option); it is highly recommended
    to use a file, because you can maintain Kubernetes configuration as code. This
    will be described in detail in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，kubectl允许通过命令行的可选参数或文件（使用`-f`选项）输入信息；强烈建议使用文件，因为您可以将Kubernetes配置保持为代码。本章将对此进行详细描述。
- en: 'Here is a typical `kubectl` command-line argument:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的`kubectl`命令行参数：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The attributes of the preceding command are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的属性如下：
- en: '`command`: Specifies the operation that you want to perform on one or more
    resources.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command`：指定要在一个或多个资源上执行的操作。'
- en: '`TYPE`: Specifies the resource type. Resource types are case-sensitive and
    you can specify the singular, plural, or abbreviated forms.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TYPE`：指定资源类型。资源类型区分大小写，您可以指定单数、复数或缩写形式。'
- en: '`NAME`: Specifies the name of the resource. Names are case-sensitive. If the
    name is omitted, details for all resources are displayed.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NAME`：指定资源的名称。名称区分大小写。如果省略名称，则会显示所有资源的详细信息。'
- en: '`flags`: Specifies optional flags.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`：指定可选标志。'
- en: 'For example, if you want to launch `nginx`, you can use either the `kubectl
    run` command or the `kubectl create -f` command with the YAML file as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想要启动`nginx`，您可以使用`kubectl run`命令或`kubectl create -f`命令与以下YAML文件：
- en: 'Use the `run` command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`run`命令：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Use the `create -f` command with the YAML file:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`create -f`命令与YAML文件：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you want to see the status of the Deployment, type the `kubectl get` command
    as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想要查看部署的状态，请输入以下`kubectl get`命令：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you also want the support abbreviation, type the following:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还想要支持缩写，输入以下内容：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you want to delete these resources, type the `kubectl delete` command as
    follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要删除这些资源，请输入以下`kubectl delete`命令：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `kubectl` command supports many kinds of sub-commands; use the `-h` option
    to see the details, for example:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl`命令支持许多种子命令；使用`-h`选项查看详细信息，例如：'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This section describes how to use the `kubectl` command to control the Kubernetes
    cluster. The following recipes describe how to set up Kubernetes components:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述如何使用`kubectl`命令来控制Kubernetes集群。以下示例描述了如何设置Kubernetes组件：
- en: '*Setting up a Kubernetes cluster on macOS using minikube* and *Set up a Kubernetes
    cluster on Windows** using minikube* in [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml),
    *Building Your Own Kubernetes Cluster*'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在macOS上使用minikube设置Kubernetes集群*和*在Windows上使用minikube设置Kubernetes集群*在[第1章](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml)，*构建您自己的Kubernetes集群*'
- en: '*Setting up a Kubernetes cluster on Linux using kubeadm* in [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml),
    *Building Your Own Kubernetes Cluster*'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Linux上使用kubeadm设置Kubernetes集群*在[第1章](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml)，*构建您自己的Kubernetes集群*'
- en: '*Setting up a Kubernetes cluster on Linux using kubespray (Ansible) *in [Chapter
    1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml), *Building Your Own Kubernetes Cluster*'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Linux上使用kubespray（Ansible）设置Kubernetes集群*在[第1章](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml)，*构建您自己的Kubernetes集群*'
- en: Linking Pods and containers
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接Pod和容器
- en: 'The Pod is a group of one or more containers and the smallest deployable unit
    in Kubernetes. Pods are always co-located and co-scheduled, and run in a shared
    context. Each Pod is isolated by the following Linux namespaces:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Pod是一个或多个容器的组合，是Kubernetes中最小的可部署单元。Pod始终是共同定位和共同调度的，并在共享上下文中运行。每个Pod都由以下Linux命名空间隔离：
- en: The **process ID** (**PID**) namespace
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程ID**（**PID**）命名空间'
- en: The network namespace
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络命名空间
- en: The **interprocess communication** (**IPC**) namespace
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程间通信**（**IPC**）命名空间'
- en: The **unix time sharing** (**UTS**) namespace
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unix时间共享**（**UTS**）命名空间'
- en: In a pre-container world, they would have been executed on the same physical
    or virtual machine.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器之前的世界中，它们将在同一台物理或虚拟机上执行。
- en: It is useful to construct your own application stack Pod (for example, web server
    and database) that are mixed by different Docker images.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自己的应用程序堆栈Pod（例如，Web服务器和数据库）是很有用的，这些Pod由不同的Docker镜像混合而成。
- en: Getting ready
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You must have a Kubernetes cluster and make sure that the Kubernetes node has
    accessibility to the Docker Hub ([https://hub.docker.com](https://hub.docker.com))
    in order to download Docker images.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须拥有一个 Kubernetes 集群，并确保 Kubernetes 节点可以访问 Docker Hub（[https://hub.docker.com](https://hub.docker.com)）以便下载
    Docker 镜像。
- en: If you are running minikube, use `minikube ssh` to log on to the minikube VM
    first, then run the `docker pull` command.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行 minikube，请先使用 `minikube ssh` 登录到 minikube VM，然后运行 `docker pull` 命令。
- en: 'You can simulate downloading a Docker image by using the `docker pull` command
    as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `docker pull` 命令模拟下载 Docker 镜像：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following are the steps to create a Pod has 2 containers:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建一个具有 2 个容器的 Pod 的步骤：
- en: Log on to the Kubernetes machine (no need to log on if using minikube) and prepare
    the following YAML file. It defines the launch `nginx` container and the CentOS
    container.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 Kubernetes 机器（如果使用 minikube，则无需登录），并准备以下 YAML 文件。它定义了启动 `nginx` 容器和 CentOS
    容器。
- en: 'The `nginx` container opens the HTTP port (TCP/`80`). On the other hand, the
    CentOS container attempts to access the `localhost:80` every three seconds using
    the `curl` command:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`nginx` 容器打开 HTTP 端口（TCP/`80`）。另一方面，CentOS 容器尝试每三秒使用 `curl` 命令访问 `localhost:80`：'
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, execute the `kubectl create` command to launch `my-first-pod` as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，执行 `kubectl create` 命令启动 `my-first-pod`，如下所示：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It takes between a few seconds and a few minutes, depending on the network bandwidth
    of the Docker Hub and Kubernetes node's spec.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要几秒到几分钟的时间，具体取决于 Docker Hub 和 Kubernetes 节点规格的网络带宽。
- en: 'You can check `kubectl get pods` to see the status, as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用 `kubectl get pods` 命令查看状态，如下所示：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now both the nginx container (`my-nginx`) and the CentOS container (`my-centos`)
    are ready.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `nginx` 容器（`my-nginx`）和 CentOS 容器（`my-centos`）都已准备就绪。
- en: 'Let''s check whether the CentOS container can access `nginx` or not. You can
    run the `kubectl exec` command to run bash on the CentOS container, then run the `curl`
    command to access the `nginx`, as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查 CentOS 容器是否能够访问 `nginx`。您可以使用 `kubectl exec` 命令在 CentOS 容器上运行 bash，然后运行
    `curl` 命令访问 `nginx`，如下所示：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the Pod links two different containers, `nginx` and `CentOS`,
    into the same Linux network namespace.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Pod 将两个不同的容器 `nginx` 和 `CentOS` 链接到相同的 Linux 网络命名空间中。
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When launching a Pod, the Kubernetes scheduler dispatches to the kubelet process
    to handle all the operations to launch both `nginx` and `CentOS` containers on
    one Kubernetes node.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 Pod 时，Kubernetes 调度程序将分派给 kubelet 进程来处理在一个 Kubernetes 节点上启动 `nginx` 和 `CentOS`
    容器的所有操作。
- en: 'The following diagram illustrates these two containers and the Pod; these two
    containers can communicate via the localhost network, because within the Pod containers,
    it share the network interface:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了这两个容器和 Pod；这两个容器可以通过本地主机网络进行通信，因为在 Pod 容器内部，它们共享网络接口：
- en: '![](assets/17157006-2419-4268-9291-481e14d19121.png)A Pod has two containers,
    which can communicate via localhost'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/17157006-2419-4268-9291-481e14d19121.png)一个 Pod 有两个容器，可以通过本地主机进行通信'
- en: 'If you have two or more nodes, you can check the `-o wide` option to find a
    node which runs a Pod:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有两个或更多节点，可以使用 `-o wide` 选项查找运行 Pod 的节点：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Log in to that node, then you can check the `docker ps | grep my-first-pod` command
    to see the running containers as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到该节点，然后您可以使用 `docker ps | grep my-first-pod` 命令查看正在运行的容器，如下所示：
- en: '![](assets/73ca0964-dd98-4df3-b84b-868116a59e25.png)List of containers that
    belong to my-first-pod'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/73ca0964-dd98-4df3-b84b-868116a59e25.png)属于我的第一个 Pod 的容器列表'
- en: You may notice that `my-first-pod` contains three containers; `centos`, `nginx`,
    and `pause` are running instead of two. Because each Pod we need to keep belongs
    to a particular Linux namespace, if both the CentOS and nginx containers die,
    the namespace will also destroyed. Therefore, the pause container just remains
    in the Pod to maintain Linux namespaces.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到`my-first-pod`包含三个容器；`centos`、`nginx`和`pause`正在运行，而不是两个。因为我们需要保留的每个Pod都属于特定的Linux命名空间，如果CentOS和nginx容器都死掉了，命名空间也会被销毁。因此，暂停容器只是留在Pod中以维护Linux命名空间。
- en: 'Let''s launch a second Pod, rename it as `my-second-pod`, and run the `kubectl`
    create command as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动第二个Pod，将其重命名为`my-second-pod`，并运行以下`kubectl` create命令：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now you have two Pods; each Pod has two containers, `centos` and `nginx`. So
    a total of four containers are running on your Kubernetes cluster as in the following
    diagram:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有两个Pod；每个Pod有两个容器，`centos`和`nginx`。因此，在您的Kubernetes集群上总共有四个容器正在运行，如下图所示：
- en: '![](assets/75affb40-1877-4289-b830-42e63715dad9.png)Duplicate Pod from my-first-pod
    to my-second-podIf you would like to deploy more of the same Pod, consider using
    a Deployment (ReplicaSet) instead.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/75affb40-1877-4289-b830-42e63715dad9.png)从my-first-pod复制Pod到my-second-pod如果您想部署更多相同的Pod，请考虑使用部署（ReplicaSet）。'
- en: 'After your testing, you can run the `kubectl` delete command to delete your
    Pod from the Kubernetes cluster:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试完成后，您可以运行`kubectl` delete命令来从Kubernetes集群中删除您的Pod：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See also
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'This recipe from this chapter described how to control Pods. They are the basic
    components of Kubernetes operation. The following recipes will describe the advanced
    operation of Pods using Deployments, Services, and so on:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的这个配方描述了如何控制Pods。它们是Kubernetes操作的基本组件。接下来的配方将描述如何使用Deployments、Services等来进行Pods的高级操作：
- en: '*Managing Pods with ReplicaSets*'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用ReplicaSets管理Pods*'
- en: '*Deployment API*'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署API*'
- en: '*Working with Services *'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Services工作*'
- en: '*Working with labels and selectors*'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用标签和选择器*'
- en: Managing Pods with ReplicaSets
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ReplicaSets管理Pods
- en: 'A ReplicaSet is a term for API objects in Kubernetes that refer to Pod replicas.
    The idea is to be able to control a set of Pods'' behaviors. The ReplicaSet ensures
    that the Pods, in the amount of a user-specified number, are running all the time.
    If some Pods in the ReplicaSet crash and terminate, the system will recreate Pods
    with the original configurations on healthy nodes automatically, and keep a certain
    number of processes continuously running. While changing the size of set, users
    can scale the application out or down easily. According to this feature, no matter
    whether you need replicas of Pods or not, you can always rely on ReplicaSet for
    auto-recovery and scalability. In this recipe, you''re going to learn how to manage
    your Pods with ReplicaSet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet是Kubernetes中指向Pod副本的API对象的术语。其想法是能够控制一组Pod的行为。ReplicaSet确保用户指定数量的Pods始终运行。如果ReplicaSet中的一些Pod崩溃并终止，系统将自动在健康节点上使用原始配置重新创建Pods，并保持一定数量的进程持续运行。在更改集的大小时，用户可以轻松地扩展或缩小应用程序。根据这个特性，无论您是否需要Pod的副本，您都可以始终依赖ReplicaSet进行自动恢复和可伸缩性。在这个配方中，您将学习如何使用ReplicaSet管理您的Pods：
- en: '![](assets/940902c6-7d59-4f0e-81c8-b2cebfc002be.png)ReplicaSet and their Pods
    on two nodes'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/940902c6-7d59-4f0e-81c8-b2cebfc002be.png)两个节点上的ReplicaSet及其Pods'
- en: 'The ReplicaSet usually handles a tier of applications. As you can see in the
    preceding diagram, we launch a ReplicaSet with three Pod replicas. Some mechanism
    details are listed as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet通常处理一个应用程序层。如前图所示，我们启动了一个具有三个Pod副本的ReplicaSet。一些机制细节列在下面：
- en: The **kube-controller-manager** daemon helps to maintain the resource running
    in its desired state. For example, the desired state of ReplicaSet in the diagram
    is three Pod replicas.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kube-controller-manager守护程序有助于保持资源以期望的状态运行。例如，图表中ReplicaSet的期望状态是三个Pod副本。
- en: The **kube-scheduler** daemon on master, the scheduler of Kubernetes, takes
    charge of assigning tasks to healthy nodes.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes主节点上的kube-scheduler守护程序负责将任务分配给健康的节点。
- en: The selector of the ReplicaSet is used for deciding which Pods it covers. If
    the key-value pairs in the Pod's label include all items in the selector of the
    ReplicaSet, this Pod belongs to this ReplicaSet. As you will see, the diagram
    shows three Pods are under the charge of the ReplicaSet. Even though Pod 2 has
    a different label of `env`, it is selected since the other two labels, `role`
    and `project`, match the ReplicaSet's selector.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReplicaSet的选择器用于决定它覆盖的Pods。如果Pod的标签中的键值对包括ReplicaSet选择器中的所有项目，则此Pod属于此ReplicaSet。正如您将看到的那样，图表显示三个Pod属于ReplicaSet的管理范围。即使Pod
    2具有不同的`env`标签，它也被选中，因为另外两个标签`role`和`project`与ReplicaSet的选择器匹配。
- en: '**ReplicationController? ReplicaSet?** For experienced Kubernetes players,
    you may notice ReplicaSet looks quite similar to the ReplicationController. Since
    version 1.2 of Kubernetes, in order to concentrate on different features, the
    ReplicationController''s functionality has been covered by ReplicaSet and Deployment.
    ReplicaSet focuses on the Pod replica, keeping certain Pods running in healthy
    states. On the other hand, Deployment is a higher-level API, which can manage
    the ReplicaSet, perform application rolling updates, and expose the services.
    In Kubernetes v1.8.3, users can still create replication controllers. However,
    using Deployment with ReplicaSet is more recommended because these are up to date
    and have finer granularity of configuration.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicationController？ReplicaSet？对于有经验的Kubernetes玩家，您可能会注意到ReplicaSet看起来与ReplicationController非常相似。自Kubernetes
    1.2版本以来，为了集中在不同的功能上，ReplicationController的功能已被ReplicaSet和Deployment覆盖。ReplicaSet专注于Pod副本，保持某些Pod处于健康状态。另一方面，Deployment是一个更高级的API，可以管理ReplicaSet，执行应用程序滚动更新，并公开服务。在Kubernetes
    v1.8.3中，用户仍然可以创建复制控制器。但是，使用带有ReplicaSet的Deployment更加推荐，因为它们是最新的，并且具有更精细的配置。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Creating a ReplicaSet is the same as creating any Kubernetes resource; we fire
    the `kubectl` command on the Kubernetes master. Therefore, we ensure your Kubernetes
    environment is ready to accept your order. More than that, the Kubernetes node
    should be able to access the Docker Hub. For the demonstration in the following
    few pages, we would take official `nginx` docker image for example, which stores
    in public docker registry as well.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建ReplicaSet与创建任何Kubernetes资源相同；我们在Kubernetes主节点上使用`kubectl`命令。因此，我们确保您的Kubernetes环境已准备好接受您的命令。此外，Kubernetes节点应该能够访问Docker
    Hub。在接下来的几页的演示中，我们将以官方的`nginx` docker镜像为例，该镜像也存储在公共docker注册表中。
- en: '**The evaluation of a prepared Kubernetes system** You can verify whether your
    Kuberenetes master is a practical one through checking the items here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好的Kubernetes系统评估：您可以通过检查以下项目来验证您的Kubernetes主节点是否实用：
- en: '**Check whether the daemons are running or no**t: There should be three working
    daemon processes on the master node: `apiserver`, `scheduler`, and `controller-manager`.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查守护程序是否正在运行：主节点上应该有三个工作中的守护进程：`apiserver`，`scheduler`和`controller-manager`。
- en: '**Check whether the command kubectl exists and is workable**: Try the command
    `kubectl get cs` to cover this bullet point and the first one. You can verify
    not only the status of components but also the feasibility of `kubectl`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查kubectl命令是否存在并且可用**：尝试使用命令`kubectl get cs`来覆盖此要点和第一个要点。您不仅可以验证组件的状态，还可以验证`kubectl`的可行性。'
- en: '**Check whether the nodes are ready to work**: You can check them by using
    the command `kubectl get nodes` to get their status.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查节点是否准备就绪**：您可以使用命令`kubectl get nodes`来检查它们的状态。'
- en: In the case that some items listed here are invalid, please refer to [Chapter
    1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml), *Building Your Own Kubernetes
    Cluster,* for proper guidelines based on the installation you chose.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此处列出的某些项目无效，请参考[第1章](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml)，*构建您自己的Kubernetes集群*，根据您选择的安装进行正确的指南。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will demonstrate the life cycle of a ReplicaSet from creation
    to destruction.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示ReplicaSet从创建到销毁的生命周期。
- en: Creating a ReplicaSet
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ReplicaSet
- en: 'When trying to use the command line to launch a Kubernetes Service immediately,
    we usually fire `kubectl run`. However, it would creates a Deployment by default,
    and not only taking care of the Pod replica but also providing a container-updating
    mechanism. To simply create a standalone ReplicaSet, we can exploit a configuration
    YAML file and run it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试使用命令行立即启动Kubernetes服务时，我们通常会使用`kubectl run`。然而，默认情况下会创建一个部署（Deployment），不仅负责Pod副本，还提供容器更新机制。为了简单地创建一个独立的ReplicaSet，我们可以利用一个配置YAML文件并运行它：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding file is the YAML for our first ReplicaSet. It defines a ReplicaSet
    named `my-first-replicaset`, which has three replicas for its Pods. Labels and
    the selector are the most characteristic settings of ReplicaSet. There are two
    sets of labels: one for ReplicaSet, the other for Pods. The first label for ReplicaSet
    is under the metadata of this resource, right beneath the name, which is simply
    used for description. However, the other label value under the template''s metadata,
    the one for Pods, is also used for identification. ReplicaSet takes charge of
    the Pods which have the labels covered by its selector.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件是我们第一个ReplicaSet的YAML。它定义了一个名为`my-first-replicaset`的ReplicaSet，其Pod有三个副本。标签和选择器是ReplicaSet最具特色的设置。有两组标签：一组用于ReplicaSet，另一组用于Pods。ReplicaSet的第一个标签位于此资源的元数据下方，就在名称的下方，仅用于描述。然而，在模板的元数据下方，用于Pods的另一个标签值也用于标识。ReplicaSet负责具有其选择器覆盖的标签的Pods。
- en: 'In our example configuration file, the selector of ReplicaSet looks for Pods
    with `project: My-Happy-Web` and `role: frontend` tags. Since we initiate Pods
    under control of this ReplicaSet, the Pods'' labels should definitely include
    what selector cares. You may get following error message while creating a ReplicaSet
    with incorrectly labeled Pods: ``selector` does not match template `labels``.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的示例配置文件中，ReplicaSet的选择器寻找具有`project: My-Happy-Web`和`role: frontend`标签的Pods。由于我们在此ReplicaSet的控制下初始化Pods，Pods的标签应该明确包含选择器关心的内容。在创建具有不正确标记的Pods的ReplicaSet时，您可能会收到以下错误消息：``选择器`与模板`标签`不匹配``。'
- en: 'Now, let''s create ReplicaSet through this file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过这个文件创建ReplicaSet：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**The API version of ReplicaSet in Kubernetes v1.9**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes v1.9中ReplicaSet的API版本**'
- en: While this book is under construction, Kubernetes v1.9 is released. The API
    version of ReplicaSet turns to a stable version `apps/v1` instead of `apps/v1beta2`.
    If you have an older version Kubernetes, please change the value of `apiVersion` to
    `apps/v1beta2`, or you can just update your Kubernetes system.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书编写时，Kubernetes v1.9已发布。ReplicaSet的API版本转为稳定版本`apps/v1`，而不再是`apps/v1beta2`。如果您使用较旧版本的Kubernetes，请将`apiVersion`的值更改为`apps/v1beta2`，或者您可以更新您的Kubernetes系统。
- en: Getting the details of a ReplicaSet
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取ReplicaSet的详细信息
- en: 'After we create the ReplicaSet, the subcommands `get` and `describe` can help
    us to capture its information and the status of Pods. In the CLI of Kubernetes,
    we are able to use the abbreviation rs for resource type, instead of the full
    name ReplicaSet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建ReplicaSet之后，子命令`get`和`describe`可以帮助我们捕获其信息和Pod的状态。在Kubernetes的CLI中，我们可以使用rs作为资源类型的缩写，而不是完整的ReplicaSet名称：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This result shows roughly that the Pod replicas of `my-first-replicaset` are
    all running successfully; currently running Pods are of the desired number and
    all of them are ready for serving requests.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果大致显示了`my-first-replicaset`的Pod副本都成功运行；当前运行的Pod数量符合预期，并且它们都准备好为请求提供服务。
- en: 'For detailed information, check by using the subcommand `describe`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取详细信息，请使用子命令`describe`：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can see that the output lists ReplicaSet''s particulars of the configuration,
    just like what we requested in the YAML file. Furthermore, the logs for the creation
    of Pods are shown as part of ReplicaSet, which confirms that the Pod replicas
    are successfully created and designated with unique names. You can also check
    Pods by name:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到输出列出了ReplicaSet的配置细节，就像我们在YAML文件中请求的那样。此外，创建Pod的日志也显示为ReplicaSet的一部分，这证实了Pod副本已成功创建并分配了唯一名称。您也可以通过名称检查Pods：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Changing the configuration of a ReplicaSet
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改ReplicaSet的配置
- en: The subcommands known as `edit`, `patch`, and `replace` can help to update live
    Kubernetes resources. All these functionalities change the settings by way of
    modifying a configuration file. Here we just take `edit`, for example.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`edit`、`patch`和`replace`的子命令可以帮助更新Kubernetes资源。所有这些功能都通过修改配置文件来改变设置。这里我们以`edit`为例。
- en: 'The subcommand edit lets users modify resource configuration through the editor.
    Try to update your ReplicaSet through the command `kubectl edit rs $REPLICASET_NAME`;
    you will access this resource via the default editor with a YAML configuration
    file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: edit子命令允许用户通过编辑器修改资源配置。尝试通过命令`kubectl edit rs $REPLICASET_NAME`来更新您的ReplicaSet；您将通过默认编辑器访问这个资源，其中包含一个YAML配置文件：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the demonstration, we succeed to add one Pod in the set, yet this is not
    the best practice for auto-scaling the Pod. Take a look at the *Working with configuration
    files* recipe in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml), *Playing
    with Containers*,for Reference, and try to change the other values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在演示中，我们成功地向集合中添加了一个Pod，但这并不是自动扩展Pod的最佳实践。参考[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)中的*使用配置文件*部分，尝试更改其他值。
- en: Deleting a ReplicaSet
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除ReplicaSet
- en: 'In order to remove the ReplicaSet from the Kubernetes system, you can rely
    on the subcommand `delete`. When we fire `delete` to remove the resource, it removes
    the target objects forcefully:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从Kubernetes系统中删除ReplicaSet，您可以依赖于子命令`delete`。当我们使用`delete`来删除资源时，它会强制删除目标对象：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We find that the response time is quite short and the effect is also instantaneous.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现响应时间非常短，效果也是瞬间的。
- en: '**Removing the Pod under ReplicaSet** As we mentioned previously, it is impossible
    to scale down the ReplicaSet by deleting the Pod, because while a Pod is removed,
    the ReplicaSet is out of stable status: if the desired number of Pods is not met,
    and the controller manager will ask ReplicaSet to create another one. The concept
    is shown in the following commands:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除ReplicaSet下的Pod** 正如我们之前提到的，通过删除Pod来缩减ReplicaSet是不可能的，因为当一个Pod被移除时，ReplicaSet就不再处于稳定状态：如果未达到期望的Pod数量，控制器管理器将要求ReplicaSet创建另一个Pod。这个概念在以下命令中显示：'
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You will find that although the `my-first-replicaset-bxf45` Pod is removed,
    the `my-first-replicaset-dvbpg` Pod is created automatically and attached to this
    ReplicaSet.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现，尽管`my-first-replicaset-bxf45` Pod被删除，但`my-first-replicaset-dvbpg` Pod会自动创建并附加到该ReplicaSet。
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The ReplicaSet defines a set of Pods by using a Pod template and labels. As
    in the ideas from previous sections, the ReplicaSet only manages the Pods via
    their labels. It is possible that the Pod template and the configuration of the
    Pod are different. This also means that standalone Pods can be added into a set
    by using label modification.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet通过使用Pod模板和标签来定义一组Pod。与前几节的想法一样，ReplicaSet只通过它们的标签来管理Pods。可能Pod模板和Pod的配置是不同的。这也意味着可以通过标签修改将独立的Pod添加到集合中。
- en: 'Let''s evaluate this concept of selectors and labels by creating a ReplicaSet
    similar to the diagram at the beginning of this recipe:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个类似于本教程开头图表的ReplicaSet来评估选择器和标签的概念：
- en: '![](assets/dd292c2f-714e-431e-a7f0-c134076653fe.png)The ReplicaSet would cover
    Pods which have the same labels describing in its selector'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/dd292c2f-714e-431e-a7f0-c134076653fe.png)ReplicaSet将覆盖具有与其选择器中描述的相同标签的Pod'
- en: 'First, we are going to create a CentOS Pod with the labels project: `My-Happy-Web`,
    `role: frontend`, and `env: test`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们将创建一个带有标签project: `My-Happy-Web`，`role: frontend`和`env: test`的CentOS Pod：'
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After adding this command, a standalone Pod runs with the labels we specified.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了这个命令后，一个带有我们指定标签的独立Pod将运行。
- en: 'Next, go create your first ReplicaSet example by using the YAML file again:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，再次使用YAML文件创建您的第一个ReplicaSet示例：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As in the preceding result, only two Pods are created. It is because the Pod
    `standalone-pod` is considered one of the sets taken by `my-first-replicaset`.
    Remember that `my-first-replicaset` takes care of the Pods labeled with project: `My-Happy-Web`
    and `role:frontend` (ignore the `env `tag). Go check the standalone Pod; you will
    find it belongs to a member of the ReplicaSet as well:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '与前面的结果一样，只创建了两个Pod。这是因为Pod `standalone-pod`被视为`my-first-replicaset`的一部分。请记住，`my-first-replicaset`负责标记为project:
    `My-Happy-Web`和`role:frontend`（忽略`env`标签）的Pod。去检查独立的Pod，您会发现它也属于ReplicaSet的成员：'
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Similarly, once we delete the set, the standalone Pod will be removed with
    the group:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一旦我们删除了集合，独立的Pod将与该组一起被删除：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There's more...
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are multiple Kubernetes resources for Pod management. Users are encouraged
    to leverage various types of resources to meet different purposes. Let''s comparing
    the resource types listed below with ReplicaSet:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种用于Pod管理的Kubernetes资源。鼓励用户利用各种资源类型来满足不同的目的。让我们将下面列出的资源类型与ReplicaSet进行比较：
- en: '**Deployment**: In general cases, Kubernetes Deployments are used together
    with ReplicaSet for complete Pod management: container rolling updates, load balancing,
    and service exposing.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Deployment**：在一般情况下，Kubernetes Deployments通常与ReplicaSet一起用于完整的Pod管理：容器滚动更新，负载均衡和服务暴露。'
- en: '**Job**: Sometimes, we want the Pods run as a job instead of a service. A Kubernetes
    job is suitable for this situation. You can consider it a ReplicaSet with the
    constraint of termination.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Job**：有时，我们希望Pods作为作业而不是服务运行。Kubernetes作业适用于这种情况。您可以将其视为具有终止约束的ReplicaSet。'
- en: '**DaemonSet**: More than ReplicaSet, the Kubernetes DaemonSet guarantees that
    the specified set is running on every node in the cluster. That said, a subset
    of ReplicaSet on every node.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DaemonSet**：与ReplicaSet相比，Kubernetes DaemonSet保证指定的集合在集群中的每个节点上都在运行。也就是说，每个节点上都有一个ReplicaSet的子集。'
- en: To get more idea and instruction, you can check the recipe *Ensuring flexible
    usage of your containers* in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多想法和指导，您可以在[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)的*Playing with
    Containers*中查看食谱*Ensuring flexible usage of your containers*。
- en: See also
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Now you understand the idea of ReplicaSet. Continue to look up the following
    recipes in this chapter for more Kubernetes resources, which will allow you to
    explore the magical effects of ReplicaSet:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了ReplicaSet的概念。继续查看本章中的以下食谱，以获取更多Kubernetes资源，这将使您能够探索ReplicaSet的神奇效果：
- en: '*Deployment API*'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署API*'
- en: '*Working with Services*'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Working with Services*'
- en: '*Working with labels an selectors*'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Working with labels an selectors*'
- en: 'Moreover, since you have built a simple ReplicaSet by using a configuration
    file, refer to more details about creating your own configuration files for Kubernetes
    resources:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于您已经使用配置文件构建了一个简单的ReplicaSet，请参考有关为Kubernetes资源创建自己的配置文件的更多详细信息：
- en: '*Working with configuration files* section in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    **Playing with Containers**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Working with configuration files*部分在[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)的**Playing
    with Containers**'
- en: Deployment API
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署API
- en: The Deployment API was introduced in Kubernetes version 1.2\. It is replacing
    the replication controller. The functionalities of rolling-update and rollback
    by replication controller, it was achieved with client side (`kubectl` command
    and `REST API`), that `kubectl` need to keep connect while updating a replication
    controller. On the other hand, Deployments takes care of the process of rolling-update
    and rollback at the server side. Once that request is accepted, the client can
    disconnect immediately.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 部署API是在Kubernetes版本1.2中引入的。它正在取代复制控制器。通过复制控制器实现的滚动更新和回滚功能是通过客户端端（`kubectl`命令和`REST
    API`）实现的，`kubectl`在更新复制控制器时需要保持连接。另一方面，部署在服务器端负责滚动更新和回滚的过程。一旦该请求被接受，客户端可以立即断开连接。
- en: Therefore, the Deployments API is designed as a higher-level API to manage ReplicaSet
    objects. This section will explore how to use the Deployments API to manage ReplicaSets.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，部署API被设计为更高级别的API来管理ReplicaSet对象。本节将探讨如何使用部署API来管理ReplicaSets。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In order to create Deployment objects, as usual, use the `kubectl run` command
    or prepare the YAML/JSON file that describe Deployment configuration. This example
    is using the `kubectl run` command to create a `my-nginx` Deployment object:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建部署对象，通常使用`kubectl run`命令或准备描述部署配置的YAML/JSON文件。此示例使用`kubectl run`命令创建`my-nginx`部署对象：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, a Deployment object `my-nginx` creates one `ReplicaSet`, which
    has an identifier: `<Deployment name>-<hex decimal hash>`. And then ReplicaSet
    creates three Pods which have an identifier: `<ReplicaSet id>-<random id>`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，部署对象`my-nginx`创建了一个`ReplicaSet`，其具有标识符：`<部署名称>-<十六进制哈希>`。然后ReplicaSet创建了三个具有标识符的Pod：`<ReplicaSet
    id>-<random id>`。
- en: Until Kubernetes version 1.8, `<Deployment name>-<pod-template-hash value (number)>`
    was used as a ReplicaSet identifier instead of a hex decimal hash.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 直到Kubernetes版本1.8，`<部署名称>-<pod-template-hash value (number)>`被用作ReplicaSet标识符，而不是十六进制哈希。
- en: For more details, look at pull request: [https://github.com/kubernetes/kubernetes/pull/51538](https://github.com/kubernetes/kubernetes/pull/51538).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请查看拉取请求：[https://github.com/kubernetes/kubernetes/pull/51538](https://github.com/kubernetes/kubernetes/pull/51538)。
- en: 'This diagram illustrates the **Deployment**, **ReplicaSet**, and **Pod** relationship:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此图示了**部署**、**ReplicaSet**和**Pod**之间的关系：
- en: '![](assets/48a785dd-5ce1-4a9b-8145-9d8aacdfd6e9.png)Relationship diagram for
    Deployments, ReplicaSets, and Pods'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/48a785dd-5ce1-4a9b-8145-9d8aacdfd6e9.png)部署、副本集和Pod的关系图'
- en: 'Because of this relationship, if you perform `delete` on a `my-nginx` Deployment
    object, it will also attempt to delete ReplicaSet and Pods respectively:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种关系，如果您对 `my-nginx` 部署对象执行 `delete` 操作，它也会尝试分别删除 ReplicaSet 和 Pods：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This example is just a simple `create` and `delete`, that easy to understand
    Deployment object and ReplicaSet object 1:1 relationship at this moment. However,
    a Deployment object can manage many ReplicaSets to preserve as a history. So the
    actual relationship is 1:N, as in the following diagram:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子只是一个简单的 `create` 和 `delete`，这个时刻很容易理解部署对象和 ReplicaSet 对象的 1:1 关系。然而，一个部署对象可以管理多个
    ReplicaSet 以保留历史记录。因此，实际关系是 1:N，如下图所示：
- en: '![](assets/48c720e2-16f1-473d-aa22-aad05204a347.png)Deployments maintain ReplicaSet
    history'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/48c720e2-16f1-473d-aa22-aad05204a347.png)部署维护 ReplicaSet 历史'
- en: To understand the 1:N relationship, let's recreate this Deployment object again
    and perform to make some changes to see how Deployment manages ReplicaSet history.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 1:N 的关系，让我们重新创建这个部署对象，并进行一些更改，看看部署如何管理 ReplicaSet 历史。
- en: How to do it...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: You may run the `kubectl run` command to recreate `my-nginx`, or write a Deployments
    configuration file that produces the same result. This is a great opportunity
    to learn about the Deployment configuration file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行 `kubectl run` 命令来重新创建 `my-nginx`，或者编写一个生成相同结果的部署配置文件。这是一个了解部署配置文件的绝佳机会。
- en: 'This example is an equivalent of `kubectl run my-nginx --image=nginx:1.11.0
    --port=80 --replicas=3`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子相当于 `kubectl run my-nginx --image=nginx:1.11.0 --port=80 --replicas=3`：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These parameters, sorted by key and value, are described here:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数按键和值排序，描述如下：
- en: '| **Key** | **Value** | **Description** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **键** | **值** | **描述** |'
- en: '| `apiVersion` | `apps/v1` | Until Kubernetes v1.8, it had been used apps/v1Beta1,
    v1.8 used apps/v1Beta2, then v1.9 or later use apps/v1 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `apiVersion` | `apps/v1` | 直到 Kubernetes v1.8，它使用了 apps/v1Beta1，v1.8 使用了
    apps/v1Beta2，然后 v1.9 或更高版本使用 apps/v1 |'
- en: '| `kind` | `deployment` | Indicates that this is a set of Deployment configurations
    |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `kind` | `deployment` | 表示这是一组部署配置 |'
- en: '| `metadata.name` | `my-nginx` | Name of Deployment |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `metadata.name` | `my-nginx` | 部署的名称 |'
- en: '| `spec.replicas` | `3` | Desire to have three Pods |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `spec.replicas` | `3` | 欲拥有三个 Pod |'
- en: '| `spec.selector.matchLabels` | `run:my-nginx` | Control ReplicaSet/Pods which
    have this label |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `spec.selector.matchLabels` | `run:my-nginx` | 控制具有此标签的 ReplicaSet/Pod |'
- en: '| `spec.template.metadata.labels` | `run:my-nginx` | Assigns this label when
    creating a ReplicaSet/Pod; it must match `spec.selector.matchLabels` |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `spec.template.metadata.labels` | `run:my-nginx` | 创建 ReplicaSet/Pod 时分配此标签；它必须与
    `spec.selector.matchLabels` 匹配 |'
- en: '| `spec.template.spec.containers` | name: `my-nginx`image: `nginx:1.11.0`port:`-
    containerPort:80` | ReplicaSet creates and manages Pods which have:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '| `spec.template.spec.containers` | name: `my-nginx`image: `nginx:1.11.0`port:`-
    containerPort:80` | ReplicaSet 创建和管理具有以下内容的 Pods：'
- en: name as `my-nginx`
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称为 `my-nginx`
- en: Container image as nginx version 1.11.0
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像为 nginx 版本 1.11.0
- en: Publish port number `80`
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布端口号 `80`
- en: '|'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If you use this YAML file to create a Deployment, use the `kubectl create` command
    instead of `kubectl run`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用此 YAML 文件创建一个部署，使用 `kubectl create` 命令而不是 `kubectl run`。
- en: 'Note that, this time, you should also specify `--save-config`, which allows
    you to update the resource using the `kubectl apply` command in the future. In
    addition, specify `--record` which can store the command line history. Those two
    options are not mandatory to manage ReplicaSet history but help you to preserve
    better information:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次，您还应该指定 `--save-config`，这样可以允许您在将来使用 `kubectl apply` 命令更新资源。此外，指定 `--record`
    可以存储命令行历史。这两个选项对于管理 ReplicaSet 历史并不是强制性的，但可以帮助您更好地保留信息：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can see a property `OldReplicaSets` and  `NewReplicaSet` in the preceding
    code, which are some association between Deployment and ReplicaSet.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在上述代码中看到`OldReplicaSets`和`NewReplicaSet`属性，这是Deployment和ReplicaSet之间的一些关联。
- en: Whenever you update a definition of a container template, for example, changing
    the nginx image version from 1.11.0 to 1.12.0, then Deployment `my-nginx` will
    create a new ReplicaSet. Then the property `NewReplicaSet` will point to the new
    ReplicaSet which has nginx version 1.12.0.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您更新容器模板的定义，例如，将nginx镜像版本从1.11.0更改为1.12.0，然后Deployment `my-nginx`将创建一个新的ReplicaSet。然后，属性`NewReplicaSet`将指向具有nginx版本1.12.0的新ReplicaSet。
- en: On the other hand, the `OldReplicaSets` property points to an old ReplicaSet
    which has nginx version 1.11.0 until new ReplicaSet is complete to setup new Pod.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`OldReplicaSets`属性指向一个旧的ReplicaSet，该ReplicaSet具有nginx版本1.11.0，直到新的ReplicaSet完成设置新的Pod。
- en: These old/new ReplicaSet associations between Deployment, Kubernetes administrator
    can easy to achieve rollback operation in case new ReplicaSet has any issues.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这些旧/新的ReplicaSet关联了Deployment，Kubernetes管理员可以很容易地实现回滚操作，以防新的ReplicaSet出现任何问题。
- en: In addition, Deployment can keep preserves the history of ReplicaSet which were
    associated with it before. Therefore, Deployment can anytime to change back (rollback)
    to any point of older ReplicaSet.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Deployment可以保留与其关联的ReplicaSet的历史记录。因此，Deployment随时可以回滚到任何旧的ReplicaSet。
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As mentioned earlier, let''s bump the nginx image version from 1.11.0 to 1.12.0\.
    There are two ways to change the container image: use the `kubectl set` command,
    or update YAML then use the `kubectl apply` command.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，让我们将nginx镜像版本从1.11.0升级到1.12.0。有两种方法可以更改容器镜像：使用`kubectl set`命令，或者更新YAML然后使用`kubectl
    apply`命令。
- en: Using the `kubectl set` command is quicker and there is better visibility when
    using the `--record` option.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl set`命令更快，而且在使用`--record`选项时有更好的可见性。
- en: On the other hand, updating YAML and using the `kubectl apply` command is better
    to preserve the entire Deployment YAML configuration file, which is better when
    using a version control system such as `git`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，更新YAML并使用`kubectl apply`命令可以更好地保留整个Deployment YAML配置文件，这在使用诸如`git`之类的版本控制系统时更好。
- en: Using kubectl set to update the container image
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用kubectl set来更新容器镜像
- en: 'Use the `kubectl set` command allows us to overwrite the `spec.template.spec.containers[].image`
    property that is similar to using the `kubectl run` command to specify the image
    file. The following example specifies `my-nginx` deployment to set the container
    `my-nginx` to change the image to nginx version 1.12.0:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl set`命令允许我们覆盖`spec.template.spec.containers[].image`属性，类似于使用`kubectl
    run`命令指定镜像文件。以下示例指定`my-nginx`部署以将容器`my-nginx`的镜像更改为nginx版本1.12.0：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, `OldReplicaSets` becomes the previous `ReplicaSet` (`my-nginx-54bb7bbcf9`)
    and `NewReplicaSet` becomes `my-nginx-77769b7666`. Note that you can see the `OldReplicaSets`
    property until `NewReplicaSet` is ready, so once the new `ReplicaSet` is successfully
    launched, `OldReplicaSet` becomes `<none>`, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`OldReplicaSets`变成了以前的`ReplicaSet`（`my-nginx-54bb7bbcf9`），而`NewReplicaSet`变成了`my-nginx-77769b7666`。请注意，您可以在新的`ReplicaSet`成功启动之前看到`OldReplicaSets`属性，因此一旦新的`ReplicaSet`成功启动，`OldReplicaSet`就变成了`<none>`，如下所示：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you can see the `ReplicaSet` list by `kubectl get rs`, you can see two ReplicaSet,
    as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过`kubectl get rs`查看`ReplicaSet`列表，您会看到两个ReplicaSet，如下所示：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, in the old `ReplicaSet` (`my-nginx-54bb7bbcf9`), the numbers
    of `DESIRED/CURRENT/READY` pods are all zero.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在旧的`ReplicaSet`（`my-nginx-54bb7bbcf9`）中，`DESIRED/CURRENT/READY`的Pod数量都为零。
- en: 'In addition, because the preceding example uses the `--record` option, you
    can see the history of the Deployment `my-nginx` rollout with the `kubectl rollout
    history` command, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为前面的示例使用了`--record`选项，您可以使用`kubectl rollout history`命令查看Deployment `my-nginx`的部署历史，如下所示：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Updating the YAML and using kubectl apply
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新YAML并使用kubectl apply
- en: 'For demo purposes, copy `deploy.yaml` to `deploy_1.12.2.yaml` and change the
    `nginx` version to `1.12.2`, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，将`deploy.yaml`复制到`deploy_1.12.2.yaml`，并将`nginx`版本更改为`1.12.2`，如下所示：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then run the `kubectl apply` command with the `--record` option:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`--record`选项运行`kubectl apply`命令：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will perform the same thing as the `kubectl set` image command, so you
    can see that the nginx image version has been bumped up to `1.12.2`; also, the
    `OldReplicaSets`/`NewReplicaSet` combination has been changed as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行与`kubectl set` image命令相同的操作，因此您可以看到nginx镜像版本已经提升到`1.12.2`；此外，`OldReplicaSets`/`NewReplicaSet`组合已更改如下：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After a few moments, `NewReplicaSet` will be ready. Then there will be a total
    of three `ReplicaSets` existing on your system:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，`NewReplicaSet`将准备就绪。然后系统上将存在三个`ReplicaSets`：
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can also see the rollout history:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以查看部署历史：
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Whenever you want to revert to a previous `ReplicaSet`, which means rolling
    back to the previous nginx version, you can use `kubectl rollout undo` with the
    `--to-revision` option. For example, if you want to roll back to revision 2 in
    your history (`kubectl set image deployment/my-nginx my-nginx=nginx:1.12.0 --record=true`),
    specify `--to-revision=2`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您想要恢复到先前的`ReplicaSet`，也就是回滚到先前的nginx版本时，您可以使用`kubectl rollout undo`命令和`--to-revision`选项。例如，如果您想要回滚到历史记录中的第2个修订版本（`kubectl
    set image deployment/my-nginx my-nginx=nginx:1.12.0 --record=true`），请指定`--to-revision=2`：
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'A few moments later, Deployment will deactivate the current `ReplicaSet`, which
    uses the Pod template with `nginx` version `1.12.2`, and will then activate the `ReplicaSet`
    which uses `nginx` version `1.12`, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，Deployment将停用当前使用`nginx`版本`1.12.2`的`ReplicaSet`，然后激活使用`nginx`版本`1.12`的`ReplicaSet`，如下所示：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: See also
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'In this section, you learned about the concept of Deployment. It is an important
    core feature in Kubernetes ReplicaSet life cycle management. It allows us to achieve
    rollout and rollback functionalities, and can integrate to CI/CD. In the following
    chapter you will see detailed operations of rollout and rollback:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了部署的概念。这是Kubernetes ReplicaSet生命周期管理中的一个重要核心功能。它允许我们实现部署和回滚功能，并可以集成到CI/CD中。在接下来的章节中，您将看到详细的部署和回滚操作：
- en: '*Updating live containers* section in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)的*更新实时容器*部分，*玩转容器*'
- en: '*Setting up a continuous delivery pipeline *section in [Chapter 5](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml),
    *Building Continuous Delivery Pipelines*'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第5章](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml)的*设置持续交付管道*部分，*构建持续交付管道*'
- en: Working with Services
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理服务
- en: 'The network service is an application that receives requests and provides a
    solution. Clients access the service by a network connection. They don''t have
    to know the architecture of the service or how it runs. The only thing that clients
    have to verify is whether the endpoint of the service can be accessed, and then
    follow its usage policy to get the response of the server. The Kubernetes Service
    has similar ideas. It is not necessary to understand every Pod before reaching
    their functionalities. For components outside the Kubernetes system, they just
    access the Kubernetes Service with an exposed network port to communicate with
    running Pods. It is not necessary to be aware of the containers'' IPs and ports.
    Behind Kubernetes Services, we can fulfill a zero-downtime update for our container
    programs without struggling:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务是一个接收请求并提供解决方案的应用程序。客户端通过网络连接访问服务。他们不必了解服务的架构或其运行方式。客户端唯一需要验证的是服务的端点是否可以访问，然后遵循其使用策略以获取服务器的响应。Kubernetes服务有类似的想法。在到达它们的功能之前，不需要了解每个Pod。对于Kubernetes系统外的组件，它们只需通过公开的网络端口访问Kubernetes服务以与运行的Pod通信。不需要了解容器的IP和端口。在Kubernetes服务的背后，我们可以为我们的容器程序实现零停机更新而不费吹灰之力：
- en: '![](assets/feaa67cf-b59c-43b1-87f2-5e0647c966ed.png)Kubernetes Service-covered
    Pods by labels of Pods and their selectors'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/feaa67cf-b59c-43b1-87f2-5e0647c966ed.png)Kubernetes服务通过Pod的标签和它们的选择器进行覆盖'
- en: 'The preceding diagram shows the basic structure of the **Service** and realizes
    the following concepts:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了**服务**的基本结构，并实现了以下概念：
- en: As with the **D****eployment**, the **Service** directs requests to Pods that
    have labels containing the Service's selector. In other words, the Pods selected
    by the **Service** are based on their labels.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与**部署**一样，**服务**将请求定向到具有包含服务选择器的标签的Pod。换句话说，**服务**选择的Pod是基于它们的标签。
- en: The load of requests sent to the Services will distribute to three Pods.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到服务的请求负载将分发到三个Pod。
- en: The **Deployment**, along with ReplicaSet, ensures that the number of running
    Pods meets its desired state. It monitors the Pods for the **Service**, making
    sure they will be healthy for taking over duties from the **Service**.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**与ReplicaSet一起，确保运行的Pod的数量达到其期望的状态。它监视**服务**的Pod，确保它们对于接管**服务**的职责是健康的。'
- en: '**Service** is an abstraction layer for grouping Pods, which allows for Pods
    scaling across nodes.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**是对分组Pod的抽象层，允许Pod在节点之间进行扩展。'
- en: In this recipe, you will learn how to create Services in front of your Pods
    for the requests.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何为请求在Pods前创建服务。
- en: Getting ready
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Prior to applying Kubernetes Services, it is important to verify whether all
    nodes in the system are running `kube-proxy`. The daemon `kube-proxy` works as
    a network proxy in a node. It helps to reflect Service settings, such as IPs or
    ports on each node, and to do network forwarding. To check if `kube-proxy` is
    running or not, we take a look at network connections:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用Kubernetes服务之前，重要的是要验证系统中所有节点是否正在运行`kube-proxy`。守护进程`kube-proxy`作为节点中的网络代理工作。它帮助反映服务设置，如每个节点上的IP或端口，并进行网络转发。要检查`kube-proxy`是否正在运行，我们看一下网络连接：
- en: '[PRE43]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once you see the output, the process ID `2326`, `kube-proxy`, listening on port
    `10249` on localhost, the node is ready for Kubernetes Services. Go ahead and
    verify whether all of your nodes in the Kubernetes cluster having `kube-proxy`
    running on them.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您看到输出，进程ID`2326`，`kube-proxy`，在本地主机上的端口`10249`上监听，节点已准备好用于Kubernetes服务。继续验证您的Kubernetes集群中的所有节点是否都在运行`kube-proxy`。
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'As mentioned in the previous section, the Kubernetes Service exposes Pods by
    selecting them through corresponding labels. However, there is another configuration
    we have to take care of: the network port. As the following diagram indicates,
    the Service and Pod have their own key-value pair labels and ports:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，Kubernetes服务通过选择相应的标签来暴露Pod。然而，还有另一个配置我们需要注意：网络端口。如下图所示，服务和Pod都有自己的键值对标签和端口：
- en: '![](assets/28ed7767-9dc7-4b82-9de3-3a6f99d969d0.png)Network port mapping between
    Service and Pod'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/28ed7767-9dc7-4b82-9de3-3a6f99d969d0.png)服务和Pod之间的网络端口映射'
- en: Therefore, setting the selector of Service and binding the service exposed port
    to the container port are required to be carried out while creating Services.
    If either of them fail to be set properly, clients won't get responses or will
    get connection-refused errors.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在创建服务时，需要设置服务的选择器并将服务暴露的端口绑定到容器端口。如果它们中的任何一个未能正确设置，客户端将无法获得响应或者会收到连接被拒绝的错误。
- en: We can define and create a new Kubernetes Service through the CLI or a configuration
    file. Here, we are going to explain how to deploy the Services by command. The
    subcommands `expose` and `describe` are utilized in the following commands for
    various scenarios. For file-format creation, it is recommended to read the *Working
    with configuration files* recipe in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*, for a detailed discussion.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过CLI或配置文件定义和创建新的Kubernetes服务。在这里，我们将解释如何通过命令部署服务。在以下命令中，子命令`expose`和`describe`用于各种场景。对于文件格式的创建，建议阅读[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)中的*使用配置文件*部分，进行详细讨论。
- en: Creating a Service for different resources
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为不同资源创建服务
- en: 'You can attach a Service to a Pod, a Deployment, an endpoint outside the Kubernetes
    system, or even another Service. We will show you these, one by one, in this section.
    The creation of the Kubernetes Service looks similar to these command formats:
    `kubectl expose $RESOURCE_TYPE $RESOURCE_NAME [OTHER TAGS]` or `kubectl expose
    -f $CONFIG_FILE`. The resource types (Pod, Deployment, and Service) are supported
    by the subcommand `expose`. So is the configuration file, which follows the limitation type.
    Accordingly, for a later demonstration we will attach the newly created Service
    to the endpoint by the configuration file.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将服务附加到Pod、部署、Kubernetes系统外的端点，甚至另一个服务。我们将在本节中依次展示这些内容。创建Kubernetes服务的方式与以下命令格式类似：`kubectl
    expose $RESOURCE_TYPE $RESOURCE_NAME [OTHER TAGS]`或`kubectl expose -f $CONFIG_FILE`。资源类型（Pod、部署和服务）都受到子命令`expose`的支持。配置文件也是如此，它遵循限制类型。因此，为了后续的演示，我们将通过配置文件将新创建的服务附加到端点。
- en: Creating a Service for a Pod
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Pod创建服务
- en: 'Kubernetes Pods covered by Service require labels, so that Service can recognize
    who is the one it should take charge of. In the following commands, we create
    a Pod with labels first, and attach a Service on it:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由服务覆盖的Kubernetes Pods需要标签，以便服务可以识别应该负责的对象。在下面的命令中，我们首先为Pod创建标签，然后在其上附加一个服务：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You may find that, based on the preceding command, we did not assign any selector
    to this Service. Nonetheless, since Service `nginx-service` takes the port forwarding
    task of Pod `nginx-pod`, it will take the labels of the Pod as its selector. Go ahead
    and check the details of the Service with the subcommand `describe`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现，根据前面的命令，我们没有为这个服务分配任何选择器。尽管如此，由于服务`nginx-service`承担了Pod`nginx-pod`的端口转发任务，它将以Pod的标签作为其选择器。继续并使用子命令`describe`检查服务的详细信息：
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now you can see that, for guaranteeing the responsibility, this successfully
    exposed Service just copied the labels of the Pod as its selector. The value list
    after `Endpoints` was the IP of the Pod and its exposed port `80`. Furthermore,
    the Service took the Pod's labels as its own. According to this example, the Pod
    can be accessed through Service by surfing `10.96.107.213:8080`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到，为了保证责任，这个成功暴露的服务只是复制了Pod的标签作为它的选择器。`Endpoints`后面的值列表是Pod的IP和它的暴露端口`80`。此外，服务将Pod的标签作为自己的标签。根据这个例子，可以通过访问`10.96.107.213:8080`来访问Pod。
- en: 'Except for the selector of Service, some parameters can be automatically configured
    if they are bypassed by users. One parameter is the labels of the Pod; another
    is the name of the Service; and the other is the exposed port of the Service.
    Let''s take a look at how this simple set of Pod and Service can be managed:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 除了服务的选择器之外，如果用户绕过了一些参数，它们可以自动配置。一个参数是Pod的标签；另一个是服务的名称；另一个是服务的暴露端口。让我们看看如何管理这个简单的Pod和服务：
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here, we can see that the Service inherited the name, label, and port from
    the Pod. The selector was assigned the dummy label with the key named `run` and
    the value named as Pod''s name, which is just the same dummy one of Pod `nginx-no-label`.
    Users should access the Service through port `80`, as well. For such simple settings,
    you can alternatively try the following command to create the Pods and Service
    at the same time:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到服务从Pod那里继承了名称、标签和端口。选择器被分配了一个名为`run`的虚拟标签，值为Pod的名称，这与Pod `nginx-no-label`的虚拟标签相同。用户也应该通过端口`80`访问服务。对于这样简单的设置，你也可以尝试使用以下命令同时创建Pod和服务：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Creating a Service for a Deployment with an external IP
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为具有外部IP的部署创建服务
- en: 'Kubernetes Deployment is the ideal resource type for a Service. For Pods supervised
    by the ReplicaSet and Deployment, the Kubernetes system has a controller manager
    to look over the their life cycles. It is also helpful for updating the version
    or state of the program by binding the existing Services to another Deployment.
    For the following commands, we create a Deployment first, and attach a Service
    with an external IP:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes部署是服务的理想资源类型。对于由ReplicaSet和Deployment监督的Pod，Kubernetes系统有一个控制器管理器来监视它们的生命周期。将现有服务绑定到另一个部署，也有助于更新程序的版本或状态。对于以下命令，我们首先创建一个部署，然后附加一个具有外部IP的服务：
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s go ahead and check the details of the newly created Service, `another-nginx-service`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续检查新创建的服务`another-nginx-service`的详细信息：
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Apart from the Service IP (in the case of the preceding command, `10.100.109.230`),
    which can be accessed within the Kubernetes system, the Service can now be connected
    through an external one (`192.168.122.102`, for example) beyond the Kubernetes
    system. While the Kubernetes master is able to communicate with every node, in
    this case, we can fire a request to the Service such as the following command:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 除了服务IP（在前面的命令中为`10.100.109.230`）可以在Kubernetes系统内访问之外，现在服务还可以通过Kubernetes系统之外的外部IP（例如`192.168.122.102`）进行连接。虽然Kubernetes主节点能够与每个节点通信，但在这种情况下，我们可以向服务发送请求，比如以下命令：
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Creating a Service for an Endpoint without a selector
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为没有选择器的端点创建服务
- en: 'First, we are going to create an Endpoint directing the external service. A
    Kubernetes Endpoint is an abstraction, making components beyond Kubernetes (for
    instance, a database in other system) become a part of Kubernetes resources. It
    provides a feasible use case for a hybrid environment. To create an endpoint,
    an IP address, along with a port, is required. Please take a look at the following
    template:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个指向外部服务的终端点。Kubernetes终端点是一个抽象，使得Kubernetes之外的组件（例如其他系统中的数据库）成为Kubernetes资源的一部分。它为混合环境提供了一个可行的用例。要创建一个终端点，需要IP地址和端口。请看下面的模板：
- en: '[PRE51]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The template defines an Endpoint named `k8s-ep`, which points to the IP of
    the host of the official Kubernetes website ([https://kubernetes.io](https://kubernetes.io)).
    Never mind that this Endpoint forwards to a plain HTML; we just take this Endpoint
    as an example. As mentioned, Endpoint is not a resource supported by the Kubernetes
    API for exposing:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 该模板定义了一个名为`k8s-ep`的终端点，它指向官方Kubernetes网站主机的IP地址（[https://kubernetes.io](https://kubernetes.io)）。不要紧，这个终端点转发到一个普通的HTML；我们只是拿这个终端点作为一个例子。正如前面提到的，终端点不是Kubernetes
    API支持的资源，用于暴露：
- en: '[PRE52]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In Kubernetes, an Endpoint not only represents an external service; an internal
    Kubernetes Service is also a Kubernetes Endpoint. You can check Endpoint resources
    with the command `kubectl get endpoints`. You will find that there is not a single
    endpoint `k8s-ep` (which you just created), but many endpoints named the same
    as the Services in previous pages. When a Service is created with a selector and
    exposes certain resources (such as a Pod, Deployment, or other Service), a corresponding
    Endpoint with the same name is created at the same time.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，终端点不仅代表外部服务；内部Kubernetes服务也是Kubernetes终端点。您可以使用命令`kubectl get endpoints`检查终端点资源。您会发现，并不是只有一个终端点`k8s-ep`（您刚刚创建的），而是许多与前几页中的服务同名的终端点。当创建一个带有选择器并暴露某些资源（如Pod、部署或其他服务）的服务时，同时会创建一个同名的终端点。
- en: 'Therefore, we still can create a Service associated with the Endpoint using
    an identical name, as in the following template:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们仍然可以使用相同的名称创建与终端点关联的服务，如下模板所示：
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The relationship between the Endpoints and the Service is built up with the
    resource name. For the Service `k8s-ep`, we didn''t indicate the selector, since
    it did not actually take any Pod in responsibility:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 终端点和服务之间的关系是通过资源名称建立起来的。对于服务`k8s-ep`，我们没有指定选择器，因为它实际上并没有承担任何Pod的责任：
- en: '[PRE54]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now you can see that the endpoint of the Service is just the one defined in
    `k8s-endpoint.yaml`. It is good for us to access the outside world through the
    Kubernetes Service! In the case earlier, we can verify the result with the following
    command:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以看到服务的终端点就是在`k8s-endpoint.yaml`中定义的终端点。通过Kubernetes服务访问外部世界对我们来说很有用！在前面的情况下，我们可以使用以下命令验证结果：
- en: '[PRE55]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Creating a Service for another Service with session affinity
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为另一个具有会话亲和性的服务创建一个服务
- en: 'While building a Service over another, we may think of multiple layers for
    port forwarding. In spite of redirecting traffic from one port to another, the
    action of exposing a Service is actually copying the setting of one Service to
    another. This scenario could be utilized as updating the Service setting, without
    causing headaches to current clients and servers:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建一个服务的同时，我们可能会考虑多层端口转发。尽管将流量从一个端口重定向到另一个端口，但暴露服务的操作实际上是将一个服务的设置复制到另一个服务。这种情况可以用作更新服务设置，而不会给当前的客户端和服务器带来麻烦：
- en: '[PRE56]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here we are! We successfully exposed another Service with similar settings
    to the Service `another-nginx-service`. The commands and output can be summarized
    as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里！我们成功地暴露了另一个具有类似设置的服务`another-nginx-service`。命令和输出可以总结如下：
- en: '**A new Service name is required**: Although we can copy the configurations
    from another Service, the name of the resource type should always be unique. When
    exposing a Service without the tag `--name`, you will get the error message: `Error
    from server (AlreadyExists): services "another-nginx-service" already exists`.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要新的服务名称**：虽然我们可以从另一个服务复制配置，但资源类型的名称应始终是唯一的。当在不带`--name`标签的情况下暴露服务时，您将收到错误消息：`Error
    from server (AlreadyExists): services "another-nginx-service" already exists`。'
- en: '**Adding or updating the configuration is workable**: We are able to add a
    new configuration, like adding session affinity; or we can update the port of
    the Service, like here, where we change to open port `8081` instead of `8080`.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加或更新配置是可行的：我们可以添加新的配置，比如添加会话亲和性；或者我们可以更新服务的端口，就像这里，我们改为打开端口`8081`而不是`8080`。
- en: '**Avoid changing target port**: Because the target port is along with the IP
    of the Pods, once the Service exposing changes the target port, the newly copied
    Service cannot forward traffic to the same endpoints. In the preceding example,
    since the new target port is defined, we should point out the container port again.
    It prevented the new Service from using the target port as the container port
    and turned out a misleading transaction.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免更改目标端口**：因为目标端口与Pod的IP一起，一旦服务暴露的目标端口发生变化，新复制的服务就无法将流量转发到相同的端点。在前面的例子中，由于定义了新的目标端口，我们应该再次指出容器端口。这样可以防止新服务将目标端口作为容器端口，并产生误导性的交易。'
- en: 'With session affinity, the list of description tags session affinity as `ClientIP`.
    For the current Kubernetes version, the client IP is the only option for session
    affinity. It takes the action as a hash function: with the same IP address, the
    request will always send to the identical Pod. However, this could be a problem
    if there is a load balancer or ingress controller in front of the Kubernetes Service:
    the requests would be considered to come from the same source, and the traffic
    forwarded to a single Pod. Users have to handle this issue on their own, for example,
    by building an HA proxy server instead of using the Kubernetes Service.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用会话亲和性，描述标签的列表将会话亲和性描述为`ClientIP`。对于当前的Kubernetes版本，客户端IP是会话亲和性的唯一选项。它将采取哈希函数的操作：使用相同的IP地址，请求将始终发送到相同的Pod。然而，如果在Kubernetes服务前面有负载均衡器或入口控制器，这可能会成为一个问题：请求将被视为来自相同的源，并且流量将被转发到单个Pod。用户必须自行处理此问题，例如，通过构建一个HA代理服务器来代替使用Kubernetes服务。
- en: Deleting a Service
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除服务
- en: 'If you go through every command in this section, there are definitely some
    demonstrated Kubernetes Services (we counted six of them) that should be removed.
    To delete a Service, the same as with any other Kubernetes resource, you can remove
    the Service with the name or the configuration file through the subcommand `delete`.
    When you try to remove the Service and the Endpoint at the same time, the following
    situation will happen:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本节中执行每个命令，肯定会有一些演示的Kubernetes服务（我们数了其中六个）应该被删除。要删除服务，与任何其他Kubernetes资源一样，您可以通过子命令`delete`删除具有名称或配置文件的服务。当您尝试同时删除服务和端点时，将发生以下情况：
- en: '[PRE57]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is because a Service is also a Kubernetes Endpoint. That's why, although
    we created the Service and the endpoint separately, once they are considered to
    work as a unit, the Endpoint is going to be removed when the Service is removed.
    Thus, the error message expresses that there is no endpoint called `k8s-ep`, since
    it was already removed with the Service deletion.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为服务也是Kubernetes端点。因此，尽管我们分别创建了服务和端点，一旦它们被视为一个单元工作，当服务被删除时，端点也将被删除。因此，错误消息表达了没有名为`k8s-ep`的端点，因为它已经随着服务的删除而被删除。
- en: How it works...
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: On the network protocol stack, the Kubernetes Service relies on the transport
    layer, working together with the **overlay network** and `kube-proxy`. The overlay
    network of Kubernetes builds up a cluster network by allocating a subnet lease
    out of a pre-configured address space and storing the network configuration in
    `etcd`; on the other hand, `kube-proxy` helps to forward traffic from the endpoints
    of Services to the Pods through `iptables` settings.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络协议栈上，Kubernetes服务依赖于传输层，与 **覆盖网络** 和 `kube-proxy` 协同工作。Kubernetes的覆盖网络通过在预配置的地址空间中分配子网租约并将网络配置存储在
    `etcd` 中来构建集群网络；另一方面，`kube-proxy` 通过 `iptables` 设置帮助将来自服务端点的流量转发到Pod。
- en: '**Proxy-mode and Service **`kube-proxy`  currently has three modes with different
    implementation methods: `userspace`, `iptables`, and `ipvs`. The modes affect
    how the requests of clients reach to certain Pods through the Kubernete Service:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式和服务 `kube-proxy` 目前有三种不同的实现方法：`userspace`、`iptables` 和 `ipvs`。这些模式会影响客户端请求如何通过Kubernetes服务到达特定的Pod：
- en: '`userspace`: `kube-proxy` opens a random port, called a proxy port, for each
    Service on the local node, then updates the `iptables` rules, which capture any
    request sent to the Service and forward it to the proxy port. In the end, any
    message sent to the proxy port will be passed to the Pods covered by the Service.
    It is less efficient, since the traffic is required to go to `kube-proxy` for
    routing to the Pod.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userspace`：`kube-proxy` 为每个本地节点上的服务打开一个随机端口，称为代理端口，然后更新 `iptables` 规则，捕获发送到服务的任何请求并将其转发到代理端口。最终，发送到代理端口的任何消息都将传递给服务覆盖的Pod。这种方式效率较低，因为流量需要经过
    `kube-proxy` 进行路由到Pod。'
- en: '`iptables`: As with the `userspace` mode, there are also required `iptables`
    rules for redirecting the client traffic. But there is no proxy port as mediator.
    Faster but need to take care the liveness of Pod. By default, there is no way
    for a request to retry another Pod if the target one fails. To avoid accessing
    the unhealthy Pod, health-checking Pods and updating `iptables` in time is necessary.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iptables`：与 `userspace` 模式一样，也需要 `iptables` 规则来重定向客户端流量。但是没有代理端口作为中介。速度更快，但需要注意Pod的存活状态。默认情况下，如果目标Pod失败，请求没有重试到另一个Pod的方式。为了避免访问不健康的Pod，需要对Pod进行健康检查并及时更新
    `iptables`。'
- en: '`ipvs`: `ipvs` is the beta feature in Kubernetes v1.9\. In this mode, `kube-proxy`
    builds up the interface called netlink between the Service and its backend set.
    The `ipvs` mode takes care of the downside in both `userspace` and `iptables`;
    it is even faster, since the routing rules stored a hash table structure in the
    kernel space, and even reliable that `kube-proxy` keeps checking the consistency
    of `netlinks`. `ipvs` even provides multiple load balancing options.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipvs`：`ipvs` 是Kubernetes v1.9中的beta功能。在这种模式下，`kube-proxy` 在服务和其后端集之间建立了称为netlink的接口。`ipvs`
    模式解决了`userspace` 和 `iptables` 的缺点；它甚至更快，因为路由规则存储在内核空间的哈希表结构中，而且`kube-proxy` 会不断检查
    `netlinks` 的一致性。`ipvs` 甚至提供了多种负载均衡选项。'
- en: The system picks the optimal and stable one as the default setting for `kube-proxy`.
    Currently, it is the mode `iptables`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会选择最佳和稳定的模式作为 `kube-proxy` 的默认设置。目前，默认设置是 `iptables` 模式。
- en: 'When a Pod tries to communicate with a Service, it can find the Service through
    environment variables or a DNS host lookup. Let''s give it a try in the following
    scenario of accessing a service in a Pod:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当Pod尝试与服务通信时，它可以通过环境变量或DNS主机查找来找到服务。让我们在以下访问Pod中尝试一下：
- en: '[PRE58]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You will find that the Pod `my-2nd-centos` comes out with additional variables
    showing information for the Service `my-nginx-service`, as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现Pod `my-2nd-centos` 显示了与服务 `my-nginx-service` 相关的额外变量信息，如下所示：
- en: '[PRE59]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This is because the system failed to do a real-time update for Services; only
    the Pods created subsequently can be applied to accessing the Service through
    environment variables. With this ordering-dependent constraint, pay attention
    to running your Kubernetes resources in a proper sequence if they have to interact
    with each other in this way. The keys of the environment variables representing
    the Service host are formed as `<SERVICE NAME>_SERVICE_HOST`, and the Service
    port is like `<SERVICE NAME>_SERVICE_PORT`. In the preceding example, the dash
    in the name is also transferred to the underscore:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为系统未能对服务进行实时更新；只有随后创建的Pod才能通过环境变量访问服务。在有序依赖的约束下，如果资源需要以这种方式相互交互，请注意按正确的顺序运行您的Kubernetes资源。表示服务主机的环境变量的键形成为`<SERVICE
    NAME>_SERVICE_HOST`，服务端口类似于`<SERVICE NAME>_SERVICE_PORT`。在前面的示例中，名称中的破折号也转换为下划线：
- en: '[PRE60]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Nevertheless, if the `kube-dns` add-on is installed, which is a DNS server
    in the Kubernetes system, any Pod in the same Namespace can access the Service,
    no matter when the Service was created. The hostname of the Service would be formed
    as `<SERVICE NAME>.<NAMESPACE>.svc.cluster.local`. `cluster.local` is the default
    cluster domain defined in booting `kube-dns`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果安装了`kube-dns`附加组件，它是Kubernetes系统中的DNS服务器，同一命名空间中的任何Pod都可以访问服务，无论服务何时创建。服务的主机名将形成为`<SERVICE
    NAME>.<NAMESPACE>.svc.cluster.local`。`cluster.local`是在启动`kube-dns`时定义的默认集群域：
- en: '[PRE61]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: There's more...
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The Kubernetes Service has four types: `ClusterIP`, `NodePort`, `LoadBalancer`,
    and `ExternalName`. In the *How to do it...* section in this recipe, we only demonstrate
    the default type, `ClusterIP`. The type `ClusterIP` indicates that the Kubernetes
    Service is assigned a unique virtual IP in the overlay network, which also means
    the identity in this Kubernetes cluster. `ClusterIP` guarantees that the Service
    is accessible internally.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes服务有四种类型：`ClusterIP`、`NodePort`、`LoadBalancer`和`ExternalName`。在本教程的*操作步骤*部分，我们只演示了默认类型`ClusterIP`。`ClusterIP`类型表示Kubernetes服务在覆盖网络中被分配了唯一的虚拟IP，这也意味着在这个Kubernetes集群中的身份。`ClusterIP`保证了服务在内部是可访问的。
- en: 'The following diagram expresses the availability coverage of the types, and
    their entry points:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表表示了各种类型的可用覆盖范围及其入口点：
- en: '![](assets/516627fc-54d3-4283-ba0f-70d54d0d7978.png)Four Service types and
    their entry points'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/516627fc-54d3-4283-ba0f-70d54d0d7978.png)四种服务类型及其入口点'
- en: For the `NodePort` type, it covers the `ClusterIP`'s features, has a peer-accessible
    virtual IP, and also allows the user to expose Services on each node with the
    same port. The type `LoadBalancer` is on the top of the other two types. The `LoadBalancer`
    Service would be exposed internally and on the node. More than that, if your cloud
    provider supports external load balancing servers, you can bind the load balancer
    IP to the Service, and this will become another exposing point. On the other hand,
    the type `ExternalName` is used for the endpoint out of your Kubernetes system.
    It is similar to the Endpoint we created with the configuration file in a previous
    section; moreover, a single `ExternalName` Service can provide this feature.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`NodePort`类型，它覆盖了`ClusterIP`的功能，具有对等可访问的虚拟IP，并且还允许用户在每个节点上使用相同端口暴露服务。`LoadBalancer`类型位于其他两种类型之上。`LoadBalancer`服务将在内部和节点上暴露。此外，如果您的云提供商支持外部负载均衡服务器，您可以将负载均衡器IP绑定到服务，这将成为另一个暴露点。另一方面，`ExternalName`类型用于Kubernetes系统之外的端点。它类似于我们在上一节中使用配置文件创建的端点；此外，单个`ExternalName`服务可以提供此功能。
- en: 'We can use the subcommand `create` to create Services in different types:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用子命令`create`来创建不同类型的服务：
- en: '[PRE62]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In this example of the `NodePort` Service, you can see that it still has the
    virtual IP (`10.105.106.134`) in the cluster, and can be accessed through port
    `31336` of any Kubernetes node:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`NodePort`服务的示例中，您可以看到它仍然在集群中具有虚拟IP（`10.105.106.134`），并且可以通过任何Kubernetes节点的端口`31336`访问：
- en: '[PRE63]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the case here, we demonstrate creating an `ExternalName` Service which exposes
    the `CNAME kubernetes.io`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们演示创建一个暴露`CNAME kubernetes.io`的`ExternalName`服务：
- en: '[PRE64]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Yet, we cannot build an `ExternalName` Service in CLI with the subcommand `expose`,
    because `expose` works on exposing the Kubernetes resources, while the `ExternalName` Service
    is for the resources in the outside world. Then, it is also reasonable that the
    `ExternalName` Service doesn't need to be defined with the selector.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们无法使用子命令`expose`在CLI中构建`ExternalName`服务，因为`expose`用于暴露Kubernetes资源，而`ExternalName`服务是为外部世界的资源。因此，`ExternalName`服务不需要使用选择器进行定义也是合理的。
- en: '**Using the subcommand "create" to create Services** While using the subcommand
    `create` on Service creation, the command line would look like this: `kubectl
    create service <SERVICE TYPE> <SERVICE NAME> [OPTIONS]`. And we can put the Service
    types at `<SERVICE TYPE>`, such as `clusterip`, `nodeport`, `loadbalancer`, and
    `externalname`. With this method, we cannot specify the selector of the Service.
    As with the `NodePort` Service we created in that section, only a default selector, `app:
    my-nginx`, is created, and we have to assign this label to a later created Deployment
    `test-nodeport`. Except for the type `ExternalName`, Service types can be created
    with the subcommand `expose` with the tag `type`. Try to create the `NodePort` service
    with `kubectl expose` for existing resources!'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用子命令"create"创建服务** 在创建服务时使用子命令`create`，命令行看起来像这样：`kubectl create service
    <SERVICE TYPE> <SERVICE NAME> [OPTIONS]`。我们可以在`<SERVICE TYPE>`处放置服务类型，例如`clusterip`、`nodeport`、`loadbalancer`和`externalname`。使用这种方法，我们无法指定服务的选择器。就像我们在那一节中创建的`NodePort`服务一样，只创建了一个默认选择器`app:
    my-nginx`，我们必须将此标签分配给稍后创建的部署`test-nodeport`。除了类型`ExternalName`，服务类型可以使用子命令`expose`和标签`type`来创建。尝试使用`kubectl
    expose`为现有资源创建`NodePort`服务！'
- en: See also
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'To get the best practices of Kubernetes Services, the following recipes in
    [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking though Kubernetes
    Concepts*, are suggested reading:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得Kubernetes服务的最佳实践，建议阅读[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中的以下示例，*深入了解Kubernetes概念*：
- en: '*Deployment API*'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署API*'
- en: '*Working with Secrets*'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用机密*'
- en: '*Working with labels and selectors*'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用标签和选择器*'
- en: 'There is more advanced knowledge to make your service more functional and flexible.
    Stay tuned:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多高级知识可以使您的服务更加功能强大和灵活。敬请关注：
- en: '*Forwarding container ports* section in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)的*Playing with Containers*部分，*转发容器端口*'
- en: '*Ensuring flexible usage of your containers* section in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)的*Playing with Containers*部分，*确保容器的灵活使用*'
- en: Working with volumes
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用卷
- en: 'Files in a container are ephemeral. When the container is terminated, the files
    are gone. Docker has introduced data volumes to help us persist data ([https://docs.docker.com/engine/admin/volumes/volumes](https://docs.docker.com/engine/admin/volumes/volumes)).
    However, when it comes to multiple hosts, as a container cluster, it is hard to
    manage volumes across all the containers and hosts for file sharing or provisioning
    volume dynamically. Kubernetes introduces volume, which lives with a Pod across
    a container life cycle. It supports various types of volumes, including popular
    network disk solutions and storage services in different public clouds. Here are
    a few:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 容器中的文件是临时的。当容器终止时，文件会消失。Docker引入了数据卷来帮助我们持久化数据（[https://docs.docker.com/engine/admin/volumes/volumes](https://docs.docker.com/engine/admin/volumes/volumes)）。然而，当涉及到多个主机时，作为容器集群，跨所有容器和主机管理卷以进行文件共享或动态配置卷是很困难的。Kubernetes引入了卷，它在容器的整个生命周期中与Pod一起存在。它支持各种类型的卷，包括流行的网络磁盘解决方案和不同公共云中的存储服务。以下是其中一些：
- en: '| **Volume type** | **Storage provider** |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| **卷类型** | **存储提供程序** |'
- en: '| `emptyDir` | Localhost |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `emptyDir` | 本地主机 |'
- en: '| `hostPath` | Localhost |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `hostPath` | 本地主机 |'
- en: '| `glusterfs` | GlusterFS cluster |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `glusterfs` | GlusterFS集群 |'
- en: '| `downwardAPI` | Kubernetes Pod information |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `downwardAPI` | Kubernetes Pod信息 |'
- en: '| `nfs` | NFS server |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `nfs` | NFS服务器 |'
- en: '| `awsElasticBlockStore` | Amazon Web Service Amazon Elastic Block Store |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `awsElasticBlockStore` | 亚马逊弹性块存储 |'
- en: '| `gcePersistentDisk` | Google Compute Engine persistent disk |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `gcePersistentDisk` | Google Compute Engine持久磁盘 |'
- en: '| `azureDisk` | Azure disk storage |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `azureDisk` | Azure磁盘存储 |'
- en: '| `projected` | Kubernetes resources; currently supports `secret`, `downwardAPI`,
    and `configMap` |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `projected` | Kubernetes资源；目前支持`secret`，`downwardAPI`和`configMap` |'
- en: '| `secret` | Kubernetes Secret resource |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `secret` | Kubernetes Secret资源 |'
- en: '| `vSphereVolume` | vSphere VMDK volume |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `vSphereVolume` | vSphere VMDK卷 |'
- en: '| `gitRepo` | Git repository |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `gitRepo` | Git仓库 |'
- en: Getting ready
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Storage providers are required when you start to use volume in Kubernetes, except
    for `emptyDir`, which will be erased when the Pod is removed. For other storage
    providers, folders, servers, or clusters have to be built before using them in
    the Pod definition. Dynamic provisioning was promoted to stable in Kubernetes
    version 1.6, which allows you to provision storage based on the supported cloud
    provider.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始在Kubernetes中使用卷时，需要存储提供程序，除了`emptyDir`，当Pod被删除时，它将被删除。对于其他存储提供程序，在使用它们之前，必须在Pod定义中构建文件夹、服务器或集群。动态配置在Kubernetes版本1.6中被提升为稳定版本，它允许您根据支持的云提供商来配置存储。
- en: In this section, we'll walk through the details of `emptyDir`, `hostPath`, `nfs`,
    `glusterfs`, `downwardAPI`, and `gitRepo`. `Secret`, which is used to store credentials,
    will be introduced in the next section. `Projected`, on the other hand, is a way
    one could group other volume resources under one single mount point. As it only
    supports `secret`, `downwardAPI`, and `configMap`, we'll be introducing this in
    the Secret section, as well. The rest of the volume types have similar Kubernetes
    syntax, just with different backend volume implementations.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细介绍`emptyDir`，`hostPath`，`nfs`，`glusterfs`，`downwardAPI`和`gitRepo`的细节。`Secret`用于存储凭据，将在下一节介绍。另一方面，`Projected`是一种将其他卷资源组合在一个单一挂载点下的方法。由于它只支持`secret`，`downwardAPI`和`configMap`，我们将在Secret部分介绍这一点。其余的卷类型具有类似的Kubernetes语法，只是具有不同的后端卷实现。
- en: How to do it...
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Volumes are defined in the volumes section of the pod definition with unique
    names. Each type of volume has a different configuration to be set. Once you define
    the volumes, you can mount them in the `volumeMounts` section in the container
    specs. `volumeMounts.name` and `volumeMounts.mountPath` are required, which indicate
    the name of the volumes you defined and the mount path inside the container, respectively.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 卷在 pod 定义的卷部分中以唯一名称定义。每种类型的卷都有不同的配置要设置。一旦定义了卷，就可以在容器规范的 `volumeMounts` 部分中挂载它们。`volumeMounts.name`
    和 `volumeMounts.mountPath` 是必需的，分别表示您定义的卷的名称和容器内的挂载路径。
- en: We'll use the Kubernetes configuration file with the YAML format to create a
    Pod with volumes in the following examples.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 YAML 格式的 Kubernetes 配置文件来创建以下示例中带有卷的 Pod。
- en: emptyDir
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: emptyDir
- en: '`emptyDir` is the simplest volume type, which will create an empty volume for
    containers in the same Pod to share. When the Pod is removed, the files in `emptyDir`
    will be erased, as well. `emptyDir` is created when a Pod is created. In the following
    configuration file, we''ll create a Pod running Ubuntu with commands to sleep
    for `3600` seconds. As you can see, one volume is defined in the volumes section
    with name data, and the volumes will be mounted under the `/data-mount` path in
    the Ubuntu container:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`emptyDir` 是最简单的卷类型，将为同一 Pod 中的容器创建一个空卷。当 Pod 被移除时，`emptyDir` 中的文件也将被删除。`emptyDir`
    在创建 Pod 时创建。在下面的配置文件中，我们将创建一个运行 Ubuntu 的 Pod，并使用命令休眠 `3600` 秒。如您所见，卷在卷部分中以名称 data
    定义，卷将在 Ubuntu 容器中的 `/data-mount` 路径下挂载：'
- en: '[PRE65]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '**Check which node the Pod is running on** By using the `kubectl describe pod
    <Pod name> | grep Node` command, you can check which node the Pod is running on.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查 Pod 运行在哪个节点上** 通过使用 `kubectl describe pod <Pod name> | grep Node` 命令，您可以检查
    Pod 运行在哪个节点上。'
- en: 'After the Pod is running, you can use `docker inspect <container ID>` on the
    target node and you can see the detailed mount points inside your container:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 运行后，您可以在目标节点上使用 `docker inspect <container ID>` 来查看容器内的详细挂载点：
- en: '[PRE66]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Kubernetes mounts `/var/lib/kubelet/pods/<id>/volumes/kubernetes.io~empty-dir/<volumeMount
    name>` to `/data-mount` for the Pod to use. If you create a Pod with more than
    one container, all of them will mount the same destination `/data-mount` with
    the same source. The default mount propagation is `rprivate`, which means any
    mount points on the host are invisible in the container, and vice versa.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 将 `/var/lib/kubelet/pods/<id>/volumes/kubernetes.io~empty-dir/<volumeMount
    name>` 挂载到 `/data-mount`，以供 Pod 使用。如果创建一个具有多个容器的 Pod，所有这些容器都将使用相同的源挂载到相同的目标 `/data-mount`。默认的挂载传播是
    `rprivate`，这意味着主机上的任何挂载点在容器中是不可见的，反之亦然。
- en: '`emptyDir` could be mounted as `tmpfs` by setting `emptyDir.medium` as `Memory`.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `emptyDir.medium` 设置为 `Memory`，可以将 `emptyDir` 挂载为 `tmpfs`。
- en: 'Taking the previous configuration file `2-6-1_emptyDir_mem.yaml` as an example,
    it would be as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的配置文件 `2-6-1_emptyDir_mem.yaml` 作为示例，如下所示：
- en: '[PRE67]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We could verify whether it''s successfully mounted with the `kubectl exec <pod_name>
    <commands>` command. We''ll run the `df` command in this container:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `kubectl exec <pod_name> <commands>` 命令来验证它是否成功挂载。我们将在此容器中运行 `df` 命令：
- en: '[PRE68]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that `tmpfs` is stored in memory instead of in the filesystem. No file
    will be created, and it'll be flushed in every reboot. In addition, it is constrained
    by memory limits in Kubernetes. For more information about container resource
    constraint, refer to *Working with Namespace* in this chapter.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`tmpfs` 存储在内存中而不是文件系统中。不会创建任何文件，并且在每次重启时都会被清除。此外，它受 Kubernetes 中的内存限制约束。有关容器资源约束的更多信息，请参阅本章中的
    *使用命名空间*。
- en: If you have more than one container inside a Pod, the `Kubectl exec` command
    will be `kubectl exec <pod_name> <container_name> <commands>`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Pod中有多个容器，`Kubectl exec`命令将是`kubectl exec <pod名称> <容器名称> <命令>`。
- en: hostPath
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: hostPath
- en: '`hostPath` acts as data volume in Docker. The local folder on a node listed
    in `hostPath` will be mounted into the Pod. Since the Pod can run on any nodes,
    read/write functions happening in the volume could explicitly exist in the node
    on which the Pod is running. In Kubernetes, however, the Pod should not be node-aware.
    Please note that the configuration and files might be different on different nodes
    when using `hostPath`. Therefore, the same Pod, created by the same command or
    configuration file, might act differently on different nodes.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`hostPath`在Docker中充当数据卷。在`hostPath`中列出的节点上的本地文件夹将被挂载到Pod中。由于Pod可以在任何节点上运行，发生在卷中的读/写功能可能明确存在于Pod正在运行的节点上。然而，在Kubernetes中，Pod不应该是节点感知的。请注意，当使用`hostPath`时，不同节点上的配置和文件可能是不同的。因此，通过相同的命令或配置文件创建的相同的Pod在不同的节点上可能会有不同的行为。'
- en: 'By using `hostPath`, you''re able to read and write the files between containers
    and localhost disks of nodes. What we need for volume definition is for `hostPath.path`
    to specify the target mounted folder on the node:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`hostPath`，你可以在容器和节点的本地磁盘之间读写文件。我们需要卷定义的是`hostPath.path`来指定节点上目标挂载的文件夹：
- en: '[PRE69]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Using `docker inspect` to check the volume details, you will see the volume
    on the host is mounted in the `/data-mount` destination:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker inspect`来检查卷的详细信息，你会看到主机上的卷被挂载在`/data-mount`目的地上：
- en: '[PRE70]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If we run `kubectl exec ubuntu touch /data-mount/sample`, we should be able
    to see one empty file, named `sample under /tmp/data`, on the host.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`kubectl exec ubuntu touch /data-mount/sample`，我们应该能够在主机上的`/tmp/data`下看到一个空文件，名为`sample`。
- en: NFS
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NFS
- en: You can mount an **network filesystem** (**NFS**) to your Pod as `nfs volume`.
    Multiple Pods can mount and share the files in the same `nfs volume`. The data
    stored into `nfs volume` will be persistent across the Pod lifetime. You have
    to create your own NFS server before using `nfs volume`, and make sure the `nfs-utils`
    package is installed on Kubernetes minions.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将**网络文件系统**（NFS）作为`nfs卷`挂载到你的Pod上。多个Pod可以挂载和共享相同的`nfs卷`中的文件。存储在`nfs卷`中的数据将在Pod的整个生命周期中持久存在。在使用`nfs卷`之前，你必须创建自己的NFS服务器，并确保Kubernetes的minions上安装了`nfs-utils`软件包。
- en: Check whether your NFS server works before you go. You should check out the `/etc/exports`
    file with a proper sharing parameter and directory, and use the `mount -t nfs
    <nfs server>:<share name> <local mounted point>` command to check whether it could
    be mounted locally.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在你离开之前，检查一下你的NFS服务器是否正常工作。你应该检查`/etc/exports`文件，使用适当的共享参数和目录，并使用`mount -t nfs
    <nfs服务器>:<共享名称> <本地挂载点>`命令来检查它是否可以在本地挂载。
- en: 'The configuration file of the volume type with NFS is similar to others, but
    `nfs.server` and `nfs.path` are required in the volume definition to specify NFS
    server information and the path mounted from. `nfs.readOnly` is an optional field
    for specifying whether the volume is read-only or not (the default is `false`):'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 具有NFS类型的卷的配置文件与其他类型类似，但卷定义中需要`nfs.server`和`nfs.path`来指定NFS服务器信息和挂载路径。`nfs.readOnly`是一个可选字段，用于指定卷是否为只读（默认为`false`）：
- en: '[PRE71]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'After you run `kubectl create –f 2-6-3_nfs.yaml`, you can describe your Pod
    with `kubectl describe <pod name>` to check the mounting status. If it''s mounted
    successfully, it should show conditions. Ready as true and the target `nfs` you
    mount:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`kubectl create -f 2-6-3_nfs.yaml`之后，你可以使用`kubectl describe <pod名称>`来描述你的Pod，以检查挂载状态。如果成功挂载，它应该显示条件。就绪为true和你挂载的目标`nfs`：
- en: '[PRE72]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If we inspect the container with the `docker` command, we can see the volume
    information in the `Mounts` section:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`docker`命令检查容器，我们可以在`Mounts`部分看到卷信息：
- en: '[PRE73]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Actually, Kubernetes just mounts your `<nfs server>:<share name>` into `/var/lib/kubelet/pods/<id>/volumes/kubernetes.io~nfs/nfs`,
    and then mounts it into the container as the destination in `/data-mount`. You
    could also use `kubectl exec` to touch the file, to test whether it's perfectly
    mounted.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Kubernetes只是将您的`<nfs服务器>:<共享名称>`挂载到`/var/lib/kubelet/pods/<id>/volumes/kubernetes.io~nfs/nfs`，然后将其作为目标挂载到容器中的`/data-mount`。您还可以使用`kubectl
    exec`来触摸文件，以测试它是否被完美地挂载。
- en: glusterfs
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: glusterfs
- en: GlusterFS ([https://www.gluster.org](https://www.gluster.org)) is a scalable,
    network-attached storage filesystem. The `glusterfs` volume type allows you to
    mount GlusterFS volume into your Pod. Just like NFS volume, the data in `glusterfs`
    volume is persistent across the Pod lifetime. If the Pod is terminated, the data
    is still accessible in `glusterfs` volume. You should build the GlusterFS system
    before using `glusterfs` volume.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: GlusterFS（[https://www.gluster.org](https://www.gluster.org)）是一个可扩展的网络附加存储文件系统。`glusterfs`卷类型允许您将GlusterFS卷挂载到您的Pod中。就像NFS卷一样，`glusterfs`卷中的数据在整个Pod生命周期中是持久的。如果Pod被终止，数据仍然可以在`glusterfs`卷中访问。在使用`glusterfs`卷之前，您应该构建GlusterFS系统。
- en: Check whether `glusterfs` works before you go. By using `glusterfs` volume information
    on GlusterFS servers, you can see currently available volumes. By using `mount
    -t glusterfs <glusterfs server>:/<volume name> <local mounted point>` on local,
    you can check whether the GlusterFS system can be successfully mounted.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行之前，请检查`glusterfs`是否有效。通过在GlusterFS服务器上使用`glusterfs`卷信息，您可以查看当前可用的卷。通过在本地使用`mount
    -t glusterfs <glusterfs服务器>:/<卷名称> <本地挂载点>`，您可以检查GlusterFS系统是否可以成功挂载。
- en: Since the volume replica in GlusterFS must be greater than `1`, let's assume
    we have two replicas in the servers `gfs1` and `gfs2`, and the volume name is
    `gvol`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GlusterFS中的卷副本必须大于`1`，让我们假设我们在服务器`gfs1`和`gfs2`上有两个副本，并且卷名称是`gvol`。
- en: 'First, we need to create an endpoint acting as a bridge for `gfs1` and `gfs2`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个作为`gfs1`和`gfs2`桥接的端点：
- en: '[PRE74]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, we can use `kubectl get endpoints` to check the endpoint was created
    properly:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`kubectl get endpoints`来检查端点是否正确创建：
- en: '[PRE75]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'After that, we should be able to create the Pod with `glusterfs` volume by
    `glusterfs.yaml`. The parameters of the `glusterfs` volume definition are `glusterfs.endpoints`,
    which specify the endpoint name we just created, and `glusterfs.path`, which is
    the volume name `gvol`. `glusterfs.readOnly` is used to set whether the volume
    is mounted in read-only mode:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们应该能够通过`glusterfs.yaml`使用`glusterfs`卷创建Pod。`glusterfs`卷定义的参数是`glusterfs.endpoints`，它指定了我们刚刚创建的端点名称，以及`glusterfs.path`，它是卷名称`gvol`。`glusterfs.readOnly`用于设置卷是否以只读模式挂载：
- en: '[PRE76]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let''s check the volume setting with `kubectl describle`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`kubectl describle`来检查卷设置：
- en: '[PRE77]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Using `docker inspect`, you should be able to see that the mounted source is
    `/var/lib/kubelet/pods/<id>/volumes/kubernetes.io~glusterfs/data` to the destination
    `/data-mount`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker inspect`，您应该能够看到挂载源是`/var/lib/kubelet/pods/<id>/volumes/kubernetes.io~glusterfs/data`到目的地`/data-mount`。
- en: downwardAPI
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: downwardAPI
- en: '`downwardAPI` volume is used to expose Pod information into a container. The
    definition of `downwardAPI` is a list of items. An item contains a path and `fieldRef`.
    Kubernetes will dump the specified metadata listed in `fieldRef` to a file named
    `path` under `mountPath` and mount the `<volume name>` into the destination you
    specified. Currently supported metadata for `downwardAPI` volume includes:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`downwardAPI`卷用于将Pod信息公开到容器中。`downwardAPI`的定义是一个项目列表。一个项目包含一个路径和`fieldRef`。Kubernetes将转储到名为`path`的文件中的指定元数据列在`fieldRef`下，并将`<volume
    name>`挂载到您指定的目的地。目前支持的`downwardAPI`卷的元数据包括：'
- en: '| **Field path** | **Scope** | **Definition** |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| **字段路径** | **范围** | **定义** |'
- en: '| `spec.nodeName` | Pod | The node that the Pod is running on |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `spec.nodeName` | Pod | Pod正在运行的节点 |'
- en: '| `spec.serviceAccountName` | Pod | The service account associating with the
    current Pod |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| `spec.serviceAccountName` | Pod | 与当前Pod关联的服务账户 |'
- en: '| `metadata.name` | Pod | The name of the Pod |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `metadata.name` | Pod | Pod的名称 |'
- en: '| `metadata.namespace` | Pod | The Namespace that the Pod belongs to |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| `metadata.namespace` | Pod | Pod所属的命名空间 |'
- en: '| `metadata.annotations` | Pod | The annotations of the Pod |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| `metadata.annotations` | Pod | Pod的注释 |'
- en: '| `metadata.labels` | Pod | The labels of the Pod |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| `metadata.labels` | Pod | Pod的标签 |'
- en: '| `status.podIP` | Pod | The ip of the Pod |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| `status.podIP` | Pod | Pod的IP |'
- en: '| `limits.cpu` | Container | The CPU limits of the container |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| `limits.cpu` | 容器 | 容器的CPU限制 |'
- en: '| `requests.cpu` | Container | The CPU requests of the container |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| `requests.cpu` | 容器 | 容器的CPU请求 |'
- en: '| `limits.memory` | Container | The memory limits of the container |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| `limits.memory` | 容器 | 容器的内存限制 |'
- en: '| `requests.memory` | Container | The memory requests of the container |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| `requests.memory` | 容器 | 容器的内存请求 |'
- en: '| `limits.ephemeral-storage` | Container | The ephemeral storage limits of
    the container |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| `limits.ephemeral-storage` | 容器 | 容器的临时存储限制 |'
- en: '| `requests.ephemeral-storage` | Container | The ephemeral storage requests
    of the container |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| `requests.ephemeral-storage` | 容器 | 容器的临时存储请求 |'
- en: 'We use `fieldRef.fieldPath` if the scope is with a Pod; `resourceFieldRef`
    is used when the scope is with a container. For example, the following configuration
    file could expose `metadata.labels` in `/data-mount` volume in an Ubuntu container:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果范围是Pod，则使用`fieldRef.fieldPath`；如果范围是容器，则使用`resourceFieldRef`。例如，以下配置文件可以在Ubuntu容器中的`/data-mount`卷中公开`metadata.labels`：
- en: '[PRE78]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'By describing the `pod`, we could check that the volume is mounted successfully
    to `/data-mount`, and `metadata.labels` is pointed to the `metadata` file:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 通过描述`pod`，我们可以检查卷是否成功挂载到`/data-mount`，并且`metadata.labels`指向`metadata`文件：
- en: '[PRE79]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We could check the file inside the container with `kubectl exec downwardapi
    cat /data-mount/metadata`, and you should be able to see `env="example" presents`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`kubectl exec downwardapi cat /data-mount/metadata`来检查容器内的文件，您应该能够看到`env="example"`的存在。
- en: 'If it''s in the container scope, we''ll have to specify the container name:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在容器范围内，我们将不得不指定容器名称：
- en: '[PRE80]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We could use the `docker inspect <container_name>` command inside a node to
    check the implementation:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在节点内部使用`docker inspect <container_name>`命令来检查实现：
- en: '[PRE81]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Kubernetes exposes `pod` information in source volume, and mounts it to `/data-mount`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes在源卷中公开`pod`信息，并将其挂载到`/data-mount`。
- en: 'For the IP of the Pod, using environment variable to propagate in Pod spec
    would be must easier:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Pod的IP，使用环境变量在Pod规范中传播将更容易：
- en: '[PRE82]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The sample folder in the Kubernetes GitHub ([https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information](https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information))
    contains more examples for both environment variables and `downwardAPI` volume.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes GitHub中的示例文件夹（[https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information](https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information)）包含了环境变量和`downwardAPI`卷的更多示例。
- en: gitRepo
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gitRepo
- en: '`gitRepo` is a convenient volume type that clones your existing Git repository
    into a container:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`gitRepo`是一种方便的卷类型，可以将现有的Git存储库克隆到容器中：'
- en: '[PRE83]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In the preceding example, the volume plugin mounts an empty directory and runs
    the git clone `<gitRepo.repolist>` to clone the repository into it. Then the Ubuntu
    container will be able to access it.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，卷插件挂载一个空目录，并运行`git clone `<gitRepo.repolist>`来将存储库克隆到其中。然后Ubuntu容器将能够访问它。
- en: There's more...
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the previous cases, the user needs to know the details of the storage provider.
    Kubernetes provides `PersistentVolumes` and `PersistentVolumeClaim` to abstract
    the details of the storage provider and storage consumer.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的情况下，用户需要了解存储提供程序的详细信息。Kubernetes提供了`PersistentVolumes`和`PersistentVolumeClaim`来抽象存储提供程序和存储消费者的细节。
- en: PersistentVolumes
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久卷
- en: 'An illustration of `PersistentVolume` is shown in the following graph. First,
    the administrator provisions the specification of a `PersistentVolume`. Then the
    consumer requests for storage with `PersistentVolumeClaim`. Finally, the Pod mounts
    the volume with the reference of `PersistentVolumeClaim`:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`PersistentVolume`的示例如下图所示。首先，管理员配置`PersistentVolume`的规范。然后，使用`PersistentVolumeClaim`请求存储。最后，Pod使用`PersistentVolumeClaim`的引用挂载卷：'
- en: '![](assets/f65303f4-59e5-4814-a38b-d6a38bd7977b.png)PersistentVolumeClaims
    is an abstract layer to decouple volumes for a Pod and physical volume resource'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/f65303f4-59e5-4814-a38b-d6a38bd7977b.png)PersistentVolumeClaims是一个抽象层，用于解耦Pod和物理卷资源的卷'
- en: 'Here is an example using `NFS`. The administrator needs to provision and allocate
    `PersistentVolume` first:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`NFS`的示例。管理员需要首先分配和配置`PersistentVolume`：
- en: '[PRE84]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We can see that there are three parameters here: `capacity`, `accessModes`,
    and `persistentVolumeReclaimPolicy`. `capacity` is the size of this `PersistentVolume`.
    Now, `accessModes` is based on the capability of the storage provider and can
    be set to a specific mode during provision. For example, NFS supports multiple
    readers and writers simultaneously—then we can specify the `accessModes` as one
    of `ReadWriteOnce`, `ReadOnlyMany`, or `ReadWriteMany`. Now, `persistentVolumeReclaimPolicy`
    is used to define the behavior when `PersistentVolume` is released. The currently
    supported policy is retain and recycle for `nfs` and `hostPath`. You have to clean
    the volume by yourself in retain mode; on the other hand, Kubernetes will scrub
    the volume in recycle mode.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里有三个参数：`capacity`，`accessModes`和`persistentVolumeReclaimPolicy`。`capacity`是这个`PersistentVolume`的大小。现在，`accessModes`是基于存储提供程序的功能，并且可以在分配期间设置为特定模式。例如，NFS支持同时多个读者和写入者，然后我们可以将`accessModes`指定为`ReadWriteOnce`，`ReadOnlyMany`或`ReadWriteMany`中的一个。现在，`persistentVolumeReclaimPolicy`用于定义`PersistentVolume`释放时的行为。当前支持的策略是`nfs`和`hostPath`的保留和回收。在保留模式下，您必须自己清理卷；另一方面，Kubernetes将在回收模式下清理卷。
- en: 'PV is a resource like a node. We could use `kubectl get pv` to see current
    provisioned PVs:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: PV就像一个节点资源。我们可以使用`kubectl get pv`来查看当前分配的PVs：
- en: '[PRE85]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Next, we will need to bind `PersistentVolume` with `PersistentVolumeClaim`
    in order to mount it as volume into the `pod`:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将`PersistentVolume`与`PersistentVolumeClaim`绑定，以便将其作为卷挂载到`pod`中：
- en: '[PRE86]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The constraints of `accessModes` and storage can be set in `PersistentVolumeClaim`.
    If the claim is bound successfully, its status will turn to `Bound`; on the other
    hand, if the status is `Unbound`, it means there is no PV currently matching the
    requests.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在“PersistentVolumeClaim”中设置“accessModes”和存储的约束。如果声明成功绑定，其状态将变为“Bound”；另一方面，如果状态为“Unbound”，这意味着当前没有与请求匹配的PV。
- en: 'Then we are able to mount the PV as volume with the reference of `PersistentVolumeClaim`:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用“PersistentVolumeClaim”的引用将PV挂载为卷：
- en: '[PRE87]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'It will be similar syntax to other volume types. Just add the `claimName` of
    `persistentVolumeClaim` in the volume definition. We are all set! Let''s check
    the details to see whether we mounted it successfully:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 它将类似于其他卷类型的语法。只需在卷定义中添加“persistentVolumeClaim”的“claimName”。我们已经准备好了！让我们检查细节，看看我们是否成功挂载了它：
- en: '[PRE88]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We can see we have a volume mounted in the Pod `nginx` with the type `pv pvclaim01`.
    Use `docker inspect` to see how it is mounted:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们在Pod“nginx”中挂载了一个卷，类型为“pv pvclaim01”。使用`docker inspect`查看它是如何挂载的：
- en: '[PRE89]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Kubernetes mounts `/var/lib/kubelet/pods/<id>/volumes/kubernetes.io~nfs/< persistentvolume
    name>` into the destination in the Pod.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes将`/var/lib/kubelet/pods/<id>/volumes/kubernetes.io~nfs/< persistentvolume
    name>`挂载到Pod中的目的地。
- en: Using storage classes
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用存储类
- en: 'In the cloud world, people provision storage or data volume dynamically. While
    `PersistentVolumeClaim` is based on existing static `PersistentVolume` that is
    provisioned by administrators, it might be really beneficial if the cloud volume
    could be requested dynamically when it needs to be. Storage classes are designed
    to resolve this problem. To make storage classes available in your cluster, three
    conditions need to be met. First, the `DefaultStorageClass` admission controller
    has to be enabled (refer to [Chapter 7](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Building Kubernetes on GCP*). Then `PersistentVolumeClaim` needs to request a
    storage class. The last condition is trivial; administrators have to configure
    a storage class in order to make dynamic provisioning work:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在云世界中，人们动态配置存储或数据卷。虽然“PersistentVolumeClaim”基于由管理员配置的现有静态“PersistentVolume”，但如果云卷在需要时可以动态请求，这可能会非常有益。存储类旨在解决这个问题。要在集群中使用存储类，需要满足三个条件。首先，必须启用“DefaultStorageClass”准入控制器（参见[第7章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)，*在GCP上构建Kubernetes*）。然后，“PersistentVolumeClaim”需要请求存储类。最后一个条件是微不足道的；管理员必须配置存储类以使动态配置工作：
- en: '![](assets/23a069b1-0d06-4c86-8762-e3fe472a7a87.png)StorageClass dynamically
    allocates a PV and associates it with a PVC'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 存储类动态分配PV并将其与PVC关联
- en: The default storage classes are various, basically based on your underlying
    cloud provider. Storage classes are the abstract way to define underlying storage
    providers. They have different syntax based on different types of providers. Default
    storage classes can be changed, but cannot be deleted. The default storage class
    has an annotation `storageclass.beta.kubernetes.io/is-default-class=true` on.
    Removing that annotation can disable the dynamic provisioning. Moving the annotation
    to another storage class can switch the default storage class. If no storage classes
    have that annotation, dynamic provisioning will not be triggered when there is
    a new `PersistentVolumeClaim`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 默认存储类各种各样，基本上取决于您的基础云提供商。存储类是定义底层存储提供程序的抽象方式。它们根据不同类型的提供程序具有不同的语法。默认存储类可以更改，但不能删除。默认存储类具有注释`storageclass.beta.kubernetes.io/is-default-class=true`。删除该注释可以禁用动态配置。将注释移动到另一个存储类可以切换默认存储类。如果没有存储类具有该注释，当有新的“PersistentVolumeClaim”时，将不会触发动态配置。
- en: gcePersistentDisk
  id: totrans-458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gcePersistentDisk
- en: '`gcePersistentDisk` volume mounts a **Google Compute Engine** (**GCE**) **Persistent
    Disk** (**PD**) into a Pod. If you provision it statically, you''ll have to create
    it first with the `gcloud` command or in the GCE console. The following is an
    example:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcePersistentDisk`卷将**Google计算引擎**（**GCE**）**持久磁盘**（**PD**）挂载到一个Pod中。如果您静态配置它，您将需要首先使用`gcloud`命令或在GCE控制台中创建它。以下是一个示例：'
- en: '[PRE90]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Alternatively, and more cost-effectively, we could use dynamic provisioning.
    Then we don''t need to provision PD beforehand. For enabling dynamic provisioning,
    the `DefaultStorageClass` admission controller has to be enabled on the API server.
    In some Kubernetes environments, it has been enabled by default, such as in GCE.
    We could explicitly disable it by setting the `storageClassName: "" in Pod/Deployment/ReplicaSet`
    configuration file.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '或者，更具成本效益地，我们可以使用动态配置。然后我们就不需要事先配置PD。要启用动态配置，API服务器上必须启用`DefaultStorageClass`准入控制器。在一些Kubernetes环境中，默认情况下已经启用了，比如在GCE中。我们可以通过在Pod/Deployment/ReplicaSet的配置文件中设置`storageClassName:
    ""`来显式禁用它。'
- en: 'Next, we''ll introduce how to create a non-default `StorageClass`:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍如何创建一个非默认的`StorageClass`：
- en: '[PRE91]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We can see we have a default storage class named `standard`. If that''s the
    desired provider, then you don''t need to create your own storage classes. In
    the following example, we''ll create a new storage class named `example`:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们有一个名为`standard`的默认存储类。如果这是所需的提供者，那么您就不需要创建自己的存储类。在下面的示例中，我们将创建一个名为`example`的新存储类：
- en: '[PRE92]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'For the type, you can specify any storage type that GCE supports, such as `pd-ssd`.
    You can specify zones by changing zone parameters, too. Next, we''ll add a `PersistentVolumeClaim`
    for using this storage class:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类型，您可以指定GCE支持的任何存储类型，比如`pd-ssd`。您也可以通过更改区域参数来指定区域。接下来，我们将添加一个`PersistentVolumeClaim`来使用这个存储类：
- en: '[PRE93]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This configuration file will create a PVC by specifying the storage class named
    `example`. A PV will be created by the claim. When a PVC is in `Bound` status,
    Kubernetes will always bind that PV to the matching PVC. Then, let''s have a Pod
    using this PVC:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置文件将通过指定名为`example`的存储类来创建一个PVC。声明将创建一个PV。当PVC处于`Bound`状态时，Kubernetes将始终将PV绑定到匹配的PVC。然后，让我们使用这个PVC来创建一个Pod：
- en: '[PRE94]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We can see that `gce-pd` is mounted under `/mount-path`. Let's see if the volume
    has been provisioned dynamically.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`gce-pd`被挂载在`/mount-path`下。让我们看看这个卷是否已经动态配置。
- en: Alternatively, you could use `gcloud compute disks list. gcloud` in a command-line
    tool in GCE.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在GCE中使用`gcloud compute disks list. gcloud`命令行工具。
- en: awsElasticBlockStore
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: awsElasticBlockStore
- en: '`awsElasticBlockStore` volume mounts an **Amazon Web Service Elastic Block
    Store** (**AWS EBS**) volume. It''s a service that provides persistent block storage
    for Amazon EC2\. Just like the GCE persistent disk, we can provision it statically
    or dynamically.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`awsElasticBlockStore`卷挂载了一个**亚马逊网络服务弹性块存储**（**AWS EBS**）卷。这是为亚马逊EC2提供持久块存储的服务。就像GCE持久磁盘一样，我们可以静态或动态地进行配置。'
- en: 'To provision it statically, administrators have to create an EBS volume by
    the AWS console or AWS CLI beforehand. The following is an example of how to mount
    an existing EBS volume to the containers in a Deployment:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 要静态配置它，管理员必须事先通过AWS控制台或AWS CLI创建一个EBS卷。以下是如何将现有的EBS卷挂载到部署中的容器的示例：
- en: '[PRE95]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'To provision it dynamically, on the other hand, just like how we demonstrated
    in the GCE persistent disk, we first create a non-default storage class; you''re
    free to use a default storage class as well. Here, our environment is provisioned
    by kops ([https://github.com/kubernetes/kops](https://github.com/kubernetes/kops);
    for more information, please refer to [Chapter 6](b7e1d803-52d0-493b-9123-5848da3fa9ec.xhtml),
    *Building Kubernetes on AWS*). The environment has been bound with the required
    IAM policies, such as `ec2:AttachVolume`, `ec2:CreateVolume`, `ec2:DetachVolume`,
    and `ec2:DeleteVolume`. If you provision it from scratch, be sure that you have
    required policies attaching to the masters:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，要动态配置它，就像我们在GCE持久磁盘中演示的那样，我们首先创建一个非默认的存储类；您也可以使用默认的存储类。在这里，我们的环境是由kops（[https://github.com/kubernetes/kops](https://github.com/kubernetes/kops)；有关更多信息，请参阅[第6章](b7e1d803-52d0-493b-9123-5848da3fa9ec.xhtml)，*在AWS上构建Kubernetes*）。该环境已绑定所需的IAM策略，如`ec2:AttachVolume`、`ec2:CreateVolume`、`ec2:DetachVolume`和`ec2:DeleteVolume`。如果您从头开始配置它，请确保您有所需的策略附加到主节点：
- en: '[PRE96]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Next, we create a PVC with the storage class name we just created:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用刚刚创建的存储类名称创建一个PVC：
- en: '[PRE97]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'When Kubernetes receives the request of `PersistentVolumeClaim`, it''ll try
    to allocate a new `PersistentVolume`, or bind to an existing PV, if possible:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 当Kubernetes接收到“PersistentVolumeClaim”的请求时，它将尝试分配一个新的“PersistentVolume”，或者如果可能的话，绑定到现有的PV：
- en: '[PRE98]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We can check the corresponding PV in the AWS console, as well.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在AWS控制台中检查相应的PV。
- en: 'At the end, we create a Deployment with this volume by specifying `persistentVolumeClaim`
    in the spec:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过在规范中指定`persistentVolumeClaim`来创建一个带有这个卷的部署：
- en: '[PRE99]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'By specifying `claimName` as `aws-example`, it''ll then use the EBS volume
    we just create by PVC, which is requested to AWS dynamically. If we take a look
    at the Pod description with `kubectl describe pod <pod_name>`, we can see the
    details of the volumes:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`claimName`指定为`aws-example`，然后它将使用我们刚刚通过PVC创建的EBS卷，该卷是动态请求到AWS的。如果我们使用`kubectl
    describe pod <pod_name>`查看Pod描述，我们可以看到卷的详细信息：
- en: '[PRE100]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: EBS volume `vol-0fccc3b0af8c17727` is mounted under `/mount-path` inside the
    container.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: EBS卷`vol-0fccc3b0af8c17727`被挂载在容器内的`/mount-path`下。
- en: If the volume was dynamically provisioned, the default reclaim policy is set
    to `delete`. Set it to `retain` if you want to keep them, even if a PVC is deleted.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 如果卷是动态配置的，默认的回收策略设置为`delete`。如果要保留它们，即使PVC被删除，将其设置为`retain`。
- en: '**The StorageObjectInUseProtection admission controller**'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '**StorageObjectInUseProtection准入控制器**'
- en: A PVC might be deleted accidentally by user even if it's used by a Pod. In Kubernetes
    v1.10, a new admission controller is added to prevent this from happening.` kubernetes.io/pv-protection`
    or `kubernetes.io/pvc-protection` finalizer will be added into PV or PVC by `StorageObjectInUseProtection`
    admission controller. Then when object deletion request is sent, admission controller
    will do pre-delete check and see if there is any Pod are using it. This will prevent
    data loss.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 即使PVC被Pod使用，也可能会被用户意外删除。在Kubernetes v1.10中，添加了一个新的准入控制器来防止这种情况发生。`kubernetes.io/pv-protection`或`kubernetes.io/pvc-protection`终结器将被`StorageObjectInUseProtection`准入控制器添加到PV或PVC中。然后，当对象删除请求被发送时，准入控制器将进行预删除检查，并查看是否有任何Pod正在使用它。这将防止数据丢失。
- en: See also
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Volumes can be mounted on the Pods by declaring in Pods or ReplicaSet spec.
    Check out the following recipes to jog your memory:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Pods或ReplicaSet规范中声明，可以挂载卷。查看以下配方以唤起您的记忆：
- en: '*Working with Pods* section in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking
    through Kubernetes Concepts*'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)的*Pods工作*部分，*走进Kubernetes概念*'
- en: '*Working with replica sets* section in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking
    through Kubernetes Concepts*'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《走进Kubernetes概念》的[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中的*使用副本集*部分
- en: '*Working with Secrets* section in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking
    through Kubernetes Concepts*'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《走进Kubernetes概念》的[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中的*使用Secrets*部分
- en: '*Setting resource in nodes* section in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml), *Advanced
    Cluster Administration*'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《高级集群管理》的[第8章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)中的*在节点中设置资源*部分
- en: '*Authentication and authorization* section in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml), *Advanced
    Cluster Administration*'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《高级集群管理》的[第8章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)中的*身份验证和授权*部分
- en: Working with Secrets
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Secrets
- en: Kubernetes Secrets manage information in key-value formats with the value encoded.
    It can be a password, access key, or token. With Secrets, users don't have to
    expose sensitive data in the configuration file. Secrets can reduce the risk of
    credential leaks and make our resource configurations more organized.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Secrets以键值格式管理编码后的信息。它可以是密码、访问密钥或令牌。使用Secrets，用户不必在配置文件中暴露敏感数据。Secrets可以减少凭据泄露的风险，并使我们的资源配置更有条理。
- en: 'Currently, there are three types of Secrets:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，有三种类型的Secrets：
- en: 'Generic/Opaque: [https://en.wikipedia.org/wiki/Opaque_data_type](https://en.wikipedia.org/wiki/Opaque_data_type)'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Generic/Opaque: [https://en.wikipedia.org/wiki/Opaque_data_type](https://en.wikipedia.org/wiki/Opaque_data_type)'
- en: Docker registry
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker注册表
- en: TLS
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLS
- en: Generic/Opaque is the default type that we're using in our application. Docker
    registry is used to store the credential of a private Docker registry. TLS Secret
    is used to store the CA certificate bundle for cluster administration.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: Generic/Opaque是我们应用程序中使用的默认类型。Docker注册表用于存储私有Docker注册表的凭据。TLS Secret用于存储用于集群管理的CA证书包。
- en: Kubernetes creates built-in Secrets for the credentials that using to access
    API server.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes为访问API服务器的凭据创建了内置的Secrets。
- en: Getting ready
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before using Secrets, we have to keep in mind that Secret should be always created
    before dependent Pods, so dependent Pods can reference it properly. In addition,
    Secrets have a 1 MB size limitation. It works properly for defining a bunch of
    information in a single Secret. However, Secret is not designed for storing large
    amounts of data. For configuration data, consider using `ConfigMaps`. For large
    amounts of non-sensitive data, consider using volumes instead.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Secrets之前，我们必须记住，Secret应该在依赖的Pods之前创建，这样依赖的Pods才能正确引用它。此外，Secrets有1MB的大小限制。这对于在单个Secret中定义一堆信息是有效的。但是，Secret并不适用于存储大量数据。对于配置数据，请考虑使用`ConfigMaps`。对于大量的非敏感数据，请考虑使用卷代替。
- en: How to do it...
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the following example, we'll walk through how to create a Generic/Opaque
    Secret and use it in your Pods by assuming that we have an access token that needs
    to be used inside a Pod.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将演示如何创建一个Generic/Opaque Secret，并在Pod中使用它，假设我们有一个访问令牌需要在Pod内使用。
- en: Creating a Secret
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Secret
- en: There are two ways to create a Secret. The first one is with `kubectl create
    secret` in the command line, and the other one is with direct resource creation
    in the configuration file.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Secret有两种方法。第一种是在命令行中使用`kubectl create secret`，另一种是在配置文件中直接创建资源。
- en: Working with kubectl create command line
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用kubectl create命令行
- en: 'By using `kubectl create secret` command line, you can create a Secret from
    a file, directory, or literal value. With this method, you don''t need to encode
    the Secret by yourself. Kubernetes will do that for you:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`kubectl create secret`命令行，您可以从文件、目录或文字值创建一个Secret。使用这种方法，您不需要自己对Secret进行编码。Kubernetes会为您完成这项工作：
- en: From a file
  id: totrans-514
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件
- en: 'If a file is the source of Secret, we''ll have to create a text file which
    contains our sensitive data first:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件是Secret的来源，我们首先必须创建一个包含我们敏感数据的文本文件：
- en: '[PRE101]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Next, we could use `kubectl create secret` in the command line to create the
    Secret. The syntax is:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用命令行中的`kubectl create secret`来创建Secret。语法是：
- en: '[PRE102]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'In our case, we use generic Secret type, since the access token is neither
    the Docker registry image pull Secrets nor TLS information:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们使用通用的Secret类型，因为访问令牌既不是Docker注册表镜像拉取Secrets也不是TLS信息：
- en: '[PRE103]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'You can check the detailed Secret information with the `kubectl get secret`
    command:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`kubectl get secret`命令检查详细的Secret信息：
- en: '[PRE104]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'You can use the `base64` command ([https://linux.die.net/man/1/base64](https://linux.die.net/man/1/base64))
    in Linux to decode the encoded Secret:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用Linux中的`base64`命令（[https://linux.die.net/man/1/base64](https://linux.die.net/man/1/base64)）来解码编码的Secret：
- en: '[PRE105]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: From a directory
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从目录
- en: 'Creating a Secret from a directory is similar to creating from a file, using
    the same command, but with `directory`. Kubernetes will iterate all the files
    inside that directory and create a Secret for you:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 从目录创建Secret与从文件创建类似，使用相同的命令，但使用`directory`。Kubernetes将迭代该目录中的所有文件，并为您创建一个Secret：
- en: '[PRE106]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: You can check the Secret with the `kubectl get secret access-token -o yaml`
    command again and see if they're identical to the ones from the file.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以再次使用`kubectl get secret access-token -o yaml`命令检查Secret，并查看它们是否与文件中的相同。
- en: From a literal value
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文字值
- en: 'Kubernetes supports creating a Secret with a single command line, as well:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes支持使用单个命令行创建一个Secret，如下所示：
- en: '[PRE107]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Then we can use the `get secret` command to check if they''re identical to
    the previous method:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用`get secret`命令来检查它们是否与以前的方法相同：
- en: '[PRE108]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Via configuration file
  id: totrans-534
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过配置文件
- en: 'A Secret can also be created directly through the configuration file; however,
    you''ll have to encode the Secret manually. Just use the kind of Secret:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: Secret也可以直接通过配置文件创建；但是，您必须手动编码Secret。只需使用Secret的种类：
- en: '[PRE109]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Using Secrets in Pods
  id: totrans-537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Pod中使用Secrets
- en: To use Secrets inside Pods, we can choose to expose them in environment variables
    or mount the Secrets as volumes.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Pod内部使用Secrets，我们可以选择将它们暴露为环境变量或将Secrets挂载为卷。
- en: By environment variables
  id: totrans-539
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过环境变量
- en: 'In terms of accessing Secrets inside a Pod, add `env section` inside the container
    spec as follows:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pod内部访问Secret方面，需要在容器规范中添加`env`部分，如下所示：
- en: '[PRE110]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'In the preceding example, we expose `2-7-1_access-token` key in access-token
    Secret as `ACCESS_TOKEN` environment variable, and print it out through a while
    infinite loop. Check the `stdout via kubectl` log command:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将`2-7-1_access-token`密钥暴露为`ACCESS_TOKEN`环境变量，通过一个无限循环打印出来。通过`kubectl`日志命令检查`stdout`：
- en: '[PRE111]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Note that the environment variable was exposed during Pod creation. If a new
    value of Secret is pushed, you'll have to re-launch/rolling-update a Pod or Deployment
    to reflect that.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Pod创建期间暴露了环境变量。如果推送了新的Secret值，您将不得不重新启动/滚动更新Pod或Deployment以反映这一点。
- en: 'If we describe the `secret-example-env` Pod, we can see that an environment
    variable was set to a Secret:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们描述`secret-example-env` Pod，我们可以看到一个环境变量被设置为一个Secret：
- en: '[PRE112]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: By volumes
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过卷
- en: 'A Secret can be also mounted as volume by using the Secret type of the volume.
    The following is an example of how to use it:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过使用卷的Secret类型将Secret挂载为卷。以下是如何使用它的示例：
- en: '[PRE113]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The preceding example will mount `secret-volume` into the `/secret mount` point
    inside the Pod. `/secret` will contain a file with the name token, which contains
    our access token. If we check the Pod details, it''ll show that we mounted a read-only
    Secret volume:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子将`secret-volume`挂载到Pod内部的`/secret`挂载点。`/secret`将包含一个名为token的文件，其中包含我们的访问令牌。如果我们检查Pod的详细信息，它将显示我们挂载了一个只读的Secret卷：
- en: '[PRE114]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'If we check the `stdout`, it''ll show the Pod can properly retrieve the expected
    value:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查`stdout`，它将显示Pod可以正确检索预期的值：
- en: '[PRE115]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The same as with the environment variable, the files in the mounted volume are
    created upon Pod creation time. It won't change dynamically when the Secret value
    is updated after the Pod creation time.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 与环境变量一样，挂载卷中的文件是在Pod创建时创建的。当Pod创建后更新Secret值时，它不会动态更改。
- en: Deleting a Secret
  id: totrans-555
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除秘密
- en: 'To delete a Secret, simply use the `kubectl delete secret` command:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 删除秘密，只需使用`kubectl delete secret`命令：
- en: '[PRE116]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'If a Secret is deleted when a Secret volume is attached, it''ll show an error
    message whenever the volume reference disappears:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在附加了Secret卷的情况下删除了Secret，每当卷引用消失时都会显示错误消息：
- en: '[PRE117]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: How it works...
  id: totrans-560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to reduce the risk of leaking the Secrets' content, Secret is not landed
    to the disk. Instead, kubelet creates a `tmpfs` filesystem on the node to store
    the Secret. The Kubernetes API server pushes the Secret to the node on which the
    demanded container is running. The data will be flashed when the container is
    destroyed.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少泄露Secrets内容的风险，Secret不会落地到磁盘上。相反，kubelet在节点上创建一个`tmpfs`文件系统来存储Secret。Kubernetes
    API服务器将Secret推送到要求容器正在运行的节点上。当容器被销毁时，数据将被擦除。
- en: There's more...
  id: totrans-562
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Secrets hold small amounts of sensitive data. For application configuration,
    consider using `ConfigMaps` to hold non-sensitive information.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets保存少量敏感数据。对于应用程序配置，请考虑使用`ConfigMaps`保存非敏感信息。
- en: Using ConfigMaps
  id: totrans-564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ConfigMaps
- en: 'Here is an example of using `ConfigMaps`:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`ConfigMaps`的示例：
- en: '[PRE118]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Similar to Secret, `ConfigMaps` can be retrieved with environment variables
    or volumes:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 与Secret类似，`ConfigMaps`可以通过环境变量或卷检索：
- en: '[PRE119]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Alternatively, you can use `ConfigMaps` volume to retrieve the configuration
    information:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`ConfigMaps`卷来检索配置信息：
- en: '[PRE120]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Mounting Secrets and ConfigMap in the same volume
  id: totrans-571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在同一卷中挂载Secrets和ConfigMap
- en: Projected volume is a way to group multiple volume sources into the same mount
    point. Currently, it supports Secrets, `ConfigMap`, and `downwardAPI`.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 投影卷是将多个卷源组合到同一挂载点的一种方式。目前，它支持Secrets、`ConfigMap`和`downwardAPI`。
- en: 'The following is an example of how we group the examples of Secrets and `ConfigMaps` that
    we used in this chapter:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在本章中使用的Secrets和`ConfigMaps`示例的分组示例：
- en: '[PRE121]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Let''s check `stdout` to see if it works properly:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`stdout`，看看它是否正常工作：
- en: '[PRE122]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: See also
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Working with Volumes* section in [*Chapter 2*](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)*, Walking
    through Kubernetes Concepts*'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第2章*](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)*中的*Working with Volumes*部分，*Walking
    through Kubernetes Concepts*'
- en: The *Working with configuration files * section in *[Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    Playing with Containers*
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)*中的*使用配置文件*部分，*与容器一起玩*'
- en: '*The Moving monolithic to microservices* and *Working with the private Docker
    registry * sections in *[Chapter 5](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml),
    Building Continuous Delivery Pipeline*'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*[第5章](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml)*中的*将单片式转换为微服务*和*使用私有Docker注册表*部分，*构建持续交付管道*'
- en: The *Advanced settings in kubeconfig * section in *[Chapter 7](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    Building Kubernetes on GCP*
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*[第7章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)*中的*kubeconfig中的高级设置*部分，*在GCP上构建Kubernetes*'
- en: Working with names
  id: totrans-582
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用名称
- en: When you create any Kubernetes object, such as a Pod, Deployment, and Service,
    you can assign a name to it. The names in Kubernetes are spatially unique, which
    means you cannot assign the same name in the Pods.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建任何Kubernetes对象，如Pod、Deployment和Service时，可以为其分配一个名称。Kubernetes中的名称在空间上是唯一的，这意味着您不能在Pod中分配相同的名称。
- en: Getting ready
  id: totrans-584
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Kubernetes allows us to assign a name with the following restrictions:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes允许我们分配以下限制的名称：
- en: Up to 253 characters
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最多253个字符
- en: Lowercase of alphabet and numeric characters
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小写字母和数字字符
- en: May contain special characters in the middle, but only dashs (-) and dots (.)
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能包含特殊字符，但只能是破折号（-）和点（.）。
- en: How to do it...
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For assigning a name to the Pod, follow the following steps:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 为Pod分配名称，请按照以下步骤操作：
- en: 'The following example is the Pod YAML configuration that assigns the Pod name
    as `my-pod` to the container name as `my-container`; you can successfully create
    it as follows:'
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例是Pod YAML配置，将Pod名称分配为`my-pod`，将容器名称分配为`my-container`；您可以成功创建它如下：
- en: '[PRE123]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'You can use the `kubectl describe` command to see the container named `my-container`
    as follows:'
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`kubectl describe`命令查看名为`my-container`的容器，如下所示：
- en: '[PRE124]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'On the other hand, the following example contains two containers, but assigns
    the same name, `my-container`; therefore, the `kubectl create` command returns
    an error and can''t create the Pod:'
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，以下示例包含两个容器，但分配相同的名称`my-container`；因此，`kubectl create`命令返回错误，无法创建Pod：
- en: '[PRE125]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: You can add the `--validate` flag. For example, the command `kubectl create
    -f duplicate.yaml --validate` uses a schema to validate the input before sending
    it.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加`--validate`标志。例如，命令`kubectl create -f duplicate.yaml --validate`在发送之前使用模式验证输入。
- en: 'In another example, the YAML contains a ReplicationController and Service,
    both of which are using the same name, `my-nginx`, but it is successfully created
    because the Deployment and Service are different objects:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个示例中，YAML包含一个ReplicationController和一个Service，两者都使用相同的名称`my-nginx`，但它成功创建，因为Deployment和Service是不同的对象：
- en: '[PRE126]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: How it works...
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A name is just a unique identifier, and all naming conventions are good; however,
    it is recommended to look up and identify the container image. For example:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 名称只是一个唯一标识符，所有命名约定都是好的；但是，建议查找和识别容器映像。例如：
- en: '`memcached-pod1`'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memcached-pod1`'
- en: '`haproxy.us-west`'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`haproxy.us-west`'
- en: '`my-project1.mysql`'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my-project1.mysql`'
- en: 'On the other hand, the following examples do not work because of Kubernetes
    restrictions:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下示例由于Kubernetes的限制而无法工作：
- en: '`Memcache-pod1` (contains uppercase)'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Memcache-pod1`（包含大写）'
- en: '`haproxy.us_west` (contains underscore)'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`haproxy.us_west`（包含下划线）'
- en: '`my-project1.mysql.` (dot in the last)'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my-project1.mysql.`（最后一个点）'
- en: 'Note that Kubernetes supports a label that allows assigning a `key=value` style
    identifier. It also allows duplication. Therefore, if you want to assign something
    like the following information, use a label instead:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Kubernetes支持一个标签，允许分配`key=value`样式的标识符。它还允许重复。因此，如果您想分配类似以下信息的内容，请改用标签：
- en: 'Environment (for example: staging, production)'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境（例如：暂存，生产）
- en: 'Version (for example: v1.2)'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本（例如：v1.2）
- en: 'Application role (for example: frontend, worker)'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序角色（例如：前端，工作人员）
- en: 'In addition, Kubernetes also supports names that have different Namespaces.
    This means that you can use the same name in different Namespaces (for example:
    `nginx`). Therefore, if you want to assign just an application name, use Namespaces
    instead.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Kubernetes还支持具有不同命名空间的名称。这意味着您可以在不同的命名空间中使用相同的名称（例如：`nginx`）。因此，如果您只想分配一个应用程序名称，请改用命名空间。
- en: See also
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'This section from the chapter described how to assign and find the name of
    objects. This is just a basic methodology, but Kubernetes has more powerful naming
    tools, such as Namespace and selectors, to manage clusters:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节描述了如何分配和查找对象的名称。这只是一种基本方法，但Kubernetes还有更强大的命名工具，如命名空间和选择器，用于管理集群：
- en: '*Working with Pods*'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与Pod一起工作*'
- en: '*Deployment API*'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署API*'
- en: '*Working with Services*'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与服务一起工作*'
- en: '*Working with Namespaces*'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与命名空间一起工作*'
- en: '*Working with labels and selectors*'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用标签和选择器*'
- en: Working with Namespaces
  id: totrans-621
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命名空间
- en: In a Kubernetes cluster, the name of a resource is a unique identifier within
    a Namespace. Using a Kubernetes Namespace could separate user spaces for different
    environments in the same cluster. It gives you the flexibility of creating an
    isolated environment and partitioning resources to different projects and teams.
    You may consider Namespace as a virtual cluster. Pods, Services, and Deployments
    are contained in a certain Namespace. Some low-level resources, such as nodes
    and `persistentVolumes`, do not belong to any Namespace.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes集群中，资源的名称是命名空间内的唯一标识符。使用Kubernetes命名空间可以将同一集群中的不同环境的用户空间分开。它使您能够创建一个隔离的环境，并将资源分区到不同的项目和团队。您可以将命名空间视为虚拟集群。Pod、服务和部署都包含在某个命名空间中。一些低级资源，如节点和`persistentVolumes`，不属于任何命名空间。
- en: 'Before we dig into the resource Namespace, let''s understand `kubeconfig` and
    some keywords first:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入资源命名空间之前，让我们先了解`kubeconfig`和一些关键词：
- en: '![](assets/b1dc5384-97c8-4a7b-af9b-ddbdc62e60c0.png)The relationship of kubeconfig
    components'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/b1dc5384-97c8-4a7b-af9b-ddbdc62e60c0.png)kubeconfig组件的关系'
- en: '`kubeconfig` is used to call the file which configures the access permission
    of Kubernetes clusters. As the original configuration of the system, Kubernetes
    takes `$HOME/.kube/config` as a `kubeconfig` file. Some concepts that are illustrated
    by the preceding diagram are as follows:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubeconfig`用于调用配置Kubernetes集群访问权限的文件。作为系统的原始配置，Kubernetes将`$HOME/.kube/config`作为`kubeconfig`文件。前面图表所说明的一些概念如下：'
- en: '**kubeconfig defines user, cluster, and context**: `kubeconfig` lists multiple
    users for defining authentication, and multiple clusters for indicating the Kubernetes
    API server. Also, the context in `kubeconfig` is the combination of a user and
    a cluster: accessing a certain Kubernetes cluster with what kind of authentication.'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubeconfig定义用户、集群和上下文**：`kubeconfig`列出了多个用户来定义身份验证，以及多个集群来指示Kubernetes API服务器。此外，`kubeconfig`中的上下文是用户和集群的组合：使用何种身份验证访问特定的Kubernetes集群。'
- en: '**Users and clusters are sharable between contexts**: In the previous diagram,
    both **Context 1** and **Context 3** take **User** **1** as their user content.
    However, each context can only have a single user and single cluster definition.'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户和集群在上下文之间是可共享的**：在前面的图表中，**上下文1**和**上下文3**都将**用户1**作为其用户内容。然而，每个上下文只能有一个用户和一个集群定义。'
- en: '**Namespace can be attached to context**: Every context can be assigned to
    an existing Namespace. If there are none, like **Context 3**, it is along with
    the default Namespace, named `default`, as well.'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间可以附加到上下文**：每个上下文都可以分配给一个现有的命名空间。如果没有，比如**上下文3**，它将与默认命名空间`default`一起。'
- en: '**The current context is the default environment for client**: We may have
    several contexts in `kubeconfig`, but only one for the current context. The current
    context and the Namespace attached on it will construct the default computing
    environment for users.'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前上下文是客户端的默认环境：我们可能在`kubeconfig`中有几个上下文，但当前上下文只有一个。当前上下文和附加在其上的命名空间将构建用户的默认计算环境。
- en: Now you will get the idea that, as Namespace works with `kubeconfig`, users
    can easily switch default resources for usage by switching the current context
    in `kubeconfig`. Nevertheless, users can still start any resource in a different
    Namespace with a specified one. In this recipe, you will learn how to create your
    own Namespace and how to work with it.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您会明白，由于命名空间与`kubeconfig`一起工作，用户可以通过切换`kubeconfig`中的当前上下文轻松切换默认资源以供使用。然而，用户仍然可以在指定的命名空间中启动任何资源。在本教程中，您将学习如何创建自己的命名空间以及如何使用它。
- en: Getting ready
  id: totrans-631
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'By default, Kubernetes has created a Namespace named `default`. All the objects
    created without specifying Namespaces will be put into the `default` Namespace.
    Kubernetes will also create another initial Namespace called `kube-system` for
    locating Kubernetes system objects, such as an add-on or overlay network. Try
    to list all the Namespaces:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes已经创建了一个名为`default`的命名空间。所有创建的对象，如果没有指定命名空间，将被放入`default`命名空间。Kubernetes还将创建另一个名为`kube-system`的初始命名空间，用于定位Kubernetes系统对象，例如插件或叠加网络。尝试列出所有命名空间：
- en: '[PRE127]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: You may find an additional Namespace, `kube-public`, listed at the initial stage.
    It is designed for presenting some public configurations for even users without
    permission to access the Kubernetes system. Both of the provisioning tools, minikube
    and kubeadm, will create it while booting the system up.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会在初始阶段找到一个额外的命名空间`kube-public`。它旨在为即使没有权限访问Kubernetes系统的用户呈现一些公共配置。在启动系统时，`minikube`和`kubeadm`都会创建它。
- en: 'The name of a Namespace must be a DNS label and follow the following rules:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间的名称必须是DNS标签，并遵循以下规则：
- en: At most, 63 characters
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最多63个字符
- en: Matching regex [a-z0-9]([-a-z0-9]*[a-z0-9])
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配正则表达式[a-z0-9]([-a-z0-9]*[a-z0-9])
- en: How to do it...
  id: totrans-638
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will demonstrate how to create a Namespace, change the default
    Namespace, and delete the Namespace.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示如何创建命名空间，更改默认命名空间和删除命名空间。
- en: Creating a Namespace
  id: totrans-640
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建命名空间
- en: 'For creating a Namespace, following are the steps:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个命名空间，请按照以下步骤：
- en: 'After deciding on our desired name for Namespace, let''s create it with a configuration
    file:'
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确定我们想要的命名空间名称后，让我们使用配置文件创建它：
- en: '[PRE128]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'You can now see that we have an additional namespace called `my-namespace`.
    Next, let''s run a Kubernetes Deployment in this new Namespace:'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以看到我们有一个名为`my-namespace`的额外命名空间。接下来，让我们在这个新的命名空间中运行一个Kubernetes部署：
- en: '[PRE129]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'While trying to check the newly created resource, we cannot easily find them
    as usual:'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在尝试检查新创建的资源时，我们无法像通常那样轻松找到它们：
- en: '[PRE130]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Instead, the Deployment is shown with a flag related to the Namespace:'
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相反，部署显示了与命名空间相关的标志：
- en: '[PRE131]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Now you can find the resource that was just created.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以找到刚刚创建的资源。
- en: Changing the default Namespace
  id: totrans-651
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改默认命名空间
- en: 'As in the previous introduction, we can change the default Namespace by switching
    the current context in `kubeconfig` to another one:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以通过将`kubeconfig`中的当前上下文切换到另一个上下文来更改默认命名空间：
- en: 'First, we may check the current context with the subcommand `config`:'
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以使用子命令`config`检查当前上下文：
- en: '[PRE132]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: You may feel unfamiliar with the output when checking the current context. The
    value of the preceding current context is defined and created by `kubeadm`. You
    could get `minikube` shown on screen if you leveraged `minikube` as your Kubernetes
    system management tool.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查当前上下文时，您可能会对输出感到陌生。上一个当前上下文的值是由`kubeadm`定义和创建的。如果您使用`minikube`作为Kubernetes系统管理工具，您可能会在屏幕上看到`minikube`。
- en: 'No matter what you got from checking the current context in `kubeconfig`, use
    the subcommand `config set-context` to create a new context:'
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论您从`kubeconfig`中检查当前上下文得到什么，都可以使用子命令`config set-context`来创建一个新的上下文：
- en: '[PRE133]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The preceding command is based on `kubeadm` managed Kubernetes; you may fire
    a similar one for `minikube`, with the names of the default cluster and user in
    `kubeconfig`:'
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述命令是基于`kubeadm`管理的Kubernetes；您可以为`minikube`发出类似的命令，其中包括`kubeconfig`中默认集群和用户的名称：
- en: '[PRE134]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Next, check `kubeconfig` to verify the changes:'
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，检查`kubeconfig`以验证更改：
- en: '[PRE135]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: When checking the configuration of `kubeconfig`, in the section of contexts,
    you can find a context named exactly as what we defined and which also takes our
    newly created Namespace.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查`kubeconfig`配置时，在上下文部分，您可以找到一个与我们定义的完全相同的上下文，并且还将我们新创建的命名空间。
- en: 'Fire the following command to switch to using the new context:'
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令以切换到使用新的上下文：
- en: '[PRE136]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Now the current context is our customized one, which is along with the Namespace
    `my-namespace`.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当前的上下文是我们定制的一个，它与命名空间`my-namespace`一起。
- en: 'Since the default Namespace is changed to `my-namespace`, it is possible that
    we can get the Deployment without specifying the Namespace:'
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于默认的命名空间已更改为`my-namespace`，因此我们可以在不指定命名空间的情况下获取部署：
- en: '[PRE137]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Deleting a Namespace
  id: totrans-668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除一个命名空间
- en: 'If you followed the previous pages for the Kubernetes resource, you may have
    gotten the idea that the subcommand `delete` is used to remove resources. It is
    workable in the case of removing a Namespace. At the same time, if we try to delete
    a Namespace, the resources under it will be removed, as well:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照之前的页面了解Kubernetes资源，您可能已经知道子命令`delete`用于删除资源。在删除命名空间的情况下是可行的。同时，如果我们尝试删除一个命名空间，其中的资源也将被删除：
- en: '[PRE138]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'To solve this issue, you may attach another Namespace to the current context,
    or just change your current context to the previous one:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，您可以将另一个命名空间附加到当前上下文，或者只是将当前上下文更改为以前的上下文：
- en: '[PRE139]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: How it works…
  id: totrans-673
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Although we discussed the Namespaces and context of `kubeconfig` together, they
    are independent objects in the Kubernetes system. The context of `kubeconfig`
    is a client concept which can only be controlled by certain users, and it makes
    it easier to work with Namespaces and clusters. On the other hand, Namespace is
    the concept of the server side, working for resource isolation in clusters, and
    it is able to be shared between clients.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们讨论了`kubeconfig`的命名空间和上下文，但它们是Kubernetes系统中独立的对象。`kubeconfig`的上下文是一个客户端概念，只能由特定用户控制，并且可以更轻松地与命名空间和集群一起工作。另一方面，命名空间是服务器端的概念，在集群中用于资源隔离，并且可以在客户端之间共享。
- en: There's more...
  id: totrans-675
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We not only leverage Namespace to separate our resources, but also to realize
    finer computing resource provisioning. By restricting the usage amount of the
    computing power of a Namespace, the system manager can avoid the client creating
    too many resources and making servers overload.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅利用命名空间来分隔我们的资源，还可以实现更精细的计算资源配置。通过限制命名空间的计算能力的使用量，系统管理员可以避免客户端创建过多资源并使服务器超载。
- en: Creating a LimitRange
  id: totrans-677
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个LimitRange
- en: To set the resource limitation of each Namespace, the admission controller `LimitRanger`
    should be added in the Kubernetes API server. Do not worry about this setting
    if you have `minikube` or `kubeadm` as your system manager.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置每个命名空间的资源限制，应该在Kubernetes API服务器中添加准入控制器`LimitRanger`。如果您的系统管理者是`minikube`或`kubeadm`，则无需担心此设置。
- en: '**The admission controller in the Kubernetes API server** Admission controller
    is a setting in the Kubernetes API server which defines more advanced functionality
    in the API server. There are several functions that can be set in the admission
    controller. Users can add the functions when starting the API server through the
    configuration file or using CLI with the flag `--admission-control`. Relying on
    `minikube` or `kubeadm` for system management, they have their own initial settings
    in the admission controller:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes API服务器中的准入控制器** 准入控制器是Kubernetes API服务器中的一个设置，它定义了API服务器中的更高级功能。准入控制器中可以设置几个功能。用户可以在启动API服务器时通过配置文件或使用CLI和标志`--admission-control`添加这些功能。依赖于`minikube`或`kubeadm`进行系统管理，它们在准入控制器中有自己的初始设置：'
- en: '**Default admission controller in** **kubeadm**: `Initializers`, `NamespaceLifecycle`,
    `LimitRanger`, `ServiceAccount`, `PersistentVolumeLabel`, `DefaultStorageClass`,
    `DefaultTolerationSeconds`, `NodeRestriction`, `ResourceQuota`'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubeadm中的默认准入控制器**：`Initializers`，`NamespaceLifecycle`，`LimitRanger`，`ServiceAccount`，`PersistentVolumeLabel`，`DefaultStorageClass`，`DefaultTolerationSeconds`，`NodeRestriction`，`ResourceQuota`'
- en: '**Default admission controller in minikube**: `NamespaceLifecycle`, `LimitRanger`,
    `ServiceAccount`, `DefaultStorageClass, ResourceQuota`'
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: minikube中的默认准入控制器：`NamespaceLifecycle`，`LimitRanger`，`ServiceAccount`，`DefaultStorageClass`，`ResourceQuota`
- en: Based on the version of your API server, there is a recommended list in an official
    document at [https://kubernetes.io/docs/admin/admission-controllers/#is-there-a-recommended-set-of-admission-controllers-to-use](https://kubernetes.io/docs/admin/admission-controllers/#is-there-a-recommended-set-of-admission-controllers-to-use).
    Check for more ideas!
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的API服务器版本，在官方文档[https://kubernetes.io/docs/admin/admission-controllers/#is-there-a-recommended-set-of-admission-controllers-to-use](https://kubernetes.io/docs/admin/admission-controllers/#is-there-a-recommended-set-of-admission-controllers-to-use)中有一个推荐的列表。查看更多想法！
- en: 'A plain new Namespace has no limitation on the resource quota. At the beginning,
    we start a Namespace and take a look at its initial settings:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 一个普通的新Namespace在资源配额上没有限制。一开始，我们创建一个Namespace并查看其初始设置：
- en: '[PRE140]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'After that, we create a resource called `LimitRange` for specifying the resource
    limitation of a Namespace. The following is a good example of creating a limit
    in a Namespace:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建一个名为`LimitRange`的资源，用于指定Namespace的资源限制。以下是创建Namespace限制的一个很好的例子：
- en: '[PRE141]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: We will then limit the resources in a Pod with the values of `2` as `max` and
    `200m` as a `min` for CPU, and `1Gi` as max and `6Mi` as a min for memory. For
    the container, the CPU is limited between `100m - 2` and the memory is between
    `3Mi` - `1Gi`. If the max is set, then you have to specify the limit in the Pod/container
    spec during the resource creation; if the min is set, then the request has to
    be specified during the Pod/container creation. The `default` and `defaultRequest`
    section in LimitRange is used to specify the default limit and request in the
    container spec.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用`2`作为CPU的`max`值，`200m`作为`min`值来限制Pod中的资源，并且使用`1Gi`作为内存的最大值，`6Mi`作为最小值。对于容器，CPU限制在`100m
    - 2`之间，内存在`3Mi` - `1Gi`之间。如果设置了最大值，则必须在资源创建时在Pod/container规范中指定限制；如果设置了最小值，则必须在Pod/container创建时指定请求。`LimitRange`中的`default`和`defaultRequest`部分用于指定容器规范中的默认限制和请求。
- en: '**The value of CPU limitation in LimitRange** What do the values of `2` and
    `200m` mean in the Pod limitation in the file `my-first-limitrange.yaml`? The
    integer value means the number of CPU; the "m" in the value means millicpu, so
    `200m` means 0.2 CPU (200 * 0.001). Similarly, the default CPU limitation of the
    container is 0.2 to 0.3, and the real limitation is 0.1 to 2.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件`my-first-limitrange.yaml`中，`LimitRange`中的CPU限制的值是什么意思？整数值表示CPU的数量；值中的“m”表示毫CPU，所以`200m`表示0.2
    CPU（200 * 0.001）。同样，容器的默认CPU限制是0.2到0.3，实际限制是0.1到2。
- en: 'Afterwards, we create the LimitRange in our plain Namespace and check what
    will happen:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们在普通的Namespace中创建`LimitRange`并检查会发生什么：
- en: '[PRE142]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'When you query the detail description of `my-namespace`, you will see the constraint
    attached to the Namespace directly. There is not any requirement to add the LimitRange.
    Now, all the Pods and containers created in this Namespace have to follow the
    resource limits listed here. If the definitions violate the rule, a validation
    error will be thrown accordingly:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查询`my-namespace`的详细描述时，您将看到直接附加到Namespace的约束。不需要添加`LimitRange`。现在，此Namespace中创建的所有Pod和容器都必须遵循此处列出的资源限制。如果定义违反规则，将相应地抛出验证错误：
- en: '[PRE143]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Deleting a LimitRange
  id: totrans-693
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除`LimitRange`
- en: 'We can delete the LimitRange resource with the subcommand `delete`. Like creating
    the `LimitRange`, deleting a `LimitRange` in a Namespace would remove the constraints
    in the Namespace automatically:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用子命令`delete`删除LimitRange资源。与创建`LimitRange`类似，在命名空间中删除`LimitRange`将自动删除命名空间中的约束：
- en: '[PRE144]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: See also
  id: totrans-696
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Many Kubernetes resources are able to run under a Namespace. To achieve good
    resource management, check out the following recipes:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Kubernetes资源能够在命名空间下运行。为了实现良好的资源管理，请查看以下的方法：
- en: '*Working with Pods*'
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Pod*'
- en: '*Deployment API*'
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署API*'
- en: '*Working with names*'
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用名称*'
- en: '*Setting resources in nodes* section in *[Chapter 7](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    Building Kubernetes on GCP*'
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在*[第7章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)，在GCP上构建Kubernetes*中的*在节点中设置资源*部分*'
- en: Working with labels and selectors
  id: totrans-702
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标签和选择器
- en: '**Labels** are a set of key/value pairs, which are attached to object metadata.
    We could use labels to select, organize, and group objects, such as Pods, ReplicaSets,
    and Services. Labels are not necessarily unique. Objects could carry the same
    set of labels.'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '**标签**是一组键/值对，附加到对象元数据。我们可以使用标签来选择、组织和分组对象，如Pod、ReplicaSets和Services。标签不一定是唯一的。对象可以携带相同的一组标签。'
- en: 'Label selectors are used to query objects with labels of the following types:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 标签选择器用于查询具有以下类型标签的对象：
- en: 'Equality-based:'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于相等性：
- en: Use equal (`=` or `==`) or not-equal (`!=`) operators
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用等于(`=`或`==`)或不等于(`!=`)运算符
- en: 'Set-based:'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于集合：
- en: Use `in` or `notin` operators
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`in`或`notin`运算符
- en: Getting ready
  id: totrans-709
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you get to setting labels in the objects, you should consider the valid
    naming convention of key and value.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象中设置标签之前，您应该考虑键和值的有效命名约定。
- en: 'A valid key should follow these rules:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的键应遵循以下规则：
- en: A name with an optional prefix, separated by a slash.
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的前缀名称，用斜杠分隔。
- en: A prefix must be a DNS subdomain, separated by dots, no longer than 253 characters.
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀必须是DNS子域，由点分隔，不超过253个字符。
- en: A name must be less than 63 characters with the combination of [a-z0-9A-Z] and
    dashes, underscores, and dots. Note that symbols are illegal if put at the beginning
    and the end.
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称必须少于63个字符，由[a-z0-9A-Z]和破折号、下划线和点的组合组成。请注意，如果放在开头和结尾，符号是不合法的。
- en: 'A valid value should follow the following rules:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的值应遵循以下规则：
- en: A name must be less than 63 characters with the combination of [a-z0-9A-Z] and
    dashes, underscores, and dots. Note that symbols are illegal if put at the beginning
    and the end.
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称必须少于63个字符，由[a-z0-9A-Z]和破折号、下划线和点的组合组成。请注意，如果放在开头和结尾，符号是不合法的。
- en: 'You should also consider the purpose, too. For example, there are two projects, `pilot`
    and `poc`. Also, those projects are under different environments, such as `develop`
    and `production`. In addition, some contain multiple tiers, such as `frontend`,
    `cache`, and `backend`. We can make our labels key and value pair combination
    like follows:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该考虑目的。例如，有两个项目，`pilot`和`poc`。此外，这些项目处于不同的环境下，如`develop`和`production`。此外，一些包含多个层次，如`frontend`、`cache`和`backend`。我们可以将我们的标签键和值组合如下：
- en: '[PRE145]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: How to do it...
  id: totrans-719
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s try to create several Pods with the previous labels to distinguish different
    projects, environments, and tiers, as follows:'
  id: totrans-720
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试使用先前的标签创建几个Pod，以区分不同的项目、环境和层次，如下所示：
- en: '| **YAML Filename** | **Pod Image** | **Project** | **Environment** | **Tier**
    |'
  id: totrans-721
  prefs: []
  type: TYPE_TB
  zh: '| **YAML文件名** | **Pod镜像** | **项目** | **环境** | **层次** |'
- en: '| `pilot-dev.yaml` | `nginx` | pilot | develop | `frontend` |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
  zh: '| `pilot-dev.yaml` | `nginx` | pilot | develop | `frontend` |'
- en: '| `pilot-dev.yaml` | `memcached` | `cache` |'
  id: totrans-723
  prefs: []
  type: TYPE_TB
  zh: '| `pilot-dev.yaml` | `memcached` | `cache` |'
- en: '| `pilot-prod.yaml` | `nginx` | production | `frontend` |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
  zh: '| `pilot-prod.yaml` | `nginx` | production | `frontend` |'
- en: '| `pilot-prod.yaml` | `memcached` | `cache` |'
  id: totrans-725
  prefs: []
  type: TYPE_TB
  zh: '| `pilot-prod.yaml` | `memcached` | `cache` |'
- en: '| `poc-dev.yaml` | `httpd` | poc | develop | `frontend` |'
  id: totrans-726
  prefs: []
  type: TYPE_TB
  zh: '| `poc-dev.yaml` | `httpd` | poc | develop | `frontend` |'
- en: '| `poc-dev.yaml` | `memcached` | `cache` |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
  zh: '| `poc-dev.yaml` | `memcached` | `cache` |'
- en: 'For convenience, we will prepare three YAML files that contain two Pods each,
    with a `YAML separator ---` between Pods:'
  id: totrans-728
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了方便起见，我们将准备三个包含两个`Pods`的`YAML`文件，`Pods`之间有一个`YAML`分隔符`---`：
- en: '`pilot-dev.yaml`:'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pilot-dev.yaml`：'
- en: '[PRE146]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '`pilot-prod.yaml`:'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pilot-prod.yaml`：'
- en: '[PRE147]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '`poc-dev.yaml`:'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poc-dev.yaml`：'
- en: '[PRE148]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Create those six Pods with the `kubectl create` command, as follows, to see
    how labels are defined:'
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl create`命令创建这六个`Pods`，如下所示，以查看标签的定义：
- en: '[PRE149]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Run `kubectl describe <Pod name>` to check labels, as follows. It looks good,
    so let''s use the label selector to query these Pods by different criteria:'
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`kubectl describe <Pod name>`来检查标签，如下所示。看起来不错，所以让我们使用标签选择器根据不同的条件查询这些`Pods`：
- en: '[PRE150]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: How it works...
  id: totrans-739
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As mentioned earlier in this section, there are two types of label selectors:
    either equality-based or set-based. Those types have different operators to specify
    criteria.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在本节中有两种类型的标签选择器：基于相等性或基于集合。这些类型有不同的运算符来指定条件。
- en: Equality-based label selector
  id: totrans-741
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于相等性的标签选择器
- en: 'The equality-based selector can specify equal or not equal, and also uses commas
    to add more criteria. Use the `-l` or `--selector` option to specify these criteria
    to filter the name of the object; for example:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 基于相等性的选择器可以指定相等或不相等，并且还使用逗号添加更多条件。使用`-l`或`--selector`选项指定这些条件来过滤对象的名称；例如：
- en: 'Query Pods which belong to the pilot project:'
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询属于试点项目的`Pods`：
- en: '[PRE151]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Query Pods which belong to the frontend tier:'
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询属于前端层的`Pods`：
- en: '[PRE152]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Query Pods which belong to the frontend tier AND the under develop environment:'
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询属于前端层和正在开发的环境的`Pods`：
- en: '[PRE153]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Query Pods which belong to the frontend tier and NOT the under develop environment:'
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询属于前端层而不属于正在开发的环境的`Pods`：
- en: '[PRE154]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Set-based label selector
  id: totrans-751
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于集合的标签选择器
- en: 'With the set-based selector, you can use either the `in` or `notin` operator,
    which is similar to the `SQL IN` clause that can specify multiple keywords, as
    in the following examples:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于集合的选择器，您可以使用`in`或`notin`运算符，这类似于`SQL IN`子句，可以指定多个关键字，如以下示例所示：
- en: 'Query `Pods` which belong to the `pilot` project:'
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询属于“pilot”项目的`Pods`：
- en: '[PRE155]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Query `Pods` which belong to the pilot project and `frontend` tier:'
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询属于试点项目和“frontend”层的`Pods`：
- en: '[PRE156]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Query `Pods` which belong to the pilot project and either the `frontend` or
    `cache` tier:'
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询属于试点项目和“frontend”或“cache”层的`Pods`：
- en: '[PRE157]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Query `Pods` which belong to the pilot project and not the `frontend` or `backend`
    tier (note, we didn''t create the `backend` tier object):'
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询属于试点项目而不属于“frontend”或“backend”层的`Pods`（请注意，我们没有创建`backend`层对象）：
- en: '[PRE158]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'As you can see in the preceding examples for both the equality-based and set-based
    label selector, equality-based is simpler and set-based is more expressive. Note
    that you can mix both operator as follows:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的示例中所看到的，基于相等性和基于集合的标签选择器，基于相等性更简单，基于集合更具表现力。请注意，您可以混合使用这两种运算符，如下所示：
- en: 'Query Pods which do not belong to the pilot project and develop environment:'
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询不属于试点项目和开发环境的`Pods`：
- en: '[PRE159]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: So, you can use the most efficient way to filter out the Kubernetes objects.
    In addition, you can also use either or both types of selectors to configure the
    Kubernetes Service, Deployments, and so on. However, some objects support the
    equality-based selector and some objects support both. So, let's take a look at
    how to define it.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以使用最有效的方式来过滤Kubernetes对象。此外，您还可以使用任一或两种类型的选择器来配置Kubernetes服务、部署等。但是，某些对象支持基于相等性的选择器，某些对象同时支持两种选择器。因此，让我们看看如何定义它。
- en: There's more...
  id: totrans-765
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Label selectors are useful to not only list an object, but also to specify the
    Kubernetes Service and Deployment to bind objects.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 标签选择器不仅有助于列出对象，还有助于指定要绑定对象的 Kubernetes Service 和 Deployment。
- en: Linking Service to Pods or ReplicaSets using label selectors
  id: totrans-767
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标签选择器将 Service 链接到 Pods 或 ReplicaSets
- en: As of Kubernetes version 1.9, Service only supports the equality-based selector
    to bind to Pods or ReplicaSet.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Kubernetes 版本 1.9，Service 仅支持基于相等性的选择器来绑定到 Pods 或 ReplicaSet。
- en: 'Let''s create one Service that binds to `nginx`, which belongs to the production
    environment and the pilot project. Remember that `nginx` also belongs to the frontend
    tier:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个绑定到属于生产环境和试点项目的 `nginx` 的 Service。请记住，`nginx` 也属于前端层。
- en: '[PRE160]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Here is the equivalent, where you can use the `kubectl expose` command to specify
    the label selector:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是等效的，您可以使用 `kubectl expose` 命令来指定标签选择器：
- en: '[PRE161]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Based on your Kubernetes environment, if you are using minikube, it is easier
    to check your Service with `minikube service <Service name>`, as in the following
    screenshot. If you are not using minikube, access to any Kubernetes node and assigned
    Service port number. For the following screenshot, it would be `<node ip>:31981
    or <node ip>:31820`:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的 Kubernetes 环境，如果您使用 minikube，则可以更轻松地使用 `minikube service <Service name>`
    检查您的 Service，如以下屏幕截图所示。如果您没有使用 minikube，则可以访问任何 Kubernetes 节点和分配的 Service 端口号。对于以下屏幕截图，它将是
    `<node ip>:31981 或 <node ip>:31820`：
- en: '![](assets/f0be9472-e1c0-4b61-9224-5af359c3be14.png)Access to Service which
    is running on minikube'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/f0be9472-e1c0-4b61-9224-5af359c3be14.png)访问在 minikube 上运行的 Service'
- en: Linking Deployment to ReplicaSet using the set-based selector
  id: totrans-775
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于集合的选择器将 Deployment 链接到 ReplicaSet
- en: 'Deployment supports not only the equality-based selector, but also the set-based
    selector, to specify `ReplicaSet`. To do that, you can write `spec.selector.matchExpressions[]`
    to specify the key and `in`/`notin` operator. For example, if you want to specify `project
    in (poc), environment in (staging), tier notn (backend,cache)`, then `matchExpressions`
    would be as follows:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment 不仅支持基于相等性的选择器，还支持基于集合的选择器，以指定 `ReplicaSet`。为此，您可以编写 `spec.selector.matchExpressions[]`
    来指定键和 `in`/`notin` 运算符。例如，如果您想要指定 `project in (poc), environment in (staging),
    tier notn (backend,cache)`，那么 `matchExpressions` 将如下所示：
- en: '[PRE162]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: As you can see, the YAML array is represented as `*-*`, and the map object as
    `{}`, to specify the key, operator, and values. Note that values would also be
    an array, so use the square bracket `[]` to specify one or more values.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，YAML 数组表示为 `*-*`，映射对象表示为 `{}`，以指定键、运算符和值。请注意，值也将是一个数组，因此使用方括号 `[]` 来指定一个或多个值。
- en: 'One thing you need to aware of is one label, called the `pod-template-hash`
    label, which is created by Deployment. When you create a Deployment, it will also
    create a `ReplicaSet` object. At this time, Deployment will also assign the `pod-template-hash`
    label to the `ReplicaSet`. Let''s see how it works:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要注意的一件事是一个标签，称为 `pod-template-hash` 标签，它是由 Deployment 创建的。当您创建一个 Deployment
    时，它还将创建一个 `ReplicaSet` 对象。此时，Deployment 还将分配 `pod-template-hash` 标签给 `ReplicaSet`。让我们看看它是如何工作的：
- en: '[PRE163]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: As you can see, the `ReplicaSet` `my-nginx2-764d7cfff` has an equality-based
    selector, as `pod-template-hash=320837999` is appended to the Selector and Pod
    template. It will be used to generate a `ReplicaSet` and Pod name with a particular
    hash function (for example, `my-nginx2-764d7cfff`).
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`ReplicaSet` `my-nginx2-764d7cfff` 具有基于相等性的选择器，因为 `pod-template-hash=320837999`
    被附加到选择器和 Pod 模板中。它将用于使用特定哈希函数生成 `ReplicaSet` 和 Pod 名称（例如，`my-nginx2-764d7cfff`）。
- en: See also
  id: totrans-782
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In this section, you learned how flexible it is to assign a label to your Kubernetes
    object. In addition, equality-based and set-based selectors allow us to filter
    out an object by label. Selector is important that loosely couple an object such
    as Service and ReplicaSet/Pod as well as Deployment and ReplicaSet.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解到为您的Kubernetes对象分配标签是多么灵活。此外，基于相等性和基于集合的选择器允许我们通过标签来过滤对象。选择器很重要，它可以松散地耦合对象，比如Service和ReplicaSet/Pod，以及Deployment和ReplicaSet。
- en: 'The following sections will also use labels and the concept of selectors to
    utilize container management:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分还将使用标签和选择器的概念来利用容器管理：
- en: '*Updating live containers* section in *[Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    Playing with Containers*'
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在*[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml), 与容器一起玩*中的*更新实时容器*部分'
- en: '*Managing the Kubernetes* *cluster on GKE* section in *[Chapter 7](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml),
    Building Kubernetes on GCP*'
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在*[第7章](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml), 在GCP上构建Kubernetes*中的*管理GKE上的Kubernetes集群*部分'
