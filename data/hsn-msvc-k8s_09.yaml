- en: Running Serverless Tasks on Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes上运行无服务器任务
- en: 'In this chapter, we will dive into one of the hottest trends in cloud-native
    systems: serverless computing (also known as **Function as a Service**, or **FaaS**).
    We will explain what serverless means (spoiler alert: it means more than one thing)
    and how it compares to microservices. We will implement and deploy a cool new
    feature for Delinkcious, known as link checking, using the Nuclio serverless framework.
    Finally, we''ll briefly cover other ways to do serverless computing in Kubernetes.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨云原生系统中最热门的趋势之一：无服务器计算（也称为**函数即服务**或**FaaS**）。我们将解释无服务器意味着什么（剧透警告：它的意义不止一种），以及它与微服务的比较。我们将使用Nuclio无服务器框架实现并部署Delinkcious的一个很酷的新功能，即链接检查。最后，我们将简要介绍在Kubernetes中进行无服务器计算的其他方法。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Serverless in the cloud
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云中的无服务器
- en: Link checking with Delinkcious
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Delinkcious进行链接检查
- en: Serverless link checking with Nuclio
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Nuclio进行无服务器链接检查
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we''ll install a serverless framework called Nuclio. First,
    let''s create a dedicated namespace as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将安装一个名为Nuclio的无服务器框架。首先，让我们创建一个专用命名空间，如下所示：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is a good security practice because Nuclio will not interfere with the
    rest of your cluster. Next, we''ll apply some **role-based access control **(**RBAC**)
    permissions. If you take a look at the file (you should always check Kubernetes
    manifests before running them on your cluster), you''ll see that most of the permissions
    are limited to the Nuclio namespace and there are a few cluster-wide permissions
    regarding **custom resource definitions** (**CRDs**) that Nuclio itself creates;
    this is an excellent hygiene:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的安全实践，因为Nuclio不会干扰您集群的其余部分。接下来，我们将应用一些**基于角色的访问控制**（**RBAC**）权限。如果您查看文件（在将其运行在您的集群之前，您应该始终检查Kubernetes清单），您会发现大多数权限都限于Nuclio命名空间，并且有一些关于Nuclio本身创建的**自定义资源定义**（**CRDs**）的集群范围权限；这是一个很好的卫生习惯：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s now deploy Nuclio itself; it creates a few CRDs, and deploys a controller
    and a dashboard service. This is very economical and straightforward, as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们部署Nuclio本身；它会创建一些CRD，并部署控制器和仪表板服务。这非常经济和直接，如下所示：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s verify the installation by checking that the controller and the
    dashboard pods are running successfully:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过检查控制器和仪表板pod是否成功运行来验证安装：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The dashboard is nice, but it is more appropriate for ad hoc exploration. For
    more serious production use, it is better to use the `nuctl` CLI. The next step
    is to download and install `nuctl` from [https://github.com/nuclio/nuclio/releases](https://github.com/nuclio/nuclio/releases).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板很好，但更适合临时探索。对于更严肃的生产使用，最好使用`nuctl` CLI。下一步是从[https://github.com/nuclio/nuclio/releases](https://github.com/nuclio/nuclio/releases)下载并安装`nuctl`。
- en: 'Then, copy the executable to your path to create `symlink nuctl`, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将可执行文件复制到您的路径中，创建`symlink nuctl`，如下所示：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, let''s create an image pull secret so that Nuclio can deploy functions
    to our cluster:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个镜像拉取密钥，以便Nuclio可以将函数部署到我们的集群中：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can also use other registries with the proper credentials; in Minikube,
    you can even use a local registry. However, we'll use the Docker Hub registry
    for consistency.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用其他注册表和适当的凭据；在Minikube中，甚至可以使用本地注册表。但是，为了保持一致，我们将使用Docker Hub注册表。
- en: The code
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码
- en: 'The code is split between two Git repositories, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分为两个Git存储库，如下所示：
- en: You can find the code samples at [https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter09)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter09)找到代码示例。
- en: You can find the updated Delinkcious application at [https://github.com/the-gigi/delinkcious/releases/tag/v0.7](https://github.com/the-gigi/delinkcious/releases/tag/v0.7)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/the-gigi/delinkcious/releases/tag/v0.7](https://github.com/the-gigi/delinkcious/releases/tag/v0.7)找到更新的Delinkcious应用程序。
- en: Serverless in the cloud
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云中的无服务器
- en: People have two different definitions for serverless in the cloud, especially
    in the context of Kubernetes. The first meaning is that you don't have to manage
    the nodes for your cluster. Some good examples of this concept include AWS Fargate
    ([https://aws.amazon.com/fargate/](https://aws.amazon.com/fargate/)) and **Azure
    Container Instances** (**ACI**) ([https://azure.microsoft.com/en-us/services/container-instances/](https://azure.microsoft.com/en-us/services/container-instances/)).
    The second meaning of serverless is that your code is not deployed as a long-running
    service, but is packaged as a function that can be invoked or triggered in different
    ways on demand. Some good examples of this concept include AWS Lambda, and Google
    Cloud Functions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 人们对云中的无服务器有两种不同的定义，特别是在Kubernetes的上下文中。第一种意思是您不必管理集群的节点。这个概念的一些很好的例子包括AWS Fargate（[https://aws.amazon.com/fargate/](https://aws.amazon.com/fargate/)）和Azure
    Container Instances（ACI）（[https://azure.microsoft.com/en-us/services/container-instances/](https://azure.microsoft.com/en-us/services/container-instances/)）。无服务器的第二个意思是，您的代码不是部署为长时间运行的服务，而是打包为可以按需调用或以不同方式触发的函数。这个概念的一些很好的例子包括AWS
    Lambda和Google Cloud Functions。
- en: Let's understand the commonalities and differences between services and serverless
    functions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解服务和无服务器函数之间的共同点和区别。
- en: Microservices and serverless functions
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务和无服务器函数
- en: 'The same code can often run either as a microservice or as a serverless function.
    The difference is mostly operational. Let''s compare the operational attributes
    of microservices and serverless functions, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的代码通常可以作为微服务或无服务器函数运行。区别主要在于操作。让我们比较微服务和无服务器函数的操作属性，如下所示：
- en: '| **Microservices** | **Serverless functions** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **微服务** | **无服务器函数** |'
- en: '|'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Always running (it can scale down to at least one).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终运行（可以缩减至至少一个）。
- en: Can expose multiple endpoints (such as HTTP and gRPC).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以暴露多个端点（如HTTP和gRPC）。
- en: Requires that you implement the request handling and routing yourself.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要自己实现请求处理和路由。
- en: Can listen to events.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以监听事件。
- en: Service instances can maintain in-memory caches, long-term connections, and
    sessions.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务实例可以维护内存缓存、长期连接和会话。
- en: In Kubernetes, microservices are represented directly by the service object.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes中，微服务直接由服务对象表示。
- en: '|'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Runs on demand (theoretically; it can scale down to zero).
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按需运行（理论上；它可以缩减到零）。
- en: Exposes a single endpoint (usually HTTP).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露单个端点（通常为HTTP）。
- en: Can be triggered by events or get an automatic endpoint.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过事件触发或获得自动端点。
- en: Often has severe limitations on resource usage and maximum runtime.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常对资源使用和最大运行时间有严格限制。
- en: Sometimes, it might have a cold start (that is, when scaling up from zero).
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，可能会有冷启动（即从零开始扩展）。
- en: In Kubernetes, there is no native serverless function concept (Jobs and CronJobs
    come close).
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes中，没有原生的无服务器函数概念（作业和定时作业接近）。
- en: '|'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'This should provide you with some relatively good guidance on when to use microservices
    and when to use serverless functions. A microservice is the right choice in the
    following cases:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该为您提供一些相对良好的指导，告诉您何时使用微服务，何时使用无服务器函数。在以下情况下，微服务是正确的选择：
- en: Your workload needs to run non-stop, or almost non-stop.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的工作负载需要持续运行，或几乎持续运行。
- en: Each request runs for a long time and can't be supported by serverless function
    limitations.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个请求运行的时间很长，无法被无服务器函数的限制所支持。
- en: The workload uses a local state between invocations that can't be easily moved
    to an external data store.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作负载在调用之间使用本地状态，无法轻松地移动到外部数据存储。
- en: However, if you have workloads that run infrequently for a relatively short
    time, then you may prefer to use a serverless function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您的工作负载很少运行，持续时间相对较短，那么您可能更喜欢使用无服务器函数。
- en: There are a few other engineering considerations to bear in mind. For example,
    services are more familiar and often have various support libraries. Developers
    may be more comfortable with services and prefer to have a single paradigm for
    deploying code to your system. In particular, in Kubernetes, there is a large
    selection of serverless functions options and it can be difficult to choose the
    right one. On the other hand, serverless functions often support agile and lightweight
    deployment models, where developers can just put some code together and it magically
    starts running on the cluster because the serverless function solution takes care
    of all the business of packaging and deploying it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他工程考虑要牢记。例如，服务更为熟悉，通常具有各种支持库。开发人员可能更喜欢服务，并希望将代码部署到系统时有一个单一的范例。特别是在Kubernetes中，有大量的无服务器函数选项可供选择，很难选择正确的选项。另一方面，无服务器函数通常支持敏捷和轻量级的部署模型，开发人员可以将一些代码放在一起，它就会在集群上神奇地开始运行，因为无服务器函数解决方案负责处理打包和部署的所有业务。
- en: Modeling serverless functions in Kubernetes
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes中建模无服务器函数
- en: At the end of the day, Kubernetes runs containers, so you know your serverless
    function will be packaged as a container. However, there are two primary ways
    to represent serverless functions in Kubernetes. The first one is just as code;
    here, developers, essentially, provide a function in some form (as a file or by pushing
    to a Git repository). The second one is to build it as an actual container. The
    developer builds a regular container and the serverless framework takes care of
    scheduling it and running it as a function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 归根结底，Kubernetes运行容器，因此您知道您的无服务器函数将被打包为容器。然而，在Kubernetes中有两种主要表示无服务器函数的方式。第一种是作为代码；在这里，开发人员基本上以某种形式（作为文件或通过将其推送到Git存储库）提供函数。第二种是将其构建为实际容器。开发人员构建一个常规容器，无服务器框架负责安排它并将其作为函数运行。
- en: Functions as code
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为代码
- en: The benefit of this approach is that, as a developer, you completely sidestep
    the whole business of building images, tagging them, pushing them to a registry,
    and deploying them to the cluster with all the Kubernetes ceremony around it (that
    is, deployment, service, ingress, and NetworkPolicy). It's great for ad hoc exploration
    and one-off jobs too.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处是，作为开发人员，您完全可以绕过构建图像、标记它们、将它们推送到注册表并将它们部署到集群的整个业务（即部署、服务、入口和NetworkPolicy）。这对于临时探索和一次性工作也非常有用。
- en: Functions as containers
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为容器
- en: Here, as a developer, you are on familiar ground. You build a container using
    your regular process and you just deploy it later to the cluster as a serverless
    function. It is still more lightweight than a regular service because you only
    need to implement a function in your container and not a fully-fledged HTTP or
    gRPC server or register to listen for some events. You get all that for the serverless
    functions solution.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，作为开发人员，您是在熟悉的领域。您使用常规流程构建一个容器，然后稍后将其部署到集群作为无服务器函数。它仍然比常规服务更轻量级，因为您只需要在容器中实现一个函数，而不是一个完整的HTTP或gRPC服务器，或者注册以监听某些事件。您可以通过无服务器函数解决方案获得所有这些。
- en: Building, configuring, and deploying serverless functions
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建、配置和部署无服务器函数
- en: You have implemented your serverless function and now you want to deploy it
    to the cluster. Regardless of whether you build your serverless function (if it's
    a container) or whether you provide it as a function, you typically also need
    to configure it in some way. The configuration may contain information such as
    scaling limits, where the function code is located, and how to invoke and trigger
    it. Then, the next step is to deploy the function to the cluster. It may be a
    one-time deployment through a CLI or web UI, or, alternatively, it may be integrated
    with your CI/CD pipeline. This depends mostly on whether your serverless function
    is part of your main application or whether it is something you launch in an ad
    hoc manner for troubleshooting or manual cleanup tasks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经实现了您的无服务器函数，现在您想要将其部署到集群中。无论您是构建无服务器函数（如果它是一个容器）还是将其提供为函数，通常也需要以某种方式对其进行配置。配置可能包含诸如扩展限制、函数代码位置以及如何调用和触发它的信息。然后，下一步是将函数部署到集群中。这可能是通过CLI或Web
    UI的一次性部署，或者也可能与您的CI/CD流水线集成。这主要取决于您的无服务器函数是您主要应用程序的一部分，还是您以临时方式启动它以进行故障排除或手动清理任务。
- en: Invoking serverless functions
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用无服务器函数
- en: Once a serverless function is deployed in the cluster, it will be dormant. There
    will be a controller that runs constantly ready to invoke or trigger functions.
    The controller should take very few resources and just listen for incoming requests
    or events to trigger functions. In Kubernetes, if you need to invoke functions
    from outside the cluster, there will probably be some additional ingress configuration.
    However, the most common use case is to invoke functions internally and expose
    a fully-fledged service to the world.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦无服务器函数在集群中部署，它将处于休眠状态。将有一个控制器不断运行，准备调用或触发函数。控制器应该占用非常少的资源，只需监听传入的请求或事件以触发函数。在Kubernetes中，如果您需要从集群外部调用函数，可能会有一些额外的入口配置。然而，最常见的用例是在内部调用函数并向世界公开一个完整的服务。
- en: Now that we understand what serverless functions are all about, let's add some
    serverless function capabilities to Delinkcious.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了无服务器函数的全部内容，让我们为Delinkcious添加一些无服务器函数功能。
- en: Link checking with Delinkcious
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Delinkcious进行链接检查
- en: 'Delinkcious is a link management system. Links – or, as they are known officially, **uniform
    resource identifiers** (**URIs**) – are really just a pointer to a particular
    resource. There could be two issues with links, such as the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Delinkcious是一个链接管理系统。链接 - 或者，正式称为**统一资源标识符**（**URIs**）- 实际上只是指向特定资源的指针。链接可能存在两个问题，如下所示：
- en: They may be broken (that is, they point to a non-existent resource).
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能是损坏的（也就是说，它们指向一个不存在的资源）。
- en: They may point to a *bad* resource (such as a phishing or virus-injecting site,
    hate speech, or child pornography).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能指向一个*不良*资源（如钓鱼或注入病毒的网站、仇恨言论或儿童色情）。
- en: Checking links and maintaining the status of each link is an important aspect
    of link management. Let's start by designing the way Delinkcious will perform
    link checking.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 检查链接并维护每个链接的状态是链接管理的重要方面。让我们从设计Delinkcious执行链接检查的方式开始。
- en: Designing link checks
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计链接检查
- en: 'Let''s consider link checking in the context of Delinkcious. We should consider
    the current state as a future improvement. Here are some assumptions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Delinkcious的背景下考虑链接检查。我们应该将当前状态视为未来的改进。以下是一些假设：
- en: Links can be temporarily or permanently broken.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接可能是暂时的或永久的中断。
- en: Link checking may be a heavyweight operation (especially if analyzing content).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接检查可能是一个繁重的操作（特别是在分析内容时）。
- en: The status of a link may change at any time (that is, a valid link can suddenly
    break if the resource that it's pointing to is deleted).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接的状态可能随时改变（也就是说，如果指向的资源被删除，有效链接可能会突然中断）。
- en: Specifically, Delinkcious links are stored redundantly per user. If two users
    add the same link, it will be stored for each user separately. This means that,
    if link checking happens when a link is added, and if *N* users add the same link,
    then it will be checked each time. This is not very efficient, especially for
    popular links that many users may add and that can all benefit from a single check.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，Delinkcious链接会按用户冗余存储。如果两个用户添加相同的链接，它将分别为每个用户存储。这意味着，如果在添加链接时进行链接检查，如果*N*用户添加相同的链接，那么每次都会进行检查。这不是很有效，特别是对于许多用户可能添加并且可以从单个检查中受益的热门链接。
- en: 'Consider the following case, which is even worse:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情况，这甚至更糟：
- en: '*N* users add the link, *L*.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*N*用户添加链接*L*。'
- en: The link check for *L* passed for all those *N* users.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有这些*N*用户，链接检查*L*都通过了。
- en: Another user, *N+1*, adds the same link, *L*, which is now broken (for example,
    the hosting company removed the page).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个用户*N+1*添加相同的链接*L*，现在已经损坏（例如，托管公司删除了页面）。
- en: Only the last user, *N+1*, will have the correct status of the link, *L*, as
    invalid.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有最后一个用户*N+1*将拥有链接*L*的正确状态，即无效。
- en: All previous *N* users will still assume that the link is valid.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有以前的*N*用户仍然会认为链接是有效的。
- en: 'Since we want, in this chapter, to focus on serverless functions, we will accept
    these limitations in the way in which Delinkcious stores links for each user.
    A more efficient and robust design in the future could be as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本章中想要专注于无服务器函数，我们将接受Delinkcious为每个用户存储链接的方式中的这些限制。将来可能会有更有效和更健壮的设计，如下所示：
- en: Store all the links independent of the users.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立于用户存储所有链接。
- en: Users that add a link will have an association to that link.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加链接的用户将与该链接关联。
- en: Link checking will automatically reflect the latest status of a link for all
    users.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接检查将自动反映所有用户的链接的最新状态。
- en: 'When it comes to designing a link check, let''s consider some of the following
    options for checking links when adding a new link:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计链接检查时，让我们考虑一些以下选项，用于在添加新链接时检查链接：
- en: When adding a link, just run the link checking code in the link service.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在添加链接时，只需在链接服务中运行链接检查代码。
- en: When adding a link, call a separate link checking service.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在添加链接时，调用一个单独的链接检查服务。
- en: When adding a link, invoke a link checking serverless function.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在添加链接时，调用一个无服务器函数进行链接检查。
- en: When adding a link, keep it in pending status, which periodically runs checks
    on all recently added links.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在添加链接时，保持链接处于待定状态，定期对所有最近添加的链接进行检查。
- en: Additionally, since links can break at anytime, it may be useful to run link
    checks periodically for existing links.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，由于链接随时可能会中断，定期对现有链接运行链接检查可能是有用的。
- en: 'Let''s consider the first option, that is, running the link check inside the
    link manager. While it has the benefit of simplicity, it also suffers from several
    problems, such as the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑第一个选项，即在链接管理器内部运行链接检查。虽然这样做简单，但也存在一些问题，比如：
- en: If link checking takes too long (for example, if the target is unreachable or
    the content takes a long time to classify), then it will delay the response to
    the user adding the link or it can even time out.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果链接检查时间太长（例如，如果目标不可达或内容分类需要很长时间），那么它将延迟对添加链接的用户的响应，甚至可能超时。
- en: Even if the actual link checking is done asynchronously, it still ties up resources
    of the link service in unpredictable ways.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使实际的链接检查是异步进行的，它仍然以不可预测的方式占用了链接服务的资源。
- en: There is no easy way to schedule periodic checks or ad hoc checks of links without
    making serious changes to the link manager.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有简单的方法可以安排定期检查或临时检查链接，而不对链接管理器进行重大更改。
- en: Conceptually, link checking is a separate responsibility to link management
    and shouldn't live in the same microservice.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从概念上讲，链接检查是链接管理的一个单独责任，不应该存在于同一个微服务中。
- en: Let's consider the second option, that is, implementing a dedicated link checking
    service. This option addresses most of the issues as the first option, but it
    may be overkill. That said, it is not the best option when there is no need to
    check links very often; for example, if the majority of added links are checked
    or if link checking happens only periodically. Additionally, for implementing
    a service for a single operation, checking links seems like overkill for a service.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑第二个选项，即实施一个专门的链接检查服务。这个选项解决了大部分第一个选项的问题，但可能有些过度。也就是说，当没有必要经常检查链接时，这并不是最佳选项；例如，如果大多数添加的链接都经过了检查，或者链接检查只是定期进行。此外，为了实施一个单一操作的服务，检查链接似乎有些过度。
- en: This leaves us with the third and fourth options, and both can be implemented
    effectively using a serverless function solution, as shown in the following diagram.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们剩下了第三和第四个选项，两者都可以通过无服务器函数解决方案有效实施，如下图所示。
- en: 'Let''s start with the following simple design:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下简单的设计开始：
- en: The link manager will invoke a serverless function when adding a new link.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当添加新链接时，链接管理器将调用一个无服务器函数。
- en: The new link will initially be in a pending state.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新链接最初将处于待定状态。
- en: The serverless function will only check whether the link is reachable.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器函数将仅检查链接是否可达。
- en: The serverless function will send an event through the NATS system, which the
    link manager will subscribe to.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器函数将通过NATS系统发送一个事件，链接管理器将订阅该事件。
- en: The link manager will update the link status from *pending* to *valid* or *invalid*
    when it receives the event.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当链接管理器接收到事件时，将更新链接状态从“待定”到“有效”或“无效”。
- en: 'Here is a diagram that describes this flow:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是描述这一流程的图表：
- en: '![](assets/10fb6373-7451-42ce-9277-26ed16dbf867.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/10fb6373-7451-42ce-9277-26ed16dbf867.png)'
- en: With a solid design in place, let's go ahead and implement and integrate it
    with Delinkcious.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有了一个坚实的设计，让我们继续实施并将其与Delinkcious集成。
- en: Implementing link checks
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施链接检查
- en: 'At this stage, we will implement the link checking functionality independent
    of serverless functions. Let''s start with our object model and add the `Status`
    field to our link object with the possible values of `pending`, `valid`, and `invalid`.
    We define an `alias` type here called `LinkStatus`, and constants for the values.
    However, note that it is not a strongly typed `enum` like other languages; it
    is really just a string:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们将独立于无服务器函数实现链接检查功能。让我们从我们的对象模型开始，并向我们的链接对象添加`Status`字段，可能的值为`pending`、`valid`和`invalid`。我们在这里定义了一个名为`LinkStatus`的`alias`类型，并为这些值定义了常量。但是，请注意，它不像其他语言中的强类型`enum`，它实际上只是一个字符串：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s also define a `CheckLinkRequest` object that will come in handy later.
    Note that each request is per specific user and includes the link''s URL:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也定义一个`CheckLinkRequest`对象，以后会派上用场。请注意，每个请求都是针对特定用户的，并包括链接的URL：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s define an interface that `LinkManager` will implement to get notified
    when a link has been checked. The interface is very simple and has a single method
    that informs the receiver (`LinkManager`, in our case) of the user, the URL, and
    the link status:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个接口，`LinkManager`将实现该接口以在链接检查完成时得到通知。该接口非常简单，只有一个方法，用于通知接收者（在我们的例子中是`LinkManager`）用户、URL和链接状态：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's create a new package, `pkg/link_checker`, to isolate this functionality.
    It has a single `CheckLink()` function that accepts a URL and uses the built-in
    Go HTTP client to call its HEAD HTTP method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的包`pkg/link_checker`，以隔离这个功能。它有一个名为`CheckLink()`的函数，接受一个URL，并使用内置的Go
    HTTP客户端调用其HEAD HTTP方法。
- en: 'If the result is less than 400, it is considered a success, otherwise, it returns
    the HTTP status as an error:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果小于400，则被视为成功，否则将HTTP状态作为错误返回：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The HEAD method, which just returns a few headers, is an effective way to check
    whether a link is reachable because, even for very large resources, the headers
    will be a small amount of data. Obviously, this is not good enough if we want
    to extend link checks to scanning and analyzing the content, but it will do for
    now.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: HEAD方法只返回一些头部信息，是检查链接是否可达的有效方法，因为即使对于非常大的资源，头部信息也只是一小部分数据。显然，如果我们想将链接检查扩展到扫描和分析内容，这是不够的，但现在可以用。
- en: 'According to our design, when the link checking is complete, `LinkManager`
    should receive an event through NATS with the check result. This is very similar
    to the news service listening to link events (such as the link added and the link
    updated events). Let''s implement another package, `link_checker_events`, for
    the NATS integration, which will allow us to send and subscribe to link checking
    events. First, we need an event object that contains the username, the URL, and
    the link status:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的设计，当链接检查完成时，`LinkManager`应该通过NATS接收到一个事件，其中包含检查结果。这与新闻服务监听链接事件（如链接添加和链接更新事件）非常相似。让我们为NATS集成实现另一个包`link_checker_events`，它将允许我们发送和订阅链接检查事件。首先，我们需要一个包含用户名、URL和链接状态的事件对象：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we need to be able to send events through NATS. The `eventSender` object
    implements the `LinkCheckerEvents` interface. Whenever it receives a call, it
    creates `link_checker_events.Event` and publishes it to NATS:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要能够通过NATS发送事件。`eventSender`对象实现了`LinkCheckerEvents`接口。每当它接收到调用时，它会创建`link_checker_events.Event`并将其发布到NATS：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The reason the event is defined in the `link_checker_events` package and not
    in the general Delinkcious object model is that this event is just created for
    the purpose of interfacing though NATS with the link checker listener that is
    also implemented in this package. There is no need to expose this event outside
    the package (except for letting NATS serialize it). In the `Listen()` method, the
    code connects to the NATS server and subscribes to NATS in a queue (which means
    that only one listener will handle each event, even if multiple subscribers subscribe
    to the same queue).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 事件在`link_checker_events`包中定义，而不是在一般的Delinkcious对象模型中定义的原因是，这个事件只是为了通过NATS与链接检查监听器进行接口交互而创建的。没有必要在包外部暴露这个事件（除了让NATS对其进行序列化）。在`Listen()`方法中，代码连接到NATS服务器并在队列中订阅NATS（这意味着即使多个订阅者订阅了同一个队列，也只有一个监听器会处理每个事件）。
- en: 'When the listener function that is subscribed to the queue receives an event
    from NATS, it forwards it to the event sink that implements `om.LinkCheckerEvents`
    (while ignoring the link deletion events):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当订阅到队列的监听函数从NATS接收到事件时，它将其转发到实现`om.LinkCheckerEvents`的事件接收器（同时忽略链接删除事件）：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you followed closely, you may have noticed that there is one key piece missing,
    which we described in our design, that is, invoking the link checking. Everything
    is wired up and ready to check links, but nobody is actually calling the link
    checker. This is where `LinkManager` comes in to invoke the serverless function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细跟随，您可能已经注意到有一个关键部分缺失，这是我们在设计中描述的，即调用链接检查。一切都已经连接好，准备好检查链接，但实际上没有人在调用链接检查。这就是`LinkManager`发挥作用的地方，用来调用无服务器函数。
- en: Serverless link checking with Nuclio
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Nuclio进行无服务器链接检查
- en: Before we dive into `LinkManager` and close the loop of link checking in Delinkcious,
    let's get familiar with Nuclio ([https://nuclio.io/](https://nuclio.io/)) and
    explore how it provides a serverless function solution that works very well for
    Delinkcious.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究`LinkManager`并关闭Delinkcious中的链接检查循环之前，让我们熟悉一下Nuclio（[https://nuclio.io/](https://nuclio.io/)），并探索它如何为Delinkcious提供非常适用的无服务器函数解决方案。
- en: A quick introduction to Nuclio
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nuclio的简要介绍
- en: 'Nuclio is a polished, open source platform for high-performance serverless
    functions. It was developed by Iguazio and supports multiple platforms, such as
    Docker, Kubernetes, GKE, and Iguazio itself. We obviously care about Kubernetes,
    but it''s interesting to note that Nuclio can be used on other platforms too.
    It has the following features:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Nuclio是一个经过精心打磨的开源平台，用于高性能无服务器函数。它由Iguazio开发，并支持多个平台，如Docker、Kubernetes、GKE和Iguazio本身。我们显然关心Kubernetes，但有趣的是Nuclio也可以在其他平台上使用。它具有以下功能：
- en: It can build functions from the source code or provide your own container.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以从源代码构建函数，也可以提供您自己的容器。
- en: It is a very clean, conceptual model.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个非常清晰的概念模型。
- en: It has great integration with Kubernetes.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与Kubernetes集成非常好。
- en: It uses a CLI called `nuctl`.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用一个名为`nuctl`的CLI。
- en: It has a web dashboard if you want to play with it interactively.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想要交互式地使用它，它有一个Web仪表板。
- en: It has a slew of methods to deploy, manage, and invoke your serverless functions.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一系列方法来部署、管理和调用您的无服务器函数。
- en: It offers GPU support.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供GPU支持。
- en: It is a managed solution with 24/7 support (this is paid).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个24/7支持的托管解决方案（需要付费）。
- en: 'Finally, it has a super cool logo! You can view the logo here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它有一个超酷的标志！您可以在这里查看标志：
- en: '![](assets/5a1e8c8f-634e-4833-b4ed-81635a523bba.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5a1e8c8f-634e-4833-b4ed-81635a523bba.png)'
- en: Let's now build and deploy our link checking capability into Delinkcious using
    Nuclio.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Nuclio构建和部署我们的链接检查功能到Delinkcious中。
- en: Creating a link checker serverless function
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个链接检查无服务器函数
- en: 'The first step is creating a serverless function; there are two components
    here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个无服务器函数；这里有两个组件：
- en: The function code
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数代码
- en: The function configuration
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数配置
- en: 'Let''s create a dedicated directory called `fun` for storing serverless functions.
    Serverless functions don''t really fit into any of our existing categories; that
    is, they are not plain packages, they are not services, and they are not commands.
    We can put the function code and its configuration as a YAML file under the `link_checker`
    subdirectory. Later, if we decide to model additional capabilities as serverless
    functions, then we can create additional subdirectories for each function as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个专门的目录，名为`fun`，用于存储无服务器函数。无服务器函数实际上不属于我们现有的任何类别；也就是说，它们既不是普通的包，也不是服务，也不是命令。我们可以将函数代码和其配置作为一个YAML文件放在`link_checker`子目录下。以后，如果我们决定将其他功能建模为无服务器函数，那么我们可以为每个函数创建额外的子目录，如下所示：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The function itself is implemented in `link_checker.go`. The `link_checker`
    function is responsible for checking a link when triggered and publishing an event
    to NATS with the results. Let''s break it down piece by piece, starting with the
    imports and constants. Our function will utilize the Nuclio GO SDK, which provides
    a standard signature that we will look at later. It also imports our Delinkcious
    packages: the `object_model`, the `link_checker`, and the `link_checker_events` packages.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 函数本身是在`link_checker.go`中实现的。`link_checker`函数负责在触发时检查链接并向NATS发布结果事件。让我们逐步分解，从导入和常量开始。我们的函数将利用Nuclio
    GO SDK，该SDK提供了一个标准签名，我们稍后会看到。它还导入了我们的Delinkcious包：`object_model`，`link_checker`和`link_checker_events`包。
- en: Here, we also define the NATS URL based on the well-known Kubernetes DNS name.
    Note that the `natsUrl` constant includes the namespace (by default). The `link_checker`
    serverless function will run in the Nuclio namespace, but will send events to
    the NATS server running in the default namespace.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还根据众所周知的Kubernetes DNS名称定义NATS URL。请注意，`natsUrl`常量包括命名空间（默认情况下）。`link_checker`无服务器函数将在Nuclio命名空间中运行，但将向运行在默认命名空间中的NATS服务器发送事件。
- en: 'This is not a problem; namespaces are not isolated from each other at the network
    level (unless you explicitly create a network policy):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个问题；命名空间在网络层不是相互隔离的（除非你明确创建了网络策略）：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Implementing a Nuclio serverless function (in Go) means implementing a handler
    function with a certain signature. The function accepts a Nuclio context and a
    Nuclio event object. Both are defined in the Nuclio GO SDK. The handler function
    returns an empty interface (which can pretty much return anything). However, there
    is a standard Nuclio response object for the HTTP-invoked functions that we use
    here. The Nuclio event has a `GetBody()` message that can be used to get the input
    to the function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 实现Nuclio无服务器函数（使用Go）意味着实现具有特定签名的处理函数。该函数接受Nuclio上下文和Nuclio事件对象。两者都在Nuclio GO
    SDK中定义。处理函数返回一个空接口（基本上可以返回任何东西）。但是，这里我们使用的是HTTP调用函数的标准Nuclio响应对象。Nuclio事件有一个`GetBody()`消息，可以用来获取函数的输入。
- en: 'Here, we unmarshal it using the standard JSON encoder in `CheckLinkRequest`
    from the Delinkcious object model. This is the contract between whoever invokes
    the `link_checker` function and the function itself. Since Nuclio provides a generic
    signature, we must validate the input that was provided in the body. If it wasn''t,
    then the `json.Unmarshal()` call will fail and the function will return a 400
    (that is, a bad request) error:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Delinkcious对象模型中的标准JSON编码器对`CheckLinkRequest`进行解组。这是调用`link_checker`函数的人和函数本身之间的契约。由于Nuclio提供了一个通用签名，我们必须验证在请求体中提供的输入。如果没有提供，那么`json.Unmarshal()`调用将失败，并且函数将返回400（即，错误的请求）错误：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Additionally, if the unmarshaling succeeded but the resulting `CheckLinkRequest`
    has an empty username or empty URL, it is still an invalid input and the function
    will return a 400 error as well:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果解组成功，但生成的`CheckLinkRequest`具有空用户名或空URL，则仍然是无效输入，函数也将返回400错误：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At this point, the function validated the input, we got a username and a URL,
    and it''s ready to check whether the link itself is valid. All it takes is to
    call the `CheckLink()` function of the `pkg/link_checker` package that we implemented
    earlier. The status is initialized to `LinkStatusValid` and, if the check returns
    an error, then the status is set to `LinkStatusInvalid` as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，函数验证了输入，我们得到了一个用户名和一个URL，并且准备检查链接本身是否有效。只需调用我们之前实现的`pkg/link_checker`包的`CheckLink()`函数。状态初始化为`LinkStatusValid`，如果检查返回错误，则状态设置为`LinkStatusInvalid`如下：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, don't get confused! The `pkg/link_checker` package is a package that
    implements the `CheckLink()` function. In comparison, `fun/link_checker` is a
    Nuclio serverless function that calls `CheckLink()`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，不要混淆！`pkg/link_checker`包是实现`CheckLink()`函数的包。相比之下，`fun/link_checker`是一个调用`CheckLink()`的Nuclio无服务器函数。
- en: 'The link was checked and we have its status; it''s now time to publish the
    result through NATS. Again, we''ve already done all the hard work in `pkg/link_checker_events`.
    The function creates a new event sender using the `natsUrl` constant. If it failed,
    then the function returns an error. If the sender was created properly, it invokes
    its `OnLinkChecked()` method with the username, the URL, and the status. Finally,
    it returns the Nuclio response (initialized to 200 OK) and no error, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 链接已经被检查，我们有了它的状态；现在是时候通过NATS发布结果了。同样，我们已经在`pkg/link_checker_events`中完成了所有的艰苦工作。函数使用`natsUrl`常量创建一个新的事件发送器。如果失败，函数将返回错误。如果发送器被正确创建，它将使用用户名、URL和状态调用其`OnLinkChecked()`方法。最后，它返回Nuclio响应（初始化为200
    OK）和无错误，如下所示：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code is only half the story, however. Let's review the function configuration
    in `fun/link_checker/function.yaml`. It looks just like a standard Kubernetes
    resource and this is no coincidence.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码只是故事的一半。让我们在`fun/link_checker/function.yaml`中审查函数配置。它看起来就像一个标准的Kubernetes资源，这不是巧合。
- en: You can take a look at the full specification at [https://nuclio.io/docs/latest/reference/function-configuration-reference/](https://nuclio.io/docs/latest/reference/function-configuration-reference/).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://nuclio.io/docs/latest/reference/function-configuration-reference/](https://nuclio.io/docs/latest/reference/function-configuration-reference/)查看完整规范。
- en: 'In the following code block, we specify the API version, the kind (`NuclioFunction`),
    and then the spec. We have a description filled, the runtime field says Golang,
    and the handler defines the package and function name that implements the handler
    function. We also specify the minimum and maximum replicas, which, in this case,
    are both `1`. Note that Nuclio doesn''t provide a way to scale to zero. There
    will always be at least one replica of each deployed function waiting to be triggered.
    The only custom part of the configuration is the `build` command to install the
    `ca-certificates` package. This uses the **Alpine Linux Package Manager** (**APK**)
    system. This is necessary because the link checker needs to check HTTPS links
    too, and that requires root CA certificates:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们指定了API版本、种类（`NuclioFunction`），然后是规范。我们填写了描述，运行时字段为Golang，处理程序定义了实现处理程序函数的包和函数名称。我们还指定了最小和最大副本数，在这种情况下都是`1`。请注意，Nuclio没有提供缩放到零的方法。每个部署的函数都至少有一个副本等待触发。配置的唯一自定义部分是`build`命令，用于安装`ca-certificates`包。这使用了**Alpine
    Linux Package Manager**（**APK**）系统。这是必要的，因为链接检查器需要检查HTTPS链接，这需要根CA证书。
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: All right! We created a link checker serverless function and a configuration;
    let's now deploy it to our cluster.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！我们创建了一个链接检查器无服务器函数和一个配置；现在让我们将其部署到我们的集群中。
- en: Deploying the link checker function with nuctl
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用nuctl部署链接检查器函数
- en: 'When Nuclio deploys a function, it actually builds a Docker image and pushes
    it to a registry. Here, we''ll use the Docker Hub registry; so, first, let''s
    log in:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当Nuclio部署函数时，实际上会构建一个Docker镜像并将其推送到注册表中。在这里，我们将使用Docker Hub注册表；所以，首先让我们登录：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The function name must follow DNS naming rules, so the `""` marks in `link_checker`
    are not acceptable. Instead, we''ll name the function `link-checker` and run the
    `nuctl deploy` command, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名称必须遵循DNS命名规则，因此`link_checker`中的`""`标记是不可接受的。相反，我们将命名函数为`link-checker`并运行`nuctl
    deploy`命令，如下所示：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that the documentation for deploying a function with `nuctl` to the Docker
    Hub registry is incorrect at the time of writing. I opened a GitHub issue ([https://github.com/nuclio/nuclio/issues/1181](https://github.com/nuclio/nuclio/issues/1181))
    for the Nuclio team. Hopefully, it will be fixed by the time you read this.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目前编写时使用`nuctl`将函数部署到Docker Hub注册表的文档是不正确的。我为Nuclio团队打开了一个GitHub问题（[https://github.com/nuclio/nuclio/issues/1181](https://github.com/nuclio/nuclio/issues/1181)）。希望在您阅读此文时能够修复。
- en: 'The function was deployed to the Nuclio namespace, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 函数已部署到Nuclio命名空间，如下所示：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The best way to see all the configuration is to use `nuctl` again:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 查看所有配置的最佳方法是再次使用`nuctl`：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, it borrows a lot from our `function.yaml` configuration file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它大量借鉴了我们的`function.yaml`配置文件。
- en: We have successfully deployed our function using the `nuctl` CLI, which is great
    for developers and CI/CD systems. Let's now take a look at how to deploy a function
    using the Nuclio web UI.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功使用`nuctl` CLI部署了我们的函数，这对开发人员和CI/CD系统非常有用。现在让我们看看如何使用Nuclio Web UI部署函数。
- en: Deploying a function using the Nuclio dashboard
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Nuclio仪表板部署函数
- en: 'Nuclio has a cool web UI dashboard. The Nuclio dashboard is very well done;
    it is installed as a service in our cluster. First, we need to do a little port
    forwarding before we can access it:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Nuclio有一个很酷的Web UI仪表板。Nuclio仪表板做得非常好；它作为一个服务安装在我们的集群中。首先，我们需要在访问之前进行一些端口转发：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, we can browse to `localhost:8070` and play with the dashboard. The dashboard
    allows you to view, deploy, and test (or invoke) serverless functions directly
    from a single screen. This is great for ad hoc exploration.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以浏览到`localhost:8070`并使用仪表板。仪表板允许您直接从单个屏幕查看、部署和测试（或调用）无服务器函数。这对于临时探索非常有用。
- en: 'Here, I slightly modified the `hello` example function (in Python) and even
    tested it with the text, `Yeah, it works!`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我稍微修改了`hello`示例函数（用Python），甚至用文本`Yeah, it works!`进行了测试：
- en: '![](assets/9b6b1b79-bec6-467a-96fc-b431bd03c809.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9b6b1b79-bec6-467a-96fc-b431bd03c809.png)'
- en: Once the function is deployed in the cluster, we can invoke it in different
    ways.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数在集群中部署，我们可以以不同的方式调用它。
- en: Invoking the link-checker function directly
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接调用链接检查器函数
- en: 'Invoking the function using `nuctl` is very simple. We need to provide the
    function name (`link-checker`), the namespace, the cluster IP address, and the
    body, which is the input to the function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`nuctl`调用函数非常简单。我们需要提供函数名称（`link-checker`），命名空间，集群IP地址和输入到函数的主体：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Triggering link checking in LinkManager
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在LinkManager中触发链接检查
- en: 'Using `nuctl` is nice when you develop your functions and want a quick edit-deploy-debug
    cycle. However, in production, you will want to either invoke the function by
    using an HTTP endpoint or one of the triggers. For Delinkcious, the simplest way
    is by having `LinkManager` directly hit the HTTP endpoint. This happens when a
    new link is added to the `AddLink()` method of `LinkManager`. It simply calls
    `triggerLinkCheck` with the username and URL, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发函数并希望快速进行编辑-部署-调试周期时，使用`nuctl`是不错的。但是，在生产中，您将希望通过使用HTTP端点或其中一个触发器来调用函数。对于Delinkcious，最简单的方法是让`LinkManager`直接命中HTTP端点。这发生在将新链接添加到`LinkManager`的`AddLink()`方法时。它只是调用`triggerLinkCheck`并提供用户名和URL，如下所示：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It's important that the `AddLink()` method doesn't have to wait for the link
    check to complete. If you remember, the link will be stored immediately with a
    *pending* status. Later, when the check is complete, the status will be changed
    to either *valid* or *invalid*. To accomplish this, the `triggerLinkCheck()` function
    runs a goroutine that returns control immediately.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是`AddLink()`方法不必等待链接检查完成。如果记得，链接将立即以*pending*状态存储。稍后，当检查完成时，状态将更改为*valid*或*invalid*。为了实现这一点，`triggerLinkCheck()`函数运行一个goroutine，立即返回控制。
- en: 'The goroutine, in the meantime, prepares `om.CheckLinkRequest`, which the handler
    of the `link_checker` serverless function is expecting. It serializes it into
    JSON via `json.Marshal()` and, using the Go built-in HTTP client, it sends a POST
    request to the link checker function URL in the Nuclio namespace (it has no problem
    hitting HTTP endpoints in another namespace). Here, we just ignore any errors;
    if something goes wrong, then the link will stay in the *pending* state and we
    can decide what to do about it later:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，goroutine准备了`om.CheckLinkRequest`，这是`link_checker`无服务器函数的处理程序所期望的。它通过`json.Marshal()`将其序列化为JSON，并使用Go内置的HTTP客户端，向Nuclio命名空间中链接检查函数的URL发送POST请求（在另一个命名空间中命中HTTP端点没有问题）。在这里，我们只忽略任何错误；如果出现问题，那么链接将保持在*pending*状态，我们可以稍后决定如何处理它。
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We did a lot of work here, but we kept everything loosely coupled and ready
    for extension. It would be very easy to add more sophisticated link checking logic
    in order to trigger link checking as a NATS event instead of directly hitting
    an HTTP endpoint, or even replace the Nuclio serverless function with a completely
    different serverless function solution. Let's briefly take a look at the other
    options in the following section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了很多工作，但我们保持了一切松散耦合并准备进行扩展。很容易添加更复杂的链接检查逻辑，以便触发链接检查作为NATS事件，而不是直接命中HTTP端点，甚至用完全不同的无服务器函数解决方案替换Nuclio无服务器函数。让我们简要地看一下以下部分中的其他选项。
- en: Other Kubernetes serverless frameworks
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他Kubernetes无服务器框架
- en: 'AWS Lambda functions made serverless functions in the cloud very popular. Kubernetes
    is not a fully-fledged serverless function primitive, but it gets pretty close
    with the Job and CronJob resources. In addition to this, a plethora of serverless
    function solutions were developed by the community (Nuclio being one of them).
    Here are some of the more popular and mature options that we will see in the following
    subsections:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda函数使云中的无服务器函数非常受欢迎。Kubernetes不是一个完全成熟的无服务器函数原语，但它通过作业和CronJob资源非常接近。除此之外，社区开发了大量无服务器函数解决方案（Nuclio就是其中之一）。以下是一些更受欢迎和成熟的选项，我们将在以下小节中看到：
- en: Kubernetes Jobs and CronJobs
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes作业和CronJobs
- en: KNative
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KNative
- en: Fission
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fission
- en: Kubeless
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubeless
- en: OpenFaas
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenFaas
- en: Kubernetes Jobs and CronJobs
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes作业和CronJobs
- en: Kubernetes deployments and services are all about creating a set of long-running
    pods that are supposed to run indefinitely. A Kubernetes Job is all about running
    one or more pods until one of them completes successfully. When you create a Job,
    it looks very much like a deployment, except that the restart policy should be
    `Never`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes部署和服务都是关于创建一组长时间运行的pod，这些pod应该无限期地运行。 Kubernetes Job的目的是运行一个或多个pod，直到其中一个成功完成。当您创建一个Job时，它看起来非常像一个部署，只是重启策略应该是`Never`。
- en: 'Here is a Kubernetes Job that prints `Yeah, it works in a Job!!!` from Python:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个从Python打印`Yeah, it works in a Job!!!`的Kubernetes Job：
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'I can now run this Job, watch it complete, and check the logs, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以运行这个Job，观察它的完成，并检查日志，如下所示：
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is almost a serverless function. Of course, it doesn''t come with all
    the bells and whistles, but the core functionality is there: launch a container,
    run it to completion, and get back the results.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎是一个无服务器函数。当然，它没有所有的花里胡哨，但核心功能是存在的：启动一个容器，运行它直到完成，并获取结果。
- en: A Kubernetes CronJob is similar to a Job, except that it gets triggered on a
    schedule. If you don't want to incur additional dependencies on a third-party
    serverless function framework, then you can build a basic solution on top of the
    Kubernetes Job and CronJob objects.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes CronJob类似于Job，只是它会按计划触发。如果您不想在第三方无服务器函数框架上增加额外的依赖项，那么您可以在Kubernetes
    Job和CronJob对象之上构建一个基本解决方案。
- en: KNative
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KNative
- en: 'KNative ([https://cloud.google.com/knative/](https://cloud.google.com/knative/))
    is a relative newcomer to the serverless functions scene, but I actually predict
    that it will become the mainstream go-to solution, and there are several reasons
    for this, such as the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: KNative（[https://cloud.google.com/knative/](https://cloud.google.com/knative/)）是无服务器函数领域的相对新手，但我实际上预测它将成为主流的首选解决方案，其中有几个原因，例如：
- en: It is a strong solution that can scale to zero (unlike Nuclio).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个强大的解决方案，可以缩放到零（不像Nuclio）。
- en: It can build images in-cluster (using Kaniko).
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在集群内构建镜像（使用Kaniko）。
- en: It is Kubernetes-specific.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是特定于Kubernetes的。
- en: It has the cloud of Google behind it and is available on GKE via Cloud Run ([https://cloud.google.com/blog/products/serverless/announcing-cloud-run-the-newest-member-of-our-serverless-compute-stack](https://cloud.google.com/blog/products/serverless/announcing-cloud-run-the-newest-member-of-our-serverless-compute-stack)).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有Google的支持，并且可以通过Cloud Run在GKE上使用（[https://cloud.google.com/blog/products/serverless/announcing-cloud-run-the-newest-member-of-our-serverless-compute-stack](https://cloud.google.com/blog/products/serverless/announcing-cloud-run-the-newest-member-of-our-serverless-compute-stack)）。
- en: It uses the Istio service mesh as a foundation, and Istio is becoming very important
    (more on that in [Chapter 13](b39834c8-859c-42a5-846a-e48b76dfd6cc.xhtml), *Service
    Mesh – Working with Istio*).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用Istio服务网格作为基础，而Istio变得非常重要（更多信息请参见[第13章](b39834c8-859c-42a5-846a-e48b76dfd6cc.xhtml)，*服务网格-使用Istio*）。
- en: 'KNative has three separate components, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: KNative有三个独立的组件，如下所示：
- en: Building
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建
- en: Serving
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Eventing
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: It is designed to be very pluggable so that you bring your own builder or event
    sources. The build component is in charge of going from the source to the image.
    The serving component is responsible for scaling the number of containers needed
    to handle the load. It can scale up as more load is generated, or down, including
    all the way to zero. The eventing component is related to producing and consuming
    events in your serverless functions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 它被设计为非常可插拔，以便您可以自己选择构建器或事件源。构建组件负责从源代码到镜像的转换。服务组件负责扩展所需的容器数量以处理负载。它可以根据生成的负载进行扩展，或者减少，甚至可以减少到零。事件组件与在无服务器函数中生成和消耗事件有关。
- en: Fission
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fission
- en: 'Fission ([https://fission.io/](https://fission.io/)) is an open source serverless
    framework from Platform9 that supports multiple languages, such as Python, NodeJS,
    Go, C#, and PHP. It can be extended to support other languages. It keeps a pool
    of containers ready to go, so new function invocations have very low latency at
    the expense of not scaling to zero when there is no load. What makes Fission special
    is its ability to compose and chain functions through Fission workflows ([https://fission.io/workflows/](https://fission.io/workflows/)).
    This is similar to AWS step functions; other interesting features of Fission include
    the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Fission（[https://fission.io/](https://fission.io/)）是来自Platform9的开源无服务器框架，支持多种语言，如Python、NodeJS、Go、C#和PHP。它可以扩展以支持其他语言。它保持一组准备就绪的容器，因此新的函数调用具有非常低的延迟，但在没有负载时无法实现零缩放。Fission特别之处在于它能够通过Fission工作流（[https://fission.io/workflows/](https://fission.io/workflows/)）组合和链接函数。这类似于AWS步函数；Fission的其他有趣特性包括以下内容：
- en: It can integrate with Istio for monitoring.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以与Istio集成进行监控。
- en: It can incorporate logs into the CLI through Fluentd integration (Fluentd is
    automatically installed as a DaemonSet).
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以通过Fluentd集成将日志整合到CLI中（Fluentd会自动安装为DaemonSet）。
- en: It offers Prometheus integration for metrics collection and dashboard visibility.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了Prometheus集成，用于指标收集和仪表板可见性。
- en: Kubeless
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubeless
- en: Kubeless is another Kubernetes-native framework from Bitnami. It uses a conceptual
    model of functions, triggers, and runtimes, which are implemented using Kubernetes
    CRDs that are configured through ConfigMaps. Kubeless uses Kubernetes deployments
    for function pods, and **Horizontal Pod Autoscaler** (**HPA**) for autoscaling.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Kubeless是Bitnami推出的另一个Kubernetes原生框架。它使用函数、触发器和运行时的概念模型，这些模型是使用通过ConfigMaps配置的Kubernetes
    CRD实现的。Kubeless使用Kubernetes部署来部署函数pod，并使用**Horizontal Pod Autoscaler**（**HPA**）进行自动缩放。
- en: This means that Kubeless doesn't scale to zero because HPA doesn't scale to
    zero at the moment. One of Kubeless's primary claims to fame is its excellent
    UI.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Kubeless不能实现零缩放，因为目前HPA不能实现零缩放。Kubeless最主要的亮点之一是其出色的用户界面。
- en: OpenFaas
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenFaas
- en: OpenFaas ([https://www.openfaas.com/](https://www.openfaas.com/)) is one of
    the earliest FaaS projects. It can run on Kubernetes or Docker Swarm. Since it's
    cross-platform, it does a lot of things in a generic and non-Kubernetes way. For
    example, it can scale to zero by using its own management for function containers.
    It also supports many languages and even plain binaries as functions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: OpenFaas（[https://www.openfaas.com/](https://www.openfaas.com/)）是最早的FaaS项目之一。它可以在Kubernetes或Docker
    Swarm上运行。由于它是跨平台的，它以通用的非Kubernetes方式执行许多操作。例如，它可以通过使用自己的函数容器管理来实现零缩放。它还支持许多语言，甚至支持纯二进制函数。
- en: It also has the OpenFaaS Cloud project, which is a complete GitOps-based CI/CD
    pipeline to manage your serverless functions. Similar to other serverless function
    projects, OpenFaas has its own CLI and UI for management and deployment.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有OpenFaaS Cloud项目，这是一个完整的基于GitOps的CI/CD流水线，用于管理您的无服务器函数。与其他无服务器函数项目类似，OpenFaas有自己的CLI和UI用于管理和部署。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced link checking to Delinkcious and we did it in
    style! We discussed the serverless scene, including its two common meanings; that
    is, not dealing with instances, nodes, or servers, and cloud functions as a service.
    We then implemented a loosely coupled solution within Delinkcious for link checking,
    which took advantage of our NATS messaging system to distribute events when links
    are checked. Then, we covered Nuclio in some detail and used it to close the loop
    and let the `LinkManager` initiate link checks on a serverless function and get
    notified later to update the link status.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们以一种时尚的方式为Delinkcious引入了链接检查！我们讨论了无服务器场景，包括它的两个常见含义；即不处理实例、节点或服务器，以及云函数作为服务。然后，我们在Delinkcious中实现了一个松散耦合的解决方案，利用我们的NATS消息系统来在链接被检查时分发事件。然后，我们详细介绍了Nuclio，并使用它来闭环，并让`LinkManager`启动无服务器函数进行链接检查，并稍后得到通知以更新链接状态。
- en: Finally, we surveyed many other solutions and frameworks for serverless functions
    on Kubernetes. At this point, you should have a solid understanding of what serverless
    computing and serverless functions are all about. You should be able to make an
    informed decision about whether your systems and projects can benefit from serverless
    functions and which solution is the best. It's clear that the benefits are real,
    and that it's not a fad that will disappear. I anticipate that the serverless
    solutions in Kubernetes will consolidate (possibly around KNative) and become
    a cornerstone of most Kubernetes deployments, even if they are not part of core
    Kubernetes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调查了许多其他解决方案和Kubernetes上的无服务器函数框架。在这一点上，您应该对无服务器计算和无服务器函数有一个扎实的了解。您应该能够就您的系统和项目是否可以从无服务器函数中受益以及哪种解决方案最佳做出明智的决定。很明显，这些好处是真实的，而且这不是一个会消失的时尚。我预计Kubernetes中的无服务器解决方案将
    consolide（可能围绕KNative）并成为大多数Kubernetes部署的基石，即使它们不是核心Kubernetes的一部分。
- en: In the next chapter, we will go back to the basics and explore one of my favorite
    subjects, that is, testing. Testing can make or break large projects and there
    are many lessons to apply in the context of microservices and Kubernetes.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到基础知识，并探讨我最喜欢的一个主题，即测试。测试可以成就或毁掉大型项目，在微服务和Kubernetes的背景下有许多经验教训可以应用。
- en: Further reading
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多阅读
- en: 'You can refer to the following references for more information:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下参考资料以获取更多信息：
- en: '**Nuclio documentation**: [https://nuclio.io/docs/latest](https://nuclio.io/docs/latest)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Nuclio文档: [https://nuclio.io/docs/latest](https://nuclio.io/docs/latest)'
- en: '**Kubernetes (Jobs – Run to Completion)**: [https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/](https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kubernetes（作业-运行完成）: [https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/](https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/)'
- en: '**CronJob**: [https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CronJob: [https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/)'
- en: '**KNative**: [https://cloud.google.com/knative/](https://cloud.google.com/knative/)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'KNative: [https://cloud.google.com/knative/](https://cloud.google.com/knative/)'
- en: '**Fission**: [https://fission.io/](https://fission.io/)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Fission: [https://fission.io/](https://fission.io/)'
- en: '**Kubeless**: [https://kubeless.io/](https://kubeless.io/)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kubeless: [https://kubeless.io/](https://kubeless.io/)'
- en: '**OpenFaas**: [https://www.openfaas.com](https://www.openfaas.com)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'OpenFaas: [https://www.openfaas.com](https://www.openfaas.com)'
