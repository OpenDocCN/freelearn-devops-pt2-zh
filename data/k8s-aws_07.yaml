- en: A Production-Ready Cluster
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个适合生产的集群
- en: In the last chapter, we spent some time thinking about a framework for planning
    a Kubernetes cluster. Hopefully, it should be clear to you that, when building
    a cluster, there are lots of decisions to make based on the requirements of the
    systems you are running.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们花了一些时间思考规划Kubernetes集群的框架。希望对你来说应该很清楚，构建集群时需要根据正在运行的系统的要求做出许多决策。
- en: In this chapter, we will take a much more practical approach to this problem.
    Instead of trying to cover the myriad options available to us, I will start by
    making some choices, and then we will build a fully functional cluster that will
    serve as a base configuration to build upon for many different use cases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将采取更加实际的方法来解决这个问题。我们将不再试图涵盖我们可以使用的众多选项，而是首先做出一些选择，然后构建一个完全功能的集群，作为许多不同用例的基础配置。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Terraform
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform
- en: Preparing node images and a node group
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备节点镜像和节点组
- en: Provisioning add-ons
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置附加组件
- en: Building a cluster
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个集群
- en: The information contained within this chapter is just one possible way that
    you could approach building and managing a cluster. When building a Kubernetes
    cluster, there are many choices to be made, and almost as many tools that could
    be chosen. For the purposes of this chapter, I have chosen to use tools that make
    it simple to illustrate the process of building a cluster. If you or your team
    has a preference for using different tools, then the concepts and architecture
    outlined in this chapter will transfer quite easily to other tools.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中包含的信息只是构建和管理集群的一种可能方式。构建Kubernetes集群时，有许多选择要做，几乎可以选择同样多的工具。出于本章的目的，我选择使用可以简单说明构建集群过程的工具。如果您或您的团队更喜欢使用不同的工具，那么本章中概述的概念和架构将很容易转移到其他工具上。
- en: In this chapter, we are going to launch our cluster in a way that will make
    it more suitable for production workloads. Much of what we do here will be familiar
    to you from [Chapter 3](4e7f067a-f87f-4a36-be63-eb3bde02ba81.xhtml), *Reach for
    the Cloud*, but we are going to build on the process we outlined there in two
    key ways. Firstly, when building infrastructure that you depend on, it is very
    important that you are able to quickly roll out a new instance of your infrastructure
    in a manner that is repeatable. We want to be able to do this because it makes
    it simple to test changes that we want to make to our infrastructure in a risk-free
    way. By automating the provisioning of a Kubernetes cluster, we enable the patterns
    of immutable infrastructure that we previously discussed. Instead of risking upgrading
    or changing our production infrastructure, we can quickly provision a replacement
    cluster that we can then test before moving our workloads to the new cluster.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将以一种更适合生产工作负载的方式启动我们的集群。我们在这里所做的大部分工作都将与第3章“云端之手”中的内容相似，但我们将在两个关键方面进一步完善我们在那里概述的流程。首先，在构建依赖的基础设施时，能够快速部署新的基础设施实例是非常重要的，而且要能够重复进行。我们希望能够做到这一点，因为这样可以简单地测试我们想要对基础设施进行的变更，而且是无风险的。通过自动化Kubernetes集群的配置，我们实现了之前讨论过的不可变基础设施模式。我们可以快速部署一个替代集群，然后在将工作负载迁移到新集群之前进行测试，而不是冒险升级或更改我们的生产基础设施。
- en: In order to achieve this, we are going to use the Terraform infrastructure provisioning
    tool to interact with AWS. Terraform allows us to define our infrastructure as
    code using a programming language of sorts. By defining our infrastructure as
    code, we are able to use tools such as version control and follow other software
    development practices to manage the evolution of our infrastructure.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用Terraform基础设施配置工具与AWS进行交互。Terraform允许我们使用一种类似编程语言的方式将我们的基础设施定义为代码。通过将基础设施定义为代码，我们能够使用诸如版本控制之类的工具，并遵循其他软件开发实践来管理我们基础设施的演变。
- en: In this chapter, we are about to make a lot of decisions about what a Kubernetes
    cluster running on AWS should look like and how it should be managed. For the
    purposes of this chapter and the example that we will be dealing with, I have
    the following requirements in mind.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做出许多关于在AWS上运行的Kubernetes集群应该是什么样子以及如何管理的决定。对于本章和我们将要处理的示例，我心中有以下要求。
- en: '**Illustrative**: We will see what a Kubernetes cluster that meets the requirements
    of an average production use case might look like. This cluster reflects the decisions
    that I have personally taken when designing Kubernetes clusters that are intended
    for real production use. In order to make this chapter as clear and easy to understand
    as I can, I have tried to keep the cluster and its configuration as simple as
    possible.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**说明性**：我们将看到符合平均生产用例要求的Kubernetes集群是什么样子。这个集群反映了我在设计用于真实生产的Kubernetes集群时所做的决定。为了使本章尽可能清晰易懂，我尽量保持集群及其配置尽可能简单。'
- en: '**Flexible**: We will create something that you can treat as a template and
    add to or alter to meet your needs.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：我们将创建一些您可以视为模板并添加或更改以满足您需求的东西。'
- en: '**Extendable**: Whenever you are designing a Kubernetes cluster (or indeed
    any infrastructure), you should think about the decisions that you make now that
    might prevent you from extending or expanding that infrastructure later.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：无论您设计Kubernetes集群（或者任何基础设施），都应该考虑您现在所做的决定可能会阻止您以后扩展或扩展该基础设施。'
- en: Clearly, when you are building your own cluster, you should have a much more
    concrete idea of your requirements so that you will be able to tailor your cluster
    to your own needs. The cluster we will build here will be a great starting point
    for any production-ready system that you can then customize and add to as required.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当您构建自己的集群时，您应该对自己的需求有一个更加具体的想法，这样您就能够根据自己的需求定制您的集群。我们将在这里构建的集群将是任何生产就绪系统的绝佳起点，然后您可以根据需要自定义和添加。
- en: Much of the configuration in this chapter has been shortened. You can check
    out the full configuration used in this chapter at [https://github.com/PacktPublishing/Kubernetes-on-AWS/tree/master/chapter07](https://github.com/PacktPublishing/Kubernetes-on-AWS/tree/master/chapter07).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多配置都已经被缩短了。您可以在[https://github.com/PacktPublishing/Kubernetes-on-AWS/tree/master/chapter07](https://github.com/PacktPublishing/Kubernetes-on-AWS/tree/master/chapter07)查看本章中使用的完整配置。
- en: Getting started with Terraform
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Terraform
- en: Terraform is a command-line tool that you can run on your workstation to make
    changes to your infrastructure. Terraform is a single binary that just needs to
    be installed onto your path.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform是一个命令行工具，您可以在工作站上运行它来对基础设施进行更改。Terraform是一个单一的二进制文件，只需安装到您的路径上即可。
- en: You can download Terraform from [https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html) for
    six different operating systems, including macOS, Windows, and Linux. Download
    the ZIP file for your operating system, extract it, and then copy the Terraform
    binary to a location on your path.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)下载Terraform，支持六种不同的操作系统，包括macOS、Windows和Linux。下载适用于您操作系统的ZIP文件，解压缩，然后将Terraform二进制文件复制到您的路径上。
- en: Terraform uses files with the `.tf` extension to describe your infrastructure.
    Because Terraform supports the management of resources on many different cloud
    platforms, it can contain the concepts of the relevant providers, which are loaded
    as required to support the different APIs exposed by the different cloud providers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform使用扩展名为`.tf`的文件来描述您的基础架构。因为Terraform支持在许多不同的云平台上管理资源，它可以包含相关提供者的概念，这些提供者根据需要加载，以支持不同云提供商提供的不同API。
- en: 'First, let''s configure the AWS Terraform provider in order to be ready to
    build a Kubernetes cluster. Create a new directory to hold the Terraform configuration
    for your Kubernetes cluster, and then create a file where we will configure the
    AWS provider, as shown in the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们配置AWS Terraform提供者，以便准备构建一个Kubernetes集群。创建一个新目录来保存Kubernetes集群的Terraform配置，然后创建一个文件，在其中我们将配置AWS提供者，如下所示的代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Save the file, and then run the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，然后运行以下命令：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you use a supported provider, Terraform can discover and download the required
    plugin for you. Note that we have already configured the provider with an AWS
    region of `us-west-2`, as this is the region where we will be launching our cluster
    in this example.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用支持的提供者时，Terraform可以发现并下载所需的插件。请注意，我们已经配置了提供者的AWS区域为`us-west-2`，因为这是我们在本例中将要启动集群的区域。
- en: In order for Terraform to communicate with the AWS API, you will need to provide
    the AWS provider with some credentials. We learned how to obtain credentials in
    [Chapter 3](4e7f067a-f87f-4a36-be63-eb3bde02ba81.xhtml), *Reach for the Cloud*.
    If you followed the advice in [Chapter 3](4e7f067a-f87f-4a36-be63-eb3bde02ba81.xhtml), *Reach
    for the Cloud*, and set your credentials up with the `aws configure` command,
    then Terraform will read your default credentials from your local config file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Terraform与AWS API通信，您需要为AWS提供者提供一些凭据。我们在[第3章](4e7f067a-f87f-4a36-be63-eb3bde02ba81.xhtml)中学习了如何获取凭据，*云的探索*。如果您遵循了[第3章](4e7f067a-f87f-4a36-be63-eb3bde02ba81.xhtml)中的建议，并使用`aws
    configure`命令设置了您的凭据，那么Terraform将从您的本地配置文件中读取默认凭据。
- en: Alternatively, Terraform can read AWS credentials from the `AWS_ACCESS_KEY_ID`
    and `AWS_SECRET_ACCESS_KEY` environment variables, or, if you are running Terraform
    on an EC2 instance, it can use the credentials provided by an EC2 instance role.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，Terraform可以从`AWS_ACCESS_KEY_ID`和`AWS_SECRET_ACCESS_KEY`环境变量中读取AWS凭据，或者如果您在EC2实例上运行Terraform，它可以使用EC2实例角色提供的凭据。
- en: It is also possible to statically configure the credentials by adding an `access_key`
    and`secret_key` parameter inline in the AWS provider block, but I wouldn't really
    recommend this practice as it makes it much harder to check your configuration
    into a version control system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过在AWS提供者块中内联添加`access_key`和`secret_key`参数来静态配置凭据，但我并不真的推荐这种做法，因为这样会使得将配置检入版本控制系统变得更加困难。
- en: By default, Terraform uses a local file called `terraform.tfstate` to keep track
    of the state of your infrastructure. This is so that it can keep track of the
    changes you have made to the configuration since you last ran Terraform.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Terraform使用名为`terraform.tfstate`的本地文件来跟踪您基础架构的状态。这样可以跟踪自上次运行Terraform以来对配置所做的更改。
- en: If you are going to be the only person managing your infrastructure, then this
    might be acceptable, but you would need to securely back up the state file. It
    should be considered sensitive, and Terraform won't function correctly if you
    lose it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将是唯一管理基础架构的人，那么这可能是可以接受的，但你需要安全地备份状态文件。它应被视为敏感信息，如果丢失，Terraform将无法正常运行。
- en: If you are using AWS, I would recommend using S3 as a backend. You can read
    about how to set this up in the Terraform documentation at [https://www.terraform.io/docs/backends/types/s3.html](https://www.terraform.io/docs/backends/types/s3.html).
    If configured correctly, S3 storage is highly secure, and if you are working on
    a team, then you can utilize a DynamoDB table as a lock to ensure that multiple
    instances of Terraform are not running at the same time. If you want to make use
    of this, set the configuration in the `backend.tf` file, otherwise delete that
    file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用AWS，我建议使用S3作为后端。您可以在Terraform文档中阅读如何设置这一点，网址为[https://www.terraform.io/docs/backends/types/s3.html](https://www.terraform.io/docs/backends/types/s3.html)。如果配置正确，S3存储是非常安全的，如果您正在团队中工作，那么您可以利用DynamoDB表作为锁，以确保多个Terraform实例不会同时运行。如果您想使用这个功能，请在`backend.tf`文件中设置配置，否则删除该文件。
- en: Variables
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: Terraform allows us to define variables in order to make our configuration more
    reusable. This is particularly useful if you later want to use your configuration
    as a module in order to define multiple clusters. We won't cover that in this
    chapter, but we can follow best practices and define some key variables to allow
    you to simply shape the cluster to meet your needs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform允许我们定义变量，以使我们的配置更具重用性。如果以后您想要将您的配置用作模块来定义多个集群，这将特别有用。我们不会在本章中涵盖这一点，但我们可以遵循最佳实践并定义一些关键变量，以便您可以简单地塑造集群以满足您的需求。
- en: It is standard to create a `variables.tf` file to include all of the variables
    in your project. This is helpful because it acts as high-level documentation about
    how your configuration can be controlled.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`variables.tf`文件来包含项目中的所有变量是标准的。这很有帮助，因为它作为关于如何控制您的配置的高级文档。
- en: 'As you can see, between choosing descriptive names for my variables and adding
    the optional description field, the whole file is quite self-explanatory. Because
    I have provided defaults for each variable, we can run Terraform without passing
    any values for these variables, as shown in the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，选择变量的描述性名称并添加可选的描述字段之间，整个文件都相当自解释。因为我为每个变量提供了默认值，所以我们可以在不传递这些变量的任何值的情况下运行Terraform，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Networking
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络
- en: We will start by creating a config file to describe the network setup for our
    Kubernetes cluster. You might recognize the design of this network, as it is quite
    similar the one we manually created in [Chapter 3](4e7f067a-f87f-4a36-be63-eb3bde02ba81.xhtml),
    *Reach for the Cloud*, but with a few additions to make it more suitable for a
    production setup.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个配置文件来描述我们的Kubernetes集群的网络设置。您可能会注意到这个网络的设计，因为它与我们在[第3章](4e7f067a-f87f-4a36-be63-eb3bde02ba81.xhtml)中手动创建的网络非常相似，但是增加了一些内容，使其更适合生产环境。
- en: Terraform configuration files can be documented with comments, and to better
    illustrate this configuration, I have provided some commentary in the form of
    comments. You will notice that they are surrounded by `/*` and `*/`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform配置文件可以用注释进行文档化，为了更好地说明这个配置，我提供了一些注释形式的评论。你会注意到它们被`/*`和`*/`包围着。
- en: 'In order to support high availability, we are going to create subnets for more
    than one availability zone, as shown in the following code. Here, we are using
    two, but if you wanted even greater resiliency, you can easily add another availability
    zone to the `availability_zones` variable:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持高可用性，我们将为多个可用区域创建子网，如下面的代码所示。在这里，我们使用了两个，但如果您想要更高的弹性，您可以轻松地将另一个可用区域添加到`availability_zones`变量中：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are going to provision two subnets for each of the availability zones we
    are using for our cluster. A public subnet which have a direct route to the internet
    where Kubernetes will provision load balancers that are accessible to the internet.
    And a private subnet that will be used by Kubernetes to assign IP addresses to
    pods.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们集群使用的每个可用区域提供两个子网。一个公共子网，它可以直接连接到互联网，Kubernetes将在其中提供可供互联网访问的负载均衡器。还有一个私有子网，Kubernetes将用它来分配给pod的IP地址。
- en: Because the address space available in the private subnets will be the limiting
    factor on the number of pods that Kubernetes will be able to launch, we provision
    a large address range with 16382 available IP addresses. This should allow our
    cluster some room for expansion.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因为私有子网中可用的地址空间将是Kubernetes能够启动的pod数量的限制因素，所以我们为其提供了一个大的地址范围，其中有16382个可用的IP地址。这应该为我们的集群提供一些扩展空间。
- en: If you are only planning to run internal services that are not be accessible
    to the internet, then you might be able to skip the public subnets. You can find
    the full `networking.tf` file in the example files for this chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只打算运行对外部不可访问的内部服务，那么您可能可以跳过公共子网。您可以在本章的示例文件中找到完整的`networking.tf`文件。
- en: Plan and apply
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计划和应用
- en: Terraform allows us to incrementally build our infrastructure by adding to and
    changing the code that defines it. Then if you wish, as you go through this chapter,
    you can build up your configuration piece by piece, or you can use Terraform to
    build your whole cluster in one go.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform允许我们通过添加和更改定义基础设施的代码来逐步构建我们的基础设施。然后，如果您希望，在阅读本章时，您可以逐步构建您的配置，或者您可以使用Terraform一次性构建整个集群。
- en: Whenever you use Terraform to make a change to your infrastructure, it first
    produces a plan of the changes that it is going to make, and then it applies this
    plan. This two-stage operation is ideal when modifying production infrastructure
    as it gives you the opportunity to review the changes that will actually be applied
    to your cluster before they are made.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您使用Terraform对基础设施进行更改时，它首先会生成一个将要进行的更改的计划，然后应用这个计划。这种两阶段的操作在修改生产基础设施时是理想的，因为它可以让您在实际应用到集群之前审查将要应用的更改。
- en: Once you have saved your networking configuration to a file, we can follow a
    few steps to safely provision our infrastructure.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将网络配置保存到文件中，我们可以按照一些步骤安全地为我们的基础设施提供。
- en: 'We can check for syntax errors in the configuration by running the following
    command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令来检查配置中的语法错误：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If your configuration is good, then there will be no output, but if there are
    syntax errors with your file(s), you should see an error message explaining the
    issue. For example, a missing closing brace might cause an error such as `Error
    parsing networking.tf: object expected closing RBRACE got: EOF`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您的配置正确，那么不会有输出，但如果您的文件存在语法错误，您应该会看到一个解释问题的错误消息。例如，缺少闭合括号可能会导致错误，如`Error parsing
    networking.tf: object expected closing RBRACE got: EOF`。'
- en: 'Once you have ensured that your files are correctly formatted for Terraform,
    you can create a plan for the changes to your infrastructure using the following
    command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您确保您的文件已正确格式化为Terraform，您可以使用以下命令为您的基础设施创建变更计划：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This command will output a summary of the changes that will be made to your
    infrastructure if this plan is run. The `-out` flag is optional, but it is a good
    idea because it allows us to apply exactly these changes later on. If you were
    paying attention to the output when you ran the Terraform plan, then you should
    have seen a message like:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将输出一个摘要，显示如果运行此计划将对基础架构进行的更改。`-out`标志是可选的，但这是一个好主意，因为它允许我们稍后应用这些更改。如果您在运行Terraform计划时注意输出，那么您应该已经看到了这样的消息：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you run `terraform apply` with a precomputed plan, it will make the changes
    that were outlined when the plan was generated. You could also run `terraform
    plan` command without pregenerating a plan, but in this case, it will still plan
    the changes and then prompt you before applying them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用预先计算的计划运行`terraform apply`时，它将进行在生成计划时概述的更改。您也可以运行`terraform plan`命令而不预先生成计划，但在这种情况下，它仍将计划更改，然后在应用更改之前提示您。
- en: Terraform computes the dependencies between the different resources in your
    infrastructure—for example, it ensures that the VPC is created before the route
    tables and other resources are created. Some resources can take a few seconds
    to create, but Terraform will wait until they are available before moving on to
    create dependent resources.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform计算基础架构中不同资源之间的依赖关系，例如，它确保在创建路由表和其他资源之前先创建VPC。一些资源可能需要几秒钟才能创建，但Terraform会等待它们可用后再继续创建依赖资源。
- en: If you want to remove a resource that Terraform has created in your AWS account,
    you can just delete the definition from the relevant `.tf` file and then plan
    and apply your changes. When you are testing a Terraform configuration, it can
    be useful to remove all of the resources created by a particular configuration
    in order to test provisioning your infrastructure from scratch. If you need to
    do this, the `terraform destroy` command is very useful; it will remove all of
    the resources that are defined in your Terraform files from your infrastructure.
    However, be aware that this could cause essential resources to be terminated and
    removed, and so you shouldn't use this method on a running production system.
    Before any resources are removed, Terraform will list them and then ask you whether
    you want to remove them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想删除Terraform在您的AWS帐户中创建的资源，只需从相关的`.tf`文件中删除定义，然后计划并应用您的更改。当您测试Terraform配置时，删除特定配置创建的所有资源可能很有用，以便测试从头开始配置基础架构。如果需要这样做，`terraform
    destroy`命令非常有用；它将从基础架构中删除在Terraform文件中定义的所有资源。但是，请注意，这可能导致关键资源被终止和删除，因此您不应该在运行中的生产系统上使用此方法。在删除任何资源之前，Terraform将列出它们，然后询问您是否要删除它们。
- en: Control Plane
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制平面
- en: In order to provide a resilient and reliable Kubernetes Control Plane for our
    cluster, we are going to make our first big departure from the simple cluster
    that we built in [Chapter 3](4e7f067a-f87f-4a36-be63-eb3bde02ba81.xhtml), *Reach
    for the Cloud*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们的集群提供一个弹性和可靠的Kubernetes控制平面，我们将首次大幅偏离我们在[第3章](4e7f067a-f87f-4a36-be63-eb3bde02ba81.xhtml)中构建的简单集群，*云端的追求*。
- en: As we learned in [Chapter 1](19821a2b-bb32-408d-9f21-256dce5d644e.xhtml), *Google's
    Infrastructure for the Rest of Us*, the key components of the Kubernetes Control
    Plane are the backing etcd store, the API server, the scheduler, and the controller
    manager. If we want to build and manage a resilient control plane, we need to
    manage running these components across multiple instances, ideally spread across
    several availability zones.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](19821a2b-bb32-408d-9f21-256dce5d644e.xhtml)中所学到的，“谷歌的基础设施服务于我们其他人”，Kubernetes控制平面的关键组件是支持etcd存储、API服务器、调度程序和控制器管理器。如果我们想要构建和管理一个弹性的控制平面，我们需要跨多个实例管理这些组件，最好分布在多个可用区。
- en: Because the API server is stateless, and the scheduler and controller manager
    have built-in leader election facilities, it is relatively simple to run multiple
    instances on AWS, for example, by using an autoscaling group.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于API服务器是无状态的，并且调度程序和控制器管理器具有内置的领导者选举功能，因此在AWS上运行多个实例相对简单，例如，通过使用自动扩展组。
- en: Running production-grade etcd is slightly trickier because etcd should be carefully
    managed when adding or removing nodes to avoid data loss and downtime. Successfully
    running an etcd cluster is quite a difficult task on AWS, and requires either
    manual operation or complex automation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 运行生产级别的etcd略微棘手，因为在添加或删除节点时，应小心管理etcd以避免数据丢失和停机。在AWS上成功运行etcd集群是一项相当困难的任务，需要手动操作或复杂的自动化。
- en: Luckily for us, AWS has developed a service that removes nearly all of the operational
    complexity involved in provisioning the Kubernetes Control Plane—**Amazon EKS**,
    or to use the full name, the Amazon Elastic Container Service for Kubernetes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，AWS开发了一项服务，几乎消除了在配置Kubernetes控制平面时涉及的所有操作复杂性——Amazon EKS，或者使用全名，亚马逊弹性容器服务用于Kubernetes。
- en: With EKS, AWS will manage and run the components that make up the Kubernetes
    Control Plane on your behalf across multiple availability zones, thus avoiding
    any single points of failure. With EKS, you no longer have to worry about performing
    or automating the operational tasks required for running a stable etcd cluster.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过EKS，AWS将代表您在多个可用区管理和运行组成Kubernetes控制平面的组件，从而避免任何单点故障。有了EKS，您不再需要担心执行或自动化运行稳定etcd集群所需的操作任务。
- en: We should bear in mind that, with EKS, a key part of the infrastructure of our
    cluster is now managed by a third party. You should be comfortable with the fact
    that AWS can do a better job than your own team of providing a resilient control
    plane. This doesn't preclude you from designing your cluster to be somewhat resistant
    to the failure of the control plane—for example, if the kubelet cannot connect
    to the control plane, then the running containers will remain running until the
    control plane becomes available again. You should make sure that any additional
    components you add to your cluster can cope with temporary downtime in a similar
    fashion.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该牢记，使用EKS时，我们集群基础设施的关键部分现在由第三方管理。您应该对AWS能够比您自己的团队更好地提供弹性控制平面感到满意。这并不排除您设计集群以在控制平面故障时具有一定的抗性的可能性——例如，如果kubelet无法连接到控制平面，那么正在运行的容器将保持运行，直到控制平面再次可用。您应该确保您添加到集群中的任何其他组件都能以类似的方式应对临时停机。
- en: EKS reduces the amount of effort required to manage the most complex parts of
    Kubernetes (the control plane), thereby reducing the time (and money) required
    to design your cluster, and to maintain it. Moreover, for even a modestly sized
    cluster, the cost of the EKS service is significantly lower than the equivalent
    cost of running your own control plane across multiple EC2 instances.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: EKS减少了管理Kubernetes最复杂部分（控制平面）所需的工作量，从而减少了设计集群和维护集群所需的时间（和金钱）。此外，即使是规模适中的集群，EKS服务的成本也明显低于在多个EC2实例上运行自己的控制平面的成本。
- en: In order for the Kubernetes Control Plane to manage resources in your AWS account,
    you need to provide EKS with an IAM role that will be assumed by EKS itself.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Kubernetes控制平面管理AWS账户中的资源，你需要为EKS提供一个IAM角色，EKS本身将扮演这个角色。
- en: EKS creates network interfaces within your VPC to allow the Kubernetes Control
    Plane to communicate with the kubelet in order to provide services such as **log
    streaming** and **exec**. To control this communication, we need to supply EKS
    with a security group when it is launched. You can find the full Terraform configuration
    used to provision the control plane in `control_plane.tf` in the example files
    for this chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: EKS在你的VPC中创建网络接口，以允许Kubernetes控制平面与kubelet通信，从而提供**日志流**和**执行**等服务。为了控制这种通信，我们需要在启动时为EKS提供一个安全组。你可以在本章的示例文件中的`control_plane.tf`中找到用于配置控制平面的完整Terraform配置。
- en: We can use the Terraform resource for the EKS cluster to query it in order to
    fetch the endpoint for the Kubernetes API and the certificate authority that is
    used to access it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Terraform资源来查询EKS集群，以获取用于访问Kubernetes API的端点和证书颁发机构。
- en: This information, combined with Terraform's templating facilities, allows us
    to generate a `kubeconfig` file with the information required to connect to the
    Kubernetes API provided by EKS. We can use this later to provision add-on components.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息，结合Terraform的模板功能，允许我们生成一个`kubeconfig`文件，其中包含连接到EKS提供的Kubernetes API所需的信息。我们以后可以使用这个文件来配置附加组件。
- en: 'If you want, you could also use this file to connect to the cluster manually
    with kubectl, either by copying the file to the default location at `~/.kube/config`
    or by passing its location to kubectl with the `--kubeconfig` flag or the `KUBECONFIG`
    environment variable, as shown in the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你也可以使用这个文件手动连接到集群，使用kubectl命令，可以通过将文件复制到默认位置`~/.kube/config`，或者通过`--kubeconfig`标志或`KUBECONFIG`环境变量传递其位置给kubectl，如下面的代码所示：
- en: 'The `KUBECONFIG` environment variable can be useful if you are managing multiple
    clusters, as you can easily load multiple configs by separating their paths; for
    example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`KUBECONFIG`环境变量在管理多个集群时非常有用，因为你可以通过分隔它们的路径轻松加载多个配置；例如：'
- en: '`export KUBECONFIG=$HOME/.kube/config:/path/to/other/conf`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将KUBECONFIG环境变量设置为`$HOME/.kube/config:/path/to/other/conf`。
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Preparing node images
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备节点镜像
- en: As we did in [Chapter 3](4e7f067a-f87f-4a36-be63-eb3bde02ba81.xhtml), *Reach
    for the Cloud*, we will now be preparing an AMI for the worker nodes in our cluster.
    However, we will improve this process by automating it with **Packer**. Packer
    is a tool that makes it simple to build machine images on AWS (and other platforms).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[第3章](4e7f067a-f87f-4a36-be63-eb3bde02ba81.xhtml)中所做的那样，*云端之手*，我们现在将为集群中的工作节点准备一个AMI。但是，我们将通过**Packer**自动化这个过程。Packer是一个在AWS（和其他平台）上构建机器镜像的简单工具。
- en: Installing Packer
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Packer
- en: Just like Terraform, Packer is distributed as a single binary that just needs
    to be copied to a location on your path. You can find detailed installation instructions
    on the Packer website at [https://www.packer.io/intro/getting-started/install.html](https://www.packer.io/intro/getting-started/install.html).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Terraform一样，Packer被分发为一个单一的二进制文件，只需将其复制到您的路径上。您可以在Packer网站上找到详细的安装说明[https://www.packer.io/intro/getting-started/install.html](https://www.packer.io/intro/getting-started/install.html)。
- en: Once you have installed Packer, you can run `packer version` to check that you
    have correctly copied it into to your path.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Packer之后，您可以运行`packer version`来检查您是否已经正确地将其复制到您的路径上。
- en: Packer configuration
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Packer配置
- en: Packer is configured with a JSON-formatted configuration file, that you can
    see at `ami/node.json`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Packer配置为一个JSON格式的配置文件，您可以在`ami/node.json`中看到。
- en: There are three parts to the example configuration here. The first is a list
    of variables. Here, we are using variables to store the version numbers of the
    important software that we are going to install in our image. This will make it
    simple to build and test images with updated versions of the Kubernetes software
    when it becomes available in the future.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的示例配置有三个部分。第一个是变量列表。在这里，我们使用变量来存储我们将在镜像中安装的重要软件的版本号。这将使得在将来可用时，构建和测试具有更新版本的Kubernetes软件的镜像变得简单。
- en: The second part of the configuration configures the builder. Packer allows us
    to choose to build our image with one or more builders that support building images
    for different cloud providers. Since we want to build an image to use on AWS,
    we are using the `amazon-ebs` builder, which creates an image by launching a temporary
    EC2 instance and then creating an AMI from the contents of its root EBS volume
    (just like the manual procedure we followed in [Chapter 3](4e7f067a-f87f-4a36-be63-eb3bde02ba81.xhtml),
    *Reach for the Cloud*). This builder configuration allows us to choose the base
    image that our machine will be based on; here, we are using an official Ubuntu
    server image, a trusted source. The `ami-name` field in the builder configuration
    defines the name that the outputted image will be given. We have included the
    version of the Kubernetes software used and a timestamp to ensure that this image
    name is unique. Having a unique image name lets us define precisely which image
    to use when we deploy servers using it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的第二部分配置了构建器。Packer允许我们选择使用一个或多个构建器来构建支持不同云提供商的镜像。由于我们想要构建一个用于AWS的镜像，我们使用了`amazon-ebs`构建器，它通过启动临时EC2实例然后从其根EBS卷的内容创建AMI来创建镜像（就像我们在[第3章](4e7f067a-f87f-4a36-be63-eb3bde02ba81.xhtml)中遵循的手动过程，*云的到来*）。这个构建器配置允许我们选择我们的机器将基于的基础镜像；在这里，我们使用了官方的Ubuntu服务器镜像，一个可信的来源。构建器配置中的`ami-name`字段定义了输出镜像将被赋予的名称。我们已经包含了所使用的Kubernetes软件的版本和时间戳，以确保这个镜像名称是唯一的。拥有唯一的镜像名称让我们能够精确地定义在部署服务器时使用哪个镜像。
- en: Finally, we configure a provisioner to install the software that our image will
    require. Packer supports many different provisioners that can install software,
    including full configuration-management systems such as Chef or Ansible. To keep
    this example simple, we will automate the installation of the software that we
    need by using a shell script. Packer will upload the configured script to the
    builder instance and then execute it via SSH.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们配置了一个provisioner来安装我们的镜像所需的软件。Packer支持许多不同的provisioners，可以安装软件，包括诸如Chef或Ansible之类的完整配置管理系统。为了保持这个示例简单，我们将使用一个shell脚本来自动安装我们需要的软件。Packer将上传配置的脚本到构建实例，然后通过SSH执行它。
- en: We are just using a simple shell script, but if your organization already has
    a configuration-management tool in use, then you might prefer to use that to install
    the software that your image needs, especially as it makes it simple to include
    your organization's base configuration.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是使用一个简单的shell脚本，但如果您的组织已经在使用配置管理工具，那么您可能更喜欢使用它来安装您的镜像所需的软件，特别是因为它可以简单地包含您组织的基本配置。
- en: In this script, we are installing the software and configuration that our worker
    nodes will need to join an EKS cluster and function correctly, as shown in the
    following list. In a real deployment, there may be other tools and configurations
    that you wish to add in addition to these.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们正在安装我们的工作节点将需要加入EKS集群并正确运行的软件和配置，如下面的列表所示。在实际部署中，可能还有其他工具和配置，您希望除了这些之外添加。
- en: '**Docker**: Docker is currently the best tested and most common container runtime
    to use with Kubernetes'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：Docker目前是与Kubernetes一起使用的经过最全面测试和最常见的容器运行时'
- en: '**kubelet**: The Kubernetes node agent'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubelet**：Kubernetes节点代理'
- en: '**ekstrap**: Configures the kubelet to connect to the EKS cluster endpoint'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ekstrap**：配置kubelet连接到EKS集群端点'
- en: '**aws-iam-authenticator**: Allows the node to authenticate with the EKS cluster
    using the node''s IAM credentials'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**aws-iam-authenticator**：允许节点使用节点的IAM凭据与EKS集群进行身份验证'
- en: 'We install these elements using the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码安装这些元素：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once you have prepared the configuration for Packer, you can use the `packer
    build` command to build the AMI in your AWS account, as shown in the following
    code. This will start a temporary EC2 instance. Save the new AMI into your account
    and clean up the temporary instance:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您为Packer准备好配置，您可以使用`packer build`命令在您的AWS账户中构建AMI，如下面的代码所示。这将启动一个临时的EC2实例。将新的AMI保存到您的账户中，并清理临时实例：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If your organization uses a continuous integration service, you might want to
    configure it to build your node image on a regular schedule in order to pick up
    security updates to the base operating system.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的组织使用持续集成服务，您可能希望配置它以便定期构建您的节点镜像，以便获取基本操作系统的安全更新。
- en: Node group
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点组
- en: Now that we have prepared an image for the worker nodes in our cluster, we can
    set up an autoscaling group to manage the launching of the EC2 instances that
    will form our cluster.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为集群中的工作节点准备好了一个镜像，我们可以设置一个自动扩展组来管理启动EC2实例，这些实例将组成我们的集群。
- en: EKS doesn't tie us to managing our nodes in any particular way, so autoscaling
    groups are not the only option for managing the nodes in our cluster, but using
    them is one of the simplest ways of managing multiple worker instances in our
    cluster.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: EKS不会限制我们以任何特定的方式管理我们的节点，因此自动扩展组并不是管理集群中节点的唯一选项，但使用它们是管理集群中多个工作实例的最简单方式之一。
- en: If you wanted to use multiple instance types in your cluster, you could repeat
    the launch configuration and autoscaling group configuration for each instance
    type that you wanted to use. In this configuration, we are launching `c5.large`
    instances on demand, but you should refer back to [Chapter 6](cb29a916-0f55-4fa9-816d-2322a86e1ccc.xhtml), *Planning
    for Production*, for more information about choosing appropriate instance sizes
    for your cluster.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在集群中使用多种实例类型，您可以为您想要使用的每种实例类型重复启动配置和自动扩展组配置。在这个配置中，我们正在按需启动`c5.large`实例，但您应该参考[第6章](cb29a916-0f55-4fa9-816d-2322a86e1ccc.xhtml)
    *生产规划*，了解有关为您的集群选择适当实例大小的更多信息。
- en: 'The first part of the configuration sets up an IAM role for our instances to
    use. This is simple because AWS provides managed policies that have the permissions
    required by Kubernetes. The `AmazonEKSWorkerNodePolicy` code phrase allows the
    kubelet to query information about EC2 instances, attached volumes, and network
    settings, and to query information about EKS clusters. The `AmazonEKS_CNI_Policy`
    provides the permissions required by the `vpc-cni-k8s` network plugin to attach
    network interfaces to the instance and assign new IP addresses to those interfaces.
    The `AmazonEC2ContainerRegistryReadOnly` policy allows the instance to pull Docker
    images from the AWS Elastic Container Registry (you can read more about using
    this in [Chapter 10](250f70f9-eb26-41a8-aa97-51563aa16de8.xhtml), *Managing Container
    Images*). We will also manually specify a policy that will allow the `kube2iam`
    tool to assume roles in order to provide credentials to applications running on
    the cluster, as shown in the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的第一部分设置了我们的实例要使用的IAM角色。这很简单，因为AWS提供了托管策略，这些策略具有Kubernetes所需的权限。`AmazonEKSWorkerNodePolicy`代码短语允许kubelet查询有关EC2实例、附加卷和网络设置的信息，并查询有关EKS集群的信息。`AmazonEKS_CNI_Policy`提供了`vpc-cni-k8s`网络插件所需的权限，以将网络接口附加到实例并为这些接口分配新的IP地址。`AmazonEC2ContainerRegistryReadOnly`策略允许实例从AWS
    Elastic Container Registry中拉取Docker镜像（您可以在[第10章](250f70f9-eb26-41a8-aa97-51563aa16de8.xhtml)中了解更多关于使用此功能的信息，*管理容器镜像*）。我们还将手动指定一个策略，允许`kube2iam`工具假定角色，以便为在集群上运行的应用程序提供凭据，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Before our worker nodes can register themselves with the Kubernetes API server,
    they need to have the correct permissions to do so. In EKS, the mapping between
    IAM roles and users is configured by submitting a config map to the cluster.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作节点在能够向Kubernetes API服务器注册之前，需要具有正确的权限。在EKS中，IAM角色和用户之间的映射是通过向集群提交配置映射来配置的。
- en: You can read more about how to map IAM users and roles to Kubernetes permissions
    in the EKS documentation at [https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html](https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在EKS文档中阅读有关如何将IAM用户和角色映射到Kubernetes权限的更多信息，网址为[https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html](https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html)。
- en: 'Terraform will use the `kubeconfig` file that we produced while setting up
    the control plane in order to submit this configuration to the cluster using `kubectl`
    via the local-exec provisioner, as shown in the following `nodes.tf` continued
    code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform将使用我们在设置控制平面时生成的`kubeconfig`文件，通过local-exec provisioner使用`kubectl`将此配置提交到集群，如下面的`nodes.tf`继续的代码所示：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, we need to prepare security groups to control the network traffic to and
    from our nodes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要准备安全组来控制与我们的节点之间的网络流量。
- en: 'We will set up a number of rules to allow the following communication flows
    that are required for our cluster to function correctly:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一些规则，以允许以下通信流，这些流对于我们的集群能够正常运行是必需的：
- en: Nodes need to communicate with each other for intracluster pod and service communication.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点需要相互通信，用于集群内的pod和服务通信。
- en: The Kubelet running on the nodes needs to connect to the Kubernetes API server
    in order to read and update information about the state of the cluster.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行在节点上的Kubelet需要连接到Kubernetes API服务器，以便读取和更新有关集群状态的信息。
- en: The control plane needs to connect to the Kubelet API on port `10250`; this
    is used for functionalities such as `kubectl exec` and `kubectl logs.`
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制平面需要连接到端口`10250`上的Kubelet API；这用于功能，如`kubectl exec`和`kubectl logs`。
- en: In order to use the proxy functionality of the API to proxy traffic to pods
    and services, the control plane needs to connect to pods that are running in the
    cluster. In this example, we are opening all of the ports, but if, for example,
    you only open unprivileged ports on your pods, then you would only need to allow
    traffic to ports above 1024.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使用API的代理功能将流量代理到pod和服务，控制平面需要连接到在集群中运行的pod。在这个例子中，我们打开了所有端口，但是，例如，如果您只在您的pod上打开了非特权端口，那么您只需要允许流量到1024以上的端口。
- en: 'We set these rules up using the following code. The code for `nodes.tf` is
    continued:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码设置这些规则。`nodes.tf`的代码如下：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have prepared the infrastructure to run our nodes, we can prepare
    a launch configuration and assign it to an autoscaling group to actually launch
    our nodes, as shown in the following code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好运行我们的节点的基础设施，我们可以准备一个启动配置并将其分配给一个自动扩展组，以实际启动我们的节点，如下面的代码所示。
- en: 'Clearly, the instance type and disk size I have chosen here might not suit
    your cluster, so you will want to refer back to the information in [Chapter 6](cb29a916-0f55-4fa9-816d-2322a86e1ccc.xhtml), *Planning
    for Production*, when choosing an instance size for your cluster. The disk size
    required will be largely dependent on the average image size of your applications.
    The code for `nodes.tf` is continued:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我在这里选择的实例类型和磁盘大小可能不适合您的集群，因此在选择集群实例大小时，您需要参考[第6章](cb29a916-0f55-4fa9-816d-2322a86e1ccc.xhtml)中的信息，即*生产规划*。所需的磁盘大小将在很大程度上取决于您的应用程序的平均镜像大小。`nodes.tf`的代码如下：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `kubernetes.io/cluster/<node name>` tag is used by the `ekstrap` tool to
    discover the EKS endpoint in order to register the node with the cluster and by
    the `kubelet` to verify that it has connected to the correct cluster.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubernetes.io/cluster/<node name>`标签被`ekstrap`工具用来发现EKS端点以注册节点到集群，并被`kubelet`用来验证它是否已连接到正确的集群。'
- en: Provisioning add-ons
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置附加组件
- en: Much of the power of Kubernetes comes from the fact that it is easy to extend
    by adding additional services to provide additional functionality.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的许多功能来自于它易于通过添加额外的服务来扩展以提供额外的功能。
- en: We are going to look at an example of this by deploying `kube2iam`. This is
    a daemon that runs on every node in our cluster and intercepts calls to the AWS
    metadata service that are made by processes running in our pods.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过部署`kube2iam`来看一个例子。这是一个守护程序，在我们的集群中的每个节点上运行，并拦截由我们的pod中运行的进程发出的对AWS元数据服务的调用。
- en: 'A simple way to provision a service like this is by using a DaemonSet to run
    a pod on every node in the cluster, as shown in the following code. This approach
    is already used in our cluster to deploy the `aws-vpc-cni` networking plugin to
    every node and to run `kube-proxy`, the Kubernetes component that runs on every
    node and that is responsible for routing traffic that is destined for service
    IPs to the underlying pods:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用DaemonSet在集群中的每个节点上运行一个pod来为这样的服务提供服务是一个简单的方法，如下面的代码所示。这种方法已经在我们的集群中用于将`aws-vpc-cni`网络插件部署到每个节点，并运行`kube-proxy`，这是运行在每个节点上的Kubernetes组件，负责将流向服务IP的流量路由到底层pod：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Managing change
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变革管理
- en: Managing your Kubernetes clusters with a tool like Terraform offers a lot of
    advantages over the manual approach that we explored in [Chapter 3](4e7f067a-f87f-4a36-be63-eb3bde02ba81.xhtml),
    *Reach for the Cloud*. Being able to quickly and easily repeat the process of
    provisioning a cluster is very useful when you want to test changes to your configuration,
    or even when you come to upgrade the version of Kubernetes that your cluster is
    running.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像Terraform这样的工具来管理您的Kubernetes集群比我们在[第3章](4e7f067a-f87f-4a36-be63-eb3bde02ba81.xhtml)中探索的手动方法具有许多优势，*云的选择*。当您想要测试对配置的更改，甚至当您要升级集群正在运行的Kubernetes版本时，能够快速轻松地重复配置集群的过程非常有用。
- en: The other key advantage of defining your infrastructure as code, is that you
    can use a version control tool to keep track of the changes that you make to your
    infrastructure over time. One of the key advantages to this is that every time
    you make a change, you can leave a commit message. Decisions that you make now
    might seem obvious, but having a record of why you chose to do something a certain
    way will certainly help you and others who have to work with your configuration
    in the future, especially as those others may not have the same context that you
    had when you made your changes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将基础设施定义为代码的另一个关键优势是，您可以使用版本控制工具随着时间的推移跟踪对基础设施所做的更改。其中一个关键优势是，每次进行更改时，您都可以留下提交消息。您现在做出的决定可能看起来很明显，但记录为什么以某种方式选择做某事将肯定有助于您和其他人在将来与您的配置一起工作，特别是因为那些其他人可能没有在您进行更改时拥有相同的上下文。
- en: A lot has been written about writing good commit messages by many software engineers.
    The best piece of advice is to make sure that you include as much information
    as is required to explain why your change was needed. Your future self will thank
    you if you have to return to the configuration months later.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件工程师已经写了很多关于写好提交消息的东西。最好的建议是确保您包含尽可能多的信息来解释为什么需要进行更改。如果您需要返回到配置几个月后，您未来的自己会感谢您。
- en: 'Consider this commit message:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个提交消息：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Also consider this commit message:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 还要考虑这个提交消息：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first commit message is bad because it just explains what you did, and that
    should be obvious just by looking at how the configuration changed. The second
    message gives a lot more information. Importantly, the second message explains
    why the change needed to be made and gives some information that will be useful
    for anyone making changes to the cluster in the future. Without this important
    context, you might wonder why port `80` was opened and worry about what might
    happen if you changed that information.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个提交消息很糟糕，因为它只是解释了你做了什么，而这应该很明显，只需看看配置如何改变就可以了。第二个消息提供了更多的信息。重要的是，第二个消息解释了为什么需要进行更改，并提供了一些对将来对集群进行更改的人有用的信息。没有这个重要的上下文，您可能会想知道为什么打开了端口`80`，并担心如果更改了该信息会发生什么。
- en: Operating a Kubernetes cluster in a production setting is not just about how
    you launch the cluster on day one; it's about making sure that you can update
    and extend the cluster over time to continue to meet the requirements of your
    organization.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中操作Kubernetes集群不仅仅是关于如何在第一天启动集群；而是确保您可以随着时间的推移更新和扩展集群，以继续满足组织的要求。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'The cluster that we have built in this chapter is still quite simple, and really
    reflects a starting point that we can build upon in the following chapters. However,
    it does meet the following essential requirements for production readiness:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中构建的集群仍然非常简单，实际上反映了我们可以在接下来的章节中建立的起点。然而，它确实满足了生产就绪的以下基本要求：
- en: '**Reliability**: By using EKS, we have provisioned a reliable control plane
    that we can depend upon to manage our cluster.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：通过使用EKS，我们已经配置了一个可靠的控制平面，我们可以依赖它来管理我们的集群。'
- en: '**Scalability**: By operating our nodes via an autoscaling group, we can make
    it simple to add extra capacity to our cluster in seconds.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：通过通过自动扩展组操作我们的节点，我们可以简单地在几秒钟内增加集群的额外容量。'
- en: '**Maintainability**: By defining our infrastructure as code using Terraform,
    we have made it simple to manage our cluster in the future. By setting up a build
    process for the AMI used by our node machines, we are able to quickly rebuild
    the image to pull in security updates and updated versions of our node software.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：通过使用Terraform将我们的基础设施定义为代码，我们已经简化了将来管理我们的集群。通过为我们的节点机器使用的AMI设置构建过程，我们能够快速重建镜像以引入安全更新和更新版本的节点软件。'
