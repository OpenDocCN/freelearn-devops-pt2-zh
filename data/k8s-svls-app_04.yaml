- en: Introducing Kubeless Functioning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Kubeless功能
- en: 'Now that we have our Kubernetes installation up-and-running, we can look at
    running our first serverless applications; we are going to start by installing
    and running Kubeless by working through some examples. We will cover the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的Kubernetes安装已经运行起来了，我们可以开始运行我们的第一个无服务器应用程序；我们将通过一些示例来安装和运行Kubeless。我们将涵盖以下主题：
- en: Installing Kubeless
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Kubeless
- en: Kubeless overview
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubeless概述
- en: Running our first functions using Kubeless—the hello world examples
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubeless运行我们的第一个函数-“hello world”示例
- en: A more advanced example—posting tweets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高级的示例-发布推文
- en: The serverless plugin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器插件
- en: Let's get started by installing Kubeless on our three target operating systems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始在我们的三个目标操作系统上安装Kubeless。
- en: Installing Kubeless
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Kubeless
- en: There are two components to Kubeless; the first is the stack, which runs on
    Kubernetes, and the second part is the command-line client you use to interact
    with your Kubeless cluster.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Kubeless有两个组件；第一个是在Kubernetes上运行的堆栈，第二部分是您用来与Kubeless集群交互的命令行客户端。
- en: We will first look at getting the Kubernetes side of Kubeless up-and-running.
    Once up we will then look at installing the command client on our three target
    operating systems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将看看如何让Kubeless在Kubernetes上运行起来。一旦运行起来，我们将看看如何在我们的三个目标操作系统上安装命令客户端。
- en: The Kubeless Kubernetes cluster
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubeless Kubernetes集群
- en: 'We will be installing Kubeless on the single-node Minikube cluster we installed
    and configured in the previous chapter. The first thing we need to do is ensure
    that we are starting with a clean Kubernetes installation. To do this, we simply
    need to run the following two commands:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在上一章中安装和配置的单节点Minikube集群上安装Kubeless。我们需要做的第一件事是确保我们从一个干净的Kubernetes安装开始。为此，我们只需要运行以下两个命令：
- en: Please remember that running the `minikube delete` command will immediately
    remove your currently running virtual machine without warning, meaning everything
    that is currently active on your Minikube single-node cluster will be lost.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，运行`minikube delete`命令将立即删除当前正在运行的虚拟机，而不会发出警告，这意味着您的Minikube单节点集群上当前活动的所有内容都将丢失。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that we have our fresh single-node Kubernetes cluster up-and-running, we
    need to create a namespace for Kubeless by running:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的新的单节点Kubernetes集群已经运行起来了，我们需要通过运行以下命令为Kubeless创建一个命名空间：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And then install Kubeless itself by running the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过运行以下命令安装Kubeless本身：
- en: At the time of writing, the current version of Kubeless was v0.2.3\. You can
    check for the latest release at the projects, GitHub releases page, which is at
    [https://github.com/kubeless/kubeless/releases](https://github.com/kubeless/kubeless/releases).
    To install a later version simply use the newer releases version number in the
    following URL—however, please be warned that there may be differences in the output
    between versions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Kubeless的当前版本是v0.2.3。您可以在项目的GitHub发布页面[https://github.com/kubeless/kubeless/releases](https://github.com/kubeless/kubeless/releases)上检查最新版本。要安装更新版本，只需在以下URL中使用更新的版本号，但请注意，不同版本之间的输出可能会有所不同。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, this will create and launch all of the components needed to
    run Kubeless on your single-node Kubernetes cluster:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这将创建并启动在您的单节点Kubernetes集群上运行Kubeless所需的所有组件：
- en: '![](assets/512c4f3f-0ccb-4f15-bfa7-b0ab993f6409.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/512c4f3f-0ccb-4f15-bfa7-b0ab993f6409.png)'
- en: 'It will take a few minutes for everything to start up. You can check the status
    of each of the components launched by running the following commands:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一切启动需要一些时间。您可以通过运行以下命令来检查每个组件的状态：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This should show you something like the following output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会显示类似以下输出：
- en: '![](assets/8e0de3e0-f560-4245-9dd8-d45588db224a.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8e0de3e0-f560-4245-9dd8-d45588db224a.png)'
- en: 'Alternatively, you can also check the status using the Kubernetes dashboard.
    To do this, open the dashboard by running the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以使用Kubernetes仪表板来检查状态。要做到这一点，运行以下命令打开仪表板：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When the dashboard first opens, it is configured to display the default namespace,
    as the first command we executed created a new namespace called `kubeless`. We
    need to switch the `kubeless` namespace to see the Pods, Deployments, and Stateful
    Sets that have been deployed inside it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当仪表板首次打开时，它被配置为显示默认命名空间，因为我们执行的第一个命令创建了一个名为`kubeless`的新命名空间。我们需要切换到`kubeless`命名空间以查看其中部署的Pods、Deployments和Stateful
    Sets。
- en: 'Once you have changed namespaces you should see something on the following
    page:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您更改了命名空间，您应该在以下页面上看到一些内容：
- en: '![](assets/5ffd6926-4594-4952-b813-e93a474da322.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5ffd6926-4594-4952-b813-e93a474da322.png)'
- en: As you can see, we have deployed quite a complex set of services using just
    two commands. All of the heavy lifting and complexity has been completely abstracted
    away from us.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们只用两个命令就部署了一组相当复杂的服务。所有繁重的工作和复杂性都已完全抽象化。
- en: The command-line client
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行客户端
- en: Now that Kubeless is installed on our single-node Kubernetes cluster we can
    look at getting the command-line client installed; this is how we will be interacting
    with our Kubeless cluster.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Kubeless已经安装在我们的单节点Kubernetes集群上，我们可以考虑安装命令行客户端；这是我们将与我们的Kubeless集群进行交互的方式。
- en: macOS 10.13 High Sierra
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS 10.13 High Sierra
- en: As we already have Homebrew installed from the previous chapter, we are going
    to use the `brew` command to install Kubeless. To do this, we need to add the
    Kubeless tap; a tap is a third-party repository that contains software installation
    instructions. Once the tap has been added, we can then install Kubeless in much
    the same way we did Minikube in [Chapter 2](494a207a-b5ff-4ee2-ae3c-c2abc8cbc108.xhtml),
    *An Introduction to Kubernetes*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在上一章安装了Homebrew，我们将使用`brew`命令来安装Kubeless。为此，我们需要添加Kubeless tap；tap是一个包含软件安装说明的第三方存储库。一旦tap被添加，我们就可以以与我们在[第2章](494a207a-b5ff-4ee2-ae3c-c2abc8cbc108.xhtml)中安装Minikube相同的方式安装Kubeless。
- en: 'To install the tap and then install the Kubeless command-line client, run the
    following two commands:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装tap，然后安装Kubeless命令行客户端，请运行以下两个命令：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once installed you can check the version of the client that was installed by
    running the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以通过运行以下命令来检查已安装的客户端的版本：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Do not worry too much if this returns a different version of the client than
    the software you installed; this should not be a problem.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这返回的客户端版本与您安装的软件不同，不要太担心；这不应该是一个问题。
- en: Windows 10 Professional
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows 10专业版
- en: 'Unfortunately, there is no Chocolatey installer available for Kubeless, so
    we will have to download and uncompress the executable file manually. To do this
    in PowerShell, run the following commands:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Kubeless没有可用的Chocolatey安装程序，因此我们必须手动下载和解压可执行文件。要在PowerShell中执行此操作，请运行以下命令：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, you can download the `kubeless_windows-amd64.zip` file from
    the Kubeless releases page. Once downloaded, extract the `.zip` file and put the
    `kubeless.exe` file where we can execute it. Run the following command from the
    folder that contains your `kubeless.exe` file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以从Kubeless发布页面下载`kubeless_windows-amd64.zip`文件。下载后，解压`.zip`文件，并将`kubeless.exe`文件放在我们可以执行它的位置。从包含您的`kubeless.exe`文件的文件夹运行以下命令：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will return the version of the command-line client.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回命令行客户端的版本。
- en: Ubuntu 17.04
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ubuntu 17.04
- en: 'Like the Windows 10 version of the command-line client for Kubeless, we have
    to download the release, uncompress it, and move the executable in place. To do
    this, run the following commands:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Windows 10版本的Kubeless命令行客户端一样，我们需要下载发布版本，解压缩并将可执行文件移动到指定位置。要做到这一点，请运行以下命令：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, to check that the executable is working as expected, run:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了检查可执行文件是否按预期工作，请运行：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are ready to use Kubeless on our Ubuntu Linux host.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好在我们的Ubuntu Linux主机上使用Kubeless。
- en: The Kubeless web interface
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubeless Web界面
- en: 'Before we move on we can also install the web interface for Kubeless. This,
    like Kubeless itself, can easily be installed by running:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们还可以安装Kubeless的Web界面。就像Kubeless本身一样，只需运行以下命令即可轻松安装：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can then use Minikube to open the service in your browser by running:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用Minikube运行以下命令在浏览器中打开服务：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see from the preceding command, as the `ui` service has been deployed
    in the `kubeless` namespace we need to let Minikube know that this is where the
    service is accessible by passing the `--namespace` flag. It may take up to several
    minutes for the Kubeless web interface to launch, but when it does you should
    be greeted by a page that looks like the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述命令中可以看出，由于`ui`服务已部署在`kubeless`命名空间中，我们需要通过传递`--namespace`标志来让Minikube知道这是服务的访问位置。Kubeless
    Web界面可能需要几分钟才能启动，但当它启动时，您应该会看到一个类似以下内容的页面：
- en: '![](assets/c568edd3-5b21-4002-8ad7-8b60e540fdc8.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c568edd3-5b21-4002-8ad7-8b60e540fdc8.png)'
- en: Kubeless overview
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubeless概述
- en: Before we start to deploy serverless functions using Kubeless we should take
    a little time to work through what it is we have just installed, and also take
    a look at the commands available when using the Kubeless command-line client.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用Kubeless部署无服务器函数之前，我们应该花点时间来了解一下我们刚刚安装的内容，并查看在使用Kubeless命令行客户端时可用的命令。
- en: As we have already mentioned, the installation process was extremely simple—while
    we were installing Kubeless on our single-node Kubernetes cluster the installation
    process would have remained pretty much the same if we were installing it on a
    Kubernetes made up of several nodes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，安装过程非常简单——在我们的单节点Kubernetes集群上安装Kubeless时，安装过程基本上是一样的，即使我们在由多个节点组成的Kubernetes上安装它也是如此。
- en: So what is Kubeless?
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，什么是Kubeless呢？
- en: Kubeless is a framework that supports the deployment of serverless functions
    on your Kubernetes cluster, and it allows you to use both HTTP and event triggers
    to execute your Python, Node.js, or Ruby code. The framework is built using core
    Kubernetes functionality such as deployments, services, ConfigMaps, and so on.
    This keeps the Kubeless codebase small, and also means that developers do not
    have to reproduce large chunks of scheduling logic as it already exists within
    the Kubernetes core.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Kubeless是一个支持在Kubernetes集群上部署无服务器函数的框架，它允许您使用HTTP和事件触发器来执行Python、Node.js或Ruby代码。该框架是使用核心Kubernetes功能构建的，如部署、服务、ConfigMaps等。这使得Kubeless的代码库很小，并且意味着开发人员不必重复大量的调度逻辑，因为它已经存在于Kubernetes核心中。
- en: It works by taking advantage of Kubernetes controllers. Using controllers, the
    Kubeless developers have extended the Kubernetes API to add a function object
    within Kubernetes. The Kubeless controller runs within the Kubernetes cluster
    as a deployment, its primary job is to watch for the function endpoint being called.
    When the endpoint is called, runtimes containing the function code are executed;
    these are pre-built Docker images that wrap your functions, which are injected
    using ConfigMaps, in either an Apache Kafka consumer, which is used for events,
    or an HTTP server, which you can call like any other web page in your Kubernetes
    cluster.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过利用Kubernetes控制器来工作。使用控制器，Kubeless开发人员已扩展了Kubernetes API，以在Kubernetes中添加一个函数对象。
    Kubeless控制器作为部署在Kubernetes集群中运行，其主要工作是监视函数端点的调用。当调用端点时，将执行包含函数代码的运行时；这些是预构建的Docker镜像，用于包装您的函数，使用ConfigMaps注入到Kubernetes集群中的Apache
    Kafka消费者或HTTP服务器中，您可以像调用任何其他网页一样调用它们。
- en: Apache Kafka is a distributed streaming platform that lets you both publish
    and subscribe to a stream of information. In our case, this stream of information
    is an event being triggered to which the Kubeless controller is subscribed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Kafka是一个分布式流平台，让您可以发布和订阅信息流。在我们的情况下，这个信息流是触发的事件，Kubeless控制器订阅了这个事件。
- en: All of this means that we can get a similar experience of the serverless services
    we covered from AWS and Microsoft Azure in [Chapter 1](37d92482-56fd-4329-8b81-01acc97e9c0c.xhtml),
    *The Serverless Landscape*, on our Kubernetes cluster, including the single-node
    cluster we are running locally.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些意味着我们可以在我们运行的单节点集群中获得与我们在[第1章](37d92482-56fd-4329-8b81-01acc97e9c0c.xhtml)
    *无服务器景观*中涵盖的AWS和Microsoft Azure的无服务器服务类似的体验，包括我们本地运行的Kubernetes集群。
- en: Who made Kubeless?
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谁创造了Kubeless？
- en: Kubeless was created by Bitnami ([https://bitnami.com/](https://bitnami.com/))
    and it is one of several projects they have written and open-sourced to support
    the easy deployment of applications into a Kubernetes cluster.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Kubeless是由Bitnami（[https://bitnami.com/](https://bitnami.com/)）创建的，它是他们编写并开源支持将应用程序轻松部署到Kubernetes集群的几个项目之一。
- en: Bitnami has for many years been a leader in distributing pre-packaged open source
    and commercially supported licensed applications—there are over 140 at the time
    of writing—in a predictable and consistent way across many different platforms
    and public clouds, so the jump to supporting and developing for Kubernetes was
    a natural fit for them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Bitnami多年来一直是分发预打包的开源和商业支持许可应用的领导者，在撰写本文时有超过140个应用程序，以可预测和一致的方式跨多个不同平台和公共云进行分发和支持，因此支持和开发Kubernetes对他们来说是一个自然的选择。
- en: They are a core contributor, alongside Microsoft and Google, to Helm, which
    is a package manager for Kubernetes maintained by the Cloud Native Computing Foundation
    forum, who as we know from [Chapter 2](494a207a-b5ff-4ee2-ae3c-c2abc8cbc108.xhtml),
    *An Introduction to Kubernetes*, also maintain Kubernetes itself.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 他们是Helm的核心贡献者，与微软和谷歌一起，Helm是由Cloud Native Computing Foundation论坛维护的Kubernetes的包管理器，我们知道来自[第2章](494a207a-b5ff-4ee2-ae3c-c2abc8cbc108.xhtml)
    *Kubernetes简介*。
- en: You can find the Kubeless website at [http://kubeless.io/](http://kubeless.io/).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://kubeless.io/](http://kubeless.io/)找到Kubeless网站。
- en: Kubeless commands
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubeless命令
- en: The Kubeless command-line client has several commands. Before we look at launching
    our first serverless function on Kubernetes using Kubeless we should quickly discuss
    some of the commands we are going to be using.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Kubeless命令行客户端有几个命令。在我们使用Kubeless在Kubernetes上启动我们的第一个无服务器函数之前，我们应该快速讨论一些我们将要使用的命令。
- en: The most common command we are going to be using is `kubeless function`. This
    allows us to `deploy`, `delete`, `edit`, and `list` functions. Also, we can execute
    our functions by using `call` and check the `logs`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的最常见的命令是`kubeless function`。这允许我们`部署`、`删除`、`编辑`和`列出`函数。此外，我们可以通过使用`call`执行我们的函数，并检查`日志`。
- en: Next up, we have `kubeless ingress`; with this command we can `create`, `delete`,
    and `list` routes to our functions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`kubeless ingress`；使用此命令，我们可以`创建`、`删除`和`列出`到我们函数的路由。
- en: Finally, we will also be looking at `kubeless topic`; like `ingress`, it allows
    us to `create`, `delete`, and `list` topics as well as `publish` a message to
    a topic.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还将看一下`kubeless topic`；与`ingress`一样，它允许我们`创建`、`删除`和`列出`主题，以及向主题`发布`消息。
- en: Hello world
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello world
- en: To start off with we are going to look at deploying two very simple hello world
    functions. The first simply prints `Hello World!` and the second takes an input
    and then displays it back to you.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看一下部署两个非常简单的hello world函数。第一个简单地打印`Hello World!`，第二个接受输入，然后将其显示回给你。
- en: The basic example
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本示例
- en: 'First of all, we need our function. The static hello-world function requires
    the following three lines of Python code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要我们的函数。静态的hello-world函数需要以下三行Python代码：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Place the preceding code, which is also available in the `Chapter04/hello-world`
    folder of the GitHub repository that accompanies this book, in a file called `hello.py`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码放在名为`hello.py`的文件中，该文件也可以在伴随本书的GitHub存储库的`Chapter04/hello-world`文件夹中找到。
- en: 'Now we have our function we can deploy it into the default namespace by running
    the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的函数，我们可以通过运行以下命令将其部署到默认命名空间中：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This command creates a function called `hello`, using the file `hello.py`. Whenever
    the function called `hello.handler` is executed, we are using the `python2.7`
    runtime, and our function is set to be triggered by an `http` request.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建一个名为`hello`的函数，使用文件`hello.py`。每当执行名为`hello.handler`的函数时，我们使用`python2.7`运行时，并且我们的函数被设置为由`http`请求触发。
- en: 'You may have noticed that, when you ran the command, there was no feedback,
    so to check that the function was created you can run the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，当您运行命令时，没有任何反馈，所以要检查函数是否已创建，您可以运行以下命令：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are several columns in the preceding command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中有几列：
- en: '`NAME`: This is the name of the function'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名称`：这是函数的名称'
- en: '`NAMESPACE`: The name of the namespace the function has been deployed into'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`命名空间`：函数部署到的命名空间的名称'
- en: '`HANDLER`: The name of the handler to run—in our case the handler is simply
    handler, so it is calling `hello-world.handler`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`处理程序`：要运行的处理程序的名称—在我们的情况下，处理程序只是处理程序，因此它正在调用`hello-world.handler`'
- en: '`RUNTIME`: There is a separate runtime for each of the languages supported
    by Kubeless'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`运行时`：Kubeless支持的每种语言都有单独的运行时'
- en: '`TYPE`: This is how the function is being called, in our case this is HTTP'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`类型`：这是函数被调用的方式，在我们的情况下这是HTTP'
- en: '`TOPIC`: If we were subscribing to a message queue this would be the topic
    we would be watching for messages in'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`主题`：如果我们订阅消息队列，这将是我们要观察消息的主题'
- en: 'Also, as mentioned in the previous section, Kubeless adds functions objects
    to Kubernetes. You can run the following command to check our function is being
    listed in the functions object:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，正如前一节中提到的，Kubeless将函数对象添加到Kubernetes中。您可以运行以下命令来检查我们的函数是否被列在函数对象中：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Running through these commands should give you something like the following
    results:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些命令运行应该会给您一些类似以下结果：
- en: '![](assets/a065e896-8db8-4d0e-ac06-292efb0e4dc5.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a065e896-8db8-4d0e-ac06-292efb0e4dc5.png)'
- en: 'Now that we have our function deployed, we can execute it. To do this run:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的函数已部署，我们可以执行它。要运行此操作，请运行：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will give the following results:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '![](assets/fae35d98-a824-4619-a8bf-4312b2459612.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fae35d98-a824-4619-a8bf-4312b2459612.png)'
- en: 'Another way we can call the function is using the Kubeless web interface. Open
    it by running the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用函数的另一种方式是使用Kubeless Web界面。通过运行以下命令打开它：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once open, you should see the function `hello` listed on the left-hand side.
    Clicking on `hello` will show you the code in the function, and there is a button
    labelled RUN FUNCTIONon the right-hand side; clicking this will execute the `hello`
    function and return `Hello World!`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 打开后，您应该在左侧列出函数`hello`。单击`hello`将显示函数中的代码，并且右侧有一个标有RUN FUNCTION的按钮；单击此按钮将执行`hello`函数并返回`Hello
    World!`：
- en: '![](assets/a103d7d4-d225-44d4-8d1e-bd34376d9930.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a103d7d4-d225-44d4-8d1e-bd34376d9930.png)'
- en: 'The final way we can interact with our function is to create an Ingress rule;
    however, before we do that we must enable the Ingress add-on in Minikube. To do
    that, run the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与函数交互的最终方式是创建Ingress规则；但是，在执行此操作之前，我们必须在Minikube中启用Ingress插件。要执行此操作，请运行以下命令：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that the Ingress add-on is enabled we need to create the Ingress route
    using Kubeless. To do this we simply need to run the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Ingress插件已启用，我们需要使用Kubeless创建Ingress路由。要执行此操作，我们只需要运行以下命令：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We need to know the host that Kubeless created so that we can access our service.
    To do this, run the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道Kubeless创建的主机，以便访问我们的服务。要执行此操作，请运行以下命令：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will give information on the Ingress route we created, including the host
    we will be able to use to access the service. For me, this was `http://hello.192.168.99.100.nip.io/`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提供有关我们创建的Ingress路由的信息，包括我们将能够使用的主机来访问该服务。对我来说，这是`http://hello.192.168.99.100.nip.io/`。
- en: '`nip.io` is a simple and free DNS service that allows you to create a DNS record
    to map your host to an IP address. Kubeless uses this service to create a valid
    host to route to your service.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`nip.io`是一个简单且免费的DNS服务，允许您创建DNS记录将您的主机映射到IP地址。Kubeless使用此服务创建有效的主机以路由到您的服务。'
- en: 'Opening this URL in my browser returned `Hello World!`, as did running it through
    HTTPie, which we covered in [Chapter 1](37d92482-56fd-4329-8b81-01acc97e9c0c.xhtml),
    *The Serverless Landscape,* as you can see from the following Terminal output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的浏览器中打开此URL返回`Hello World!`，通过HTTPie运行它也是如此，我们在[第1章](37d92482-56fd-4329-8b81-01acc97e9c0c.xhtml)中介绍了HTTPie，您可以从以下终端输出中看到：
- en: '![](assets/0a40f91c-d6bb-4622-96ab-8228c1f9c878.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0a40f91c-d6bb-4622-96ab-8228c1f9c878.png)'
- en: Now that we have our first function up-and-running, let's look at creating one
    that can be passed and print data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的第一个函数已经运行起来了，让我们看看如何创建一个可以传递并打印数据的函数。
- en: An example of reading data
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取数据的示例
- en: 'The code for our new function is still quite simple:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新函数代码仍然非常简单：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'All this code does is take the JSON we post and display it back to us. Place
    it in a file called `hello-name.py` or use the one in the `Chapter04/hello-world/`
    folder in the GitHub repository. Once you have the file you can create the function
    by running:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的全部作用只是接收我们发布的JSON并将其显示给我们。将其放入名为`hello-name.py`的文件中，或者使用GitHub存储库中`Chapter04/hello-world/`文件夹中的文件。一旦有了文件，您可以通过运行以下命令创建函数：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once you have deployed the function, you check it has been created by running:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 部署函数后，通过运行以下命令检查是否已创建：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You should see two functions listed, `hello` and `hello-name`. Now that we
    have created our new function you can call it by running:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到列出了两个函数，`hello`和`hello-name`。现在我们已经创建了新函数，可以通过运行以下命令来调用它：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Notice that this time we are using the `--data` flag to pass data to the function.
    Running all of the commands, you should see something like the following terminal
    output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次我们使用`--data`标志将数据传递给函数。运行所有命令后，您应该看到类似以下终端输出：
- en: '![](assets/a6639d16-6ca1-4734-8002-583e1e08b50d.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a6639d16-6ca1-4734-8002-583e1e08b50d.png)'
- en: 'When calling the function using the web interface, we also need to pass data.
    To do this, open the interface again by running:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Web界面调用函数时，我们还需要传递数据。要做到这一点，再次打开界面，运行：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once open, click on the `hello-name` function. Before clicking the RUN FUNCTION
    button change GET to POST using the drop-down menu, and in the Request form enter
    the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 打开后，点击`hello-name`函数。在点击RUN FUNCTION按钮之前，使用下拉菜单将GET更改为POST，并在请求表单中输入以下内容：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, press the RUN FUNCTION button. This will return the same result as the
    `kubeless function call` command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击RUN FUNCTION按钮。这将返回与`kubeless function call`命令相同的结果：
- en: '![](assets/74229f95-2b2a-4338-ac02-95f7175eb8a6.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/74229f95-2b2a-4338-ac02-95f7175eb8a6.png)'
- en: 'We can also interact with the service directly by configuring an Ingress route:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过配置Ingress路由直接与服务交互：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will give you URLs for both of our functions:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们的两个函数提供URL：
- en: '![](assets/04cb951e-861b-40c9-a279-b68696db2150.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/04cb951e-861b-40c9-a279-b68696db2150.png)'
- en: 'Unlike our first example, going to the URL for `hello-name`, which for me was
    `http://hello-name.192.168.99.100.nip.io/`, will give Error: 500 Internal Server
    Error (or on later versions of Kubeless, a 504 Gateway timeout):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的第一个示例不同，转到`hello-name`的URL，对我来说是`http://hello-name.192.168.99.100.nip.io/`，将会显示错误：500内部服务器错误（或在Kubeless的后续版本中，显示504网关超时）：
- en: '![](assets/041b574c-34fc-4f43-91af-fba1f8cc17e5.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/041b574c-34fc-4f43-91af-fba1f8cc17e5.png)'
- en: Why is that, given that it worked without error when we called it using the
    `kubeless function call` command and also using the Kubeless web interface?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会这样，尽管我们使用`kubeless function call`命令和Kubeless Web界面调用时都没有错误？
- en: 'Well, by simply entering the URL into a browser we have not posted any data
    for the function to return; this is why the error is being generated. We can confirm
    this by checking the logs. To do this, refresh the page in your browser a few
    times and then run the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地将URL输入到浏览器中，我们没有发布任何数据供函数返回；这就是为什么会生成错误的原因。我们可以通过检查日志来确认这一点。要做到这一点，刷新浏览器中的页面几次，然后运行以下命令：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should see something like the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的内容：
- en: '![](assets/28667ea3-e6f4-40fa-9d03-ace20d7eb60d.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/28667ea3-e6f4-40fa-9d03-ace20d7eb60d.png)'
- en: 'The first line of the preceding log output is the internal health check, which
    was successful, as a `200` status was generated, which you can see after the `GET`.
    The next several lines contain the error we are after; as you can see, we get
    a `Traceback` and then the following: `TypeError: handler() takes exactly 1 argument
    (0 given)`. This means that the function was expecting data to be passed and none
    was. The next line is the request from our browser; as you can see after the `GET`,
    there is a status of `500`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '前面日志输出的第一行是内部健康检查，它是成功的，因为生成了`200`状态，您可以在`GET`之后看到。接下来的几行包含我们要查找的错误；正如您所看到的，我们得到了`Traceback`，然后是以下内容：`TypeError:
    handler() takes exactly 1 argument (0 given)`。这意味着函数期望传递数据，但没有传递。下一行是来自我们浏览器的请求；正如您在`GET`之后看到的，有一个`500`的状态。'
- en: So how can we interact with our function that requires us to POST data rather
    than GET? There are a few ways you can achieve this on the macOS and Linux command
    line, but you will have to run something else on Windows. Rather than working
    through different examples I am going to install a piece of software called Postman.
    This desktop software works on all three of the operating systems we are covering
    in the book and it will provide a great graphical interface for us to interact
    with both the `hello-name` function and any other functions we launch.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何与需要POST数据而不是GET的函数进行交互呢？在macOS和Linux命令行上，您可以通过几种方式实现这一点，但在Windows上，您将不得不运行其他东西。与其通过不同的示例来工作，我要安装一个名为Postman的软件。这个桌面软件适用于我们在书中涵盖的所有三种操作系统，并且它将为我们与`hello-name`函数以及我们启动的任何其他函数进行交互提供一个很好的图形界面。
- en: 'To install Postman on macOS 10.13 High Sierra using Homebrew, simply run:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要在macOS 10.13 High Sierra上使用Homebrew安装Postman，只需运行：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There is a Chocolatey package for Postman, so if you are using Windows 10 Professional,
    you can run:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Postman有一个Chocolatey软件包，因此如果您使用的是Windows 10专业版，可以运行：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To install Postman on Ubuntu 17.04 we need to run a few more additional steps.
    First of all, we need to download, uncompress, and move the file into place, making
    sure to clean up and move the files we need. To do this, run the following commands:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Ubuntu 17.04上安装Postman，我们需要运行一些额外的步骤。首先，我们需要下载、解压缩并移动文件到指定位置，确保清理和移动我们需要的文件。为此，请运行以下命令：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we have the files in the correct place, we can create a desktop launcher
    for them by running:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将文件放在了正确的位置，我们可以通过运行以下命令为它们创建一个桌面启动器：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once you have created the launcher you should see a Postman icon appear in the
    list of installed software.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了启动器后，您应该在已安装软件列表中看到一个Postman图标出现。
- en: 'Now that we have installed Postman, open it and you will be greeted by a screen
    asking you to sign-up. It is up to you if you wish to sign-up or not; the service
    is free and you will find it of great use if you ever need to test posting data
    to APIs. Once you have passed the Sign up or Sign in option you will be presented
    with a screen that looks like the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了Postman，打开它，您将看到一个屏幕，询问您是否要注册。如果您愿意注册或不注册，完全取决于您；该服务是免费的，如果您需要测试向API发送数据，您会发现它非常有用。一旦您通过了注册或登录选项，您将看到一个类似以下的屏幕：
- en: '![](assets/a7b780ee-1998-41a4-b4b1-a82103f989b9.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a7b780ee-1998-41a4-b4b1-a82103f989b9.png)'
- en: Click on the Request option under BUILDING BLOCKS; this will take you to a save
    dialog. Here, enter the Request name of `hello-name` and then click on +Create
    Collection. Here, create a collection called `Kubeless` and then click on the
    Save to Kubeless button.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 点击BUILDING BLOCKS下的Request选项；这将带您进入保存对话框。在这里，输入`hello-name`的请求名称，然后点击+Create
    Collection。在这里，创建一个名为`Kubeless`的集合，然后点击Save to Kubeless按钮。
- en: First of all, change GET to POST using the drop-down menu, then in the space
    that is labelled Enter request URL enter `http://hello-name.192.168.99.100.nip.io`
    (or your URL if different). Now that we have defined that we are going to be posting
    our data, to we need to actually give Postman the data that needs to be passed
    to our function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用下拉菜单将GET更改为POST，然后在标有输入请求URL的空格中输入`http://hello-name.192.168.99.100.nip.io`（或者如果不同的话，输入您的URL）。现在我们已经定义了我们将要发布我们的数据，我们需要实际给Postman传递需要传递给我们的函数的数据。
- en: 'To enter the data click on Body, and then select the raw option. When you select
    raw the input field will change, and you should see the word Text with a drop-down
    icon next to it. Click on this and check the option for JSON (application/json).
    Once changed, enter the following in the main field:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要输入数据，请单击Body，然后选择原始选项。当您选择原始选项时，输入字段将发生变化，您应该看到单词Text和旁边的下拉图标。单击这个图标，然后选中JSON（application/json）选项。一旦更改，输入以下内容到主字段中：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that Postman is configured to POST JSON data to our function you can click
    on Send. This will post the data we defined and then display the results in the
    bottom part of the screen, along with the HTTP status and the time the request
    took to be executed, just like the following screenshot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Postman已经配置为将JSON数据发送到我们的函数，您可以单击发送。这将发布我们定义的数据，然后在屏幕底部显示结果，以及HTTP状态和请求执行所需的时间，就像下面的截图一样：
- en: '![](assets/68e8d681-0794-4ad0-851a-e9aadfcd7179.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/68e8d681-0794-4ad0-851a-e9aadfcd7179.png)'
- en: Clicking on the Save button will store the settings, should you want to re-run
    them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 单击保存按钮将保存设置，如果您想重新运行它们的话。
- en: 'Before we move on to the next section we should tidy up our functions. To do
    this, we simply need to run:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一节之前，我们应该整理一下我们的函数。要做到这一点，我们只需要运行：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will remove our two hello world functions and Ingress routes. You can
    also double-check that everything has been removed in the Kubeless web interface
    and Kubernetes dashboard; again, you can open these by running:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除我们的两个hello world函数和Ingress路由。您还可以在Kubeless web界面和Kubernetes仪表板中再次检查是否已删除了所有内容；您可以通过运行以下命令打开它们：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you spot anything left over for either `hello` or `hello-name` you can remove
    the services, pods, and even Ingress routes from the dashboard.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现任何剩余的内容，无论是`hello`还是`hello-name`，您都可以从仪表板中删除服务、pod，甚至Ingress路由。
- en: Twitter example
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Twitter示例
- en: The Kubeless GitHub account has a few more example applications that do something
    more than printing static content or reposting data you sent. In this example,
    we are going to look at creating a function that posts to a Twitter account.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Kubeless GitHub账户有一些更多的示例应用程序，这些应用程序不仅可以打印静态内容或转发您发送的数据。在这个例子中，我们将看看如何创建一个可以发布到Twitter账户的函数。
- en: The Twitter API
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Twitter API
- en: 'Before we look at launching the function we need to generate keys for our function
    to be able to authenticate against Twitter and then post to your account. To do
    this, you need the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看如何启动函数之前，我们需要为我们的函数生成密钥，以便对Twitter进行身份验证，然后发布到您的账户。为此，您需要以下内容：
- en: A Twitter account
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter账户
- en: A mobile number registered with the account
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与账户注册的手机号码
- en: 'If you have them then going to the Twitter application page at [https://apps.twitter.com/](https://apps.twitter.com/)
    will present you with a form to fill in (Application Details)—I used the following
    information. However, a few of the fields need to be unique to you; these are
    marked with *:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有它们，那么前往Twitter应用程序页面[https://apps.twitter.com/](https://apps.twitter.com/)将为您呈现一个表格（应用程序详情）-我使用了以下信息。然而，一些字段需要对您来说是唯一的；这些字段用*标记：
- en: 'Name*: `MedialGlassesKubeless`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称*：`MedialGlassesKubeless`
- en: 'Description: `Testing posting to Twitter using Kubeless`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述：`使用Kubeless测试发布到Twitter`
- en: 'Website*: `https://media-glass.es/`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站*：`https://media-glass.es/`
- en: 'Callback URL: Leave blank'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调URL：留空
- en: 'Developer Agreement: Agree to the agreement'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者协议：同意协议
- en: Once you have filled in the preceding information, click on the Create your
    Twitter application button. Once the application has been created you will be
    taken to a page that allows you to manage your application. One of the tabs on
    the page is Keys and Access Tokens; clicking on this will reveal your Consumer
    Key (API Key) and Consumer Secret (API Secret)—make a note of these.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 填写完上述信息后，点击“创建Twitter应用”按钮。创建应用程序后，您将被带到一个页面，允许您管理您的应用程序。页面上的一个选项卡是“密钥和访问令牌”；点击这个选项卡将显示您的消费者密钥（API密钥）和消费者秘钥（API秘钥）—请记下这些信息。
- en: At the bottom of the page, you will have a button that allows you to create
    an Access Token and Access Token Secret for your account; clicking on the button
    will generate the tokens—again, make a note of these.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面底部，您将有一个按钮，允许您为您的帐户创建访问令牌和访问令牌秘钥；点击按钮将生成这些令牌—再次，请记下这些信息。
- en: While the following examples will contain the keys I have generated, they have
    been revoked, and you should use your own. Also, as they allow both read and write
    access to your Twitter account, storing them in a publicly accessible place such
    as GitHub, Gists, or other version control software may result in third-parties
    having full access to your Twitter account without your permission.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以下示例将包含我生成的密钥，但它们已被撤销，您应该使用您自己的密钥。此外，由于它们允许对您的Twitter帐户进行读写访问，将它们存储在GitHub、Gists或其他版本控制软件等公开可访问的地方可能导致第三方未经您的许可就完全访问您的Twitter帐户。
- en: Adding secrets to Kubernetes
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将秘密添加到Kubernetes
- en: Now that we have our Twitter application configured and all of the tokens we
    need to be able to post a tweet, we need to add them to Kubernetes. Kubernetes
    allows you to define secrets; these are variables such as API keys and tokens
    that your applications need to use to function. However, you might not want to
    put them under source control or embed them in your application because various
    deployments of the same code interact with the APIs using different keys—for example,
    the development version of the code uses a different set of API credentials from
    the production version.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了Twitter应用程序，并且拥有了发布推文所需的所有令牌，我们需要将它们添加到Kubernetes中。Kubernetes允许您定义秘密；这些是您的应用程序需要使用的API密钥和令牌等变量。但是，您可能不希望将它们放在源代码控制下或嵌入到您的应用程序中，因为相同代码的各种部署使用不同的密钥与API进行交互—例如，代码的开发版本使用与生产版本不同的API凭据。
- en: 'To add the tokens you made a note of in the previous section you just need
    to run the following command, replacing the placeholders, which are in uppercase,
    with your tokens and keys:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加前一节中记下的令牌，您只需要运行以下命令，用您的令牌和密钥替换大写的占位符：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For me, the command looked like the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，命令看起来像下面这样：
- en: '![](assets/2ac31d01-3e2b-44d6-a10e-408be3e438ef.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2ac31d01-3e2b-44d6-a10e-408be3e438ef.png)'
- en: 'This has created a secret called `twitter` that contains the four different
    keys and tokens we passed to the command. You can list the secrets by running:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就创建了一个名为`twitter`的秘密，其中包含我们传递给命令的四个不同的键和令牌。您可以通过运行以下命令来列出这些秘密：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will list all of the secrets within your Kubernetes cluster, as you can
    see from the following Terminal output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出您的Kubernetes集群中的所有秘密，如下面终端输出所示：
- en: '![](assets/03d530ba-27c4-4586-9c23-169891138d84.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/03d530ba-27c4-4586-9c23-169891138d84.png)'
- en: 'There are the default Kubernetes service account tokens, which contain three
    items, and our `twitter` secret containing the four keys and tokens. You can also
    view secrets in the Kubernetes dashboard:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有默认的Kubernetes服务账户令牌，包含三个项目，以及我们的`twitter`秘密，其中包含四个键和令牌。您也可以在Kubernetes仪表板中查看秘密：
- en: '![](assets/46a1520c-fa01-4080-a3ec-a937485a8ce8.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/46a1520c-fa01-4080-a3ec-a937485a8ce8.png)'
- en: As you can see from the preceding screenshot, you also have the option of revealing
    the secret by clicking on the eye icon.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图中可以看出，您还可以通过单击眼睛图标来显示秘密。
- en: The Twitter function
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Twitter函数
- en: 'Now that we have our environment prepared we can deploy the function. To do
    this we need two files; the first is the `requirements.txt` file, this contains
    just two lines:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的环境准备好了，我们可以部署函数了。为此，我们需要两个文件；第一个是`requirements.txt`文件，其中只包含两行：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `requirements.txt` file lets Python know which external libraries to deploy
    alongside our code. In our file we are using the `twitter` library so that we
    can post the tweet easily, and also the `kubernetes` library to decode the secrets
    we created in the previous section. Using the libraries means that our code is
    quite streamlined, as all of the hard work takes place outside our core function.
    The code for the function is as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements.txt`文件让Python知道要与我们的代码一起部署的外部库。在我们的文件中，我们使用`twitter`库，以便可以轻松地发布推文，还使用`kubernetes`库来解码我们在上一节中创建的秘密。使用这些库意味着我们的代码非常简化，因为所有的繁重工作都发生在我们的核心函数之外。函数的代码如下：'
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Place this in a file called `tweet.py`. As before, both the `requirements.txt`
    and `tweet.py` files can be found in the GitHub repository at `Chapter04/twitter/`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将此内容放入名为`tweet.py`的文件中。与以前一样，`requirements.txt`和`tweet.py`文件都可以在GitHub存储库`Chapter04/twitter/`中找到。
- en: 'The command to deploy the function has one addition to the deployment command.
    As we are now loading external libraries, we need to let Kubeless know that we
    want to use a `requirements.txt` file by adding the `--dependencies` flag:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 部署函数的命令在部署命令中有一个附加项。由于我们现在正在加载外部库，我们需要让Kubeless知道我们想要使用`requirements.txt`文件，方法是添加`--dependencies`标志：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see from the following Terminal output, the dependencies are now
    listed when running the `kubeless function list` command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下终端输出中可以看出，在运行`kubeless function list`命令时现在列出了依赖项：
- en: '![](assets/4c4fc377-f38c-451e-acc6-46969dfaecdd.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4c4fc377-f38c-451e-acc6-46969dfaecdd.png)'
- en: 'Now that our function has been deployed, we can start tweeting. To send our
    first tweet you simply need to run the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的函数已经部署，我们可以开始发推文了。要发送我们的第一条推文，您只需运行以下命令：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You will not receive any feedback, but if you go to your Twitter account you
    should see the tweet:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您将不会收到任何反馈，但如果您转到您的Twitter帐户，您应该会看到这条推文：
- en: '![](assets/66f521f6-717a-432b-8c15-7906e6aeafba.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/66f521f6-717a-432b-8c15-7906e6aeafba.png)'
- en: 'You can also use Postman to send a tweet. First of all, create an Ingress route
    by running the following commands:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用Postman发送推文。首先，通过运行以下命令创建一个Ingress路由：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will create the route and give us the host we need to use to access the
    function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建路由并给我们提供访问函数所需的主机：
- en: '![](assets/f9daa0b6-64d2-49e3-9500-58b2440ec5ac.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f9daa0b6-64d2-49e3-9500-58b2440ec5ac.png)'
- en: 'Now we can open Postman, and as before configure it in pretty much the same
    way, but this file uses the following as the post content:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以打开Postman，并且像以前一样配置它，但是这个文件将以下内容作为发布内容：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Clicking on Send will post the tweet and, like when calling the function using
    the `kubeless function call` command, will not give us any feedback:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 单击发送将发布推文，并且与使用`kubeless function call`命令调用函数时一样，不会给我们任何反馈：
- en: '![](assets/2be50eb1-e057-423c-a3e1-d817773ba022.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2be50eb1-e057-423c-a3e1-d817773ba022.png)'
- en: 'Checking Twitter should show you a second tweet, this time mentioning `@postmanclient`.
    You can view both of my test tweets at the following URLs:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Twitter应该会显示第二条推文，这次提到了`@postmanclient`。您可以在以下URL查看我的两条测试推文：
- en: 'Command line tweet: [https://twitter.com/mediaglasses/status/922036070954536960](https://twitter.com/mediaglasses/status/922036070954536960)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行推文：[https://twitter.com/mediaglasses/status/922036070954536960](https://twitter.com/mediaglasses/status/922036070954536960)
- en: 'Postman tweet: [https://twitter.com/mediaglasses/status/922038490883346432](https://twitter.com/mediaglasses/status/922038490883346432)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Postman推文：[https://twitter.com/mediaglasses/status/922038490883346432](https://twitter.com/mediaglasses/status/922038490883346432)
- en: 'Again, before moving on to the next section we should remove our function and
    tidy up:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在继续下一部分之前，我们应该删除我们的函数并整理一下：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Also, if you need to you should return to [https://apps.twitter.com/](https://apps.twitter.com/)
    and either remove or revoke your application or tokens.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果需要的话，你应该返回[https://apps.twitter.com/](https://apps.twitter.com/)并删除或撤销你的应用程序或令牌。
- en: The Kubeless serverless plugin
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubeless无服务器插件
- en: Back in [Chapter 1](37d92482-56fd-4329-8b81-01acc97e9c0c.xhtml), *The Serverless
    Landscape*, we installed the Serverless framework to deploy an AWS Lambda function;
    serverless also works with Kubeless.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第1章](37d92482-56fd-4329-8b81-01acc97e9c0c.xhtml)，*无服务器景观*，我们安装了Serverless框架来部署AWS
    Lambda函数；无服务器也适用于Kubeless。
- en: If you didn't install serverless yet, here is a quick recap on how to install
    it on the three operating systems we are covering.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装无服务器，这里是如何在我们正在涵盖的三个操作系统上安装它的快速回顾。
- en: While every effort has been made to ensure that the following instructions work
    on all supported platforms there has been varying degrees of success of running
    the Kubeless serverless plugin on *Windows-based* operating systems due to compatibility
    issues with some of the dependencies required by the plugin.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管已经尽一切努力确保以下说明适用于所有支持的平台，但由于插件所需的一些依赖项的兼容性问题，Kubeless无服务器插件在*基于Windows的*操作系统上的运行成功程度有所不同。
- en: 'For macOS 10.13 High Sierra, run the following command to install Node.js using
    Homebrew:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于macOS 10.13 High Sierra，运行以下命令使用Homebrew安装Node.js：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you are following along using Windows 10 Professional then you can install
    Node.js using Chocolatey by running:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Windows 10专业版，你可以通过运行Chocolatey来安装Node.js：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, if you are using Ubuntu 17.04, you can install Node.js using the following
    commands:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你使用的是Ubuntu 17.04，你可以使用以下命令安装Node.js：
- en: '[PRE48]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now that the latest version of Node.js is installed we can use **Node Package
    Manager** (**NPM**) to install serverless by running:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最新版本的Node.js已安装，我们可以使用**Node Package Manager** (**NPM**)通过运行以下命令来安装无服务器：
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Once serverless is installed you can log in using the following command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦无服务器安装完成，你可以使用以下命令登录：
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now that serverless is installed we can launch the demo Kubeless function by
    running the following commands:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在无服务器已安装，我们可以通过运行以下命令启动演示Kubeless函数：
- en: '[PRE51]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you are not following along, running these commands gives the following
    output:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有跟着做，运行这些命令会得到以下输出：
- en: '![](assets/ae272daf-8510-4fb1-acbc-c650f0d9ed05.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ae272daf-8510-4fb1-acbc-c650f0d9ed05.png)'
- en: 'This has installed the Kubeless serverless plugin and created the `serverless.yml`
    file that defines our function. This contains the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这安装了Kubeless无服务器插件并创建了定义我们函数的`serverless.yml`文件。其中包含以下内容：
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As you can see, the code tells serverless that we are using Kubeless and that
    it should use the Kubeless plugin. It also defines a function and handler called
    `hello`. The function can be found in the `handler.py` file. This contains the
    following code and is pretty similar to the hello-world examples we looked at
    earlier in the chapter:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这段代码告诉无服务器我们正在使用Kubeless，并且它应该使用Kubeless插件。它还定义了一个名为`hello`的函数和处理程序。该函数可以在`handler.py`文件中找到。这包含以下代码，与我们在本章前面看过的hello-world示例非常相似：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now that we have our example function, we can deploy the service by running:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了示例函数，我们可以通过运行以下命令部署服务：
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Once the service has been deployed, the final step is to deploy the function
    itself. To do this, run:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 服务部署完成后，最后一步是部署函数本身。要做到这一点，请运行：
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Using serverless itself to invoke the function might result in an error like
    the following one—if it does, do not worry:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无服务器本身来调用函数可能会导致以下错误，如果出现这种情况，不要担心：
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![](assets/46e38a11-2f63-4841-9dcb-0ec381c9ca39.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/46e38a11-2f63-4841-9dcb-0ec381c9ca39.png)'
- en: 'You can still access the function using Kubeless:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以使用Kubeless访问该函数：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This will return the expected results:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回预期的结果：
- en: '![](assets/a30409ea-a28b-4d16-9225-c73774c79b6f.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a30409ea-a28b-4d16-9225-c73774c79b6f.png)'
- en: 'To remove the example function, run the following command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除示例函数，请运行以下命令：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Before we finish this chapter, let's look at an example that uses events rather
    than HTTP. In the `Chapter04/serverless-event/` folder in the GitHub repository,
    there is a sample application that listens for events.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章之前，让我们看一个使用事件而不是HTTP的示例。在GitHub存储库的`Chapter04/serverless-event/`文件夹中，有一个监听事件的示例应用程序。
- en: 'The `serverless.yml` file differs from the previous HTTP example in that as
    well as a handler it adds an events section that contains the trigger/topic:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`serverless.yml`文件与之前的HTTP示例不同，除了处理程序外，还添加了一个包含触发器/主题的事件部分：'
- en: '[PRE59]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `handler.py` file contains probably the most simplistic code we have looked
    at so far:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`handler.py`文件可能包含迄今为止我们所看到的最简单的代码：'
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To launch the example, simply run the following commands from within the `Chapter04/serverless-event/`
    folder:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动示例，只需从`Chapter04/serverless-event/`文件夹中运行以下命令：
- en: '[PRE61]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '![](assets/0aca75c4-1e13-4c4c-8507-4b3900c3aacc.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0aca75c4-1e13-4c4c-8507-4b3900c3aacc.png)'
- en: 'As you can see from the preceding Terminal output, we have a type of `PubSub`
    and a topic of `hello_topic`. We can now publish an event in the `hello_topic`
    topic by running:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的终端输出中可以看出，我们有一个`PubSub`类型和一个`hello_topic`主题。现在我们可以通过运行以下命令在`hello_topic`主题中发布事件：
- en: '[PRE62]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, we can check the logs to see the that the two events have been processed
    by running:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过运行日志来检查这两个事件是否已经被处理：
- en: '[PRE63]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As you can see from the following output, the events have successfully been
    published and processed by our test function:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下输出中可以看出，事件已成功发布并由我们的测试函数处理：
- en: '![](assets/c0fe43a8-e234-4028-8272-5cedd178a7d8.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c0fe43a8-e234-4028-8272-5cedd178a7d8.png)'
- en: 'Before moving on to the next chapter, we can remove our Kubeless Kubernetes
    single-node cluster by running the following command:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一章之前，我们可以通过运行以下命令删除我们的Kubeless Kubernetes单节点集群：
- en: '[PRE64]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we have deployed Kubeless onto our single-node Kubernetes, which
    we launched with Minikube. We installed the Kubernetes command-line client and
    web-based interface. Once the cluster was deployed and tools installed, we deployed
    and executed functions on our Kubeless installation.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经将Kubeless部署到了我们使用Minikube启动的单节点Kubernetes上。我们安装了Kubernetes命令行客户端和基于Web的界面。一旦集群部署并安装了工具，我们就在Kubeless安装上部署和执行函数。
- en: We worked through installing two basic test functions before installing a more
    useful function that posts tweets. We then looked at how we can interact with
    Kubeless using the Serverless framework.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装一个更有用的发布推文的函数之前，我们先安装了两个基本的测试函数。然后，我们看了一下如何使用Serverless框架与Kubeless进行交互。
- en: In the next chapter, we are going to be looking at an event-based framework
    called **Funktion**.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下一个名为**Funktion**的基于事件的框架。
