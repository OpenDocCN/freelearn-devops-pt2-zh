- en: Packaging Your Code to Run in Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的代码打包以在Kubernetes中运行
- en: 'n this chapter, we will dig into the first thing you need to enable to use
    Kubernetes: getting your software into a container. We will review what containers
    are, how you store and share images, and how to build a container. The chapter
    then continues with two examples, one in Python, and another in Node.js, which
    step you through how to take simple example code from those languages to build
    containers, and run them within Kubernetes. The sections of this chapter are:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨使用Kubernetes所需的第一件事：将软件放入容器中。我们将回顾容器是什么，如何存储和共享镜像，以及如何构建容器。然后，本章继续进行两个示例，一个是Python，另一个是Node.js，它们将引导您如何将这些语言的简单示例代码构建成容器，并在Kubernetes中运行它们。本章的部分内容包括：
- en: Container images
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像
- en: Making your own container
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作自己的容器
- en: Python example—making a container image
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python示例-制作容器镜像
- en: Node.js example—making a container image
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js示例-制作容器镜像
- en: Tagging your container images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给您的容器镜像打标签
- en: Container images
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器镜像
- en: 'The first step for using Kubernetes is getting your software into a container.
    Docker is the easiest way to create these containers, and it is a fairly simple
    process. Let''s take a moment to look at an existing container image to understand
    what choices you will need to make when creating your own containers:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes的第一步是将您的软件放入容器中。Docker是创建这些容器的最简单方法，而且这是一个相当简单的过程。让我们花点时间来查看现有的容器镜像，以了解在创建自己的容器时需要做出什么选择：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First, you''ll see it pulling down a list of files with arcane IDs. You''ll
    see them updating in parallel, as it tries to grab these as they''re available:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将看到它下载具有奥秘ID的文件列表。您会看到它们并行更新，因为它尝试在可用时抓取它们：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And when the downloads are complete, the output will update to say `extracting`,
    and finally `pull complete`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当下载完成时，输出将更新为“提取”，最后为“拉取完成”：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What you saw in the Terminal was Docker downloading the layers that go into
    a container image, pulling them all together, and then verifying the output. Kubernetes
    does exactly this same process when you ask it to run the software, downloading
    the images and then running them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您在终端中看到的是Docker正在下载构成容器镜像的层，将它们全部汇集在一起，然后验证输出。当您要求Kubernetes运行软件时，Kubernetes正是执行这个相同的过程，下载镜像然后运行它们。
- en: 'If you now run the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行以下命令：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will see (perhaps among others) the image listed akin to this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到（也许还有其他）列出的镜像类似于这样：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The image is `211MB` in size, and you'll notice that when we specified `jocatalin/kubernetes-bootcamp:v1`,
    we were specifying both a name, `jocatalin/kubernetes-bootcamp`, and a tag, `v1`.
    In addition, the image has an `IMAGE ID` (`8fafd8af70e9`), which is a unique ID
    for the whole image. If you were to specify a name for an image without a tag,
    the default is to assume you want a default tag of `latest`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该镜像的大小为`211MB`，当我们指定`jocatalin/kubernetes-bootcamp:v1`时，您会注意到我们同时指定了一个名称`jocatalin/kubernetes-bootcamp`和一个标签`v1`。此外，该镜像具有一个`IMAGE
    ID`（`8fafd8af70e9`），这是整个镜像的唯一ID。如果您要为镜像指定一个名称而没有标签，那么默认情况下会假定您想要一个默认标签`latest`。
- en: 'Let''s take a deeper look at the image we just downloaded, using the `docker
    history` command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解刚刚下载的镜像，使用`docker history`命令：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is making explicit what we saw earlier when it downloaded the container:
    that a container image is made up of layers, which build upon the ones below it.
    The layers of a Docker image are quite simple—each layer is the result of a command
    being executed and any changes that the command ended up making on the local filesystem.
    In the previous `docker history` command, you will see a size reported by any
    commands that changed the size of the underlying filesystem.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这明确了我们之前在下载容器时看到的情况：容器镜像由层组成，每一层都建立在它下面的层之上。Docker镜像的层非常简单——每一层都是执行命令和命令在本地文件系统上所做的任何更改的结果。在之前的`docker
    history`命令中，您将看到任何更改底层文件系统大小的命令报告的大小。
- en: The image format was created by Docker and is now formally specified by the
    **OCI** (**Open Container Initiative**) Image Format project. If you want to dig
    into that further, you can find the format and all relevant details at [https://github.com/opencontainers/image-spec](https://github.com/opencontainers/image-spec).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像格式是由Docker创建的，现在由**OCI**（**Open Container Initiative**）Image Format项目正式指定。如果您想进一步了解，可以在[https://github.com/opencontainers/image-spec](https://github.com/opencontainers/image-spec)找到格式和所有相关细节。
- en: Container images, and each of the layers in the images, are typically available
    on the internet. All the examples I use in this book are publicly available. It
    is possible to configure your Kubernetes cluster to use a private image repository,
    and there's documentation at the Kubernetes project for exactly how to do that
    task, available at [https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/](https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/).
    This setup is more private, but at the cost of being more involved and complex
    to set up, so in this book, we will be sticking with publicly available images.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像以及镜像中的每个层通常都可以在互联网上找到。我在本书中使用的所有示例都是公开可用的。可以配置Kubernetes集群使用私有镜像仓库，Kubernetes项目的文档中有关于如何执行该任务的详细说明，网址为[https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/](https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/)。这种设置更加私密，但设置起来更加复杂，因此在本书中，我们将继续使用公开可用的镜像。
- en: 'A container image also includes information on how to run the image, what to
    run, what environment variables to set, and so forth. We can see all those details
    using the `docker inspect` command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像还包括如何运行镜像、要运行什么、要设置哪些环境变量等信息。我们可以使用`docker inspect`命令查看所有这些细节：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding command produces quite a bit of content, describing the container
    image in quite a bit of detail and the metadata that goes along with running the
    code within it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令生成了相当多的内容，详细描述了容器镜像以及其中运行代码所需的元数据：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In addition to the base configuration, a Docker container image can also contain
    a runtime configuration, so there is often a duplicate section defining much of
    what you say under the `ContainerConfig` key:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本配置之外，Docker容器镜像还可以包含运行时配置，因此通常会有一个重复的部分，在`ContainerConfig`键下定义了大部分你所说的内容：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The last section included is an explicit list of the overlays for filesystems
    and how they fit together:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个部分包括了文件系统的叠加的显式列表以及它们如何组合在一起：
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There''s a lot of information in that JSON dump, more than you probably need
    or care about right now. Most importantly, I want you to know that it specifies
    a `cmd` under the `config` section in three parts. This is what will be invoked
    by default if you `run` the container, and it is often called the `Entrypoint`.
    If you put those pieces together and imagine running them yourself in the container,
    you would be running the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: JSON转储中包含了很多信息，可能比你现在需要或关心的要多。最重要的是，我想让你知道它在`config`部分下指定了一个`cmd`，分为三个部分。这是如果你`run`容器时默认会被调用的内容，通常被称为`Entrypoint`。如果你把这些部分组合起来，想象自己在容器中运行它们，你将会运行以下内容：
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Entrypoint` defines what binary will get executed, and any arguments to
    it, and is the key to specify what you want to run and how you want to run it.
    Kubernetes works with this same `Entrypoint` and can override it, with commands
    and arguments to run your software, or run diagnostic tools that you have stored
    in the same container image.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entrypoint`定义了将要执行的二进制文件，以及任何参数，并且是指定你想要运行什么以及如何运行的关键。Kubernetes与这个相同的`Entrypoint`一起工作，并且可以用命令和参数覆盖它，以运行你的软件，或者运行你在同一个容器镜像中存储的诊断工具。'
- en: Container registries
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器注册表
- en: 'In the preceding example, when we invoked the command to pull the container,
    we referenced [https://www.docker.com/](https://www.docker.com/), which is Docker''s
    container registry. There are two other common registries that you will see frequently
    when working with Kubernetes or reading documentation about Kubernetes: [gcr.io](https://cloud.google.com/container-registry/),
    Google''s container registry, and [quay.io](https://quay.io/), CoreOS''s container
    registry. Other companies offer hosted container registries on the internet, and
    you can run your own. Currently, Docker and Quay both offer free hosting for public
    images, so you will see those frequently in documentation and examples. All three
    registries also offer options for private image repositories, typically for a
    relatively small subscription.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当我们调用命令来拉取容器时，我们引用了[https://www.docker.com/](https://www.docker.com/)，这是Docker的容器注册表。在使用Kubernetes或阅读有关Kubernetes的文档时，你经常会看到另外两个常见的注册表：[gcr.io](https://cloud.google.com/container-registry/)，谷歌的容器注册表，以及[quay.io](https://quay.io/)，CoreOS的容器注册表。其他公司在互联网上提供托管的容器注册表，你也可以自己运行。目前，Docker和Quay都为公共镜像提供免费托管，因此你会经常在文档和示例中看到它们。这三个注册表还提供私有镜像仓库的选项，通常需要相对较小的订阅费用。
- en: One of the benefits of publicly available images (and layering on top of those
    images) is that it makes it very easy to compose your images, sharing underlying
    layers. This also implies that those layers can be inspected, and common layers
    searched for security vulnerabilities. There are several open source projects
    aimed at helping provide this information, and several companies have formed that
    help in coordinating the information and scanning. If you subscribe to an image
    repository for your images, they will often include this scanning for vulnerabilities
    in their product offering.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 公开可用的镜像（以及在这些镜像上进行层叠）的一个好处是，它使得非常容易组合你的镜像，共享底层层。这也意味着这些层可以被检查，并且可以搜索常见的层以查找安全漏洞。有几个旨在帮助提供这些信息的开源项目，还有几家公司成立了帮助协调信息和扫描的公司。如果你为你的镜像订阅了一个镜像仓库，它们通常会在其产品中包括这种漏洞扫描。
- en: As a developer, when you use a library in your code, you are responsible for
    how it will operate. You are already responsible for being familiar with how those
    libraries work (or not), and handling any issues when they don't work as expected.
    With the flexibility and control of specifying the whole container, you are equally
    responsible for everything that gets included in the container in the same fashion.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，当您在代码中使用库时，您对其操作负有责任。您已经负责熟悉这些库的工作方式（或者不熟悉），并在它们不按预期工作时处理任何问题。通过指定整个容器的灵活性和控制权，您同样负责以相同的方式包含在容器中的所有内容。
- en: It is easy to forget about the layers that your software is built upon, and
    you may not always have the time to track all the potential security vulnerabilities
    and issues that have arisen with the software that you are building upon. The
    security scans from projects such as Clair ([https://github.com/coreos/clair](https://github.com/coreos/clair))
    can provide you with excellent information about potential vulnerabilities. I
    recommend you consider taking advantage of a service that can provide those details
    for you.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易忘记软件构建所依赖的层，并且您可能没有时间跟踪所有可能出现的安全漏洞和问题，这些问题可能已经出现在您正在构建的软件中。来自Clair等项目的安全扫描（[https://github.com/coreos/clair](https://github.com/coreos/clair)）可以为您提供有关潜在漏洞的出色信息。我建议您考虑利用可以为您提供这些详细信息的服务。
- en: Making your first container
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个容器
- en: Making a container is something easily done with the Docker software and the `docker
    build` command. This command uses a manifest that details how to create the container,
    called a Dockerfile.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker软件和`docker build`命令很容易创建一个容器。这个命令使用一个详细说明如何创建容器的清单，称为Dockerfile。
- en: 'Let''s start with the simplest possible container. Create a file called a Dockerfile
    and add this to it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的容器开始。创建一个名为Dockerfile的文件，并将以下内容添加到其中：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And then, invoke `build`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，调用`build`：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you see a response like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到这样的响应：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then you are either missing the `.` in the command, or ran the command in a
    directory different from where you created the Dockerfile. The `.` is telling
    `docker` where to find Dockerfile (`.` meaning] in this current directory).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您要么在命令中缺少`.`，要么在与创建Dockerfile的目录不同的目录中运行了该命令。`.`告诉`docker`在哪里找到Dockerfile（`.`表示在当前目录中）。
- en: 'What you should see is some output akin to the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This image only has an ID, `f5d273aa2dcb`, not a name, but this is sufficient
    for us to see how this works. If you run this sample example locally, you will
    get a different ID that uniquely identifies the container image. You can run the
    code in the container image using the `docker run f5d273aa2dcb` command. This
    should result in you seeing the following output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图像只有一个ID，`f5d273aa2dcb`，没有名称，但这对我们来说已经足够了解它是如何工作的。如果您在本地运行此示例，您将获得一个唯一标识容器图像的不同ID。您可以使用`docker
    run f5d273aa2dcb`命令在容器图像中运行代码。这应该会导致您看到以下输出：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Take a moment to run `docker history f5d273aa2dcb` and `docker inspect f5d273aa2dcb`
    on the image you just created.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间在刚刚创建的图像上运行`docker history f5d273aa2dcb`和`docker inspect f5d273aa2dcb`。
- en: 'When you''re done, we can delete the Docker image we just made with the following
    command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以使用以下命令删除刚刚创建的Docker图像：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you get an error removing an image, which can happen if you have a stopped
    container that references the image locally, you can force the removal with the
    addition of `-f`. For example, the command that will force the removal of a local
    image would be:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在删除图像时遇到错误，这可能是因为您有一个引用本地图像的已停止容器，您可以通过添加`-f`来强制删除。例如，强制删除本地图像的命令将是：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Dockerfile commands
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile命令
- en: Docker has documentation on how to write a Dockerfile at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/),
    and a set of best practices that they recommend at [https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/](https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/).
    We will cover some of the commands that are common and important to know for building
    your own container images.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Docker有关于如何编写Dockerfile的文档，网址是[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)，以及他们推荐的一套最佳实践，网址是[https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/](https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/)。我们将介绍一些常见且重要的命令，以便你能够构建自己的容器镜像。
- en: 'The following are some of the important Dockerfile build commands that you
    should be aware of:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要的Dockerfile构建命令，你应该知道：
- en: '`FROM` ([https://docs.docker.com/engine/reference/builder/#from](https://docs.docker.com/engine/reference/builder/#from)): `FROM`
    describes the image that you are using as a base to build your container, and
    is generally the first command in a Dockerfile. Docker best practices encourage
    the use of Debian as a base Linux distribution. As you saw from my example earlier,
    I prefer to use Alpine Linux because it is very compact in size. You can also
    use Ubuntu, Fedora, and CentOS, all of which are larger images and include significantly
    more software in their base image. If you are already familiar with a distribution
    of Linux and the tools that are used with it, then I recommend you take advantage
    of that knowledge for making your first containers. You can also frequently find
    containers built specifically to support the language you''re using, such as Node
    or Python. At the time of writing (fall 2017), I downloaded a variety of these
    images to show the relative sizes:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FROM` ([https://docs.docker.com/engine/reference/builder/#from](https://docs.docker.com/engine/reference/builder/#from)):
    `FROM`描述了你用作构建容器基础的图像，并且通常是Dockerfile中的第一个命令。Docker最佳实践鼓励使用Debian作为基础Linux发行版。正如你之前从我的示例中看到的，我更喜欢使用Alpine
    Linux，因为它非常紧凑。你也可以使用Ubuntu、Fedora和CentOS，它们都是更大的图像，并在其基本图像中包含了更多的软件。如果你已经熟悉某个Linux发行版及其使用的工具，那么我建议你利用这些知识来制作你的第一个容器。你还经常可以找到专门构建的容器来支持你正在使用的语言，比如Node或Python。在撰写本文时（2017年秋），我下载了各种这些图像来展示它们的相对大小：'
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the images vary considerably in size.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这些图像的大小差异很大。
- en: You can explore these (and a wide variety of other base images) at [https://hub.docker.com/explore/](https://hub.docker.com/explore/).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://hub.docker.com/explore/](https://hub.docker.com/explore/)上探索这些（以及各种其他基本图像）。
- en: '`RUN` ([https://docs.docker.com/engine/reference/builder/#run](https://docs.docker.com/engine/reference/builder/#run)): `RUN`
    describes commands that you run within the container image that you''re building,
    most frequently used for adding in dependencies or other libraries. If you look
    at Dockerfiles created by others, you''ll often see the `RUN` command used to
    install libraries using commands such as `apt-get install ...` or `rpm -ivh ...`.
    The commands that are used are specific to the choice of base image; `apt-get`,
    for example, is available on Debian and Ubuntu base images, but not on Alpine
    or Fedora. If you put in a `RUN` command that''s not available (or just has a
    typo), then when you''re running the `docker build` command you''ll see an error.
    As an example, when building the Dockerfile:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RUN` ([https://docs.docker.com/engine/reference/builder/#run](https://docs.docker.com/engine/reference/builder/#run)): `RUN`描述了您在构建的容器映像中运行的命令，最常用于添加依赖项或其他库。如果您查看其他人创建的Dockerfile，通常会看到`RUN`命令用于使用诸如`apt-get
    install ...`或`rpm -ivh ...`的命令安装库。使用的命令取决于基本映像的选择；例如，`apt-get`在Debian和Ubuntu基本映像上可用，但在Alpine或Fedora上不可用。如果您输入一个不可用的`RUN`命令（或只是打字错误），那么在运行`docker
    build`命令时会看到错误。例如，在构建Dockerfile时：'
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `/bin/sh -c apt-get install nodejs` command returned a non-zero code: `127`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`/bin/sh -c apt-get install nodejs` 命令返回了非零代码：`127`。'
- en: '`ENV` ([https://docs.docker.com/engine/reference/builder/#env](https://docs.docker.com/engine/reference/builder/#env)): `ENV`
    defines environment variables that will persist and be set prior to invoking your
    software in the container image. These are also set while creating the container
    image, which may cause surprising effects. If you need an environment variable
    set for a specific `RUN` command, for example, it is probably better to define
    it with a single `RUN` command rather than using the `ENV` command. For example,
    using `ENV DEBIAN_FRONTEND` non-interactive may confuse using a later `RUN apt-get
    install …` command on a Debian-based image. In the case where you want to enable
    that for a specific `RUN` command, you can do so by temporarily adding the environment
    variable in front of the single `RUN` command. For example:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ENV` ([https://docs.docker.com/engine/reference/builder/#env](https://docs.docker.com/engine/reference/builder/#env)): `ENV`定义了将在容器映像中持久存在并在调用软件之前设置的环境变量。这些也在创建容器映像时设置，这可能会导致意想不到的影响。例如，如果您需要为特定的`RUN`命令设置环境变量，最好是使用单个`RUN`命令而不是使用`ENV`命令来定义它。例如，在Debian基础映像上使用`ENV
    DEBIAN_FRONTEND`非交互可能会混淆后续的`RUN apt-get install …`命令。在您想要为特定的`RUN`命令启用它的情况下，您可以通过在单个`RUN`命令前临时添加环境变量来实现。例如：'
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`COPY` ([https://docs.docker.com/engine/reference/builder/#copy](https://docs.docker.com/engine/reference/builder/#copy)): `COPY`
    (or the `ADD` command) is how you add your own local files into the container.
    This is often the most effective way to copy your code into the container image
    to run. You can copy an entire directory, or a single file. Along with the `RUN`
    command, this is likely going to be how you do most of the work of creating a
    container image with your code.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`COPY` ([https://docs.docker.com/engine/reference/builder/#copy](https://docs.docker.com/engine/reference/builder/#copy)): `COPY`（或`ADD`命令）是将您自己的本地文件添加到容器中的方法。这通常是将代码复制到容器映像中运行的最有效方式。您可以复制整个目录或单个文件。除了`RUN`命令之外，这可能是您使用代码创建容器映像的大部分工作。'
- en: '`WORKDIR` ([https://docs.docker.com/engine/reference/builder/#workdir](https://docs.docker.com/engine/reference/builder/#workdir)): `WORKDIR`
    makes a local directory and then makes that directory the base for all further
    commands (`RUN`, `COPY`, and so on). It can be extraordinarily convenient for
    `RUN` commands that expect to be run from a local or relative directory, such
    as installation tools such as Node.js `npm`.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WORKDIR` ([https://docs.docker.com/engine/reference/builder/#workdir](https://docs.docker.com/engine/reference/builder/#workdir))：`WORKDIR`创建一个本地目录，然后将该目录作为以后所有命令（`RUN`，`COPY`等）的基础。对于期望从本地或相对目录运行的`RUN`命令，例如Node.js
    `npm`等安装工具，这可能非常方便。'
- en: '`LABEL` ([https://docs.docker.com/engine/reference/builder/#label](https://docs.docker.com/engine/reference/builder/#label)): `LABEL`
    adds values that are visible to `docker inspect` and are generally used as references
    for who is responsible or what is within a container. The `MAINTAINER` command
    was very common earlier, but it has been replaced with the `LABEL` command. Labels
    are built on base images and are additive, so any labels you add will be included
    with labels from a base image you''re using.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LABEL` ([https://docs.docker.com/engine/reference/builder/#label](https://docs.docker.com/engine/reference/builder/#label))：`LABEL`添加的值可在`docker
    inspect`中看到，并通常用作容器内部的责任人或内容的参考。`MAINTAINER`命令以前非常常见，但已被`LABEL`命令取代。标签是基于基本镜像构建的，并且是可累加的，因此您添加的任何标签都将与您使用的基本镜像的标签一起包含在内。'
- en: '`CMD` ([https://docs.docker.com/engine/reference/builder/#cmd](https://docs.docker.com/engine/reference/builder/#cmd))
    and `ENTRYPOINT `([https://docs.docker.com/engine/reference/builder/#entrypoint](https://docs.docker.com/engine/reference/builder/#entrypoint)): `CMD`
    (and the `ENTRYPOINT` command) is how you specify what to run when someone runs
    your container. The most common format is a JSON array, where the first element
    is the command to be invoked, and the second and later elements are arguments
    to that command. `CMD` and `ENTRYPOINT` were made to be used either individually,
    in which case you use either `CMD` or `ENTRYPOINT` to specify the executable to
    run and all arguments, or together, in which case `ENTRYPOINT` should be just
    the executable and `CMD` should be the arguments for that executable.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMD` ([https://docs.docker.com/engine/reference/builder/#cmd](https://docs.docker.com/engine/reference/builder/#cmd))和`ENTRYPOINT`
    ([https://docs.docker.com/engine/reference/builder/#entrypoint](https://docs.docker.com/engine/reference/builder/#entrypoint))：`CMD`（和`ENTRYPOINT`命令）是您指定当有人运行容器时要运行什么的方式。最常见的格式是JSON数组，其中第一个元素是要调用的命令，而第二个及以后的元素是该命令的参数。`CMD`和`ENTRYPOINT`旨在单独使用，这种情况下，您可以使用`CMD`或`ENTRYPOINT`来指定要运行的可执行文件和所有参数，或者一起使用，这种情况下，`ENTRYPOINT`应该只是可执行文件，而`CMD`应该是该可执行文件的参数。'
- en: Example – Python/Flask container image
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - Python/Flask容器镜像
- en: To walk through the details of how to use Kubernetes, I have created two sample
    applications that you can download, or replicate to follow along and try out these
    commands. The first of these is a very simple Python application using the Flask
    library. The sample application is directly from the Flask documentation ([http://flask.pocoo.org/docs/0.12/](http://flask.pocoo.org/docs/0.12/)).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了详细了解如何使用Kubernetes，我创建了两个示例应用程序，您可以下载或复制以便跟随并尝试这些命令。其中一个是使用Flask库的非常简单的Python应用程序。示例应用程序直接来自Flask文档（[http://flask.pocoo.org/docs/0.12/](http://flask.pocoo.org/docs/0.12/)）。
- en: 'You can download a copy of this code from GitHub at [https://github.com/kubernetes-for-developers/kfd-flask/tree/first_container](https://github.com/kubernetes-for-developers/kfd-flask/tree/first_container).
    Since we will evolve these files, the code referenced here is available at the `first_container`
    tag. If you want to use Git to get these files, you can run the following commands:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub上下载这些代码，网址为[https://github.com/kubernetes-for-developers/kfd-flask/tree/first_container](https://github.com/kubernetes-for-developers/kfd-flask/tree/first_container)。由于我们将不断改进这些文件，因此此处引用的代码可在`first_container`标签处获得。如果您想使用Git获取这些文件，可以运行以下命令：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, go into the repository and check out the tag:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，进入存储库并检出标签：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's start with looking at the contents of a Dockerfile, which define what
    gets built into a container and how that happens.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看Dockerfile的内容开始，该文件定义了构建到容器中的内容以及构建过程。
- en: 'The goals we have for creating this Dockerfile are:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建这个Dockerfile的目标是：
- en: Get and install any security patches for the underlying operating system
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取并安装底层操作系统的任何安全补丁
- en: Install the language or runtime that we need to use to run our code
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装我们需要用来运行代码的语言或运行时
- en: Install any dependencies for our code that are not included directly in our
    source control
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装我们的代码中未直接包含的任何依赖项
- en: Copy our code into the container
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的代码复制到容器中
- en: Define how and what to run
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义如何以及何时运行
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This container is based on Alpine Linux. I appreciate the small size of the
    containers, and there is less extraneous software residing in the container. You
    will see several commands that may not be familiar, specifically the `apk` command.
    This is the command-line tool that helps install, update, and remove Alpine Linux
    packages. These commands update the package repository, upgrade all installed
    and pre-existing packages in the image, and then install Python 3 from packages.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此容器基于Alpine Linux。我欣赏容器的小巧尺寸，并且容器中没有多余的软件。您将看到一些可能不熟悉的命令，特别是`apk`命令。这是一个命令行工具，用于帮助安装、更新和删除Alpine
    Linux软件包。这些命令更新软件包存储库，升级镜像中安装的和预先存在的所有软件包，然后从软件包中安装Python 3。
- en: If you are already familiar with Debian commands (such as `apt-get`) or Fedora/CentOS
    commands (such as `rpm`), then I recommend you use those base Linux containers
    for your own work.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经熟悉Debian命令（如`apt-get`）或Fedora/CentOS命令（如`rpm`），那么我建议您使用这些基本Linux容器进行您自己的工作。
- en: The next two commands make a directory on the container at `/opt/exampleapp`
    to house our source code and copy it all into place. The `COPY` command adds everything
    from the local directory into the container, which is probably more than we need.
    You can create a file called `.dockerignore` in the future that will `ignore`
    a set of files based on patterns so that some common files that we don't want
    to be included will be ignored in the `COPY` command.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个命令在容器中创建一个目录`/opt/exampleapp`来存放我们的源代码，并将所有内容复制到指定位置。`COPY`命令将本地目录中的所有内容添加到容器中，这可能比我们需要的要多。您可以在将来创建一个名为`.dockerignore`的文件，该文件将根据模式`ignore`一组文件，以便在`COPY`命令中忽略一些不想包含的常见文件。
- en: Next, you'll see a `RUN` command that installs the application dependencies,
    in this case from the file `requirements.txt`, which is included in the source
    repository. It is good practice to maintain your dependencies in a file like this,
    and the `pip` command was made to support doing exactly that.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将看到一个`RUN`命令，该命令安装应用程序的依赖项，这些依赖项来自名为`requirements.txt`的文件，该文件包含在源代码库中。在这种情况下，将依赖项保存在这样的文件中是一个很好的做法，而`pip`命令就是为了支持这样做而创建的。
- en: The last two commands leverage `ENTRYPOINT` and `CMD` separately. For this simple
    example, I could have used just one or the other. Both are included to show how
    they can be used together, the `CMD` being essentially arguments passed to the
    executable defined in `ENTRYPOINT`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个命令分别利用了 `ENTRYPOINT` 和 `CMD`。对于这个简单的例子，我可以只使用其中一个。两者都包括在内是为了展示它们如何一起使用，`CMD`
    本质上是传递给 `ENTRYPOINT` 中定义的可执行文件的参数。
- en: Building the container
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建容器
- en: 'We will use the `docker build` command to create the container. In a Terminal
    window, change into the directory with the Dockerfile and run the following command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `docker build` 命令来创建容器。在终端窗口中，切换到包含 Dockerfile 的目录，并运行以下命令：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You should see output that looks something like the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Each step in the Dockerfile will be reflected by output of what''s happening
    when Docker is building the image at that step, and with more complex Dockerfiles,
    the output can be quite extensive. As it finishes its build process, it will report
    an overall success or failure, and will also report the container IDs:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 中的每一步都会反映在 Docker 构建镜像时发生的输出，对于更复杂的 Dockerfile，输出可能会非常庞大。在完成构建过程时，它会报告总体成功或失败，并且还会报告容器的
    ID：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When we build the container without any other information, it makes an image
    locally that we can play with (it has an ID), but it doesn't have a name or a
    tag. When you are choosing a name, you will generally want to consider where you
    are hosting your container images. In this case, I am using CoreOS's Quay.io service,
    which offers free hosting for open source container images.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建容器时，如果没有其他信息，它会在本地创建一个我们可以使用的镜像（它有一个 ID），但它没有名称或标签。在选择名称时，通常要考虑您托管容器镜像的位置。在这种情况下，我使用的是
    CoreOS 的 Quay.io 服务，该服务为开源容器镜像提供免费托管。
- en: 'To tag the image that we just created, we can use the `docker tag` command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要为刚刚创建的镜像打标签，我们可以使用 `docker tag` 命令：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This tag contains three relevant parts. The first [quay.io](http://quay.io)
    is the container registry. The second (`kubernetes-for-developers`) is the namespace
    for your container, and the third (`flask`) is the name of the container. We did
    not specify any specific tag for the container, so the `docker` command will use
    the latest.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标签包含三个相关部分。第一个 [quay.io](http://quay.io) 是容器注册表。第二个 (`kubernetes-for-developers`)
    是您容器的命名空间，第三个 (`flask`) 是容器的名称。我们没有为容器指定任何特定的标签，所以 `docker` 命令将使用 latest。
- en: 'You should use tags for releases or other points in time in your development
    that you want to be able to jump back to easily and leverage latest to represent
    your most recent development work, so let''s also tag this as a specific version:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该使用标签来表示发布或开发中的其他时间点，以便您可以轻松地返回到这些时间点，并使用 latest 来表示您最近的开发工作，因此让我们也将其标记为一个特定的版本：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When you share an image with someone else, it is a very good idea to be explicit
    about which image you are working with. As a general rule, consider only using
    the code yourself, and whenever you share the image with any other people, use
    an explicit tag. The tag does not have to be a version, and although there are
    limits on its format, it can be nearly any string.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当您与他人共享镜像时，明确指出您正在使用的镜像是一个非常好的主意。一般来说，只考虑自己使用代码，每当与其他人共享镜像时，都要使用明确的标签。标签不一定是一个版本，虽然它的格式有限制，但几乎可以是任何字符串。
- en: 'You use the `docker push` command to transfer the image to the container repository
    once it''s been tagged. You will need to log in to your container repository first:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `docker push` 命令将已经标记的镜像传输到容器仓库。您需要先登录到您的容器仓库：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And then you can push the image:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以推送这个镜像：
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The push refers to a repository, `[quay.io/kubernetes-for-developers/flask]`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 推送是指一个仓库，`[quay.io/kubernetes-for-developers/flask]`：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You will generally want to build your container with a tag from the start,
    rather than having to do the additional commands. To do that, you can add the
    tag information with the `-t <your_name>` option to the `build` command. For the
    examples in this book, I am using the name `kubernetes-for-developers`, so the
    command I have been using to build the example is:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您希望从一开始就使用标签构建您的容器，而不是必须执行额外的命令。为此，您可以使用`-t <your_name>`选项将标签信息添加到`build`命令中。对于本书中的示例，我使用的名称是`kubernetes-for-developers`，因此我一直在使用以下命令构建示例：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you are following along with this example, use your own value where the
    preceding command has `quay.io/kubernetes-for-developers/flask .`. You should
    see output that looks as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在按照此示例操作，请在先前命令中的`quay.io/kubernetes-for-developers/flask .`处使用您自己的值。您应该看到以下输出：
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Take a moment to read through that output, and notice that in several places
    it reports `Using cache`. You may have also noticed that the command was faster
    than the first time you built the image.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间阅读该输出，并注意在几个地方报告了`Using cache`。您可能还注意到，该命令比您第一次构建镜像时更快。
- en: That is because Docker attempts to reuse any layers that haven't changed so
    that it doesn't have to recreate that work. Since we just did all of those commands,
    it can use the layers from the cache it made while creating the previous image.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Docker尝试重用任何未更改的层，以便它不必重新创建该工作。由于我们刚刚执行了所有这些命令，它可以使用在创建上一个镜像时制作的缓存中的层。
- en: 'If you run the `docker images` command, you should now see it listed:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行`docker images`命令，您现在应该看到它被列出：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you continue with using container images to house and deploy your code,
    you will likely want to automate the process of creating the images. As a general
    pattern, a good build process would be:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您继续使用容器映像来存储和部署您的代码，您可能希望自动化创建映像的过程。作为一般模式，一个良好的构建过程应该是：
- en: Get the code from source control
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源代码控制获取代码
- en: '`docker build`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker build`'
- en: '`docker tag`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker tag`'
- en: '`docker push`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker push`'
- en: This is the process we are using in these examples, and you can automate these
    commands with whatever tooling is most comfortable for you. I recommend you set
    up something that can be run on a command line quickly and consistently.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在这些示例中使用的过程，您可以使用最适合您的工具自动化这些命令。我建议您设置一些可以快速且一致地在命令行上运行的东西。
- en: Running your container
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行您的容器
- en: 'Now, let''s run the container we just made. We will use the `kubectl run` command
    to specify the simplest deployment—just the container:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行刚刚制作的容器。我们将使用`kubectl run`命令来指定最简单的部署——只是容器：
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To see what this is doing, we need to ask the cluster for the current state
    of the resources we just created. When we use the `kubectl run` command, it will
    implicitly create a Deployment resource for us, and as you learned in the last
    chapter, a Deployment has a ReplicaSet within it, and a Pod within the ReplicaSet:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这是在做什么，我们需要向集群询问我们刚刚创建的资源的当前状态。当我们使用`kubectl run`命令时，它将隐式为我们创建一个Deployment资源，并且正如您在上一章中学到的，Deployment中有一个ReplicaSet，ReplicaSet中有一个Pod：
- en: '[PRE37]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can get details on this deployment by asking for the raw data associated
    with the Kubernetes deployment resource `flask`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过请求与Kubernetes部署资源`flask`相关联的原始数据来获取有关此部署的详细信息：
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We could just as easily request the information in `YAML` format, or query
    a subset of these details leveraging JsonPath or the other capabilities of the
    `kubectl` command. The JSON output will be extensive. It will start with a key
    indicating apiVersion from Kubernetes, the kind of resource, and metadata about
    the resource:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以轻松地请求以`YAML`格式的信息，或者查询这些细节的子集，利用JsonPath或`kubectl`命令的其他功能。JSON输出将非常丰富。它将以一个指示来自Kubernetes的apiVersion的键开始，资源的种类以及关于资源的元数据：
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Beneath this is usually the specification of the deployment itself, which has
    a lot of the core of what is running:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之下通常是部署本身的规范，其中包含了大部分正在运行的核心内容。
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And the last part is usually the status, which indicates the current state
    of the deployment, as of the time you made the request for the information:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分通常是状态，它指示了部署的当前状态，即您请求信息的时间。
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Remember that when a Pod runs in Kubernetes, it is running in a sandbox, isolated
    from the rest of the world. Kubernetes does this intentionally, so you can specify
    how Pods are supposed to be connected and what can be accessed from outside the
    cluster. We will cover how to set up external access in a later chapter. In the
    meantime, you can leverage one of two commands with `kubectl` to get direct access
    from your development machine: `kubectl port-forward` or `kubectl proxy`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中运行Pod时，请记住它是在一个沙盒中运行的，与世界其他部分隔离开来。Kubernetes有意这样做，这样您就可以指定Pod应该如何连接以及集群外部可以访问什么。我们将在后面的章节中介绍如何设置外部访问。与此同时，您可以利用`kubectl`中的两个命令直接从开发机器获取访问权限：`kubectl
    port-forward`或`kubectl proxy`。
- en: These commands both work by making proxies from your local development machine
    into the Kubernetes cluster, providing you private and personal access to your
    running code. The `port-forward` command will open a specific TCP (or UDP) port
    and arrange all traffic to forward to your Pod in the cluster. The proxy command
    uses an HTTP proxy that already exists to forward HTTP traffic in and out of your
    Pod. Both of these commands rely on knowing the Pod name to make the connections.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令都是通过将代理从您的本地开发机器到Kubernetes集群，为您提供对正在运行的代码的私人访问权限。`port-forward`命令将打开一个特定的TCP（或UDP）端口，并安排所有流量转发到集群中的Pod。代理命令使用已经存在的HTTP代理来转发HTTP流量进出您的Pod。这两个命令都依赖于知道Pod名称来建立连接。
- en: Pod name
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pod名称
- en: Since we are working with a web server, using a proxy would make the most sense,
    as it will forward HTTP traffic through a URL based on the name of the Pod. Before
    we do that, we will use the `port-forward` command, which will be more relevant
    if what you're writing doesn't use the HTTP protocol.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用一个Web服务器，使用代理是最合理的，因为它将根据Pod的名称将HTTP流量转发到一个URL。在这之前，我们将使用`port-forward`命令，如果您的编写不使用HTTP协议，这将更相关。
- en: 'The key thing you will need is the name of the Pod that was created. When we
    ran `kubectl get pods` earlier, you probably noticed that the name wasn''t just
    `flask`, but included some additional characters in the name: `flask-1599974757-b68pw`.
    When we invoked `kubectl run`, it created a deployment, which consists of a Kubernetes
    ReplicaSet wrapped around a Pod. The first part of the name (`flask`) is from
    the deployment, the second part (`1599974757`) is the unique name assigned to
    the ReplicaSet that was created, and the third part (`b68pw`) is the unique name
    assigned to the Pod that was created. If you run the following command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的关键是创建的Pod的名称。当我们之前运行`kubectl get pods`时，你可能注意到名称不仅仅是`flask`，而是在名称中包含了一些额外的字符：`flask-1599974757-b68pw`。当我们调用`kubectl
    run`时，它创建了一个部署，其中包括一个包裹在Pod周围的Kubernetes ReplicaSet。名称的第一部分（`flask`）来自部署，第二部分（`1599974757`）是分配给创建的ReplicaSet的唯一名称，第三部分（`b68pw`）是分配给创建的Pod的唯一名称。如果你运行以下命令：
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The result will show you the replicasets:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将显示副本集：
- en: '[PRE43]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can see that the ReplicaSet name is the first two parts of the Pod's name.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到ReplicaSet名称是Pod名称的前两部分。
- en: Port forwarding
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端口转发
- en: 'Now we can use that name to ask `kubectl` to set up a proxy that will forward
    all traffic from a local port we specify to a port associated with the Pod we
    determine. Get the full name of the Pod that was created with your deployment
    by looking at the Pods using the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用该名称来要求`kubectl`设置一个代理，将我们指定的本地端口上的所有流量转发到我们确定的Pod关联的端口。通过使用以下命令查看使用部署创建的Pod的完整名称：
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In my example, the result was `flask-1599974757-b68pw`, which can then be used
    with the `port-forward` command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的例子中，结果是`flask-1599974757-b68pw`，然后可以与`port-forward`命令一起使用：
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output should be something like the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is forwarding any and all traffic that gets created on your local machine
    at TCP port `5000` to TCP port `5000` on the Pod `flask-1599974757-b68pw`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将转发在本地机器上创建的任何流量到Pod`flask-1599974757-b68pw`的TCP端口`5000`上的TCP端口`5000`。
- en: You will note that you don't have a Command Prompt back yet, which is because
    the command is actively running to keep this particular tunnel we've requested
    alive. If we cancel or quit the `kubectl` command, typically by pressing *Ctrl*
    + C, then port forwarding will immediately end. `kubectl proxy` works in the same
    fashion, so when you use commands such as `kubectl port-forward` or `kubectl proxy`,
    you will probably want to open another Terminal window to run that command in
    by itself.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到你还没有回到命令提示符，这是因为命令正在积极运行，以保持我们请求的特定隧道活动。如果我们取消或退出`kubectl`命令，通常通过按*Ctrl*
    + C，那么端口转发将立即结束。`kubectl proxy`的工作方式相同，因此当你使用诸如`kubectl port-forward`或`kubectl
    proxy`的命令时，你可能希望打开另一个终端窗口单独运行该命令。
- en: While the command is still running, open a browser and put in this URL: `http://localhost:5000`.
    The response should come back that says `Index Page`. When we invoked the `kubectl
    run` command, I specifically choose port `5000` to match the default from Flask.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当命令仍在运行时，打开浏览器并输入此URL：`http://localhost:5000`。响应应该返回`Index Page`。当我们调用`kubectl
    run`命令时，我特意选择端口`5000`来匹配Flask的默认端口。
- en: Proxy
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: 'The other command you can use to access your Pod is the `kubectl proxy` command.
    The proxy provides access not only to your Pod, but to all of the Kubernetes APIs
    as well. To invoke the proxy, run the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用的另一个命令来访问你的Pod是`kubectl proxy`命令。代理不仅提供对你的Pod的访问，还提供对所有Kubernetes API的访问。要调用代理，运行以下命令：
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And the output will show something akin to the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示类似于以下内容：
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Like the `port-forward` command, you won't get a prompt back in the Terminal
    window until the proxy terminates. While it is active, you can access Kubernetes
    REST API endpoints through this proxy. Open a browser and enter the URL `http://localhost:8001/`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与`port-forward`命令一样，在代理终止之前，您在终端窗口中将不会收到提示。在它处于活动状态时，您可以通过这个代理访问Kubernetes REST
    API端点。打开浏览器，输入URL `http://localhost:8001/`。
- en: 'You should see a long list of URLs in JSON format, something akin to the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个类似以下的JSON格式的URL列表：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'These are accessing the Kubernetes infrastructure directly. One of those URL''s
    is `/api/v1` - and although it wasn''t listed specifically, it uses the Kubernetes
    API server to provide a proxy to Pods based on the name. When we invoked our `run`
    command, we didn''t specify a namespace, so it used the default, which is called
    `default`. The URL pattern to see a Pod is:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是直接访问Kubernetes基础设施。其中一个URL是`/api/v1` - 尽管它没有被明确列出，它使用Kubernetes API服务器来根据名称为Pod提供代理。当我们调用我们的`run`命令时，我们没有指定一个命名空间，所以它使用了默认的命名空间，称为`default`。查看Pod的URL模式是：
- en: '`http://localhost:8001/api/v1/proxy/namespaces/<NAME_OF_NAMESPACE>/pods/<POD_NAME>/`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8001/api/v1/proxy/namespaces/<NAME_OF_NAMESPACE>/pods/<POD_NAME>/`'
- en: 'And in the case of our Pod, this would be:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Pod的情况下，这将是：
- en: '`http://localhost:8001/api/v1/proxy/namespaces/default/pods/flask-1599974757-b68pw/`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8001/api/v1/proxy/namespaces/default/pods/flask-1599974757-b68pw/`'
- en: If you open a URL in your browser created with the Pod name that your Kubernetes
    cluster assigned, it should show you the same output that you saw using the `port-forward`
    command.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中打开一个由Kubernetes集群分配的Pod名称创建的URL，它应该显示与使用`port-forward`命令看到的相同的输出。
- en: How did the proxy know to connect to port 5000 on the container?
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理是如何知道连接到容器上的端口5000的？
- en: 'When you ran a container, Kubernetes did not magically know what TCP ports
    your code is listening on. When we created this deployment using the `kubectl
    run` command, we added the `--port=5000` option at the end of that command. That
    was used by Kubernetes to know that the program should be listening on port `5000`
    for HTTP traffic. If you look back at the output from the `kubectl get deployment
    -o json` command, you will see a section in there under the key containers that
    includes the image we provided, the name of the deployment, and a data structure
    indicating a default port for accessing the container: `5000`. If we had not provided
    the additional details, the proxy would have assumed we wanted to access the container
    at port `80`. Since nothing is running on port `80` with our development container,
    you would have seen an error akin to the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行容器时，Kubernetes并不会神奇地知道您的代码正在侦听哪些TCP端口。当我们使用`kubectl run`命令创建此部署时，我们在该命令的末尾添加了`--port=5000`选项。Kubernetes使用这个选项来知道程序应该在端口`5000`上侦听HTTP流量。如果您回顾一下`kubectl
    get deployment -o json`命令的输出，您会看到其中一个部分在`containers`键下包括我们提供的镜像、部署的名称和一个数据结构，指示访问容器的默认端口为`5000`。如果我们没有提供额外的细节，代理将假定我们希望在端口`80`访问容器。由于我们的开发容器上没有在端口`80`上运行任何内容，您会看到类似于以下的错误：
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Getting logs from your application
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从您的应用程序获取日志
- en: There are more ways to interact with your code running in the container, which
    we'll cover in a future chapter. If the code you run does not listen on a TCP
    socket to provide HTTP traffic, or something equivalent, then you generally want
    to see the output that your code created to know that it's running.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多的方法可以与在容器中运行的代码进行交互，我们将在以后的章节中介绍。如果您运行的代码没有侦听TCP套接字以提供HTTP流量，或者类似的内容，那么通常您希望查看您的代码创建的输出以知道它是否正在运行。
- en: 'Containers are specifically set up to capture any output to STDOUT and STDERR
    from the executable you''ve specified and capture that into logs, which can be
    retrieved with another `kubectl` command: `kubectl logs`. Like the `proxy` and
    `port-forward` commands, this command needs to know the name of the Pod you want
    to interact with.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 容器专门设置为捕获您指定的可执行文件的STDOUT和STDERR的任何输出，并将其捕获到日志中，可以使用另一个`kubectl`命令检索这些日志：`kubectl
    logs`。与`proxy`和`port-forward`命令一样，此命令需要知道您要交互的Pod的名称。
- en: 'Run the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE51]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And you should see some output akin to the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Example – Node.js/Express container image
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - Node.js/Express容器映像
- en: This example follows the same pattern as the Python example, a simple Node.js
    application built with the Express library to walk through the details of how
    to use Kubernetes. If you are more familiar with JavaScript development, this
    example may be more meaningful. The sample application is directly from the Express
    documentation ([https://expressjs.com/en/starter/generator.html](http://flask.pocoo.org/docs/0.12/)).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例遵循与Python示例相同的模式，即使用Express库构建的简单Node.js应用程序，以详细介绍如何使用Kubernetes。如果您更熟悉JavaScript开发，则此示例可能更有意义。示例应用程序直接来自Express文档([https://expressjs.com/en/starter/generator.html](http://flask.pocoo.org/docs/0.12/))。
- en: 'You can get a download a copy of this code from GitHub at [https://github.com/kubernetes-for-developers/kfd-nodejs/tree/first_container](https://github.com/kubernetes-for-developers/kfd-nodejs/tree/first_container).
    Since we will evolve these files, the code referenced here is available at the `first_container` tag.
    If you want to use Git to retrieve these files, you can do so using the following
    commands:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub下载此代码副本[https://github.com/kubernetes-for-developers/kfd-nodejs/tree/first_container](https://github.com/kubernetes-for-developers/kfd-nodejs/tree/first_container)。由于我们将使这些文件发展，此处引用的代码可在`first_container`标签处获得。如果要使用Git检索这些文件，可以使用以下命令：
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Like the Python example, we will start with the Dockerfile. As a reminder,
    this is what defines what gets built into a container, and how it happens. The
    goals of this Dockerfile are:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python示例一样，我们将从Dockerfile开始。提醒一下，这是定义构建到容器中的内容以及构建方式的文件。此Dockerfile的目标是：
- en: Get and install any critical security patches for the underlying operating system
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取并安装基础操作系统的任何关键安全补丁
- en: Install the language or runtime that we'll need to use to run our code
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装我们将需要用来运行我们的代码的语言或运行时
- en: Install any dependencies for our code that aren't included directly in our source
    control
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装我们的代码中未直接包含的任何依赖项
- en: Copy our code into the container
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的代码复制到容器中
- en: Define how and what to run
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义如何以及何时运行
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Like the Python example, this container is based on Alpine Linux. You will see
    several commands that may not be familiar, specifically the `apk` command. As
    a reminder, this command is used to install, update, and remove Alpine Linux packages.
    These commands update the Alpine package repository, upgrade all installed and
    pre-existing packages in the image, and then install `nodejs` and `npm` from packages.
    Those steps basically bring us to a minimal container that can run a Node.js application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python示例一样，此容器基于Alpine Linux。您将看到一些可能不熟悉的命令，特别是`apk`命令。作为提醒，此命令用于安装、更新和删除Alpine
    Linux软件包。这些命令更新Alpine软件包存储库，升级图像中安装的所有已安装和预先存在的软件包，然后从软件包安装`nodejs`和`npm`。这些步骤基本上使我们得到一个可以运行Node.js应用程序的最小容器。
- en: The next commands make a directory in the container at `/src` to house our source
    code, copy in the `package.json` file, and then use `npm` to install the dependencies
    for running the code. The `--production` option used with the `npm install` command
    installs only those items listed in `package.json` that are needed for running
    the code - development dependencies are excluded. Node.js makes it easy and consistent
    to maintain your dependencies with its `package.json` format, and it is good practice
    to separate out dependencies needed in production from those needed in development.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的命令在容器中创建一个目录`/src`来存放我们的源代码，复制`package.json`文件，然后使用`npm`安装运行代码所需的依赖项。`npm
    install`命令与`--production`选项一起使用，只安装`package.json`中列出的运行代码所需的项目 - 开发依赖项被排除在外。Node.js通过其`package.json`格式轻松而一致地维护依赖关系，将生产所需的依赖与开发所需的依赖分开是一个良好的做法。
- en: The last two commands leverage `ENV` and `CMD`. This differs from the Python
    example where I used `CMD` and `ENTRYPOINT` to highlight how they work together.
    In this example, I use the `ENV` command to set the `DEBUG` environment variable
    to match the example instructions in the Express documentation. `CMD` then contains
    a command to start our code, which simply leverages `npm` to run the command defined
    in `package.json`, and uses the earlier `WORKDIR` command to set the local directory
    for that invocation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个命令利用了`ENV`和`CMD`。这与Python示例不同，我在Python示例中使用了`CMD`和`ENTRYPOINT`来突出它们如何一起工作。在这个示例中，我使用`ENV`命令将`DEBUG`环境变量设置为与Express文档中示例指令匹配。然后`CMD`包含一个启动我们代码的命令，简单地利用`npm`运行`package.json`中定义的命令，并使用之前的`WORKDIR`命令为该调用设置本地目录。
- en: Building the container
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建容器
- en: 'We use the same `docker build` command to create the container:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的`docker build`命令来创建容器：
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You should see output that looks something like the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下的输出：
- en: '[PRE56]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As you saw with the Python-based example, every step in the Dockerfile is reflected
    with output showing you what happened as Docker was building the container image
    based on your instructions (the Dockerfile):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在基于Python的示例中看到的那样，Dockerfile中的每个步骤都会反映出输出，显示Docker根据你的指令（Dockerfile）构建容器镜像的过程：
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As with the Python example, this builds a container with only an ID. This example
    also leverages Quay for hosting the images publicly, so we will take the image
    appropriately so we can upload it to Quay:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python示例一样，这将构建一个只有ID的容器。这个示例还利用Quay来公开托管图像，因此我们将适当地获取图像，以便上传到Quay：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As with the Python example, the tag contains three relevant parts - [quay.io](http://quay.io)
    is the container registry. The second (`kubernetes-for-developers`) is the namespace
    for your containers, and the third (`nodejs`) is the name of the container. The
    same commands as the Python example are used to upload the container, referencing
    `nodejs` instead of `flask`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python示例一样，标签包含三个相关部分 - [quay.io](http://quay.io) 是容器注册表。第二个（`kubernetes-for-developers`）是容器的命名空间，第三个（`nodejs`）是容器的名称。与Python示例一样，使用相同的命令上传容器，引用`nodejs`而不是`flask`：
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And when it is complete, you should see something akin to the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你应该看到类似以下的内容：
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Like the Python example, you may want to build and tag in the same command.
    For the Node.js example, that command would be:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python示例一样，你可能希望在同一命令中构建和标记。对于Node.js示例，该命令将是：
- en: '[PRE62]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This, if run immediately after you built the image, should display output that
    looks like the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在构建图像后立即运行，应该显示类似以下的输出：
- en: '[PRE63]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Again, it will be significantly faster as it was using Docker's cache of the
    image layers that were previously built.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用Docker缓存的图像层相比，速度会快得多，因为它使用了先前构建的图像层。
- en: 'If you run the `docker images` command, you should now see it listed:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行`docker images`命令，你现在应该能看到它被列出来了：
- en: '[PRE64]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you are pushing your own images to `quay.io` as a container repository, you
    may need to log in to the website and make the images public in addition to these
    commands. By default, `quay.io` will keep images private, even the public ones,
    until you approve their exposure on their website.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将自己的镜像推送到`quay.io`作为容器仓库，除了这些命令，你可能需要登录网站并将镜像设为公开。默认情况下，`quay.io`会保持镜像私有，即使是公共的，直到你在他们的网站上批准它们的公开。
- en: Running your container
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行你的容器
- en: 'Now, let''s run the container we just made. We will use the `kubectl run` command
    as with the Python example, but replacing flask with `nodejs` to specify the container
    we just made and uploaded:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行刚刚创建的容器。我们将使用`kubectl run`命令，就像Python示例一样，但是用`nodejs`替换flask来指定我们刚刚创建和上传的容器：
- en: '[PRE65]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To see what it''s doing, we need to ask the cluster for the current state of
    the resources we just created:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看它的运行情况，我们需要向集群请求刚刚创建的资源的当前状态：
- en: '[PRE66]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `kubectl run` command works regardless of the language, and in the same
    fashion as the Python example. The simple deployment created in this case is named
    `nodejs`, and we can request the same kinds of information about it that we did
    with the Python example earlier:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl run`命令不受语言限制，并且与Python示例的方式相同。在这种情况下创建的简单部署被命名为`nodejs`，我们可以请求与之前Python示例相同类型的信息：'
- en: '[PRE67]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The JSON output should will be fairly extensive, and will have multiple sections.
    At the top of the output will be `apiVersion`, `kind`, and `metadata` about the
    deployment:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: JSON输出应该会非常详细，并且会有多个部分。输出的顶部会有关于部署的`apiVersion`，`kind`和`metadata`：
- en: '[PRE68]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Typically, underneath that will be `spec`, which has a lot of the core of what
    you''re just asked to be run:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在这之下会有`spec`，其中包含了你刚刚要求运行的核心内容：
- en: '[PRE69]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'And the final section is `status`, which indicates the current state (as of
    the request for this information) of the deployment:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是`status`，它指示了部署的当前状态（截至请求此信息时）：
- en: '[PRE70]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When a Pod runs in Kubernetes, it is running in a sandbox, isolated from the
    rest of the world. Kubernetes does this intentionally, so you can specify what
    systems can communicate with each other, and what can be accessed from outside.
    For most clusters, the defaults for Kubernetes allow any Pod to communicate with
    any other Pod.  Just like the Python example, you can leverage one of two commands
    with `kubectl` to get direct access from your development machine: `kubectl` port-forward
    or `kubectl` proxy.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当Pod在Kubernetes中运行时，它是在一个与世隔绝的沙盒中运行的。Kubernetes故意这样做，这样你就可以指定哪些系统可以相互通信，以及可以从外部访问什么。对于大多数集群，Kubernetes的默认设置允许任何Pod与任何其他Pod通信。就像Python示例一样，你可以利用`kubectl`中的两个命令之一来从开发机器直接访问：`kubectl`
    port-forward或`kubectl` proxy。
- en: Port forwarding
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端口转发
- en: 'Now we can use that name to ask `kubectl` to set up a proxy that will forward
    all traffic from a local port we specify to a port associated with the Pod we
    determine. The Node.js example runs on a different port than the Python example
    (port `3000` instead of port `5000`), so the command needs to be updated accordingly:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个名称来要求`kubectl`设置一个代理，将我们指定的本地端口的所有流量转发到我们确定的Pod关联的端口。Node.js示例在不同的端口上运行（端口`3000`而不是端口`5000`），因此命令需要相应地更新：
- en: '[PRE71]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The output should be something like the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE72]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This is forwarding any and all traffic that gets created on your local machine
    at TCP port `3000` to TCP port `3000` on the `nodejs-568183341-2bw5v` Pod.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将在本地机器上创建的任何流量转发到`nodejs-568183341-2bw5v` Pod上的TCP端口`3000`。
- en: Just as with the Python example, you don't get a Command Prompt back yet because
    the command is actively running to keep this particular tunnel alive. As a reminder,
    you can cancel or quit the `kubectl` command by pressing *Ctrl* + *C* and port
    forwarding will immediately end.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Python 示例一样，因为命令正在运行以保持这个特定的隧道活动，所以你还没有得到一个命令提示符。提醒一下，你可以通过按下 *Ctrl* + *C*
    来取消或退出 `kubectl` 命令，端口转发将立即结束。
- en: While the command is still running, open a browser and put in this URL: `http://localhost:3000`.
    The response should come back that says, `Index Page`. When we invoked the `kubectl
    run` command, I specifically choose port `3000` to match the default from Express.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当命令仍在运行时，打开浏览器并输入此 URL：`http://localhost:3000`。响应应该返回说 `Index Page`。当我们调用 `kubectl
    run` 命令时，我特意选择端口 `3000` 来匹配 Express 的默认端口。
- en: Proxy
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: 'Since this is an HTTP-based application, we can also use the `kubectl proxy`
    command to get access to the responses from our code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个基于 HTTP 的应用程序，我们也可以使用 `kubectl proxy` 命令来访问我们代码的响应：
- en: '[PRE73]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'And the output will show something akin to the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示类似于以下内容：
- en: '[PRE74]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'As a reminder, you won''t get a prompt back in the Terminal window until the
    proxy terminates. Just as with the Python example, we can determine the URL to
    use that the proxy will use to forward to our container based on the Pod name
    and the namespace that we used when invoking the `kubectl run` command. Since
    we did not specify a namespace, it used the default, which is called `default`.
    The URL pattern for accessing the Pod is the same as the Python example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，在代理终止之前，你不会在终端窗口中得到提示符。就像 Python 示例一样，我们可以根据我们在调用 `kubectl run` 命令时使用的
    Pod 名称和命名空间来确定代理将用于转发到我们容器的 URL。由于我们没有指定命名空间，它使用的是默认的 `default`。访问 Pod 的 URL 模式与
    Python 示例相同：
- en: '`http://localhost:8001/api/v1/proxy/namespaces/<NAME_OF_NAMESPACE>/pods/<POD_NAME>/`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8001/api/v1/proxy/namespaces/<NAME_OF_NAMESPACE>/pods/<POD_NAME>/`'
- en: 'And in the case of our Pod, this would be:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Pod 的情况下，这将是：
- en: '`http://localhost:8001/api/v1/proxy/namespaces/default/pods/nodejs-568183341-2bw5v/`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:8001/api/v1/proxy/namespaces/default/pods/nodejs-568183341-2bw5v/`'
- en: If you open a URL in your browser created with the Pod name that your Kubernetes
    cluster assigned, it should show you the same output that you saw using the `port-forward`
    command.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在浏览器中打开一个由你的 Kubernetes 集群分配的 Pod 名称创建的 URL，它应该显示与使用 `port-forward` 命令看到的相同的输出。
- en: Getting logs from your application
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取应用程序的日志
- en: 'Just like the Python example, the Node.js example sends some output to `STDOUT`.
    As the containers are specifically set up to capture any output to `STDOUT` and
    `STDERR` from the executable you''ve specified and capture that into logs, the
    same commands will work to show you the log output from the Node.js application:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Python 示例一样，Node.js 示例也会将一些输出发送到 `STDOUT`。由于容器专门设置来捕获你指定的可执行文件的 `STDOUT`
    和 `STDERR` 的任何输出，并将其捕获到日志中，相同的命令将起作用，以显示来自 Node.js 应用程序的日志输出：
- en: '[PRE75]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This should show you output akin to the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该显示类似于以下的输出：
- en: '[PRE76]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Tagging your container images
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给你的容器图像打标签
- en: Using the `:latest` tag on Docker images is incredibly convenient, but it can
    easily lead to confusion as to what exactly is running. If you do use `:latest`,
    then it is a very good idea to also tell Kubernetes to always attempt to pull
    a new image when loading the container. We will see how to set this in [Chapter
    4](a210420d-4d80-43c1-9acb-531bc6b19b75.xhtml), *Declarative Infrastructure*,when
    we talk about declaratively defining our applications.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 图像上使用 `:latest` 标签非常方便，但很容易导致混淆，不知道到底在运行什么。如果你使用 `:latest`，那么告诉 Kubernetes
    在加载容器时始终尝试拉取新的镜像是一个非常好的主意。我们将在[第 4 章](a210420d-4d80-43c1-9acb-531bc6b19b75.xhtml)中看到如何设置这一点，*声明式基础设施*，当我们谈论声明性地定义我们的应用程序时。
- en: An alternative is to make explicit tags, building with a tag, and also using
    `docker tag` to tag the image as `latest` for the convenience factor, but maintaining
    specific tags within the declarations that you check in to source control. For
    this example, the tag chosen is `0.2.0`, using semantic versioning to represent
    a value to use with the container, and matched to a `git tag` as well.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是制作显式标签，使用标签进行构建，并使用`docker tag`将映像标记为`latest`以方便使用，但在提交到源代码控制时保持特定的标签。对于本示例，选择的标签是`0.2.0`，使用语义化版本表示要与容器一起使用的值，并与`git
    tag`匹配。
- en: 'The steps that were used while making this example were:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作这个示例时使用的步骤是：
- en: '[PRE77]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed what makes up a container, how to store and share
    containers on the internet, and some of the commands you can use to create your
    own containers. We then used that knowledge to walk through an example in Python
    and another in Node.js, creating simple web-based services in both, building those
    into container images, and running them within Kubernetes. In our next chapter,
    we will dive deeper into how to interact with your code once it's been packaged
    into a container and will explore tips for taking full advantage of containers
    and Kubernetes during your development.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了容器的组成，如何在互联网上存储和共享容器，以及一些用于创建自己的容器的命令。然后，我们利用这些知识在Python和Node.js中进行了示例演示，分别创建了简单的基于Web的服务，将它们构建成容器映像，并在Kubernetes中运行它们。在下一章中，我们将深入探讨如何与打包成容器的代码进行交互，并探索在开发过程中充分利用容器和Kubernetes的技巧。
