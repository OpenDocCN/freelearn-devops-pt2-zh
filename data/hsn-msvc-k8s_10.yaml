- en: Testing Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试微服务
- en: Software is the most complex thing humans create. Most programmers can't write
    10 lines of code without any errors occurring. Now, take this common knowledge
    and consider what it takes to write a distributed system made of tens, hundreds,
    or thousands of interacting components that have been designed and implemented
    by large teams using lots of third-party dependencies, lots of data-driven logic,
    and lots of configuration. Over time, many of the original architects and engineers
    that built the system might have left the organization or moved to a different
    role. Requirements change, new technologies are reintroduced, and better practices
    are discovered. The system must evolve to meet all of these changes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件是人类创造的最复杂的东西。大多数程序员在编写10行代码时都无法避免出现错误。现在，考虑一下编写由大量相互作用的组件组成的分布式系统所需的工作，这些组件由大型团队使用大量第三方依赖、大量数据驱动逻辑和大量配置进行设计和实现。随着时间的推移，许多最初构建系统的架构师和工程师可能已经离开组织或转移到不同的角色。需求变化，新技术被重新引入，更好的实践被发现。系统必须发展以满足所有这些变化。
- en: The bottom line is that you have zero chance of building a working non-trivial
    system without rigorous testing. Proper tests are the skeleton that ensures that
    your system works as expected and immediately identifies problems when you introduce
    a breaking change before it makes in into production. A microservices-based architecture
    introduces some unique challenges for testing since many of the workflows touch
    upon multiple microservices and it may be difficult to control the test conditions
    across all the relevant microservices and data stores. Kubernetes introduces its
    own testing challenges since it does so much under the covers, which takes more
    work to create predictable and repeatable tests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是，如果没有严格的测试，你几乎没有机会构建一个可行的非平凡系统。适当的测试是确保系统按预期工作并在引入破坏性变化之前立即识别问题的骨架。基于微服务的架构在测试方面引入了一些独特的挑战，因为许多工作流涉及多个微服务，可能难以控制所有相关微服务和数据存储的测试条件。Kubernetes引入了自己的测试挑战，因为它在幕后做了很多工作，需要更多的工作来创建可预测和可重复的测试。
- en: We will demonstrate all these types of tests within Delinkcious. In particular,
    we will focus on local testing with Kubernetes. Then, we'll discuss the important
    issue of isolation, which allows us to run end-to-end tests without impacting
    our production environments. Finally, we'll see how to deal with data-intensive
    tests.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Delinkcious中演示所有这些类型的测试。特别是，我们将专注于使用Kubernetes进行本地测试。然后，我们将讨论隔离这个重要问题，它允许我们在不影响生产环境的情况下运行端到端测试。最后，我们将看到如何处理数据密集型测试。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Unit testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Local testing with Kubernetes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes进行本地测试
- en: Isolation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离
- en: End to end testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试
- en: Managing test data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理测试数据
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code is split between two Git repositories:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代码分布在两个Git存储库之间：
- en: You can find the code samples here: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter10)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在这里找到代码示例：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter10)
- en: 'You can find the updated Delinkcious application here: [https://github.com/the-gigi/delinkcious/releases/tag/v0.8](https://github.com/the-gigi/delinkcious/releases/tag/v0.8)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在这里找到更新后的Delinkcious应用程序：[https://github.com/the-gigi/delinkcious/releases/tag/v0.8](https://github.com/the-gigi/delinkcious/releases/tag/v0.8)
- en: Unit testing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing is the easiest type of testing to incorporate into your codebase,
    yet it brings a lot of value. When I say it's the easiest, I take it for granted
    that you can use best practices such as proper abstraction, separation of concerns,
    dependency injection, and so on. There is nothing easy about trying to test a
    spaghetti codebase!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是最容易融入代码库的测试类型，但它带来了很多价值。当我说它是最容易的时候，我认为你可以使用最佳实践，比如适当的抽象、关注点分离、依赖注入等等。试图测试一个意大利面代码库并不容易！
- en: Let's talk briefly about unit testing in Go, the Ginkgo test framework, and
    then review some unit tests in Delinkcious.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要谈谈Go中的单元测试、Ginkgo测试框架，然后回顾一些Delinkcious中的单元测试。
- en: Unit testing with Go
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go进行单元测试
- en: Go is a modern language and recognizes the importance of testing. Go encourages
    that for each `foo.go` file you have, to have `foo_test.go`. It also provides
    the testing package, and the Go tool has a `test` command. Let's look at a simple
    example. Here is a `foo.go` file that contains the `safeDivide()` function. This
    function divides integers and returns a result and an error.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种现代语言，认识到测试的重要性。Go鼓励对于每个`foo.go`文件，都有一个`foo_test.go`。它还提供了testing包，Go工具有一个`test`命令。让我们看一个简单的例子。这是一个包含`safeDivide()`函数的`foo.go`文件。这个函数用于整数除法，并返回一个结果和一个错误。
- en: 'If the denominator is non-zero, it returns no error, but if the denominator
    is zero, it returns a `division by zero` error:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分母非零，则不返回错误，但如果分母为零，则返回“除以零”错误：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that Go division uses integer division when both operands are integers.
    This is done so that the result of dividing two integers is always the whole part
    (the fractional part is discarded). For example, 6/4 returns 1.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当两个操作数都是整数时，Go除法使用整数除法。这样做是为了确保两个整数相除的结果始终是整数部分（小数部分被舍弃）。例如，6/4返回1。
- en: 'Here is a Go unit test in a file called `foo_test.go` that tests both non-zero
    and zero denominators and uses the `testing` package. Each `test` function accepts
    a pointer to the `testing.T` object. When a test fails, it calls the `Errorf()`
    method of the `T` object:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个名为`foo_test.go`的Go单元测试文件，测试了非零和零分母，并使用了`testing`包。每个`test`函数接受一个指向`testing.T`对象的指针。当测试失败时，它调用`T`对象的`Errorf()`方法：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, to run the tests, we can use the `go test -v` command. It is part of the
    standard Go tool:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要运行测试，我们可以使用`go test -v`命令。这是标准Go工具的一部分：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Nice – all the tests pass. We can also see how long it took to run the tests.
    Let''s introduce an intentional bug. Now, `safeDivide` subtracts instead of divides:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 很好 - 所有测试都通过了。我们还可以看到测试运行花了多长时间。让我们引入一个有意的错误。现在，`safeDivide`减去了，而不是除以：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We only expect the divide by zero test to pass:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只期望通过零除测试：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We got exactly what we expected.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了我们预期的结果。
- en: There is a lot more to the `testing` package. The `T` object has additional
    methods you can use. There are facilities for benchmarks and for common setups.
    However, overall, due to the ergonomics of the testing package, it's not ideal
    to have call methods on the `T` object. It can also be difficult to manage a complex
    and hierarchical set of tests using the `testing` package without additional tooling
    on top of it. This is exactly where Ginkgo comes into the picture. Let's get to
    know Ginkgo. Delinkcious uses Ginkgo for its unit tests.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`testing`包还有很多内容。`T`对象有其他方法可以使用。它提供了基准测试和常见设置的设施。然而，总的来说，由于测试包的人体工程学，最好不要在`T`对象上调用方法。在没有额外的工具支持的情况下，使用`testing`包管理复杂和分层的测试集也可能会很困难。这正是Ginkgo出现的地方。让我们来了解一下Ginkgo。Delinkcious使用Ginkgo进行单元测试。'
- en: Unit testing with Ginkgo and Gomega
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ginkgo和Gomega进行单元测试
- en: 'Ginkgo ([https://github.com/onsi/ginkgo](https://github.com/onsi/ginkgo)) is
    a **b****ehavior-driven development** (**BDD**) testing framework. It still uses
    the testing package under the covers, but allows you to write tests using a much
    nicer syntax. It also pairs well with Gomega ([https://github.com/onsi/gomega](https://github.com/onsi/gomega)),
    which is an excellent assertions library. Here is what you get with Ginkgo and
    Gomega:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Ginkgo（[https://github.com/onsi/ginkgo](https://github.com/onsi/ginkgo)）是一个**行为驱动开发**（**BDD**）测试框架。它仍然在底层使用测试包，但允许您使用更好的语法编写测试。它还与Gomega（[https://github.com/onsi/gomega](https://github.com/onsi/gomega)）很搭配，后者是一个出色的断言库。使用Ginkgo和Gomega可以获得以下功能：
- en: Write BDD-style tests
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写BDD风格的测试
- en: Arbitrary nested blocks (`Describe`, `Context`, `When`)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任意嵌套块（`Describe`，`Context`，`When`）
- en: Good setup/teardown support (`BeforeEach`, `AfterEach`, `BeforeSuite`, `AfterSuite`)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的设置/拆卸支持（`BeforeEach`，`AfterEach`，`BeforeSuite`，`AfterSuite`）
- en: Focus on one test only or match by regex
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅关注一个测试或通过正则表达式匹配
- en: Skip tests by regex
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过正则表达式跳过测试
- en: Parallelism
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行性
- en: Integration with coverage and benchmarking
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与覆盖率和基准测试的集成
- en: Let's see how Delinkcious uses Ginkgo and Gomega for its unit tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Delinkcious如何在其单元测试中使用Ginkgo和Gomega。
- en: Delinkcious unit testing
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Delinkcious单元测试
- en: 'We''ll use `LinkManager` from the `link_manager` package as an example. It
    has pretty sophisticated interactions: it allows you to manage a data store, hit
    another microservice (social graph service), trigger a serverless function (link
    checker), and respond to link check events. This sounds like a very diverse set
    of dependencies, but as you''ll see, by designing for testability, it is possible
    to achieve a high level of testing without too much complexity.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`link_manager`包中的`LinkManager`作为示例。它具有非常复杂的交互：它允许您管理数据存储，访问另一个微服务（社交图服务），触发无服务器函数（链接检查器）并响应链接检查事件。这听起来是一组非常多样化的依赖关系，但正如您将看到的，通过设计可测试性，可以在不太复杂的情况下实现高水平的测试。
- en: Designing for testability
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计可测试性
- en: Proper testing starts a long time before you write your test. Even if you practice
    **test-driven design** (**TDD**) and you write your tests before the implementation,
    you still need to design the interface of the code you want to test before you
    write the test (otherwise what functions or methods will the test invoke?). With
    Delinkcious, we took a very deliberate approach with abstractions, layers, and
    separation of concerns. All our hard work is going to pay off now.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的测试开始于编写测试之前很长时间。即使您实践**测试驱动设计**（**TDD**）并在实现之前编写测试，您仍然需要在编写测试之前设计要测试的代码的接口（否则测试将调用哪些函数或方法？）。对于Delinkcious，我们采用了非常有意识的方法，包括抽象、层和关注点分离。我们所有的辛勤工作现在将会得到回报。
- en: 'Let''s look at `LinkManager` and just consider its dependencies:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`LinkManager`，并只考虑它的依赖关系：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, `LinkManager` depends on the Delinkcious object model abstract
    package, `link_checker_events`, and standard Go packages.  `LinkManager` doesn't
    depend on the implementation of any other Delinkcious component or on any third-party
    dependency. During testing, we can provide alternative (mock) implementations
    for all the dependencies and have total control of the test environment and the
    result. We'll see how we can go about doing this in the next section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`LinkManager`依赖于Delinkcious对象模型抽象包，`link_checker_events`和标准的Go包。`LinkManager`不依赖于任何其他Delinkcious组件的实现或任何第三方依赖。在测试期间，我们可以为所有依赖项提供替代（模拟）实现，并完全控制测试环境和结果。我们将在下一节中看到如何做到这一点。
- en: The art of mocking
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟的艺术
- en: 'Ideally, an object should have all its dependencies injected when it is created.
    Let''s look at the `NewLinkManager()` function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，对象在创建时应注入所有依赖项。让我们看看`NewLinkManager()`函数：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is almost the ideal situation. We get interfaces to the link store, social
    graph manager, and to the event sink. However, there are two dependencies that
    are not injected here: `link_checker_events` and the built-in `net/http` package.
    Let''s start with mocking the link store, the social graph manager, and the link
    manager event sink, and then consider the more difficult cases.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎是理想的情况。我们得到了链接存储、社交图管理器和事件接收器的接口。然而，这里有两个未注入的依赖项：`link_checker_events`和内置的`net/http`包。让我们从模拟链接存储、社交图管理器和链接管理器事件接收器开始，然后考虑更困难的情况。
- en: '`LinkStore` is an interface that''s defined internally:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkStore`是在内部定义的一个接口：'
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `pkg/link_manager/mock_social_graph_manager.go` file, we can find a
    mock social graph manager that implements `om.SocialGraphManager` and always returns
    the followers that were provided to the `newMockSocialGraphManager()` function
    from the `GetFollowers()` method. This is a great way to reuse the same mock for
    different tests that require different canned responses from `GetFollowers()`.
    The reason the other methods just return nil is that they are not called by `LinkManager`,
    so there''s no need to provide an actual response:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pkg/link_manager/mock_social_graph_manager.go`文件中，我们可以找到一个模拟社交图管理器，它实现了`om.SocialGraphManager`并且总是从`newMockSocialGraphManager()`函数中提供的关注者中返回`GetFollowers()`方法。这是重用相同的模拟来进行不同测试的一个很好的方法，这些测试需要`GetFollowers()`不同的预定义响应。其他方法只返回nil的原因是它们不被`LinkManager`调用，所以不需要提供实际的响应：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The event sink is a little different. We are interested in verifying that when
    various operations, such as `AddLink()`, are called, `LinkManager` properly notifies
    the event sink. In order to do that, we can create a test event sink that implements
    the `om.LinkManagerEvents` interface and keeps track of events coming its way.
    Here is the code in the `pkg/link_manager/test_event_sink.go` file. The `testEventSink`
    struct keeps a map for each event type, where the keys are username and the values
    are a list of links. It updates these maps in response to the various events:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 事件接收器有点不同。我们有兴趣验证当调用各种操作，比如`AddLink()`时，`LinkManager`是否正确通知了事件接收器。为了做到这一点，我们可以创建一个测试事件接收器，它实现了`om.LinkManagerEvents`接口，并跟踪接收到的事件。这是在`pkg/link_manager/test_event_sink.go`文件中的代码。`testEventSink`结构体为每种事件类型保留了一个映射，其中键是用户名，值是链接列表。它根据各种事件更新这些映射：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we've got our mocks in place, let's create the Ginkgo test suite.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了模拟，让我们创建Ginkgo测试套件。
- en: Bootstrapping your test suite
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动测试套件
- en: 'Ginkgo builds on top of Go''s testing package, which is convenient because
    you can run your Ginkgo tests with just `go test`, although Ginkgo also provides
    a CLI called Ginkgo with more options. To bootstrap a test suite for a package,
    run the `ginkgo bootstrap` command. It will generate a file called `<package>_suite_test.go`.
    The file wires up all the Ginkgo tests to the standard Go testing, and also imports
    the `ginkgo` and `gomega` packages. Here is the test suite file for the `link_manager`
    package:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Ginkgo是建立在Go的测试包之上的，这很方便，因为你可以只用`go test`来运行你的Ginkgo测试，尽管Ginkgo还提供了一个名为Ginkgo的CLI，提供了更多的选项。要为一个包启动一个测试套件，运行`ginkgo
    bootstrap`命令。它将生成一个名为`<package>_suite_test.go`的文件。该文件将所有的Ginkgo测试连接到标准的Go测试，并导入`ginkgo`和`gomega`包。这是`link_manager`包的测试套件文件：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the test suite file in place, we can start writing some unit tests.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有了测试套件文件，我们可以开始编写一些单元测试。
- en: Implementing the LinkManager unit tests
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现LinkManager单元测试
- en: 'Let''s look at the test for getting and adding links. There is a lot going
    on there. This is all in the `pkg/link_manager/in_memory_link_manager_test.go` file.
    First, let''s set the scene by importing `ginkgo`, `gomega`, and the `delinkcious`
    object model:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看获取和添加链接的测试。那里有很多事情要做。这都在`pkg/link_manager/in_memory_link_manager_test.go`文件中。首先，让我们通过导入`ginkgo`，`gomega`和`delinkcious`对象模型来设置场景：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Ginkgo `Describe` block describes all the tests in the file and defines
    variables that will be used by multiple tests:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Ginkgo的`Describe`块描述文件中的所有测试，并定义将被多个测试使用的变量：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `BeforeEach()` function is called before each test. It creates a fresh
    mock social graph manager with `liat` as the only follower, a new event sink,
    and initializes the new `LinkManager` with these dependencies, as well as an in-memory
    link store, thus utilizing the dependency injection practice:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeforeEach()`函数在每个测试之前调用。它使用`liat`作为唯一的关注者创建一个新的模拟社交图管理器，一个新的事件接收器，并使用这些依赖项初始化新的`LinkManager`，以及一个内存链接存储，从而利用依赖注入实践：'
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is the actual test. Note the BDD style of defining tests that read like
    English, *It should add and get link*. Let''s break it down piece by piece; first,
    the test makes sure that there are no existing links for the `"gigi"` user by
    calling `GetLinks()` and asserting that the result is empty by using Gomega''s
    `Ω` operator:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实际的测试。注意以BDD风格定义测试，读起来像英语，*应该添加并获取链接*。让我们一步一步地分解；首先，测试确保`"gigi"`用户没有现有链接，通过调用`GetLinks()`并断言结果为空，使用Gomega的`Ω`运算符：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next part is about adding a link and just making sure that no errors occurred:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是关于添加链接并确保没有错误发生的部分：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, the test calls `GetLinks()` and expects the link that was just added to
    be returned:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试调用`GetLinks()`并期望刚刚添加的链接被返回：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, the test makes sure that the event sink recorded the `OnLinkAdded()`
    call for `follower "liat"`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，测试确保事件接收器记录了“follower "liat"”的`OnLinkAdded()`调用：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is a pretty typical unit test that performs the following tasks:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常典型的单元测试，执行以下任务：
- en: Controls the test environment
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制测试环境
- en: Mocks dependencies (social graph manager)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟依赖项（社交图管理器）
- en: Provides recording placeholders for outgoing interactions (test event sink records
    link manager events)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为外部交互提供记录占位符（测试事件接收器记录链接管理器事件）
- en: Executes the code under test (get links and add links)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行被测试的代码（获取链接和添加链接）
- en: Verifies the responses (no links at first; one link is returned after it is
    added)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证响应（一开始没有链接；添加后返回一个链接）
- en: Verifies any outgoing interactions (the event sink received the `OnLinkAdded()`
    event)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证任何外部交互（事件接收器接收到`OnLinkAdded()`事件）
- en: We didn't test error cases here, but it's easy to add. You add bad inputs and
    check the code under the test that returned the expected error.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里没有测试错误情况，但很容易添加。您可以添加错误输入并检查返回预期错误的测试代码。
- en: Should you test everything?
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你应该测试所有吗？
- en: The answer is no! Testing provides a lot of value, but has costs too. The marginal
    value of adding tests is decreasing. Testing *everything* is difficult, if not
    impossible. Considering that testing takes time to develop, it can slow down changes
    to the system (you need to update the tests), and the tests might need to change
    when dependencies change. Testing also takes time and resources to run, which
    can slow down the edit-test-deploy cycle. Also, tests can have bugs too. Finding
    the sweet spot of how much testing you need is a judgement call.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的！测试提供了很多价值，但也有成本。添加测试的边际价值正在减少。测试*所有*是困难的，甚至是不可能的。考虑到测试需要时间来开发，它可能会减慢对系统的更改（您需要更新测试），并且当依赖关系发生变化时，测试可能需要更改。测试还需要时间和资源来运行，这可能会减慢编辑-测试-部署周期。此外，测试也可能存在错误。找到您需要进行多少测试的平衡点是一个判断性的决定。
- en: Unit tests are very valuable, but they are not enough. This is especially true
    for microservice-based architectures where there are a lot of small components
    that may work independently, but fail to work together to accomplish the goals
    of the system. This is where integration tests come in.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试非常有价值，但还不够。这对于基于微服务的架构尤其如此，因为有很多小组件可能可以独立工作，但无法一起实现系统的目标。这就是集成测试的用武之地。
- en: Integration testing
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'Integration testing is a test that includes multiple components that interact
    with each other. Integration tests means testing complete subsystems without or
    very little mocking. Delinkcious has several integration tests focused on particular
    services. These tests are not automated Go tests. They don''t use Ginkgo or the
    standard Go testing. They are executable programs that panic on error. These programs
    are designed to test cross-service interaction and how a service integrates with
    third-party components such as actual data stores. For example, the  `link_manager_e2e`
    test performs the following steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是包括多个相互交互的组件的测试。集成测试意味着在没有或者很少模拟的情况下测试完整的子系统。Delinkcious有几个针对特定服务的集成测试。这些测试不是自动化的Go测试。它们不使用Ginkgo或标准的Go测试。它们是在出现错误时会panic的可执行程序。这些程序旨在测试跨服务的交互以及服务如何与实际数据存储等第三方组件集成。例如，`link_manager_e2e`测试执行以下步骤：
- en: Starts the social graph service and the link service as local processes
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动社交图服务和链接服务作为本地进程
- en: Starts a Postgres DB in a Docker container
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Docker容器中启动一个Postgres数据库
- en: Runs the test against the link service
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对链接服务运行测试
- en: Verifies the results
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证结果
- en: 'Let''s see how it all plays out. The list of imports includes the Postgres
    Golang driver (`lib/pq`), several Delinkcious packages, and a couple of standard
    Go packages (`context`, `log`, and `os`). Note that `pq` is imported as a dash.
    This means that the `pq` name is unavailable. The reason to import a library in
    such an unnamed mode is that it just needs to run some initialization code and
    is not accessed externally. Specifically, `pq` registers a Go driver with the
    standard Go `database/sql` library:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何发挥作用的。导入列表包括Postgres Golang驱动程序（`lib/pq`），几个Delinkcious包，以及一些标准的Go包（`context`，`log`和`os`）。请注意，`pq`被导入为破折号。这意味着`pq`名称不可用。以这种未命名模式导入库的原因是它只需要运行一些初始化代码，不会被外部访问。具体来说，`pq`向标准的Go
    `database/sql`库注册了一个Go驱动程序：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's look at some of the functions that are used to set up the test environments,
    starting with initializing the database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些用于设置测试环境的函数，首先是初始化数据库。
- en: Initializing a test database
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化测试数据库
- en: 'The `initDB()` function calls the `RunLocalDB()` function by passing the name
    of the database (`link_manager`). This is important because if you''re starting
    from fresh, it needs to create the database too. Then, to make sure that the test
    always runs from scratch, it deletes the `tags` and `links` tables, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`initDB()`函数通过传递数据库名称（`link_manager`）调用`RunLocalDB()`函数。这很重要，因为如果你是从头开始的，它也需要创建数据库。然后，为了确保测试总是从头开始运行，它删除`tags`和`links`表，如下所示：'
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Running services
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行服务
- en: 'The test has two separate functions to run the services. These functions are
    very similar. They set environment variables and call the `RunService()` function,
    which we will dive into soon. Both services depend on the value of the `PORT`
    environment variable, and it needs to be different for each of the services. This
    means that it is imperative that we launch the services sequentially and not in
    parallel. Otherwise, a service might end up listening on the wrong port:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 测试有两个单独的函数来运行服务。这些函数非常相似。它们设置环境变量并调用`RunService()`函数，我们很快就会深入了解。两个服务都依赖于`PORT`环境变量的值，并且每个服务的值都需要不同。这意味着我们必须按顺序启动服务，而不是并行启动。否则，服务可能最终会监听错误的端口：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Running the actual test
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行实际测试
- en: 'The `main()` function is the driver of the entire test. It turns on the mutual
    authentication between the link manager and the social graph manager, initializes
    the database, and runs the services (as long as the `RUN_XXX_SERVICE` environment
    variable is `true`):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数是整个测试的驱动程序。它打开了链接管理器和社交图管理器之间的相互认证，初始化数据库，并运行服务（只要`RUN_XXX_SERVICE`环境变量为`true`）：'
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now it''s ready to actually run the test. It uses the link manager client to
    connect to port `8080` on the localhost, which is where the link service is running.
    Then, it calls the `GetLinks()` method, prints the result (should be empty), adds
    a link by calling `AddLink()`, calls `GetLinks()` again, and prints the results
    (should be one link):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它已经准备好实际运行测试了。它使用链接管理器客户端连接到本地主机上的端口`8080`，这是链接服务正在运行的地方。然后，它调用`GetLinks()`方法，打印结果（应该为空），通过调用`AddLink()`添加一个链接，再次调用`GetLinks()`，并打印结果（应该是一个链接）：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This integration test is not automated. It is designed for interactive use where
    the developer can run and debug individual services. If an error occurs, it immediately
    bails out. The results of each operation are simply printed to the screen.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集成测试不是自动化的。它是为了交互式使用而设计的，开发人员可以运行和调试单个服务。如果发生错误，它会立即退出。每个操作的结果只是简单地打印到屏幕上。
- en: 'The rest of the test checks the `UpdateLink()` and `DeleteLink()` operations:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的其余部分检查了`UpdateLink()`和`DeleteLink()`操作：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The fact that the test is conducted through the link manager client library
    ensures that the entire chain is working from client to service to dependent services
    and their data stores.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过链接管理器客户端库进行测试确保了从客户端到服务到依赖服务及其数据存储的整个链条都在工作。
- en: Let's review some test helper functions, which are very useful when we are trying
    to test and debug complex interactions between microservices locally.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些测试助手函数，当我们试图在本地测试和调试微服务之间的复杂交互时，它们非常有用。
- en: Implementing database test helpers
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现数据库测试助手
- en: Before diving into the code, let's consider what we want to accomplish. We want
    a local empty database to be created. We want to launch it as a Docker container,
    but only if it's not running already. In order to do that, we need to check whether
    a Docker container is running already, if we should restart it, or if we should
    run a new one. Then, we will try to connect to the target database and create
    it if it doesn't exist. The service will be responsible for creating the schema
    if needed because the generic DB utilities know nothing about the database schema
    of specific services.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，让我们考虑一下我们想要实现的目标。我们希望创建一个本地空数据库。我们希望将其作为Docker容器启动，但只有在它尚未运行时才这样做。为了做到这一点，我们需要检查Docker容器是否已经在运行，如果我们应该重新启动它，或者我们应该运行一个新的容器。然后，我们将尝试连接到目标数据库，并在不存在时创建它。服务将负责根据需要创建模式，因为通用的DB实用程序对特定服务的数据库模式一无所知。
- en: 'The `db_util.go` file in the `db_util` package contains all the helpers functions.
    First, let''s review the imports that include the standard Go `database/sql` package
    and squirrel – a fluent-style Go library to generate SQL (but not an ORM). The
    Postgres driver library – `pq` – is imported as well:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`db_util`包中的`db_util.go`文件包含所有辅助函数。首先，让我们回顾一下导入的内容，其中包括标准的Go `database/sql`包和squirrel
    - 一个流畅风格的Go库，用于生成SQL（但不是ORM）。还导入了Postgres驱动程序库`pq`：'
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `dbParams` struct contains the information that''s needed to connect to
    the database, and the `defaultDbParams()` function is convenient for getting a
    struct that''s populated with default values:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`dbParams`结构包含连接到数据库所需的信息，`defaultDbParams()`函数方便地获取填充有默认值的结构：'
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can call the `connectToDB()` function by passing the information from the
    `dbParams` struct. If everything goes OK, you''ll get back a handle to the database
    (`*sql.DB`) that you can then use to access the database later:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过传递`dbParams`结构中的信息来调用`connectToDB()`函数。如果一切顺利，您将得到一个数据库句柄（`*sql.DB`），然后可以使用它来以后访问数据库：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With all the preliminaries out of the way, let''s see how the `RunLocalDB()`
    function works. First, it runs a `docker ps -f name=postgres` command, which lists
    the running Docker containers named `postgres` (there can only be one):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有准备工作后，让我们看看`RunLocalDB()`函数是如何工作的。首先，它运行`docker ps -f name=postgres`命令，列出名为`postgres`的正在运行的Docker容器（只能有一个）：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the output is empty, it means there is no such container running, so it
    tries to restart the container in case it has stopped. If that fails too, it just
    runs a new container of the `postgres:alpine` image, exposing the standard `5432`
    port to the local host. Note the `-z` flag. It tells Docker to run the container
    in detached (non-blocking) mode, which allows the function to continue. If it
    fails to run the new container for any reason, it gives up and returns an error:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出为空，这意味着没有正在运行的容器，因此它会尝试重新启动容器，以防它已经停止。如果这也失败了，它就会运行一个新的`postgres:alpine`镜像的容器，将标准的`5432`端口暴露给本地主机。注意`-z`标志。它告诉Docker以分离（非阻塞）模式运行容器，这允许函数继续。如果由于任何原因无法运行新容器，它会放弃并返回错误：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'At this point, we are running a Postgres DB running in a container. We can
    use the `defaultDBParams()` function and call the `EnsureDB()` function, which
    we will examine next:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们正在运行一个在容器中运行的Postgres DB。我们可以使用`defaultDBParams()`函数并调用`EnsureDB()`函数，接下来我们将对其进行检查：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To ensure that the DB is ready, we need to connect to the Postgres DB of the
    postgres instance. Each postgres instance has several built-in databases, including
    the `postgres` database. The Postgres DB of the postgres instance can be used
    to get information and metadata about the instance. In particular, we can query
    the `pg_database` table to check if the target database exists. If it doesn''t
    exist, we can create it by executing the `CREATE database <db name>` command.
    Finally, we connect to the target database and return its handle. As usual, if
    anything goes wrong, we return an error:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保数据库已准备就绪，我们需要连接到postgres实例的Postgres DB。每个postgres实例都有几个内置数据库，包括`postgres`数据库。postgres实例的Postgres DB可用于获取有关实例的信息和元数据。特别是，我们可以查询`pg_database`表以检查目标数据库是否存在。如果不存在，我们可以通过执行`CREATE
    database <db name>`命令来创建它。最后，我们连接到目标数据库并返回其句柄。通常情况下，如果出现任何问题，我们会返回错误：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: That was a deep dive into automatically setting up a database for local tests.
    It's very handy in many situations, even beyond microservices.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个深入研究自动设置本地测试数据库的过程。在许多情况下，甚至超出微服务范围，这非常方便。
- en: Implementing service test helpers
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施服务测试助手
- en: 'Let''s look at some of the helper functions for testing services. The `test_util`
    package is very basic and uses Go standard packages as dependencies:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些测试服务的辅助函数。`test_util`包非常基础，使用Go标准包作为依赖项：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It provides an error checking function and two functions to run and stop services.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了一个错误检查函数和两个运行和停止服务的函数。
- en: Checking errors
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查错误
- en: 'One of the annoying things about Go is the explicit error checking you have
    to do all time. The following snippet is very common; we call a function that
    returns a result and an error, check the error, and if it''s not nil, we do something
    (often, we just return):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Go的一个让人讨厌的事情是你必须一直进行显式的错误检查。以下片段非常常见；我们调用一个返回结果和错误的函数，检查错误，如果它不是nil，我们就做一些事情（通常我们只是返回）：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `Check()` function makes this a little more concise by deciding that it
    will just panic and exit the program (or the current Go routine). This is an acceptable
    choice in a testing scenario where you want to bail out once any failure is encountered:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Check()`函数通过决定它将仅仅恐慌并退出程序（或当前的Go例程）使得这一点更加简洁。这在测试场景中是一个可以接受的选择，因为你希望一旦遇到任何故障就退出：'
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The previous snippet can be shortened to the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段可以缩短为以下内容：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you have code that needs to check many errors, then these small savings accumulate.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码需要检查许多错误，那么这些小的节省会累积起来。
- en: Running a local service
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地运行服务
- en: 'One of the most important helper functions is `RunService()`.  Microservices
    often depend on other microservices. When testing a service, the test code often
    needs to run the dependent services. Here, the code builds a Go service in its
    `target` directory and executes it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的辅助函数之一是`RunService()`。微服务通常依赖于其他微服务。在测试服务时，测试代码通常需要运行依赖的服务。在这里，代码在其`target`目录中构建一个Go服务并执行它：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Running a service is important, but cleaning up at the end of the test by stopping
    all the services that were started by the test is important too.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 运行服务很重要，但在测试结束时清理并停止所有由测试启动的服务也很重要。
- en: Stopping a local service
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止本地服务
- en: 'Stopping a service is as simple as calling the `Done()` method of the context.
    It can be used to signal completion to any code that uses contexts:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 停止服务就像调用上下文的`Done()`方法一样简单。它可以用来向使用上下文的任何代码发出完成信号：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, there is a lot of work involved in running Delinkcious, or even
    just a few parts of Delinkcious locally without the help of Kubernetes. When Delinkcious
    is running, it's great for debugging and troubleshooting, but creating and maintaining
    this setup is tedious and error-prone.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，运行Delinkcious，甚至只是在没有Kubernetes帮助的情况下本地运行Delinkcious的一些部分，都涉及大量的工作。当Delinkcious运行时，它非常适用于调试和故障排除，但创建和维护这个设置是乏味且容易出错的。
- en: Also, even if all the integration tests work, they don't fully replicate the
    Kubernetes cluster, and there may be many failure modes that are not captured.
    Let's see how we can do local testing with Kubernetes itself.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使所有集成测试都能正常工作，它们也无法完全复制Kubernetes集群，可能会有许多未被捕获的故障模式。让我们看看如何使用Kubernetes本身进行本地测试。
- en: Local testing with Kubernetes
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes进行本地测试
- en: One of the hallmarks of Kubernetes is that the same cluster can run anywhere.
    For real-world systems, it's not always trivial if you use services that are not
    available locally or are prohibitively slow or expensive to access locally. The
    trick is to find a good spot between high fidelity and convenience.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的一个特点是同一个集群可以在任何地方运行。对于真实世界的系统来说，如果您使用的服务在本地不可用，或者访问本地的速度太慢或者太昂贵，那么情况就不总是那么简单。关键是要在高保真度和便利性之间找到一个好的平衡点。
- en: Let's write a smoke test that takes Delinkcious through the primary workflow
    of getting links, adding links, and checking their status.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个烟雾测试，让Delinkcious通过获取链接、添加链接和检查它们的状态的主要工作流程。
- en: Writing a smoke test
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写烟雾测试
- en: The Delinkcious smoke test is not an automated one. It can be, but it will require
    special setup to make it work in the CI/CD environment. For real-world production
    systems, I highly recommend that you have an automated smoke test (and other tests,
    too).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Delinkcious烟雾测试不是自动化的。它可以是，但需要特殊的设置才能在CI/CD环境中运行。对于真实的生产系统，我强烈建议您进行自动化的烟雾测试（以及其他测试）。
- en: The code is in the `cmd/smoke_test` directory and consists of a single file, `smoke.go`.
    It exercises Delinkcious though the REST API that's exposed by the API gateway.
    We could write this test in any language because there is no client library. I
    chose to use Go for consistency and to highlight how to consume a raw REST API
    from Go, working directly with URLs, query strings, and JSON payload serialization.
    I also used the Delinkcious object model link as a convenient serialization target.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 代码位于`cmd/smoke_test`目录中，由一个名为`smoke.go`的文件组成。它通过API网关公开的REST API对Delinkcious进行测试。我们可以使用任何语言编写这个测试，因为没有客户端库。我选择使用Go是为了保持一致性，并突出如何从Go中消费原始的REST
    API，直接使用URL、查询字符串和JSON负载序列化。我还使用了Delinkcious对象模型链接作为方便的序列化目标。
- en: 'The test expects a local Minikube cluster where Delinkcious is installed to
    be up and running. Here is the flow of the test:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 测试期望本地Minikube集群中已安装并运行Delinkcious。以下是测试的流程：
- en: Delete our test link to start fresh.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除我们的测试链接以重新开始。
- en: Get links (and print them).
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取链接（并打印它们）。
- en: Add a test link.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试链接。
- en: Get links again (the new link should have a *pending* status).
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次获取链接（新链接应该具有*待定*状态）。
- en: Wait a couple of seconds.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几秒钟。
- en: Get links one more time (the new link should have a *valid* status now).
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次获取链接（新链接现在应该具有*有效*状态）。
- en: 'This simple smoke test goes through a significant portion of Delinkcious functionality,
    such as the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的烟雾测试涵盖了Delinkcious功能的重要部分，例如以下内容：
- en: Hitting the API gateway for multiple endpoints (GET links, POST new link, DELETE
    link).
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命中API网关的多个端点（获取链接、发布新链接、删除链接）。
- en: Verifying the caller identity (via access token).
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证调用者身份（通过访问令牌）。
- en: The API gateway will forward the requests to the link manager service.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关将转发请求到链接管理器服务。
- en: The link manager service will trigger the link checker serverless function.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接管理器服务将触发链接检查器无服务器函数。
- en: The link checker will notify the link manager via NATS about the status of the
    new link.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接检查器将通过NATS通知链接管理器新链接的状态。
- en: Later, we can extend the test to create social relationships, which will involve
    the social graph manager, as well as checking the news service. This will establish
    a comprehensive end-to-end test. For smoke test purposes, the aforementioned workflow
    is just fine.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以后，我们可以扩展测试以创建社交关系，这将涉及社交图管理器，以及检查新闻服务。这将建立一个全面的端到端测试。对于烟雾测试目的，上述工作流程就足够了。
- en: 'Let''s start with the list of imports, which includes a lot of standard Go
    libraries, as well as the Delinkcious `object_model` (for the `Link` struct) package
    and the `test_util` package (for the `Check()` function). We could easily avoid
    these dependencies, but they are familiar and convenient:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入列表开始，其中包括许多标准的Go库，以及Delinkcious的`object_model`（用于`Link`结构）包和`test_util`包（用于`Check()`函数）。我们可以很容易地避免这些依赖关系，但它们是熟悉和方便的：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The next part defines a few variables. `delinkciousUrl` will be initialized
    later. `delinkciousToken` should be available in the environment, and `httpClient`
    is the standard Go HTTP client that we will use to call the Delinkcious REST API:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分定义了一些变量。`delinkciousUrl`稍后将被初始化。`delinkciousToken`应该在环境中可用，`httpClient`是我们将用于调用Delinkcious
    REST API的标准Go HTTP客户端：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With the preliminaries out of the way, we can focus on the test itself. It
    is surprisingly simple and looks pretty much like the high-level description of
    the smoke test. It gets the Delinkcious URL from Minikube using the following
    command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 完成前提工作后，我们可以专注于测试本身。它非常简单，看起来非常像冒烟测试的高级描述。它使用以下命令从Minikube获取Delinkcious URL：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, it calls the `DeleteLink()`, `GetLinks()`, and `AddLink()` functions,
    as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它调用`DeleteLink()`、`GetLinks()`和`AddLink()`函数，如下所示：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `GetLinks()` function constructs the proper URL, creates a new HTTP request,
    adds the authentication token as a header (as required by the API gateway social
    login authentication), and hits the `/links` endpoint. When the response comes
    back, it checks the status code and bails out if there was an error. Otherwise,
    it deserializes the response''s body into the `om.GetLinksResult` struct and prints
    the links:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetLinks()`函数构造正确的URL，创建一个新的HTTP请求，将身份验证令牌作为标头添加（根据API网关社交登录身份验证的要求），并命中`/links`端点。当响应返回时，它检查状态码，并在出现错误时退出。否则，它将响应的主体反序列化为`om.GetLinksResult`结构，并打印链接：'
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `addLink()` function is very similar except that it uses the POST method
    and just checks that the response has an OK status. The function takes a URL and
    a title and constructs a URL (including encoding the query string) to comply with
    the API gateway specification. If the status is not OK, it will use the contents
    of the body as an error message:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`addLink()`函数非常相似，只是它使用POST方法，并且只检查响应是否具有OK状态。该函数接受一个URL和一个标题，并构造一个URL（包括对查询字符串进行编码）以符合API网关规范。如果状态不是OK，它将使用响应的内容作为错误消息：'
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Great! Now, let's see the test in action.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，让我们看看测试是如何运行的。
- en: Running the test
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'Before running the test, we should export `DELINKCIOUS_TOKEN` and make sure
    that Minikube is running:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试之前，我们应该导出`DELINKCIOUS_TOKEN`并确保Minikube正在运行：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To run the test, we just type the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，我们只需输入以下内容：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The results are printed to the console. There was already one invalid link,
    that is, `http://gg.com`. Then, the test added the new link, that is, `https://github.com/the-gigi`.
    The new link''s status was initially pending and then, after a couple of seconds
    when the link check succeeded, it became valid:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将打印到控制台。已经有一个无效的链接，即`http://gg.com`。然后，测试添加了新链接，即`https://github.com/the-gigi`。新链接的状态最初是挂起的，然后在几秒钟后，当链接检查成功时，它变为有效：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Telepresence
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Telepresence
- en: 'Telepresence ([https://www.telepresence.io/](https://www.telepresence.io/))
    is a special tool. It lets you run a service locally as if it''s running inside
    your Kubernetes cluster. Why is that interesting? Consider the smoke test we just
    implemented. If we detect a failure, we would like to do the following three things:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Telepresence ([https://www.telepresence.io/](https://www.telepresence.io/))
    是一个特殊的工具。它允许您在本地运行一个服务，就好像它正在您的Kubernetes集群内运行一样。为什么这很有趣？考虑我们刚刚实施的冒烟测试。如果我们检测到失败，我们希望执行以下三件事：
- en: Find the root cause.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到根本原因。
- en: Fix it.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复它。
- en: Verify that the fix works.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证修复是否有效。
- en: Since we discovered the failure only when running the smoke test on our Kubernetes
    cluster, it is probably a failure that is not detected by our local unit tests.
    The normal way to find the root cause (other than reviewing the code offline)
    is to add a bunch of logging statements, add experimental debug code, comment
    out irrelevant sections and deploy the modified code, rerun the smoke test, and
    try to get a sense about what's broken.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只在Kubernetes集群上运行冒烟测试时才发现了故障，这可能是我们的本地单元测试未检测到的故障。找到根本原因的常规方法（除了离线审查代码之外）是添加一堆日志记录语句，添加实验性调试代码，注释掉无关的部分并部署修改后的代码，重新运行冒烟测试，并尝试了解出现了什么问题。
- en: 'Deploying modified code to a Kubernetes cluster typically involves the following
    steps:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将修改后的代码部署到Kubernetes集群通常涉及以下步骤：
- en: Modifying the code
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改代码
- en: Pushing the modified code to a Git repository (pollute your Git history with
    changes that are only used for debugging)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将修改后的代码推送到Git存储库（污染您的Git历史记录，因为这些更改仅用于调试）
- en: Building an image (often requires running various tests)
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建镜像（通常需要运行各种测试）
- en: Pushing the new image to an image registry
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新镜像推送到镜像注册表
- en: Deploying the new image to the cluster
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新镜像部署到集群
- en: This process is cumbersome and doesn't encourage ad hoc exploration and quick
    edit-debug-fix cycles. There are tools we will explore in [Chapter 11](ba776b0b-35e6-4fbd-9450-78b155daa743.xhtml), *Deploying
    Microservices*, that can skip pushing to the Git repository and automatically
    building your images for you, but the image is still built and deployed to the
    cluster.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程很繁琐，不鼓励临时探索和快速编辑-调试-修复循环。在[第11章](ba776b0b-35e6-4fbd-9450-78b155daa743.xhtml)中，我们将探索一些工具，可以跳过推送到Git存储库并为您自动构建镜像，但镜像仍然会构建并部署到集群。
- en: With Telepresence, you just make changes to the code locally, and Telepresence
    makes sure that your local service becomes a full-fledged member of your cluster.
    It sees the same environment and Kubernetes resources, it can communicate with
    other services though the internal network, and for all intents and purposes it
    is part of the cluster.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Telepresence，您只需在本地对代码进行更改，Telepresence会确保您的本地服务成为集群的一个完整成员。它看到相同的环境和Kubernetes资源，可以通过内部网络与其他服务通信，实际上它是集群的一部分。
- en: Telepresence accomplishes this by installing a proxy inside the cluster that
    reaches out and talks to your local service. This is pretty ingenious. Let's install
    Telepresence and start playing with it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Telepresence通过在集群内安装代理来实现这一点，代理会联系并与您的本地服务进行通信。这非常巧妙。让我们安装Telepresence并开始使用它。
- en: Installing Telepresence
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Telepresence
- en: 'The installation of Telepresence requires the FUSE filesystem:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Telepresence需要FUSE文件系统：
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, we can install Telepresence itself:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以安装Telepresence本身：
- en: '[PRE47]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Running a local link service via Telepresence
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Telepresence运行本地链接服务
- en: Let's run the link manager service locally via Telepresence. First, to demonstrate
    that it is really the local service that is running, we can modify the service
    code. For example, we can print a message when getting links, that is, `"****
    Local link service here! calling GetLinks() ****"`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过Telepresence在本地运行链接管理器服务。首先，为了证明真的是本地服务在运行，我们可以修改服务代码。例如，当获取链接时，我们可以打印一条消息，即`"****
    本地链接服务在这里！调用GetLinks() ****"`。
- en: 'Let''s add it to the `GetLinks` endpoint in `svc/link_service/service/transport.go`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其添加到`svc/link_service/service/transport.go`中的`GetLinks`端点：
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we can build the local link service (with flags recommended by Telepresence)
    and swap the `link-manager` deployment with the local service:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建本地链接服务（使用Telepresence推荐的标志），并将`link-manager`部署与本地服务进行交换：
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note that Telepresence requires `sudo` privileges when you swap a deployment
    for the following tasks:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当您为以下任务交换部署时，Telepresence需要`sudo`权限：
- en: Modifying your local network (via `sshuttle` and `pf/iptables`) for the `vpn-tcp`
    method that's used for Go programs
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改本地网络（通过`sshuttle`和`pf/iptables`）以用于Go程序的`vpn-tcp`方法
- en: Running the `docker` command (for some configurations on Linux)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`docker`命令（对于Linux上的某些配置）
- en: Mounting the remote filesystem for access in a Docker container
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载远程文件系统以在Docker容器中访问
- en: 'To test our new changes, let''s run the `smoke` test again:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的新更改，让我们再次运行`smoke`测试：
- en: '[PRE50]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Looking at the our local service output, we can see that it was indeed invoked
    when the `smoke` test ran:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的本地服务输出，我们可以看到在运行`smoke`测试时确实被调用了：
- en: '[PRE51]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you may recall, the smoke test exercises the API gateway in the cluster,
    so the fact that our local service was invoked shows that it is indeed running
    in the cluster. One interesting fact is that the output of our local service is
    NOT captured by Kubernetes logs. If we search the logs, we find nothing. The following
    command generates no output:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得，smoke测试会在集群中调用API网关，因此我们的本地服务被调用表明它确实在集群中运行。有趣的是，我们本地服务的输出不会被Kubernetes日志捕获。如果我们搜索日志，什么也找不到。以下命令不会生成任何输出：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, let's see what it takes to attach the GoLand debugger to the running local
    service.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何将GoLand调试器连接到正在运行的本地服务。
- en: Attaching to the local link service with GoLand for live debugging
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GoLand附加到本地链接服务进行实时调试
- en: 'This is the holy grail of debugging! We will be connecting to our local link
    service using the GoLand interactive debugger while it''s running as part of the
    Kubernetes cluster. It doesn''t get better than that. Let''s get started:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调试的终极目标！我们将使用GoLand交互式调试器连接到我们的本地链接服务，同时它作为Kubernetes集群的一部分在运行。这再好不过了。让我们开始吧：
- en: First, follow the instructions here to get ready for attaching to a local Go
    process with GoLand: [https://blog.jetbrains.com/go/2019/02/06/debugging-with-goland-getting-started/#debugging-a-running-application-on-the-local-machine](https://blog.jetbrains.com/go/2019/02/06/debugging-with-goland-getting-started/#debugging-a-running-application-on-the-local-machine).
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，按照这里的说明准备好使用GoLand附加到本地Go进程：[https://blog.jetbrains.com/go/2019/02/06/debugging-with-goland-getting-started/#debugging-a-running-application-on-the-local-machine](https://blog.jetbrains.com/go/2019/02/06/debugging-with-goland-getting-started/#debugging-a-running-application-on-the-local-machine)。
- en: 'Then, click the Run | Attach to Process menu option in GoLand, which will bring
    the following dialog box:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在GoLand中点击Run | Attach to Process菜单选项，将会出现以下对话框：
- en: '![](assets/131918fe-55b0-4ec6-a233-0dd4fd1bfc8a.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/131918fe-55b0-4ec6-a233-0dd4fd1bfc8a.png)'
- en: Unfortunately, when GoLand attaches to the process (successfully), Telepresence
    mistakenly thinks that the local service has exited and tears down the tunnel
    to the Kubernetes cluster and its own control process.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当GoLand成功附加到进程时，Telepresence错误地认为本地服务已退出，并关闭了到Kubernetes集群及其自身控制进程的隧道。
- en: The local link service keeps running, but it's not connected to the cluster
    anymore. I opened a GitHub issue for the Telepresence team: [https://github.com/telepresenceio/telepresence/issues/1003](https://github.com/telepresenceio/telepresence/issues/1003).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本地链接服务仍在运行，但不再连接到集群。我为Telepresence团队打开了一个GitHub问题：[https://github.com/telepresenceio/telepresence/issues/1003](https://github.com/telepresenceio/telepresence/issues/1003)。
- en: I later contacted the Telepresence developers, dived into the code, and contributed
    a fix that was merged recently.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 后来我联系了Telepresence开发人员，深入了解了代码，并贡献了最近合并的修复。
- en: See the following PR (Adding support for attaching a debugger to processes under
    Telepresence): [https://github.com/telepresenceio/telepresence/pull/1005](https://github.com/telepresenceio/telepresence/pull/1005).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下PR（为在Telepresence下附加调试器到进程添加支持）：[https://github.com/telepresenceio/telepresence/pull/1005](https://github.com/telepresenceio/telepresence/pull/1005)。
- en: 'If you''re using VS Code for Go programming, you can try your luck by following
    the information here: [https://github.com/Microsoft/vscode-go/wiki/Debugging-Go-code-using-VS-Code](https://github.com/Microsoft/vscode-go/wiki/Debugging-Go-code-using-VS-Code).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用VS Code进行Go编程，可以尝试按照这里的信息进行操作：[https://github.com/Microsoft/vscode-go/wiki/Debugging-Go-code-using-VS-Code](https://github.com/Microsoft/vscode-go/wiki/Debugging-Go-code-using-VS-Code)。
- en: So far, we have written a standalone smoke test and used Telepresence to be
    able to debug locally services that are part of our Kubernetes cluster. It doesn't
    get any better for interactive development. The next section will deal with test
    isolation.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写了一个独立的冒烟测试，并使用Telepresence来能够在我们的Kubernetes集群中本地调试服务。这对于交互式开发来说再好不过了。下一节将处理测试隔离。
- en: Isolating tests
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离测试
- en: Isolation is a key topic with tests. The core idea is that, in general, your
    tests should be isolated from your production environment, or even isolated from
    other shared environments. If tests are not isolated, then changes the tests make
    can impact these environments and vice versa (external changes to these environments
    can break tests that make assumptions). Another level of isolation is between
    tests. If your tests run in parallel and make changes to the same resources, then
    various race conditions can occur and tests can interfere with each other and
    cause false negatives.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离是测试的一个关键主题。核心思想是，一般来说，您的测试应该与生产环境隔离，甚至与其他共享环境隔离。如果测试不是隔离的，那么测试所做的更改可能会影响这些环境，反之亦然（对这些环境的外部更改可能会破坏假设的测试）。另一种隔离级别是在测试之间。如果您的测试并行运行并对相同的资源进行更改，那么各种竞争条件可能会发生，测试可能会相互干扰并导致错误的负面结果。
- en: This can happen if tests don't run in parallel, but neglecting to clean up test
    A can make changes that break test B. Another case where isolation can help is
    when multiple teams or developers want to test incompatible changes. If two developers
    make incompatible changes to a shared environment, at least one of them will experience
    failures. There are various levels of isolation and they often have inverse relation
    to cost – more isolated tests are more expensive to set up.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试不并行运行，但忽略清理测试A可能会导致破坏测试B的更改。隔离可以帮助的另一种情况是当多个团队或开发者想要测试不兼容的更改时。如果两个开发者对共享环境进行了不兼容的更改，其中至少一个将遇到失败。隔离有各种级别，它们通常与成本呈反比-更隔离的测试设置成本更高。
- en: 'Let''s consider the following isolation approaches:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下隔离方法：
- en: Test clusters
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试集群
- en: Test namespaces
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试命名空间
- en: Cross namespace/ cluster
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨命名空间/集群
- en: Test clusters
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试集群
- en: Cluster-level isolation is the highest form of isolation. You run your tests
    in clusters that are totally independent of your production cluster. The challenge
    with this approach is how to keep your test cluster/clusters in sync with your
    production cluster. On the software side, this may not be too difficult with a
    good CI/CD system, but populating and migrating data is often pretty complicated.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 集群级别的隔离是最高形式的隔离。您可以在完全独立于生产集群的集群中运行测试。这种方法的挑战在于如何保持测试集群/集群与生产集群的同步。在软件方面，通过一个良好的CI/CD系统可能并不太困难，但填充和迁移数据通常相当复杂。
- en: 'There are two forms of test clusters:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 测试集群有两种形式：
- en: Each developer gets their own cluster.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个开发者都有自己的集群。
- en: Dedicated clusters for performing system tests.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为执行系统测试而专门设置的集群。
- en: Cluster per developer
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个开发者一个集群
- en: 'Creating a cluster per developer is the ultimate level of isolation. The developer
    doesn''t have to worry about breaking other people''s code or being impacted by
    other people''s code. However, there are some significant downsides for this approach,
    such as the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个开发人员创建一个集群是最高级别的隔离。开发人员不必担心破坏其他人的代码或受其他人的代码影响。但是，这种方法也有一些显著的缺点，例如：
- en: It is often too expensive to provision a full-fledged cluster for each developer.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个开发人员提供一个成熟的集群通常成本太高。
- en: The provisioned cluster often doesn't have high fidelity with the production
    system.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的集群通常与生产系统的高保真度不高。
- en: You will generally still need another integration environment to reconcile changes
    from multiple teams/developers.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常仍然需要另一个集成环境来协调多个团队/开发人员的更改。
- en: With Kubernetes, it may be possible to utilize Minikube as a local cluster per
    developer and avoid many of the downsides.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes，可能可以将Minikube作为每个开发人员的本地集群，并避免许多缺点。
- en: Dedicated clusters for system tests
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统测试的专用集群
- en: Creating dedicated clusters for system tests is a great way to consolidate changes
    and test them one more time before deploying to production. The test cluster can
    run more rigorous tests, depend on external resources, and interact with third-party
    services. Such test clusters are expensive resources, and you must manage them
    carefully.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为系统测试创建专用集群是在部署到生产环境之前，整合更改并再次测试的好方法。测试集群可以运行更严格的测试，依赖外部资源，并与第三方服务交互。这样的测试集群是昂贵的资源，您必须仔细管理它们。
- en: Test namespaces
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试命名空间
- en: Test namespaces are a lightweight form of isolation. They can run side-by-side
    next to the production system and reuse some of the resources of the production
    environment (for example, the control plane). It can be much easier to sync data,
    and on Kubernetes, in particular, writing a custom controller to sync and audit
    the test namespace against the production namespace is a good option.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 测试命名空间是一种轻量级的隔离形式。它们可以与生产系统并行运行，并重用生产环境的一些资源（例如控制平面）。同步数据可能更容易，在Kubernetes上，特别是编写自定义控制器来同步和审计测试命名空间与生产命名空间是一个不错的选择。
- en: The downside of test namespaces is the reduced level of isolation. By default,
    services in different namespaces can still talk to each other. If your system
    is already using multiple namespaces, then you have to be extremely careful to
    keep tests isolated from production.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 测试命名空间的缺点是隔离级别降低。默认情况下，不同命名空间中的服务仍然可以相互通信。如果您的系统已经使用多个命名空间，那么您必须非常小心，以保持测试与生产的隔离。
- en: Writing multi-tenant systems
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写多租户系统
- en: Multi-tenant systems are systems where totally isolated entities share the same
    physical or virtual resources. Kubernetes namespaces provide several mechanisms
    to support this. You can define network policies that prevent connectivity between
    namespaces (except for interaction with the Kubernetes API server). You can define
    resource quotas and limits per namespace to prevent rogue namespaces from hogging
    all the cluster resources. If your system is already set up for multi-tenancy,
    you can treat a test namespace as just another tenant.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 多租户系统是指完全隔离的实体共享相同的物理或虚拟资源的系统。Kubernetes命名空间提供了几种机制来支持这一点。您可以定义网络策略，防止命名空间之间的连接（除了与Kubernetes
    API服务器的交互）。您可以定义每个命名空间的资源配额和限制，以防止恶意命名空间占用所有集群资源。如果您的系统已经设置为多租户，您可以将测试命名空间视为另一个租户。
- en: Cross namespace/cluster
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨命名空间/集群
- en: Sometimes, your system is deployed into multiple coordinated namespaces or even
    multiple clusters. Under these circumstances, you'll need to pay more attention
    on how to design tests that mimic the same architecture, yet be careful that tests
    don't interact with production namespaces or clusters.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您的系统部署到多个协调的命名空间甚至多个集群中。在这种情况下，您需要更加注意如何设计模拟相同架构的测试，同时要小心测试不要与生产命名空间或集群发生交互。
- en: End-to-end testing
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端测试
- en: End-to-end tests are very important for complex distributed systems. The smoke
    test we wrote for Delinkcious is one example of an end-to-end test, but there
    are several other categories. End-to-end tests often run against a dedicated environment
    such as a staging environment, but in some cases they run against the production
    environment itself (with a lot of attention). Since end-to-end tests typically
    take a long time to run and may be slow and expansive to set up, it is not common
    to run them for every commit. Instead, it is common to run them periodically (every
    night, every weekend, or every month) or ad hoc (for example, before an important
    release). There are several categories of end-to-end tests.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试对于复杂的分布式系统非常重要。我们为Delinkcious编写的冒烟测试就是端到端测试的一个例子，但还有其他几个类别。端到端测试通常针对专用环境运行，比如一个暂存环境，但在某些情况下，它们会直接针对生产环境运行（需要特别注意）。由于端到端测试通常需要很长时间才能运行，并且可能设置起来很慢、费用很高，因此通常不会在每次提交时运行。相反，通常会定期运行（每晚、每个周末或每个月）或临时运行（例如，在重要发布之前）。端到端测试有几个类别。
- en: 'We will explore some of the most important categories in the following sections,
    such as the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下部分探讨一些最重要的类别，例如以下内容：
- en: Acceptance testing
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验收测试
- en: Regression testing
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归测试
- en: Performance testing
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试
- en: Acceptance testing
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验收测试
- en: Acceptance testing is a form of testing that verifies that the system behaves
    as expected. It is up to the system stakeholder to decide what is considered as
    acceptable. It could be as simple as a smoke test or as elaborate as testing all
    the possible paths through the code, all failure modes, and all side effects (for
    example, which messages are written to log files). One of the main benefits of
    a good battery of acceptance tests is that it is a forcing function for describing
    your system in terms that make sense for non-engineer stakeholders, such as product
    managers and top management. The ideal situation (I've never seen in it practice)
    is that business stakeholders will be able to write and maintain acceptance tests
    themselves.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试是一种验证系统行为是否符合预期的测试形式。决定什么是可以接受的是系统利益相关者的责任。它可以简单到一个冒烟测试，也可以复杂到测试代码中所有可能的路径、所有故障模式和所有副作用（例如，写入日志文件的消息）。良好的验收测试套件的主要好处之一是它是描述系统的一种强制性手段，这种描述对于非工程师利益相关者（如产品经理和高层管理人员）是有意义的。理想的情况（我从未在实践中见过）是业务利益相关者能够自己编写和维护验收测试。
- en: This is close in spirit to visual programming. I personally believe that all
    automated testing should be written and maintained by the developers, but your
    mileage may vary. Delinkcious currently exposes just a REST API and doesn't have
    a user facing web application. Most systems these days have web applications that
    become the acceptance test boundary. It is common to run acceptance tests in the
    browser. There are many good frameworks. If you prefer to stay with Go, Agouti
    ([https://agouti.org/](https://agouti.org/)) is a great choice. It has tight integration
    with Ginkgo and Gomega and can drive the browser though PhantomJS, Selenium, or
    ChromeDriver.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这在精神上接近于可视化编程。我个人认为所有的自动化测试都应该由开发人员编写和维护，但你的情况可能有所不同。Delinkcious目前只公开了一个REST
    API，并没有用户界面的Web应用程序。大多数系统现在都有成为验收测试边界的Web应用程序。在浏览器中运行验收测试是很常见的。有很多好的框架。如果你喜欢使用Go，Agouti
    ([https://agouti.org/](https://agouti.org/)) 是一个很好的选择。它与Ginkgo和Gomega紧密集成，可以通过PhantomJS、Selenium或ChromeDriver驱动浏览器。
- en: Regression testing
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回归测试
- en: Regression testing is a good option when you just want to make sure that the
    new system doesn't deviate from the behavior of the current system. If you have
    comprehensive acceptance tests, then you just have to make sure that the new version
    of your system passes all the acceptance tests, just like the previous version
    did. However, if your acceptance tests coverage is lacking, you can get some form
    of confidence by bombarding the current system and the new system with the same
    inputs and verify that the outputs are identical. This can be done with fuzz testing
    too, where you generate random inputs.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试是一个很好的选择，当你只想确保新系统不会偏离当前系统的行为时。如果你有全面的验收测试，那么你只需要确保新版本的系统通过所有验收测试，就像之前的版本一样。然而，如果你的验收测试覆盖不足，你可以通过向当前系统和新系统发送相同的输入并验证输出是否相同来获得某种信心。这也可以通过模糊测试来完成，其中你生成随机输入。
- en: Performance testing
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测试
- en: 'Performance testing is a large topic. Here, the goal is to measure the performance
    of the system and not the correctness of its responses. That being said, errors
    can significantly influence performance. Consider the following error handling
    options:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试是一个很大的话题。在这里，目标是衡量系统的性能，而不是其响应的正确性。也就是说，错误可能会显著影响性能。考虑以下错误处理选项：
- en: Return immediately when an error is encountered
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到错误时立即返回
- en: Retry five times and sleep for one second between tries
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试五次，并在尝试之间休眠一秒钟
- en: Now, given these two strategies, consider a request that usually takes about
    two seconds to process. A large number of errors for this request on a naive performance
    test will increase performance when using the first strategy (because requests
    will not be processed and return immediately), but will reduce performance when
    using the second strategy (requests will be retried for five seconds before failing).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑这两种策略，考虑一个通常需要大约两秒来处理的请求。在一个简单的性能测试中，对于这个请求的大量错误将会增加性能，当使用第一种策略时（因为请求将不会被处理并立即返回），但当使用第二种策略时会降低性能（请求将在失败之前重试五秒）。
- en: Microservices architectures often utilize asynchronous processing, queues, and
    other mechanisms that can make it challenging to measure the actual performance
    of the system. In addition, a lot of networking calls are involved, which might
    be volatile.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构通常利用异步处理、队列和其他机制，这可能会使系统的实际性能测试变得具有挑战性。此外，涉及大量的网络调用，这可能是不稳定的。
- en: In addition, performance is not just about response time. It can include CPU
    and memory utilization, a number of external API calls, access to network storage,
    and so on. Performance is also tightly related to availability and cost. In a
    complex cloud-native distributed system, performance tests can often inform and
    guide architectural decisions.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，性能不仅仅是响应时间的问题。它可能包括CPU和内存利用率、外部API调用次数、对网络存储的访问等等。性能也与可用性和成本密切相关。在复杂的云原生分布式系统中，性能测试通常可以指导架构决策。
- en: As you can see, end-to-end testing is quite a complicated issue and must be
    considered with great care, because both the value and the costs of end-to-end
    tests are not trivial. One of the most difficult resources to manage with end-to-end
    tests is the test data.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，端到端测试是一个相当复杂的问题，必须非常谨慎地考虑，因为端到端测试的价值和成本都不容忽视。管理端到端测试中最困难的资源之一就是测试数据。
- en: Let's take a look at some of the approaches for managing test data, their pros,
    and their cons.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些管理测试数据的方法，它们的优缺点。
- en: Managing test data
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理测试数据
- en: With Kubernetes, it is relatively easy to deploy a lot of software, including
    software made of many components, as in typical microservice architectures. However,
    data is much less dynamic. There are different ways to generate and maintain test
    data. Different tactics of test data management are appropriate for different
    types of end-to-end tests. Let's look into synthetic data, manual test data, and
    production snapshots.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes相对容易部署大量软件，包括由许多组件组成的软件，如典型的微服务架构。然而，数据变化要少得多。有不同的方法来生成和维护测试数据。不同的测试数据管理策略适用于不同类型的端到端测试。让我们来看看合成数据、手动测试数据和生产快照。
- en: Synthetic data
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合成数据
- en: 'Synthetic data is test data that you generate programmatically. The pros and
    cons are as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 合成数据是您以编程方式生成的测试数据。其优缺点如下：
- en: '**Pros**:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: Easy to control and update because it is generated programmatically
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于控制和更新，因为它是以编程方式生成的
- en: Easy to create bad data to test error handling
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于创建错误数据以测试错误处理
- en: Easy to create a lot of data
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于创建大量数据
- en: '**Cons**:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: You have to write code to generate it.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要编写代码来生成它。
- en: It can get out of sync with the format of actual data.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能与实际数据格式不同步。
- en: Manual test data
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动测试数据
- en: 'Manual test data is similar to synthetic data, but you create it manually. The
    pros and cons are as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试数据类似于合成数据，但是您需要手动创建它。其优缺点如下：
- en: '**Pros**:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: Ultimate control, including verifying what the out should be
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有终极控制权，包括验证输出应该是什么
- en: Can be based on example data and tweaked lightly
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以基于示例数据，并进行轻微调整。
- en: Easy to start quickly (no need to write and maintain code)
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速启动（无需编写和维护代码）
- en: No need to filter or deanonymize
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需过滤或去匿名化
- en: '**Cons**:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: Tedious and error-prone
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 繁琐且容易出错
- en: Difficult to generate a lot of test data
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以生成大量测试数据
- en: Difficult to generate related data across multiple microservices
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以在多个微服务之间生成相关数据
- en: Have to manually update when the data format changes
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须在数据格式更改时手动更新
- en: Production snapshot
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产快照
- en: 'A production snapshot is literally recording real data and using it to populate
    your test system. The pros and cons are as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 生产快照实际上是记录真实数据并将其用于填充测试系统。其优缺点如下：
- en: '**Pros**:'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: High fidelity to real data
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与真实数据高度一致
- en: Recollection ensures test data is always in sync with production data
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新收集确保测试数据始终与生产数据同步
- en: '**Cons**:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: Need to filter and anonymize sensitive data
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要过滤和去匿名化敏感数据
- en: Data might not support all testing scenarios (for example, error handling)
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据可能不支持所有测试场景（例如，错误处理）
- en: Might be difficult to collect all relevant data
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能难以收集所有相关数据
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we covered the topic of testing and its various flavors: unit
    testing, integration testing, and all kinds of end-to-end testing. We also dived
    deep into how Delinkcious tests are structured. We explored the link manager unit
    tests, added a new smoke test, and introduced Telepresence for expediting the
    edit-test-debug life cycle against a real Kubernetes cluster while modifying the
    code locally.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了测试及其各种类型：单元测试，集成测试和各种端到端测试。我们还深入探讨了Delinkcious测试的结构。我们探索了链接管理器的单元测试，添加了一个新的冒烟测试，并介绍了Telepresence，以加速对真实Kubernetes集群进行编辑-测试-调试生命周期，同时在本地修改代码。
- en: That being said, testing is a spectrum that has costs, and just blindly adding
    more and more tests doesn't make your system better or  higher quality. There
    are many important trade-offs between quantity and quality of tests, such as the
    time it takes to develop and maintain the tests, the time and resources it takes
    to run the tests, and the number and complexity of problems that tests detect
    early. You should have enough context to make those tough decisions for your system
    and choose the testing strategies that will work best for you.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，测试是一个有成本的范围，盲目地添加越来越多的测试并不能使您的系统变得更好或更高质量。在测试数量和质量之间存在许多重要的权衡，例如开发和维护测试所需的时间，运行测试所需的时间和资源，以及测试早期检测到的问题的数量和复杂性。您应该有足够的上下文来为您的系统做出艰难的决策，并选择最适合您的测试策略。
- en: It's also important to remember that testing evolves with the system, and the
    level of testing often has to be ratcheted up when the stakes are higher, even
    for the same organization. If you're a hobbyist developer that has a Beta product
    out there with a few users that just play with it at home, you may not be as rigorous
    in your testing (unless it saves you development time). However, as your company
    grows and gathers more users that use your product for mission-critical applications,
    the impact of problems in your code might require much more stringent testing.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是要记住，随着系统的发展，测试也在不断演变，即使是同一组织，测试的水平在风险更高时通常也必须提高。如果您是一个业余开发人员，发布了一个Beta产品，有一些用户只是在家里玩玩，您可能在测试上不那么严格（除非它可以节省开发时间）。然而，随着您的公司的发展和吸引更多将您的产品用于关键任务的用户，代码中出现问题的影响可能需要更严格的测试。
- en: In the next chapter, we will look at various deployment use cases and situations
    for Delinkcious. Kubernetes and its ecosystem provides many interesting options
    and tools. We will consider both robust deployment to production as well as quick
    developer-focused scenarios.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Delinkcious的各种部署用例和情况。Kubernetes及其生态系统提供了许多有趣的选项和工具。我们将考虑到生产环境的强大部署以及快速的面向开发人员的场景。
- en: Further reading
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following references for more information regarding what
    was covered in this chapter:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下参考资料，了解本章涵盖的更多信息：
- en: '**The Go Programming Language Package testing**: [https://golang.org/pkg/testing/](https://golang.org/pkg/testing/)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Go编程语言包测试**：[https://golang.org/pkg/testing/](https://golang.org/pkg/testing/)'
- en: '**Ginkgo**: [http://onsi.github.io/ginkgo/](http://onsi.github.io/ginkgo/)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ginkgo**：[http://onsi.github.io/ginkgo/](http://onsi.github.io/ginkgo/)'
- en: '**Gomega**: [http://onsi.github.io/gomega/](http://onsi.github.io/gomega/)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gomega**：[http://onsi.github.io/gomega/](http://onsi.github.io/gomega/)'
- en: '**Agouti**: [https://agouti.org/](https://agouti.org/)'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**豚鼠**：[https://agouti.org/](https://agouti.org/)'
- en: '**Telepresence**: [https://telepresence.io](https://telepresence.io)'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程呈现**：[https://telepresence.io](https://telepresence.io)'
