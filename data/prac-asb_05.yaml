- en: Playbooks and Roles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: playbook和角色
- en: So far in this book, we have worked mostly with ad hoc Ansible commands for
    simplicity and to help you to understand the fundamentals. However, the lifeblood
    of Ansible is most certainly the playbook, which is a logical organization of
    tasks (think ad hoc commands) in a structure that creates a useful outcome. This
    might be to deploy a web server on a newly built virtual machine, or it might
    be to apply a security policy. It might even handle the whole build process for
    a virtual machine! The possibilities are endless. Ansible playbooks, as we have
    already covered, are designed to be simple to write and easy to read—they are
    intended to be self-documenting and, as such, will form a valuable part of your
    IT processes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们主要使用临时的Ansible命令来简化操作，并帮助您理解基本原理。然而，Ansible的生命线无疑是playbook，它是任务的逻辑组织（类似于临时命令），以创建有用的结果的结构。这可能是在新建的虚拟机上部署Web服务器，也可能是应用安全策略。甚至可能处理虚拟机的整个构建过程！可能性是无限的。正如我们已经介绍过的，Ansible
    playbook的设计是简单易写、易读——它们旨在自我记录，因此将成为您IT流程中宝贵的一部分。
- en: In this chapter, we will explore playbooks in greater depth, from the basics
    of their creation to more advanced concepts such as running tasks in loops and
    blocks, performing conditional logic, and—perhaps one of the most important concepts
    for playbook organization and code re-use—Ansible roles. We will cover roles in
    more detail later, but please know that this is something you will want to use
    as much as possible when creating manageable playbook code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨playbook，从创建的基础知识到更高级的概念，如循环和块中运行任务、执行条件逻辑，以及playbook组织和代码重用中可能最重要的概念之一——Ansible角色。我们将稍后更详细地介绍角色，但请知道，这是您在创建可管理的playbook代码时希望尽可能使用的内容。
- en: 'Specifically, in this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，我们将涵盖以下主题：
- en: Understanding the playbook framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解playbook框架
- en: Understanding roles—the playbook organizer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解角色——playbook的组织者
- en: Using conditions in your code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中使用条件
- en: Repeating tasks with loops
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用循环重复任务
- en: Grouping tasks using blocks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用块分组任务
- en: Configuring play execution via strategies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过策略配置play执行
- en: Using `ansible-pull`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ansible-pull`
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [Chapter 1](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml), *Getting
    Started with Ansible*, and are using the most recent version available—the examples
    in this chapter were tested with Ansible 2.9\. This chapter also assumes that
    you have at least one additional host to test against, and ideally this should
    be Linux based. Although we will give specific examples of hostnames in this chapter,
    you are free to substitute them with your own hostname and/or IP addresses, and
    details of how to do this will be provided in the appropriate places.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经按照[第1章](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml)中详细介绍的方式在控制主机上安装了Ansible，并且正在使用最新版本——本章中的示例是使用Ansible
    2.9进行测试的。本章还假设您至少有一个额外的主机进行测试，并且最好是基于Linux的。尽管本章中将给出主机名的具体示例，但您可以自由地用自己的主机名和/或IP地址替换它们，如何做到这一点的详细信息将在适当的地方提供。
- en: The code bundle for this chapter is available here: [https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%204](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%204).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包在此处可用：[https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%204](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%204)。
- en: Understanding the playbook framework
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解playbook框架
- en: A playbook allows you to manage multiple configurations and complex deployments
    on many machines simply and easily. This is one of the key benefits of using Ansible
    for the delivery of complex applications. With playbooks, you can organize your
    tasks in a logical structure as tasks are (generally) executed in the order they
    are written, allowing you to have a good deal of control over your automation
    processes. With that said, it is possible to perform tasks asynchronously, so
    where tasks are not executed in sequence, we will highlight this. Our goal is
    that once you complete this chapter, you will understand the best practices for
    writing your own Ansible playbooks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: playbook允许您简单轻松地管理多台机器上的多个配置和复杂部署。这是使用Ansible交付复杂应用程序的关键优势之一。通过playbook，您可以将任务组织成逻辑结构，因为任务通常按照编写的顺序执行，这使您能够对自动化过程有很好的控制。话虽如此，也可以异步执行任务，因此我们将强调任务不按顺序执行的情况。我们的目标是，一旦您完成本章，您将了解编写自己的Ansible
    playbook的最佳实践。
- en: 'Although YAML format is easy to read and write, it is very pedantic when it
    comes to spacing. For example, you cannot use tabs to set indentation even though
    on the screen a tab and four spaces might look identical—in YAML, they are not.
    We recommend that you adopt an editor with YAML support to aid you in writing
    your playbooks if you are doing this for the first time, perhaps Vim, Visual Studio
    Code, or Eclipse, as these will help you to ensure that your indentation is correct. To
    test the playbooks we develop in this chapter, we will reuse a variant of an inventory
    created in [Chapter 3](1bbd0c5e-1eb1-4521-b84d-16cc07083f64.xhtml), *Defining
    Your* *Inventory* (unless stated otherwise):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管YAML格式易于阅读和编写，但在间距方面非常严谨。例如，您不能使用制表符来设置缩进，即使在屏幕上，制表符和四个空格看起来可能相同——在YAML中，它们并不相同。如果您是第一次编写playbook，我们建议您采用支持YAML的编辑器，例如Vim、Visual
    Studio Code或Eclipse，这些编辑器将帮助您确保缩进正确。为了测试本章中开发的playbook，我们将重复使用[第3章](1bbd0c5e-1eb1-4521-b84d-16cc07083f64.xhtml)中创建的清单的变体，*定义您的清单*（除非另有说明）：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s dive right in and get started writing a playbook. In the section entitled *Breaking
    down the Ansible components* in [Chapter 2](da04dfe7-d42f-41dd-93a2-c1db97a7fbb1.xhtml),* Understanding
    the Fundamentals of Ansible,* we covered some of the basic aspects of a playbook
    so we won''t repeat these in detail here, but rather build on them to show you
    what playbook development is all about:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即开始编写一个playbook。在[第2章](da04dfe7-d42f-41dd-93a2-c1db97a7fbb1.xhtml)的*理解Ansible基础*中的*分解Ansible组件*一节中，我们涵盖了playbook的一些基本方面，因此我们不会在这里详细重复，而是在此基础上展示playbook开发的内容：
- en: 'Create a simple playbook to run on the hosts in the `frontends` host group
    defined in our inventory file. We can set the user that will access the hosts
    using the `remote_user` directive in the playbook as demonstrated in the following
    (you can also use the `--user` switch on the command line, but as this chapter
    is about playbook development, we''ll ignore that for now):'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的playbook，在我们的清单文件中定义的`frontends`主机组中运行。我们可以在playbook中使用`remote_user`指令设置访问主机的用户，如下所示（您也可以在命令行上使用`--user`开关，但由于本章是关于playbook开发的，我们暂时忽略它）：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add another task below the first to run the `shell` module (that will, in turn,
    run the `ls` command on the remote hosts). We''ll also add the `ignore_errors`
    directive to this task to ensure that our playbook doesn''t fail if the `ls` command
    fails (for example, if the directory we''re trying to list doesn''t exist). Be
    careful with the indentation and ensure it matches that of the first part of the
    file:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个任务下面添加另一个任务来运行`shell`模块（这将依次在远程主机上运行`ls`命令）。我们还将在这个任务中添加`ignore_errors`指令，以确保如果`ls`命令失败（例如，如果我们尝试列出的目录不存在），我们的playbook不会失败。小心缩进，并确保它与文件的第一部分匹配：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s see how our newly created playbook behaves when we run it:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们运行时，我们新创建的playbook的行为如何：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From the output of the playbook run, you can see that our two tasks were executed
    in the order in which they were specified. We can see that the `ls` command failed
    because we tried to list a directory that did not exist, but the playbook did
    not register any `failed` tasks because we set `ignore_errors` to `true` for this
    task (and only this task).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从playbook运行的输出中，您可以看到我们的两个任务是按照指定的顺序执行的。我们可以看到`ls`命令失败，因为我们尝试列出一个不存在的目录，但是playbook没有注册任何`failed`任务，因为我们为这个任务设置了`ignore_errors`为`true`（仅针对这个任务）。
- en: Most Ansible modules (with the exception of those that run user-defined commands
    such as `shell`, `command`, and `raw`) are coded to be idempotent, that is to
    say, if you run the same task twice, the results will be the same, and the task
    will not make the same change twice—if it detects that the action it is being
    requested to perform has been completed, then it does not perform it a second
    time. This, of course, is not possible for the aforementioned modules as they
    could be used to perform just about any conceivable task—hence, how could the
    module know it was being performed twice?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Ansible模块（除了运行用户定义命令的模块，如`shell`、`command`和`raw`）都被编码为幂等的，也就是说，如果您运行相同的任务两次，结果将是相同的，并且任务不会进行相同的更改两次
    - 如果检测到被请求执行的操作已经完成，那么它不会再次执行。当然，对于前述模块来说这是不可能的，因为它们可以用于执行几乎任何可以想象的任务 - 因此，模块如何知道它被执行了两次呢？
- en: 'Every module returns a set of results and among these results is the task status.
    You can see these summarized at the bottom of the preceding playbook run output,
    and their meaning is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都会返回一组结果，其中包括任务状态。您可以在前面playbook运行输出的底部看到这些总结，它们的含义如下：
- en: '`ok`: The task ran successfully and no changes were made.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ok`：任务成功运行，没有进行任何更改。'
- en: '`changed`: The task ran successfully and a change was made.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`changed`：任务成功运行，并进行了更改。'
- en: '`failed`: The task failed to run.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failed`：任务运行失败。'
- en: '`unreachable`: The host was unreachable to run the task on.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unreachable`：无法访问主机以运行任务。'
- en: '`skipped`: This task was skipped.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skipped`：此任务被跳过。'
- en: '`ignored`: This task was ignored (for example, in the case of `ignore_errors`).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignored`：此任务被忽略（例如，在`ignore_errors`的情况下）。'
- en: '`rescued`: We will see an example of this later when we look at blocks and
    rescue tasks.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rescued`：稍后我们将在查看块和救援任务时看到一个例子。'
- en: 'These statuses can be very useful—for example, if we have a task to deploy
    a new Apache configuration file from a template, we know we must restart the Apache
    service for the changes to be picked up. However, we only want to do this if the
    file was actually changed—if no changes were made, we don''t want to needlessly
    restart Apache as it would interrupt people who might be using the service. Hence,
    we can use the `notify` action, which tells Ansible to call a `handler` when (and
    only when) the result from a task is `changed`. In brief, a handler is a special
    type of task that is run as a result of a `notify`. However, unlike Ansible playbook
    tasks, which are performed in sequence, handlers are all grouped together and
    run at the very end of the play. Also, they can be notified more than once but
    will only be run once regardless, again preventing needless service restarts.
    Consider the following playbook:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态可能非常有用，例如，如果我们有一个任务从模板部署新的Apache配置文件，我们知道必须重新启动Apache服务才能应用更改。但是，我们只想在文件实际更改时才这样做
    - 如果没有进行任何更改，我们不希望不必要地重新启动Apache，因为这会打断可能正在使用服务的人。因此，我们可以使用`notify`操作，告诉Ansible在任务结果为`changed`时（仅在此时）调用一个`handler`。简而言之，处理程序是一种特殊类型的任务，作为`notify`的结果而运行。但是，与按顺序执行的Ansible
    playbook任务不同，处理程序都被分组在一起，并在play的最后运行。此外，它们可以被通知多次，但无论如何只会运行一次，再次防止不必要的服务重启。考虑以下playbook：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To keep the output concise, I''ve turned off fact-gathering for this playbook
    (we won''t use them in any of the tasks). I''m also running this on just one host
    again for conciseness, but you are welcome to expand the demo code as you wish.
    If we run this task a first time, we will see the following results:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持输出简洁，我已经关闭了这个playbook的事实收集（我们不会在任何任务中使用它们）。出于简洁起见，我再次只在一个主机上运行，但您可以根据需要扩展演示代码。如果我们第一次运行这个任务，我们将看到以下结果：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice how the handler was run at the end, as the configuration file was updated.
    However, if we run this playbook a second time without making any changes to the
    template or configuration file, we will see something like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当配置文件更新时，处理程序被运行。然而，如果我们再次运行这个playbook，而没有对模板或配置文件进行任何更改，我们将看到类似以下的结果：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This time, the handler was not called as the result from the configuration
    task as OK. All handlers should have a globally unique name so that the notify
    action can call the correct handler. You could also call multiple handlers by
    setting a common name for using the `listen` directive—this way, you can call
    either the handler `name` or the `listen` string—as demonstrated in the following
    example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，由于配置任务的结果是OK，处理程序没有被调用。所有处理程序的名称应该是全局唯一的，这样通知操作才能调用正确的处理程序。您还可以通过设置一个公共名称来调用多个处理程序，使用`listen`指令——这样，您可以调用`name`或`listen`字符串中的任何一个处理程序，就像下面的示例中演示的那样：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We only have one task in the playbook, but when we run it, both handlers are
    called. Also, remember that we said earlier that `command` was among a set of
    modules that were a special case because they can''t detect whether a change has
    occurred—as a result, they always return the `changed` value, and so, in this
    demo playbook, the handlers will always be notified:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的playbook中只有一个任务，但当我们运行它时，两个处理程序都会被调用。另外，请记住我们之前说过的，`command`是一组特殊情况下的模块之一，因为它们无法检测到是否发生了更改——因此，它们总是返回`changed`值，因此，在这个演示playbook中，处理程序将始终被通知：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These are some of the fundamentals that you need to know to start writing your
    own playbooks. With these under your belt, let's run through a comparison of ad
    hoc commands and playbooks in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是您需要了解的一些基础知识，以开始编写自己的playbooks。有了这些知识，让我们在下一节中比较临时命令和playbooks。
- en: Comparing playbooks and ad hoc tasks
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较playbooks和临时任务
- en: Ad hoc commands allow you to quickly create and execute one-off commands, without
    keeping any record of what was done (other than perhaps your shell history). These
    serve an important purpose and can be very valuable in getting small changes made
    quickly and for learning Ansible and its modules.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 临时命令允许您快速创建和执行一次性命令，而不保留任何已完成的记录（除了可能是您的shell历史）。这些命令具有重要的作用，并且在快速进行小改动和学习Ansible及其模块方面非常有价值。
- en: Playbooks, by contrast, are logically organized sets of tasks (each could conceivably
    be an ad hoc command), put together in a sequence that performs one bigger action.
    The addition of conditional logic, error handling, and so on means that, very
    often, the benefits of playbooks outweigh the usefulness of ad hoc commands. In
    addition, provided you keep them organized, you will have copies of all previous
    playbooks that you run and so you will be able to refer back (if ever you need
    to) to see what you ran and when.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，playbooks是逻辑上组织的一系列任务（每个任务都可以是一个临时命令），按顺序组合在一起执行一个更大的动作。条件逻辑、错误处理等的添加意味着，很多时候，playbooks的好处超过了临时命令的用处。此外，只要保持它们有组织，你将拥有你运行的所有以前的playbooks的副本，因此你将能够回顾（如果你需要的话）看看你运行了什么以及何时运行的。
- en: Let's develop a practical example—suppose you want to install Apache 2.4 on
    CentOS. There are a number of steps involved even if the default configuration
    is sufficient (which is unlikely, but for now, we'll keep the example simple).
    If you were to perform the basic installation by hand, you would need to install
    the package, open up the firewall, and ensure the service is running (and runs
    at boot time).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来开发一个实际的例子——假设你想在CentOS上安装Apache 2.4。即使默认配置足够（这不太可能，但现在我们将保持例子简单），也涉及到一些步骤。如果你要手动执行基本安装，你需要安装软件包，打开防火墙，并确保服务正在运行（并且在启动时运行）。
- en: 'To perform these commands in the shell, you might do the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要在shell中执行这些命令，您可能会这样做：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, for each of these commands, there is an equivalent ad hoc Ansible command
    that you could run. We won''t go through all of them here in the interests of
    space; however, let''s say you want to restart the Apache service—in this case,
    you could run an ad hoc command similar to the following (again, we will perform
    it only on one host for conciseness):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于这些命令中的每一个，都有一个等效的临时Ansible命令可以运行。出于篇幅考虑，我们不会在这里逐个讨论它们；然而，假设你想要重新启动Apache服务——在这种情况下，你可以运行类似以下的临时命令（同样，为了简洁起见，我们只在一个主机上执行）：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When run successfully, you will see pages of shell output containing all of
    the variable data returned from running the service module in this way. A snippet
    of this is shown in the following for you to check yours against—the key thing
    being that the command resulted in the `changed` status, meaning that it ran successfully
    and that the service was indeed restarted:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当成功运行时，您将看到包含从以这种方式运行服务模块返回的所有变量数据的页面式shell输出。下面是一个片段供您检查您的结果——关键是命令导致`changed`状态，这意味着它成功运行，并且服务确实被重新启动了：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You could create and execute a series of ad hoc commands to replicate the six
    shell commands given in the preceding and run them all individually. With a bit
    of cleverness, you should reduce this from six commands (for example, the Ansible
    `service` module can both enable a service at boot time and restart it in one
    ad hoc command). However, you would still ultimately end up with at least three
    or four ad hoc commands, and if you want to run these again later on another server,
    you will need to refer to your notes to figure out how you did it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建并执行一系列临时命令来复制前面给出的六个shell命令，并分别运行它们。通过一些巧妙的方法，你应该可以将这个减少到六个命令（例如，Ansible的`service`模块可以在一个临时命令中同时启用服务和重新启动它）。然而，你最终仍然会至少需要三到四个临时命令，如果你想在以后的另一台服务器上再次运行这些命令，你将需要参考你的笔记来弄清楚你是如何做的。
- en: 'A playbook is hence a far more valuable way to approach this—not only will
    it perform all of the steps in one go, but it will also give you a record of how
    it was done for you to refer to later on. There are multiple ways to do this,
    but consider the following as an example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，playbook是一种更有价值的方法来处理这个问题——它不仅会一次性执行所有步骤，而且还会为你记录下来以供以后参考。有多种方法可以做到这一点，但请将以下内容作为一个例子：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, when you run this, you should see that all of our installation requirements
    have been completed by one fairly simple and easy to read playbook. There is a
    new concept here, loops, which we haven''t covered yet, but don''t worry, we will
    cover this later in this chapter:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行这个时，你应该看到我们所有的安装要求都已经通过一个相当简单和易于阅读的playbook完成了。这里有一个新的概念，循环，我们还没有涉及，但不要担心，我们将在本章后面涉及到：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, this is far better for capturing what was actually done and
    documenting it in a format that someone else could easily pick up. Even though
    we will cover loops later on in the book, it''s fairly easy to see from the preceding
    how they might be working. With this set out, let''s proceed in the next section
    to look in more detail at a couple of terms we have used several times to ensure
    you are clear on their meanings: **plays** and **tasks**.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这样做要比实际操作和记录在一个格式中更好，其他人可以很容易地理解。尽管我们将在书的后面讨论循环，但从前面的内容很容易看出它们是如何工作的。有了这个设置，让我们在下一节中更详细地看一下我们已经多次使用的一些术语，以确保你清楚它们的含义：**plays**和**tasks**。
- en: Defining plays and tasks
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义plays和tasks
- en: So far when we have worked with playbooks, we have been creating one single
    play per playbook (which logically is the minimum you can do). However, you can
    have more than one play in a playbook, and a "play" in Ansible terms is simply
    a set of tasks (and roles, handlers, and other Ansible facets) associated with
    a host (or group of hosts). A task is the smallest possible element of a play
    and is responsible for running a single module with a set of arguments to achieve
    a specific goal. Of course, in theory, this sounds quite complex, but when backed
    up by a practical example, it becomes quite simple to understand.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当我们使用playbook时，我们一直在每个playbook中创建一个单一的play（从逻辑上讲，这是你可以做的最少的）。然而，你可以在一个playbook中有多个play，并且在Ansible术语中，“play”简单地是与主机（或主机组）相关联的一组任务（和角色、处理程序和其他Ansible方面）。任务是play的最小可能元素，负责使用一组参数运行单个模块以实现特定的目标。当然，在理论上，这听起来相当复杂，但在实际示例的支持下，它变得非常容易理解。
- en: If we refer to our example inventory, this describes a simple two-tier architecture
    (we've left out the database tier for now). Now, suppose we want to write a single
    playbook to configure both the frontend servers and the application servers. We
    could use two separate playbooks to configure the front end and application servers,
    but this risks fragmenting your code and making it difficult to organize. However,
    front end servers and application servers are going to be (by their very nature)
    fundamentally different and so are unlikely to be configured with the same set
    of tasks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们参考我们的示例清单，这描述了一个简单的两层架构（我们暂时忽略了数据库层）。现在，假设我们想编写一个单一的playbook来配置前端服务器和应用服务器。我们可以使用两个单独的playbook来配置前端和应用服务器，但这会使你的代码变得零散并且难以组织。然而，前端服务器和应用服务器（从它们的本质上）本质上是不同的，因此不太可能使用相同的任务集进行配置。
- en: 'The solution to this problem is to create a single playbook with two plays
    in it. The start of each play can be identified by the line at the lowest indentation
    (that is, zero spaces in front of it). Let''s get started with building up our
    playbook:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是创建一个包含两个play的单一playbook。每个play的开始可以通过最低缩进的行来识别（即在其前面没有空格）。让我们开始构建我们的playbook：
- en: 'Add the first play to the playbook and define some simple tasks to set up the
    Apache server on the front end, as shown here:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个play添加到playbook中，并定义一些简单的任务来设置前端的Apache服务器，如下所示：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Immediately below this, in the same file, add the second play to configure
    the application tier servers:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个文件中，立即在下面添加第二个play来配置应用程序层服务器：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, you have two plays: one to install web servers in the `frontends` group
    and one to install application servers in the `apps` group, all combined into
    one simple playbook.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有两个plays：一个用于在`frontends`组中安装web服务器，另一个用于在`apps`组中安装应用服务器，全部合并成一个简单的playbook。
- en: 'When we run this playbook, we''ll see the two plays performed sequentially,
    in the order they appear in the playbook. Note the presence of the `PLAY` keyword,
    which denotes the start of each play:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个playbook时，我们将看到两个play按顺序执行，按照playbook中的顺序。请注意`PLAY`关键字的存在，它表示每个play的开始：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There we have it—one playbook, yet two distinct plays operating on different
    sets of hosts from the provided inventories. This is very powerful, especially
    when combined with roles (which will be covered later in this book). Of course,
    you can have just one play in your playbook—you don't have to have multiple ones,
    but it is important to be able to develop multi-play playbooks as you will almost
    certainly find them useful as your environment gets more complex.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个playbook，但是有两个不同的play在提供的清单中操作不同的主机集。这非常强大，特别是与角色结合使用时（这将在本书的后面部分介绍）。当然，您的playbook中可以只有一个play——您不必有多个play，但是能够开发多play
    playbook非常重要，因为随着环境变得更加复杂，您几乎肯定会发现它们非常有用。
- en: Playbooks are the lifeblood of Ansible automation—they extend it beyond single
    task/commands (which in themselves are incredibly powerful) to a whole series
    of tasks organized in a logical fashion. As you extend your library of playbooks,
    however, how do you keep your work organized? How do you efficiently reuse the
    same blocks of code? In the preceding example, we installed Apache, and this might
    be a requirement on a number of your servers. However, should you attempt to manage
    them all from one playbook? Or should you perhaps keep copying and pasting the
    same block of code over and over again? There is a better way, and in Ansible
    terms, we need to start looking at roles, which we shall do in the very next section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Playbooks是Ansible自动化的生命线——它们将其扩展到不仅仅是单个任务/命令（它们本身就非常强大），而是一系列以逻辑方式组织的任务。然而，随着您扩展playbook库，您如何保持工作的组织？如何有效地重用相同的代码块？在前面的示例中，我们安装了Apache，这可能是您的许多服务器的要求。但是，您应该尝试从一个playbook管理它们所有吗？或者您应该一遍又一遍地复制和粘贴相同的代码块？有一个更好的方法，在Ansible术语中，我们需要开始看角色，我们将在下一节中进行介绍。
- en: Understanding roles – the playbook organizer
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解角色——playbook组织者
- en: Roles are designed to enable you to efficiently and effectively reuse Ansible
    code. They always follow a known structure and often will include sensible default
    values for variables, error handling, handlers, and so on. Taking our Apache installation
    example from the previous chapter, we know that this is something that we might
    want to do over and over again, perhaps with a different configuration file each
    time, and perhaps with a few other tweaks on a per-server (or per inventory group)
    basis. In Ansible, the most efficient way to support the reuse of this code in
    this way would be to create it as a role.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 角色旨在使您能够高效有效地重用Ansible代码。它们始终遵循已知的结构，并且通常会包含变量、错误处理、处理程序等的合理默认值。以前一章中的Apache安装示例为例，我们知道这是我们可能想一遍又一遍地做的事情，也许每次都使用不同的配置文件，也许每台服务器（或每个清单组）都需要进行一些其他调整。在Ansible中，支持以这种方式重用代码的最有效方法是将其创建为一个角色。
- en: The process of creating roles is in fact very simple—Ansible will (by default)
    look within the same directory as you are running your playbook from for a `roles/`
    directory, and in here, you will create one subdirectory for each role. The role
    name is derived from the subdirectory name—there is no need to create complex
    metadata or anything else—it really is that simple. Within each subdirectory goes
    a fixed directory structure that tells Ansible what the tasks, default variables,
    handlers, and so on are for each role.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建角色的过程实际上非常简单——Ansible（默认情况下）将在您运行playbook的同一目录中寻找`roles/`目录，在这里，您将为每个角色创建一个子目录。角色名称源自子目录名称——无需创建复杂的元数据或其他任何东西——就是这么简单。在每个子目录中，都有一个固定的目录结构，告诉Ansible每个角色的任务、默认变量、处理程序等是什么。
- en: The `roles/` directory is not the only play Ansible will look for roles—this
    is the first directory it will look in, but it will then look in `/etc/ansible/roles`
    for any additional roles. This can be further customized through the Ansible configuration
    file, as discussed in [Chapter 2](da04dfe7-d42f-41dd-93a2-c1db97a7fbb1.xhtml),
    *Understanding the Fundamentals of Ansible.*
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`roles/`目录并不是Ansible寻找角色的唯一目录——这是它首先查找的目录，但然后它会在`/etc/ansible/roles`中查找任何额外的角色。这可以通过Ansible配置文件进一步定制，如[第2章](da04dfe7-d42f-41dd-93a2-c1db97a7fbb1.xhtml)中所讨论的那样，*理解Ansible的基本原理*。'
- en: 'Let''s explore this in a little more detail. Consider the following directory
    structure:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨一下。考虑以下目录结构：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding directory structure shows two roles defined in our hypothetical
    playbook directory, called `installapache` and `installtomcat`. Within each of
    these directories, you will notice a series of subdirectories. These subdirectories
    do not need to exist (more on what they mean in a minute, but for example, if
    your role has no handlers, then `handlers/` does not need to be created). However,
    where you do require such a directory, you should populate it with a YAML file
    named `main.yml`. Each of these `main.yml` files will be expected to have certain
    contents, depending on the directory that contained them.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的目录结构显示了在我们假设的playbook目录中定义的两个角色，名为`installapache`和`installtomcat`。在这些目录中，您会注意到一系列子目录。这些子目录不需要存在（稍后会详细说明它们的含义，但例如，如果您的角色没有处理程序，则无需创建`handlers/`）。但是，如果您确实需要这样的目录，您应该用名为`main.yml`的YAML文件填充它。每个`main.yml`文件都应该有特定的内容，具体取决于包含它们的目录。
- en: 'The subdirectories that can exist inside of a role are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 角色中可以存在的子目录如下：
- en: '`tasks`: This is the most common directory to find in a role, and it contains
    all of the Ansible tasks that the role should perform.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasks`：这是在角色中找到的最常见的目录，它包含角色应执行的所有Ansible任务。'
- en: '`handlers`: All handlers used in the role should go into this directory.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handlers`：角色中使用的所有处理程序都应该放在这个目录中。'
- en: '`defaults`: All default variables for the role go in here.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaults`：角色的所有默认变量都放在这里。'
- en: '`vars`: These are other role variables—these override those declared in the
    `defaults/` directory as they are higher up the precedence order.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vars`：这些是其他角色变量——它们会覆盖`defaults/`目录中声明的变量，因为它们在优先顺序中更高。'
- en: '`files`: Files needed by the role should go in here—for example, any configuration
    files that need to be deployed to the target hosts.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`files`：角色需要的文件应该放在这里 - 例如，需要部署到目标主机的任何配置文件。'
- en: '`templates`: Distinct from the `files/` directory, this directory should contain
    all templates used by the role.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates`：与`files/`目录不同，这个目录应该包含角色使用的所有模板。'
- en: '`meta`: Any metadata needed for the role goes in here. For example, roles are
    normally executed in the order they are called from the parent playbook—however,
    sometimes a role will have dependency roles that need to be run first, and if
    this is the case, they can be declared within this directory.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta`：角色所需的任何元数据都放在这里。例如，角色通常按照从父playbook调用它们的顺序执行 - 但是，有时角色会有需要先运行的依赖角色，如果是这种情况，它们可以在这个目录中声明。'
- en: 'For the examples we will develop in this part of this chapter, we will need
    an inventory, so let''s reuse the inventory we used in the previous section (included
    in the following for convenience):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在本章的这一部分中将开发的示例，我们将需要一个清单，所以让我们重用我们在上一节中使用的清单（以下是为了方便包含的）：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s get started with some practical exercises to help you to learn how to
    create and work with roles. We''ll start by creating a role called `installapache`,
    which will handle the Apache installation process we looked at in the previous
    section. However, here, we will expand it to cover the installation of Apache
    on both CentOS and Ubuntu. This is good practice, especially if you are looking
    to submit your roles back to the community as the more general purpose they are
    (and the wider the range of systems they will work on), the more useful they will
    be to people. Step through the following process to create your first role:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始一些实际的练习，帮助你学习如何创建和使用角色。我们将首先创建一个名为`installapache`的角色，该角色将处理我们在上一节中看到的Apache安装过程。但是，在这里，我们将扩展它以涵盖在CentOS和Ubuntu上安装Apache。这是一个很好的实践，特别是如果您希望将您的角色提交回社区，因为它们越通用（以及能够在更广泛的系统上运行），对人们就越有用。按照以下过程创建您的第一个角色：
- en: 'Create the directory structure for the `installapache` role from within your
    chosen playbook directory—this is as simple as this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您选择的playbook目录中创建`installapache`角色的目录结构 - 这就是这么简单：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s create the mandatory `main.yml` inside the `tasks` directory we
    just created. This won''t actually perform the Apache installation—rather, it
    will call one of two external tasks files, depending on the operating system detected
    on the target host during the fact-gathering stage. We can use this special variable, 
    `ansible_distribution`, in a `when` condition to determine which of the tasks
    files to import:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在我们刚刚创建的`tasks`目录中创建一个必需的`main.yml`。这实际上不会执行Apache安装 - 而是在事实收集阶段检测到目标主机的操作系统后，将调用两个外部任务文件中的一个。我们可以使用这个特殊的变量`ansible_distribution`在`when`条件中确定要导入哪个任务文件：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create `centos.yml` in `roles/installapache/tasks` to install the latest version
    of the Apache web server via the `yum` package manager. This should contain the
    following content:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`roles/installapache/tasks`中创建一个名为`centos.yml`的文件，以通过`yum`软件包管理器安装Apache Web服务器的最新版本。这应该包含以下内容：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a file called `ubuntu.yml` in `roles/installapache/tasks` to install
    the latest version of the Apache web server via the `apt` package manager on Ubuntu.
    Notice how the content differs between CentOS and Ubuntu hosts:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`roles/installapache/tasks`中创建一个名为`ubuntu.yml`的文件，以通过`apt`软件包管理器在Ubuntu上安装Apache
    Web服务器的最新版本。注意在CentOS和Ubuntu主机之间内容的不同：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For now, we''re keeping our role code really simple—however, you can see that
    the preceding tasks files are just like an Ansible playbook, except that they
    lack the play definition. As they do not come under a play, they are also at a
    lower indentation level than in a playbook, but apart from this difference, the
    code should look very familiar to you. In fact, this is part of the beauty of
    roles: as long as you pay attention to getting the indentation level right, you
    can more or less use the same code in a playbook or a role.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的角色代码非常简单 - 但是，您可以看到前面的任务文件就像一个Ansible playbook，只是它们缺少了play定义。由于它们不属于一个play，所以它们的缩进级别也比playbook中的低，但是除了这个差异，代码应该对您来说非常熟悉。事实上，这就是角色的美妙之处之一：只要您注意正确的缩进级别，您几乎可以在playbook或角色中使用相同的代码。
- en: 'Now, roles don''t run by themselves—we have to create a playbook to call them,
    so let''s write a simple playbook to call our newly created role. This has a play
    definition just like we saw before, but then rather than having a `tasks:` section
    within the play, we have a `roles:` section where the roles are declared instead.
    Convention dictates that this file be called `site.yml`, but you are free to call
    it whatever you like:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，角色不能自行运行 - 我们必须创建一个playbook来调用它们，所以让我们编写一个简单的playbook来调用我们新创建的角色。这与我们之前看到的一样有一个play定义，但是不是在play中有一个`tasks:`部分，而是有一个`roles:`部分，在那里声明了角色。惯例规定这个文件被称为`site.yml`，但您可以自由地称它为任何您喜欢的名字：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For clarity, your final directory structure should look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，您的最终目录结构应该如下所示：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With this completed, you can now run your `site.yml` playbook using `ansible-playbook` in
    the normal way—you should see output similar to this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您现在可以以正常方式使用`ansible-playbook`运行您的`site.yml` playbook - 您应该会看到类似于这样的输出：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That's it—you have created, at the simplest possible level, your first role.
    Of course (as we discussed earlier), there is much more to a role than just simple
    tasks as we have added here, and we will see expanded examples as we work through
    this chapter. However, the preceding example is intended to show you how quick
    and easy it is to get started with roles.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样 - 您已经在最简单的级别上创建了您的第一个角色。当然（正如我们之前讨论的那样），角色不仅仅是我们在这里添加的简单任务，还有更多内容，当我们在本章中进行工作时，我们将看到扩展的示例。然而，前面的示例旨在向您展示如何快速轻松地开始使用角色。
- en: 'Before we look at some of the other aspects relating to roles, let''s take
    a look at some other ways to call your role. Ansible allows you to statically
    import or dynamically include roles when you write a playbook. The syntax between
    these importing or including a role is subtly different, and notably, both go
    in the tasks section of your playbook rather than in the roles section. The following
    is a hypothetical example that shows both options in a really simple playbook.
    The roles directory structure including both the `common` and `approle` roles
    would have been created in a similar manner as in the preceding example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看一些与角色相关的其他方面之前，让我们看一些调用角色的其他方法。当您编写playbook时，Ansible允许您静态导入或动态包含角色。这两种导入或包含角色的语法略有不同，值得注意的是，两者都在playbook的任务部分而不是角色部分。以下是一个假设的示例，展示了一个非常简单的playbook中的两种选项。包括`common`和`approle`角色的角色目录结构将以与前面示例类似的方式创建：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These features were not available in versions of Ansible earlier than 2.3, and
    their usage changed slightly in version 2.4 for consistency with the way that
    some other Ansible features work. We will not worry about the details of this
    here as Ansible is now on release 2.9, so unless you absolutely have to run a
    much earlier version of Ansible, it is sufficient to assume that these two statements
    work as we shall outline in the following.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能在2.3之前的Ansible版本中是不可用的，并且它们在2.4版本中的使用方式略有改变，以保持与其他一些Ansible功能的一致性。我们不会在这里担心这些细节，因为现在Ansible的版本是2.9，所以除非您绝对必须运行早期版本的Ansible，否则可以假定这两个语句的工作方式如我们将在接下来的内容中概述的那样。
- en: Fundamentally, the `import_role` statement performs a static import of the role
    you specify at the time when all playbook code is parsed. Hence, roles brought
    into your playbook using the `import_role` statement are treated just as any other
    code in a play or role is when Ansible begins parsing. Using `import_role` is
    basically the same as declaring your roles after the `roles:` statement in `site.yml`,
    just as we did in the preceding example.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`import_role`语句在解析所有playbook代码时执行您指定的角色的静态导入。因此，使用`import_role`语句将角色引入您的playbook时，Ansible在开始解析时将其视为play或角色中的任何其他代码一样。使用`import_role`基本上与在`site.yml`中的`roles:`语句之后声明您的角色一样，就像我们在前面的示例中所做的那样。
- en: '`include_role` is subtly but fundamentally different in that the role you specify
    is not evaluated when the playbook is parsed initially—rather, it is processed
    dynamically during the playbook run, at the point at which `include_role` is encountered.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`include_role`在某种程度上与`import_role`有根本的不同，因为您指定的角色在解析playbook时不会被评估，而是在playbook运行期间动态处理，在遇到`include_role`时进行处理。'
- en: Probably the most fundamental reason to choose between the `include` or `import`
    statements given in the preceding is looping—if you need to run a role within
    a loop, you cannot do so with `import_role` and so must use `include_role`. There
    are, however, both benefits and limitations to both, and you will need to choose
    the most appropriate one for your scenario—the official Ansible documentation
    ([https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html#dynamic-vs-static](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html#dynamic-vs-static))
    will help you to make the right decision.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择前面提到的`include`或`import`语句之间最基本的原因可能是循环——如果您需要在循环内运行一个角色，您不能使用`import_role`，因此必须使用`include_role`。然而，两者都有好处和局限性，您需要根据您的情况选择最合适的方法——官方的Ansible文档（[https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html#dynamic-vs-static](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html#dynamic-vs-static)）将帮助您做出正确的决定。
- en: As we have seen in this section, roles are incredibly simple to get started
    with and yet offer an incredibly powerful way in which to organize and reuse your
    Ansible code. In the next section, we will expand upon our simple task-based example
    by looking at adding role-specific variables and dependencies into your code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节中所看到的，角色非常简单易用，但却提供了一种非常强大的方式来组织和重用您的Ansible代码。在下一节中，我们将通过查看如何将角色特定的变量和依赖项添加到您的代码中来扩展我们简单的基于任务的示例。
- en: Setting up role-based variables and dependencies
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置基于角色的变量和依赖关系
- en: Variables are at the heart of making Ansible playbooks and roles reusable, as
    they allow the same code to be repurposed with slightly different values or configuration
    data. The Ansible role directory structure allows for role-specific variables
    to be declared in two locations. Although, at first, the difference between these
    two locations may not seem obvious, it is of fundamental importance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是使Ansible playbook和角色可重用的核心，因为它们允许相同的代码以略有不同的值或配置数据重新利用。Ansible角色目录结构允许在两个位置声明特定于角色的变量。虽然乍一看，这两个位置之间的区别可能并不明显，但它具有根本重要性。
- en: 'Roles based variables can go in one of two locations:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 基于角色的变量可以放在两个位置之一：
- en: '`defaults/main.yml`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaults/main.yml`'
- en: '`vars/main.yml`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vars/main.yml`'
- en: The difference between these two locations is their position in Ansible's variable
    order of precedence ([https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable)).
    Variables that go in the `defaults/` directory are one of the lowest in terms
    of precedence and so are easily overwritten. This location is where you would
    put variables that you want to override easily, but where you don't want to leave
    a variable undefined. For example, if you are installing Apache Tomcat, you might
    build a role to install a specific version. However, you don't want the role to
    exit with an error if someone forgets to set the version—rather, you would prefer
    to set a sensible default such as `7.0.76`, which can then be overridden with
    inventory variables or on the command line (using the `-e` or `--extra-vars` switches).
    In this way, you know the role will work even without someone explicitly setting
    this variable, but it can easily be changed to a newer Tomcat version if desired.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个位置之间的区别在于它们在Ansible变量优先顺序中的位置。放在`defaults/`目录中的变量在优先级方面较低，因此很容易被覆盖。这个位置是你想要轻松覆盖的变量的位置，但你不想让变量未定义。例如，如果你要安装Apache
    Tomcat，你可能会构建一个安装特定版本的角色。然而，如果有人忘记设置版本，你不希望角色因此退出错误，而是更愿意设置一个合理的默认值，比如`7.0.76`，然后可以用清单变量或命令行（使用`-e`或`--extra-vars`开关）轻松覆盖它。这样，即使没有人明确设置这个变量，你也知道角色可以正常工作，但如果需要，它可以很容易地更改为更新的Tomcat版本。
- en: Variables that go in the `vars/` directory, however, come much higher up on
    Ansible's variable precedence ordering. This will not be overridden by inventory
    variables, and so should be used for variable data that it is more important to
    keep static. Of course, this is not to say they can't be overridden—the `-e` or `--extra-vars` switches
    are the highest order of precedence in Ansible and so will override anything else
    that you define.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，放在`vars/`目录中的变量在Ansible的变量优先顺序中更靠前。这不会被清单变量覆盖，因此应该用于更重要的保持静态的变量数据。当然，这并不是说它们不能被覆盖——`-e`或`--extra-vars`开关是Ansible中优先级最高的，因此会覆盖你定义的任何其他内容。
- en: Most of the time, you will probably make use of the `defaults/` based variables
    alone, but there will doubtless be times when having the option of variables higher
    up the precedence ordering becomes valuable to your automation, and so it is vital
    to know that this option is available to you.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你可能只会使用基于`defaults/`的变量，但无疑会有时候，拥有更高优先级变量的选项对你的自动化变得更有价值，因此知道这个选项对你是可用的是至关重要的。
- en: 'In addition to the role-based variables described previously, there is also
    the option to add metadata to a role using the `meta/` directory. As before, to
    make use of this, simply add a file called `main.yml` into this directory. To
    explain how you might make use of the `meta/` directory, let''s build and run
    a practical example that will show how it can be used. Before we get started though,
    it is important to note that, by default, the Ansible parser will only allow you
    to run a role once. This is somewhat similar to the way in which we discussed
    handlers earlier, which can be called multiple times but ultimately are only run
    once at the end of the play. Roles are the same in that they can be or referred
    to multiple times but will only actually get run once. There are two exceptions
    to this—the first is if the role is called more than once but with different variables
    or parameters, and the other is if the role being called has `allow_duplicates`
    set to `true` in its `meta/` directory. We shall see examples of both of these
    as we build our example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前描述的基于角色的变量之外，还可以使用`meta/`目录为角色添加元数据。与之前一样，只需在这个目录中添加一个名为`main.yml`的文件即可。为了解释如何使用`meta/`目录，让我们构建并运行一个实际的例子，展示它如何被使用。在开始之前，重要的是要注意，默认情况下，Ansible解析器只允许你运行一个角色一次。这在某种程度上类似于我们之前讨论的处理程序，可以被多次调用，但最终只在play结束时运行一次。角色也是一样的，它们可以被多次引用，但实际上只会运行一次。有两个例外情况——第一个是如果角色被多次调用，但使用了不同的变量或参数，另一个是如果被调用的角色在其`meta/`目录中将`allow_duplicates`设置为`true`。在构建示例时，我们将看到这两种情况的例子：
- en: 'At the top level of our practical example, we will have a copy of the same
    inventory we have been using throughout this chapter. We will also create a simple
    playbook called `site.yml`, which contains the following code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们实际的例子的顶层，我们将有一个与本章节中一直在使用的清单相同的副本。我们还将创建一个名为`site.yml`的简单playbook，其中包含以下代码：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that we are simply calling one role called `platform` from this playbook—nothing
    else is called from the playbook itself.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只是从这个playbook中调用了一个名为`platform`的角色，playbook本身没有调用其他内容。
- en: 'Let''s go ahead and create the `platform` role—unlike our previous role, this
    will not contain any tasks or even any variable data; instead, it will just contain
    a `meta` directory:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续创建`platform`角色——与我们之前的角色不同，这个角色不包含任何任务，甚至不包含任何变量数据；相反，它只包含一个`meta`目录。
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Inside this directory, create a file called `main.yml` with the following contents:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个目录中，创建一个名为`main.yml`的文件，内容如下：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code will tell Ansible that the platform role is dependent on the `linuxtype`
    role. Notice that we are specifying the dependency twice, but each type we specify
    it, we are passing it a variable called `type` with a different value—in this
    way, the Ansible parser allows us to call the role twice because a different variable
    value has been passed to it each time it is referred to as a dependency.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将告诉Ansible平台角色依赖于`linuxtype`角色。请注意，我们指定了依赖两次，但每次指定时，我们都传递了一个名为`type`的变量，并赋予不同的值。这样，Ansible解析器允许我们调用角色两次，因为每次作为依赖项引用时都传递了不同的变量值。
- en: 'Let''s now go ahead and create the `linuxtype` role—again, this will contain
    no tasks, but more dependency declarations:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们继续创建`linuxtype`角色，这将不包含任何任务，但会有更多的依赖声明：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Again, create a `main.yml` file in the `meta` directory, but this time containing
    the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在`meta`目录中创建一个`main.yml`文件，但这次包含以下内容：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once again, we are creating more dependencies—this time, when the `linuxtype`
    role is called, it, in turn, is declaring dependencies on roles called `version`
    and `network`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 再次创建更多的依赖关系——这次，当调用`linuxtype`角色时，它反过来声明对称为`version`和`network`的角色的依赖。
- en: 'Let''s create the `version` role first—this will have both `meta` and `tasks`
    directories in it:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建`version`角色——它将包含`meta`和`tasks`目录：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the `meta` directory, we''ll create a `main.yml` file with the following
    contents:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`meta`目录中，我们将创建一个包含以下内容的`main.yml`文件：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This declaration is important in this example—as discussed earlier, normally
    Ansible will only allow a role to be executed once, even if it is called multiple
    times. Setting `allow_duplicates` to `true` tells Ansible to allow the execution
    of the role more than once. This is required because, in the `platform` role,
    we call (via a dependency) the `linuxtype` role twice, which means, in turn, we
    will call the `version` role twice.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明在这个例子中很重要——正如前面讨论的，通常情况下，Ansible只允许一个角色被执行一次，即使它被多次调用。将`allow_duplicates`设置为`true`告诉Ansible允许角色被执行多次。这是必需的，因为在`platform`角色中，我们通过依赖两次调用了`linuxtype`角色，这意味着我们将两次调用`version`角色。
- en: 'We''ll also create a simple `main.yml` file in the tasks directory, which prints
    the value of the `type` variable that gets passed to the role:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在任务目录中创建一个简单的`main.yml`文件，打印传递给角色的`type`变量的值：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We will now repeat the process with the `network` role—to keep our example
    code simple, we''ll define it with the same contents as the `version` role:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将使用`network`角色重复这个过程——为了保持我们的示例代码简单，我们将使用与`version`角色相同的内容定义它：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `meta` directory, we''ll again create a `main.yml` file with the following
    contents:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`meta`目录中，我们将再次创建一个`main.yml`文件，其中包含以下内容：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Again, we''ll create a simple `main.yml` file in the `tasks` directory, which
    prints the value of the `type` variable that gets passed to the role:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在`tasks`目录中创建一个简单的`main.yml`文件，打印传递给角色的`type`变量的值：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At the end of this process, your directory structure should look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程结束时，你的目录结构应该是这样的：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s see what happens when we run this playbook. Now, you might think that
    the playbook is going to run like this: with the dependency structure we created
    in the preceding code, our initial playbook statically imports the `platform`
    role. The `platform` role then states that it depends upon the `linuxtype` role,
    and the dependency is declared twice with a different value in a variable called
    `type` each time. The `linuxtype` role then states that it depends upon both the
    `network` and `version` roles, which are allowed to run more than once and print
    the value of `type`. Hence, you could be forgiven for thinking that we''ll see
    the `network` and `version` roles called twice, printing `centos` once and `ubuntu`
    the second time (as this is how we originally specified the dependencies in the
    `platform` role). However, when we run it, we actually see this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看运行这个剧本会发生什么。现在，你可能会认为剧本会像这样运行：根据我们在前面的代码中创建的依赖结构，我们的初始剧本静态导入`platform`角色。`platform`角色然后声明依赖于`linuxtype`角色，并且每次使用名为`type`的变量声明两次不同的值。`linuxtype`角色然后声明依赖于`network`和`version`角色，这些角色可以运行多次并打印`type`的值。因此，你可能会认为我们会看到`network`和`version`角色被调用两次，第一次打印`centos`，第二次打印`ubuntu`（因为这是我们最初在`platform`角色中指定依赖关系的方式）。然而，当我们运行它时，实际上看到的是这样的：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: What happened? Although we see that the `network` and `version` roles are called
    twice (as expected), the value of the `type` variable is always `ubuntu`. This
    highlights an important point about the way the Ansible parser works and the difference
    between static imports (which we are doing here) and dynamic includes (which we
    discussed in the previous section).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？尽管我们看到`network`和`version`角色被调用了两次（如预期的那样），但`type`变量的值始终是`ubuntu`。这突出了关于Ansible解析器工作方式的重要一点，以及静态导入（我们在这里所做的）和动态包含（我们在前一节中讨论过）之间的区别。
- en: With static imports, role variables are scoped as if they were defined at the
    play level rather than the role level. The roles themselves are all parsed and
    merged into the play we created in our `site.yml` playbook at parsing time—hence, the
    Ansible parser creates (in memory) one big playbook that contains all of the merged
    variable and role content from our directory structure. There is nothing wrong
    with doing this, but what it means is that the `type` variable gets overwritten
    each time it is declared, and so the last value we declare (which, in this case,
    was `ubuntu`) is the value that gets used for the playbook run.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态导入时，角色变量的作用域就好像它们是在播放级别而不是角色级别定义的一样。角色本身在解析时都会被解析并合并到我们在`site.yml`剧本中创建的播放中，因此，Ansible解析器会创建（在内存中）一个包含来自我们目录结构的所有合并变量和角色内容的大型剧本。这样做并没有错，但意味着`type`变量每次声明时都会被覆盖，因此我们声明的最后一个值（在这种情况下是`ubuntu`）是用于播放运行的值。
- en: So, how do we get this playbook to run as we originally intended—to load our
    dependent roles but with the two different values we defined for the `type` variable?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使这个剧本按照我们最初的意图运行——加载我们的依赖角色，但使用我们为`type`变量定义的两个不同值？
- en: 'The answer to this question is if we are to continue using statically imported
    roles, then we should not use role variables when we declare the dependencies.
    Instead, we should pass over `type` as a role parameter. This is a small but crucial
    difference—role parameters remain scoped at the role level even when the Ansible
    parser is run, hence we can declare our dependency twice without the variable
    getting overwritten. To do this, change the contents of the `roles/platform/meta/main.yml`
    file to the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案是，如果我们要继续使用静态导入的角色，那么在声明依赖关系时就不应该使用角色变量。相反，我们应该将`type`作为角色参数传递。这是一个小但至关重要的区别——即使在运行Ansible解析器时，角色参数仍然保持在角色级别上，因此我们可以在不覆盖变量的情况下声明我们的依赖两次。要做到这一点，将`roles/platform/meta/main.yml`文件的内容更改为以下内容：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Do you notice the subtle change? The `vars:` keyword has gone, and the declaration
    of `type` is now at a lower indentation level, meaning it is a role parameter.
    Now, when we run the playbook, we get the results that we had hoped for:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您注意到微妙的变化了吗？`vars:`关键字消失了，`type`的声明现在处于较低的缩进级别，这意味着它是一个角色参数。现在，当我们运行playbook时，我们得到了我们所希望的结果：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is quite an advanced example of Ansible role dependencies but it has been
    provided to you to demonstrate the importance of knowing a little about variable
    precedence (that is, where the variable is scoped) and how the parser works. If
    you write simple, sequentially parsed tasks, then you may never need to know this,
    but I recommend that you make extensive use of the debug statement and test your
    playbook design to make sure that you don't fall foul of this during your playbook
    development.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当高级的Ansible角色依赖示例，但是提供给您是为了演示了解变量优先级（即变量的作用域）和解析器工作的重要性。如果您编写简单的、按顺序解析的任务，那么您可能永远不需要了解这一点，但我建议您广泛使用调试语句，并测试您的playbook设计，以确保在playbook开发过程中不会遇到这种问题。
- en: Having look in great detail at a number of aspects of roles, let's take a look
    in the following section at a centralized store for publicly available Ansible
    roles — Ansible Galaxy.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在对角色的许多方面进行了详细的研究之后，让我们在下一节中看一下一个用于公开可用的Ansible角色的集中存储——Ansible Galaxy。
- en: Ansible Galaxy
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible Galaxy
- en: No section on Ansible roles would be complete without a mention of Ansible Galaxy.
    Ansible Galaxy is a community-driven collection of Ansible roles, hosted by Ansible
    at [https://galaxy.ansible.com/](https://galaxy.ansible.com/). It contains a great
    many community-contributed Ansible roles, and if you can conceive of an automation
    task, there is a good chance someone has already written a role to do exactly
    what you want it to do. It is well worth exploring and can get your automation
    project off the ground quickly as you can start work with a set of ready-made
    roles.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 没有关于Ansible角色的部分会完整无缺地提到Ansible Galaxy。Ansible Galaxy是Ansible托管的一个由社区驱动的Ansible角色集合，托管在[https://galaxy.ansible.com/](https://galaxy.ansible.com/)。它包含了许多社区贡献的Ansible角色，如果您能构想出一个自动化任务，很有可能已经有人编写了一个角色来完全满足您的需求。它非常值得探索，并且可以让您的自动化项目迅速起步，因为您可以开始使用一组现成的角色。
- en: 'In addition to the web site, the `ansible-galaxy` client is included in Ansible,
    and this provides a quick and convenient way for you to download and deploy roles
    into your playbook structure. Let''s say that you want to update the **message
    of the day** (**MOTD**) on your target hosts—this is surely something that somebody
    has already figured out. A quick search on the Ansible Galaxy website returns
    (at the time of writing) 106 roles for setting the MOTD. If we want to use one
    of these, we could download it into our roles directory using the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了网站之外，`ansible-galaxy`客户端也包含在Ansible中，这为您提供了一种快速便捷的方式，让您下载并部署角色到您的playbook结构中。假设您想要在目标主机上更新**每日消息**（**MOTD**）—这肯定是有人已经想出来的事情。在Ansible
    Galaxy网站上快速搜索返回（在撰写本文时）106个设置MOTD的角色。如果我们想使用其中一个，我们可以使用以下命令将其下载到我们的角色目录中：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That's all you need to do—once the download is complete, you can import or include
    the role in your playbook just as you would for the manually created roles we
    have discussed in this chapter. Note that if you don't specify `-p roles/`, `ansible-galaxy`
    installs the roles into `~/.ansible/roles`, the central roles directory for your
    user account. This might be what you want, of course, but if you want the role
    downloaded directly into your playbook directory structure, you would add this
    parameter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要做的一切——一旦下载完成，您可以像在本章讨论的手动创建的角色一样，在playbook中导入或包含角色。请注意，如果您不指定`-p roles/`，`ansible-galaxy`会将角色安装到`~/.ansible/roles`，这是您的用户帐户的中央角色目录。当然，这可能是您想要的，但如果您希望将角色直接下载到playbook目录结构中，您可以添加此参数。
- en: 'Another neat trick is to use `ansible-galaxy` to create an empty role directory
    structure for you to create your own roles in—this saves all of the manual directory
    and file creation we have been undertaking in this chapter, as in this example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个巧妙的技巧是使用`ansible-galaxy`为您创建一个空的角色目录结构，以便您在其中创建自己的角色——这样可以节省我们在本章中一直在进行的所有手动目录和文件创建，就像在这个例子中一样：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: That should give you enough information to get started on your journey into
    Ansible roles. I cannot stress highly enough how important it is to develop your
    code as roles—it might not seem important initially, but as your automation use
    cases expand, and your requirement to reuse code grows, you will be glad that
    you did. In the next section, let's expand our look at Ansible playbooks with
    a discussion of the ways in which conditional logic can be used in your Ansible
    code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该为您提供足够的信息，让您开始进入Ansible角色的旅程。我无法再次强调开发代码作为角色是多么重要——最初可能看起来不重要，但随着您的自动化用例的扩展，以及重用代码的需求增长，您会为自己的决定感到高兴。在下一节中，让我们扩展一下对Ansible
    playbook的讨论，讨论条件逻辑在您的Ansible代码中的使用方式。
- en: Using conditions in your code
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的代码中使用条件
- en: In most of our examples so far, we have created simple sets of tasks that always
    run. However, as you generate tasks (whether in roles or playbooks) that you want
    to apply to a wider array of hosts, sooner or later, you will want to perform
    some kind of conditional action. This might be to only perform a task in response
    to the results of a previous task. Or it might be to only perform a task in response
    to a specific fact gathered from an Ansible system. In this section, we will provide
    some practical examples of conditional logic to apply to your Ansible tasks to
    demonstrate how to use this feature.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的大多数示例中，我们创建了一组简单的任务集，这些任务总是运行。然而，当你生成你想要应用于更广泛主机数组的任务（无论是在角色还是playbooks中），迟早你会想要执行某种条件动作。这可能是只对先前任务的结果执行任务。或者可能是只对从Ansible系统中收集的特定事实执行任务。在本节中，我们将提供一些实际的条件逻辑示例，以演示如何在你的Ansible任务中应用这个特性。
- en: 'As ever, we''ll need an inventory to get started, and we''ll reuse the inventory
    we have used throughout this chapter:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 和以往一样，我们需要一个清单来开始，并且我们将重用本章中一直使用的清单：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Suppose that you want to perform an Ansible task only on certain operating
    systems. We have already discussed Ansible facts, and these provide the perfect
    platform to start exploring conditional logic in your playbooks. Consider this:
    an urgent patch has been released for all of your CentOS systems, and you want
    to apply it immediately. You could, of course, go through and create a special
    inventory (or host group) for CentOS hosts, but this is additional work that you
    don''t necessarily need to do.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你只想在某些操作系统上执行Ansible任务。我们已经讨论了Ansible事实，这为在playbooks中探索条件逻辑提供了一个完美的平台。考虑一下：所有你的CentOS系统都发布了一个紧急补丁，你想立即应用它。当然，你可以逐个创建一个专门的清单（或主机组）来适用于CentOS主机，但这是你不一定需要做的额外工作。
- en: 'Instead, let''s define the task that will perform our update but add a `when`
    clause containing a Jinja 2 expressions to it in a simple example playbook:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们定义一个将执行我们的更新的任务，但在一个简单的示例playbook中添加一个包含Jinja 2表达式的`when`子句：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, when we run this task, if your test system(s) are CentOS-based (and mine
    are), you should see output similar to the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行这个任务时，如果你的测试系统是基于CentOS的（我的也是），你应该会看到类似以下的输出：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding output shows that all of our systems were CentOS-based, but that
    only `frt01.example.com` needed the patch applying. Now we can make our logic
    more precise—perhaps it is only our legacy systems that are running on CentOS
    6 that need the patch applying. In this case, we can expand the logic in our playbook
    to check both the distribution and major version, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示，我们所有的系统都是基于CentOS的，但只有`frt01.example.com`需要应用补丁。现在我们可以使我们的逻辑更加精确——也许只有我们的旧系统运行在CentOS
    6上需要应用补丁。在这种情况下，我们可以扩展playbook中的逻辑，检查发行版和主要版本，如下所示：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, if we run our modified playbook, depending on the systems you have in
    your inventory, you might see output similar to the following. In this case, my
    `app01.example.com` server was based on CentOS 6 so had the patch applied. All
    other systems were skipped because they did not match my logical expression:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行我们修改后的playbook，根据你的清单中有哪些系统，你可能会看到类似以下的输出。在这种情况下，我的`app01.example.com`服务器基于CentOS
    6，因此已应用了补丁。所有其他系统都被跳过，因为它们不符合我的逻辑表达式：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Of course, this conditional logic is not limited to Ansible facts and can be
    incredibly valuable when using the `shell` or `command` modules. When you run
    any Ansible module (be it `shell`, `command`, `yum`, `copy`, or otherwise), the
    module returns data detailing the results of its run. You can capture this in
    a standard Ansible variable using the `register` keyword and then process it further
    later on in the playbook.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行任何Ansible模块（无论是`shell`、`command`、`yum`、`copy`还是其他模块），模块都会返回详细的运行结果数据。你可以使用`register`关键字将其捕获到一个标准的Ansible变量中，然后在playbook中稍后进一步处理它。
- en: 'Consider the following playbook code. It contains two tasks, the first of which
    is to obtain the listing of the current directory and capture the output of the
    `shell` module in a variable called `shellresult`. When then print a simple `debug`
    message, but only on the condition that the `hosts` string is in the output of
    the `shell` command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下playbook代码。它包含两个任务，第一个任务是获取当前目录的列表，并将`shell`模块的输出捕获到一个名为`shellresult`的变量中。然后打印一个简单的`debug`消息，但只有在`shell`命令的输出中包含`hosts`字符串时才会打印：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, when we run this in the current directory, which if you are working from
    the GitHub repository that accompanies this book will contain a file named `hosts`,
    then you should see output similar to the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在当前目录中运行这个命令时，如果你是从本书附带的GitHub仓库中工作，那么目录中将包含一个名为`hosts`的文件，那么你应该会看到类似以下的输出：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Yet, if the file doesn''t exist, then you''ll see that the `debug` message
    gets skipped:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果文件不存在，那么你会发现`debug`消息被跳过了。
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can also create complex conditions for IT operational tasks in production;
    however, remember that, in Ansible, variables are not cast to any particular type
    by default, and hence even though the contents of a variable (or fact) might look
    like a number, Ansible will by default treat it as a string. If you need to perform
    an integer comparison instead, you must first cast the variable to an integer
    type. For example, here is a fragment of a playbook that will run a task only
    on Fedora 25 and newer:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为生产中的IT运维任务创建复杂的条件；但是，请记住，在Ansible中，默认情况下变量不会被转换为任何特定的类型，因此即使变量（或事实）的内容看起来像一个数字，Ansible默认也会将其视为字符串。如果你需要执行整数比较，你必须首先将变量转换为整数类型。例如，这是一个playbook的片段，它只在Fedora
    25及更新版本上运行一个任务：
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There are many different types of conditionals you can apply to your Ansible
    tasks, and this section is just scratching the surface; however, it should give
    you a sound basis on which to expand your knowledge of applying conditions to
    your tasks in Ansible. Not only can you apply conditional logic to Ansible tasks,
    but you can also run them in loops over a set of data, and we shall explore this
    in the next section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以应用许多不同类型的条件到你的Ansible任务中，这一节只是触及了表面；然而，它应该为你扩展你在Ansible任务中应用条件的知识提供了一个坚实的基础。你不仅可以将条件逻辑应用到Ansible任务中，还可以在一组数据上运行它们，并且我们将在下一节中探讨这一点。
- en: Repeating tasks with loops
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用循环重复任务
- en: Oftentimes, we will want to perform a single task, but use that single task
    to iterate over a set of data. For example, you might not want to create one user
    account but 10\. Or you might want to install 15 packages to a system. The possibilities
    are endless, but the point remains the same—you would not want to write 10 individual
    Ansible tasks to create 10 user accounts. Fortunately, Ansible supports looping
    over datasets to ensure that you can perform large scale operations using tightly
    defined code. In this section, we will explore how to make practical use of loops
    in your Ansible playbooks.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望执行一个单一的任务，但使用该单一任务来迭代一组数据。例如，你可能不想创建一个用户帐户，而是创建10个。或者你可能想要将15个软件包安装到系统中。可能性是无穷无尽的，但要点仍然是一样的——你不想编写10个单独的Ansible任务来创建10个用户帐户。幸运的是，Ansible支持对数据集进行循环，以确保你可以使用紧密定义的代码执行大规模操作。在本节中，我们将探讨如何在你的Ansible
    playbook中实际使用循环。
- en: 'As ever, we must start with an inventory to work against, and we will use our
    by-now familiar inventory, which we have consistently used throughout this chapter:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 和以往一样，我们必须从清单开始工作，并且我们将使用我们在本章中一直使用的熟悉清单：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Let's start with a really simple playbook to show you how to loop over a set
    of data in a single task. Although this is quite a contrived example, it is intended
    to be simple to show you the fundamentals of how loops work in Ansible. We will
    define a single task that runs the `command` module on a single host from the
    inventory and uses the `command` module to `echo` the numbers 1 through 6 in turn
    on the remote system (with some imagination, this could easily be extended to
    adding user accounts or creating a sequence of files).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的playbook开始，向你展示如何在单个任务中循环一组数据。虽然这是一个相当牵强的例子，但它旨在简单地向你展示循环在Ansible中的工作原理。我们将定义一个单个任务，在清单中的单个主机上运行`command`模块，并使用`command`模块在远程系统上依次`echo`数字1到6（可以很容易地扩展到添加用户帐户或创建一系列文件）。
- en: 'Consider the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `loop:` statement defines the start of the loop, and the items in the loop
    are defined as a YAML list. Also, note the higher indentation level, which tells
    the parser they are part of the loop. When working with the loop data, we use
    a special variable called `item`, which contains the current value from the loop
    iteration to be echoed. Hence, if we run this playbook, we should see output similar
    to the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop:`语句定义了循环的开始，循环中的项目被定义为一个YAML列表。此外，请注意更高的缩进级别，这告诉解析器它们是循环的一部分。在处理循环数据时，我们使用一个名为`item`的特殊变量，其中包含要回显的循环迭代的当前值。因此，如果我们运行这个playbook，我们应该看到类似以下的输出：'
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can combine the conditional logic we discussed in the preceding section
    with loops, to make the loop operate on just a subset of its data. For example,
    consider the following iteration of the playbook:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将我们在前一节中讨论的条件逻辑与循环结合起来，使循环仅对其数据的子集进行操作。例如，考虑以下playbook的迭代：
- en: '[PRE56]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, when we run this, we see that the task is skipped until we reach the integer
    value of 4 and higher in the loop contents:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行这个时，我们会看到任务被跳过，直到我们达到循环内容中的整数值4及以上：
- en: '[PRE57]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can, of course, combine this with the conditional logic based on Ansible
    facts and other variables in the manner we discussed previously. Just as we captured
    the results of a module's execution using the `register` keyword before, we can
    do so with loops. The only difference is that the results will now be stored in
    a dictionary, with one dictionary entry for each iteration of the loop rather
    than just one set of results.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以将这个与基于Ansible事实和其他变量的条件逻辑相结合，就像我们之前讨论过的那样。就像我们以前使用`register`关键字捕获模块执行的结果一样，我们也可以使用循环来做到这一点。唯一的区别是，结果现在将存储在一个字典中，每次循环迭代都会有一个字典条目，而不仅仅是一组结果。
- en: 'Hence, let''s see what happens if we further enhance the playbook, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看如果我们进一步增强playbook会发生什么：
- en: '[PRE58]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, when we run the playbook, you will see pages out output containing the
    dictionary with the contents of `loopresult`. The following output is truncated
    in the interests of space but demonstrates the kind of results you should expect
    from running this playbook:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行playbook时，你将看到包含`loopresult`内容的字典的输出页面。由于空间限制，以下输出被截断，但演示了运行此playbook时你应该期望的结果类型：
- en: '[PRE59]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, the results section of the output is a dictionary, and we can
    clearly see that the first two items in the list were `skipped` because the result
    of our `when` clause (`Conditional`) was `false`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，输出的结果部分是一个字典，我们可以清楚地看到列表中的前两个项目被`skipped`，因为我们`when`子句的结果(`Conditional`)是`false`。
- en: Hence, we can see so far that loops are easy to define and work with—but you
    may be asking, *can you create nested loops?* The answer to that question is *yes*,
    but there is a catch—the special variable named `item` would clash as both the
    inner and outer loops would use the same variable name. This would mean the results
    from your nested loop run would be, at best, unexpected.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到目前为止，我们可以看到循环很容易定义和使用，但你可能会问，*你能创建嵌套循环吗？*这个问题的答案是*可以*，但有一个问题——特殊变量`item`会发生冲突，因为内部循环和外部循环都会使用相同的变量名。这意味着你嵌套循环运行的结果将是意想不到的。
- en: Fortunately, there is a `loop` parameter called `loop_control`, which allows
    you to change the name of the special variable containing the data from the current
    `loop` iteration from `item` to something of your choosing. Let's create a nested
    loop to see how this works.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个名为`loop_control`的`loop`参数，允许您更改包含当前`loop`迭代数据的特殊变量的名称，从`item`更改为您选择的内容。让我们创建一个嵌套循环来看看它是如何工作的。
- en: 'First of all, we''ll create a playbook in the usual manner, with a single task
    to run in a loop. To generate our nested loop, we''ll use the `include_tasks`
    directory to dynamically include a single task from another YAML file that will
    also contain a loop. As we''re intending to use this playbook in a nested loop,
    we''ll use the `loop_var` directive to change the name of the special loop contents
    variable from `item` to `second_item`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将以通常的方式创建一个playbook，其中包含一个要在循环中运行的单个任务。为了生成我们的嵌套循环，我们将使用`include_tasks`目录来动态包含另一个YAML文件中的单个任务，该文件还将包含一个循环。由于我们打算在嵌套循环中使用此playbook，因此我们将使用`loop_var`指令将特殊循环内容变量的名称从`item`更改为`second_item`：
- en: '[PRE60]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, we''ll create a second file called `loopsubtask.yml`, which contains
    the inner loop and is included in the preceding playbook. As we''re already changed
    the loop item variable name in the outer loop, we don''t need to change it again
    here. Note that the structure of this file is very much like a tasks file in a
    role—it is not a complete playbook, but rather simply a list of tasks:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个名为`loopsubtask.yml`的第二个文件，其中包含内部循环，并包含在前面的playbook中。由于我们已经在外部循环中更改了循环项变量名称，因此在这里不需要再次更改它。请注意，此文件的结构非常类似于角色中的任务文件-它不是一个完整的playbook，而只是一个任务列表：
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now you should be able to run the playbook, and you will see Ansible iterate
    over the outer loop first and then process the inner loop over the data defined
    by the outer loop. As the loop variable names do not clash, all works exactly
    as we would expect:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够运行playbook，并且您将看到Ansible首先迭代外部循环，然后处理由外部循环定义的数据的内部循环。由于循环变量名称不冲突，一切都按我们的预期工作：
- en: '[PRE62]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Loops are simple to work with, and yet very powerful as they allow you to easily
    use one task to iterate over a large set of data. In the next section, we'll look
    at another construct of the Ansible language for controlling playbook flow—blocks.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 循环很容易使用，但非常强大，因为它们允许您轻松地使用一个任务来迭代大量数据。在下一节中，我们将看一下Ansible语言的另一个构造，用于控制playbook流程-块。
- en: Grouping tasks using blocks
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用块分组任务
- en: Blocks in Ansible allow you to logically group a set of tasks together, primarily
    for one of two purposes. One might be to apply conditional logic to an entire
    set of tasks; in this example, you could apply an identical when clause to each
    of the tasks, but this is cumbersome and inefficient—far better to place all of
    the tasks in a block and apply the conditional logic to the block itself. In this
    way, the logic only needs to be declared once. Blocks are also valuable when it
    comes to error handling and especially when it comes to recovering from an error
    condition. We shall explore both of these through simple practical examples in
    this chapter to get you up to speed with blocks in Ansible.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible中，块允许您逻辑地将一组任务组合在一起，主要用于两个目的之一。一个可能是对整组任务应用条件逻辑；在这个例子中，您可以将相同的when子句应用于每个任务，但这很麻烦和低效-最好将所有任务放在一个块中，并将条件逻辑应用于块本身。这样，逻辑只需要声明一次。块在处理错误和特别是从错误条件中恢复时也非常有价值。在本章中，我们将通过简单的实际示例来探讨这两个问题，以帮助您快速掌握Ansible中的块。
- en: 'As ever, let''s ensure we have an inventory to work from:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，让我们确保我们有一个清单可以使用：
- en: '[PRE63]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, let''s dive straight in and look at an example of how you would use blocks
    to apply conditional logic to a set of tasks. At a high level, suppose we want
    to perform the following actions on all of our Fedora Linux hosts:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们直接看一个如何使用块来对一组任务应用条件逻辑的示例。在高层次上，假设我们想在所有Fedora Linux主机上执行以下操作：
- en: Install the package for the Apache web server.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Apache web服务器安装软件包。
- en: Install a templated configuration.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装一个模板化的配置。
- en: Start the appropriate service.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动适当的服务。
- en: 'We could achieve this with three individual tasks, all with a `when` clause
    associated with them, but blocks provide us with a better way. The following example
    playbook shows the three tasks discussed contained in a block (notice the additional
    level of indentation required to denote their presence in the block):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过三个单独的任务来实现这一点，所有这些任务都与一个`when`子句相关联，但是块为我们提供了更好的方法。以下示例playbook显示了包含在块中的三个任务（请注意需要额外的缩进级别来表示它们在块中的存在）：
- en: '[PRE64]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'When you run this playbook, you should find that the Apache-related tasks are
    only run on any Fedora hosts you might have in your inventory; you should see
    that either all three tasks are run or are skipped—depending on the makeup and
    contents of your inventory, it might look something like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此playbook时，您应该发现与您可能在清单中拥有的任何Fedora主机上只运行与Apache相关的任务；您应该看到三个任务中的所有任务都被运行或跳过-取决于清单的组成和内容，它可能看起来像这样：
- en: '[PRE65]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is very simple to construct, but very powerful in terms of the effect it
    has on your ability to control the flow over large sets of tasks.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易构建，但在控制大量任务流程方面非常强大。
- en: This time, let's build a different example to demonstrate how blocks can be
    utilized to help Ansible to handle error conditions gracefully. So far, you should
    have experienced that if your playbooks encounter any errors, they are likely
    to stop executing at the point of failure. This is in some situations far from
    ideal, and you might want to perform some kind of recovery actions in this event
    rather than simply halting the playbook.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，让我们构建一个不同的示例，以演示如何利用块来帮助Ansible优雅地处理错误条件。到目前为止，您应该已经经历过，如果您的playbook遇到任何错误，它们可能会在失败点停止执行。在某些情况下，这远非理想，您可能希望在此事件中执行某种恢复操作，而不仅仅是停止playbook。
- en: 'Let''s create a new playbook, this time with the following contents:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的playbook，这次内容如下：
- en: '[PRE66]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Notice that in the preceding play, we now have additional sections to `block`—as
    well as the tasks in `block` itself, we have two new parts labeled `rescue` and
    `always`. The flow of execution is as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的play中，我们现在有了额外的`block`部分——除了`block`本身中的任务外，我们还有两个标记为`rescue`和`always`的新部分。执行流程如下：
- en: All tasks in the `block` section are executed normally, in the sequence in which
    they are listed.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`block`部分中的所有任务都按照其列出的顺序正常执行。'
- en: 'If a task in the `block` results in an error, no further tasks in the `block`
    are run:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`block`中的任务导致错误，则不会运行`block`中的其他任务：
- en: Tasks in the `rescue` section start to run in the order they are listed.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rescue`部分中的任务按其列出的顺序开始运行。'
- en: Tasks in the `rescue` section do not run if no errors result from the `block`
    tasks.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`block`任务没有导致错误，则`rescue`部分中的任务不会运行。
- en: If an error results from a task being run in the `rescue` section, no further
    `rescue` tasks are executed and execution moves on to the `always` section.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在`rescue`部分运行的任务导致错误，则不会执行进一步的`rescue`任务，执行将移至`always`部分。
- en: Tasks in the `always` section are always run, regardless of any errors in either
    the `block` or `rescue` sections. They even run when no errors are encountered.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`always`部分中的任务始终运行，无论`block`或`rescue`部分是否出现错误。即使没有遇到错误，它们也会运行。'
- en: 'With this flow of execution in mind, you should see output similar to the following
    when you execute this playbook, noting that we have deliberately created two error
    conditions to demonstrate the flow:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这种执行流程，当您执行此playbook时，您应该会看到类似以下的输出，注意我们故意创建了两个错误条件来演示流程：
- en: '[PRE67]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Ansible has two special variables, which contain information you might find
    useful in the rescue block to perform your recovery actions:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible有两个特殊变量，其中包含您可能在`rescue`块中找到有用的信息以执行恢复操作：
- en: '`ansible_failed_task`: This is a dictionary containing details of the task
    from `block` that failed, causing us to enter the `rescue` section. You can explore
    this by displaying its contents using `debug`, but for example, the name of the
    failing task can be obtained from `ansible_failed_task.name`*.*'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_failed_task`：这是一个包含来自`block`失败的任务的详细信息的字典，导致我们进入`rescue`部分。您可以通过使用`debug`显示其内容来探索这一点，但例如，失败任务的名称可以从`ansible_failed_task.name`中获取。'
- en: '`ansible_failed_result`: This is the result of the failed task and behaves
    the same as if you had added the `register` keyword to the failing task. This
    saves you having to add `register` to every single task in the block in case it
    fails.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_failed_result`：这是失败任务的结果，并且与如果您在失败的任务中添加了`register`关键字的行为相同。这样可以避免在每个任务中添加`register`以防它失败。'
- en: As your playbooks get more complex and error handling gets more and more important
    (or indeed conditional logic becomes more vital), blocks will become an important
    part of your arsenal in writing good, robust playbooks. Let's proceed in the next
    section to explore execution strategies to gain further control of your playbook
    runs.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的playbooks变得更加复杂，错误处理变得越来越重要（或者条件逻辑变得更加重要），`block`将成为编写良好、健壮的playbooks的重要组成部分。让我们在下一节中继续探讨执行策略，以进一步控制您的playbook运行。
- en: Configuring play execution via strategies
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过策略配置play执行
- en: As your playbooks become increasingly complex, it becomes more and more important
    that you have robust ways to debug any issues that might arise. For example, is
    there a way you can check the contents of a given variable (or variables) during
    execution without the need to insert `debug` statements throughout your playbook?
    Similarly, we have so far seen that Ansible will ensure that a particular task
    runs to completion on all inventory hosts that it applies to before moving on
    to the next task—is there a way to vary this?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的playbooks变得越来越复杂，调试任何可能出现的问题变得越来越重要。例如，您是否可以在执行过程中检查给定变量（或变量）的内容，而无需在整个playbook中插入`debug`语句？同样，我们迄今为止已经看到，Ansible将确保特定任务在应用于所有清单主机之前完成，然后再移动到下一个任务——是否有办法改变这一点？
- en: When you are getting started with Ansible, the execution strategy that you see
    by default (and we have seen this so far in every playbook we have executed, even
    though we have not mentioned it by name) is known as `linear`. This does exactly
    what it describes—each task is executed in turn on all applicable hosts before
    the next task is started. However, there is another, less commonly used strategy
    called `free`, which allows all tasks to be completed as fast as they can on each
    host, without waiting for other hosts.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始使用Ansible时，默认情况下看到的执行策略（尽管我们尚未提到它的名称）被称为`linear`。这正是它所描述的——在开始下一个任务之前，每个任务都会在所有适用的主机上依次执行。然而，还有另一种不太常用的策略称为`free`，它允许所有任务在每个主机上尽快完成，而不必等待其他主机。
- en: 'The most useful strategy when you are starting work with Ansible, however,
    is going to be the `debug` strategy, and this enables Ansible to drop you straight
    into its integrated debug environment if an error should occur in the playbook.
    Let''s demonstrate this by creating a playbook that has a deliberate error in
    it. Note the `strategy: debug` and `debugger: on_failed` statements in the play
    definition:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，当您开始使用Ansible时，最有用的策略将是`debug`策略，这使得Ansible可以在playbook中发生错误时直接将您置于集成的调试环境中。让我们通过创建一个有意义的错误的playbook来演示这一点。请注意play定义中的`strategy:
    debug`和`debugger: on_failed`语句：'
- en: '[PRE68]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now if you execute this playbook, you should see that it starts to run, but
    then drops you into the integrated debugger when it encounters the deliberate
    error it contains. The start of the output should be similar to the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您执行此playbook，您应该会看到它开始运行，但是当遇到它包含的故意错误时，它会将您带入集成调试器。输出的开头应该类似于以下内容：
- en: '[PRE69]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Notice that the playbook starts executing but fails on the first task with an
    error as the variable is undefined. However, rather than exiting back to the shell,
    it enters an interactive debugger. An exhaustive guide to the use of the debugger
    is beyond the scope of this book, but further details are available here if you
    are interested in learning: [https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.html).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，剧本开始执行，但在第一个任务上失败，并显示错误，因为变量未定义。但是，它不是退出到shell，而是进入交互式调试器。本书不涵盖调试器的详尽指南，但如果您有兴趣学习，可以在此处找到更多详细信息：[https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.html)。
- en: 'To take you through a very simple, practical debugging example, however, enter
    the `p task` command at the prompt—this will cause the Ansible debugger to print
    the name of the failing task; this is very useful if you are in the midst of a
    large playbook:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了带您进行一个非常简单的实际调试示例，输入`p task`命令——这将导致Ansible调试器打印失败任务的名称；如果您正在进行一个大型剧本，这将非常有用：
- en: '[PRE70]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now we know where the play failed, so let''s dig a little deeper by issuing
    the `p task.args` command, which will show us the arguments that were passed to
    the module in the task:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了剧本失败的原因，所以让我们通过发出`p task.args`命令来深入了解一下，这将显示传递给任务模块的参数：
- en: '[PRE71]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'So, we can see that our module was passed the argument called `data`, with
    the argument value being a variable (denoted by the pairs of curly braces) called
    `mobile`. Hence, it might be logical to have a look at the variables available
    to the task, to see whether this variable exists, and if so whether the value
    is sensible (use the `p task_vars` command to do this):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到我们的模块传递了一个名为`data`的参数，参数值是一个变量（由大括号对表示）称为`mobile`。因此，可能有必要查看任务可用的变量，看看这个变量是否存在，如果存在的话，值是否合理（使用`p
    task_vars`命令来执行此操作）：
- en: '[PRE72]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The preceding output is truncated, and you will find a great many variables
    associated with the task—this is because any gathered facts, and internal Ansible
    variables, are all available to the task. However, if you scroll through the list,
    you will be able to confirm that there is no variable called `mobile`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出被截断了，您会发现与任务相关的许多变量——这是因为任何收集的事实和内部Ansible变量都可用于任务。但是，如果您浏览列表，您将能够确认没有名为`mobile`的变量。
- en: 'Hence, this should be enough information to fix your playbook. Enter `q` to
    quit the debugger:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这应该足够的信息来修复您的剧本。输入`q`退出调试器：
- en: '[PRE73]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The Ansible debugger is an incredibly powerful tool and you should learn to
    make effective use of it, especially as your playbook complexity grows. This concludes
    our practical look at the various aspects of playbook design—in the next section,
    we'll take a look at the ways in which you can integrate Git source code management
    into your playbooks.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible调试器是一个非常强大的工具，您应该学会有效地使用它，特别是当您的剧本复杂性增加时。这结束了我们对剧本设计各个方面的实际考察——在下一节中，我们将看看您可以将Git源代码管理集成到您的剧本中的方法。
- en: Using ansible-pull
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ansible-pull
- en: The `ansible-pull` command is a special feature of Ansible that allows you to,
    all in one go, pull a playbook from a Git repository (for example, GitHub) and
    then execute it, hence saving the usual steps such as cloning (or updating the
    working copy of) the repository, then executing the playbook. The great thing
    about `ansible-pull` is that it allows you to centrally store and version control
    your playbooks and then execute them with a single command, hence enabling them
    to be executed using the `cron` scheduler without the need to even install the
    Ansible playbooks on a given box.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible-pull`命令是Ansible的一个特殊功能，允许您一次性从Git存储库（例如GitHub）中拉取一个剧本，然后执行它，因此节省了克隆（或更新工作副本）存储库，然后执行剧本等常规步骤。`ansible-pull`的好处在于它允许您集中存储和版本控制您的剧本，然后使用单个命令执行它们，从而使它们能够使用`cron`调度程序执行，而无需甚至在给定的主机上安装Ansible剧本。'
- en: An important thing to note, however, is that, while the `ansible` and `ansible-playbook`
    commands can both operate over an entire inventory and run the playbooks against
    one or more remote hosts, the `ansible-pull` command is only intended to run the
    playbooks it obtains from your source control system on the localhost. Hence,
    if you want to use `ansible-pull` throughout your infrastructure, you must install
    it onto every host that needs it.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的一点是，虽然`ansible`和`ansible-playbook`命令都可以在整个清单上运行剧本，并针对一个或多个远程主机运行剧本，但`ansible-pull`命令只打算在本地主机上运行从您的源代码控制系统获取的剧本。因此，如果您想在整个基础架构中使用`ansible-pull`，您必须将其安装到每个需要它的主机上。
- en: Nonetheless, let's see how this might work. We'll simply run the command by
    hand to explore its application, but in reality, you would almost certainly install
    it into your `crontab` so that it runs on a regular basis, picking up any changes
    you make to your playbook in the version control system.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，让我们看看这可能是如何工作的。我们将简单地手动运行命令来探索它的应用，但实际上，您几乎肯定会将其安装到您的`crontab`中，以便定期运行，捕捉您对剧本所做的任何更改版本控制系统中。
- en: As `ansible-pull` is only intended to run the playbook on the local system,
    an inventory file is somewhat redundant—instead, we'll use a little-used inventory
    specification whereby you can simply specify inventory hosts directory as a comma-separated
    list on the command line. If you only have one host, you simply specify its name
    followed by a comma.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ansible-pull`只打算在本地系统上运行剧本，因此清单文件有些多余——相反，我们将使用一个很少使用的清单规范，您可以在命令行上简单地指定清单主机目录为逗号分隔的列表。如果您只有一个主机，只需指定其名称，然后加上逗号。
- en: 'Let''s use a simple playbook from GitHub that sets the message of the day based
    on variable content. To do this, we will run the following command (which we''ll
    break down in a minute):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GitHub上的一个简单的剧本，根据变量内容设置每日消息。为此，我们将运行以下命令（我们将在一分钟内分解）：
- en: '[PRE74]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This command breaks down as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令分解如下：
- en: '`-d /var/ansible-set-motd`: This sets the working directory that will contain
    the checkout of the code from GitHub.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d /var/ansible-set-motd`：这将设置包含来自GitHub的代码检出的工作目录。'
- en: '`-i ${HOSTNAME},`: This runs only on the current host, specified by its hostname
    from the appropriate shell variable.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i ${HOSTNAME},`：这仅在当前主机上运行，由适当的shell变量指定其主机名。'
- en: '`-U https://github.com/jamesfreeman959/ansible-set-motd.git`: We use this URL
    to obtain the playbooks.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-U https://github.com/jamesfreeman959/ansible-set-motd.git`：我们使用此URL来获取playbooks。'
- en: '`site.yml`: This is the name of the playbook to run.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`site.yml`：这是要运行的playbook的名称。'
- en: '`-e "ag_motd_content=''MOTD generated by ansible-pull''"`: This sets the appropriate
    Ansible variable to generate the MOTD content.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e "ag_motd_content=''MOTD generated by ansible-pull''"`：这将设置适当的Ansible变量以生成MOTD内容。'
- en: '`>> /tmp/ansible-pull.log 2>&1`: This redirects the output of the command to
    a log file in case we need to analyze it later—especially useful if running the
    command in a `cron job` where the output would never be printed to the user''s
    terminal.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>> /tmp/ansible-pull.log 2>&1`：这将重定向命令的输出到日志文件，以便以后分析 - 特别是在`cron job`中运行命令时，输出将永远不会打印到用户的终端上，这是非常有用的。'
- en: 'When you run this command, you should see some output similar to the following
    (note that log redirection has been removed to make it easier to see the output):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此命令时，您应该会看到类似以下的输出（请注意，为了更容易看到输出，已删除了日志重定向）：
- en: '[PRE75]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This command can be a very powerful part of your overall Ansible solution, especially
    as it means you don't have to worry too greatly about running all of your playbooks
    centrally, or ensuring that they are all up to date every time you run them. The
    ability to schedule this in `cron` is especially powerful in a large infrastructure
    where, ideally, automation means things should take care of themselves.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令可以成为您整体Ansible解决方案的一个非常强大的部分，特别是因为这意味着您不必过于担心集中运行所有playbooks，或者确保每次运行它们时它们都是最新的。在大型基础架构中，将其安排在`cron`中的能力尤其强大，理想情况下，自动化应该能够自行处理事务。
- en: This concludes our practical look at playbooks and how to author your own code—with
    a little research into Ansible modules, you should now have enough to write your
    own robust playbooks with ease.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对playbooks的实际观察，以及如何编写自己的代码 - 通过对Ansible模块进行一些研究，现在您应该足够轻松地编写自己的强大playbooks了。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Playbooks are the lifeblood of Ansible automation, providing a robust framework
    within which to define logical collections of tasks and handle error conditions
    cleanly and robustly. The addition of roles into this mix is valuable in terms
    of not only organizing your code but also in terms of supporting code reuse as
    your automation requirements grow. Ansible playbooks provide a truly complete
    automation solution for your technology needs.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Playbooks是Ansible自动化的生命线，提供了一个强大的框架，用于定义任务的逻辑集合并清晰而强大地处理错误条件。将角色添加到这个混合中对于组织代码和支持代码重用都是有价值的，尤其是在您的自动化需求增长时。Ansible
    playbooks为您的技术需求提供了一个真正完整的自动化解决方案。
- en: In this chapter, you learned about the playbook framework and how to start building
    your own playbooks. You then learned how to organize your code into roles and
    design your code to effectively and efficiently support reuse. We then explored
    some of the more advanced playbook writing topics such as working with conditional
    logic, blocks, and loops. Finally, we looked at playbook execution strategies,
    especially with a view to being able to debug your playbooks effectively, and
    we wrapped up with a look at how you can run Ansible playbooks on a local machine
    directly from GitHub.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了playbook框架以及如何开始编写自己的playbooks。然后，您学习了如何将代码组织成角色，并设计代码以有效地支持重用。然后，我们探讨了一些更高级的playbook编写主题，如使用条件逻辑、块和循环。最后，我们看了一下playbook执行策略，特别是为了能够有效地调试您的playbooks，最后，我们看了一下如何直接从GitHub在本地机器上运行Ansible
    playbooks。
- en: In the next chapter, we will learn how to consume and create our very own modules,
    providing you with the skills you need to expand the capabilities of Ansible to
    suit your own bespoke environments, and to contribute back to the community.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用和创建我们自己的模块，为您提供扩展Ansible功能的技能，以适应自己定制的环境，并为社区做出贡献。
- en: Questions
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do you restart the Apache web server in the `frontends` host group via an
    ad hoc command?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何通过临时命令在“frontends”主机组中重新启动Apache Web服务器？
- en: A) `ansible frontends -i hosts -a "name=httpd state=restarted"`
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: A) `ansible frontends -i hosts -a "name=httpd state=restarted"`
- en: B) `ansible frontends -i hosts -b service -a "name=httpd state=restarted"`
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: B) `ansible frontends -i hosts -b service -a "name=httpd state=restarted"`
- en: C) `ansible frontends -i hosts -b -m service -a "name=httpd state=restarted"`
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: C) `ansible frontends -i hosts -b -m service -a "name=httpd state=restarted"`
- en: D) `ansible frontends -i hosts -b -m server -a "name=httpd state=restarted"`
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: D) `ansible frontends -i hosts -b -m server -a "name=httpd state=restarted"`
- en: E) `ansible frontends -i hosts -m restart -a "name=httpd"`
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: E) `ansible frontends -i hosts -m restart -a "name=httpd"`
- en: Do blocks allow you to logically make a group of tasks, or perform error handling?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Do块允许您逻辑地组合一组任务，或执行错误处理吗？
- en: A) True
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: A) 正确
- en: B) False
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: B) 错误
- en: Default strategies are intended via the relevant modules in the playbook.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认策略是通过playbook中的相关模块进行设置。
- en: A) True
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: A) 正确
- en: B) False
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: B) 错误
- en: Further reading
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '`ansible-galaxy` and the documentation can be found here: [https://galaxy.ansible.com/docs/](https://galaxy.ansible.com/docs/).'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible-galaxy`和文档可以在这里找到：[https://galaxy.ansible.com/docs/](https://galaxy.ansible.com/docs/)。'
