- en: Interacting with Your Code in Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes中与您的代码交互
- en: In the last chapter, we walked through making container images, and created
    simple examples using Python and Node.js. In this chapter, we will expand on the
    brief introduction to interacting with your running code, and dig into further
    details on how to see how your code is operating, run additional commands, and
    get debugging from those Pods.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了制作容器镜像，并使用Python和Node.js创建了简单的示例。在本章中，我们将扩展与正在运行的代码交互的简要介绍，并深入了解如何查看代码的运行情况，运行其他命令，并从这些Pod中进行调试的更多细节。
- en: 'The sections for this chapter are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的各节包括：
- en: Practical notes for writing your software to run in a Pod
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写软件以在Pod中运行的实用注释
- en: Getting logs from your containers and Pods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从您的容器和Pod中获取日志
- en: Interaction with a running Pod
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与正在运行的Pod交互
- en: Kubernetes Concepts—labels and selectors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes概念—标签和选择器
- en: Kubernetes Resource—service
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes资源—服务
- en: Discovering services from your Pod
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从您的Pod中发现服务
- en: Practical notes for writing software to run in a container
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写软件以在容器中运行的实用注释
- en: To use Kubernetes in your development process, one of the foundational requirements
    is running your code in a container. As you've seen, this adds a few steps to
    your development process. It also places a few more constraints around how you
    structure your code and interact with it, primarily so you can take advantage
    of the constraints to let Kubernetes do the work of running the processes, connecting
    them together, and coordinating any output. This is very different from many developers'
    habits of running one or more processes together, even with additional services
    needed for your application – such as databases or caches—on your local development
    machine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要在开发过程中使用Kubernetes，其中一个基本要求是在容器中运行代码。正如您所见，这为您的开发过程增加了一些步骤。它还在如何构造代码和与之交互方面增加了一些约束，主要是为了让您能够利用这些约束，让Kubernetes来运行进程、连接它们，并协调任何输出。这与许多开发人员习惯的在本地开发机器上运行一个或多个进程，甚至需要额外服务来运行应用程序（如数据库或缓存）的习惯非常不同。
- en: This section provides some tips and suggestions on how to work with containers
    more effectively.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了一些有关如何更有效地使用容器的提示和建议。
- en: Getting options for your executable code
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取可执行代码的选项
- en: Aside from the `ENTRYPOINT` and `CMD` defined when you create your container,
    a container image can also define environment variables, usually via the `ENV`
    command when creating the container image. The `ENTRYPOINT`, `CMD`, and the environment
    variables can be overwritten or updated at execution time or when defining a deployment.
    Environment variables therefore become one of the most common ways of passing
    in configuration to your container.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在创建容器时定义的`ENTRYPOINT`和`CMD`之外，容器镜像还可以通过`ENV`命令定义环境变量。`ENTRYPOINT`、`CMD`和环境变量可以在执行时或在定义部署时被覆盖或更新。因此，环境变量成为向容器传递配置的最常见方式之一。
- en: Writing your software to utilize these environment variables will be important.
    As you create your software, make sure that you can take advantage of environment
    variables as well as command-line arguments in your code. Most languages have
    a library that will support options as either command-line arguments or environment
    variables.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编写软件以利用这些环境变量将是重要的。在创建软件时，请确保您可以利用环境变量以及代码中的命令行参数。大多数语言都有一个库，可以支持选项作为命令行参数或环境变量。
- en: In our next chapter, we will see how to set up configurations and pass them
    to your container at deployment time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何设置配置并在部署时将其传递给您的容器。
- en: Practical notes for building container images
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建容器镜像的实用注释
- en: 'The following are suggestions and practical advice for maintaining your container
    images:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是维护容器镜像的建议和实用建议：
- en: 'Keep a Dockerfile in your source repository.  If your application source is
    by itself in a Git repository, then including a Dockerfile in the repository along
    with it makes a great deal of sense. You can reference files to COPY or ADD from
    the relative directory of where your source is located. It’s not uncommon to see
    a Dockerfile in the root of a repository, or if you''re working from a monorepo
    with many projects, consider a Docker directory in the same directory as  your
    project’s source code:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源代码存储库中保留一个Dockerfile。如果您的应用程序源代码本身位于Git存储库中，那么在存储库中包含一个Dockerfile是非常合理的。您可以引用要从相对目录复制或添加的文件，该目录是您的源代码所在的位置。在存储库的根目录中看到Dockerfile是很常见的，或者如果您正在从一个包含许多项目的monorepo中工作，可以考虑在与项目源代码相同的目录中创建一个Docker目录：
- en: If you want to take advantage of an automatic Docker build on Docker Hub, Quay,
    or another container repository, the automated system expects the Dockerfile to
    be in the root of your Git repository.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想利用Docker Hub、Quay或其他容器存储库上的自动Docker构建，自动化系统期望Dockerfile位于Git存储库的根目录中。
- en: Maintain a separate script (if needed) for creating the container image. Or
    more specifically, don’t mix the process of creating your container image with
    code generation, compilation, testing, or validation. This keeps a clear separation
    of concerns from development tasks that you may need, depending on your language
    and framework. This will allow you to include it when and where you want to in
    an automation pipeline.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持一个单独的脚本（如果需要）用于创建容器镜像。更具体地说，不要将创建容器镜像的过程与代码生成、编译、测试或验证混在一起。这将清晰地区分出您可能需要的开发任务，具体取决于您的语言和框架。这将允许您在自动化流水线中在需要时包含它。
- en: 'It will be very tempting to add in additional tools to your base image to enable
    debugging, support new or additional diagnostic work, and so on. Make an explicit
    and conscious choice of what additional tooling you will (and won’t) include within
    the image. I advise minimal additional tools, not just because they cause the
    image to be larger, but often the same tools that are so effective at debugging
    present an option for easier exploitation from hackers:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基础镜像中添加额外工具可能非常诱人，以便进行调试、支持新的或额外的诊断工作等。明确和有意识地选择要在镜像中包含的额外工具。我建议最小化额外工具的使用，不仅因为它们会使镜像变得更大，而且通常那些在调试中非常有效的工具也会给黑客提供更容易利用的选项：
- en: If you find you must add debugging tools into your image, consider making a
    second Dockerfile in a subdirectory that adds to the first and only includes the
    debugging tools you want to add. If you do this, I recommend you add a name `-debug` to
    the name of the image to make it clear that the image has the additional tooling
    installed.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您发现必须在镜像中添加调试工具，请考虑在子目录中创建第二个Dockerfile，该文件添加到第一个文件中，并且只包含您想要添加的调试工具。如果这样做，我建议您在镜像的名称中添加一个“-debug”以明确表明该镜像已安装额外的工具。
- en: 'When you build your container image, build it with production usage in mind,
    and as a default. With containers, this is often represented with default values
    for environment variables that are made available in the container. In general,
    try not to include the dependencies needed for unit testing, development tasks,
    and so on in your container image:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建容器镜像时，要考虑其生产使用，并将其作为默认设置。对于容器来说，这通常表示容器中提供的环境变量的默认值。一般来说，尽量不要在容器镜像中包含单元测试、开发任务等所需的依赖项：
- en: In the case of Node.js, use the environment variable `ENV=PROD`, so that `npm`
    doesn’t include development dependencies, or explicitly strip them away with a
    command line `npm install —production`.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Node.js的情况下，使用环境变量`ENV=PROD`，这样`npm`就不会包含开发依赖项，或者使用命令行`npm install —production`明确地将它们剥离。
- en: Treat the entire container you create as a read-only filesystem after you’ve
    created it. If you want to have some place to write local files, identify that
    location explicitly and set up a volume in your container for it.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建容器后，将整个容器视为只读文件系统。如果您想要有某个地方来写入本地文件，请明确标识该位置并在容器中设置一个卷。
- en: Sending output from your program
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送程序输出
- en: '`kubectl logs` (as well as the Docker equivalent: `docker logs`) defaults to
    combining `stdout` and `stderr` and passing anything presented as logs for the
    container. You may have also had experience with creating specific logging capabilities
    in your code to write logs to a file location on disk. In general, writing logs
    to a filesystem location is not encouraged for software running within a container,
    as to include it in general logging means that something has to read it again,
    which unnecessarily increases disk I/O.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl logs`（以及Docker的等效命令：`docker logs`）默认将`stdout`和`stderr`组合在一起，并将任何显示为日志的内容传递给容器。您可能也有过在代码中创建特定的日志记录功能，将日志写入磁盘上的文件位置的经验。一般来说，将日志写入文件系统位置不鼓励在容器内运行的软件中，因为要将其包含在一般日志记录中意味着必须再次读取它，这会不必要地增加磁盘I/O。'
- en: If you want to have a means of supporting aggregated logging in your application,
    then you will typically want to have something external to your container and/or
    Pod defined to help capture, transport, and process those logs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在应用程序中支持聚合日志记录的方法，那么通常希望在容器和/或Pod之外定义一些内容来帮助捕获、传输和处理这些日志。
- en: In general, if you write your programs to log to `stdout` and `stderr`, then
    containers and Kubernetes running those containers will generally help you to
    get access to those details more easily.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果您编写程序将日志记录到`stdout`和`stderr`，那么运行这些容器的容器和Kubernetes通常会帮助您更轻松地访问这些细节。
- en: Logs
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志
- en: The most common method of getting information about how your code is working
    is generally through logs. Every language and development environment has its
    own pattern of how to expose those details, but at the very basics, it can be
    as simple as a print statement sending a line of text that will mean something
    to you to `stdout`. It is without a doubt the most consistent means across all
    programming languages of quick and simple debugging. When you deploy and run your
    code in Kubernetes, it maintains access to the logs from each Pod and container—where
    logs, in this case, are sending data to `stdout` and `stderr`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 获取有关代码运行情况的最常见方法通常是通过日志。每种语言和开发环境都有自己的模式来公开这些细节，但基本上，它可以简单地通过打印语句发送一行文本到`stdout`，这对于快速和简单的调试无疑是最一致的方法。当您在Kubernetes中部署和运行代码时，它可以访问来自每个Pod和容器的日志，其中日志在这种情况下是将数据发送到`stdout`和`stderr`。
- en: If your existing pattern of development writes output to a specific file location,
    and maybe your framework includes the capability of rotating those log files as
    they grow, you may want to consider just sending data to `stdout` and/or `stderr`
    so that Kubernetes can make this coordination work.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现有的开发模式将输出写入特定的文件位置，也许您的框架包括在文件增长时旋转这些日志文件的功能，您可能希望考虑只是将数据发送到`stdout`和/或`stderr`，以便Kubernetes可以使这种协调工作。
- en: Pods with more than one container
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有多个容器的Pod
- en: Our examples have been simple so far, with a single container in a Pod. A Pod
    can have more than one container at a time, and the command to get the logs can
    specify which container to use. If there is only one container, you don’t need
    to specify which one to use.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的示例都很简单，一个Pod中只有一个容器。一个Pod可以同时拥有多个容器，获取日志的命令可以指定使用哪个容器。如果只有一个容器，就不需要指定要使用哪个容器。
- en: If you need to specify a specific container, you can do so with either the `-c`
    option, or by adding it onto the `logs` command. For example, if you had a Pod
    named `webapp `with two containers, `flask` and `background`, and you wanted to
    see the logs from the `background` container, you could use the `kubectl logs
    webapp background` or `kubectl logs webapp -c background` commands.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要指定特定的容器，可以使用`-c`选项，或者将其添加到`logs`命令中。例如，如果有一个名为`webapp`的Pod，其中包含两个容器`flask`和`background`，你想要查看`background`容器的日志，可以使用`kubectl
    logs webapp background`或`kubectl logs webapp -c background`命令。
- en: 'Likewise, there''s a shortcut for defining Pods and containers within a deployment.
    Rather than specifying the full Pod name based on the names assigned through Kubernetes,
    you can prefix the name of the Pod with just the deployment name. For example,
    if we had created a deployment with the `kubectl run flask image=…` command from
    our earlier examples, we could use the following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，定义部署中的Pod和容器也有一个快捷方式。与其通过Kubernetes分配的名称来指定完整的Pod名称，你可以只用部署名称作为Pod名称的前缀。例如，如果我们之前使用`kubectl
    run flask image=…`命令创建了一个部署，我们可以使用以下命令：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is rather than looking up the specific Pod name and then asking for the
    logs based on that name.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就不需要查找特定的Pod名称，然后根据该名称请求日志了。
- en: Streaming the logs
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流式传输日志
- en: 'A common desire is to see a continuously flowing set of logs from your container,
    updated as the container provides the information. You can enable this with the
    `-f` option. For example, to see the updated logs from the Pod associated with
    the `flask` deployment, you can run the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常希望能够连续查看容器的日志，随着容器提供信息而更新。你可以使用`-f`选项来实现这一点。例如，要查看与`flask`部署相关的Pod的更新日志，可以运行以下命令：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you interact with that service, or that service writes to `stdout` and does
    its normal logging, you will see the output streamed to your console.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与该服务交互，或者该服务写入`stdout`并进行正常日志记录时，你会看到输出流到你的控制台。
- en: Previous logs
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 之前的日志
- en: The logs are generally specific to an active container. However, there is a
    common need to see what might have been in the logs if a container fails, or perhaps
    if you rolled out an update and something didn't work as expected. Kubernetes
    maintains a reference to the previous container for any Pod (if it exists), so
    that you can get this information when you need it. You can do this with the `-p`
    option, as long as the logs are available to Kubernetes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 日志通常是特定于活动容器的。然而，通常需要查看如果容器失败时日志中可能包含的内容，或者如果你部署更新后出现了意外情况。Kubernetes会保留对任何Pod的先前容器的引用（如果存在），这样你在需要时就可以获取这些信息。只要日志对Kubernetes可用，你可以使用`-p`选项来实现这一点。
- en: Timestamps
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间戳
- en: 'Timestamps are also available for the log output, although not by default.
    You can get the log messages prefixed by a timestamp by adding the `--timestamps`
    option. For example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 日志输出也可以包含时间戳，尽管默认情况下不会。你可以通过添加`--timestamps`选项来获取带有时间戳前缀的日志消息。例如：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You then may see the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可能会看到以下内容：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is worthwhile to note that the timestamps are from the hosts that are running
    the containers, not your local machine, so the time zone on those logs will often
    not be the same time zone in which you reside. The timestamps all include full-time
    zone detail (typically set to the UTC-0 time zone) so the values can be converted
    easily.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，时间戳来自运行容器的主机，而不是您的本地机器，因此这些日志中的时区通常不是您所在的时区。所有时间戳都包括完整的时区细节（通常设置为 UTC-0
    时区），因此值可以很容易地转换。
- en: More debugging techniques
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多的调试技术
- en: 'There are several debugging techniques to work with your code deployed into
    an existing cluster. These include:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种调试技术可以处理部署到现有集群中的代码。这些包括：
- en: Interactive deployment of a container image
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像的交互式部署
- en: Attaching to a running Pod
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加到运行中的 Pod
- en: Running a second command within an existing Pod
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有 Pod 中运行第二个命令
- en: Interactive deployment of an image
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜像的交互式部署
- en: You can also use the `kubectl run` command to start an interactive session with
    a Pod. This can be exceptionally useful to log in and see what is available in
    a container image, or within the context of the software you've copied into a
    container image.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `kubectl run` 命令启动与 Pod 的交互会话。这对于登录并查看容器镜像中可用的内容，或者在您复制到容器镜像中的软件的上下文中非常有用。
- en: 'For example, if you wanted to run a shell to look around inside the base Alpine
    container image that I used for the Python example, you could run the following
    command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想运行一个 shell 来查看我用于 Python 示例的基本 Alpine 容器镜像内部，您可以运行以下命令：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `-i` option is what tells it to make the session interactive, and the `-t`
    option (which is almost always used with the `-i` option) indicates that it should
    allocate a TTY session (a Terminal session) for the interactive output. The trailing
    `-- sh` is an override to provide a specific command to be invoked with this session,
    in this case `sh`, asking to execute the shell.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: -i` 选项是告诉它使会话交互，并且 `-t` 选项（几乎总是与 `-i` 选项一起使用）表示它应为交互式输出分配一个 TTY 会话（终端会话）。结尾的
    `-- sh` 是一个覆盖，提供一个特定的命令来调用这个会话，在这种情况下是 `sh`，要求执行 shell。
- en: 'When you invoke this command, it still sets up a deployment, and when you exit
    the interactive shell, the output will tell you how can you reattach to that same
    interactive shell. The output will look something like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用此命令时，它仍然设置一个部署，当您退出交互式 shell 时，输出将告诉您如何重新连接到相同的交互式 shell。输出将看起来像下面这样：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you want to kill that deployment, you will need to run the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要终止该部署，您需要运行以下命令：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This technique is immensely useful for getting a container image up and running
    within the Kubernetes cluster, and giving you shell access to interact with it.
    If you are used to using Python, Node.js, or similar dynamic languages, then the
    ability to get your libraries all loaded and a REPL active for you to interrogate
    or interact with to interactively poke at the running environment can be incredibly
    useful.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术对于在 Kubernetes 集群中启动和运行容器镜像，并让您与之交互的 shell 访问非常有用。如果您习惯使用 Python、Node.js
    或类似的动态语言，那么能够加载所有库并激活 REPL 以便与之交互或交互式地查看运行环境，将会非常有用。
- en: 'As an example, we can do this with the same Python image that we used for our
    Flask application. To bring it up as an interactive session that you can later
    delete, use the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用相同的 Python 镜像来为我们的 Flask 应用程序做这个。要将其作为一个可以稍后删除的交互式会话启动，使用以下命令：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This command can take a little time to complete, as it will wait while Kubernetes
    downloads the image and starts it, using the command we put in (`/bin/sh`) instead
    of the entrypoint that we defined for it originally. In a short while, you should
    see some output in your Terminal window akin to the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令可能需要一些时间才能完成，因为它将等待Kubernetes下载映像并启动它，使用我们最初放置的命令(`/bin/sh`)，而不是我们为其定义的入口点。不久之后，您应该在终端窗口中看到类似以下的一些输出：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At this point, you can invoke Python and interact with the Python REPL directly,
    loading code and doing whatever you need. The following are some example commands
    to show you how this might work:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可以调用Python并直接与Python REPL交互，加载代码并执行所需的操作。以下是一些示例命令，以显示这可能如何工作：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once you are done interacting with this deployment, you can exit the shell by
    pressing *Ctrl* + *D* or by typing `exit`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与部署交互完成后，您可以通过按下*Ctrl* + *D*或输入`exit`来退出shell。
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is leaving the deployment running, so you can reattach to it using the
    preceding command, or you can delete the deployment and recreate it again when/if
    you want it. To delete it, you would use the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将保持部署运行，因此您可以使用上述命令重新附加到它，或者在需要时删除部署并重新创建它。要删除它，您将使用以下命令：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Attaching to a running Pod
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到正在运行的Pod
- en: If your pod is up and running, and you want to run some commands from within
    the context of that container image, you can attach an interactive session to
    it. You do this via the `kubectl attach` command. A Pod must be active for this
    command to work, so if you’re trying to figure out why a Pod didn’t start properly,
    this command probably won’t help.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Pod正在运行，并且您想从该容器映像的上下文中运行一些命令，您可以附加一个交互式会话。您可以通过`kubectl attach`命令来执行此操作。Pod必须处于活动状态才能使用此命令，因此如果您试图弄清楚为什么Pod未正确启动，此命令可能不会有帮助。
- en: 'Attaching to a Pod will connect `stdin` into your process, and take anything
    from `stdout` and `stderr` and present it on the screen, so it’s more like an
    interactive version of the `kubectl logs -f` command. Whatever you specified for
    the container will need to take `stdin` in order for this to be useful. You will
    also need to explicitly enable the TTY in order to connect to it. If you do not,
    you will frequently see the following as a first line of the output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到Pod将连接`stdin`到您的进程，并将`stdout`和`stderr`的任何内容呈现在屏幕上，因此它更像是`kubectl logs -f`命令的交互版本。为了使其有用，您指定的容器还需要接受`stdin`。您还需要显式启用TTY才能连接到它。如果不这样做，您经常会看到以下内容作为输出的第一行：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you had created a deployment from the `nodejs` example earlier using the
    following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前使用以下命令从`nodejs`示例创建了一个部署：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You could attach to this Pod using the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令附加到此Pod：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will return a warning message:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个警告消息：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And thereafter, when you interact with the service, you will see `stdout` streamed
    in the Terminal window.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，当您与服务交互时，您将在终端窗口中看到`stdout`流。
- en: This is most effective if your application prints its logs to `stdout` and you
    want to watch those logs while you interact with your code, for example by using
    a web browser. To use a web browser to interact with your running Pod, remember
    to use either the `kubectl proxy` or `kubectl port-forward` commands, typically
    from another Terminal window, to route access from your laptop to your Pod within
    the cluster.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序将其日志打印到`stdout`并且您希望在与代码交互时观看这些日志，例如使用Web浏览器，这将非常有效。要使用Web浏览器与正在运行的Pod进行交互，请记住使用`kubectl
    proxy`或`kubectl port-forward`命令，通常从另一个终端窗口，将访问从您的笔记本电脑路由到集群中的Pod。
- en: In many cases, you will be better served by using the `kubectl logs` command
    that we described earlier with the `-f` option. The primary difference is if you
    have enabled your application to react to input from `stdin` and you ran it with
    `stdin` and a TTY defined, then you can interact with it directly by using the
    `kubectl attach` command.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，您最好使用我们之前描述的带有`-f`选项的`kubectl logs`命令。主要区别在于，如果您已经启用了应用程序以对来自`stdin`的输入做出反应，并且使用了定义了`stdin`和TTY的命令运行它，那么您可以直接使用`kubectl
    attach`命令与其交互。
- en: Running a second process in a container
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中运行第二个进程
- en: I frequently find it more useful to run an additional command in a Pod rather
    than attempting to attach to the Pod. You can do this with the `kubectl exec`
    command.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常发现在Pod中运行额外的命令比尝试附加到Pod更有用。您可以使用`kubectl exec`命令来实现这一点。
- en: 'As of Kubernetes 1.8, `kubectl exec` doesn''t support the deployment/name shortcut
    that we have used for the logs or attach commands, so you will need to specify
    the specific Pod name you want to interact with. If you just want to open an interactive
    shell in the Pod, you could run the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 截至Kubernetes 1.8，`kubectl exec`不支持我们用于日志或附加命令的部署/名称快捷方式，因此您需要指定要与之交互的特定Pod名称。如果您只想在Pod中打开交互式shell，可以运行以下命令：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using the name of the running pod, invoke `kubectl exec` to open an interactive
    shell within it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用运行中的Pod的名称，调用`kubectl exec`在其中打开交互式shell：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can also use this to invoke any command that’s built into your container.
    For example, if you had a script or process that collected and exported diagnostic
    data, you might invoke that. Or, you could use a command such as `killall -HUP
    python3`, which will send a `HUP` signal to all `python3` processes that are running.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用此功能调用内置于容器中的任何命令。例如，如果您有一个收集和导出诊断数据的脚本或进程，您可以调用该命令。或者，您可以使用`killall -HUP
    python3`这样的命令，它将向所有正在运行的`python3`进程发送`HUP`信号。
- en: Kubernetes concepts – labels
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes概念-标签
- en: In the first example, you saw how creating a deployment also created a ReplicaSet
    and related pods, in order to run your software.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，您看到创建部署还创建了一个ReplicaSet和相关的Pod，以便运行您的软件。
- en: Kubernetes has a very flexible mechanism for connecting and referencing objects
    that it manages. Rather than having a very strict hierarchy of what can be connected,
    the Kubernetes project uses short, definitive key/value pairs as set of tags on
    resources, called labels. There is a matching mechanism to query and find related
    labels, called Selectors.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes具有非常灵活的机制，用于连接和引用其管理的对象。 Kubernetes项目使用资源上的一组标签，称为标签，而不是具有非常严格的可以连接的层次结构。有一个匹配机制来查询和找到相关的标签，称为选择器。
- en: Labels are fairly strictly defined in format, and are intended to group together
    resources in Kubernetes. They are not intended to identify a single or unique
    resource. They can be used to describe relevant information about a set of Kubernetes
    resources, be that a Pod, ReplicaSet, Deployment, and so on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 标签在格式上相当严格定义，并且旨在将Kubernetes中的资源分组在一起。它们不打算标识单个或唯一的资源。它们可用于描述一组Kubernetes资源的相关信息，无论是Pod、ReplicaSet、Deployment等。
- en: As we mentioned earlier, labels are key-value structures. The keys in labels
    are limited in size and may include an optional prefix, followed by a / character,
    and then the rest of the key. Prefixes, if supplied, are expected to be a DNS
    domain. Internal components and plugins to Kubernetes are expected to use prefixes
    to group and segregate their labels, and the prefix `kubernetes.io` is reserved
    for Kubernetes internal labels. If a prefix is not defined, then it is considered
    entirely under user control, and you need to maintain your own rules about consistency
    of what non-prefixed labels mean.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，标签是键-值结构。标签中的键大小受限，并且可能包括一个可选的前缀，后跟一个/字符，然后是键的其余部分。如果提供了前缀，则预期使用DNS域。Kubernetes的内部组件和插件预期使用前缀来分组和隔离它们的标签，前缀`kubernetes.io`保留用于Kubernetes内部标签。如果未定义前缀，则被认为完全由用户控制，并且你需要维护自己关于非前缀标签意义一致性的规则。
- en: If you do want to use a prefix, it needs to be 253 characters or less. The key
    beyond the prefix has a maximum length of 63 characters. Keys can also only be
    specified with alphanumeric characters, as well as `-`, `_`, and `.`. Unicode
    and non-alpha-numeric characters aren’t supported as labels.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用前缀，它需要少于253个字符。前缀之外的键的最大长度为63个字符。键也只能由字母数字字符、`-`、`_`和`.`指定。Unicode和非字母数字字符不支持作为标签。
- en: 'Labels are intended to represent semantic information about a resource, and
    having multiple labels is not only acceptable, but expected. You will see labels
    used extensively in Kubernetes examples for a wide variety of purposes. Most common
    are dimensions of interest, such as:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 标签旨在表示关于资源的语义信息，拥有多个标签不仅可以接受，而且是预期的。你会看到标签在Kubernetes示例中被广泛使用，用于各种目的。最常见的是感兴趣的维度，例如：
- en: Environment
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境
- en: Version
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本
- en: Application name
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序名称
- en: Tier of service
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务层级
- en: They can also be used to track any grouping that you’re interested in based
    on your organization or development needs. Team, area of responsibility, or other
    semantic attributes are fairly common.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以用来跟踪你感兴趣的任何基于你的组织或开发需求的分组。团队、责任领域或其他语义属性都是相当常见的。
- en: Organization of labels
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签的组织
- en: Grouping your resources when you have more than "just a few" is critical to
    maintaining understanding of your system, as well as allowing you to think about
    the resources by their responsibility rather than individual names or IDs.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拥有超过“只是一点点”的资源时，对资源进行分组对于维护对系统的理解至关重要，同时也让你能够根据其责任而不是个体名称或ID来思考资源。
- en: 'You should consider making and maintaining a living document with labels you
    use and their meaning and intentions. I prefer to do this in a `README.md` in
    the deploy directory where I keep the Kubernetes declarations, and find that whatever
    conventions you set are critical to understand, especially when you are working
    as part of a team. Even if you work alone, this is an excellent practice: what
    is obvious to you today may be completely obscure to *future you* in six months
    or even longer.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该考虑创建并维护一个包含你使用的标签及其含义和意图的实时文档。我更喜欢在部署目录中的`README.md`中进行这项工作，我会在那里保存Kubernetes声明，我发现你设置的任何约定都对理解至关重要，特别是当你作为团队的一部分工作时。即使你是独自工作，这也是一个很好的实践：今天对你来说很明显的东西，也许在六个月甚至更长时间内对*未来的你*来说完全晦涩难懂。
- en: It is also your responsibility to keep clear the meaning of your own labels.
    Kubernetes does nothing to prevent you from confusing or reusing simplistic labels.
    A resource we will talk about later in this chapter called a service specifically
    uses labels to coordinate access to Pods, so keeping clear usage of those labels
    is very important. Reusing label keys across different Pods can lead to very unexpected
    results.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您还有责任清楚地了解自己标签的含义。Kubernetes不会阻止您混淆或重复使用简单的标签。我们将在本章后面讨论的一种资源称为服务，专门使用标签来协调对Pods的访问，因此保持清晰地使用这些标签非常重要。在不同的Pods之间重用标签键可能会导致非常意外的结果。
- en: Kubernetes concepts – selectors
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes概念-选择器
- en: Selectors are used in Kubernetes to connect resources together based on the
    labels they have (or don’t have). A selector is meant to provide a means to retrieve
    a set of resources in Kubernetes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，选择器用于基于它们具有（或不具有）的标签将资源连接在一起。选择器旨在提供一种在Kubernetes中检索一组资源的方法。
- en: Most of the `kubectl` commands support a `-l` option that allows you to provide
    a selector to filter what it finds.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数`kubectl`命令支持`-l`选项，允许您提供选择器以过滤其查找的内容。
- en: A Selector can be equality-based to represent specific values, or set-based
    to allow filtering and selection based on multiple values. Equality selectors
    use `=` or `!=`. Set selectors use `in`, `notin`, and `exists`. You can combine
    these in a selector to create more complex filters and selection criteria by appending
    the selectors together with a `,` between them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器可以基于相等性表示特定值，也可以基于集合表示允许基于多个值进行过滤和选择。相等选择器使用`=`或`!=`。集合选择器使用`in`，`notin`和`exists`。您可以将这些组合在一个选择器中，通过在它们之间添加`,`来创建更复杂的过滤器和选择条件。
- en: 'For example, you might use a label `app` to represent a grouping of Pods that
    provide service to a specific application - in this case using the value `flask`
    and `tier` to represent the values of `front-end`, `cache`, and `back-end` tiers.
    A selector that would return all resources related to the app might be:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用标签`app`来表示提供特定应用程序服务的Pods分组-在这种情况下，使用值`flask`和`tier`来表示`front-end`，`cache`和`back-end`层的值。可能返回与该应用相关的所有资源的选择器可能是：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And the selector that just returned the frontend resources supporting this
    application:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 并且刚刚返回支持此应用程序的前端资源的选择器：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you wanted to list all the Pods that matched the select `app=flask`, you
    could do so with the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想列出所有与选择`app=flask`匹配的Pods，您可以使用以下命令：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Viewing labels
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看标签
- en: The deployments we made earlier through the `kubectl run` commands put in place
    labels and used them as selectors. As you saw earlier, you can get all the underlying
    detail for a Kubernetes resource using the `kubectl get -o json` command.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前通过`kubectl run`命令创建的部署放置了标签并将它们用作选择器。正如您之前看到的，您可以使用`kubectl get -o json`命令获取Kubernetes资源的所有底层详细信息。
- en: 'A similar command is `kubectl describe`, which is intended to provide a human-readable
    overview of a resource and its recent history:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的命令是`kubectl describe`，旨在提供资源及其最近历史的人类可读概述：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will provide output akin to the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提供类似以下的输出：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You''ll notice two labels in there, `run` and `pod-template-hash`, and a selector
    as well, `app=flask`. You can query for these exact labels using the `kubectl
    get` command line, for example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到其中有两个标签，`run`和`pod-template-hash`，以及一个选择器，`app=flask`。例如，您可以使用`kubectl
    get`命令行查询这些确切的标签：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will return the deployments matching that selector:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回匹配该选择器的部署：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And the equivalent for pods, requesting by selector
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以及对Pods的等效请求选择器
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will return pods is matching the `app=flask` selector:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回匹配`app=flask`选择器的Pods：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Within this deployment, the Pod is referenced from the deployment using the
    selector `app=flask`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个部署中，Pod是使用选择器`app=flask`从部署中引用的。
- en: '**NOTE**: You can use selectors along with `kubectl get` to request multiple
    kinds of resources at once. For example, if you tagged all the relevant resources
    with `app=flask`, then you could use a command such as `kubectl get deployment,pod
    -l app=flask` to see both deployments and pods.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：您可以与`kubectl get`一起使用选择器来一次请求多种资源。例如，如果您使用`app=flask`标记了所有相关资源，那么您可以使用诸如`kubectl
    get deployment,pod -l app=flask`的命令来查看部署和Pod。'
- en: As you can see, there are some common label structures that are used implicitly
    when you create and run resources interactively. `kubectl run`, which creates
    deployments, uses the keys `run`, `pod-template-hash`, and `app` for specific
    meanings.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，当您交互式地创建和运行资源时，通常会隐式使用一些常见的标签结构。`kubectl run`创建部署时，使用`run`、`pod-template-hash`和`app`键具有特定的含义。
- en: 'Labels can also be applied interactively to resources, after they already exist,
    using the `kubectl label` command. For example, to apply a label for enabled to
    a Pod, you might use the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 标签也可以在资源已经存在后，使用`kubectl label`命令进行交互式应用。例如，要为Pod应用一个名为enabled的标签，您可以使用以下命令：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This lets you interactively group resources together, or provide a consistent
    means of rolling out, updating, or even removing sets of resources.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这使您可以交互式地将资源分组在一起，或者提供一种一致的方式来推出、更新，甚至移除一组资源。
- en: Listing resources with labels using kubectl
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用kubectl列出带有标签的资源
- en: The `kubectl get` commands will show you basic information by default, typically
    the name and status of the resources you're looking for. You can extend the columns
    that it displays to include specific labels, which can often make it much easier
    to find what you are looking for when dealing with large numbers of different
    Pods, deployments, and ReplicaSets. `kubectl` takes an `-L` option with a comma-separated
    list of label keys to show as headers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get`命令默认会显示基本信息，通常是您要查找的资源的名称和状态。您可以扩展它显示的列，以包括特定的标签，这通常可以使在处理大量不同的Pods、部署和ReplicaSets时更容易找到您要查找的内容。`kubectl`使用`-L`选项和逗号分隔的标签键列表作为标题显示。'
- en: 'If you wanted to show the Pods along with the label keys `run` and `pod-template-hash`,
    the command would be:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想显示Pods以及标签键`run`和`pod-template-hash`，命令将是：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You then may see output like the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可能会看到以下输出：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Automatic labels and selectors
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动标签和选择器
- en: 'Kubernetes includes a number of imperative commands that automatically create
    a number of resources for you. As these commands create the resources, they also
    apply their own conventions for labels and use those labels to tie the resources
    together. A perfect example of this is the command we have used several times
    now: `kubectl run`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes包括许多命令，可以自动为您创建许多资源。当这些命令创建资源时，它们还会应用自己的约定标签，并使用这些标签将资源联系在一起。一个完美的例子就是我们现在已经使用了好几次的命令：`kubectl
    run`。
- en: 'For example, when we used:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们使用：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This created a deployment called `flask`. When the controller for the deployment
    was created, that in turn caused the creation of a ReplicaSet for that deployment,
    and the ReplicaSet controller in turn created a Pod. We saw earlier that the names
    of these resources were all related, and there are labels that relate them as
    well.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个名为`flask`的部署。当部署的控制器被创建时，这反过来导致了为该部署创建一个ReplicaSet，而ReplicaSet控制器又创建了一个Pod。我们之前看到这些资源的名称都是相关的，它们之间也有相关的标签。
- en: The deployment, `flask`, is created with the label `run=flask`, using the name
    of the `kubectl` command as the key, and the name we provided on the command line
    as a value. The deployment also has the selector `run=flask`, so that it can apply
    its controller rules to the relevant ReplicaSets and Pods that are created for
    it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 部署`flask`是使用`run=flask`标签创建的，使用`kubectl`命令的名称作为键，并且我们在命令行上提供的名称作为值。部署还具有选择器`run=flask`，以便它可以将其控制器规则应用于为其创建的相关ReplicaSets和Pods。
- en: Looking at the ReplicaSet that was created, you will see the `run=flask` label
    as well as a label that corresponds to the name that was created for the ReplicaSet
    with the key `pod-template-hash`. This ReplicaSet also includes the same selectors
    to reference the Pods that are created for it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 查看创建的ReplicaSet，您将看到`run=flask`标签以及与使用`pod-template-hash`键为ReplicaSet创建的名称相对应的标签。这个ReplicaSet还包括相同的选择器来引用为其创建的Pods。
- en: And finally, the Pod has these same selectors, which is how the ReplicaSet and
    deployment know which resources within Kubernetes to interact with when needed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Pod具有相同的选择器，这就是当需要时ReplicaSet和部署如何知道与Kubernetes中的哪些资源进行交互。
- en: 'Here is a table summarizing the labels and selectors that were automatically
    created with the preceding example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是总结了前面示例中自动创建的标签和选择器的表格：
- en: '|  | Deployment | ReplicaSet | Pod |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|  | 部署 | ReplicaSet | Pod |'
- en: '| Name | `flask` | `flask-1908233635` | `flask-1908233635-d6stj` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | `flask` | `flask-1908233635` | `flask-1908233635-d6stj` |'
- en: '| Labels | `run=flask` | `pod-template-hash=1908233635` `run=flask` | `pod-template-hash=1908233635`
    `run=flask` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 标签 | `run=flask` | `pod-template-hash=1908233635` `run=flask` | `pod-template-hash=1908233635`
    `run=flask` |'
- en: '| Selectors | `run=flask` | `pod-template-hash=1908233635,run=flask` |  |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 选择器 | `run=flask` | `pod-template-hash=1908233635,run=flask` |  |'
- en: Kubernetes resources – service
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes资源 - 服务
- en: So far, all the details we have explored have been related to a single container
    running within Kubernetes. The significant benefits of leveraging Kubernetes start
    to come into play when leveraging many containers running together. Being able
    to group together a set of Pods that all do the same thing, so that we can scale
    them and access them, is what the Kubernetes resource Service is all about.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们探讨的所有细节都与在Kubernetes中运行的单个容器相关。当一起运行多个容器时，利用Kubernetes的重大好处开始发挥作用。能够将一组做同样事情的Pods组合在一起，以便我们可以对它们进行扩展和访问，这就是Kubernetes资源服务的全部内容。
- en: A Service is the Kubernetes resource used to provide an abstraction through
    to your Pod (or Pods) that is agnostic of the specific instances that are running.
    Providing a layer between what one container (or set of containers) provides,
    such as a frontend web application, and another layer, such as a database, allows
    Kubernetes to scale them independently, update them, handle scaling issues, and
    more. A service also can contain a policy by which data should be transferred,
    so you might consider it a software load balancer within Kubernetes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是Kubernetes资源，用于提供对Pod（或Pods）的抽象，不考虑正在运行的特定实例。在一个容器（或一组容器）提供的内容与另一层，比如数据库之间提供一个层，允许Kubernetes独立扩展它们，更新它们，处理扩展问题等。服务还可以包含数据传输的策略，因此您可以将其视为Kubernetes中的软件负载均衡器。
- en: A Service is also the key abstraction used to expose Pods to each other, or
    your container outside the Kubernetes cluster. A service is the heart of how Kubernetes
    manages the coordination between sets of Pods, as well as traffic in and out of
    them.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 服务也是用于将Pod公开给彼此或将容器公开给Kubernetes集群外部的关键抽象。服务是Kubernetes管理Pod组之间以及进出它们的流量的核心。
- en: An advanced use of Service also allows you to define a service for a resource
    entirely outside the cluster. This can allow you to have a consistent means of
    using services, regardless of whether the endpoint you need to run is from within
    Kubernetes or external to the cluster.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的高级用法还允许您为集群之外的资源定义服务。这可以让您以一致的方式使用服务，无论您需要运行的端点是来自Kubernetes内部还是集群外部。
- en: 'Kubernetes includes an expose command that can create a service based on a
    resource that is already operating within the cluster. For example, we could expose
    the `flask` deployment example we used earlier with the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes包括一个`expose`命令，可以基于集群内已经运行的资源创建服务。例如，我们可以使用以下命令暴露我们之前使用的`flask`部署示例：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Most services will define a ClusterIP, and Kubernetes will handle all the dynamics
    of linking up the resources as Pods are created and destroyed that match to the
    relevant selectors. You can think of this like a simple load-balancer construct
    within Kubernetes, and it will forward traffic internally as Pods are available,
    and stop sending traffic to Pods that are failed or unavailable.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数服务将定义一个ClusterIP，Kubernetes将处理所有动态链接资源的工作，当匹配相关选择器的Pod被创建和销毁时。您可以将其视为Kubernetes内部的简单负载均衡器构造，并且它将在Pod可用时内部转发流量，并停止向失败或不可用的Pod发送流量。
- en: 'If you request the details of the service we just created with the `expose`
    command, you will see the ClusterIP listed:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`expose`命令请求我们刚刚创建的服务的详细信息，您将看到列出了ClusterIP：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Defining a service resource
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义服务资源
- en: The Service specification is fairly simple, documented for version 1.8 at [https://kubernetes.io/docs/api-reference/v1.8/#service-v1-core](https://kubernetes.io/docs/api-reference/v1.8/#service-v1-core).
    All resources within Kubernetes can be defined declaratively, which we will look
    at in more depth in [Chapter 4](a210420d-4d80-43c1-9acb-531bc6b19b75.xhtml), *Declarative
    Infrastructure*. Resources can also be defined using YAML as well as JSON. To
    look at the details of what can be included with a Service resource, we will look
    at the YAML specification for it. The core of the specification includes a name,
    a selector for the Pods that provide the service, and ports associated with the
    services.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 服务规范在版本1.8的文档中非常简单，可以在[https://kubernetes.io/docs/api-reference/v1.8/#service-v1-core](https://kubernetes.io/docs/api-reference/v1.8/#service-v1-core)找到。Kubernetes中的所有资源都可以以声明方式定义，我们将在第4章“声明式基础设施”中更深入地研究这一点。资源也可以使用YAML和JSON来定义。为了查看可以包含在服务资源中的细节，我们将查看其YAML规范。规范的核心包括名称、为提供服务的Pod选择器以及与服务相关的端口。
- en: 'For example, a simple service declaration for our `flask` Pod might be:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的`flask` Pod的简单服务声明可能是：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This defines a service that selects the Pods to front using the selector `run:
    flask`, accepting any requests on TCP port `80` and forwarding them to port `5000`
    on the selected Pods. Services support both TCP and UDP. The default is TCP, so
    we didn’t strictly need to include it. Additionally, targetPort can be a string
    referring to the name of a port and not just a port number, allowing significantly
    greater flexibility between services and the ability to move around the specific
    backend ports as development teams desire without needing as much careful coordination
    to keep the overall system operational.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '这定义了一个服务，使用选择器`run: flask`选择要前置的Pod，并在TCP端口`80`上接受任何请求，并将其转发到所选Pod的端口`5000`。服务支持TCP和UDP。默认是TCP，所以我们严格来说不需要包含它。此外，targetPort可以是一个字符串，指的是端口的名称，而不仅仅是端口号，这允许服务之间具有更大的灵活性，并且可以根据开发团队的需求移动特定的后端端口，而无需进行太多的仔细协调以保持整个系统的运行。'
- en: A service can define (and redirect) multiple ports—for example, if you wanted
    to support both port `80` and `443` for access, you can define that on the service.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可以定义（和重定向）多个端口 - 例如，如果您想要支持端口`80`和`443`的访问，可以在服务上定义它。
- en: Endpoints
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端点
- en: A service does not require a selector, and a service without a selector is how
    Kubernetes represents a service that's outside of the cluster for the other resources
    within. To enable this, you create a service without a selector as well as a new
    resource, an Endpoint, which defines the network location of the remote service.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 服务不需要选择器，没有选择器的服务是Kubernetes用来表示集群外部服务的方式。为了实现这一点，您创建一个没有选择器的服务，以及一个新的资源，即端点，它定义了远程服务的网络位置。
- en: If you are migrating services into Kubernetes and have some of those services
    external to the cluster, this provides one way to represent the remote system
    as a service internally, and if you move it into Kubernetes later, you wouldn't
    have to change how internal Pods connect or utilize that resource. This is an
    advanced feature of services, and does not also account for authorization. Another
    option is to not represent external services as service resources, and simply
    reference them in Secrets, a feature we will look at in more depth in the next
    chapter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在将服务迁移到Kubernetes，并且其中一些服务是集群外部的，这提供了一种将远程系统表示为内部服务的方式，如果以后将其移入Kubernetes，则无需更改内部Pod连接或利用该资源的方式。这是服务的高级功能，也不考虑授权。另一个选择是不将外部服务表示为服务资源，而是在Secrets中简单地引用它们，这是我们将在下一章中更深入地研究的功能。
- en: 'For example, if you had a remote TCP service running on the internet at port
    `1976` at the IP address `1.2.3.4`, you could define a Service and Endpoint to
    reference that `external-to-kubernetes` system:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您在互联网上以IP地址`1.2.3.4`的端口`1976`上运行远程TCP服务，则可以定义一个服务和端点来引用`Kubernetes外部`系统：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This would work with the following `Endpoints` definition:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将与以下`Endpoints`定义一起工作：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Service type – ExternalName
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务类型 - ExternalName
- en: There is a variant to the preceding Endpoint definition that simply provides
    a DNS reference, called an `ExternalName` service. Like the `Endpoint` oriented
    service, it doesn’t include a selector, but also does not include any port references.
    Instead, it simply defines an external DNS entry that can be used as a service
    definition.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的Endpoint定义有一个变体，它只提供DNS引用，称为`ExternalName`服务。像`Endpoint`定向服务一样，它不包括选择器，但也不包括任何端口引用。相反，它只定义了一个外部DNS条目，可以用作服务定义。
- en: 'The following example provides a Service interface inside Kubernetes to the
    external DNS entry `my.rest.api.example.com`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例为Kubernetes内部提供了一个服务接口，用于外部DNS条目`my.rest.api.example.com`：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Unlike the other services, which provide TCP and UDP (Layer 4 on the ISO network
    stack) forwarding, the `ExternalName` only provides a DNS response and does not
    manage any port forwarding or redirection.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他服务不同，其他服务提供TCP和UDP（ISO网络堆栈上的第4层）转发，`ExternalName`只提供DNS响应，不管理任何端口转发或重定向。
- en: Headless service
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无头服务
- en: 'It is possible to create a service grouping that does not allocate an IP address
    or forward traffic, if there is a reason that you want to definitively control
    what specific pods you connect and communicate with. This kind of service is called
    a headless service. You can request this setup by explicitly setting ClusterIP
    to `None` within the service definition:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有理由要明确控制您连接和通信的特定Pod，可以创建一个不分配IP地址或转发流量的服务分组。这种服务称为无头服务。您可以通过在服务定义中明确设置ClusterIP为`None`来请求此设置：
- en: 'For example, a headless service might be:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，无头服务可能是：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For these services, DNS entries will be created that point to the Pods backing
    the service, and that DNS will be automatically updated as Pods matching the selector
    come online (or disappear).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些服务，将创建指向支持服务的Pod的DNS条目，并且该DNS将在与选择器匹配的Pod上线（或消失）时自动更新。
- en: '**NOTE**: Be aware that DNS caching could end up getting in the way if using
    a headless service. You should always check DNS records before making connections.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：要注意DNS缓存可能会妨碍无头服务的使用。在建立连接之前，您应该始终检查DNS记录。'
- en: Discovering services from within your Pod
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Pod内部发现服务
- en: There are two means by which services are visible from within your Pods. The
    first is through environment variables that are added to all Pods in the same
    namespace as the service.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以从Pod内部看到服务。第一种是通过环境变量添加到与服务相同命名空间中的所有Pod。
- en: 'When you add a service (using `kubectl create`, or `kubectl apply`), the service
    is registered within Kubernetes and thereafter any Pods that are started will
    get environment variables set that reference the services. For example, if we
    created the preceding first example service, and then ran:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当您添加服务（使用`kubectl create`或`kubectl apply`）时，该服务将在Kubernetes中注册，此后启动的任何Pod都将设置引用该服务的环境变量。例如，如果我们创建了前面的第一个示例服务，然后运行：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We would see the service listed:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会看到列出的服务：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you looked inside that container, you would see environment variables associated
    with both services listed previously. Those environment variables are:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看容器内部，您会看到与先前列出的两个服务相关联的环境变量。这些环境变量是：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: (The preceding output has been re-ordered to make it easier to see the values
    and some extraneous environment variables have been removed.)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: （前面的输出已经重新排序，以便更容易看到值，并删除了一些多余的环境变量。）
- en: For each service, there are environment variables defined that provide the IP
    address, port, and protocol with a couple of name variations. Note that this IP
    address is not the IP address of any underlying Pods, but an IP address within
    the Kubernetes cluster that the service is managing as a single endpoint for accessing
    the selected Pods.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个服务，都定义了环境变量，提供了IP地址、端口和协议，还有一些名称变体。请注意，这个IP地址不是任何底层Pod的IP地址，而是Kubernetes集群中的IP地址，服务将其作为访问所选Pod的单个端点进行管理。
- en: '**WARNING**: Ordering is critical with services! If Pods exist prior to the
    Service being defined, then the environment variables for that service will not
    exist within those Pods. Restarting the Pods, or scaling them down to `0` and
    back up (forcing the containers to be killed and recreated) will resolve it, but
    in general it’s best to always define and apply your service declarations first.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：服务的顺序很重要！如果Pod在定义服务之前存在，那么该服务的环境变量将不会存在于这些Pod中。重新启动Pods，或将其缩减到`0`然后再次启动（强制容器被杀死和重新创建）将解决此问题，但通常最好始终首先定义和应用您的服务声明。'
- en: DNS for services
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务的DNS
- en: Not originally part of the core distribution, there is a cluster add-on that
    is now included for all clusters in version 1.3 (and later) that provides internal
    DNS services for Kubernetes. Minikube, for example, includes this add-on, and
    it is likely already running within your cluster.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最初并不是核心分发的一部分，现在在1.3版（以及更高版本）的所有集群中都包含了一个集群附加组件，为Kubernetes提供了内部DNS服务。例如，Minikube包括了这个附加组件，并且很可能已经在您的集群中运行。
- en: A DNS entry is created and coordinates with every service defined, so that you
    can request the DNS entry for `<service>` or  `<service>.<namespace>`, and the
    internal DNS services will provide you with a correct internal IP address.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建一个DNS条目，并与定义的每个服务协调，以便您可以请求`<service>`或`<service>.<namespace>`的DNS条目，并且内部DNS服务将为您提供正确的内部IP地址。
- en: 'For example, if we exposed the `flask` deployment with the `expose` command,
    the service would be listed in DNS from our containers. We could open an interactive
    Terminal to an existing Pod and check on that DNS:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用`expose`命令公开`flask`部署，该服务将在我们的容器中列出DNS。我们可以打开一个交互式终端到现有的Pod，并检查DNS：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The service gets an internal A record (address record in DNS) for every service
    at `<servicename>.<namespace>.svc.cluster.local`, and as a shortcut, they can
    generally be referenced within the Pods as `<servicename>.<namespace>.svc`, or
    more simply `<servicename>` for Pods that are all within the same namespace.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务在DNS中都会获得一个内部A记录（地址记录）`<servicename>.<namespace>.svc.cluster.local`，作为快捷方式，它们通常可以在Pods中被引用为`<servicename>.<namespace>.svc`，或者更简单地为所有在同一命名空间中的Pods的`<servicename>`。
- en: '**NOTE**: Tacking on a namespace should only be done when you are explicitly
    trying to refer to a service in another namespace. Leaving the namespace off makes
    your manifest inherently more reusable, since you can stamp out an entire stack
    of services with static routing configuration into arbitrary namespaces.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：只有在您明确尝试引用另一个命名空间中的服务时，才应该添加命名空间。不带命名空间会使您的清单本质上更具重用性，因为您可以将整个服务堆栈与静态路由配置放入任意命名空间。'
- en: Exposing services outside the cluster
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集群外部公开服务
- en: Everything we have discussed so far has been about representing services inside
    the Kubernetes cluster. The service concept is also how applications are exposed
    outside of a cluster.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的一切都是关于在Kubernetes集群内部表示服务。服务概念也是将应用程序暴露在集群外部的方式。
- en: The default service type is ClusterIP, and we briefly touched upon the type
    `ExternalName`, which was added to Kubernetes 1.7 to provide an external DNS reference.
    There are two other types that are very common, `NodePort` and `LoadBalancer`,
    which are specifically oriented towards exposing a service outside of the Kubernetes
    cluster.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 默认服务类型是ClusterIP，我们简要介绍了类型`ExternalName`，它是在Kubernetes 1.7中添加的，用于提供外部DNS引用。还有另外两种非常常见的类型，`NodePort`和`LoadBalancer`，它们专门用于在Kubernetes集群之外公开服务。
- en: Service type – LoadBalancer
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务类型 - LoadBalancer
- en: The `LoadBalancer` service type is not supported in all Kubernetes clusters.
    It is most commonly used with cloud providers such as Amazon, Google, or Microsoft,
    and coordinates with the cloud provider's infrastructure to set up an external
    `LoadBalancer` that will forward traffic into the service.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadBalancer`服务类型在所有Kubernetes集群中都不受支持。它最常用于云提供商，如亚马逊、谷歌或微软，并与云提供商的基础设施协调，以设置一个外部`LoadBalancer`，将流量转发到服务中。'
- en: How you define these services is specific to your cloud provider, and slightly
    different between AWS, Azure, and Google. `LoadBalancer` service definitions may
    also include recommended annotations to help define how to handle and process
    SSL traffic. More details about the specifics for each provider can be found in
    the Kubernetes documentation. The documentation on the LoadBalancer definitions
    is available at [https://kubernetes.io/docs/concepts/services-networking/service/#type-loadbalancer](https://kubernetes.io/docs/concepts/services-networking/service/#type-loadbalancer).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 定义这些服务的方式是特定于您的云提供商的，并且在AWS、Azure和Google之间略有不同。 `LoadBalancer`服务定义还可能包括推荐的注释，以帮助定义如何处理和处理SSL流量。有关每个提供程序的具体信息，可以在Kubernetes文档中找到。有关LoadBalancer定义的文档可在[https://kubernetes.io/docs/concepts/services-networking/service/#type-loadbalancer](https://kubernetes.io/docs/concepts/services-networking/service/#type-loadbalancer)上找到。
- en: Service type – NodePort
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务类型 - NodePort
- en: When you are using a Kubernetes cluster on premises, or in our case in a virtual
    machine on your development machine with Minikube, NodePort is a common service
    type used to expose your services. NodePort relies on the underlying hosts upon
    which you run Kubernetes to be accessible on your local network, and exposes the
    service definition through a high-numbered port on all of the Kubernetes cluster
    nodes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在本地使用Kubernetes集群，或者在我们的情况下，在Minikube上的虚拟机上使用开发机器时，NodePort是一种常用的服务类型，用于暴露您的服务。NodePort依赖于运行Kubernetes的基础主机在您的本地网络上可访问，并通过所有Kubernetes集群节点上的高端口公开服务定义。
- en: 'These services are exactly like the default ClusterIP services, with the exception
    that they have a type of `NodePort`. If we wanted to create such a service with
    the `expose` command, we could add a `--type=Nodeport` option to our earlier command,
    for example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务与默认的ClusterIP服务完全相同，唯一的区别是它们的类型是`NodePort`。如果我们想要使用`expose`命令创建这样一个服务，我们可以在之前的命令中添加一个`--type=Nodeport`选项，例如：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This results in a definition that would look something like the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致一个定义看起来像以下的东西：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Notice `nodePort: 31501`. This is the port that the service is exposed on.
    With this enabled, where previously we had to use port-forward or a proxy to access
    our service, we can now do so directly through the service.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '注意`nodePort: 31501`。这是服务暴露的端口。启用了这个选项后，以前我们必须使用端口转发或代理来访问我们的服务，现在可以直接通过服务来做。'
- en: Minikube service
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Minikube服务
- en: 'Minikube has a service command to make it very easy to both get and access
    this service. While you could get the IP address for your `minikube` host with
    `minikube ip` and put that together with the previous port, you could also use
    the `minikube service` command to make a combined URL in one command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube有一个服务命令，可以非常容易地获取和访问这个服务。虽然您可以使用`minikube ip`获取您的`minikube`主机的IP地址，并将其与先前的端口组合在一起，但您也可以使用`minikube
    service`命令在一个命令中创建一个组合的URL：
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This should return a value like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回一个像这样的值：
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And `minikube` has the helpful option of opening a browser window with your
    default if you use the following command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 而且`minikube`有一个有用的选项，如果你使用以下命令，可以打开一个浏览器窗口：
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If you had a service enabled, but no Pods are backing that service, then you
    would see a connection refused message.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您启用了一个服务，但没有Pod支持该服务，那么您将看到一个连接被拒绝的消息。
- en: 'You can list all the services exposed from your instance of `minikube` with
    the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令列出从您的`minikube`实例暴露的所有服务：
- en: '[PRE52]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You would then see output like the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您将看到类似以下的输出：
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Example service – Redis
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例服务 - Redis
- en: We will create an example service within Kubernetes, to show you how you can
    connect to services, and use them to architect your code. Redis ([https://redis.io](https://redis.io))
    is a super-flexible data store that you may already be familiar with, and it is
    easy to use from both Python and Node.js.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Kubernetes中创建一个示例服务，向您展示如何连接服务，并使用它们来设计您的代码。Redis（[https://redis.io](https://redis.io)）是一个超级灵活的数据存储，您可能已经很熟悉了，它很容易从Python和Node.js中使用。
- en: 'Redis is already available as a container, and it is easily found on the Docker
    Hub ([https://hub.docker.com/](https://hub.docker.com/)) as a container image.
    There are several options available, with the relevant tags listed on the Docker
    Hub web page:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Redis已经作为一个容器可用，并且很容易在Docker Hub（[https://hub.docker.com/](https://hub.docker.com/)）上找到作为一个容器镜像。有几个选项可用，相关标签在Docker
    Hub网页上列出：
- en: '![](assets/d602d47e-f217-49d7-adeb-cd47a22afea8.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d602d47e-f217-49d7-adeb-cd47a22afea8.png)'
- en: 'We can use this image with the `kubectl run` command to create a deployment,
    and then with the `kubectl expose` command to create a service to map to the Pods
    within the deployment:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`kubectl run`命令使用这个镜像创建一个部署，然后使用`kubectl expose`命令创建一个服务来映射到部署中的Pod：
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We will create a deployment named `redis`, and through that deployment download
    the image and start running it. We can see the Pod operational:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`redis`的部署，并通过该部署下载镜像并开始运行它。我们可以看到Pod正在运行：
- en: '[PRE55]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You can run an interactive shell within this Pod using the `kubectl exec` command
    and interrogate the running instance of `redis` directly:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`kubectl exec`命令在此Pod中运行交互式shell，并直接查询运行中的`redis`实例：
- en: '[PRE57]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can expose this service both inside our cluster instance and outside of
    `minikube` using `NodePort`. The default port for `redis` is `6379`, so we will
    want to make sure to include that in our service:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`NodePort`在我们的集群实例内部和`minikube`外部暴露这个服务。`redis`的默认端口是`6379`，所以我们需要确保在我们的服务中包含这个端口：
- en: '[PRE59]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If we then list the services available:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们列出可用的服务：
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We will see `redis` exposed on port `30336` using `NodePort`. The `minikube
    service` command won’t be immediately helpful here because redis isn’t an HTTP-based
    API, but using `minikube ip` we can put together a command to interact with `redis`
    through its command-line interface:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到`redis`在端口`30336`上使用`NodePort`暴露。`minikube service`命令在这里不会立即有帮助，因为redis不是基于HTTP的API，但是使用`minikube
    ip`，我们可以组合一个命令来通过其命令行界面与`redis`交互：
- en: '[PRE63]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To interact with `redis`, we can use the `redis-cli` command-line tool. If
    you don''t have the tool, you can follow along with this example by downloading
    it from [https://redis.io/download](https://redis.io/download):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要与`redis`交互，我们可以使用`redis-cli`命令行工具。如果您没有这个工具，您可以从[https://redis.io/download](https://redis.io/download)下载并按照本例进行操作：
- en: '[PRE65]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Finding the Redis service
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找Redis服务
- en: 'WIth the Redis service up and running, we can now use it from our own Pod.
    As we mentioned previously, there are two ways to locate the service: an environment
    variable with a name based on the service will be set with the host IP and port,
    or you can use a DNS entry based on the name of the service.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有了Redis服务正在运行，我们现在可以从我们自己的Pod中使用它。正如我们之前提到的，有两种方法可以定位服务：基于服务名称的环境变量将设置为主机IP和端口，或者您可以使用基于服务名称的DNS条目。
- en: The environment variables will only be set on Pods that are created after the
    service. If you still have the `flask` Pod up and running as per our previous
    example, then it will not show the environment variables. If we create a new Pod,
    even a temporary one, then it will include the service in the environment variables.
    This is because environment variables are set based on the state of Kubernetes
    at the time that the Pods are created and they are not updated during the life
    of the Pod.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量只会在服务之后创建的Pod上设置。如果您仍然像我们之前的示例那样运行`flask` Pod，那么它将不会显示环境变量。如果我们创建一个新的Pod，甚至是一个临时的Pod，那么它将包括环境变量中的服务。这是因为环境变量是根据Pod创建时的Kubernetes状态设置的，并且在Pod的生命周期内不会更新。
- en: DNS, however, is updated dynamically with the state of the cluster. While not
    instantaneous, this means that a DNS request will start returning as expected
    after the service is created. And because the DNS entries are predictable based
    on namespace and service name, they can easily be included in configuration data.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，DNS会根据集群的状态动态更新。虽然不是即时的，但这意味着在服务创建后，DNS请求将开始返回预期的结果。而且因为DNS条目是根据命名空间和服务名称可预测的，它们可以很容易地包含在配置数据中。
- en: '**NOTE:** Use DNS for service discovery, not environment variables, because
    DNS updates with your environment, but environment variables do not.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：**使用DNS进行服务发现，而不是环境变量，因为DNS会随着您的环境更新，但环境变量不会。'
- en: 'If you still have a Flask or Node.js Pod running, get the Pod name and open
    a shell within it:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍在运行Flask或Node.js Pod，请获取Pod名称并在其中打开一个shell：
- en: '[PRE67]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'And then, we can look up the Redis service we just created in the default namespace,
    which should be listed as `redis.default`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以查找我们刚刚在默认命名空间中创建的Redis服务，它应该被列为`redis.default`：
- en: '[PRE70]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Using Redis from Python
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Python中使用Redis
- en: Once we can access our Python Pod, we can invoke Python interactively and access
    Redis. Recall that when we created this Pod, we didn’t include any Python libraries
    for Redis. For this example, we can install them on the fly, but that change will
    only be relevant for this single Pod, and for the duration of this Pod’s life
    cycle. If the Pod dies, any changes (such as adding the Redis library) will be
    lost.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们可以访问我们的Python Pod，我们可以调用Python进行交互并访问Redis。请记住，当我们创建这个Pod时，我们没有包含任何用于Redis的Python库。在这个示例中，我们可以即时安装它们，但这种更改只对这个单独的Pod有效，并且只在这个Pod的生命周期内有效。如果Pod死掉，任何更改（比如添加Redis库）都将丢失。
- en: This makes a great tool for interactively and dynamically trying things out,
    but remember that you will need to incorporate any desired changes back into the
    process of creating the container as well.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的工具，可以交互式地动态尝试各种操作，但请记住，您需要将任何所需的更改合并到创建容器的过程中。
- en: 'Within the `flask` Pod, go to the code directory we set up and we can add the
    Redis library using PIP:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在`flask` Pod中，转到我们设置的代码目录，我们可以使用PIP添加Redis库：
- en: '[PRE71]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, we can interactively try Redis from the Python interpreter:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以交互式地尝试从Python中使用Redis：
- en: '[PRE72]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: To match this and enable this library for our Python code, we will want to add
    it to the `requirements.txt` file that is used by the Docker build process to
    install all the dependencies. We would then want to rebuild the container and
    push it to the registry, and then recreate the Pods so that the new image was
    used.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了匹配这一点并为我们的Python代码启用这个库，我们需要将它添加到Docker构建过程中使用的`requirements.txt`文件中，以安装所有依赖项。然后我们需要重新构建容器并将其推送到注册表，然后重新创建Pods，以便使用新的镜像。
- en: Updating the Flask deployment
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新Flask部署
- en: 'The steps to this update process are:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此更新过程的步骤如下：
- en: Update the code or dependencies in source control
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源代码控制中更新代码或依赖项
- en: Build and tag a new Docker image
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建并标记一个新的Docker镜像
- en: Push the Docker image to the container repository
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Docker镜像推送到容器存储库
- en: Update the deployment resource in Kubernetes to use this new image
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新Kubernetes中的部署资源以使用这个新镜像
- en: An example of stepping through this will highlight how you can start to roll
    out code updates, either directly or by adding additional services, to your application.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逐步进行这个示例，可以突出显示您可以开始推出代码更新，直接或通过添加其他服务到您的应用程序。
- en: 'For this example, we will not change any code immediately, we just want to
    include the Redis Python library so that it''s available. To do this, we would
    normally use PIP to install the library we want. With our Python example, we are
    installing all the required libraries with PIP through the dependency listing
    `requirements.txt`, which gets invoked during the Docker build process:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们不会立即更改任何代码，我们只是想包含Redis Python库，以便它可用。为了做到这一点，我们通常会使用PIP来安装我们想要的库。通过我们的Python示例，我们通过依赖项列表`requirements.txt`使用PIP安装所有所需的库，这在Docker构建过程中被调用：
- en: 'Update the `requirements.txt` file to include Redis:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`requirements.txt`文件以包括Redis：
- en: '[PRE73]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Not specifying a specific version is an indicator to PIP that you want it to
    locate the most recent version and install it. If you know the version of the
    `redis` library already, or want to pin it explicitly, you can add it, such as
    `==2.10.6` (akin to what was added with Flask previously).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 不指定特定版本是向 PIP 表明您希望它找到最新版本并安装它。如果您已经知道 `redis` 库的版本，或者想要明确地固定它，您可以添加它，比如 `==2.10.6`（类似于之前添加的
    Flask）。
- en: 'Rebuild the `docker` image:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新构建 `docker` 镜像：
- en: '[PRE74]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In this example, I am explicitly rebuilding without a tag, intending to add
    that one in a second step:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我明确地重新构建了一个没有标签的镜像，打算在第二步中添加标签：
- en: Tag the `build`
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给 `build` 打标签
- en: 'To tag a `build`, use a command like the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个 `build` 打标签，使用以下命令：
- en: '[PRE75]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The command I used for this example was:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个例子中使用的命令是：
- en: '[PRE76]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Once the build has the tag you'd like associated with it (in this case, we used
    `0.1.1`), you could tag this with more than one value if you wanted to reference
    the image in different ways. Once it is tagged, you need to make the images available
    to your cluster.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建的镜像有您想要关联的标签（在本例中，我们使用了 `0.1.1`），您可以为其添加多个值的标签，以便以不同的方式引用该镜像。一旦标记完成，您需要使这些镜像可用于您的集群。
- en: 'Push the container image:'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送容器镜像：
- en: '[PRE77]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Container tags do not need to be in a dot version format. In this case, I chose
    a tag that was simple and contextual, but also explicit rather than reusing `latest`,
    which could lead to some confusion over which `latest` we were running.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 容器标签不需要以点版本格式。在这种情况下，我选择了一个简单和有上下文的标签，但也是明确的，而不是重复使用 `latest`，这可能会导致对我们正在运行的
    `latest` 产生一些混淆。
- en: '**NOTE**: Use tags that are meaningful, and avoid using `latest` as a tag when
    running Kubernetes. You will save yourself an immense amount of time debugging
    exactly which version is running if you use explicit tags at the start. Even something
    as simple as a Git hash or very explicit timestamp can be used as a tag.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：使用有意义的标签，并且在运行 Kubernetes 时避免使用 `latest` 作为标签。如果一开始就使用明确的标签，您将节省大量时间来调试确切运行的版本。甚至像
    Git 哈希或非常明确的时间戳都可以用作标签。'
- en: Now, we can update the deployment to indicate that we want Kubernetes to use
    this new image we have created. Kubernetes supports several commands that will
    do what we want, such as `kubectl replace`, which will take a changed specification
    in YAML or JSON format, where you could change any of the values. There is an
    older command, `kubectl rolling-update`, but that only works with replication
    controllers.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新部署，指示 Kubernetes 使用我们创建的新镜像。Kubernetes 支持几个命令来实现我们想要的效果，比如 `kubectl
    replace`，它将采用 YAML 或 JSON 格式的更改规范，您可以更改任何值。还有一个较旧的命令 `kubectl rolling-update`，但它只适用于复制控制器。
- en: '**NOTE**: Replication controllers were an early version of ReplicaSet, and
    have been replaced by ReplicaSets and Deployments.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：复制控制器是 ReplicaSet 的早期版本，并已被 ReplicaSets 和 Deployments 所取代。'
- en: The `kubectl rolling-update` command has been replaced by a combination of `kubectl
    set` and `kubectl rollout`, which applies to deployments as well as some additional
    resources. The `kubectl set` command helps with frequent updates to some of the
    more common changes, such as changing an image in a deployment, environment variables
    defined within a deployment, and so on.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl rolling-update` 命令已被 `kubectl set` 和 `kubectl rollout` 命令的组合所取代，这适用于部署以及一些其他资源。`kubectl
    set` 命令有助于频繁更新一些常见更改，比如更改部署中的镜像、在部署中定义的环境变量等等。'
- en: The `kubectl apply` command is similar to `kubectl replace`, taking a file (or
    set of files) and dynamically applying differences to all the kubernetes resources
    referenced. We will look deeper into using the `kubectl apply` command in the
    next chapter, where we will also look into maintaining the definitions of your
    application and its structure alongside your code as declarative files, rather
    than relying on the ordering and invocation of interactive commands.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl apply`命令类似于`kubectl replace`，它接受一个文件（或一组文件）并动态应用到所有引用的kubernetes资源的差异。我们将在下一章更深入地研究使用`kubectl
    apply`命令，我们还将研究如何在声明文件中维护应用程序及其结构的定义，而不是依赖于交互式命令的顺序和调用。'
- en: As you can see, there are a lot of options to choose from; all of which boil
    down to changing the resources that are defined within Kubernetes to let it perform
    some action.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，有很多选择可以进行; 所有这些都归结为更改在Kubernetes中定义的资源，以便让它执行某些操作。
- en: Let's take the most general option and use the `kubectl replace` command, stepping
    through the process to make it clear exactly what we are changing.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择最一般的选项，并使用`kubectl replace`命令，逐步进行过程，以清楚地说明我们正在改变什么。
- en: 'First, get the deployment we are changing:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，获取我们正在更改的部署：
- en: '[PRE79]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, open the `flask_deployment.yaml` file in a text editor and find the line
    that specifies the image. The current image version can be found in the file under
    `template -> spec -> containers`, and should read something like the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在文本编辑器中打开`flask_deployment.yaml`文件，并找到指定图像的行。当前图像版本可以在文件中的`template -> spec
    -> containers`下找到，并应该读取类似以下内容：
- en: '[PRE80]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Edit the file and change this to reference our updated tag:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑文件并更改为引用我们更新的标签：
- en: '[PRE81]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'And now, we can use the `kubectl replace` command to tell Kubernetes to update
    it:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`kubectl replace`命令告诉Kubernetes更新它：
- en: '[PRE82]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This change will initiate an update of the resources associated with the deployment,
    in this case doing a rolling update or rollout. The deployment controller will
    automatically create a new ReplicaSet and Pod for the deployment, and terminate
    the old one once it is available. This process will also maintain the scale, or
    number of replicas running, during this process, and can take some time.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改将启动与部署相关的资源的更新，这种情况下进行滚动更新或部署。部署控制器将自动为部署创建新的ReplicaSet和Pod，并在可用后终止旧的。在此过程中，该过程还将维护规模或运行的副本数量，并可能需要一些时间。
- en: '**Note**: You should also be aware of the command `kubectl edit`, which allows
    you to specify a resource, such as a deployment/flask, and edit the YAML declaration
    for it directly. When you save the editor window that was opened with `kubectl
    edit`, it does the actions as the `kubectl replace` command previously.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：你还应该知道`kubectl edit`命令，它允许你指定一个资源，比如一个部署/flask，并直接编辑它的YAML声明。当你保存用`kubectl
    edit`打开的编辑器窗口时，它会执行之前`kubectl replace`命令的操作。'
- en: 'You can use `kubectl get pods` to get a view of this happening:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`kubectl get pods`来查看这个过程：
- en: '[PRE83]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Since there is only a single Pod with a single container, it will not take
    long to complete, and when it is done you will see something like the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有一个具有单个容器的Pod，完成时间不会太长，完成后你会看到类似以下的内容：
- en: '[PRE85]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You may notice that the replica-set hash has changed, as well as the Pod’s
    unique identifier. If we now access this Pod with an interactive session, we can
    see that the library has been loaded. This time, we will use Python’s interactive
    REPL directly:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到副本集哈希已经改变，以及Pod的唯一标识符。如果我们现在使用交互式会话访问此Pod，我们可以看到库已加载。这一次，我们将直接使用Python的交互式REPL：
- en: '[PRE87]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Deployments and rollouts
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和滚动
- en: Changing the image within a deployment initiates a rollout. A deployment rollout
    is an asynchronous process that takes time to complete, and is controlled by values
    defined within the deployment. If you look at the resource file that we dumped
    into YAML and updated, you will see the defaults that were created for the deployment
    when we made it with the `kubectl run` command.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 更改部署中的镜像会启动一个部署。部署的滚动更新是一个异步过程，需要时间来完成，并由部署中定义的值控制。如果您查看我们转储到YAML并更新的资源文件，您将看到我们使用`kubectl
    run`命令创建部署时创建的默认值。
- en: 'Under `spec -> strategy`, you will see the default specification of how it
    will handle an update:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在`spec -> strategy`下，您将看到如何处理更新的默认规范：
- en: '[PRE89]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'As of Kubernetes 1.8, there are two strategies available: `Recreate` and `RollingUpdate`.
    `RollingUpdate` is the default, and is intended for the primary use case of maintaining
    service availability while doing code updates. Recreate operates differently:
    killing all existing pods before creating new pods with updated versions, which
    may result in a short outage.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 截至Kubernetes 1.8，有两种可用的策略：`Recreate`和`RollingUpdate`。`RollingUpdate`是默认值，旨在用于在进行代码更新时保持服务可用性的主要用例。Recreate的操作方式不同：在创建新的具有更新版本的pod之前，杀死所有现有的pod，这可能会导致短暂的中断。
- en: 'The `RollingUpdate` is controlled by two values: `maxUnavailable` and `maxSurge`,
    which serve to provide some controls so that you can have a minimum number of
    pods available to handle your service while the update rolls out. You can find
    details on these two controlling options in the documentation at [https://kubernetes.io/docs/concepts/workloads/controllers/deployment/](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/),
    along with some additional options that influence the rollout process.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`RollingUpdate`由两个值控制：`maxUnavailable`和`maxSurge`，它们提供了一些控制，以便在更新进行时您可以拥有最少数量的可用pod来处理您的服务。您可以在[https://kubernetes.io/docs/concepts/workloads/controllers/deployment/](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)的文档中找到有关这两个控制选项的详细信息，以及一些其他影响部署过程的选项。'
- en: Rollout history
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署历史
- en: Kubernetes also maintains a history (the length of which can also be controlled)
    for rollouts. You can see the state of a rollout, as well as its history, through
    the `kubectl rollout` command.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes还维护着一个历史记录（其长度也可以受到控制）用于部署。您可以通过`kubectl rollout`命令查看部署的状态以及其历史记录。
- en: 'For example, to see the status of the rollout that we just did:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要查看我们刚刚执行的部署状态：
- en: '[PRE90]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'And you can view the history of the changes to the deployment with the following:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令查看部署更改的历史记录：
- en: '[PRE92]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '`change-cause` is tracked as an annotation on the deployment resource, which
    (as of Kubernetes 1.8) does not exist, since we created the deployment with the
    default `kubectl run` command. There is a `--record=true` option, which can be
    used with `kubectl run`, `kubectl set`, and several other commands that explicitly
    set these annotations. We will discuss annotations, more detail in the next chapter.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`change-cause`作为部署资源的注释进行跟踪，（截至Kubernetes 1.8）由于我们使用默认的`kubectl run`命令创建了部署，因此它不存在。有一个`--record=true`选项，可以与`kubectl
    run`、`kubectl set`和其他一些明确设置这些注释的命令一起使用。我们将在下一章节中详细讨论注释。'
- en: 'We can go ahead and create an annotation to match what we just did with the
    following command:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续创建一个注释，以匹配我们刚刚执行的操作，使用以下命令：
- en: '[PRE94]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now, if we look at the history, you will see the following displayed:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们查看历史记录，您将看到以下内容显示：
- en: '[PRE96]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You can get more detailed information using the `--revision` option with the
    `history` command. For example:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`history`命令的`--revision`选项获取更详细的信息。例如：
- en: '[PRE98]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This would return something like the following:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回类似以下内容：
- en: '[PRE99]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: You can see the annotation that we just created as well as the container image
    version that we changed.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们刚刚创建的注释，以及我们更改的容器镜像版本。
- en: Rollout undo
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回滚
- en: 'The deployment resource includes the capability to revert back to a previous
    version. The simplest form of this is the `kubectl rollout undo` command. If you
    wanted to revert back to the Pods running at the previous image, you could use
    the following command:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 部署资源包括回滚到先前版本的能力。最简单的形式是`kubectl rollout undo`命令。如果您想要回滚到先前镜像运行的Pods，您可以使用以下命令：
- en: '[PRE100]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This would reverse the process, doing the same steps except moving back to the
    earlier deployment resource configuration.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这将逆转该过程，执行相同的步骤，只是回到先前的部署资源配置。
- en: 'If you have multiple versions, you can roll back to a specific version with
    the `--revision` option. You can also watch the process updates with the `rollout
    status` command and the `-w` option. For example, if you just invoked the `undo`
    command, you could watch the progress with the following command:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个版本，您可以使用`--revision`选项回滚到特定版本。您还可以使用`rollout status`命令和`-w`选项观察过程更新。例如，如果您刚刚调用了`undo`命令，您可以使用以下命令观察进度：
- en: '[PRE101]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The deployment history keeps rolling version numbers forward, even when you
    undo or roll back to a previous version. If you are familiar with using Git for
    source control, it is very similar to using the `git revert` command. If you looked
    at the history after an undo, you might see the following:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您撤消或回滚到先前版本，部署历史记录仍会不断向前滚动版本号。如果您熟悉使用Git进行源代码控制，这与使用`git revert`命令非常相似。如果您在撤消后查看历史记录，您可能会看到以下内容：
- en: '[PRE103]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Updating with the kubectl set command
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用kubectl set命令进行更新
- en: 'Updating the container image is a very common task. You may also update that
    value directly with the `kubectl set` command, as we mentioned previously. If
    the deployment resource has the `change-cause` annotation added, then using the
    `kubectl set` command will update the annotation as you make changes. For example:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 更新容器镜像是一个非常常见的任务。您也可以直接使用`kubectl set`命令更新该值，就像我们之前提到的那样。如果部署资源已添加`change-cause`注释，那么使用`kubectl
    set`命令将在您进行更改时更新该注释。例如：
- en: '[PRE105]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'If you now look at the history, it will include the changes made with the `set`
    command:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在查看历史记录，它将包括使用`set`命令进行的更改：
- en: '[PRE109]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: As you create services and deployments with your code, you may find it convenient
    to quickly create deployments and update them with these commands.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用代码创建服务和部署时，您可能会发现使用这些命令快速创建部署并更新它们非常方便。
- en: '**Note**: Another reason to avoid using the `latest` tag when referencing container
    images: updates to deployments require a change to the deployment specification.
    If you were just updating the image behind the deployment, the deployment would
    never know when to update it.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：避免在引用容器镜像时使用`latest`标签的另一个原因：更新部署需要更改部署规范。如果您只是在部署后面更新镜像，部署将永远不知道何时更新它。'
- en: The rollouts that we have been describing so far are all idempotent and expect
    that you can change the containers seamlessly forward or back. This expects that
    the container images you are creating and deploying are stateless and don’t have
    to manage existing persistent data. That will not always be the case, and Kubernetes
    is actively adding support for handling these more complex needs with a feature
    called StatefulSets, which we will discuss further in a future chapter.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们描述的升级都是幂等的，并且期望您可以无缝地向前或向后更改容器。这期望您创建和部署的容器镜像是无状态的，并且不必管理现有的持久数据。这并不总是如此，Kubernetes正在积极添加对处理这些更复杂需求的支持，这个功能称为StatefulSets，我们将在未来的章节中进一步讨论。
- en: Summary
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started with reviewing some practical notes about how to
    develop your code to run within a container. We reviewed options for getting logging
    from your program, and then some techniques for accessing the Pods when your code
    is running. We then reviewed the Kubernetes concepts of labels and selectors,
    showing how they are used on the commands we have used so far, and then looked
    at the Kubernetes service concept to expose sets of Pods (such as in a deployment)
    to each other, or external to a Kubernetes cluster. Finally, we ended the chapter
    by looking at deployment rollouts, and how you can roll out changes as well as
    see the history of those changes.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先回顾了一些关于如何开发代码以在容器中运行的实用注意事项。我们讨论了从程序中获取日志的选项，以及在代码运行时访问Pods的一些技术。然后，我们回顾了Kubernetes的标签和选择器的概念，展示了它们在我们迄今为止使用的命令中的用法，然后看了一下Kubernetes服务概念，以公开一组Pods（例如在部署中）给彼此，或者对Kubernetes集群外部。最后，我们结束了本章，看了一下部署的推出，以及您如何推出更改，以及查看这些更改的历史记录。
