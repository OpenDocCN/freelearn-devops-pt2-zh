- en: 9\. Storing and Reading Data on Disk
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 在磁盘上存储和读取数据
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces the concept of using Volumes to store or read data from
    the containers running inside pods. By the end of this chapter, you will be able
    to create Volumes to temporarily store data in a pod independent of a container's
    life cycle, as well as share the data among different containers inside the same
    pod. You will also learn how to use **PersistentVolumes** (**PVs**) to store data
    on your cluster independent of the pod life cycle. We will also cover how to create
    **PersistentVolumeClaims** (**PVCs**) to dynamically provision volumes and use
    them inside a pod.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了使用卷来存储或读取容器内部运行的数据的概念。在本章结束时，您将能够创建卷来临时存储数据在一个 pod 中，独立于容器的生命周期，并在同一个 pod
    内的不同容器之间共享数据。您还将学习如何使用**持久卷**（**PVs**）来在集群中独立于 pod 生命周期存储数据。我们还将介绍如何创建**持久卷声明**（**PVCs**）来动态配置卷并在
    pod 内使用它们。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In previous chapters, we created Deployments to create multiple replicas of
    our application and exposed our application using Services. However, we have not
    yet properly explored how Kubernetes facilitates applications to store and read
    data, which is the subject of this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们创建了部署来创建应用程序的多个副本，并使用服务公开了我们的应用程序。然而，我们还没有完全探讨 Kubernetes 如何促进应用程序存储和读取数据，这是本章的主题。
- en: In practice, most applications interact with data in some way. It's possible
    that we may have an application that needs to read data from a file. Similarly,
    our application may need to write some data locally in order for other parts of
    the application, or different applications, to read it. For example, if we have
    a container running our main application that produces some logs locally, we would
    want to have a sidecar container (which is a second container running inside the
    pod along with the main application container) that can run inside the same pod
    to read and process the local logs produced by the main application. However,
    to enable this, we need to find a way to share the storage among different containers
    in the same pod.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，大多数应用程序以某种方式与数据交互。可能我们有一个需要从文件中读取数据的应用程序。同样，我们的应用程序可能需要在本地写入一些数据，以便应用程序的其他部分或不同的应用程序来读取。例如，如果我们有一个运行主应用程序的容器，它在本地产生一些日志，我们希望有一个旁路容器（这是一个与主应用程序容器一起在
    pod 中运行的第二个容器），可以在同一个 pod 中运行以读取和处理主应用程序产生的本地日志。然而，为了实现这一点，我们需要找到一种在同一个 pod 中的不同容器之间共享存储的方法。
- en: Let's say we are training a machine learning model in a pod. During the intermediate
    stages of the model training, we would need to store some data locally on a disk.
    Similarly, the end result – the trained model – will need to be stored on a disk,
    such that it can be retrieved later even once the pod terminates. For this use
    case, we need some way of allocating some storage to the pod such that the data
    written in that storage exists even beyond the life cycle of the pod.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在一个 pod 中训练一个机器学习模型。在模型训练的中间阶段，我们需要在磁盘上本地存储一些数据。同样，最终结果 - 训练好的模型 - 也需要被存储在磁盘上，以便即使
    pod 终止后也可以稍后检索。对于这种用例，我们需要一种方式来为 pod 分配一些存储空间，以便在 pod 的生命周期之外存在写入该存储的数据。
- en: Similarly, we may have some data that needs to be written or read by multiple
    replicas of the same application. This data should also persist when some of such
    pod replicas crash and/or restart. For example, if we have an e-commerce website,
    we may want to store the user data, as well as inventory records, in a database.
    This data will need to be persisted across pod restarts as well as Deployment
    updates or rollbacks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可能有一些数据需要被同一应用程序的多个副本写入或读取。当这些pod副本中的一些崩溃和/或重新启动时，这些数据也应该持久存在。例如，如果我们有一个电子商务网站，我们可能希望将用户数据以及库存记录存储在数据库中。这些数据需要在pod重新启动以及部署更新或回滚时持久存在。
- en: To serve these purposes, Kubernetes provides an abstraction called Volume. A
    **PersistentVolume** (**PV**) is the most common type of Volume that you will
    encounter. In this chapter, we will cover this, as well as many other types of
    Volumes. We will learn how to use them and provision them on-demand.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些目的，Kubernetes提供了一个称为卷的抽象。**持久卷**（**PV**）是您将遇到的最常见类型的卷。在本章中，我们将涵盖这一点，以及许多其他类型的卷。我们将学习如何使用它们，并按需进行配置。
- en: Volumes
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卷
- en: Let's say we have a pod that stores some data locally on a disk. Now, if the
    container that's storing the data crashes and is restarted, the data will be lost.
    The new container will start with an empty disk space allocated. Thus, we cannot
    rely on containers themselves even for the temporary storage of data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个pod在本地磁盘上存储一些数据。现在，如果存储数据的容器崩溃并重新启动，数据将丢失。新容器将以分配的空白磁盘空间开始。因此，我们甚至不能依赖容器本身来临时存储数据。
- en: We may also have a case where one container in a pod stores some data that needs
    to be accessed by other containers in the same pod as well.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还有这样一种情况，即pod中的一个容器存储了一些需要被同一pod中的其他容器访问的数据。
- en: 'The Kubernetes Volume abstraction solves both of these problems. Here''s a
    diagram showing Volumes and their interaction with physical storage and the application:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes卷抽象解决了这两个问题。下面是一个显示卷及其与物理存储和应用程序交互的图表：
- en: '![Figure 9.1: Volume as a storage abstraction for applications'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1：卷作为应用程序的存储抽象'
- en: '](image/B14870_09_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_09_01.jpg)'
- en: 'Figure 9.1: Volume as a storage abstraction for applications'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：卷作为应用程序的存储抽象
- en: As you can see from this diagram, a Volume is exposed to the applications as
    an abstraction, which eventually stores the data on any type of physical storage
    that you may be using.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个图表中可以看出，卷被暴露给应用程序作为一个抽象，最终将数据存储在您可能正在使用的任何类型的物理存储上。
- en: The lifetime of a Kubernetes Volume is the same as that of the pod that uses
    it. In other words, even if the containers within a pod restart, the same Volume
    will be used by the new container as well. Hence, the data isn't lost across container
    restarts. However, once a pod terminates or is restarted, the Volume ceases to
    exist, and the data is lost. To solve this problem, we can use PVs, which we will
    cover later in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes卷的生命周期与使用它的pod的生命周期相同。换句话说，即使pod中的容器重新启动，新容器也将使用相同的卷。因此，数据在容器重新启动时不会丢失。然而，一旦一个pod终止或重新启动，卷就会停止存在，数据也会丢失。为了解决这个问题，我们可以使用PVs，我们将在本章后面介绍。
- en: How to Use Volumes
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用卷
- en: 'A Volume is defined in the pod spec. Here''s an example of a pod configuration
    with Volumes:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 卷在pod规范中定义。以下是一个带有卷的pod配置的示例：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see in the preceding configuration, to define a Volume, a pod configuration
    needs to set two fields:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的配置中所看到的，要定义一个卷，pod配置需要设置两个字段：
- en: The `.spec.volumes` field defines what Volumes this pod is planning to use.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.spec.volumes`字段定义了这个pod计划使用的卷。'
- en: The `.spec.containers.volumeMounts` defines where to mount those Volumes in
    individual containers. This will be defined separately for all the containers.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.spec.containers.volumeMounts`定义了在各个容器中挂载这些卷的位置。这将为所有容器单独定义。'
- en: Defining Volumes
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义卷
- en: 'In the preceding example, the `.spec.volumes` field has two fields that define
    the configuration of a Volume:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`.spec.volumes`字段有两个字段，定义了卷的配置：
- en: '`name`: This is the name of the Volume by which it will be referred to in the
    containers'' `volumeMounts` fields when it will be mounted. It has to be a valid
    DNS name. The name of the Volume must be unique within a single pod.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是卷的名称，当卷被挂载时，它将在容器的`volumeMounts`字段中被引用。它必须是有效的DNS名称。卷的名称必须在单个pod内是唯一的。'
- en: '`emptyDir`: This varies based on the type of the Volume being used (which,
    in the case of the preceding example, is `emptyDir`). This defines the actual
    configuration of the Volume. We will go through the types of Volumes in the next
    section with some examples.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emptyDir`：这取决于所使用的卷的类型（在前面的示例中是`emptyDir`）。这定义了卷的实际配置。我们将在下一节中通过一些示例来介绍卷的类型。'
- en: Mounting Volumes
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载卷
- en: 'Each container needs to specify `volumeMounts` separately to mount the volume.
    In the preceding example, you can see that the `.spec.containers[*].volumeMounts`
    configuration has the following fields:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器都需要单独指定`volumeMounts`来挂载卷。在前面的示例中，您可以看到`.spec.containers[*].volumeMounts`配置具有以下字段：
- en: '`name`: This is the name of the Volume that needs to be mounted for this container.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是需要为此容器挂载的卷的名称。'
- en: '`mountPath`: This is the path inside the container where the Volume should
    be mounted. Each container can mount the same Volume on different paths.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mountPath`：这是容器内应该挂载卷的路径。每个容器可以在不同的路径上挂载相同的卷。'
- en: 'Other than these, there are two other notable fields that we can set:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些之外，我们还可以设置两个其他值得注意的字段：
- en: '`subPath`: This is an optional field that contains the path from the Volume
    that needs to be mounted on the container. By default, the volume is mounted from
    its root directory. This field can be used to mount only a sub-directory in the
    volume and not the entire volume. For example, if you''re using the same Volume
    for multiple users, it''s useful to mount a sub-path on the containers, rather
    than the root directory of the Volume.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subPath`：这是一个可选字段，包含需要在容器上挂载的卷的路径。默认情况下，卷是从其根目录挂载的。此字段可用于仅挂载卷中的子目录，而不是整个卷。例如，如果您将相同的卷用于多个用户，将子路径挂载到容器上比在卷的根目录上挂载更有用。'
- en: '`readonly`: This is an optional flag that determines whether the mounted volume
    will be read-only or not. By default, the volumes are mounted with read-write
    access.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readonly`：这是一个可选标志，用于确定挂载的卷是否为只读。默认情况下，卷是以读写方式挂载的。'
- en: Types of Volumes
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卷的类型
- en: As mentioned earlier, Kubernetes supports several types of Volumes and the availability
    of most of them depends on the cloud provider that you use. AWS, Azure, and Google
    Cloud all have different types of Volumes supported.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，Kubernetes支持多种类型的卷，大多数类型的卷的可用性取决于您使用的云提供商。AWS、Azure和Google Cloud都支持不同类型的卷。
- en: Let's take a look at some common types of Volumes in detail.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看一些常见类型的卷。
- en: emptyDir
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: emptyDir
- en: An `emptyDir` Volume refers to an empty directory that's created when a pod
    is assigned to a node. It only exists as long as the pod does. All the containers
    running inside the pod have the ability to write and read files from this directory.
    The same `emptyDir` Volume can be mounted on different paths for different containers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`emptyDir`卷是指在分配给节点的pod上创建的空目录。它只存在于pod存在的时间。在pod内运行的所有容器都可以从该目录中写入和读取文件。相同的`emptyDir`卷可以挂载到不同的路径以供不同的容器使用。'
- en: 'Here''s an example of pod configuration using the `emptyDir` Volume:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`emptyDir`卷的pod配置的示例：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, `{}` indicates that the `emptyDir` Volume will be defined in
    the default manner. By default, the `emptyDir` Volumes are stored on the disk
    or SSD, depending on the environment. We can change it to use RAM instead by setting
    the `.emptyDir.medium` field to `Memory`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`{}`表示`emptyDir`卷将以默认方式定义。默认情况下，`emptyDir`卷存储在磁盘或SSD上，具体取决于环境。我们可以通过将`.emptyDir.medium`字段设置为`Memory`来将其更改为使用RAM。
- en: 'Thus, we can modify the `volumes` section of the preceding pod configuration
    to use the `emptyDir` Volume backed by memory, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以修改前面的pod配置的`volumes`部分，使用内存支持的`emptyDir`卷，如下所示：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This informs Kubernetes to use a RAM-based filesystem (tmpfs) to store the Volume.
    Even though tmpfs is very fast compared to data on a disk, there are a couple
    of downsides to using in-memory Volume. First, the tmpfs storage is cleared on
    the system reboot of the node on which the pod is running. Second, the data stored
    in a memory-based Volume counts against the memory limits of the container. Hence,
    we need to be careful while using memory-based Volumes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这通知Kubernetes使用基于RAM的文件系统（tmpfs）来存储卷。尽管与磁盘上的数据相比，tmpfs非常快，但使用内存卷有一些缺点。首先，tmpfs存储在节点重启时会被清除。其次，存储在基于内存的卷中的数据会计入容器的内存限制。因此，在使用基于内存的卷时需要小心。
- en: We can also specify the size limit of the storage to be used in the `emptyDir`
    Volume by setting the `.volumes.emptyDir.sizeLimit` field. This size limit applies
    to both disk-based and memory-based `emptyDir` Volumes. In the case of memory-based
    Volumes, the maximum usage allowed will be either the `sizeLimit` field value
    or the sum of memory limits on all containers in the pod – whichever is lower.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过设置`.volumes.emptyDir.sizeLimit`字段来指定要在`emptyDir`卷中使用的存储的大小限制。这个大小限制适用于基于磁盘和基于内存的`emptyDir`卷。对于基于内存的卷，允许的最大使用量将是`sizeLimit`字段值或pod中所有容器的内存限制之和中较低的那个。
- en: '**Use Cases**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**用例**'
- en: 'Some of the use cases for `emptyDir` Volumes are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`emptyDir`卷的一些用例如下：'
- en: Temporary scratch space for computations requiring a lot of space, such as on-disk
    merge sort
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要大量空间进行计算的临时临时空间，例如磁盘上的归并排序
- en: Storage required for storing checkpoints for a long computation, such as training
    machine learning models where the progress needs to be saved to recover from crashes
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储长时间计算的检查点所需的存储空间，例如训练机器学习模型，其中需要保存进度以便从崩溃中恢复
- en: hostPath
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: hostPath
- en: A `hostPath` Volume is used to mount a file or a directory from the host node's
    filesystem to a pod.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`hostPath`卷用于将主机节点文件系统中的文件或目录挂载到pod中。'
- en: 'Here''s an example of pod configuration using the `hostPath` Volume:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`hostPath`卷的pod配置的示例：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, the `/home/user/data` directory from the host node will be
    mounted on the `/data` path on the container. Let''s look at the two fields under
    `hostPath`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，主机节点上的`/home/user/data`目录将挂载到容器上的`/data`路径上。让我们看一下`hostPath`下的两个字段：
- en: '`path`: This is the path of the directory or the file that will be mounted
    on the containers mounting this Volume. It can also be a symlink (symbolic link)
    to a directory or a file, the address of a UNIX socket, or a character or block
    device, depending on the `type` field.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：这是将要挂载在挂载此卷的容器上的目录或文件的路径。它也可以是一个符号链接指向目录或文件，一个UNIX套接字的地址，或者一个字符或块设备，取决于`type`字段。'
- en: '`type`: This is an optional field that allows us to specify the type of the
    Volume. If this field is specified, certain checks will be performed before mounting
    the `hostPath` Volume.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：这是一个可选字段，允许我们指定卷的类型。如果指定了此字段，将在挂载`hostPath`卷之前执行某些检查。'
- en: 'The `type` field supports the following values:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`字段支持以下值：'
- en: '`""` (an empty string): This is the default value implying that no checks will
    be performed before mounting the `hostPath` Volume. If the path specified doesn''t
    exist on the node, the pod will still be created without verifying the existence
    of the path. Hence, the pod will keep crashing indefinitely because of this error.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`""`（空字符串）：这是默认值，意味着在挂载`hostPath`卷之前不会执行任何检查。如果指定的路径在节点上不存在，Pod仍将被创建，而不会验证路径的存在。因此，Pod将因此错误而不断崩溃。'
- en: '`DirectoryOrCreate`: This implies that the directory path specified may or
    may not already exist on the host node. If it doesn''t exist, an empty directory
    is created.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DirectoryOrCreate`：这意味着指定的目录路径在主机节点上可能已经存在，也可能不存在。如果不存在，将创建一个空目录。'
- en: '`Directory`: This implies that a directory must exist on the host node at the
    path specified. If the directory doesn''t exist at the path specified, there will
    be a `FailedMount` error while creating the pod, indicating that the `hostPath`
    type check has failed.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Directory`：这意味着主机节点上必须存在指定路径的目录。如果指定路径上的目录不存在，创建Pod时将出现`FailedMount`错误，表示`hostPath`类型检查失败。'
- en: '`FileOrCreate`: This implies that the file path specified may or may not already
    exist on the host node. If it doesn''t exist, an empty file is created.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileOrCreate`：这意味着指定的文件路径在主机节点上可能已经存在，也可能不存在。如果不存在，将创建一个空文件。'
- en: '`File`: This implies that a file must exist on the host node at the path specified.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File`：这意味着主机节点上必须存在指定路径的文件。'
- en: '`Socket`: This implies that a UNIX socket must exist at the path specified.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Socket`：这意味着必须在指定的路径上存在一个UNIX套接字。'
- en: '`CharDevice`: This implies that a character device must exist at the path specified.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CharDevice`：这意味着在指定路径上必须存在一个字符设备。'
- en: '`BlockDevice`: This implies that a block device must exist at the path specified.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlockDevice`：这意味着在指定路径上必须存在一个块设备。'
- en: '**Use Cases**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**用例**'
- en: 'In most cases, your application won''t need a `hostPath` Volume. However, there
    are some niche use cases where the `hostPath` Volume may be particularly useful.
    Some of these use cases for the `hostPath` Volume are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您的应用程序不需要`hostPath`卷。但是，有一些利基用例可能特别有用。`hostPath`卷的一些用例如下：
- en: Allowing pods to be created only if a particular host path exists on the host
    node before running the pod. For example, a pod may require some Secrets or credentials
    to be present in a file on the host before it can run.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在运行Pod之前主机节点上存在特定主机路径时才允许创建Pod。例如，一个Pod可能需要一些秘密或凭据存在于主机上的文件中才能运行。
- en: Running a container that needs access to Docker internals. We can do that by
    setting `hostPath` to `/var/lib/docker`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行需要访问Docker内部的容器。我们可以通过将`hostPath`设置为`/var/lib/docker`来实现。
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In addition to the two types of Volumes covered here, Kubernetes supports many
    more, some of which are specific to certain cloud platforms. You can find more
    information about them at [https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes](https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这里介绍的两种类型的Volume外，Kubernetes还支持许多其他类型，其中一些是特定于某些云平台的。您可以在[https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes](https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes)找到更多信息。
- en: In the previous sections, we learned about Volumes and how to use their different
    types. In the following exercises, we will put these concepts into action and
    use Volumes with pods.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了有关Volumes以及如何使用它们的不同类型的知识。在接下来的练习中，我们将把这些概念付诸实践，并在pod中使用Volumes。
- en: 'Exercise 9.01: Creating a Pod with an emptyDir Volume'
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.01：创建一个带有emptyDir Volume的Pod
- en: 'In this exercise, we will create a basic pod with an `emptyDir` Volume. We
    will also simulate data being written manually, and then make sure that the data
    stored in the Volume is kept across container restarts:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个带有`emptyDir` Volume的基本pod。我们还将模拟手动写入数据，然后确保Volume中存储的数据在容器重新启动时保持不变：
- en: 'Create a file called `pod-with-emptydir-volume.yaml` with the following content:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pod-with-emptydir-volume.yaml`的文件，内容如下：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this pod configuration, we have used an `emptyDir` Volume mounted at the
    `/mounted-data` directory.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个pod配置中，我们使用了一个挂载在`/mounted-data`目录下的`emptyDir` Volume。
- en: 'Run the following command to create the pod using the preceding configuration:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以使用前面的配置创建pod：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see the following response:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the following command to confirm that the pod was created and is ready:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以确认pod已创建并准备就绪：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see the following response:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the following command to describe the pod so that we can verify that the
    correct Volume was mounted on this pod:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以描述pod，以便我们可以验证该pod上挂载了正确的Volume：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will give a long output. Look for the following section in the terminal
    output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生很长的输出。在终端输出中查找以下部分：
- en: '![Figure 9.2: Describing the pod with a mounted emptyDir volume'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2：描述具有挂载的emptyDir卷的pod'
- en: '](image/B14870_09_02.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_09_02.jpg)'
- en: 'Figure 9.2: Describing the pod with a mounted emptyDir volume'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：描述具有挂载的emptyDir卷的pod
- en: As highlighted in the preceding image, the `emptyDir` Volume named `data-volume`
    was created and it was mounted on `nginx-container` at the `/mounted-data` path.
    We can see that the Volume has been mounted in `rw` mode, which stands for read-write.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的图像所示，名为`data-volume`的`emptyDir` Volume已创建，并且它被挂载在`nginx-container`上的`/mounted-data`路径上。我们可以看到Volume已以`rw`模式挂载，表示读写。
- en: Now that we have verified that the pod was created with the correct Volume configured,
    we will manually write some data to this path. In practice, this writing will
    be done by your application code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了pod是使用正确的Volume配置创建的，我们将手动向该路径写入一些数据。在实践中，这种写入将由您的应用程序代码完成。
- en: 'Now, we will use the `kubectl exec` command to run the Bash shell inside the
    pod:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用`kubectl exec`命令在pod内部运行Bash shell：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should see the following on your terminal screen:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端屏幕上看到以下内容：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will now allow you to run commands via an SSH connection on the Bash shell
    running in the `nginx-container`. Note that we are running as a root user.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这将允许您通过SSH连接在运行`nginx-container`中的Bash shell上运行命令。请注意，我们是以root用户身份运行的。
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you had a sidecar container running in the pod (or any number of multiple
    containers in a pod), then you can control where the `kubectl exec` command will
    execute by adding the `-c` parameter to specify the container, as you will see
    in the next exercise.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果pod中运行了一个sidecar容器（或者一个pod中有多个容器），那么你可以通过添加`-c`参数来控制`kubectl exec`命令的执行位置，以指定容器，就像你将在下一个练习中看到的那样。
- en: 'Run the following command to check the content of the root directory of the
    pod:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来检查pod的根目录的内容：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should see an output similar to this one:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似于这样的输出：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that there's a directory called `mounted-data`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到有一个名为`mounted-data`的目录。
- en: 'Run the following commands to go to the `mounted-data` directory and check
    its content:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令进入`mounted-data`目录并检查其内容：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should see a blank output, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个空白的输出，如下所示：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This output indicates that the `mounted-data` directory is empty as expected
    because we don't have any code running inside the pod that would write to this
    path.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出表明`mounted-data`目录是空的，这是预期的，因为我们没有任何在pod内运行的代码会写入这个路径。
- en: 'Run the following command to create a simple text file inside the `mounted-data`
    directory:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令在`mounted-data`目录内创建一个简单的文本文件：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, run the `ls` command again to check the content of the directory:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次运行`ls`命令来检查目录的内容：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see the following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Thus, we have created a new file with some content in the mounted volume directory.
    Now, our aim will be to verify that this data will still exist if the container
    is restarted.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经在挂载卷目录中创建了一个新文件并添加了一些内容。现在，我们的目标是验证如果容器重新启动，这些数据是否仍然存在。
- en: 'In order to restart the container, we will kill the `nginx` process, which
    will trigger a restart. Run the following commands to install the procps package
    so that we can use the `ps` command to find out the process ID (PID) of the process
    that we want to kill. First, update the package lists:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了重新启动容器，我们将杀死`nginx`进程，这将触发重新启动。运行以下命令安装procps软件包，以便我们可以使用`ps`命令找到我们想要杀死的进程的进程ID（PID）。首先，更新软件包列表：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should see an output similar to the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似于以下的输出：
- en: '![Figure 9.3: An apt-get update'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3：apt-get更新'
- en: '](image/B14870_09_03.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_09_03.jpg)'
- en: 'Figure 9.3: An apt-get update'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：apt-get更新
- en: Our package lists are up to date and we are now ready to install procps.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的软件包列表已经更新，现在我们准备安装procps。
- en: 'Use the following command to install procps:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装procps：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Enter *Y* when prompted to confirm the installation, and then the installation
    will proceed with an output similar to the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示确认安装时输入*Y*，然后安装将继续并输出类似于以下内容：
- en: '![Figure 9.4: Using apt-get to install procps'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4：使用apt-get安装procps'
- en: '](image/B14870_09_04.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_09_04.jpg)'
- en: 'Figure 9.4: Using apt-get to install procps'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：使用apt-get安装procps
- en: 'Now, run the following command to check the list of processes running on the
    container:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行以下命令来检查容器上运行的进程列表：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should see the following output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![Figure 9.5: A list of the running processes'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5：运行中的进程列表'
- en: '](image/B14870_09_05.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_09_05.jpg)'
- en: 'Figure 9.5: A list of the running processes'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：运行中的进程列表
- en: In the output, we can see that among several other processes, the `nginx` master
    process is running with a `PID` of `1`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到除了其他几个进程外，`nginx`主进程以`PID`为`1`的形式运行。
- en: 'Run the following command to kill the `nginx` master process:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来杀死`nginx`主进程：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should see the following response:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '![Figure 9.6: Killing the container'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6：杀死容器'
- en: '](image/B14870_09_06.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_09_06.jpg)'
- en: 'Figure 9.6: Killing the container'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：杀死容器
- en: The output shows that the terminal exited the Bash session on the pod. This
    is because the container was killed. The `137` exit code indicates that the session
    was killed by manual intervention.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示终端退出了pod上的Bash会话。这是因为容器被杀死。`137`退出代码表示该会话被手动干预杀死。
- en: 'Run the following command to get the status of the pod:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以获取pod的状态：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Observe the following section in the output that you get:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 观察您获得的输出中的以下部分：
- en: '![Figure 9.7: Describing the pod'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7：描述pod'
- en: '](image/B14870_09_07.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_09_07.jpg)'
- en: 'Figure 9.7: Describing the pod'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：描述pod
- en: You will see that there's now a `Restart Count` field for `nginx-container`
    that has a value of `1`. That means that the container was restarted after we
    killed it. Please note that restarting a container doesn't trigger a restart of
    a pod. Hence, we should expect the data stored in the Volume to still exist. Let's
    verify that in the next step.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到`nginx-container`现在有一个`Restart Count`字段，其值为`1`。这意味着在我们杀死它后容器被重新启动。请注意，重新启动容器不会触发pod的重新启动。因此，我们应该期望Volume中存储的数据仍然存在。让我们在下一步中验证一下。
- en: 'Let''s run Bash inside the pod again and go to the `/mounted-data` directory:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次在pod内运行Bash，并转到`/mounted-data`目录：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You will see the following output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the following command to check the contents of `/mounted-data` directory:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以检查`/mounted-data`目录的内容：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You will see the following output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This output indicates that the file we created before killing the container
    still exists in the Volume.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出表明我们在杀死容器之前创建的文件仍然存在于Volume中。
- en: 'Run the following command to verify the contents of the file we created in
    the Volume:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以验证我们在Volume中创建的文件的内容：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You will see the following output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This output indicates that the data we stored in the Volume stays intact even
    when the container gets restarted.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出表明，我们存储在Volume中的数据即使在容器重新启动时也保持完整。
- en: 'Run the following command to delete the pod:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以删除pod：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You will see the following output confirming that the pod has been deleted:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出，确认pod已被删除：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this exercise, we created a pod with the `emptyDir` Volume, checked that
    the pod was created with an empty directory mounted at the correct path inside
    the container, and verified that we can write the data inside that directory and
    that the data stays intact across the container restarts as long as the pod is
    still running.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建了一个带有`emptyDir`卷的pod，检查了pod是否创建了一个空目录挂载在容器内的正确路径，并验证了我们可以在该目录内写入数据，并且只要pod仍在运行，数据就会在容器重新启动时保持完整。
- en: Now, let's move to a scenario that lets us observe some more uses for Volumes.
    Let's consider a scenario where we have an application pod that runs a total of
    three containers. We can assume that two of the three containers are serving traffic
    and they dump the logs into a shared file. The third container acts as a sidecar
    monitoring container that reads the logs from the file and dumps them into an
    external log storage system where the logs can be preserved for further analysis
    and alerting. Let's consider this scenario in the next exercise and understand
    how we can utilize an `emptyDir` Volume shared between the three containers of
    a pod.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转移到一个场景，让我们观察一些更多卷的用途。让我们考虑这样一个场景，我们有一个应用pod，运行了三个容器。我们可以假设其中三个容器中有两个正在提供流量，并且它们将日志转储到一个共享文件中。第三个容器充当一个sidecar监控容器，从文件中读取日志，并将其转储到外部日志存储系统，以便进一步分析和警报。让我们在下一个练习中考虑这种情况，并了解如何利用pod的三个容器之间共享的`emptyDir`卷。
- en: 'Exercise 9.02: Creating a Pod with an emptyDir Volume Shared by Three Containers'
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.02：创建一个由三个容器共享emptyDir卷的Pod
- en: 'In this exercise, we will show some more uses of the `emptyDir` Volume and
    share it among three containers in the same pod. Each container will mount the
    same volume at a different local path:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将展示`emptyDir`卷的一些更多用途，并在同一个pod中的三个容器之间共享它。每个容器将在不同的本地路径挂载相同的卷：
- en: 'Create a file called `shared-emptydir-volume.yaml` with the following content:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`shared-emptydir-volume.yaml`的文件，内容如下：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this configuration, we have defined an `emptyDir` Volume named `data-volume`,
    which is being mounted on three containers at different paths.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配置中，我们定义了一个名为`data-volume`的`emptyDir`卷，它被挂载在三个容器的不同路径上。
- en: Note that each of the containers has been configured to run a command on startup
    that makes them sleep for 1 hour. This is intended to keep the `ubuntu` container
    running so that we can perform the following operations on the containers. By
    default, an `ubuntu` container is configured to run whatever command is specified
    and exit upon completion.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个容器都被配置为在启动时运行一个使它们休眠1小时的命令。这是为了保持`ubuntu`容器运行，以便我们可以在容器上执行以下操作。默认情况下，`ubuntu`容器被配置为运行指定的命令并在完成后退出。
- en: 'Run the following command to create the pod with the preceding configuration:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以使用上述配置创建pod：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You will see the following output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the following command to check the status of the pod:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来检查pod的状态：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You will see the following output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This output indicates that all three containers inside this pod are running.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出表明此pod内的所有三个容器都在运行。
- en: 'Next, we will run the following command to run Bash in the first container:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将运行以下命令在第一个容器中运行Bash：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, the `-c` flag is used to specify the container that we want to run Bash
    in. You will see the following in the terminal:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`-c`标志用于指定我们要在其中运行Bash的容器。您将在终端中看到以下内容：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the following command to check the content of the root directory on the
    container:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来检查容器中根目录的内容：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You will see the following output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![Figure 9.8: Listing the content of the root directory inside the container'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8：列出容器内根目录的内容'
- en: '](image/B14870_09_08.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_09_08.jpg)'
- en: 'Figure 9.8: Listing the content of the root directory inside the container'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：列出容器内根目录的内容
- en: We can see that the `mounted-data-1` directory has been created on the container.
    Also, you can see the list of directories you would see in a typical Ubuntu root
    directory, in addition to the `mounted-data-1` directory that we created.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`mounted-data-1`目录已在容器中创建。此外，您还可以看到在典型的Ubuntu根目录中会看到的目录列表，以及我们创建的`mounted-data-1`目录。
- en: 'Now, we will go to the `mounted-data-1` directory and create a simple text
    file with some text in it:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将进入`mounted-data-1`目录并创建一个带有一些文本的简单文本文件：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run the following command to verify that the file has been stored:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来验证文件是否已存储：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You will see the following output:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Run the following command to exit `container-1` and go back to your host terminal:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令退出`container-1`并返回到您的主机终端：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let''s run Bash inside the second container, which is named `container-2`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在第二个容器中运行Bash，它的名称是`container-2`：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You will see the following in your terminal:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在终端中看到以下内容：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Run the following command to locate the mounted directory in the root directory
    on the container:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来定位容器中根目录中的挂载目录：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You will see the following output:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![Figure 9.9: Listing the content of the root directory inside the container'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9：列出容器内根目录的内容'
- en: '](image/B14870_09_09.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_09_09.jpg)'
- en: 'Figure 9.9: Listing the content of the root directory inside the container'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：列出容器内根目录的内容
- en: Note the directory called `mounted-data-2`, which is the mount point for our
    Volume inside `container-2`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意名为`mounted-data-2`的目录，这是我们在`container-2`中的卷的挂载点。
- en: 'Run the following command to check the content of the `mounted-data-2` directory:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令检查`mounted-data-2`目录的内容：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You will see the following output:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到以下输出：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This output indicates that there's already a file called `data-1.txt`, which
    we created in `container-1` earlier.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出表明，已经有一个名为`data-1.txt`的文件，我们之前在`container-1`中创建过。
- en: 'Let''s verify that it''s the same file that we created in earlier steps. Run
    the following command to check the content of this file:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们验证这是否是我们在早期步骤中创建的同一个文件。运行以下命令检查该文件的内容：
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You will see the following output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到以下输出：
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This output verifies that this is the same file that we created in earlier steps
    of this exercise.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出验证了这是我们在这个练习的早期步骤中创建的同一个文件。
- en: 'Run the following command to write a new file called `data-2.txt` into this
    directory:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令在该目录中写入一个名为`data-2.txt`的新文件：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let''s confirm that the file has been created:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们确认文件已经创建：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You should see the following output:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see in this screenshot, the new file has been created and there are
    now two files – `data-1.txt` and `data-2.txt` – in the mounted directory.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在截图中看到的，新文件已经创建，现在挂载目录中有两个文件——`data-1.txt`和`data-2.txt`。
- en: 'Run the following command to exit the Bash session on this container:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令退出该容器上的Bash会话：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, let''s run Bash inside `container-3`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`container-3`中运行Bash：
- en: '[PRE55]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You will see the following in your terminal:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在终端上看到以下内容：
- en: '[PRE56]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Go to the `/mounted-data-3` directory and check its content:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`/mounted-data-3`目录并检查其内容：
- en: '[PRE57]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You will see the following output:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到以下输出：
- en: '[PRE58]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This output shows that this container can see the two files – `data-1.txt` and
    `data-2.txt` – that we created in earlier steps from `container-1` and `container-2`,
    respectively.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示，这个容器可以看到我们之前在`container-1`和`container-2`中创建的两个文件——`data-1.txt`和`data-2.txt`。
- en: 'Run the following command to verify the content of the first file, `data-1.txt`:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令验证第一个文件`data-1.txt`的内容：
- en: '[PRE59]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You should see the following output:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE60]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Run the following commands to verify the content of the second file, `data-2.txt`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令验证第二个文件`data-2.txt`的内容：
- en: '[PRE61]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You should see the following output:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE62]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The output of the last two commands proves that the data written by any container
    on the mounted volume is accessible by other containers for reading. Next, we
    will verify that other containers have write access to the data written by a particular
    container.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个命令的输出证明，任何一个容器在挂载卷上写入的数据都可以被其他容器读取。接下来，我们将验证其他容器是否有权限写入特定容器写入的数据。
- en: 'Run the following command to overwrite the content of the `data-2.txt` file:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令覆盖`data-2.txt`文件的内容：
- en: '[PRE63]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, let''s exit `container-3`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们退出`container-3`：
- en: '[PRE64]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Run the following command to run Bash inside `container-1` again:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令再次在`container-1`中运行Bash：
- en: '[PRE65]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You should see the following in your terminal:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在终端上看到以下内容：
- en: '[PRE66]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Run the following command to check the content of the `data-2.txt` file:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令检查`data-2.txt`文件的内容：
- en: '[PRE67]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You should see the following output:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE68]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This output indicates that the data overwritten by `container-3` becomes available
    for other containers to read as well.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出表明，被`container-3`覆盖的数据也可以被其他容器读取。
- en: 'Run the following command to come out of the SSH session inside `container-3`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令退出`container-3`中的SSH会话：
- en: '[PRE69]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Run the following command to delete the pod:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以删除pod：
- en: '[PRE70]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You should see the following output, indicating that the pod has been deleted:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出，表明pod已被删除：
- en: '[PRE71]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In this exercise, we learned how to use Volumes and verified that the same Volume
    can be mounted at different paths in different containers. We also saw that the
    containers using the same Volume can read or write (or overwrite) content of the
    Volume.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何使用卷，并验证了相同的卷可以挂载到不同容器中的不同路径。我们还看到使用相同卷的容器可以读取或写入（或覆盖）卷的内容。
- en: Persistent Volumes
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久卷
- en: The Volumes we have seen so far have the limitation that their life cycle depends
    on the life cycle of pods. Volumes such as emptyDir or hostPath get deleted when
    the pod using them is deleted or gets restarted. For example, if we use Volumes
    to store user data and inventory records for our e-commerce website, the data
    will be deleted when the application pod restarts. Hence, Volumes are not suited
    to store data that you want to persist.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的卷有一个限制，即它们的生命周期取决于pod的生命周期。例如，当使用它们的pod被删除或重新启动时，emptyDir或hostPath等卷将被删除。例如，如果我们使用卷来存储电子商务网站的用户数据和库存记录，当应用程序pod重新启动时，数据将被删除。因此，卷不适合存储您想要持久保存的数据。
- en: To solve this problem, Kubernetes supports persistent storage in the form of
    a **Persistent Volume** (**PV**). A PV is a Kubernetes object that represents
    a block of storage in the cluster. It can either be provisioned beforehand by
    the cluster administrators or be dynamically provisioned. A PV can be considered
    a cluster resource just like a node and, hence, it is not scoped to a single namespace.
    These Volumes work similarly to the Volumes we have seen in previous sections.
    The life cycle of a PV doesn't depend on the life cycle of any pod that uses the
    PV. From the pod's perspective, however, there's no difference between using a
    normal Volume and a PV.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Kubernetes支持以**持久卷**（**PV**）的形式提供持久存储。PV是Kubernetes集群中表示存储块的对象。它可以由集群管理员预先配置，也可以动态配置。PV可以被视为集群资源，就像节点一样，因此它不限于单个命名空间。这些卷的工作方式类似于我们在之前章节中看到的卷。PV的生命周期不依赖于使用PV的任何pod的生命周期。然而，从pod的角度来看，使用普通卷和PV没有区别。
- en: In order to use a PV, a **PersistentVolumeClaim** (**PVC**) needs to be created.
    A PVC is a request for storage by a user or a pod. A PVC can request a specific
    size of storage and specific access modes. A PVC is effectively an abstract way
    of accessing the various storage resources by users. PVCs are scoped by namespaces,
    so pods can only access the PVCs created within the same namespace.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用PV，需要创建一个**持久卷索赔**（**PVC**）。PVC是用户或pod对存储的请求。PVC可以请求特定大小的存储和特定的访问模式。PVC实际上是用户访问各种存储资源的抽象方式。PVC由命名空间范围，因此pod只能访问在同一命名空间中创建的PVC。
- en: Note
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At any time, a PV can be bound to one PVC only.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候，PV只能绑定到一个PVC。
- en: 'Here''s a diagram showing how an application interacts with a PV and PVC:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个显示应用程序如何与PV和PVC交互的图表：
- en: '![Figure 9.10: How PV and PVC work together to provide storage to your application
    pod'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.10：PV和PVC如何共同为您的应用程序pod提供存储'
- en: '](image/B14870_09_10.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_09_10.jpg)'
- en: 'Figure 9.10: How PV and PVC work together to provide storage to your application
    pod'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：PV和PVC如何共同为您的应用程序pod提供存储
- en: As you can see in this diagram, Kubernetes uses a combination of PV and PVC
    to make storage available to your applications. A PVC is basically a request to
    provide a PV that meets certain criteria.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，Kubernetes使用PV和PVC的组合来为您的应用程序提供存储。PVC基本上是提供符合特定条件的PV的请求。
- en: This is a notable variation from what we saw in the previous exercises, where
    we created Volumes directly in the pod definitions. This separation of the request
    (PVC) and the actual storage abstraction (PV) allows an application developer
    to not worry about the specifics and the statuses of all the different PVs present
    on the cluster; they can simply create a PVC with the application requirements
    and then use it in the pod. This kind of loose binding also allows the entire
    system to be resilient and remain stable in the case of pod restarts.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与我们在先前练习中看到的有显著变化，我们在那里直接在pod定义中创建了卷。请求（PVC）和实际存储抽象（PV）的分离使应用程序开发人员不必担心集群上存在的所有不同PV的具体情况和状态；他们只需根据应用程序的要求创建PVC，然后在pod中使用它。这种松散的绑定还允许整个系统在pod重新启动的情况下保持稳定和可靠。
- en: 'Similar to Volumes, Kubernetes supports several types of PVs. Some of them
    may be specific to your cloud platform. You can find a list of the different supported
    types at this link: [https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes
    )'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 与卷类似，Kubernetes支持几种类型的PV。其中一些可能特定于您的云平台。您可以在此链接找到不同支持类型的列表：[https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes)
- en: PersistentVolume Configuration
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久卷配置
- en: 'Here''s an example of PV configuration:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是PV配置的示例：
- en: '[PRE72]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As usual, the PV object also has the three fields that we have already seen:
    `apiVersion`, `kind`, and `metadata`. Since this is an `nfs` type of PV, we have
    the `nfs` section in the configuration. Let''s go through some important fields
    in the PV `spec` section one by one.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，PV对象还具有我们已经看到的三个字段：`apiVersion`、`kind`和`metadata`。由于这是一种`nfs`类型的PV，我们在配置中有`nfs`部分。让我们逐个浏览PV
    `spec`部分中的一些重要字段。
- en: storageClassName
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: storageClassName
- en: Each PV belongs to a certain storage class. We define the name of the storage
    class that the PV is associated with using the `storageClassName` field. A StorageClass
    is a Kubernetes object that provides a way for administrators to describe the
    different types or profiles of storages they support. In the preceding example,
    `standard` is just an example of a storage class.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 每个PV都属于某个存储类别。我们使用`storageClassName`字段定义PV关联的存储类别的名称。StorageClass是Kubernetes对象，为管理员提供了描述他们支持的不同类型或存储配置文件的方式。在前面的示例中，`standard`只是存储类别的一个示例。
- en: Different storage classes allow you to allocate different types of storage based
    on performance and capacity to different applications based on the specific needs
    of the application. Each cluster administrator can configure their own storage
    classes. Each storage class can have its own provisioners, backup policies, or
    reclamation policies determined by administrators. A provisioner is a system that
    determines how to provision a PV of a particular type. Kubernetes supports a set
    of internal provisioners as well as external ones that can be implemented by users.
    The details about how to use or create a provisioner are, however, beyond the
    scope of this book.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的存储类别允许您根据应用程序的特定需求，基于性能和容量为不同的应用程序分配不同类型的存储。每个集群管理员都可以配置自己的存储类别。每个存储类别可以有自己的提供程序、备份策略或管理员确定的回收策略。提供程序是确定如何为特定类型的PV提供存储的系统。Kubernetes支持一组内部提供程序以及用户可以实现的外部提供程序。关于如何使用或创建提供程序的详细信息，但是超出了本书的范围。
- en: A PV belonging to a certain storage class can only be bound to a PVC requesting
    that particular class. Note that this is an optional field. Any PV without the
    storage class field will only be available to PVCs that do not request a specific
    storage class.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 属于特定存储类的PV只能绑定到请求该特定类的PVC。请注意，这是一个可选字段。没有存储类字段的任何PV只对不请求特定存储类的PVC可用。
- en: capacity
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容量
- en: This field denotes the storage capacity of the PV. We can set this field in
    a similar way as we would define constraints used by memory and CPU limit fields
    in a pod spec. In the preceding example spec, we have set the capacity to 10 GiB.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段表示PV的存储容量。我们可以像定义Pod规范中的内存和CPU限制字段一样设置这个字段。在前面的示例规范中，我们将容量设置为10 GiB。
- en: volumeMode
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: volumeMode
- en: 'The `volumeMode` field denotes how we want the storage to be used. It can have
    two possible values: `Filesystem` (default) and `Block`. We can set the `volumeMode`
    field to `Block` in order to use the raw block device as storage, or `Filesystem`
    to use a traditional filesystem on the persistent volume.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`volumeMode`字段表示我们希望如何使用存储。它可以有两个可能的值：`Filesystem`（默认）和`Block`。我们可以将`volumeMode`字段设置为`Block`，以便使用原始块设备作为存储，或者设置为`Filesystem`以在持久卷上使用传统文件系统。'
- en: accessModes
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问模式
- en: 'The access mode for a PV represents the capabilities allowed for a mounted
    Volume. A Volume can be mounted using only one of the supported access modes at
    a time. There are three possible access modes:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: PV的访问模式表示挂载卷允许的功能。一个卷一次只能使用一个支持的访问模式进行挂载。有三种可能的访问模式：
- en: '`ReadWriteOnce` (`RWO`): Mounted as read-write by a single node only'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadWriteOnce`（`RWO`）：仅由单个节点挂载为读写'
- en: '`ReadOnlyMany` (`ROX`): Mounted as read-only by many nodes'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadOnlyMany`（`ROX`）：由多个节点挂载为只读'
- en: '`ReadWriteMany` (`RWX`): Mounted as read-write by many nodes'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadWriteMany`（`RWX`）：由多个节点挂载为读写'
- en: Note that not all the types of volumes support all the access modes. Please
    check the reference for the allowed access modes for the specific type of volume
    you are using.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有类型的卷都支持所有访问模式。请检查允许的访问模式的参考文献，以了解您正在使用的特定类型的卷的访问模式。
- en: persistentVolumeReclaimPolicy
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久卷回收策略
- en: 'Once a user is done with a volume, they can delete their PVC, and that allows
    the PV resource to be reclaimed. The reclaim policy field denotes the policy that
    will be used to allow a PV to be claimed after its release. A PV being *released*
    implies that the PV is no longer associated with the PVC since that PVC is deleted.
    Then, the PV is available for any other PVCs to use, or in other words, *reclaim*.
    Whether a PV can be reused or not depends on the reclaim policy. There can be
    three possible values for this field:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 用户完成卷的使用后，他们可以删除他们的PVC，这样就可以回收PV资源。回收策略字段表示在释放后允许声明PV的策略。PV被*释放*意味着PV不再与PVC相关联，因为PVC已被删除。然后，PV可供任何其他PVC使用，或者换句话说，*回收*。PV是否可以被重用取决于回收策略。该字段有三个可能的值：
- en: '`Retain`: This reclaim policy indicates that the data stored in the PV is kept
    in storage even after the PV has been released. The administrator will need to
    delete the data in storage manually. In this policy, the PV is marked as `Released`
    instead of `Available`. Thus, a `Released` PV may not necessarily be empty.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Retain`：此回收策略表示即使PV已被释放，存储在PV中的数据也会保留。管理员需要手动删除存储中的数据。在此策略中，PV标记为`Released`而不是`Available`。因此，`Released`
    PV可能不一定为空。'
- en: '`Recycle`: Using this reclaim policy means that once the PV is released, the
    data on the volume is deleted using a basic `rm -rf` command. This marks the PV
    as `Available` and hence ready to be claimed again. Using dynamic provisioning
    is a better alternative to using this reclaim policy. We will discuss the dynamic
    provisioning in the next section.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`回收`: 使用此回收策略意味着一旦PV被释放，卷上的数据将使用基本的`rm -rf`命令删除。这将标记PV为`可用`，因此可以再次声明。使用动态配置比使用此回收策略更好。我们将在下一节讨论动态配置。'
- en: '`Delete`: Using this reclaim policy means that once the PV is released, both
    the PV as well as the data stored in the underlying storage will be deleted.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`删除`: 使用此回收策略意味着一旦PV被释放，底层存储中存储的数据以及PV本身将被删除。'
- en: Note
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Various cloud environments have different default values for reclaim policies.
    So, make sure you check the default value of the reclaim policy for the cloud
    environment you're using to avoid the accidental deletion of data in PVs.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的云环境对回收策略有不同的默认值。因此，请确保您检查您使用的云环境的回收策略的默认值，以避免意外删除PV中的数据。
- en: PV Status
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PV状态
- en: 'At any moment of its life cycle, a PV can have one of the following statuses:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在其生命周期的任何时刻，PV可以具有以下状态之一：
- en: '`Available`: This indicates that the PV is available to be claimed.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`可用`: 这表示PV可以被声明。'
- en: '`Bound`: This indicates that the PV has been bound to a PVC.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`绑定`: 这表示PV已绑定到PVC。'
- en: '`Released`: This indicates that the PVC bound to this resource has been deleted;
    however, it''s yet to be reclaimed by some other PVC.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`发布`: 这表示绑定到此资源的PVC已被删除；但是，它尚未被其他PVC回收。'
- en: '`Failed`: This indicates that there was a failure during reclamation.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`失败`: 这表示回收过程中出现了失败。'
- en: Now that we have taken a look at the various aspects of the PV, let's take a
    look at the PVC.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看了PV的各个方面，让我们来看看PVC。
- en: PersistentVolumeClaim Configuration
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久卷声明配置
- en: 'Here''s an example of PVC configuration:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是PVC配置的示例：
- en: '[PRE73]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Again, as usual, the PVC object also has three fields that we have already
    seen: `apiVersion`, `kind`, and `metadata`. Let''s go through some important fields
    in the PVC `spec` section one by one.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，通常情况下，PVC对象也有三个我们已经看到的字段：`apiVersion`，`kind`和`metadata`。让我们逐个查看PVC `spec`部分中的一些重要字段。
- en: storageClassName
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: storageClassName
- en: A PVC can request a particular class of storage by specifying the `storageClassName`
    field. Only the PVs of the specified storage class can be bound to such a PVC.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: PVC可以通过指定`storageClassName`字段来请求特定类别的存储。只有指定存储类的PV才能绑定到这样的PVC。
- en: If the `storageClassName` field is set to an empty string (`""`), these PVCs
    will only be bound to PVs that have no storage class set.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`storageClassName`字段设置为空字符串（`""`），这些PVC只会绑定到没有设置存储类的PV。
- en: On the other hand, if the `storageClassName` field in the PVC is not set, then
    it depends on whether `DefaultStorageClass` has been enabled by the administrator.
    If a default storage class is set for the cluster, the PVCs with no `storageClassName`
    field set will be bound to PVs with that default storage class. Otherwise, PVCs
    with no `storageClassName` field set will only be bound to PVs that have no storage
    class set.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果PVC中的`storageClassName`字段未设置，则取决于管理员是否启用了`DefaultStorageClass`。如果为集群设置了默认存储类，则没有设置`storageClassName`字段的PVC将绑定到具有该默认存储类的PV。否则，没有设置`storageClassName`字段的PVC将只绑定到没有设置存储类的PV。
- en: resources
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源
- en: Just as we learned that pods can make specific resource requests, PVCs can also
    request resources in a similar manner by specifying the `requests` and `limits`
    fields, which are optional. Only the PVs satisfying the resource requests can
    be bound to a PVC.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们学到的pod可以发出特定的资源请求一样，PVC也可以通过指定`requests`和`limits`字段来以类似的方式请求资源，这是可选的。只有满足资源请求的PV才能绑定到PVC上。
- en: volumeMode
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: volumeMode
- en: PVCs follow the same convention as PVs to indicate the use of storage as a filesystem
    or a raw block device. A PVC can only be bound to a PV that has the same Volume
    mode as the one specified in the PVC configuration.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: PVC遵循与PV相同的约定，以指示将存储用作文件系统或原始块设备。只有与PVC配置中指定的卷模式相同的PV才能绑定到PVC。
- en: accessMode
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: accessMode
- en: A PVC should specify the access mode that it needs, and a PV is assigned as
    per the availability based on that access mode.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: PVC应该指定它需要的访问模式，并且根据该访问模式的可用性分配PV。
- en: selectors
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: selectors
- en: Similar to pod selectors in Services, PVCs can use the `matchLabels` and/or
    `matchExpressions` fields to specify the criteria of volumes that can satisfy
    a particular claim. Only the PVs whose labels satisfy the conditions specified
    in the `selectors` field are considered for a claim. When both of these fields
    are used together as selectors, the conditions specified by the two fields are
    combined using an AND operation.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务中的pod选择器类似，PVC可以使用`matchLabels`和/或`matchExpressions`字段来指定可以满足特定声明的卷的条件。只有满足`selectors`字段中指定条件的PV才会被考虑为声明。当这两个字段一起作为选择器使用时，两个字段指定的条件将使用AND操作进行组合。
- en: How to Use Persistent Volumes
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用持久卷
- en: 'In order to use a PV, we have the following three steps: provisioning the volume,
    binding it to a claim (PVC), and using the claim as a volume on a pod. Let''s
    go through these steps in detail.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用PV，我们有以下三个步骤：配置卷，将其绑定到声明（PVC），并在pod上使用声明作为卷。让我们详细了解这些步骤。
- en: Step 1 – Provisioning the Volume
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步 - 配置卷
- en: 'A Volume can be provisioned in two ways – statically and dynamically:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 卷可以通过两种方式进行配置 - 静态和动态：
- en: '**Static**: In static provisioning, the cluster administrator has to provision
    several PVs beforehand, and only then are they available to PVCs as available
    resources.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态**：在静态配置中，集群管理员必须预先配置多个PV，然后它们才能作为可用资源提供给PVC。'
- en: '**Dynamic**: If you are using dynamic provisioning, the administrator doesn''t
    need to provision all the PVs beforehand. In this kind of provisioning, the cluster
    will dynamically provision the PV for the PVC based on the storage class requested.
    Thus, as the applications or microservices demand more storage, Kubernetes can
    automatically take care of it and expand the cloud infrastructure as needed.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态**：如果您使用动态配置，管理员不需要预先配置所有PV。在这种配置中，集群将根据请求的存储类动态为PVC配置PV。因此，当应用程序或微服务需要更多存储时，Kubernetes可以自动处理并根据需要扩展云基础设施。'
- en: We will go through dynamic provisioning in more detail in a later section.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的部分更详细地介绍动态配置。
- en: Step 2 – Binding the Volume to a Claim
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二步 - 将卷绑定到声明
- en: In this step, a PVC is to be created with the requested storage limits, a certain
    access mode, and a specific storage class. Whenever a new PVC is created, the
    Kubernetes controller will search for a PV matching its criteria. If a PV matching
    all of the PVC criteria is found, it will bind the claim to the PV. Each PV can
    be bound to only one PVC at a time.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，需要使用请求的存储限制、特定的访问模式和特定的存储类来创建PVC。每当创建新的PVC时，Kubernetes控制器将搜索与其条件匹配的PV。如果找到与所有PVC条件匹配的PV，它将绑定声明到PV上。每个PV一次只能绑定到一个PVC。
- en: Step 3 – Using the Claim
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三步 - 使用声明
- en: Once the PV has been provisioned and bound to a PVC, the PV can be used by the
    pod as a Volume. Next, when a pod uses a PVC as a Volume, Kubernetes will take
    the PV bound to that PVC and mount that PV for the pod.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦PV被配置并绑定到PVC，pod就可以将PV作为Volume使用。接下来，当pod使用PVC作为Volume时，Kubernetes将会找到与该PVC绑定的PV，并将其挂载到pod上。
- en: 'Here''s an example of pod configuration using a PVC as a Volume:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用PVC作为Volume的pod配置示例：
- en: '[PRE74]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this example, we assume that we have a PVC named `example-claim` that has
    already been bound to `PersistentVolume`. The pod configuration specifies `persistentVolumeClaim`
    as the type of the Volume and specifies the name of the claim to be used. Kubernetes
    will then find the actual PV bound to this claim and mount it on `/data/application`
    inside the container.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们假设已经有一个名为`example-claim`的PVC已经绑定到`PersistentVolume`。pod配置指定`persistentVolumeClaim`作为Volume的类型，并指定要使用的claim的名称。Kubernetes将会找到实际绑定到该claim的PV，并将其挂载到容器内的`/data/application`目录下。
- en: Note
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The pod and the PVC have to be in the same namespace for this to work. This
    is because Kubernetes will look for the claim inside the pod's namespace only,
    and if the PVC isn't found, the pod will not be scheduled. In this case, the pod
    will be stuck in a `Pending` state until deleted.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个工作，pod和PVC必须在同一个命名空间中。这是因为Kubernetes只会在pod的命名空间中寻找claim，如果找不到PVC，pod将无法被调度。在这种情况下，pod将会被卡在`Pending`状态，直到被删除。
- en: Now, let's put these concepts into action by creating a pod that uses PV in
    the following exercise.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过创建一个使用PV的pod来将这些概念付诸实践。
- en: 'Exercise 9.03: Creating a Pod That Uses PersistentVolume for Storage'
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.03：创建使用PersistentVolume进行存储的Pod
- en: 'In this exercise, we will first provision the PV pretending that the cluster
    administrator does it in advance. Next, assuming the role of a developer, we will
    create a PVC that is bound to the PV. After that, we will create a pod that will
    use this claim as a Volume mounted on one of the containers:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们首先假装集群管理员提前配置了PV。接下来，假设是开发人员的角色，我们将创建一个绑定到PV的PVC。之后，我们将创建一个使用这个claim作为Volume挂载到一个容器上的pod：
- en: 'First of all, we will access the host node via SSH. In the case of Minikube,
    we can do so by using the following command:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将通过SSH访问主机节点。在Minikube的情况下，我们可以使用以下命令来做到：
- en: '[PRE75]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You should see an output similar to this one:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似于以下的输出：
- en: '![Figure 9.11: SSH to the minikube node'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.11：SSH到minikube节点'
- en: '](image/B14870_09_11.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_09_11.jpg)'
- en: 'Figure 9.11: SSH to the minikube node'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：SSH到minikube节点
- en: 'Run the following command to create a directory named `data` inside the `/mnt`
    directory:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令在`/mnt`目录下创建一个名为`data`的目录：
- en: '[PRE76]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Run the following command to create a file called `data.txt` inside the `/mnt/data`
    directory:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令在`/mnt/data`目录下创建一个名为`data.txt`的文件：
- en: '[PRE77]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This command should create a file, `data.txt`, with the `Data written on host
    node` content. We will use the content of this file to verify at a later stage
    that we can successfully mount this directory on a container using a PV and a
    PVC.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令应该会创建一个名为`data.txt`的文件，其中包含`Data written on host node`的内容。我们将使用这个文件的内容在稍后的阶段验证，我们可以成功地使用PV和PVC在容器上挂载这个目录。
- en: 'Run the following command to exit the host node:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令退出主机节点：
- en: '[PRE78]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: That will bring us back to the local machine terminal where we can run `kubectl`
    commands.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会把我们带回到本地机器终端，我们可以在那里运行`kubectl`命令。
- en: 'Create a file called `pv-hostpath.yaml` with the following content:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pv-hostpath.yaml`的文件，内容如下：
- en: '[PRE79]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In this PV configuration, we have used the `local-pv` storage class. The Volume
    will be hosted at the `/mnt/data` path on the host node. The size of the volume
    will be `500Mi` and the access mode will be `ReadWriteOnce`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个PV配置中，我们使用了`local-pv`存储类。Volume将托管在主机节点的`/mnt/data`路径上。卷的大小将为`500Mi`，访问模式将为`ReadWriteOnce`。
- en: 'Run the following command to create the PV using the preceding configuration:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来使用前面的配置创建PV：
- en: '[PRE80]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You should see the following output:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE81]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Run the following command to check the status of the PV we just created:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来检查我们刚刚创建的PV的状态：
- en: '[PRE82]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'As you can see in this command, `pv` is an accepted shortened name for `PersistentVolume`.
    You should see the following output:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这个命令中看到的那样，`pv`是`PersistentVolume`的一个被接受的缩写。你应该看到以下输出：
- en: '![Figure 9.12: Checking the status of the PV'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.12：检查PV的状态'
- en: '](image/B14870_09_12.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_09_12.jpg)'
- en: 'Figure 9.12: Checking the status of the PV'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：检查PV的状态
- en: In the preceding output, we can see that the Volume was created with the required
    configuration and that its status is `Available`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到Volume已经使用所需的配置创建，并且其状态为`Available`。
- en: 'Create a file called `pvc-local.yaml` with the following content:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pvc-local.yaml`的文件，内容如下：
- en: '[PRE83]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In this configuration, we have a claim that requests a Volume with the `local-pv`
    storage class, the `ReadWriteOnce` access mode and a storage size of `100Mi`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配置中，我们有一个声明，请求一个带有`local-pv`存储类、`ReadWriteOnce`访问模式和`100Mi`存储大小的Volume。
- en: 'Run the following command to create this PVC:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来创建这个PVC：
- en: '[PRE84]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'You should see the following output:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE85]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Once we create this PVC, Kubernetes will search for a matching PV to satisfy
    this claim.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了这个PVC，Kubernetes将搜索匹配的PV来满足这个声明。
- en: 'Run the following command to check the status of this PVC:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来检查这个PVC的状态：
- en: '[PRE86]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You should see the following output:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![Figure 9.13: Checking the status of the claim'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.13：检查声明的状态'
- en: '](image/B14870_09_13.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_09_13.jpg)'
- en: 'Figure 9.13: Checking the status of the claim'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13：检查声明的状态
- en: As we can see in this output, the PVC has been created with the required configuration
    and has been immediately bound to the existing PV named `pv-hostpath` that we
    created in earlier steps of this exercise.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这个输出中看到的那样，PVC已经使用所需的配置创建，并立即绑定到我们在此练习的早期步骤中创建的名为`pv-hostpath`的现有PV。
- en: 'Next, we can create a pod that will use this PVC as a Volume. Create a file
    called `pod-local-pvc.yaml` with the following content:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建一个将使用这个PVC作为Volume的pod。创建一个名为`pod-local-pvc.yaml`的文件，内容如下：
- en: '[PRE87]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The pod will use a PVC named `pvc-local` as a Volume and mount it at the `/data/application`
    path in the container. Also, we have a container that will run the `cat /data/application/data.txt`
    command on startup. This is just a simplified example where we will showcase that
    the data we wrote in the PV directory on the host node initially is now available
    to this pod.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: pod将使用名为`pvc-local`的PVC作为Volume，并在容器中的`/data/application`路径上挂载它。此外，我们有一个容器将在启动时运行`cat
    /data/application/data.txt`命令。这只是一个简化的例子，我们将展示最初在主机节点的PV目录中写入的数据现在可用于这个pod。
- en: 'Run the following command to create this pod:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来创建这个pod：
- en: '[PRE88]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You should see the following output:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE89]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This output indicates that the pod was created successfully.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出表明pod已经成功创建。
- en: 'Run the following command to check the status of the pod we just created:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来检查我们刚刚创建的pod的状态：
- en: '[PRE90]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'You should see the following output:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE91]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In this output, we can see that the pod has run to completion since we didn't
    add any sleep commands this time.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，我们可以看到pod已经成功完成，因为这次我们没有添加任何休眠命令。
- en: 'Run the following command to check the logs. We expect to see the output of
    the `cat /data/application/data.txt` command in the logs:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来检查日志。我们期望在日志中看到`cat /data/application/data.txt`命令的输出：
- en: '[PRE92]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'You should see the following output:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE93]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This output clearly indicates that this pod has access to the file that we created
    at `/mnt/data/data.txt`. This file is a part of the directory mounted at `/data/application`
    in the container.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出清楚地表明这个pod可以访问我们在`/mnt/data/data.txt`创建的文件。这个文件是容器中挂载在`/data/application`目录中的一部分。
- en: 'Now, let''s clean up the resources created in this exercise. Use the following
    command to delete the pod:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们清理本练习中创建的资源。使用以下命令删除pod：
- en: '[PRE94]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'You should see the following output, indicating that the pod has been deleted:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出，表明pod已被删除：
- en: '[PRE95]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Use this command to delete the PVC:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令删除PVC：
- en: '[PRE96]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You should see the following output, indicating that the PVC has been deleted:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出，表明PVC已被删除：
- en: '[PRE97]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Note that if we try to delete the PV before the PVC is deleted, the PV will
    be stuck in the `Terminating` phase and will wait for it to be released by the
    PVC. Hence, we need to first delete the PVC bound to the PV before the PV can
    be deleted.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们在删除PVC之前尝试删除PV，PV将被卡在“Terminating”阶段，并且将等待PVC释放它。因此，我们需要在删除PV之前先删除绑定到PV的PVC。
- en: 'Now that our PVC has been deleted, we can safely delete the PV by running the
    following command:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的PVC已被删除，我们可以安全地通过运行以下命令删除PV：
- en: '[PRE98]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You should see the following output, indicating that the PV has been deleted:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出，表明PV已被删除：
- en: '[PRE99]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: In this exercise, we learned how to provision PVs, create claims to use these
    volumes, and then use those PVCs as volumes inside pods.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何配置PV，创建声明来使用这些卷，然后在pod内部使用这些PVC作为卷。
- en: Dynamic Provisioning
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态配置
- en: In previous sections of this chapter, we saw that the cluster administrator
    needs to provision PVs for us before we can use them as storage for our application.
    To solve this problem, Kubernetes supports dynamic volume provisioning as well.
    Dynamic volume provisioning enables the creation of storage volumes on-demand.
    This eliminates the need for administrators to create volumes before creating
    any PVCs. The volume is provisioned only when there's a claim requesting it.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几节中，我们看到集群管理员需要为我们配置PV，然后我们才能将其用作应用程序的存储。为了解决这个问题，Kubernetes也支持动态卷配置。动态卷配置使得可以按需创建存储卷。这消除了管理员在创建任何PVC之前创建卷的需要。只有在有要求时才会配置卷。
- en: In order to enable dynamic provisioning, the administrator needs to create one
    or more storage classes that users can use in their claims to make use of dynamic
    provisioning. These `StorageClass` objects need to specify what provisioner will
    be used along with its parameters. The provisioner depends on the environment.
    Every cloud provider supports different provisioners, so make sure you check with
    your cloud provider if you happen to create this kind of storage class in your
    cluster.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用动态配置，管理员需要创建一个或多个存储类，用户可以在其声明中使用这些存储类来使用动态配置。这些`StorageClass`对象需要指定将使用的配置程序以及其参数。配置程序取决于环境。每个云提供商支持不同的配置程序，因此请确保您在集群中创建此类存储类时与您的云提供商进行核实。
- en: 'Here''s an example of the configuration for creating a new `StorageClass` on
    the AWS platform:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在AWS平台上创建新`StorageClass`的配置示例：
- en: '[PRE100]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In this configuration, the `kubernetes.io/aws-ebs` provisioner is used – EBS
    stands for Elastic Block Store and is only available on AWS. This provisioner
    takes various parameters, including `type`, which we can use to specify what kind
    of disk we want to use for this storage class. Please check the AWS docs to find
    out more about the various parameters we can use and their possible values. The
    provisioner and the parameters required will change based on what cloud provider
    you use.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种配置中，使用了`kubernetes.io/aws-ebs` provisioner - EBS代表弹性块存储，仅在AWS上可用。这个provisioner需要各种参数，包括`type`，我们可以使用它来指定我们想要为这个存储类使用什么类型的磁盘。请查看AWS文档，了解我们可以使用的各种参数及其可能的值。provisioner和所需的参数将根据你使用的云提供商而改变。
- en: 'Once a storage class is created by the cluster administrator, users can create
    a PVC, requesting storage with that storage class name set in the `storageClassName`
    field. Kubernetes will then automatically provision the storage volume, create
    a PV object with that storage class satisfying the claim, and bind it to the claim:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦集群管理员创建了一个存储类，用户就可以创建一个PVC，请求使用该存储类名称在`storageClassName`字段中设置的存储。Kubernetes将自动提供存储卷，创建一个满足要求的存储类的PV对象，并将其绑定到声明：
- en: 'Here''s an example of the configuration for a PVC using the storage class we
    defined previously:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用我们之前定义的存储类的PVC的配置示例：
- en: '[PRE101]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: As we can see, the configuration of the PVC stays the same, except that now,
    we have to use a storage class that has already been created by the cluster administrator
    for us.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，PVC的配置保持不变，只是现在，我们必须使用集群管理员为我们创建的存储类。
- en: Once the claim has been bound to an automatically created Volume, we can create
    pods using that PVC as a Volume, as we saw in the previous section. Once the claim
    is deleted, the Volume is automatically deleted.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明被绑定到一个自动创建的Volume，我们可以创建使用该PVC作为Volume的pod，就像我们在前面的部分中看到的那样。一旦声明被删除，Volume就会被自动删除。
- en: 'Activity 9.01: Creating a Pod That Uses a Dynamically Provisioned PersistentVolume'
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动9.01：创建一个使用动态配置的持久卷的Pod
- en: Consider that you are a cluster administrator, at first, and are required to
    create a custom storage class that will enable the developers using your cluster
    to provision PVs dynamically. To create a storage class on a minikube cluster,
    you can use the `k8s.io/minikube-hostpath` provisioner without any extra parameters,
    similar to what we showed in the `StorageClass` example in the *Dynamic Provisioning*
    section.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下，你是一个集群管理员，首先需要创建一个自定义的存储类，以便让使用你的集群的开发人员动态地提供PV。要在minikube集群上创建一个存储类，你可以使用`k8s.io/minikube-hostpath`
    provisioner，不需要任何额外的参数，就像我们在*动态配置*部分的`StorageClass`示例中所示的那样。
- en: 'Next, acting as a developer or a cluster user, claim a PV with a storage request
    of 100Mi and mount it on the containers inside the pod created using the following
    specifications:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，作为开发人员或集群用户，使用以下规格声明一个带有100Mi存储请求的PV，并将其挂载到使用以下规格创建的pod中的容器中：
- en: The pod should have two containers.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该pod应该有两个容器。
- en: Both the containers should mount the same PV locally.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个容器应该在本地挂载相同的PV。
- en: The first container should write some data into the PV and the second container
    should read and print out the data written by the first container.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个容器应该向PV中写入一些数据，第二个容器应该读取并打印出第一个容器写入的数据。
- en: For simplicity, consider writing a simple string to a file in the PV from the
    first container. For the second container, add a bit of wait time so that the
    second container does not start reading data until it is fully written. Then,
    the latter container should read and print out the content of the file written
    by the first container.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，考虑从第一个容器向PV中的文件写入一个简单的字符串。对于第二个容器，添加一些等待时间，以便第二个容器在完全写入之前不开始读取数据。然后，后一个容器应该读取并打印出第一个容器写入的文件的内容。
- en: Note
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Ideally, you would want to create this deployment to be in a different namespace
    to keep it separate from the rest of the stuff that you created during these exercises.
    So, feel free to create a namespace and create all the objects in this activity
    in that namespace.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您希望将此部署创建在一个不同的命名空间中，以使其与您在这些练习期间创建的其他内容分开。因此，请随意创建一个命名空间，并在该命名空间中创建此活动的所有对象。
- en: 'The high-level steps to perform this activity are as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此活动的高级步骤如下：
- en: Create a namespace for this activity.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此活动创建一个命名空间。
- en: Write the appropriate configuration for the storage class using the given information,
    and create the `StorageClass` object.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用给定的信息编写适当的存储类配置，并创建`StorageClass`对象。
- en: Write the appropriate configuration for the PVC using the storage class created
    in the previous step. Create the PVC using this configuration.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在上一步创建的存储类编写PVC的适当配置。使用此配置创建PVC。
- en: Verify that the claim was bound to an automatically created PV of the same storage
    class that we created in *step 2*.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证声明是否绑定到了与我们在*步骤2*中创建的相同存储类的自动创建的PV。
- en: Write the appropriate configuration for the pod using the given information
    and the PVC from the previous step as a Volume. Create the pod using this configuration.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用给定的信息和上一步的PVC作为卷，编写适当的pod配置。使用此配置创建pod。
- en: Verify that one of the containers can read the content of the file written to
    PV by another container.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证其中一个容器是否可以读取另一个容器写入PV的文件的内容。
- en: 'You should be able to check the logs of the second container and verify that
    the data written by the first container in the PV can be read by the second container,
    as shown in the following output:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够检查第二个容器的日志，并验证第一个容器在PV中写入的数据是否可以被第二个容器读取，如下面的输出所示：
- en: '[PRE102]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Note
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在以下地址找到：[https://packt.live/304PEoD](https://packt.live/304PEoD)。
- en: Summary
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As we mentioned in the introduction, most applications need to store or retrieve
    data for a lot of different reasons. In this chapter, we saw that Kubernetes provides
    various ways of provisioning storage for not just storing the state of an application,
    but also for the long-term storage of data.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍中提到的，大多数应用程序需要出于许多不同的原因存储或检索数据。在本章中，我们看到Kubernetes提供了各种方式来为存储应用程序的状态以及长期存储数据提供存储。
- en: We have covered ways to use storage for our application running inside pods.
    We saw how we can use the different types of Volumes to share temporary data among
    containers running in the same pod. We also learned how to persist data across
    pod restarts. We learned how to manually provision PVs to create PVCs to bind
    to those Volumes, as well as how to create pods that can use these claims as Volumes
    mounted on their containers. Next, we learned how to request storage dynamically
    using only the PVCs with pre-created storage classes. We also learned about the
    life cycle of these volumes with respect to that of the pods.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何在Pod内运行的应用程序中使用存储的方法。我们看到了如何使用不同类型的卷来在同一Pod中运行的容器之间共享临时数据。我们还学习了如何在Pod重新启动时持久化数据。我们学会了如何手动配置PV来创建PVC，并将其绑定到这些卷，以及如何创建可以使用这些声明作为其容器上挂载的卷的Pod。接下来，我们学会了如何仅使用预先创建的存储类和PVC动态请求存储。我们还了解了这些卷与Pod的生命周期之间的关系。
- en: In the next chapter, we will extend these concepts further and learn how to
    store application configurations and secrets.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步扩展这些概念，并学习如何存储应用程序配置和机密信息。
