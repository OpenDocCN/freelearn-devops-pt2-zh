# 三、使用 Ansible 在服务供应商中自动化 Juniper 设备

在本章中，我们将概述如何在典型的**服务供应商** ( **服务供应商**)环境中自动运行 Juniper 设备。我们将探索如何使用 Ansible 与 Juniper 设备交互，以及如何使用各种 Ansible 模块在 Juniper 设备上提供不同的服务和协议。我们将根据以下基本服务点网络的网络图示例进行说明:

![](assets/13923e95-73e7-4fb8-b34e-cc346f018842.png)

下表概述了我们的示例拓扑中的设备及其各自的管理**互联网协议** ( **IPs** ):

| **装置** | **角色** | **供应商** | **管理(MGMT)港** | **MGMT IP** |
| `mxp01` | 路由器 | Juniper vMX 14.1 | `fxp0` | `172.20.1.2` |
| `mxp02` | 路由器 | Juniper vMX 14.1 | `fxp0` | `172.20.1.3` |
| `mxpe01` | 对等路由器 | Juniper vMX 14.1 | `fxp0` | `172.20.1.4` |
| `mxpe02` | 对等路由器 | Juniper vMX 17.1 | `fxp0` | `172.20.1.5` |

本章涵盖的主要配方如下:

*   构建网络清单
*   连接和验证到 Juniper 设备
*   在朱诺操作系统设备上启用**网络配置协议** ( **网络配置**)
*   在 Juniper 设备上配置通用系统选项
*   在 Juniper 设备上配置接口
*   首先在 Juniper 设备上配置**开放最短路径** ( **OSPF** )
*   在 Juniper 设备上配置**多协议标签交换** ( **MPLS** )
*   在 Juniper 设备上配置**边界网关协议** ( **BGP** )
*   在 Juniper 设备上部署配置
*   在 Juniper 设备上配置**第 3 层虚拟专用网络** ( **L3VPN** )服务
*   使用 Ansible 收集 Juniper 设备事实
*   验证 Juniper 设备上的网络可达性
*   从 Juniper 设备中检索操作数据
*   使用 PyEZ 操作表验证网络状态

# 技术要求

本章的代码文件可以在这里找到:[https://github . com/packt publishing/Network-Automation-cook book/tree/master/CH3 _ Junos](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch3_junos)。

以下是本章所基于的软件版本:

*   运行 CentOS 7 的Ansible机器
*   Ansible 2.9
*   运行 Junos OS 14.1R8 和 Junos OS 17.1R1 版本的 Juniper **虚拟 MX** ( **vMX**

查看以下视频，了解《行动守则》:
[https://bit.ly/3ajF4Mp](https://bit.ly/3ajF4Mp)

# 构建网络清单

在本食谱中，我们将概述如何构建和组织 Ansible 清单，以描述前面概述的示例 SP 网络设置。Ansible 库存是 Ansible 的关键部分，因为它定义并分组了应该由 Ansible 管理的设备。

# 准备好

我们创建了一个新文件夹，其中将存放我们将在本章中创建的所有文件。新文件夹名为`ch3_junos`。

# 怎么做...

1.  在新文件夹`ch3_junos`中，我们创建了一个`hosts`文件，内容如下:

```
$ cat hosts

[pe]
mxpe01 Ansible_host=172.20.1.3
mxpe02 Ansible_host=172.20.1.4

[p]
mxp01 Ansible_host=172.20.1.2
mxp02 Ansible_host=172.20.1.6

[junos]
mxpe[01:02]
mxp[01:02]

[core:children]
pe
p
```

2.  创建一个`Ansible.cfg`文件，如下代码所示:

```
$ cat Ansible.cfg

 [defaults]
 inventory=hosts
 retry_files_enabled=False
 gathering=explicit
 host_key_checking=False
```

# 它是如何工作的...

我们使用`hosts`文件构建 Ansible 清单，并定义多个组，以便对网络基础架构中的不同设备进行分组，如下所示:

*   我们创建`PE`组，它引用拓扑中所有的 MPLS **供应商边缘** ( **PE** )节点。
*   我们创建`P`组，它引用拓扑中所有的 MPLS **供应商** ( **P** )节点。
*   我们创建`junos`组，该组引用所有运行 Junos 操作系统的设备作为操作系统。
*   我们创建了`core parent`组，它引用了`PE`和`P`组。

最后，我们创建`Ansible.cfg`文件，并将其配置为指向我们的`hosts`文件，用作 Ansible 库存文件。我们将`gathering`设置为`explicit`以禁用设置模块，该模块默认运行以发现被管理主机的事实。禁用安装模块是强制性的，因为安装模块在网络设备上运行时会失败。

我们可以通过键入以下命令来验证我们的 Ansible 清单的结构和编写是否正确:

```
$ Ansible-inventory --list

 "all": {
 "children": [
 "core",
 "junos",
 "ungrouped"
 ]
 },
 "core": {
 "children": [
 "p",
 "pe"
 ]
 },
 "junos": {
 "hosts": [
 "mxp01",
 "mxp02",
 "mxpe01",
 "mxpe02"
 ]
 },
 "p": {
 "hosts": [
 "mxp01",
 "mxp02"
 ]
 },
 "pe": {
 "hosts": [
 "mxpe01",
 "mxpe02"
 ]
 }
```

# 连接和验证到 Juniper 设备

在本食谱中，我们将概述如何通过**安全外壳** ( **SSH** )从 Ansible 连接和认证到 Juniper 设备，以便开始管理 Juniper 设备。我们将概述如何使用 SSH 密钥作为身份验证方法来建立 Ansible 和 Juniper 设备之间的通信。

# 准备好

为了遵循该配方，应根据之前的配方构建一个Ansible的库存文件。必须配置 Ansible 控制机器和网络中所有设备之间的 IP 可达性。

# 怎么做...

1.  在 Ansible 机器上，在我们的`ch3_junos`工作目录中创建私有和公共 SSH 密钥，如下代码所示:

```
$ SSH-keygen -t rsa -b 2048 -f Ansible_SSH_key

Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in Ansible_SSH_key.
Your public key has been saved in Ansible_SSH_key.pub.
The key fingerprint is:
SHA256:aCqgMYKAWIkv3nVz/q9cYp+2n3doD9jpgw/jeWWcVWI Ansible@centos7.localdomain
```

2.  捕获上一步中创建的公钥，如下所示:

```
$ cat Ansible_SSH_key.pub
 SSH-rsa SSH-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0/wvdC5ycAanRorlfMYDMAv5OTcYAALlE2bdboajsQPQNEw1Li3N0J50OJBWXX+FFQuF7JKpM32vNQjQN7BgyaBWQGxv+Nj0ViVP+8X8Wuif0m6bFxBYSaPbIbGogDjPu4qU90Iv48NGOZpcPLqZthtuN7yZKPshX/0YJtXd2quUsVhzVpJnncXZMb4DZQeOin7+JVRRrDz6KP6meIylf35mhG3CV5VqpoMjYTzkDiHwIrFWVMydd4C77RQu27N2HozUtZgJy9KD8qIJYVdP6skzvp49IdInwhjOA+CugFQuhYhHSoQxRxpws5RZlvrN7/0h0Ahc3OwHaUWD+P7lz Ansible@centos7.localdomain
```

3.  在 Juniper 设备上，添加一个名为`admin`的新用户，并指定我们将使用 SSH 密钥对此用户进行身份验证。将在 Ansible 机器上创建的公共 SSH 密钥复制到设备，如以下代码所示:

```
[edit system login]
Ansible@mxpe01# show
user admin {
 uid 2001;
 class super-user;
 authentication {
 SSH-rsa " SSH-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0/wvdC5ycAanRorlfMYDMAv5OTcYAALlE2bdboajsQPQNEw1Li3N0J50OJBWXX+FFQuF7JKpM32vNQjQN7BgyaBWQGxv+Nj0ViVP+8X8Wuif0m6bFxBYSaPbIbGogDjPu4qU90Iv48NGOZpcPLqZthtuN7yZKPshX/0YJtXd2quUsVhzVpJnncXZMb4DZQeOin7+JVRRrDz6KP6meIylf35mhG3CV5VqpoMjYTzkDiHwIrFWVMydd4C77RQu27N2HozUtZgJy9KD8qIJYVdP6skzvp49IdInwhjOA+CugFQuhYhHSoQxRxpws5RZlvrN7/0h0Ahc3OwHaUWD+P7lz Ansible@centos7.localdomain"; ## SECRET-DATA
 }
}
```

# 它是如何工作的...

我们首先在 Ansible 控制机器上创建公共和私有 SSH 密钥，使用`SSH-keygen`命令并指定以下选项:

*   我们用`-t`选项指定加密算法，并将其设置为`rsa`。
*   我们使用`-b`选项指定加密密钥的大小，并将大小设置为`2048`位。
*   我们使用`-f`选项指定保存私钥和公钥的位置，并指定将要生成的公钥和私钥的名称，该名称将是`Ansible_SSH_key`。

运行该命令后，我们将看到生成了以下两个文件(私有和公共 SSH 密钥)，如下所示:

```
$ ls -la | grep Ansible_SSH_key
 -rw------- 1 Ansible Ansible 1679 Dec 31 23:41 Ansible_SSH_key
 -rw-r--r-- 1 Ansible Ansible 409 Dec 31 23:41 Ansible_SSH_key.pub
```

在我们清单中的所有 Juniper 设备上，我们创建`admin`用户，并指定使用 SSH 密钥进行身份验证。我们将在 Ansible 控制机器上创建的公钥内容粘贴到这个新用户的`authentication`节下。通过这种配置，任何拥有相应私钥的主机都可以作为`admin`用户进行身份验证并登录到 Juniper 设备。

为了测试和验证我们已经从计算节点成功登录到 Junos 操作系统设备，我们可以使用下面代码中显示的 Ansible 命令进行测试:

```
$ Ansible all -m ping -u admin --private-key Ansible_SSH_key -c network_cli

mxp02 | SUCCESS => {
 "changed": false,
 "ping": "pong"
}
mxpe02 | SUCCESS => {
 "changed": false,
 "ping": "pong"
}
mxpe01 | SUCCESS => {
 "changed": false,
 "ping": "pong"
}
mxp01 | SUCCESS => {
 "changed": false,
 "ping": "pong"
}
```

我们使用`-u`选项指定连接到设备的用户名，并使用`–private-key`选项指定私有 SSH 密钥。最后，我们使用`-c`选项来指定用于连接到受管设备的连接插件，在这种情况下，我们使用`network_cli`连接插件来打开与受管 Juniper 设备的 SSH 会话。

# 还有更多...

为了使用我们在行动手册中生成的 SSH 密钥，我们可以在 Ansible 中指定用户名和 SSH 私钥文件，我们将使用它们作为主机或组变量向 Juniper 设备进行身份验证。在我们的例子中，我们将这些变量设置为`junos`组的组变量。我们创建`group_vars`目录，创建`junos.yml`文件，并指定变量，如下代码所示:

```
$ cat group_vars/junos.yml

Ansible_user: admin
 Ansible_SSH_private_key_file: Ansible_SSH_key
```

我们使用`Ansible`命令再次测试 Ansible 和我们的设备之间的连接；但是，这次没有指定任何参数，如下面的代码所示:

```
$ Ansible all -m ping -c network_cli

mxp02 | SUCCESS => {
 "changed": false,
 "ping": "pong"
}
mxpe02 | SUCCESS => {
 "changed": false,
 "ping": "pong"
}
mxpe01 | SUCCESS => {
 "changed": false,
 "ping": "pong"
}
mxp01 | SUCCESS => {
 "changed": false,
 "ping": "pong"
} 
```

# 在朱诺操作系统设备上启用网络配置

在本食谱中，我们将概述如何在 Junos 操作系统设备上启用 NETCONF 协议。这项任务至关重要，因为我们将在所有未来的食谱中使用 NETCONF 应用编程接口来管理 Juniper 设备。与传统的 SSH 访问方法相比，NETCONF API 提供了几个优势，这就是为什么我们将在与 Junos 操作系统设备的所有交互中使用它。

# 准备好

作为该配方的先决条件，必须存在一个 Ansible 清单文件，以及按照之前的配方部署和运行的 SSH 认证。

# 怎么做...

1.  创建一个名为`pb_jnpr_net_build.yml`的新剧本，如下代码所示:

```
$ cat pb_jnpr_net_build.yml

- name: Build Juniper SP Network
 hosts: junos
 tasks:
 - name: "Enable NETCONF"
 junos_netconf:
 netconf_port: 830
 state: present
 vars:
 Ansible_connection: network_cli
 tags: netconf
```

2.  用连接细节更新`group_vars/junos.yml`文件，如下代码所示:

```
$ cat group_vars/junos.yml

Ansible_network_os: junos
Ansible_connection: netconf
```

# 它是如何工作的...

为了开始通过 NETCONF 与 Junos 操作系统设备进行交互，我们需要首先启用它，因此我们需要在设备中进行初始 SSH 并启用 NETCONF。这就是为什么我们使用`network_cli`Ansible连接，以便通过传统的 SSH 与朱诺操作系统设备连接。为了使用`network_cli`连接插件，我们需要将`Ansible_network_os`设置为`junos`。

由于我们将在未来的所有食谱中与 Juniper 设备的所有交互中使用 NETCONF API，因此我们仅通过`vars`属性为该剧本中的`junos_netconf`任务启用了`network_cli`插件。但是，对于我们将在本行动手册中添加的所有未来任务，我们将使用在`group_vars/junos.yml`文件中的`Ansible_connection`属性中指定的`netconf`连接。

我们创建了一个名为`pb_jnpr_net_build.yml`的新剧本，在第一个任务中，我们使用`junos_netconf`模块在远程 Junos OS 操作系统设备上启用 NETCONF 协议。我们声明将使用的 NETCONF 端口(默认情况下，它是`830`)，并且我们概述了该配置必须通过`state: present`指令出现在远程设备上。

运行行动手册后，我们将看到所有 Junos 操作系统设备都配置了 NETCONF，如以下代码所示:

```
admin@mxpe01# show system services
SSH;
netconf {
 SSH {
 port 830;
 }
}
```

# 在 Juniper 设备上配置通用系统选项

在本食谱中，我们将概述如何配置一些通用系统选项，如主机名和**域名系统** ( **域名系统**)服务器，并在 Juniper 设备上调配用户。

# 准备好

为了遵循这个方法，假设已经建立了一个 Ansible 清单，并且按照前面的方法，在所有 Juniper 设备上启用了 NETCONF。

# 怎么做...

1.  用以下参数更新`group_vars/all.yml`文件，定义`dns`和系统用户等各种系统级参数，如下代码所示:

```
$ cat group_vars/all.yml
tmp_dir: ./tmp
config_dir: ./configs
global:
 dns:
 - 172.20.1.1
 - 172.20.1.15
 root_pwd: $1$ciI4raxU$XfCVzABJKdALim0aWVMql0
 users:
 -   role: super-user
 SSH_key: Ansible_SSH_key.pub
 username: admin
 -   hash: $1$mR940Z9C$ipX9sLKTRDeljQXvWFfJm1
 passwd: 14161C180506262E757A60
 role: super-user
 username: Ansible
```

2.  创建名为`pb_jnpr_basic_config.yml`的新行动手册，包括以下任务，以在 Juniper 设备上设置`dns`、`hostname`和系统用户:

```
$ cat pb_jnpr_basic_config.yml
---
- name: Configure Juniper Devices
 hosts: junos
 tasks:
 - name: "Conifgure Basic System config"
 junos_system:
 hostname: "{{ inventory_hostname }}"
 name_servers: "{{ global.dns }}"
 state: present
 - name: "Configure Users"
 junos_user:
 name: "{{ item.username }}"
 role: "{{ item.role }}"
 SSHkey: "{{ lookup ('file', item.SSH_key) }}"
 state: present
 with_items: "{{ global.users | selectattr('SSH_key','defined') | list }}"
```

# 它是如何工作的...

Ansible 提供声明性模块来配置 Juniper 设备上的各种系统级参数。`junos_system` Ansible 模块使我们能够在 Juniper 设备上设置主机名和 DNS 服务器。`junos_user`模块为我们提供了在 Juniper 设备上为系统用户设置基本参数的能力。在本例中，我们设置了所有使用 SSH 密钥作为身份验证方法的用户，并且我们遍历`users`数据结构，只选择定义了`SSH_key`选项的用户。

运行本行动手册后，我们可以看到设备上的配置已经更新，如以下代码块所示:

```
$ Ansible@mxpe01# show system
host-name mxpe01;
}
name-server {
 172.20.1.1;
 172.20.1.15;
}
login {
 user admin {
 uid 2001;
 class super-user;
 authentication {
 SSH-rsa "SSH-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0/wvdC5ycAanRorlfMYDMAv5OTcYAALlE2bdboajsQPQNEw1Li3N0J50OJBWXX+FFQuF7JKpM32vNQjQN7BgyaBWQGxv+Nj0ViVP+8X8Wuif0m6bFxBYSaPbIbGogDjPu4qU90Iv48NGOZpcPLqZthtuN7yZKPshX/0YJtXd2quUsVhzVpJnncXZMb4DZQeOin7+JVRRrDz6KP6meIylf35mhG3CV5VqpoMjYTzkDiHwIrFWVMydd4C77RQu27N2HozUtZgJy9KD8qIJYVdP6skzvp49IdInwhjOA+CugFQuhYhHSoQxRxpws5RZlvrN7/0h0Ahc3OwHaUWD+P7lz Ansible@centos7.localdomain"; ## SECRET-DATA
 }
 }
```

# 还有更多...

我们在本节中概述的声明性 Ansible 模块提供了一种为 Juniper 设备配置基本系统级参数的简单方法。然而，它们可能没有涵盖我们需要在 Juniper 设备上设置的所有参数。为了更好地控制和灵活地在 Juniper 设备上配置系统级参数，我们可以使用 Jinja2 模板和 Ansible `template`模块来生成部署所需的特定系统级配置。在本节中，我们将概述这种方法，以实现这一目标，这是我们将在后续配方中用于为其他设备生成配置的方法。

我们将重用这种方法来为不同部分的 Juniper 设备生成配置，例如系统、接口、OSPF 和 MPLS。我们将创建一个 Ansible 角色，以便包含生成最终配置所需的所有 Jinja2 模板和任务，我们将把最终配置推送到我们的设备上。以下过程概述了创建角色和使用该角色生成配置所需的步骤:

1.  创建一个新的`roles`目录，添加一个名为`build_router_config`的新角色，目录结构如下:

```
$ tree roles/
 roles/
 └── build_router_config
 ├── tasks
 └── templates
```

2.  在`tasks`文件夹下，创建一个`build_config_dir.yml` YAML 文件，创建所需的文件夹来存储将要生成的配置，如下所示:

```
$ cat roles/build_router_config/tasks/build_config_dir.yml

---
- name: Create Config Directory
 file: path={{config_dir}} state=directory
 run_once: yes

- name: Create Temp Directory per Node
 file: path={{tmp_dir}}/{{inventory_hostname}} state=directory

- name: SET FACT >> Build Directory
 set_fact:
 build_dir: "{{tmp_dir}}/{{inventory_hostname}}"
```

3.  在`templates`文件夹下，新建一个名为`junos`的文件夹，在该文件夹内新建一个名为`mgmt.j2`的 Jinja2 模板，内容如下:

```
$ cat roles/build_router_config/templates/junos/mgmt.j2

system {
 host-name {{inventory_hostname}};
 no-redirects;
{%  if global.dns is defined %}
 name-server {
{%      for dns_server in global.dns %}
 {{dns_server}};
{%      endfor %}
 }
{%  endif %}
 root-authentication {
 encrypted-password "{{ global.root_pwd}}"; ## SECRET-DATA
 }
 login {
{%      for user in global.users if user.hash is defined %}
 user {{ user.username }} {
 class super-user;
 authentication {
 encrypted-password "{{user.hash}}"; ## SECRET-DATA
 }
 }
{%      endfor %}
{%      for user in global.users if user.SSH_key is defined %}
 user {{ user.username }} {
 class {{ user.role }};
 authentication {
 SSH-rsa "{{lookup('file',user.SSH_key)}}"; ## SECRET-DATA
 }
 }
{%      endfor %}
 }
}
```

4.  在`tasks`文件夹下，创建一个名为`build_device_config.yml`的新 YAML 文件，使用以下任务创建系统配置:

```
$ cat roles/build_router_config/tasks/build_device_config.yml

---
- name: "System Configuration"
 template:
 src: "{{Ansible_network_os}}/mgmt.j2"
 dest: "{{build_dir}}/00_mgmt.cfg"
 tags: mgmt
```

5.  在`tasks`文件夹下创建`main.yml`文件，任务如下:

```
$ cat roles/build_router_config/tasks/main.yml

---
- name: Build Required Directories
 import_tasks: build_config_dir.yml

- name: Build Device Configuration
 import_tasks: build_device_config.yml

- name: "Remove Old Assembled Config"
 file:
 path: "{{config_dir}}/{{ inventory_hostname }}.cfg"
 state: absent

- name: Build Final Device Configuration
 assemble:
 src: "{{ build_dir }}"
 dest: "{{config_dir}}/{{ inventory_hostname }}.cfg"

- name: Remove Build Directory
 file: path={{ tmp_dir }} state=absent
 run_once: yes
```

6.  使用以下任务更新`pb_jnpr_net_build.yml`行动手册，为我们库存中的所有 Juniper 设备生成配置:

```
$ cat pb_jnpr_net_build.yml

- name: Build Device Configuration
 import_role:
 name: build_router_config
 vars:
 Ansible_connection: local
 tags: build
```

在这种方法中，我们创建了一个名为`build_router_config`的角色，并创建了一个名为`mgmt.j2`的新 Jinja2 模板，其中包括用于 Junos OS 系统级配置的模板。我们使用 Ansible `template`模块，以便使用`group_vars/all.yml`文件下定义的 Ansible 变量渲染 Jinja2 模板。为了保存每台设备的配置，我们创建了`configs`文件夹目录，其中存储了每台设备的最终配置。

因为我们将使用这种方法来为每个部分(MGMT、OSPF、MPLS 等)生成配置，所以我们将把每个部分分割成一个单独的 Jinja2 模板，并且我们将在一个单独的文件中生成每个部分。我们使用`assemble`模块将所有这些不同的部分分组到一个配置文件中，我们将该文件存储在`configs`目录中。这是每个设备的`final`和`assembled`配置文件。我们将每个部分的临时配置片段存储在每个设备的临时文件夹中，并在剧本运行结束时删除该临时文件夹。这是因为我们为设备组装了最终配置，我们不再需要这些配置片段。

In this playbook, we set the `Ansible_connection` to `local` as we don't need to connect to the devices in order to run any of the tasks within our role. We are only generating the configuration on the Ansible control machine, therefore all the tasks need to run locally on the Ansible control machine. Therefore, there is no need to connect to the remotely managed nodes.

运行剧本后，我们可以看到在`configs`目录中创建了以下配置文件:

```
$ tree configs/
 configs/
 ├── mxp01.cfg
 ├── mxp02.cfg
 ├── mxpe01.cfg
 └── mxpe02.cfg
```

我们可以以`mxpe01`设备生成的配置为例，如下所示:

```
$ cat configs/mxpe01.cfg
system {
 host-name mxpe01;
 no-redirects;
 name-server {
 172.20.1.1;
 172.20.1.15;
 }
 root-authentication {
 encrypted-password "$1$ciI4raxU$XfCVzABJKdALim0aWVMql0"; ## SECRET-DATA
 }
 login {
 user Ansible {
 class super-user;
 authentication {
 encrypted-password "$1$mR940Z9C$ipX9sLKTRDeljQXvWFfJm1"; ##
SECRET-DATA
 }
 }
 user admin {
 class super-user;
 authentication {
 SSH-rsa "SSH-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0/wvdC5ycAanRorlfMYDMAv5OTcYAALlE2bdboajsQPQNEw1Li3N0J50OJBWXX+FFQuF7JKpM32vNQjQN7BgyaBWQGxv+Nj0ViVP+8X8Wuif0m6bFxBYSaPbIbGogDjPu4qU90Iv48NGOZpcPLqZthtuN7yZKPshX/0YJtXd2quUsVhzVpJnncXZMb4DZQeOin7+JVRRrDz6KP6meIylf35mhG3CV5VqpoMjYTzkDiHwIrFWVMydd4C77RQu27N2HozUtZgJy9KD8qIJYVdP6skzvp49IdInwhjOA+CugFQuhYhHSoQxRxpws5RZlvrN7/0h0Ahc3OwHaUWD+P7lz Ansible@centos7.localdomain"; ## SECRET-DATA
 }
 }
 }
}
```

在后续的食谱中，我们将概述如何使用另一个 Ansible 模块将生成的配置推送到 Juniper 设备中。

# 请参见...

有关 Ansible `template`模块以及该模块支持的不同参数的更多信息，请参考以下网址:[https://docs . ansi ble . com/ansi ble/latest/modules/template _ module . html](https://docs.ansible.com/ansible/latest/modules/template_module.html)。

有关 Ansible `assemble`模块和该模块支持的不同参数的更多信息，请参考以下网址:[https://docs . ansi ble . com/ansi ble/latest/modules/assembly _ module . html](https://docs.ansible.com/ansible/latest/modules/assemble_module.html)。

# 在 Juniper 设备上配置接口

在本食谱中，我们将概述如何管理 Juniper 设备上的接口。这允许我们为我们的接口设置不同的参数，例如**最大转换单元** ( **MTU** )和 Juniper 设备上的 IP 地址。

# 准备好

为了遵循这个方法，假设已经建立了一个 Ansible 清单，并且按照前面的方法，在所有 Juniper 设备上启用了 NETCONF。

# 怎么做...

1.  更新`group_vars/all.yml` YAML 文件，在我们的示例网络拓扑中包含所有**点对点** ( **P2P** )和环回接口的以下数据:

```
p2p_ip:
 mxp01:
 - {port: ge-0/0/0, ip: 10.1.1.2 , peer: mxpe01, pport: ge-0/0/0, peer_ip: 10.1.1.3}
 - {port: ge-0/0/1, ip: 10.1.1.4 , peer: mxpe02, pport: ge-0/0/0, peer_ip: 10.1.1.5}
 - {port: ge-0/0/3, ip: 10.1.1.0 , peer: mxp02, pport: ge-0/0/3, peer_ip: 10.1.1.1}
 mxp02:
 <-- Output Trimmed for brevity ------>
 mxpe01:
 <-- Output Trimmed for brevity ------>
 mxpe02:
 <-- Output Trimmed for brevity ------>
 xrpe03:
 <-- Output Trimmed for brevity ------>
lo_ip:
 mxp01: 10.100.1.254/32
 mxp02: 10.100.1.253/32
 mxpe01: 10.100.1.1/32
 mxpe02: 10.100.1.2/32
 xrpe03: 10.100.1.3/32
```

2.  使用以下任务更新`pb_jnpr_basic_config.yml`行动手册，以在我们的 Juniper 设备上设置接口:

```
- name: "Configure the Physical Interfaces"
 junos_interface:
 name: "{{ item.port }}"
 enabled: true
 description: "peer:{{item.peer}} remote_port:{{item.pport }}"
 mtu: "{{ global.mtu | default(1500) }}"
 with_items: "{{p2p_ip[inventory_hostname]}}"
 tags: intf

- name: "Configure IP Addresses"
 junos_l3_interface:
 name: "{{ item.port }}"
 ipv4: "{{ item.ip }}/{{ global.p2p_prefix }}"
 state: present
 with_items: "{{ p2p_ip[inventory_hostname] }}"
 tags: intf
```

# 它是如何工作的...

我们在`group_vars/all.yml`文件中的两个主要数据结构下定义了示例网络拓扑中所有接口的所有数据。我们使用`p2p_ip`字典对样本网络中的所有 P2P IP 地址进行建模，并使用`lo_ip`字典为我们的节点指定环回 IP 地址。

我们使用`junos_interface` Ansible 模块来启用接口并设置接口的基本参数，例如 MTU 和描述。我们循环每个设备的`p2p_ip`数据结构，并为网络清单中所有设备的每个接口设置正确的参数。我们使用`junos_l3_interface` Ansible 模块在所有设备的示例网络拓扑中的所有接口上设置正确的 IPv4 地址。

一旦我们运行剧本，我们可以看到接口按照要求配置，如`mxpe01`设备所示:

```
Ansible@mxpe01# show interfaces
ge-0/0/0 {
 description "peer:mxp01 remote_port:ge-0/0/0";
 mtu 1500;
 unit 0 {
 family inet {
 address 10.1.1.3/31;
 }
 }
}
ge-0/0/1 {
 description "peer:mxp02 remote_port:ge-0/0/0";
 mtu 1500;
 unit 0 {
 family inet {
 address 10.1.1.9/31;
 }
 }
}
```

# 还有更多...

如果我们需要对接口配置有更多的控制，并设置我们在本节中概述的声明性 Ansible 模块没有涉及的参数，我们可以使用 Jinja2 模板来实现这个目标。使用与我们在前面的系统配置方法中概述的完全相同的方法，我们可以生成 Juniper 设备所需的接口配置。

使用我们在前面的配方中创建的同一个 Ansible 角色，我们可以扩展它来为我们的 Juniper 设备生成接口配置。我们使用以下步骤来完成此任务:

1.  在`templates`文件夹中创建新的名为`intf.j2`的 Jinja2 模板文件，数据如下:

```
$ cat roles/build_router_config/templates/junos/intf.j2

interfaces {
{% for intf in p2p_ip[inventory_hostname] | sort(attribute='port') %}
 {{ intf.port.split('.')[0] }} {
 description "peer:{{intf.peer}} -- peer_port: {{intf.pport}}"
 unit 0 {
 family inet {
 address {{intf.ip}}/{{global.p2p_prefix}};
 }
 family mpls;
 }
 }
 {% endif %}
 {% endfor %}
 lo0 {
 unit 0 {
 family inet {
 address {{lo_ip[inventory_hostname]}};
 }
 }
 }
```

2.  用新任务更新`tasks`目录下的`build_device_config.yml`文件，生成界面配置，如下:

```
$ cat roles/build_router_config/tasks/build_device_config.yml

<-- Output Trimmed for brevity ------>

- name: "Interface Configuration"
 template:
 src: "{{Ansible_network_os}}/intf.j2"
 dest: "{{build_dir}}/01_intf.cfg"
 tags: intf
```

这是运行剧本后为`mxp02`设备生成的界面配置:

```
interfaces {
 ge-0/0/0 {
 description "peer:mxpe01 -- peer_port: ge-0/0/1"
 unit 0 {
 family inet {
 address 10.1.1.8/31;
 }
 family mpls;
 }
 }
 ge-0/0/1 {
 description "peer:mxpe02 -- peer_port: ge-0/0/1"
 unit 0 {
 family inet {
 address 10.1.1.10/31;
 }
 family mpls;
 }
 }
<--   Output Trimmed for brevity ------>

 lo0 {
 unit 0 {
 family inet {
 address 10.100.1.253/32;
 }
 }
 }
```

# 在 Juniper 设备上配置 OSPF

在本菜谱中，我们将概述如何在 Juniper 设备上将 OSPF 配置为示例网络拓扑中的**内部网关协议** ( **IGP** )，以及 OSPF 链路类型和 OSPF 接口成本等不同的 OSPF 参数。

# 怎么做...

1.  在`templates/junos`目录中创建新的 Jinja2 文件`ospf.j2`，包含以下数据:

```
$ cat roles/build_router_config/templates/junos/ospf.j2

 protocols {
 ospf {
 area {{global.ospf_area}} {
{%          for intf in p2p_ip[inventory_hostname]|sort(attribute='port') %}
 interface {{ intf.port }} {
 interface-type p2p;
 metric {{intf.cost | default(100)}};
 }
{%          endfor %}
 interface lo0.0 {
 passive;
 }
 }
 }
}
```

2.  在`tasks`文件夹内的`junos_build_config.yml`文件中，添加以下任务:

```
$ cat roles/build_router_config/tasks/build_device_config.yml

<-- Output Trimmed for brevity ------>

- name: "OSPF Configuration"
 template:
 src: "{{Ansible_network_os}}/ospf.j2"
 dest: "{{config_dir}}/{{ inventory_hostname }}/02_ospf.cfg"
```

# 它是如何工作的...

我们使用在`all.yml`文件的`p2p_ip`数据结构中声明的相同接口数据，以便在示例网络中的网络设备上配置 OSPF 配置。我们使用在`templates/junos`目录下的`ospf.j2`文件中定义的新 Jinja2 模板来捕获需要在 Juniper 设备上实现的 OSPF 配置参数(OSPF 成本、OSPF 接口类型等)。

在`tasks/Juniper_build_config.yml`文件下，我们添加了一个新任务，该任务使用`ospf.j2` Jinja2 模板来渲染 Jinja2 模板，并输出 Ansible 清单中列出的每个设备的 OSPF 配置部分。

以下片段概述了在运行新任务的剧本后为`mxpe01`设备生成的 OSPF 配置:

```
$ cat configs/mxpe01.cfg

 <--   Output Trimmed for brevity ------>

protocols {
 ospf {
 area 0 {
 interface ge-0/0/0 {
 interface-type p2p;
 metric 100;
 }
 interface ge-0/0/1 {
 interface-type p2p;
 metric 100;
 }
 interface lo0.0 {
 passive;
 }
 }
 }
}
```

# 在 Juniper 设备上配置 MPLS

在本食谱中，我们将概述如何在 Juniper 设备上配置 MPLS 以及一些相关协议，如**标签分发协议** ( **LDP** )和**资源预留协议** ( **RSVP** )。我们将概述如何使用 Ansible 和 Jinja2 模板生成所需的 MPLS 配置。

# 怎么做...

1.  用以下数据在`templates/junos`目录下创建一个新的 Jinja2 文件`mpls.j2`:

```
$ cat roles/build_router_config/templates/junos/mpls.j2

 protocols {
 ldp {
{%      for intf in p2p_ip[inventory_hostname]|sort(attribute='port') %}
 interface {{intf.port}}.{{intf.vlan|default('0')}};
{%      endfor %}
 interface lo0.0;
 }
 rsvp {
{%      for intf in p2p_ip[inventory_hostname]|sort(attribute='port') %}
 interface {{intf.port}}.{{intf.vlan|default('0')}};
{%      endfor %}
 }
 mpls {
{%      for intf in p2p_ip[inventory_hostname]|sort(attribute='port') %}
 interface {{intf.port}}.{{intf.vlan|default('0')}};
{%      endfor %}
 }
}
```

2.  在`tasks`文件夹内的`build_device_config.yml`文件中，添加以下任务:

```
$ cat roles/build_router_config/tasks/build_device_config.yml

<-- Output Trimmed for brevity ------>

- name: "MPLS Configuration"
 template:
 src: "{{Ansible_network_os}}/mpls.j2"
 dest: "{{config_dir}}/{{ inventory_hostname }}/03_mpls.cfg"
```

# 它是如何工作的...

我们使用与配置接口和 OSPF 相同的方法，通过使用 Jinja2 模板为清单中的 Juniper 设备生成所需的 MPLS 配置，以下是`mxpe02`路由器的 MPLS 配置示例:

```
protocols {
    ldp {
        interface ge-0/0/0.0;
        interface ge-0/0/1.0;
        interface lo0.0;
    }
    rsvp {
        interface ge-0/0/0.0;
        interface ge-0/0/1.0;
    }
    mpls {
        interface ge-0/0/0.0;
        interface ge-0/0/1.0;
    }
}
```

# 在 Juniper 设备上配置 BGP

在本食谱中，我们将概述如何在 Juniper 设备上配置 BGP。我们将概述如何设置 BGP 和 BGP **路由反射器** ( **RR** )作为示例拓扑的一部分，以及支持**虚拟专用网络** ( **VPN** )服务所需的所有 BGP 地址系列。

# 怎么做...

1.  用以下 BGP 信息更新`group_vars/all.yml`文件:

```
bgp_topo:
  rr: mxp01
  af:
  - inet
  - inet-vpn
```

2.  对于 Ansible 清单中的每个节点，我们在`host_vars`目录下创建一个名为`bgp.yml`的文件。该文件保存每个节点的 BGP 信息和 BGP 对等体。这是`mxpe01`装置的例子:

```
$ cat host_vars/mxpe01/bgp.yml

bgp_asn: 65400

bgp_peers:
 - local_as: 65400
 peer: 10.100.1.254
 remote_as: 65400
```

3.  在`templates/junos`目录下创建一个新的 Jinja2 文件`bgp.j2`，包含以下数据:

```
$ cat roles/build_router_config/templates/junos/bgp.j2

 protocols {
{%  if bgp_peers is defined %}
 bgp {
 group Core {
 type internal;
 local-address {{ lo_ip[inventory_hostname] | ipaddr('address')}};
{%          if bgp_topo.rr == inventory_hostname %}
 cluster {{ lo_ip[inventory_hostname].split('/')[0] }};
{%          endif %}
{%          for af in bgp_topo.af %}
{%          if af == 'inet' %}
 family inet {
 unicast;
 }
{%          endif %}
{%          if af == 'inet-vpn' %}
 family inet-vpn {
 unicast;
 }
{%          endif %}
<--   Output Trimmed for brevity ------>
{%          endfor %}
{%          for p in bgp_peers %}
 neighbor {{ p.peer}};
{%          endfor %}
 }
 }
{%  endif %}
}
```

4.  在`tasks`文件夹内的`build_device_config.yml`文件中，添加以下突出显示的任务:

```
$ cat roles/build_router_config/tasks/build_device_config.yml

<-- Output Trimmed for brevity ------>

- name: "BGP Configuration"
 template:
 src: "{{Ansible_network_os}}/bgp.j2"
 dest: "{{config_dir}}/{{ inventory_hostname }}/04_bgp.cfg"
```

# 它是如何工作的...

使用与前面所有方法相似的方法，我们使用 Jinja2 模板为 Juniper 设备生成 BGP 配置。但是，在本节中，我们在两个不同的地方声明了 BGP 参数，这两个地方是`group_vars`和`host_vars`目录。在`group_vars/all.yml`文件中，我们声明了我们的 BGP 拓扑的整体参数，例如我们将使用的 RR，以及我们将配置哪些地址族。对于清单中的每个节点，我们在`host_vars`目录中创建了一个目录，在这个目录中，我们创建了一个`bgp.yml`文件。这个新的 YAML 文件保存了我们清单中每个节点的 BGP 对等体。我们使用在这两个位置定义的数据来呈现每个设备的 BGP 配置。

这是`mxp01`路由器的 BGP 配置示例，也就是我们拓扑中的 RR:

```
protocols {
 bgp {
 group Core {
 type internal;
 local-address 10.100.1.254;
 cluster 10.100.1.254;
 family inet {
 unicast;
 }
 family inet-vpn {
 unicast;
 }
 neighbor 10.100.1.1;
 neighbor 10.100.1.2;
 neighbor 10.100.1.3;
 }
 }
}
```

# 在 Juniper 设备上部署配置

在本食谱中，我们将概述如何使用 Ansible 在 Juniper 设备上推送我们在前面所有部分中通过 Jinja2 模板生成的配置。这为我们提供了将我们创建的任何自定义配置推送到 Juniper 设备的能力。

# 准备好

该方法要求在 Juniper 设备上启用 NETCONF。

# 怎么做...

1.  在`pb_junos_push_con`文件中，添加以下任务:

```
$ cat pb_jnpr_net_build.yml

<-- Output Trimmed for brevity ------>

- name: "Deploy Configuration"
 junos_config:
 src: "{{config_dir}}/{{ inventory_hostname }}.cfg"
```

# 它是如何工作的...

在前面的配方中，我们为 Juniper 设备生成了不同的配置部分，如接口、OSPF、MPLS 和 BGP。我们使用了`assemble`模块，以便在一个配置文件中对每个节点的所有这些部分进行分组。该文件存储在每个设备的`configs`文件夹中。

我们使用`junos_config`模块将生成的配置文件推送到网络清单中的每台设备。我们可以使用`update`参数来控制我们想要推送的配置如何与设备上的现有配置合并。它支持以下选项:

*   `merge`:这将导致我们文件中的配置与设备上的配置(候选配置)合并。此选项是使用的默认选项。
*   `Override/update`:这将导致我们文件中的配置覆盖被管理设备上的完整配置。

我们可以使用`check`模式在试运行模式下运行我们的剧本。在这种情况下，我们将把配置推送到设备，而不提交配置。这使我们能够检查将推送到设备的更改。这可以通过以下方式实现:

```
$ Ansible-playbook pb_jnpr_net_build.yml -l mxpe01 --check –diff
```

我们使用`–check`选项在检查模式下运行剧本(试运行)，使用`–diff`选项输出将推送到我们设备的更改。

# 还有更多...

`junos_config`模块还支持 Junos OS OS 支持的回滚功能，因此我们可以添加另一个任务来回滚配置并控制其运行方式，如下所示:

```
$ cat pb_jnpr_net_build.yml

<-- Output Trimmed for brevity ------>

- name: "Rollback config"
 junos_config:
 rollback: "{{ rollback | default('1') | int }}"
 tags: rollback, never
```

在前面的剧本中，我们回到了配置的最后一个版本。但是，通过更改`rollback`属性中的数字，我们可以控制要回滚到的配置版本。此外，我们使用标记是为了仅在剧本运行期间指定`rollback`标记时执行该任务，如以下代码片段所示:

```
$ Ansible-playbook pb_jnpr_net_build.yml --tags rollback -l mxpe01
```

我们可以指定另一个回滚点，如下所示:

```
$ Ansible-playbook pb_jnpr_net_build.yml --tags rollback -l mxpe01 –e rollback=2
```

# 请参见...

欲了解更多关于`junos_config`模块和该模块支持的不同参数的信息，请访问以下网址:[https://docs . ansi ble . com/ansi ble/latest/modules/Junos _ config _ module . html](https://docs.ansible.com/ansible/latest/modules/junos_config_module.html)[。](https://docs.ansible.com/ansible/latest/modules/junos_config_module.html)

# 在 Juniper 设备上配置 L3VPN 服务

在本食谱中，我们将概述如何使用各种 Ansible 模块在 Juniper 设备上建模和配置 L3VPNs。这使我们能够使用**基础设施作为代码** ( **IaC** )实践来建模我们的服务，并利用 Ansible 来部署和推送所需的配置，以在 Juniper 设备上部署 L3VPN。

# 准备好

必须在 Juniper 设备上启用 NETCONF，才能使用本食谱中的 Ansible 模块。

# 怎么做...

1.  创建一个名为`l3vpn.yml`的新文件，内容如下:

```
---
l3vpns:
 vpna:
 state: present
 rt: "target:{{bgp_asn}}:10"
 rd: "1:10"
 sites:
 - node: mxpe01
 port: ge-0/0/3.10
 ip: 172.10.1.1/24
 - node: mxpe02
 port: ge-0/0/3.10
 ip: 172.10.2.1/24
 vpnb:
 state: present
 rt: "target:{{bgp_asn}}:20"
 rd: "1:20"
 sites:
 - node: mxpe01
 port: ge-0/0/3.20
 ip: 172.20.1.1/24
 - node: mxpe02
 port: ge-0/0/3.20
 ip: 172.20.2.1/24
```

2.  创建名为`pb_junos_l3vpn.yml`的新行动手册，并执行以下任务来配置 PE- **客户边缘** ( **CE** )链接:

```
---
- name: "Deploy L3VPNs on Juniper Devices"
 hosts: pe
 vars_files:
 - "l3vpn.yml"
 tasks:
 - name: "Set VPN Interfaces"
 set_fact:
 l3vpn_intfs: "{{ l3vpn_intfs|default([]) +
 l3vpns[item.key].sites |
 selectattr('node','equalto',inventory_hostname) | list}}"
 with_dict: "{{l3vpns}}"
 delegate_to: localhost

 - name: "Configure Interfaces for L3VPN Sites"
 junos_config:
 lines:
 - set interfaces {{ item.port.split('.')[0]}} vlan-tagging
 - set interfaces {{ item.port}} vlan-id {{ item.port.split('.')[1] }}
 loop: "{{ l3vpn_intfs }}"
```

3.  在`pb_junos_l3vpn.yml`中添加以下任务，在对等点链路上设置 P2P IP 地址:

```
- name: "Configure IP address for L3VPN Interfaces"
 junos_l3_interface:
 name: "{{ item.port.split('.')[0]}}"
 ipv4: "{{ item.ip }}"
 unit: "{{ item.port.split('.')[1] }}"
 loop: "{{l3vpn_intfs}}"
 tags: intf_ip
```

4.  在`pb_junos_l3vpn.yml`中添加以下任务，在对等节点上配置**虚拟路由和转发** ( **虚拟路由**):

```
- name: "Configure L3VPNs"
 junos_vrf:
 name: "{{ item.key }}"
 rd: "{{item.value.rd}}"
 target: "{{ item.value.rt }}"
 interfaces: "{{ l3vpns[item.key].sites |
 map(attribute='port') | list }}"
 state: "{{ item.value.state }}"
 with_dict: "{{l3vpns}}"
 when: inventory_hostname in (l3vpns[item.key].sites | map(attribute='node') | list)
 tags: l3vpn
```

# 它是如何工作的...

我们创建了一个名为`l3vpn.yml`的新 YAML 文件，该文件描述并建模了我们想要在拓扑中所有 Juniper 设备上实现的 L3VPN 拓扑和数据。我们将此文件包含在我们创建的新行动手册中，以便在我们的网络设备上配置 L3VPNs。

在`pb_junos_l3vpn.yml`剧本中，我们使用来自`l3vpn.yml`文件的数据来捕获调配 L3VPN 所需的数据。

在我们剧本中的第一个任务中，我们创建了一个名为`l3vpn_intfs`的新变量，它捕获了每个对等设备上的所有 L3VPN 接口，跨越了我们在`l3vpn.yml`文件中定义的所有 VPN。我们遍历这个文件中的所有 L3VPNs，并为属于特定节点的所有接口创建一个新的列表数据结构。以下片段概述了`mxpe01`的新数据结构`l3vpn_intfs`:

```
ok: [mxpe01 -> localhost] => {
 "l3vpn_intfs": [
 {
 "ip": "172.10.1.1/24",
 "node": "mxpe01",
 "port": "ge-0/0/3.10"
 },
 {
 "ip": "172.20.1.1/24",
 "node": "mxpe01",
 "port": "ge-0/0/3.20"
 }
 ]
}
```

接下来，在我们的行动手册中，我们将 L3VPN 服务的供应划分为多个任务:

*   我们使用`junos_config`模块来配置 L3VPNs 的所有接口，以便在这些接口上配置**虚拟局域网** ( **虚拟局域网**)。
*   我们使用`junos_l3_interface`模块在所有这些接口上应用 IPv4 地址，这些接口是我们的 L3VPN 模型的一部分。
*   根据我们的 L3VPN 数据模型，我们使用`junos_vrf`模块在节点上配置正确的路由实例。

以下概述了运行本行动手册后在`mxpe01`上应用的 L3VPN 配置:

```

Ansible@mxpe01> show configuration routing-instances
vpna {
 instance-type vrf;
 interface ge-0/0/3.10;
 route-distinguisher 1:10;
 vrf-target target:65400:10;
 vrf-table-label;
}
vpnb {
 instance-type vrf;
 interface ge-0/0/3.20;
 route-distinguisher 1:20;
 vrf-target target:65400:20;
 vrf-table-label;
}
```

# 请参见...

有关`junos_vrf`模块以及该模块支持的在 Juniper 设备上配置 L3VPNs 的不同参数的更多信息，请参考以下网址:[https://docs . ansi ble . com/ansi ble/latest/modules/Junos _ vrf _ module . html # Junos-vrf-module](https://docs.ansible.com/ansible/latest/modules/junos_vrf_module.html#junos-vrf-module)[。](https://docs.ansible.com/ansible/latest/modules/junos_vrf_module.html#junos-vrf-module)

# 使用 Ansible 收集 Juniper 设备事实

在这个配方中，我们将检索 Ansible 为 Juniper 设备收集的基本系统事实。这些基本的系统事实为我们提供了关于 Juniper 设备的基本运行状况检查，我们可以用它来验证其运行状态。

# 准备好

必须在 Juniper 设备上启用 NETCONF，才能使用本食谱中的 Ansible 模块。

# 怎么做...

1.  创建一个新的行动手册`pb_jnpr_facts.yml`，任务如下收集事实:

```
$ cat pb_jnpr_facts.yml

---
- name: Collect and Validate Juniper Facts
 hosts: junos
 tasks:
 - name: Collect Juniper Facts
 junos_facts:
```

2.  使用以下任务更新`pb_jnpr_facts.yml`行动手册，为我们清单中的每个节点创建事实报告:

```
 - name: Create Facts Folder
 file: path=device_facts state=directory
 run_once: yes

 - name: Create Basic Device Facts Report
 blockinfile:
 path: "device_facts/{{ inventory_hostname }}.txt"
 block: |
 device_name: {{ Ansible_net_hostname }}
 model: {{ Ansible_net_system }} {{ Ansible_net_model }}
 os_version: {{ Ansible_net_version }}
 serial_number: {{ Ansible_net_serialnum }}
 create: yes
```

3.  使用以下任务更新行动手册，以验证核心接口的运行状态:

```
 - name: Validate all Core Interface are Operational
 assert:
 that:
 - Ansible_net_interfaces[item.port]['oper-status'] == 'up'
 fail_msg: "Interface {{item.port}} is not Operational "
 loop: "{{ p2p_ip[inventory_hostname] }}"
```

# 它是如何工作的...

Ansible 提供了一个事实收集模块来收集 Juniper 设备的基本系统属性，并以一致的结构化数据结构返回这些事实。我们可以使用本模块收集的事实来验证设备的基本属性和运行状态，并且可以使用这些数据构建简单的报告来捕获设备的状态。

在本食谱中，我们使用`junos_facts`模块收集所有 Juniper 设备的设备事实。该模块以多个变量返回 Ansible 为每个设备收集的基本事实，如下所示:

```
"Ansible_net_serialnum": "VM5D112EFB39",
"Ansible_net_system": "junos",
"Ansible_net_version": "17.1R1.8",
"Ansible_network_os": "junos",
```

我们使用这些数据来为使用`blockinfile`模块的每个设备构建事实报告，并且我们使用这些数据来验证使用`assert`模块的每个设备的核心接口的操作状态。

运行行动手册后，我们可以看到为每台设备生成了一份事实报告，如下所示:

```
$ tree device_facts/

device_facts/
 ├── mxp01.txt
 ├── mxp02.txt
 ├── mxpe01.txt
 └── mxpe02.txt

 $ cat device_facts/mxp01.txt

device_name: mxp01
 model: junos vmx
 os_version: 14.1R4.8
 serial_number: VM5701F131C6
```

在最后一个任务中，我们使用`assert`模块来验证所有 Juniper 设备上的所有核心接口都是可操作的。Ansible 在`Ansible_net_interfaces`下存储设备所有接口的运行状态。我们使用这个数据结构中的数据来验证操作状态是否正常。如果所有的核心接口都可以运行，任务就会成功，否则任务就会失败。

# 请参见...

欲了解更多关于`junos_facts`模块和该模块支持的不同参数的信息，请访问以下网址:[https://docs . ansi ble . com/ansi ble/latest/modules/Junos _ facts _ module . html](https://docs.ansible.com/ansible/latest/modules/junos_facts_module.html)[。](https://docs.ansible.com/ansible/latest/modules/junos_facts_module.html)

# 验证 Juniper 设备上的网络可达性

在本食谱中，我们将概述如何在 Juniper 设备上使用 Ansible 通过`ping`验证网络可达性。这将使我们能够在示例网络拓扑中验证网络可达性和流量转发。

# 准备好

该方法假设网络已经构建和配置，如前面所有方法中所述。

# 怎么做...

1.  创建一个名为`pb_junos_ping.yml`的新剧本，任务如下，ping 示例网络中的所有核心环回:

```
---
- name: "Validate Core Reachability"
 hosts: junos
 tasks:
 - name: "Ping Across All Loopback Interfaces"
 junos_ping:
 dest: "{{ item.value.split('/')[0] }}"
 interface: lo0.0
 size: 512
 with_dict: "{{lo_ip}}"
 vars:
 Ansible_connection: network_cli
 register: ping_rst
 ignore_errors: yes
```

2.  使用以下任务更新`pb_junos_ping.yml`行动手册，以创建自定义报告来捕获 ping 结果:

```
 - name: Create Ping Report
 blockinfile:
 block: |
 Node | Destination | Packet Loss | Delay |
 -----| ------------| ------------| ------|
 {% for node in play_hosts %}
 {% for result in hostvars[node].ping_rst.results %}
 {% if result.rtt is defined %}
 {{ node }} | {{ result.item.value }} | {{ result.packet_loss }} | {{ result.rtt.avg }}
 {% else %}
 {{ node }} | {{ result.item.value }} | {{ result.packet_loss }} | 'N/A'
 {% endif %}
 {% endfor %}
 {% endfor %}
 path: ./ping_report.md
 create: yes
 run_once: yes
```

# 它是如何工作的...

我们使用`junos_ping`模块从网络清单中的所有节点 ping 通`lo_ip`数据结构中定义的所有环回接口，该数据结构在`group_vars/all.yml`文件中定义。该模块连接到每个设备，对所有目的地执行 ping 操作，并验证 ping 数据包是否到达预期目的地。这个模块需要使用`network_cli`连接插件，因此我们提供这个参数作为任务变量，以便覆盖在组级定义的组级 NETCONF 连接插件。

我们注册模块的输出，以便使用这些数据生成 ping 报告。最后，我们将`ignore_errors`设置为`yes`，以便忽略我们可能遇到的任何失败的 ping 任务，并确保我们将运行后续任务来创建报告。

我们使用`blockinfile`模块在 Markdown 中创建自定义报告。我们使用表格布局来捕获 ping 结果，并显示捕获这些 ping 结果的表格。以下片段捕获了为`mxpe01` ping 测试报告生成的表格:

```
$ cat ping_report.md

# BEGIN ANSIBLE MANAGED BLOCK
 Node | Destination | Packet Loss | Delay |
 -----| ------------| ------------| ------|
 mxpe01 | 10.100.1.254/32 | 0% | 3.75
 mxpe01 | 10.100.1.253/32 | 0% | 2.09
 mxpe01 | 10.100.1.1/32 | 0% | 0.27
 mxpe01 | 10.100.1.2/32 | 0% | 4.72
 mxpe01 | 10.100.1.3/32 | 100% | 'N/A'
 # END ANSIBLE MANAGED BLOCK
```

以下是 ping 结果的渲染标记表:

![](assets/8dd7c8e4-61f2-4c27-bf5d-7a5ffd391dd3.png)

# 请参见...

欲了解更多关于`junos_ping`模块和该模块支持的不同参数的信息，请访问以下网址:[https://docs . ansi ble . com/ansi ble/latest/modules/Junos _ ping _ module . html](https://docs.ansible.com/ansible/latest/modules/junos_ping_module.html)[。](https://docs.ansible.com/ansible/latest/modules/junos_ping_module.html)

# 从 Juniper 设备中检索操作数据

在本食谱中，我们将概述如何在 Juniper 设备上执行操作命令，并将这些输出存储在文本文件中以供进一步处理。

# 准备好

为了遵循这个方法，必须在 Juniper 设备上启用 NETCONF。

# 怎么做...

1.  安装`jxmlease` Python 包，如下所示:

```
$ pip3 install jxmlease
```

2.  创建一个名为`pb_get_ospf_peers.yml`的新剧本，并使用以下任务填充它以提取 OSPF 对等信息:

```
---
- name: "Get OSPF Status"
 hosts: junos
 tasks:
 - name: "Get OSPF Neighbours Data"
 junos_command:
 commands: show ospf neighbor
 display: xml
 register: ospf_output

 - name: "Extract OSPF Neighbour Data"
 set_fact:
 ospf_peers: "{{ ospf_output.output[0]['rpc-reply']\
 ['ospf-neighbor-information']['ospf-neighbor'] }}"
```

3.  使用以下任务更新`pb_get_ospf_peers.yml`行动手册，以验证所有节点上的所有 OSPF peering 都处于`Full`状态:

```
 - name: "Validate All OSPF Peers are in Full State"
 assert:
 that: item['ospf-neighbor-state'] == 'Full'
 fail_msg: "Peer on Interface {{item['interface-name']}} is Down"
 success_msg: "Peer on Interface {{item['interface-name']}} is UP"
 loop: "{{ospf_peers}}"
```

# 它是如何工作的...

使用 NETCONF API 与 Juniper 设备交互的优势之一是，我们可以获得在 Juniper 设备上执行的所有操作命令的结构化输出。设备通过 NETCONF 会话返回给我们的输出是 XML，Ansible 使用名为`jxmlease`的 Python 库对这个 XML 进行解码，并将其转换为 JSON，以便更好地表示。这就是为什么我们的第一个任务是安装`jxmlease` Python 包。

我们使用`junos_command`模块向 Juniper 设备发送操作命令，我们指定需要 XML 作为从节点返回的输出格式。这个 XML 数据结构被 Ansible 使用`jxmlease`包转换为 JSON。我们使用`register`关键字将该数据保存到一个名为`ospf_output.`的新变量中，下面是从该命令返回的 JSON 数据示例:

```
 "msg": [
 {
 "rpc-reply": {
 "ospf-neighbor-information": {
 "ospf-neighbor": [
 {
 "activity-timer": "34",
 "interface-name": "ge-0/0/0.0",
 "neighbor-address": "10.1.1.2",
 "neighbor-id": "10.100.1.254",
 "neighbor-priority": "128",
 "ospf-neighbor-state": "Full"
 },
 {
 "activity-timer": "37",
 "interface-name": "ge-0/0/1.0",
 "neighbor-address": "10.1.1.8",
 "neighbor-id": "10.100.1.253",
 "neighbor-priority": "128",
 "ospf-neighbor-state": "Full"
 }
 ]
 }
 }
 }
 ]
```

所有这些数据结构都包含在`ospf_output.output[0]`变量中，我们使用`set_fact`模块来捕获`ospf-neigbour`数据。之后，我们使用`assert`模块循环遍历该数据结构中的所有 OSPF 对等体，并验证 OSPF 邻居状态等于`Full`。如果所有 OSPF 同行都处于`Full`状态，任务就会成功。但是，如果 OSPF 州处于任何其他州，该任务将失败。

# 还有更多...

如果我们需要从 Juniper 设备获取文本格式的操作数据以进行日志收集，我们可以使用`junos_command`模块，而不使用`xml`显示选项，如本新行动手册所示:

```
$ cat pb_collect_output.yml

---
- name: Collect Network Logs
 hosts: junos
 vars:
 log_folder: "logs"
 op_cmds:
 - show ospf neighbor
 tasks:
 - name: "P1T1: Build Directories to Store Data"
 block:
 - name: "Create folder to store Device config"
 file:
 path: "{{ log_folder }}"
 state: directory
 run_once: yes
 delegate_to: localhost

 - name: "P1T2: Get Running configs from Devices"
 junos_command:
 commands: "{{ item }}"
 loop: "{{ op_cmds }}"
 register: logs_output

 - name: "P1T3: Save Running Config per Device"
 copy:
 content: "{{ item.stdout[0] }}"
 dest: "{{ log_folder }}/{{inventory_hostname}}_{{ item.item | regex_replace(' ','_') }}.txt"
 loop: "{{ logs_output.results }}"
 delegate_to: localhost
```

本手册将从所有设备收集`show ospf neigbor`命令，并将其存储在名为`logs`的新文件夹中。以下是运行行动手册后`logs`文件夹的内容:

```
$ tree logs
 logs
 ├── mxp01_show_ospf_neighbor.txt
 ├── mxp02_show_ospf_neighbor.txt
 ├── mxpe01_show_ospf_neighbor.txt
 └── mxpe02_show_ospf_neighbor.txt
```

我们可以检查其中一个文件的内容，确认是否捕获到了所需的输出:

```

 $ cat logs/mxpe01_show_ospf_neighbor.txt

Address Interface State ID Pri Dead
 10.1.1.2 ge-0/0/0.0 Full 10.100.1.254 128 35
 10.1.1.8 ge-0/0/1.0 Full 10.100.1.253 128 37
```

# 使用 PyEZ 操作表验证网络状态

在本食谱中，我们将概述如何使用 Juniper 定制 Ansible 模块来验证网络状态。我们将使用 Juniper PyEZ Python 库和 PyEZ 操作表和视图来验证 Junos 操作系统设备的操作状态。

# 准备好

为了遵循这个方法，必须在 Juniper 设备上启用 NETCONF。

# 怎么做...

1.  安装`junos-eznc` Python 包，如下所示:

```
$ pip3 install junos-eznc
```

2.  使用`Ansible-galaxy`安装`Juniper.junos`Ansible角色，如下所示:

```
$ Ansible-galaxy install Juniper.junos
```

3.  创建一个名为`pb_jnpr_pyez_table.yml`的新剧本，并使用以下任务填充它，以使用 PyEZ 表提取 BGP 对等信息:

```
$ cat pb_jnpr_pyez_table.yml

---
- name: Validate BGP State using PyEZ Tables
 hosts: junos
 roles:
 - Juniper.junos
 tasks:
 - name: Retrieve BGP Neighbor Information Using PyEZ Table
 Juniper_junos_table:
 file: "bgp.yml"
 register: jnpr_pyez_bgp
```

4.  使用以下任务更新行动手册，以验证所有节点上的所有 BGP 对等是否正常运行:

```
 - name: Validate all BGP Peers are operational
 assert:
 that:
 - item.peer in jnpr_pyez_bgp.resource | map(attribute='peer_id') | list
 fail_msg: " BGP Peer {{ item.peer }} is Not Operational"
 loop: "{{ bgp_peers }}"
```

# 它是如何工作的...

除了我们在之前的所有食谱中概述的预装 Ansible 的内置 Juniper 模块之外，还有由 Juniper 维护的附加 Ansible 模块，它们不是 Ansible 版本的一部分。这些模块封装在 Ansible 角色中，该角色在 Ansible Galaxy 中维护，所有这些模块都基于 Juniper PyEZ Python 库，该库也是由 Juniper 开发和维护的。

Juniper PyEZ Python 库提供了一个简单而健壮的 API，以便与 Juniper 设备交互，并简化了如何使用 Python 管理 Juniper 设备。Juniper 维护的 Ansible 模块都依赖于 PyEZ Python 库，因此我们需要执行的第一个任务是确保 PyEZ ( `junos-eznc`)安装在我们的 Ansible 控制机上。

Juniper 维护和开发的 Ansible 模块被打包为 Ansible 角色，与 Ansible 版本中内置的 Juniper 模块相比，它们为多个模块提供了额外的功能。我们使用 Ansible Galaxy 安装这个角色，以便开始利用这些额外的模块。以下代码片段概述了属于此角色的额外模块:

```
$ tree ~/.Ansible/roles/Juniper.junos/library/

/home/Ansible/.Ansible/roles/Juniper.junos/library/
 ├── Juniper_junos_command.py
 ├── Juniper_junos_config.py
 ├── Juniper_junos_facts.py
 ├── Juniper_junos_jsnapy.py
 ├── Juniper_junos_ping.py
 ├── Juniper_junos_pmtud.py
 ├── Juniper_junos_rpc.py
 ├── Juniper_junos_software.py
 ├── Juniper_junos_srx_cluster.py
 ├── Juniper_junos_system.py
 └── Juniper_junos_table.py
```

在本食谱中，我们概述了如何使用`Juniper_junos_table` Ansible 模块，该模块使用 PyEZ 表和视图在 Juniper 设备上执行操作命令，并从 Juniper 设备中提取特定信息。它还将这些信息解析成一个一致的数据结构，我们可以在自动化脚本中利用它。在我们的行动手册中，我们的第一个任务是使用`bgp.yml`表定义(作为`junos-eznc`安装的一部分)来使用`Juniper_junos_table`模块。我们这样做是为了获得设备上的 BGP 对等体，并以一致的数据结构返回相关信息。以下片段概述了`Juniper_junos_table`为`mxpe01`上的 BGP 信息返回的 BGP 数据:

```
ok: [mxpe01] => {
 "jnpr_pyez_bgp": {
 "changed": false,
 "failed": false,
 "msg": "Successfully retrieved 1 items from bgpTable.",
 "resource": [
 {
 "local_address": "10.100.1.1+179",
 "local_as": "65400",
 "local_id": "10.100.1.1",
 "peer_as": "65400",
 "peer_id": "10.100.1.254",
 "route_received": [
 "0",
 "2",
 "1",
 "1"
 ]
 }
 ],
 }
}
```

我们行动手册中的最后一个任务是使用`assert`模块，以验证我们所有的 BGP 对等体(在`host_vars)`目录下定义)都存在于 BGP 表中返回的数据结构中，这表明所有的 BGP 对等体都在运行。

# 请参见...

有关由 Juniper 维护的 Juniper Ansible 模块的更多信息，请参考以下网址:[https://www . Juniper . net/documentation/en _ US/Junos-ansi ble/topics/reference/general/Junos-ansi ble-modules-overview . html](https://www.juniper.net/documentation/en_US/junos-ansible/topics/reference/general/junos-ansible-modules-overview.html)[。](https://www.juniper.net/documentation/en_US/junos-ansible/topics/reference/general/junos-ansible-modules-overview.html)

有关 PyEZ 表和视图的更多信息，请参考以下网址: [https://www。juniper . net/documentation/en _ US/Junos-pyez/topics/concept/Junos-pyez-tables-and-view-overview . html](https://www.Juniper.net/documentation/en_US/junos-pyez/topics/concept/junos-pyez-tables-and-views-overview.html)。