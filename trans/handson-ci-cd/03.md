# 三、持续交付的基础

可以说，软件最重要的部分实际上是让它交付给最终用户并准备好使用。**持续交付** ( **光盘**)是您向最终用户交付软件产品的时间点，也是本章的基础。一个产品只有在你的目标用户能够真正使用它的情况下才是有用的。在本章中，我们将讨论部署管道以及自动化和光盘的概念。

本章将涵盖以下主题:

*   交付软件时出现问题
*   结构管理
*   部署管道
*   部署脚本
*   部署生态系统

# 技术要求

本章假设您理解自动化和持续集成的概念。如果您对这些主题中的任何一个不确定，请在阅读本章之前阅读[第 1 章](01.html)、*自动化测试 CI/CD*和[第 2 章](02.html)、*持续集成基础知识*。

本章的代码文件可以在[https://github . com/jbelmont/API-workshop/blob/master/Gopkg . toml](https://github.com/jbelmont/api-workshop/blob/master/Gopkg.toml)上找到。

# 交付软件时出现问题

当试图向您的最终用户交付软件产品时，有许多事情可能会出错，我们将看看影响交付软件的几个场景。一种可能的情况是，开发人员正在开发一个新特性，但是这个新特性可能实际上没有通过 CI 构建阶段，或者可能没有按照产品所有者最初建议的方式运行。另一种可能的情况是，目标受众没有被正确理解，这将影响用户对最终产品的使用。另一种可能的情况是，软件产品没有适当地分离，而是与泡泡糖和磁带放在一起，随着新的特性请求出现了许多回归。

# 我们所说的交付软件是什么意思？

关于交付软件到底意味着什么，可能会有很多争论。就本章而言，这意味着实际的软件产品已经交付给预期用户，而不仅仅是软件产品已经由**质量保证** ( **QA** )部门批准工作。

# 常见发布反模式

存在一些您应该避免的常见版本反模式，例如手动部署软件、手动配置管理以及每个环境的不同环境配置。

# 手动部署软件

这种类型的反模式很常见，会导致软件交付的瓶颈。软件交付的那一天压力很大，容易出错。运营部的 Tom 从将版本控制系统中的软件工件复制到生产环境中开始他的一天。Tom 通过**文件传输协议** ( **FTP** )复制文件，但是忘记添加新的配置文件，登录页面不再工作。Tom 必须与开发团队交谈，询问是否有新的配置文件被添加，并等待几个小时才能得到响应。

一旦 Tom 获得了新的配置文件，他就将其上传到生产环境中。登录页面现在可以工作了，但是一些页面加载了奇怪的图像放置和不规则。Tom ping UI/UX 团队，发现生产环境中缺少一个 CSS 文件。Tom 上传了 CSS 文件，现在页面加载正确。Tom 询问客户成功团队是否可以进一步测试生产环境中的新变化，最后在晚上 7 点左右结束。

如果存在详细描述软件产品交付的长文档，这可能表示手动过程。这使得交付产品更加复杂，因为过程中的任何错误都会导致更多的问题。如果交付往往是不可预测的，这也可能指向这种反模式。

# 救援部署自动化

正如我们在[第 1 章](01.html)、 *CI/CD 与自动化测试*中所讨论的，自动化是以可重复和自动化的方式完成动作的过程。软件交付应该是一个自动化的过程，因为这将有助于确保软件交付的一致实践和行为。我们将在本章的后面部分讨论帮助您自动化软件交付过程的工具。

# 手动配置管理

这种反模式可能会让操作人员感到沮丧，因为他们将是最后一个知道产品中新行为的人。如果软件交付日是运营团队第一次看到新功能，那么他们可能会对软件行为感到惊讶。运营团队成员辛迪负责交付软件，并注意到安装脚本完全中断，因为它无法与**标识** ( **标识**)服务器通信。Cindy 向开发团队发送日志消息，发现 ID 服务器的一个客户端机密已经更改，安装脚本需要使用这个新值才能正确连接。

如果 Cindy 知道 ID 服务器的这种新变化，这种类型的问题本可以得到缓解，但是开发人员正在与另一个环境合作，质量保证部门获得了这种信息来测试新功能，但是没有人想到将这种信息传递给运营部门，直到他们在交付当天遇到问题。

# 配置管理自动化

我们将讨论有助于解决配置管理问题的工具，例如之前遇到的问题。使用适当的工具，运营/开发人员可以快速为每个环境(包括生产环境)获得正确的环境配置。

# 生产环境与其他环境有何不同

这种类型的反模式可能特别具有挑战性，因为所有的更改都已经在开发中测试过了，并且一个临时环境可能在生产中表现不稳定。例如，Travis 在 QA 部门担任测试人员，自新功能推出以来一直在测试试运行环境。作为一名运营人员，Billy 无法看到新功能，因为登台环境与生产环境完全不同。Billy 还注意到生产环境数据缺少登台环境中显示的关键信息。Billy 联系了开发团队，发现必须运行一个数据库迁移脚本，新功能才能在生产环境中运行。

# 生产环境应该与登台环境相同

所有环境，包括测试、试运行和生产，都应该有必要的迁移脚本和任何其他软件资产，以防止生产中断，开发团队应该确保将操作指向脚本文件中的任何更改，或者在共享文档中明确标记这些更改。

# 如何进行软件发布

在进行软件发布时，有一些重要的步骤需要考虑，例如频繁发布以避免一次引入太多的更改，并确保发布是自动化的。

# 频繁发布

软件发布必须频繁。大型软件版本往往充满问题，因此最好将版本之间的差异(变更)做小。通过增加软件发布的频率，您还可以获得更快的反馈。大型软件发布往往需要更长的时间，关键反馈可能不会那么快交付。

# 自动发布

手动发布是有问题的，因为它们不可重复。每次手动发布完成后，都会因配置更改、软件更改和环境更改而有所不同。手动发布步骤错误百出，因为每个步骤都是手动的，可能会导致级联错误。手动更改的危害的一个很好的例子是，当最受欢迎的云提供商**亚马逊网络服务** ( **AWS** )在美国东部地区遭遇重大停机，因为一名操作人员在手动流程的一系列步骤中输入了错误的命令。自动化是软件发布的关键，因为它们确保了可重复性和对软件交付过程的控制。我们将在本章中进一步研究部署脚本工具，以帮助自动化软件交付。

# 交付软件自动化的好处

正如我们前面所说明的，自动化在软件交付中很重要，因为它确保了软件发布的可重复性、可靠性和可预测性。灾难性事件可以通过自动化软件交付过程而不是长时间的手动过程来避免或减轻。

# 团队授权

如果自动化到位，质量保证部门可以安全地选择旧版本的软件版本来测试回归。操作人员可以运行用于转移的脚本，不会因为环境级别的差异而遇到问题。通过自动化软件流程，操作人员可以在交付过程中出现灾难时安全地回滚发布。此外，正如我们在[第 2 章](02.html)、*持续集成基础*中所述，自动化有助于按钮的释放。

# 减少误差

自动化有助于减少手动流程可能造成的错误。正如我们之前看到的，配置管理问题可能会导致软件交付不佳。手动软件发布不能有效地确保可重复性，因此容易出错。

# 减压

另一个好处是减轻了软件交付期间所有人员的压力。手动过程往往会造成不必要的压力，因为无论谁做手动过程，都必须勤奋，并且在交付过程中不犯任何错误。自动化交付过程很棒，因为它确保了每个运行都以相同的方式执行。手动流程中的错误可能需要高级人员的支持来解决问题。

# 结构管理

保存重要信息(如客户端机密和密码)的配置文件必须得到正确管理，并且必须在其他环境中保持同步。每个环境可能有不同的环境变量，这些变量必须被使用并传递到应用中。

# 配置管理到底意味着什么？

配置管理可以简单地描述为检索、存储、识别和修改与每个给定项目相关的所有软件工件以及软件工件之间的任何关系的过程。

# 版本控制

版本控制是在所有软件工件之间保持修订的手段。版本控制对于配置管理非常重要，因为对包含环境文件的文件的任何更改都应该在版本控制之下。

托尼是开发团队的一员，他一直在使用一个尚未被置于源代码管理之下的属性文件，并且一直在对产品中的**单点登录** ( **SSO** )流程进行更改。托尼不小心删除了文件，并丢失了单点登录流程中必需的所有客户端标识和机密。Tony 现在必须转到不同的 API 入口，为一些属性重新生成客户端密码，因为它们在创建过程中只显示一次，现在他必须通知团队的其他成员更新他们的属性文件。

# 示例属性文件

我添加了一个包含客户端机密信息和身份验证机密信息的示例属性文件。这是给定环境正常运行所必需的，但不应将其签入源代码控制中，此处仅用于演示目的:

```
API_URL=http://localhost:8080
PORT=8080
AUTH_ZERO_CLIENT_ID=fakeClientId
AUTH_ZERO_JWT_TOKEN=someFakeToken.FakedToken.Faked
AUTH_ZERO_URL=https://fake-api.com
REDIS_PORT=redis:6379
SEND_EMAILS=true
SMTP_SERVER=fakeamazoninstance.us-east-1.amazonaws.com
SMTP_USERNAME=fakeUsername
SMTP_PASSWORD=fakePassword
SMTP_PORT=587
TOKEN_SECRET="A fake token secret"
```

The `TOKEN_SECRET` environment variable is only seen once, so if it is lost, then you must regenerate it in the API portal.

# 版本控制管理工具

以下是版本控制管理工具的列表:

*   **Git**([https://git-scm.com/](https://git-scm.com/)):Git 是分布式版本控制系统
*   **Mercurial**([https://www.mercurial-scm.org/](https://www.mercurial-scm.org/)):Mercurial 也是一个分布式版本控制系统
*   **Subversion**([https://subversion.apache.org/](https://subversion.apache.org/)):Subversion 被认为是集中式版本控制系统
*   **化石**([https://www.fossil-scm.org/](https://www.fossil-scm.org/)):化石是像 Git 一样的分布式版本控制系统，虽然不太为人所知

# 版本控制实践

一个重要的实践是尽可能将所有东西都控制在版本之下，以避免丢失软件产品中的重要工作。网络文件、配置文件、部署脚本、数据库脚本、构建脚本以及对应用正常运行非常重要的任何其他工件都应该在版本控制之下，否则您可能会丢失关键数据。

# 经常进行软件签入

经常签入你的主分支是很重要的，否则你就有可能在你的代码库中引入破坏性的变化。此外，频繁的签入有助于开发人员随时注意引入小的更改。应该避免对代码库进行大范围的更改，因为它们更难测试，并且会带来倒退。频繁的签入也是有益的，因为突破性的变化会更快被注意到。

# 编写描述性和有意义的提交消息

使用包含问题跟踪信息的描述性提交消息，例如清楚描述提交意图的JIRA问题。避免编写模糊的提交消息，如`Fixed bug`或`Wrapped up`，因为这些类型的提交消息没有用处，对以后的开发人员也没有帮助。

Here is a sample descriptive commit message [DEV-1003] added a new navigation link to the Parts Supply list. A test case for the new navigation was also added. This is clearly more descriptive. Additionally, in Jira, when you provide an issue such as DEV-1003, it will create a link in the Jira issue that references the work on this issue. Also, if you create a pull request and put `git commit` with the Jira issue, it will link your pull requests with the issue.

# 依赖性管理

应用通常具有对软件产品至关重要的第三方依赖关系。依赖管理是任何应用的重要部分，不同的编程语言处理依赖管理的方式也不同。

# Node.js 依赖文件和 Gopkg.toml 依赖文件示例

这里有一个`Gopkg.toml`文件，其中包含存储库中每个依赖项的版本和包信息:

```
# Gopkg.toml example
#
# Refer to https://github.com/golang/dep/blob/master/docs/Gopkg.toml.md
# for detailed Gopkg.toml documentation.
#
# required = ["github.com/user/thing/cmd/thing"]
# ignored = ["github.com/user/project/pkgX", "bitbucket.org/user/project/pkgA/pkgY"]
#
# [[constraint]]
#   name = "github.com/user/project"
#   version = "1.0.0"
#
# [[constraint]]
#   name = "github.com/user/project2"
#   branch = "dev"
#   source = "github.com/myfork/project2"
#
# [[override]]
#   name = "github.com/x/y"
#   version = "2.4.0"
#
# [prune]
#   non-go = false
#   go-tests = true
#   unused-packages = true

[prune]
  go-tests = true
  unused-packages = true

[[constraint]]
  branch = "v2"
  name = "gopkg.in/mgo.v2"

[[constraint]]
  name = "github.com/dgrijalva/jwt-go"
  version = "3.1.0"

[[constraint]]
  name = "github.com/go-playground/locales"
  version = "0.11.2"

[[constraint]]
  name = "github.com/pkg/errors"
  version = "0.8.0"

[[constraint]]
  name = "github.com/pborman/uuid"
  version = "1.1.0"

[[constraint]]
  name = "gopkg.in/go-playground/validator.v9"
  version = "9.9.3"
```

Dependency management like this is important because third-party dependencies can easily bring breaking changes to an application, and API changes in a third-party dependency can break critical behavior in any running application.

# 管理软件组件

通常，软件项目将从一个整体构建开始，所有的工作组件都在一个层中。随着应用规模和成熟度的增长，应用的各个层将分解成服务或不同的层，这就是有必要使用单独的构建管道的地方。也许身份服务用于应用中的身份验证，也许管理服务在管理门户的单独构建管道中运行。微服务体系结构是应用的这种服务级别组件化的延续，其中每个微服务在应用中都有明确而集中的目的。

# 软件配置管理

配置是任何应用的重要部分，应该像在代码中使用业务级逻辑一样小心对待。因此，配置需要像源代码一样进行适当的管理和测试。

# 可配置性和灵活性概念

乍一看，尽可能灵活地进行配置似乎是合适的。*为什么不使系统尽可能灵活，并允许它适应任何类型的环境？*这通常被称为*终极可配置性*的反模式，意味着配置可以像编程语言一样运行，并且可以以任何方式运行。以这种方式完成的配置管理可以使一个软件项目屈服，因为它的用户会期望必要的灵活性。为您的配置管理设置一些约束会更有用。约束有助于控制配置环境中过于灵活的影响。

# 特定类型的配置

以下是应用可以利用的可能配置类型列表:

*   可以在**构建时间**将配置提取并合并到应用二进制文件中:
    *   像 C/C++和 Rust 这样的语言可以完成这样的构建时配置
*   创建组件或宝石时，可在**封装时间**注入配置:
    *   C#、Java 和 Ruby 等语言可以使用这样的配置选项
*   配置可以在**部署时间**完成，这意味着部署脚本或安装程序可以根据需要获取任何必要的信息，或者部署脚本可以要求用户传递这些信息:
    *   我们将在本书的稍后部分使用 Jenkins、Travis 和 CircleCI 工具来了解这一点
*   可以在**启动时间或** **运行时间****进行配置，这意味着当应用启动时:

    *   像 Node.js 这样的语言经常在 Node.js 服务器运行时注入环境变量** 

 **# 跨应用的配置管理

当您跨不同的应用进行配置时，配置管理会变得更加复杂。有一些工具可以帮助跨应用边界进行配置，下面是这些工具的列表:

*   CFEngine([https://cfengine.com/](https://cfengine.com/))
*   木偶([https://puppet.com/](https://puppet.com/))
*   厨师〔t 0〕https://www .厨师. io/厨师/
*   ansi ble([https://www.ansible.com/](https://www.ansible.com/))
*   库伯内斯码头工人([https://www.docker.com/](https://www.docker.com/))

# 环境管理

应用所依赖的硬件、软件、基础设施和任何外部系统都可以被认为是应用的环境。任何环境的创建都应该以完全自动化的方式完成，因为复制环境的能力很重要，正如我们将要说明的那样。

# 手动环境设置

手动设置基础架构可能会有问题，原因有几个:

*   手动设置的服务器实例可以配置为适合单个操作人员。该运营人员可能会离开组织，导致核心基础架构崩溃。
*   修复手动设置的环境可能需要很长时间，因此在这种环境中修复问题是不可重现和重复的。
*   出于测试目的，手动设置的环境可能无法复制。

# 环境的重要配置信息

以下是所有环境都需要的重要配置信息列表:

*   每个环境中需要安装的第三方依赖项和软件包
*   网络拓扑信息

*   应用运行所需的外部服务，如数据库服务
*   应用数据或种子数据，以建立和运行全新的环境

# 集装箱化环境

Docker 和 Kubernetes 等工具越来越受欢迎，因为它们能够隔离环境级别的信息，并创建可复制/可重复的环境。使用 Docker，您可以声明所有的外部服务，比如 Redis 和 MongoDB。

以下是应用编程接口研讨会报告([https://github.com/jbelmont/api-workshop](https://github.com/jbelmont/api-workshop))的`docker-compose` YML 脚本示例:

```
version: '3'
services:
  mongo:
    image: mongo:3.4.5
    command: --smallfiles --quiet --logpath=/dev/null --dbpath=/data/db
    ports:
      - "27017:27017"
    volumes:
      - data:/data/db
  redis:
    image: redis:3.2-alpine
    ports:
      - "6379:6379"
 apid:
    build:
      context: .
      dockerfile: Dockerfile-go
    depends_on:
      - mongo
      - redis
    env_file:
      - ./common.env
    links:
      - mongo
      - redis
    ports:
      - "8080:8080"
volumes:
    data:
```

We have declared a database as well as a caching service (Redis) and an API that all run as an isolated container, all of which can have environment-level information such as environment variables, that can be configured separately.

# 部署管道

我们在[第 2 章](02.html)、*持续集成基础*中谈到了 CI 的重要性，虽然 CI 是一个重要的生产力增强器，但它主要对开发团队有用。在等待修复或更新文档时，质量保证和运营团队经常会发现软件生命周期中的瓶颈。质量保证可以留给开发团队等待一个好的构建。开发团队也可能在完成一个新特性几周后收到错误报告。所有这些情况都会导致软件不可部署，最终导致软件无法交付给最终用户。正如我们前面提到的，创建可以部署到测试、试运行和生产环境中的按钮部署构建可以帮助缓解这些问题。

# 什么是部署管道？

部署管道可以被认为是构建、部署、测试和发布过程的端到端自动化。部署管道也可以被认为是将开发人员编写的软件交付给用户的过程。

# 部署管道实践

在本节中，我们将讨论一些要遵循的部署管道实践，例如一次构建二进制文件，在每个环境中以相同的方式处理部署，以及在部署管道中进行提交阶段。

# 构建二进制文件一次

多次编译的二进制文件可能会有问题，原因有几个:

*   二进制文件在每次运行时可能有不同的上下文，这会给系统带来不可预测性
*   静态编译的语言，如 C/C++，在每次运行时可以有不同的编译器版本

*   第三方软件可能在不同编译执行上下文中指定了不同的版本
*   多次编译二进制文件也会导致低效的部署管道
*   重新编译二进制文件也很耗时

It is better to compile binaries once during compile time if you can do so.

# 在每个环境中，部署都应该以相同的方式进行

当您考虑在每个源代码签入上运行的配置项构建时，开发人员通常会一直部署他们的软件。质量保证/测试人员不会经常部署，操作更不会。部署到生产环境的频率要比开发环境低得多，这是有充分理由的。

应该创建一个可以为开发、试运行和生产环境运行的部署脚本。每个环境中所需的任何更改都可以通过在版本控制中管理的属性文件来管理。例如，您可以在部署脚本中使用环境变量来区分不同的环境。

# 提交阶段–部署管道的第一步

部署管道的第一阶段是提交阶段，或者每当开发人员将代码签入版本控制时。一旦代码被签入到配置项构建管道中，构建管道应该在必要时编译任何代码，运行一套单元测试(希望存在一些)和集成测试，如果以后部署管道需要，创建任何二进制文件，运行静态分析工具来检查代码库的运行状况，并为部署管道准备以后需要的任何构建工件。

对于提交阶段构建来说，还有一些其他重要的指标需要考虑，例如代码覆盖率、代码库中的重复、圈复杂度(度量代码库中的复杂度)、监控大量警告消息以及代码风格(通常由林挺工具报告)。

If the commit build stage passes, then we can think of it as the first gate to pass through, albeit an important one.

# 测试门

在极限编程中，开发人员创建验收测试，作为测试软件系统某一方面的功能级测试。例如，用户登录到系统，用户从系统中注销。另一个例子是用户转到他们的个人资料并更新信息。这样的测试比单元测试和集成测试要广泛得多，因此它们揭示了系统级的问题(如果存在的话)。

# 验收测试构建阶段

运行一套验收测试应该是部署管道的第二道门。验收测试还充当回归测试套件，以验证系统中没有引入新特性。在这个阶段，验收测试套件中出现的任何测试失败都需要逐个案例地进行评估。失败可能是由于系统中有意的行为改变，因此验收测试套件需要更新，或者失败可能代表需要解决的回归。不管怎样，验收测试套件必须尽快修复。验收测试充当另一个入口，以便部署管道能够继续进行。

# 手动测试

验收测试确实提供了系统行为正常的保证，但是只有人类才能检测到系统中的异常。质量保证/测试人员可以执行系统的用户级测试，以确保系统的适当可用性。测试人员也可以对系统进行探索性测试。自动化验收测试套件有助于为测试人员腾出时间来执行这种更高价值的测试。

# 非功能测试

非功能测试之所以被恰当地命名，是因为这些类型的测试不是系统的功能需求。相反，非功能测试测试诸如系统的容量和安全性。部署管道的这一步中的失败可能不需要将构建标记为失败，而可以简单地作为构建的决策度量。

# 释放准备

进行发布时总会有相关的风险，因此在进行软件发布时最好有适当的流程。发布过程中出现的问题将被避免，但可以通过在发布过程中设置流程来缓解这些问题。

以下是发布过程中可能要遵循的一些步骤:

*   创建一个发布计划，该计划涉及并由交付产品的每个人创建
*   尽可能多地自动化发布过程，以防止错误
*   发行版应该经常在类似生产的环境中排练，以帮助调试可能出现的问题
*   设置流程以迁移正在使用的任何生产数据，并在回滚(将版本还原回版本)或升级系统时迁移配置信息

# 自动化发布流程

尽可能多地尝试自动化发布过程，因为自动化程度越高，您对发布过程的控制就越多。手动步骤容易出错，并可能导致意想不到的结果。生产环境中发生的任何更改都需要正确锁定，这意味着更改是通过自动化流程完成的。

# 进行回滚

发布日往往压力很大，因为发布过程中出现的错误可能会产生难以检测的问题，或者正在发布的新系统可能有缺陷。排练版本有助于缓解此类问题，并能帮助人们快速解决可能遇到的问题。

最好的策略是在发布前和发布后准备好软件系统的前一个版本，以防您必须将系统回滚到前一个版本；这不包括任何必要的数据迁移或配置。作为另一个可行的替代方案，您可以重新部署一个已知良好的应用版本。点击一个按钮就可以完成回滚。

# 部署脚本

部署脚本是必要的，因为开发团队编写的软件不仅仅在他们的集成开发环境或本地环境中运行，而是需要在部署管道中运行。部署脚本是指您用来为部署管道编写脚本的特定构建工具。

# 构建工具概述

已经有很多构建工具，每一个都有自己的优缺点。下面是一个构建工具的小列表:

*   **Make**([https://www.gnu.org/software/make/](https://www.gnu.org/software/make/)):Make 是一个与语言无关的构建工具，已经使用了很长时间
*   **Maven**([https://maven.apache.org/](https://maven.apache.org/)):Maven 是一个主要用于 Java 项目的构建工具
*   **MsBuild**([https://docs . Microsoft . com/en-us/visualstudio/MsBuild/MsBuild](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild)):MsBuild 是一个构建工具，主要用于。NET 编程语言家族
*   **耙子**([https://ruby.github.io/rake/](https://ruby.github.io/rake/)):耙子是一种类似 Make 的构建工具，最初是为 Ruby 设计的
*   https://gulpjs.com/:一个用于前端网络开发的构建工具
*   **堆栈**([https://docs.haskellstack.org/en/stable/README/](https://docs.haskellstack.org/en/stable/README/)):用于哈斯克尔环境的构建工具

# 部署脚本概念

无论您使用什么构建工具，在执行部署脚本时，您都需要遵循特定的实践。

# 为部署管道中的每个阶段编写脚本

在部署管道的提交阶段，您将拥有部署脚本需要执行的操作。例如，您可能需要编译任何源文件，运行一套单元和集成测试，并运行一个检查代码风格的林挺工具，或许还有一个静态分析工具。所有这些步骤可能需要使用不同的工具，所以编写一个脚本来完成所有这些是最好的。根据脚本的特定操作，您可能希望进一步将脚本分解为执行集中操作的下标。在验收测试阶段，您的脚本可能会运行整个验收测试套件，并生成一些关于测试的报告和度量。

# 每个环境都应该使用相同的脚本

您应该在所有环境中使用完全相同的脚本，因为这将确保构建和部署过程在每个环境中以相同的方式进行。如果每个环境都有不同的脚本，那么您无法确保正在运行的特定脚本在不同的环境中表现相同。开发人员在本地环境中运行的部署脚本应该与在其他环境中运行的脚本相同，否则会有环境泄漏的风险。我们在这里的意思是，开发人员环境可能有特定的环境变量集，而不是部署脚本，或者每个环境(如开发、试运行和生产)可能有不同的环境变量集，这将使调试在出现问题时更加困难。

# 部署过程不应在每次运行时改变

部署过程应该在每次运行时保持不变。数学上有个术语叫**幂等**，基本上是说某个运算可以做多次，结果相同。如果您的部署过程在任何给定的运行中发生了变化，那么您就不能保证每次运行的行为，这反过来会使故障排除变得更加困难。

# 部署脚本最佳实践

本节讨论部署脚本的最佳实践，例如确保只测试已知的良好基础、测试环境配置、使用相对路径以及删除手动过程。

# 仅测试已知的良好基础

您不应该测试甚至不能编译的源代码，并且当单元和集成测试失败时，您不应该费心运行任何验收测试。基本上，对于要运行和继续的部署过程的任何附加阶段，必须存在已知的良好基线。

# 测试环境配置

由于部署管道正在经历每个阶段，并随后经历每个阶段，因此最好检查各个阶段是否正常运行。你在相关阶段所做的测试可以被认为是**冒烟**测试。例如，通过访问网址来检查网站是否启动并运行，以及检查数据库中的记录是否仍然可以被提取。

# 使用相对路径

最好使用相对路径而不是绝对路径。开发人员可能具有某个文件系统或文件夹结构，但在运行部署管道的环境中不存在，因此最好使用相对路径，以免造成意外损坏。有时做到这一点可能很难，但最好尽可能多地遵循它。Docker 容器可以映射每个容器的文件夹结构；例如，如果 Docker 容器在部署管道的特定部分产生，它也可以映射到某个相对文件夹结构。

# 删除手动流程

避免生成包含完成部署特定部分必须执行的步骤列表的构建脚本。

以下是手动流程中可能的步骤列表:

*   将项目根目录下的所有图像复制到`static/build`文件夹中
*   在新的生产版本上运行数据的手动迁移
*   如果有人必须进入一个盒子并运行一个脚本，这可能是有问题的

任何必须手动完成的步骤都会很快在文档中过时，因此最容易遵循的指导是，如果必须第二次执行某个操作，则进行自动化流程。

# 部署生态系统

在本节中，我们将简要介绍一些可以在您的部署管道中帮助您的工具，这些工具有不同的用途。

# 基础设施工具

我们在本章前面简单提到了厨师；Chef 是一个很好的工具，可以用来以可靠的方式自动建立基础设施。如果没有适当的工具，很难确保您设置的每个新环境都以相同的方式完成。您可能会创建具有不同配置的新环境，这在故障排除时可能会很成问题。

# 云提供商和工具

三大云提供商都有自己的相关工具:

*   **AWS**([https://aws.amazon.com/](https://aws.amazon.com/)):AWS 有一套 CI/CD 工具；
    *   **AWS CodeCommit** 是一个完全托管的源代码管理服务。更多信息请参考[https://aws.amazon.com/codecommit/](https://aws.amazon.com/codecommit/)。
    *   **AWS CodeDeploy** 是一项将软件部署自动化到各种计算服务的服务，包括 Amazon EC2、AWS Lambda 和内部运行的实例。更多信息请参考[https://aws.amazon.com/codedeploy/](https://aws.amazon.com/codedeploy/)。
*   **微软 Azure**([https://azure.microsoft.com/en-us/](https://azure.microsoft.com/en-us/)):Visual Studio Team Services 是一个端到端的 CI/CD 服务。更多信息请参考[https://visualstudio.microsoft.com/team-services/](https://visualstudio.microsoft.com/team-services/)。

*   **谷歌应用引擎**([https://visualstudio.microsoft.com/team-services/](https://visualstudio.microsoft.com/team-services/)):谷歌应用引擎比其他云提供商更不可知论。

您可以对所有主要的云提供商使用 Jenkins、Travis 和 CircleCI/CD 工具，尽管微软 Azure 和 AWS 已经创建了自己的 CI/CD 工具，您也可以使用。

# 摘要

正如我们所看到的，光盘围绕着自动化的概念。在本章中，我们已经了解了交付软件的含义。我们首先研究了交付软件时出现的常见问题。我们还详细讨论了配置管理以及版本控制和依赖管理在任何配置中扮演的角色。我们还查看了部署管道，并深入查看了不同的构建阶段。在部署脚本部分，我们查看了一些现有的构建工具，并设置了一些最佳实践。最后，我们简要介绍了部署生态系统和一些云提供商。在下一章中，我们将讨论不同团队之间的沟通问题，如何将痛点传达给其他团队成员，如何在不同团队之间分担责任，向利益相关方演示为什么 CI/CD 很重要，以及如何获得业务利益相关方对 CI/CD 的认可。

# 问题

1.  我们所说的交付软件是什么意思？
2.  说出一些常见的反发布模式。
3.  说出交付软件时自动化的一些好处。
4.  配置管理到底意味着什么？
5.  为什么要写描述性和有意义的提交消息？
6.  什么是部署管道？
7.  为什么每个环境中的部署方式都应该相同？

# 进一步阅读

考虑阅读 *Packt Publishing* 所著的《DevOps:用 DevOps 进行持续交付、集成和部署》一书，对 CD 有更深入的了解。**