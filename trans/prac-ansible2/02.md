# 理解 Ansible 的基本原理

Ansible 本质上是一个简单的框架，它将一个名为 **Ansible 模块**的小程序推送到目标节点。模块是 Ansible 的核心，负责执行自动化的所有艰苦工作。然而，Ansible 框架不止于此，还包括插件和动态库存管理，以及将所有这些与行动手册结合在一起，以自动化基础架构配置、配置管理、应用部署、网络自动化等等，如图所示:

![](Images/075a1fbf-b62c-4730-8456-c81515ebb75c.png)

Ansible 只需安装在管理节点上；从那里，它通过网络的传输层(通常是 SSH 或 WinRM)分发所需的模块来执行任务，并在任务完成后删除它们。通过这种方式，Ansible 保留了其无代理架构，并且不会用一次性自动化任务可能需要的代码来打乱您的目标节点。

在本章中，您将了解更多关于 Ansible 框架及其各种组件的组成，以及如何在用 YAML 语法编写的剧本中一起使用它们。因此，您将学习如何为您的 IT 操作任务创建自动化代码，并学习如何使用临时任务和更复杂的行动手册来应用这些代码。最后，您将了解 Jinja2 模板化如何允许您使用变量和动态表达式可重复地构建动态配置文件。

在本章中，我们将涵盖以下主题:

*   熟悉 Ansible 框架
*   浏览配置文件
*   命令行参数
*   定义变量
*   了解 Jinja2 过滤器

# 技术要求

本章假设您已经成功地将 Ansible 的最新版本(2.9，在撰写本文时)安装到 Linux 节点上，如[第 1 章](01.html)、*ansi ble 入门*中所述。它还假设您至少有一个其他的 Linux 主机来测试自动化代码；可用的主机越多，您就越能够开发本章中的示例并了解 Ansible。假设了 Linux 主机之间的 SSH 通信，以及它们的工作知识。

本章的代码包可在[https://github . com/packt publishing/Ansible-2-cook book/tree/master/Chapter % 202](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%202)上获得。

# 熟悉 Ansible 框架

在本节中，您将了解 Ansible 框架如何适应信息技术操作自动化。我们将首次解释如何启动 Ansible。一旦您理解了这个框架，您就可以开始学习更高级的概念，例如用自己的清单创建和运行行动手册。

为了通过 SSH 连接从您的 Ansible 控制机器到多个远程主机运行 Ansible 的临时命令，您需要确保在控制主机上安装了最新的 Ansible 版本。使用以下命令确认最新的 Ansible 版本:

```
$ ansible --version
ansible 2.9.6
 config file = /etc/ansible/ansible.cfg
 configured module search path = [u'/home/jamesf_local/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules']
 ansible python module location = /usr/lib/python2.7/dist-packages/ansible
 executable location = /usr/bin/ansible
 python version = 2.7.17 (default, Nov 7 2019, 10:07:09) [GCC 9.2.1 20191008]
```

您还需要确保与您将在清单中定义的每个远程主机的 SSH 连接。您可以在每台远程主机上使用简单的手动 SSH 连接来测试连接，因为 Ansible 将在所有基于 Linux 的远程自动化任务中使用 SSH:

```
$ ssh <username>@frontend.example.com
The authenticity of host 'frontend.example.com (192.168.1.52)' can't be established.
ED25519 key fingerprint is SHA256:hU+saFERGFDERW453tasdFPAkpVws.
Are you sure you want to continue connecting (yes/no)? yes
password:<Input_Your_Password>
```

在本节中，我们将从一些简单的连接测试开始，向您介绍 Ansible 的工作原理。通过遵循以下简单步骤，您可以了解 Ansible 框架如何访问多个主机来执行您的任务:

1.  创建或编辑您的默认清单文件`/etc/ansible/hosts`(您也可以通过传递`–-inventory=/path/inventory_file`等选项，用自己的清单文件指定路径)。向您的清单中添加一些示例主机—这些必须是 Ansible 要测试的真实机器的 IP 地址或主机名。以下是我的网络中的示例，但是您需要用这些来替换您自己的设备。每行添加一个主机名(或 IP 地址):

```
frontend.example.com
backend1.example.com
backend2.example.com

```

如果您的主机有 DNS 条目(或位于您的可解析控制节点上的`/etc/hosts`中)，则所有主机都应指定一个可解析的地址，即**完全限定域名** ( **FQDN** )。如果您没有设置域名系统或主机条目，这可以是 IP 地址。无论您为清单地址选择何种格式，您都应该能够成功 ping 通每台主机。请参见以下输出示例:

```
$ ping frontend.example.com
PING frontend.example.com (192.168.1.52): 56 data bytes
64 bytes from 192.168.1.52: icmp_seq=0 ttl=64 time=0.040 ms
64 bytes from 192.168.1.52: icmp_seq=1 ttl=64 time=0.115 ms
64 bytes from 192.168.1.52: icmp_seq=2 ttl=64 time=0.097 ms
64 bytes from 192.168.1.52: icmp_seq=3 ttl=64 time=0.130 ms 
```

2.  为了使自动化过程无缝，我们将生成一个 SSH 身份验证密钥对，这样我们就不必每次运行剧本时都输入密码。如果您还没有 SSH 密钥对，可以使用以下命令生成一个:

```
$ ssh-keygen 
```

当您运行`ssh-keygen`工具时，您将看到类似如下的输出。请注意，当出现提示时，应将`passphrase`变量留空；否则，每次要运行 Ansible 任务时，您都需要输入密码，这就取消了使用 SSH 密钥进行身份验证的便利性:

```
$ ssh-keygen 
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/doh/.ssh/id_rsa): <Enter>
Enter passphrase (empty for no passphrase): <Press Enter>
Enter same passphrase again: <Press Enter>
Your identification has been saved in /Users/doh/.ssh/id_rsa.
Your public key has been saved in /Users/doh/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:1IF0KMMTVAMEQF62kTwcG59okGZLiMmi4Ae/BGBT+24 doh@danieloh.com
The key's randomart image is:
+---[RSA 2048]----+
|=*=*BB==+oo |
|B=*+*B=.o+ . |
|=+=o=.o+. . |
|...=. . |
| o .. S |
| .. |
| E |
| . |
| |
+----[SHA256]-----+
```

3.  虽然有自动获取 SSH 密钥的条件，但建议您使用`ssh-agent`，因为这允许您加载多个密钥来针对各种目标进行身份验证。这将在未来对你非常有用，即使现在不是。启动`ssh-agent`并添加您的新身份验证密钥，如下所示(注意，您需要对打开的每个外壳都这样做):

```
$ ssh-agent bash
$ ssh-add ~/.ssh/id_rsa 
```

4.在对目标主机执行基于密钥的身份验证之前，您需要将刚刚生成的密钥对中的公钥应用于每台主机。您可以使用以下命令依次将密钥复制到每个主机:

```
$  ssh-copy-id -i ~/.ssh/id_rsa.pub frontend.example.com
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "~/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
doh@frontend.example.com's password:

Number of key(s) added: 1

Now try logging into the machine, with: "ssh 'frontend.example.com'"
and check to make sure that only the key(s) you wanted were added.
```

5.完成后，您现在应该能够在放入清单文件的主机上执行 Ansible `ping`命令。您会发现，在任何时候都不会提示您输入密码，因为到清单中所有主机的 SSH 连接都是使用您的 SSH 密钥对进行身份验证的。因此，您应该会看到类似如下的输出:

```
$ ansible all -i hosts -m ping
frontend.example.com | SUCCESS => {
 "changed": false, 
 "ping": "pong"
}
backend1.example.com | SUCCESS => {
 "changed": false, 
 "ping": "pong"
}
backend2.example.com | SUCCESS => {
 "changed": false, 
 "ping": "pong"
}
```

该示例输出是使用 Ansible 的默认详细级别生成的。如果您在此过程中遇到问题，您可以通过在运行时将一个或多个`-v`开关传递给`ansible`命令来提高 Ansible 的详细程度。对于大多数问题，建议您使用`-vvvv`，它为您提供了丰富的调试信息，包括原始 SSH 命令及其输出。例如，假设某台主机(如`backend2.example.com`)无法连接，您会收到类似如下的错误:

```
backend2.example.com | FAILED => SSH encountered an unknown error during the connection. We recommend you re-run the command using -vvvv, which will enable SSH debugging output to help diagnose the issue 
```

请注意，即使是 Ansible 也建议使用`-vvvv`开关进行调试。这可能会产生输出页面，但会包括许多有用的细节，例如用于生成到清单中目标主机的连接的原始 SSH 命令，以及该调用可能导致的任何错误消息。这在调试连接性或代码问题时非常有用，尽管开始时输出可能会有点大。然而，通过一些练习，你会很快学会解释它。

到目前为止，您应该已经很好地了解了 Ansible 是如何通过 SSH 与其客户端进行通信的。让我们进入下一部分，我们将更详细地了解组成 Ansible 的各种组件，因为这将有助于我们了解如何更好地使用它。

# 分解可转化的成分

Ansible 允许您在行动手册中定义策略、配置、任务序列和编排步骤，但实际上这只是您的想象。尽管您会发现大多数示例都是同步的，但是可以在远程机器上同步或异步地执行行动手册来管理您的任务。在本节中，您将了解 Ansible 的主要组件，并了解 Ansible 如何使用这些组件与远程主机通信。

为了理解各种组件，我们首先需要一个工作清单。让我们创建一个示例，最好包含多个主机，这可能与您在上一节中创建的示例相同。如该部分所述，您应该使用您可以从控制主机本身访问的主机的主机名或 IP 地址来填充清单:

```
remote1.example.com
remote2.example.com
remote3.example.com
```

为了真正理解 Ansible 及其各种组件是如何工作的，我们首先需要创建一个 Ansible 剧本。虽然我们到目前为止试验的临时命令只是单个任务，但是行动手册是按顺序(通常)运行的有组织的任务组。条件逻辑可以被应用，在任何其他编程语言中，它们将被认为是你的代码。在剧本的开头，你应该指定你的剧本的名字——虽然这不是强制性的，但为你所有的剧本和任务命名是一个很好的做法，因为如果没有这个，别人很难解释剧本的内容，甚至如果你过一段时间再来看，你也很难解释。让我们开始构建我们的第一个示例行动手册:

1.  在行动手册的最上方指定行动名称和运行任务的库存主机。此外，请注意`---`的使用，它表示 YAML 文件的开始(在 YAML 编写的Ansible剧本):

```
---
- name: My first Ansible playbook
  hosts: all
```

2.  之后，我们会告诉 Ansible，我们希望以超级用户(通常为`root`)的身份执行本剧本中的所有任务。我们用以下语句来做这件事(为了帮助你记忆，把`become`想象成`become superuser`的简写):

```
  become: yes
```

3.  在这个头之后，我们将指定一个任务块，它将包含一个或多个要按顺序运行的任务。现在，我们将简单地创建一个任务，使用`yum`模块更新 Apache 版本(正因为如此，本剧本仅适用于针对基于 RHEL、CentOS 或 Fedora 的主机运行)。我们还将指定一个称为处理程序的特殊元素。在[第四章](04.html)、*剧本和角色*中会更详细地介绍处理者，所以暂时不要太担心他们。简而言之，处理程序是一种特殊类型的任务，只有在发生变化时才会被调用。因此，在本例中，它会重新启动 web 服务器，但前提是它发生了变化，这样可以防止在多次运行剧本且没有 Apache 更新的情况下进行不必要的重新启动。以下代码准确地执行了这些功能，应该构成您的第一份行动手册的基础:

```
  tasks:
  - name: Update the latest of an Apache Web Server
    yum:
      name: httpd
      state: latest
    notify:
      - Restart an Apache Web Server

 handlers:
 - name: Restart an Apache Web Server
   service:
     name: httpd
     state: restarted
```

恭喜你，你现在有了你的第一本 Ansible 剧本！如果您现在运行它，您应该会看到它遍历清单中的所有主机，以及 Apache 包中的每个更新，然后重新启动更新包的服务。您的输出应该如下所示:

```
$ PLAY [My first Ansible playbook] ***********************************************

TASK [Gathering Facts] *********************************************************
ok: [remote2.example.com]
ok: [remote1.example.com]
ok: [remote3.example.com]

TASK [Update the latest of an Apache Web Server] *******************************
changed: [remote2.example.com]
changed: [remote3.example.com]
changed: [remote1.example.com]

RUNNING HANDLER [Restart an Apache Web Server] *********************************
changed: [remote3.example.com]
changed: [remote1.example.com]
changed: [remote2.example.com]

PLAY RECAP *********************************************************************
remote1.example.com : ok=3 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
remote2.example.com : ok=3 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
remote3.example.com : ok=3 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

如果您检查剧本的输出，您可以看到不仅命名剧本而且命名执行的每个任务的价值，因为它使解释运行的输出成为一个非常简单的任务。您还会看到运行任务有多种可能的结果；在前面的例子中，我们可以看到其中的两个结果——`ok`和`changed`。这些结果中的大多数都是不言自明的，`ok`表示任务成功运行，运行结果没有任何变化。在前面的行动手册中，这方面的一个例子是`Gathering Facts`阶段，这是一个收集目标主机信息的只读任务。因此，如果主机停机，它只能返回`ok`或失败状态，如`unreachable`。它永远不会返回`changed`。

但是，您可以在前面的输出中看到，所有三个主机都需要升级它们的 Apache 包，因此，`Update the latest of an Apache Web Server`任务的结果是所有主机的`changed`。这个`changed`结果意味着我们的`handler`变量被通知并且 web 服务器服务被重新启动。

如果我们再次运行剧本，我们知道 Apache 包不太可能需要再次升级。请注意这次行动手册输出的不同之处:

```
PLAY [My first Ansible playbook] ***********************************************

TASK [Gathering Facts] *********************************************************
ok: [remote1.example.com]
ok: [remote2.example.com]
ok: [remote3.example.com]

TASK [Update the latest of an Apache Web Server] *******************************
ok: [remote2.example.com]
ok: [remote3.example.com]
ok: [remote1.example.com]

PLAY RECAP *********************************************************************
remote1.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
remote2.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
remote3.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

您可以看到，这次`Update the latest of an Apache Web Server`任务的输出对于所有三个主机都是`ok`，这意味着没有应用任何更改(包没有更新)。因此，我们的处理程序不会得到通知，也不会运行——您可以看到，它甚至没有出现在前面的剧本输出中。这种区别很重要——Ansible 行动手册(以及支撑 Ansible 的模块)的目标应该是只在需要的时候进行更改。如果一切都是最新的，那么就不应该改变目标主机。应该避免对服务进行不必要的重启，也应该避免对文件进行不必要的更改。简而言之，Ansible 行动手册被设计为(并且应该被设计为)高效并实现目标机器状态。

这是一个关于编写您的第一本行动手册的速成班，但希望它能让您体验一下当您从单个临时命令过渡到更复杂的行动手册时，Ansible 能做些什么。在我们进一步研究 Ansible 语言和组件之前，让我们更深入地了解一下剧本所用的 YAML 语言。

# 学习 YAML 语法

在本节中，您将学习如何使用正确的语法编写 YAML 文件，以及在多台远程计算机上运行行动手册的最佳实践和技巧。Ansible 之所以使用 YAML，是因为它比其他常见的数据格式(如 XML 或 JSON)更便于人类读写。没有逗号、大括号或标签需要担心，代码中强制的缩进确保了它看起来整洁和容易。此外，大多数编程语言都有与 YAML 一起工作的库。

这反映了 Ansible 的核心目标之一——生成易于阅读(和编写)的代码，描述给定主机的目标状态。Ansible 行动手册(理想情况下)应该是自我记录的，因为在繁忙的技术环境中，记录通常是事后才想到的——那么，还有什么比通过负责部署代码的自动化系统记录更好的方法呢？

在我们深入 YAML 结构之前，先说一下文件本身。在 YAML 编写的文件可以选择以`---`开始(如前一节的示例剧本所示)，以`...`结束。这适用于 YAML 的所有文件，无论它是由 Ansible 还是其他系统使用，并且表明该文件是 YAML 语言的。你会发现大多数 Ansible 剧本的例子(以及角色和其他相关的 YAML 文件)以`---`开头，但不以`...`结尾——标题足以清楚地表明文件使用了 YAML 格式。

让我们通过上一节中创建的示例剧本来探索 YAML 语言:

1.  列表在 YAML 语言中是一个重要的结构——事实上，尽管它可能并不明显，但剧本中的`tasks:`块实际上是一个 YAML 列表。YAML 的列表以相同的缩进级别列出所有项目，每行以`-`开头。例如，我们使用以下代码更新了前面剧本中的`httpd`包:

```
  - name: Update the latest of an Apache Web Server
    yum:
      name: httpd
      state: latest
```

但是，我们可以指定要升级的软件包列表，如下所示:

```
  - name: Update the latest of an Apache Web Server
    yum:
      name:
        - httpd
        - mod_ssl
      state: latest
```

现在，我们不是向`name:`键传递一个值，而是传递一个 YAML 格式的列表，其中包含两个要更新的包的名称。

2.  在 YAML，字典是另一个重要的概念——正如我们已经广泛看到的，它们由`key: value`格式表示，但是字典中的所有项目都缩进了一级。这最容易通过一个示例来解释，因此请考虑我们示例行动手册中的以下代码:

```
    service:
      name: httpd
      state: restarted
```

在本例中(从`handler`开始)，`service`定义实际上是一个字典，`name`和`state`键都比`service`键多缩进两个空格。这种更高级别的缩进意味着`name`和`state`键与`service`键相关联，因此，在这种情况下，告诉`service`模块操作哪个服务(`httpd`)以及如何处理(重启)。

我们已经在这两个例子中观察到，通过混合列表和字典，您可以生成非常复杂的数据结构。

3.  随着您在剧本设计方面变得越来越先进(我们将在本书的后面部分看到这方面的例子)，您很可能开始产生相当复杂的变量结构，您将把这些结构放入它们自己的单独文件中，以保持您的剧本代码可读。下面是一个`variables`文件的例子，该文件提供了一家公司的两名员工的详细信息:

```
---
employees:
  - name: daniel
    fullname: Daniel Oh
    role: DevOps Evangelist
    level: Expert
    skills:
      - Kubernetes
      - Microservices
      - Ansible
      - Linux Container
  - name: michael
    fullname: Michael Smiths
    role: Enterprise Architect
    level: Advanced
    skills:
      - Cloud
      - Middleware
      - Windows
      - Storage
```

在这个例子中，您可以看到我们有一个包含每个员工详细信息的字典。员工本身是列表项(您可以发现这一点，因为行以`-`开头)，同样，员工技能也表示为列表项。您会注意到`fullname`、`role`、`level`和`skills`键与`name`处于同一缩进级别，但它们之前没有`-`功能。这告诉您它们与列表项本身一起在字典中，因此它们代表员工的详细信息。

4.  在解析语言时，YAML 非常注重字面意义，新的一行总是代表新的一行代码。如果您实际上需要添加一个文本块(例如，添加到一个变量)会怎么样？在这种情况下，您可以使用文字块标量`|`来写入多行，YAML 将忠实地保留新行、回车以及每行后面的所有空白(但是，请注意，每行开头的缩进是 YAML 语法的一部分):

```
Specialty: |
  Agile methodology
  Cloud-native app development practices
  Advanced enterprise DevOps practices
```

因此，如果我们让 Ansible 将前面的内容打印到屏幕上，它将显示如下(注意，前面的两个空格已经消失——它们被正确地解释为 YAML 语言的一部分，没有打印出来):

```
Agile methodology
Cloud-native app development practices
Advanced enterprise DevOps practices
```

与前面类似的是折叠块标量`>`，它与文字块标量相同，但不保留行尾。这对于非常长的字符串非常有用，您希望在单行上打印，但也希望在代码中换行以提高可读性。以我们的示例为例，采用以下变体:

```
Specialty: >
  Agile methodology
  Cloud-native app development practices
  Advanced enterprise DevOps practices
```

现在，如果我们要打印这个，我们会看到以下内容:

```
Agile methodologyCloud-native app development practicesAdvanced enterprise DevOps practices
```

我们可以在前面的示例中添加尾随空格，以防止单词相互冲突，但是我在这里没有这样做，因为我想为您提供一个易于解释的示例。

当您查看行动手册、可变文件等时，您会看到这些结构被反复使用。虽然定义简单，但它们非常重要——遗漏缩进级别或在列表项开始处遗漏`-`实例会导致您的整个行动手册无法运行。正如我们所发现的，您可以将所有这些不同的构造放在一起。下面的一个`variables`文件的代码块中提供了一个额外的示例供您考虑，它显示了我们在一个地方介绍的各种示例:

```
---
servers:
  - frontend
  - backend
  - database
  - cache
employees:
  - name: daniel
    fullname: Daniel Oh
    role: DevOps Evangelist
    level: Expert
    skills:
      - Kubernetes
      - Microservices
      - Ansible
      - Linux Container
  - name: michael
    fullname: Michael Smiths
    role: Enterprise Architect
    level: Advanced
    skills:
      - Cloud
      - Middleware
      - Windows
      - Storage
    Speciality: |
      Agile methodology
      Cloud-native app development practices
      Advanced enterprise DevOps practices
```

你也可以用缩写形式表达字典和列表，称为**流集合**。以下示例显示了与我们原始的`employees`变量文件完全相同的数据结构:

```
---
employees: [{"fullname": "Daniel Oh","level": "Expert","name": "daniel","role": "DevOps Evangelist","skills": ["Kubernetes","Microservices","Ansible","Linux Container"]},{"fullname": "Michael Smiths","level": "Advanced","name": "michael","role": "Enterprise Architect","skills":["Cloud","Middleware","Windows","Storage"]}]
```

虽然这显示了完全相同的数据结构，但你可以看到用肉眼阅读有多困难。流量收集在 YAML 没有广泛使用，我不建议你自己使用它们，但重要的是要理解它们，以防你遇到它们。您还会注意到，虽然我们已经开始讨论 YAML 的变量，但是我们还没有表达任何变量类型。YAML 试图根据变量包含的数据对变量类型做出假设，所以如果你想给变量赋值`1.0`，YAML 会假设它是一个浮点数。如果您需要将其表示为字符串(可能是因为它是版本号)，您需要在它周围加上引号，这将导致 YAML 解析器将其解释为字符串，如下例所示:

```
version: "2.0"
```

这就完成了我们对 YAML 语言语法的研究。现在已经完成了，在下一节中，让我们看一下组织自动化代码以保持其可管理性和整洁性的方法。

# 组织您的自动化代码

可以想象，如果你把所有需要的 Ansible 任务都写在一个巨大的剧本中，它会很快变得不可管理——也就是说，它很难阅读，很难被其他人理解，最重要的是，当事情出错时很难调试。Ansible 为您提供了许多将代码分成可管理块的方法；也许其中最重要的是角色的使用。角色(为了简单的类比)的行为就像传统高级编程语言中的一个库。我们将在[第 4 章](04.html)、*剧本和角色*中详细介绍角色。

然而，Ansible 还支持将代码分成可管理的块的其他方法，我们将在本节中简要探讨这些方法，作为本书后面更深入探讨角色的前奏。

让我们建立一个实际的例子。首先，我们知道我们需要为 Ansible 创建一个清单来运行。在本例中，我们将创建四个服务器的概念组，每个组包含两个服务器。我们假设的示例将包含一个前端服务器和一个虚拟应用的应用服务器，位于两个不同的地理位置。我们的库存文件将被称为`production-inventory`，示例内容如下:

```
[frontends_na_zone] 
frontend1-na.example.com 
frontend2-na.example.com

[frontends_emea_zone]
frontend1-emea.example.com
frontend2-emea.example.com

[appservers_na_zone]
appserver1-na.example.com
appserver2-na.example.com

[appservers_emea_zone]
appserver1-emea.example.com
appserver2-emea.example.com
```

现在，很明显，我们可以只编写一个庞大的剧本来解决这些不同主机上的所需任务，但正如我们已经讨论过的，这将是麻烦和低效的。相反，让我们将自动化这些不同主机的任务分解成更小的行动手册:

1.  创建行动手册，在特定主机组上运行连接测试，如`frontends_na_zone`。将以下内容写入行动手册:

```
---
- hosts: frontends_na_zone
  remote_user: danieloh
  tasks:
    - name: simple connection test
      ping:

```

2.  现在，尝试针对主机运行此行动手册(注意，我们已将其配置为连接到库存系统上的远程用户，称为`danieloh`，因此您需要创建此用户并设置适当的 SSH 密钥，或者在行动手册的`remote_user`行中更改用户)。设置身份验证后运行行动手册时，您应该会看到类似以下内容的输出:

```
$ ansible-playbook -i production-inventory frontends-na.yml

PLAY [frontends_na_zone] *******************************************************

TASK [Gathering Facts] *********************************************************
ok: [frontend1-na.example.com]
ok: [frontend2-na.example.com]

TASK [simple connection test] **************************************************
ok: [frontend1-na.example.com]
ok: [frontend2-na.example.com]

PLAY RECAP *********************************************************************
frontend1-na.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
frontend2-na.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 
```

3.  现在，让我们通过创建仅在应用服务器上运行的行动手册来扩展我们的简单示例。同样，我们将使用 Ansible `ping`模块来执行连接测试，但是在现实世界中，您将执行更复杂的任务，例如安装软件包或修改文件。从`appservers_emea_zone`清单中指定针对该主机组运行该行动手册。将以下内容添加到行动手册中:

```
---
- hosts: appservers_emea_zone
  remote_user: danieloh
  tasks:
    - name: simple connection test
      ping:

```

像以前一样，您需要确保您可以访问这些服务器，因此要么创建`danieloh`用户并为该帐户设置身份验证，要么更改示例行动手册中的`remote_user`行。完成此操作后，您应该能够运行行动手册，您将看到类似以下内容的输出:

```
$ ansible-playbook -i production-inventory appservers-emea.yml

PLAY [appservers_emea_zone] ****************************************************

TASK [Gathering Facts] *********************************************************
ok: [appserver2-emea.example.com]
ok: [appserver1-emea.example.com]

TASK [simple connection test] **************************************************
ok: [appserver2-emea.example.com]
ok: [appserver1-emea.example.com]

PLAY RECAP *********************************************************************
appserver1-emea.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
appserver2-emea.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

4.  目前为止，一切顺利。但是，我们现在有两本需要手动运行的行动手册，只针对我们的两个库存主机组。如果我们想要解决所有四个组，我们需要创建总共四个行动手册，所有这些都需要手动运行。这很难反映最佳自动化实践。如果有一种方法可以将这些单个的行动手册从一个顶级的行动手册中一起运行呢？这将使我们能够划分代码以保持可管理性，但也避免了运行行动手册时大量的手动工作。幸运的是，我们可以通过利用我们称之为`site.yml`的顶级剧本中的`import_playbook`指令来做到这一点:

```
---
- import_playbook: frontend-na.yml
- import_playbook: appserver-emea.yml
```

现在，当您使用`ansible-playbook`命令运行这一单个行动手册时，您会看到效果是一样的，就好像我们已经连续运行了这两个行动手册一样。这样，甚至在我们探索角色的概念之前，您就可以看到 Ansible 支持将代码分成可管理的块，而无需手动运行每个块:

```
$ ansible-playbook -i production-inventory site.yml

PLAY [frontends_na_zone] *******************************************************

TASK [Gathering Facts] *********************************************************
ok: [frontend2-na.example.com]
ok: [frontend1-na.example.com]

TASK [simple connection test] **************************************************
ok: [frontend1-na.example.com]
ok: [frontend2-na.example.com]

PLAY [appservers_emea_zone] ****************************************************

TASK [Gathering Facts] *********************************************************
ok: [appserver2-emea.example.com]
ok: [appserver1-emea.example.com]

TASK [simple connection test] **************************************************
ok: [appserver2-emea.example.com]
ok: [appserver1-emea.example.com]

PLAY RECAP *********************************************************************
appserver1-emea.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
appserver2-emea.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
frontend1-na.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
frontend2-na.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

对于地理位置不同的环境，您还可以做更多的事情，例如我们这里的简单示例，因为我们甚至没有涉及到诸如在库存中放置变量(例如，将不同的参数与不同的环境相关联)之类的事情。我们将在[第 3 章](03.html)、*定义您的库存*中对此进行更详细的探讨。

然而，希望已经掌握了足够的知识，这样您就可以开始就如何组织行动手册的代码做出明智的选择。当您完成本书的后续章节时，您将能够确定您是否希望将角色或`import_playbook`指令(或甚至两者)作为行动手册组织的一部分。

在下一节中，让我们继续我们关于 Ansible 的速成课程，看看配置文件和一些您可能觉得有价值的关键指令。

# 浏览配置文件

Ansible 的行为部分由其配置文件定义。中央配置文件(影响系统上所有用户的 Ansible 行为)可以在`/etc/ansible/ansible.cfg`找到。然而，这并不是 Ansible 寻找其配置的唯一地方；事实上，它将从顶部到底部看以下位置。

文件的第一个实例是它将使用的配置；所有其他的都被忽略，即使它们存在:

1.  `ANSIBLE_CONFIG`:由该环境变量的值指定的文件位置(如果设置)
2.  `ansible.cfg`:在当前工作目录中
3.  `~/.ansible.cfg`:在用户主目录中
4.  `/etc/ansible/ansible.cfg`:我们之前提到的中央配置

如果你通过包管理器安装了 Ansible，比如`yum`或`apt`，你几乎总能在`/etc/ansible`中找到一个名为`ansible.cfg`的默认配置文件。但是，如果您从源代码构建了 Ansible 或者通过`pip`安装了 ansi ble，则中央配置文件将不存在，您需要自己创建它。一个很好的起点是参考源代码中包含的示例 Ansible 配置文件，其副本可在 GitHub 上的[https://raw . githubuser content . com/ansi ble/ansi ble/develop/examples/ansi ble . CFG](https://raw.githubusercontent.com/ansible/ansible/devel/examples/ansible.cfg)找到。

在本节中，我们将详细介绍如何定位 Ansible 的运行配置以及如何操作它。大多数通过软件包安装 Ansible 的人发现，在不得不修改默认配置之前，他们可以用 Ansible 走很长一段路，因为它是经过精心设计的，可以在许多情况下工作。但是，如果您在环境中遇到了只能通过修改配置来更改的问题，了解一些关于配置 Ansible 的知识是很重要的。

显然，如果您没有安装 Ansible，那么探究它的配置就没有什么意义了，所以让我们通过发出如下命令来检查您是否安装了 Ansible 并正在工作(显示的输出来自编写本文时 Ansible 的最新版本，安装在带有 Homebrew 的 macOS 上):

```
$ ansible 2.9.6
  config file = None
  configured module search path = ['/Users/james/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /usr/local/Cellar/ansible/2.9.6_1/libexec/lib/python3.8/site-packages/ansible
  executable location = /usr/local/bin/ansible
  python version = 3.8.2 (default, Mar 11 2020, 00:28:52) [Clang 11.0.0 (clang-1100.0.33.17)]
```

让我们从探索 Ansible 提供的默认配置开始:

1.  下面代码块中的命令列出了 Ansible 支持的当前配置参数。它非常有用，因为它告诉您可以用来更改设置的环境变量(参见`env`字段)以及可以使用的配置文件参数和部分(参见`ini`字段)。给出了其他有价值的信息，包括默认配置值和配置描述(分别参见`default`和`description`字段)。所有信息来源于`lib/constants.py`。运行以下命令浏览输出:

```
$ ansible-config list 
```

以下是您将看到的输出类型的示例。当然，它有很多页面，但这里显示了一个片段作为示例:

```
$ ansible-config list
ACTION_WARNINGS:
  default: true
  description:
  - By default Ansible will issue a warning when received from a task action (module
    or action plugin)
  - These warnings can be silenced by adjusting this setting to False.
  env:
  - name: ANSIBLE_ACTION_WARNINGS
  ini:
  - key: action_warnings
    section: defaults
  name: Toggle action warnings
  type: boolean
  version_added: '2.5'
AGNOSTIC_BECOME_PROMPT:
  default: true
  description: Display an agnostic become prompt instead of displaying a prompt containing
    the command line supplied become method
  env:
  - name: ANSIBLE_AGNOSTIC_BECOME_PROMPT
  ini:
  - key: agnostic_become_prompt
    section: privilege_escalation
  name: Display an agnostic become prompt
  type: boolean
  version_added: '2.5'
  yaml:
    key: privilege_escalation.agnostic_become_prompt
.....
```

2.  如果希望看到所有可能的配置参数及其当前值的直观显示(无论它们是从环境变量还是从前面列出的某个位置的配置文件中配置的)，可以运行以下命令:

```
$ ansible-config dump 
```

输出显示了所有配置参数(以环境变量格式)以及当前设置。如果参数配置了默认值，系统会告诉您(参见每个参数名称后的`(default)`元素):

```
$ ansible-config dump
ACTION_WARNINGS(default) = True
AGNOSTIC_BECOME_PROMPT(default) = True
ALLOW_WORLD_READABLE_TMPFILES(default) = False
ANSIBLE_CONNECTION_PATH(default) = None
ANSIBLE_COW_PATH(default) = None
ANSIBLE_COW_SELECTION(default) = default
ANSIBLE_COW_WHITELIST(default) = ['bud-frogs', 'bunny', 'cheese', 'daemon', 'default', 'dragon', 'elephant-in-snake', 'elephant', 'eyes', 'hellokitty', 'kitty', 'luke-koala', 'meow', 'milk', 'moofasa', 'moose', 'ren', 'sheep', 'small', 'stegosaurus', 'stimpy', 'supermilker', 'three-eyes', 'turkey', 'turtle', 'tux', 'udder', 'vader-koala', 'vader', 'www']
ANSIBLE_FORCE_COLOR(default) = False
ANSIBLE_NOCOLOR(default) = False
ANSIBLE_NOCOWS(default) = False
ANSIBLE_PIPELINING(default) = False
ANSIBLE_SSH_ARGS(default) = -C -o ControlMaster=auto -o ControlPersist=60s
ANSIBLE_SSH_CONTROL_PATH(default) = None
ANSIBLE_SSH_CONTROL_PATH_DIR(default) = ~/.ansible/cp
....
```

3.  让我们通过编辑一个配置参数来看看对这个输出的影响。让我们通过设置一个环境变量来实现这一点，如下所示(这个命令已经在`bash` shell 中测试过了，但是对于其他 shell 可能会有所不同):

```
$ export ANSIBLE_FORCE_COLOR=True 
```

现在，让我们重新运行`ansible-config`命令，但这次让它只告诉我们已经从默认值更改的参数:

```
$ ansible-config dump --only-change
ANSIBLE_FORCE_COLOR(env: ANSIBLE_FORCE_COLOR) = True
```

这里可以看到`ansible-config`告诉我们只改变了`ANSIBLE_FORCE_COLOR`的默认值，设置为`True`，通过`env`变量进行设置。这是非常有价值的，尤其是当你不得不调试配置问题的时候。

当使用 Ansible 配置文件本身时，您会注意到它是 INI 格式的，这意味着它有像`[defaults]`这样的部分，格式为`key = value`的参数，以及以`#`或`;`开头的注释。您只需要在配置文件中放置您希望从默认值更改的参数，因此，如果您想创建一个简单的配置来更改默认清单文件的位置，它可能如下所示:

```
# Set my configuration variables
[defaults]
inventory = /Users/danieloh/ansible/hosts ; Here is the path of the inventory file
```

如前所述，`ansible.cfg`配置文件可能的有效位置之一是在您当前的工作目录中。这很可能在您的主目录中，因此在多用户系统中，我们强烈建议您仅将对 Ansible 配置文件的访问权限限制在您的用户帐户。在保护多用户系统上的重要配置文件时，您应该采取所有常见的预防措施，尤其是 Ansible 通常用于配置多个远程系统，因此，如果配置文件被无意中泄露，可能会造成很大的损害！

当然，Ansible 的行为不仅仅由配置文件和开关控制——您传递给各种 Ansible 可执行文件的命令行参数也非常重要。事实上，我们已经处理过一个了——在前面的例子中，我们向您展示了如何使用`ansible.cfg`中的`inventory`参数来更改 Ansible 查找其库存文件的位置。然而，在本书前面介绍的许多例子中，我们在运行 Ansible 时用`-i`开关覆盖了这一点。因此，让我们继续下一节，看看运行 Ansible 时命令行参数的使用。

# 命令行参数

在本节中，您将了解到命令行参数在剧本执行中的使用，以及如何利用一些更常用的参数。我们已经非常熟悉其中的一个参数`--version`开关，我们用它来确认是否安装了 Ansible(以及安装了哪个版本):

```
$ ansible 2.9.6
  config file = None
  configured module search path = ['/Users/james/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /usr/local/Cellar/ansible/2.9.6_1/libexec/lib/python3.8/site-packages/ansible
  executable location = /usr/local/bin/ansible
  python version = 3.8.2 (default, Mar 11 2020, 00:28:52) [Clang 11.0.0 (clang-1100.0.33.17)]
```

正如我们能够直接通过 Ansible 了解各种配置参数一样，我们也可以了解命令行参数。几乎所有可执行文件都有一个`--help`选项，您可以运行该选项来显示有效的命令行参数。让我们现在试试这个:

1.  执行`ansible`命令行时，可以查看所有选项和参数。使用以下命令:

```
$ ansible --help 
```

当您运行前面的命令时，您将看到大量有用的输出；下面的代码块显示了这方面的一个例子(您可能希望将它导入一个寻呼机，如`less`，这样您就可以轻松地阅读它):

```
$ ansible --help
usage: ansible [-h] [--version] [-v] [-b] [--become-method BECOME_METHOD] [--become-user BECOME_USER] [-K] [-i INVENTORY] [--list-hosts] [-l SUBSET] [-P POLL_INTERVAL] [-B SECONDS] [-o] [-t TREE] [-k]
               [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER] [-c CONNECTION] [-T TIMEOUT] [--ssh-common-args SSH_COMMON_ARGS] [--sftp-extra-args SFTP_EXTRA_ARGS] [--scp-extra-args SCP_EXTRA_ARGS]
               [--ssh-extra-args SSH_EXTRA_ARGS] [-C] [--syntax-check] [-D] [-e EXTRA_VARS] [--vault-id VAULT_IDS] [--ask-vault-pass | --vault-password-file VAULT_PASSWORD_FILES] [-f FORKS]
               [-M MODULE_PATH] [--playbook-dir BASEDIR] [-a MODULE_ARGS] [-m MODULE_NAME]
               pattern

Define and run a single task 'playbook' against a set of hosts

positional arguments:
  pattern host pattern

optional arguments:
  --ask-vault-pass ask for vault password
  --list-hosts outputs a list of matching hosts; does not execute anything else
  --playbook-dir BASEDIR
                        Since this tool does not use playbooks, use this as a substitute playbook directory.This sets the relative path for many features including roles/ group_vars/ etc.
  --syntax-check perform a syntax check on the playbook, but do not execute it
  --vault-id VAULT_IDS the vault identity to use
  --vault-password-file VAULT_PASSWORD_FILES
                        vault password file
  --version show program's version number, config file location, configured module search path, module location, executable location and exit
  -B SECONDS, --background SECONDS
                        run asynchronously, failing after X seconds (default=N/A)
  -C, --check don't make any changes; instead, try to predict some of the changes that may occur
  -D, --diff when changing (small) files and templates, show the differences in those files; works great with --check
  -M MODULE_PATH, --module-path MODULE_PATH
                        prepend colon-separated path(s) to module library (default=~/.ansible/plugins/modules:/usr/share/ansible/plugins/modules)
  -P POLL_INTERVAL, --poll POLL_INTERVAL
                        set the poll interval if using -B (default=15)
  -a MODULE_ARGS, --args MODULE_ARGS
                        module arguments
  -e EXTRA_VARS, --extra-vars EXTRA_VARS
                        set additional variables as key=value or YAML/JSON, if filename prepend with @
```

2.  我们可以从前面的代码中举一个例子来建立我们之前对`ansible`的使用；到目前为止，我们几乎只使用它来运行带有`-m`和`-a`参数的临时任务。但是，`ansible`也可以执行一些有用的任务，例如告诉我们库存中某个组的主机。我们可以使用本章前面使用的`production-inventory`文件来探索这一点:

```
$ ansible -i production-inventory --list-host appservers_emea_zone 
```

当你运行这个时，你应该看到`appservers_emea_zone`库存组的成员被列出。虽然可能有点做作，但当您开始使用动态清单文件时，这个示例非常有价值，您不能再仅仅将清单文件`cat`带到终端查看其内容:

```
$ ansible -i production-inventory --list-host appservers_emea_zone
  hosts (2):
    appserver1-emea.example.com
    appserver2-emea.example.com
```

`ansible-playbook`可执行文件也是如此。我们已经在本书前面的例子中看到了其中的一些，我们还可以做更多的事情。例如，前面我们讨论了使用`ssh-agent`来管理多个 SSH 认证密钥。虽然这使得运行行动手册变得简单(因为您不必将任何身份验证参数传递给 Ansible)，但这并不是唯一的方法。您可以使用其中一个命令行参数`ansible-playbook`来指定私有 SSH 密钥文件，如下所示:

```
$ ansible-playbook -i production-inventory site.yml --private-key ~/keys/id_rsa
```

同样，在前面的部分中，我们在剧本中为 Ansible 指定了要连接的`remote_user`变量。但是，命令行参数也可以为 playbook 设置此参数；因此，与其编辑剧本中的`remote_user`行，我们可以完全删除它，而是使用以下命令行字符串运行它:

```
$ ansible-playbook -i production-inventory site.yml --user danieloh
```

Ansible 的最终目标是让你的生活变得更简单，并从你的清单中删除平凡的日常任务。因此，这样做没有对错之分——您可以使用命令行参数指定您的私有 SSH 密钥，或者使用`ssh-agent`使其可用。同样，您可以将`remote_user`行放入您的行动手册中，或者在命令行中使用`--user`参数。最终，选择是你的，但重要的是要考虑到，如果你向多个用户分发剧本，他们都必须记住在命令行上指定远程用户，他们真的会记得这样做吗？如果他们不这样做，会有什么后果？如果`remote_user`线出现在剧本里，会不会因为用户账号已经在剧本里设定好了，让他们的生活更轻松，更不容易出错？

与 Ansible 的配置一样，您将经常使用一小部分命令行参数，并且有许多参数您可能永远不会接触到。重要的是，你知道它们在那里，以及如何找到它们，你可以就何时使用它们做出明智的决定。让我们进入下一部分，我们将更详细地了解带有 Ansible 的特殊命令。

# 理解临时命令

到目前为止，我们已经在本书中看到了一些特别的命令，但是概括地说，它们是您可以用 Ansible 运行的单个命令，利用 Ansible 模块，而不需要创建或保存行动手册。它们对于在许多远程机器上执行快速、一次性的任务，或者对于测试和理解您打算在行动手册中使用的 Ansible 模块的行为非常有用。它们既是一个很好的学习工具，也是一个快速而肮脏的工具(因为你从来不用剧本记录你的工作！)自动化解决方案。

就像每个 Ansible 示例一样，我们需要一个清单来运行。让我们重复使用之前的`production-inventory`文件:

```
[frontends_na_zone]
frontend1-na.example.com
frontend2-na.example.com

[frontends_emea_zone]
frontend1-emea.example.com
frontend2-emea.example.com

[appservers_na_zone]
appserver1-na.example.com
appserver2-na.example.com

[appservers_emea_zone]
appserver1-emea.example.com
appserver2-emea.example.com
```

现在，让我们从最快速、最脏的临时命令开始——在一组远程机器上运行一个原始 shell 命令。假设您想检查 EMEA 所有前端服务器的日期和时间是否同步，您可以通过使用监控工具或手动依次登录到每台服务器并检查日期和时间来完成。但是，您也可以使用 Ansible 临时命令:

1.  运行以下临时命令，从所有`frontends_emea_zone`服务器检索当前日期和时间:

```
$ ansible -i production-inventory frontends_emea_zone -a /usr/bin/date 
```

您将看到 Ansible 依次忠实地登录每台机器并运行`date`命令，返回当前日期和时间。您的输出将如下所示:

```
$ ansible -i production-inventory frontends_emea_zone -a /usr/bin/date
frontend1-emea.example.com | CHANGED | rc=0 >>
Sun 5 Apr 18:55:30 BST 2020
frontend2-emea.example.com | CHANGED | rc=0 >>
Sun 5 Apr 18:55:30 BST 2020
```

2.  运行该命令时，使用您登录的用户帐户运行该命令。您可以使用命令行参数(在上一节中讨论)以不同的用户身份运行:

```
$ ansible -i production-inventory frontends_emea_zone -a /usr/sbin/pvs -u danieloh

frontend2-emea.example.com | FAILED | rc=5 >>
  WARNING: Running as a non-root user. Functionality may be unavailable.
  /run/lvm/lvmetad.socket: access failed: Permission denied
  WARNING: Failed to connect to lvmetad. Falling back to device scanning.
  /run/lock/lvm/P_global:aux: open failed: Permission denied
  Unable to obtain global lock.non-zero return code
frontend1-emea.example.com | FAILED | rc=5 >>
  WARNING: Running as a non-root user. Functionality may be unavailable.
  /run/lvm/lvmetad.socket: access failed: Permission denied
  WARNING: Failed to connect to lvmetad. Falling back to device scanning.
  /run/lock/lvm/P_global:aux: open failed: Permission denied
  Unable to obtain global lock.non-zero return code
```

3.  这里我们可以看到`danieloh`用户账号没有成功运行`pvs`命令所需的权限。然而，我们可以通过添加`--become`命令行参数来解决这个问题，该参数告诉 Ansible 在远程系统上成为`root`:

```
$ ansible -i production-inventory frontends_emea_zone -a /usr/sbin/pvs -u danieloh --become

frontend2-emea.example.com | FAILED | rc=-1 >>
Missing sudo password
frontend1-emea.example.com | FAILED | rc=-1 >>
Missing sudo password
```

4.  我们可以看到命令仍然失败，因为虽然`danieloh`在`/etc/sudoers`中，但是不允许不输入`sudo`密码就以`root`的身份运行命令。幸运的是，有一个开关可以让 Ansible 在运行时提示我们，这意味着我们不需要编辑我们的`/etc/sudoers`文件:

```
$ ansible -i production-inventory frontends_emea_zone -a /usr/sbin/pvs -u danieloh --become --ask-become-pass
BECOME password:

frontend1-emea.example.com | CHANGED | rc=0 >>
 PV VG Fmt Attr PSize PFree
 /dev/sda2 centos lvm2 a-- <19.00g 0
frontend2-emea.example.com | CHANGED | rc=0 >>
 PV VG Fmt Attr PSize PFree
 /dev/sda2 centos lvm2 a-- <19.00g 0
```

5.  默认情况下，如果没有使用`-m`命令行参数指定模块，Ansible 会假设您想要使用`command`模块(参见[https://docs . ansi ble . com/ansi ble/latest/modules/command _ module . html](https://docs.ansible.com/ansible/latest/modules/command_module.html))。如果希望使用特定的模块，可以将`-m`开关添加到命令行参数中，然后在`-a`开关下指定模块参数，如下例所示:

```
$ ansible -i production-inventory frontends_emea_zone -m copy -a "src=/etc/yum.conf dest=/tmp/yum.conf"
frontend1-emea.example.com | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    },
    "changed": true,
    "checksum": "e0637e631f4ab0aaebef1a6b8822a36f031f332e",
    "dest": "/tmp/yum.conf",
    "gid": 0,
    "group": "root",
    "md5sum": "a7dc0d7b8902e9c8c096c93eb431d19e",
    "mode": "0644",
    "owner": "root",
    "size": 970,
    "src": "/root/.ansible/tmp/ansible-tmp-1586110004.75-208447517347027/source",
    "state": "file",
    "uid": 0
}
frontend2-emea.example.com | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    },
    "changed": true,
    "checksum": "e0637e631f4ab0aaebef1a6b8822a36f031f332e",
    "dest": "/tmp/yum.conf",
    "gid": 0,
    "group": "root",
    "md5sum": "a7dc0d7b8902e9c8c096c93eb431d19e",
    "mode": "0644",
    "owner": "root",
    "size": 970,
    "src": "/root/.ansible/tmp/ansible-tmp-1586110004.75-208447517347027/source",
    "state": "file",
    "uid": 0
} 
```

前面的输出不仅显示对两台主机成功执行了复制，还显示了来自`copy`模块的所有输出值。同样，这在您以后开发行动手册时非常有用，因为它使您能够准确地了解模块是如何工作的，以及在您需要使用该输出执行进一步工作的情况下，它会产生什么输出。然而，这是一个更高级的主题，超出了本章介绍的范围。

您还会注意到，传递给模块的所有参数都必须用引号(`"`)括起来。所有参数都指定为`key=value`对，`key`和`value`之间不应添加空格(例如，`key = value`不可接受)。如果需要在某个参数值周围加上引号，可以使用反斜杠字符对其进行转义(例如，`-a "src=/etc/yum.conf dest=\"/tmp/yum file.conf\""`)

到目前为止，我们执行的所有示例都非常容易执行和运行，但计算任务并不总是如此。当你必须长时间运行一个操作，比如两个多小时，你应该考虑把它作为一个后台进程运行。在这种情况下，您可以异步运行该命令，并在以后确认执行结果。

例如，要在后台异步执行`sleep 2h`，超时时间为 7，200 秒(`-B`)且不进行轮询(`-P`)，请使用以下命令:

```
$ ansible -i production-inventory frontends_emea_zone -B 7200 -P 0 -a "sleep 2h"
frontend1-emea.example.com | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    },
    "ansible_job_id": "537978889103.8857",
    "changed": true,
    "finished": 0,
    "results_file": "/root/.ansible_async/537978889103.8857",
    "started": 1
}
frontend2-emea.example.com | CHANGED => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    },
    "ansible_job_id": "651461662130.8858",
    "changed": true,
    "finished": 0,
    "results_file": "/root/.ansible_async/651461662130.8858",
    "started": 1
}
```

请注意，此命令的输出为每台主机上的每个任务提供了唯一的作业标识。现在假设我们想看看这个任务如何在第二个前端服务器上进行。只需从您的 Ansible 控制机器发出以下命令:

```
$ ansible -i production-inventory frontend2-emea.example.com -m async_status -a "jid=651461662130.8858"
frontend2-emea.example.com | SUCCESS => {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python"
    },
    "ansible_job_id": "651461662130.8858",
    "changed": false,
    "finished": 0,
    "started": 1
} 
```

在这里，我们可以看到工作已经开始，但没有完成。如果我们现在终止我们发出的`sleep`命令并再次检查状态，我们可以看到以下内容:

```
$ ansible -i production-inventory frontend2-emea.example.com -m async_status -a "jid=651461662130.8858"
frontend2-emea.example.com | FAILED! => {
 "ansible_facts": {
 "discovered_interpreter_python": "/usr/bin/python"
 },
 "ansible_job_id": "651461662130.8858",
 "changed": true,
 "cmd": [
 "sleep",
 "2h"
 ],
 "delta": "0:03:16.534212",
 "end": "2020-04-05 19:18:08.431258",
 "finished": 1,
 "msg": "non-zero return code",
 "rc": -15,
 "start": "2020-04-05 19:14:51.897046",
 "stderr": "",
 "stderr_lines": [],
 "stdout": "",
 "stdout_lines": []
}
```

这里我们看到一个`FAILED`状态结果，因为`sleep`命令被杀；它没有干净地退出并返回一个`-15`代码(参见`rc`参数)。当它被杀死时，没有输出被发送到`stdout`或`stderr`，但是如果有，Ansible 会捕获它并在前面的代码中显示它，这将有助于您调试故障。还包括许多其他有用的信息，包括任务实际运行了多长时间、结束时间等等。同样，当任务干净地退出时，返回有用的输出。

我们在 Ansible 中对临时命令的研究到此结束。到目前为止，您应该已经对 Ansible 的基本原理有了相当扎实的掌握，但是有一件重要的事情我们还没有看到，尽管我们简要地谈到了它——变量以及如何定义它们。我们将在下一节继续讨论这个问题。

# 定义变量

在本节中，我们将讨论变量的主题以及如何在 Ansible 中定义它们。您将逐步学习如何定义变量，并了解如何在 Ansible 中使用它们。

尽管自动化消除了以前手动任务中的许多重复，但并不是每个系统都是相同的。如果两个系统有一些细微的不同，您可以编写两个独特的剧本——每个系统一个。然而，这将是低效和浪费的，并且随着时间的推移很难管理(例如，如果一个剧本中的代码被更改，您如何确保它在第二个变体中被更新？).

同样，您可能需要在另一个系统中使用一个值——也许您需要获取一个数据库服务器的主机名，并使其对另一个可用。所有这些问题都可以通过变量来解决，因为它们允许相同的自动化代码在参数变化的情况下运行，并且允许值从一个系统传递到另一个系统(尽管这必须小心处理)。

让我们从在 Ansible 中定义变量开始。

Ansible 中的变量应该具有符合以下规则的格式良好的名称:

*   变量的名称必须只包含字母、下划线和数字，不允许有空格。
*   变量的名称只能以字母开头，它们可以包含数字，但不能以数字开头。

例如，以下是很好的变量名:

*   `external_svc_port`
*   `internal_hostname_ap1`

但是，以下示例都是无效的，不能使用:

*   `appserver-zone-na`
*   `cache server ip`
*   `dbms.server.port`
*   `01appserver`

正如在*学习 YAML 语法*一节中所讨论的，变量可以在字典结构中定义，如下所示。所有值都以键值对的形式声明:

```
region:
  east: app
  west: frontend
  central: cache
```

为了从前面的字典结构中检索特定的字段，可以使用以下符号之一:

```
# bracket notation
region['east']

# dot notation
region.east
```

对此有一些例外；例如，如果变量名以两个下划线开头和结尾(例如，`__variable__`)或包含已知的公共属性，则应使用`bracket notation`，如下所示:

*   `as_integer_ratio`
*   `symmetric_difference`

你可以在[上找到更多的信息。](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#creating-valid-variable-names)

这种字典结构在定义宿主变量时很有价值；虽然在本章的前面，我们使用了一组虚构的员工记录，这些记录被定义为一个Ansible的`variables`文件，但是您可以使用它来指定一些东西，例如一些`redis`服务器参数:

```
---
redis:
  - server: cacheserver01.example.com
    port: 6379
    slaveof: cacheserver02.example.com

```

然后可以通过您的行动手册应用这些参数，并且一个通用的行动手册可以用于所有`redis`服务器，而不管其配置如何，因为可变参数(如`port`和`master`服务器)都包含在变量中。

您还可以在行动手册中直接传递集合变量，甚至将它们传递给您调用的角色。例如，下面的剧本代码调用四个假设的角色，每个角色为每个角色的`username`变量分配不同的值。这些角色可用于在一台服务器(或多台服务器)上设置各种管理角色，随着公司人员的往来，每个角色都会传递一个不断变化的用户名列表:

```
roles:
  - role: dbms_admin
    vars:
      username: James
  - role: system_admin
    vars:
      username: John
  - role: security_amdin
    vars:
      username: Rock
  - role: app_admin
    vars:
      username: Daniel
```

要从剧本中访问变量，只需将变量名放在带引号的花括号对中。考虑以下示例行动手册(大致基于我们之前的`redis`示例):

```
---
- name: Display redis variables
  hosts: all

  vars:
    redis:
      server: cacheserver01.example.com
      port: 6379
      slaveof: cacheserver02.example.com

  tasks:
    - name: Display the redis port
      debug:
        msg: "The redis port for {{ redis.server }} is {{ redis.port }}"
```

这里，我们在剧本本身中定义了一个名为`redis`的变量。这个变量是一个字典，包含许多对我们的服务器可能很重要的参数。为了访问这些变量的内容，我们在它们周围使用成对的花括号(如前所述)，整个字符串都用引号括起来，这意味着我们不必单独给变量加引号。如果在本地计算机上运行剧本，您应该会看到如下输出:

```
$ ansible-playbook -i localhost, redis-playbook.yml

PLAY [Display redis variables] *************************************************

TASK [Gathering Facts] *********************************************************
ok: [localhost]

TASK [Display the redis port] **************************************************
ok: [localhost] => {
 "msg": "The redis port for cacheserver01.example.com is 6379"
}

PLAY RECAP *********************************************************************
localhost : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

虽然我们在这里访问这些变量是为了在调试消息中打印它们，但是您可以使用相同的大括号符号将它们分配给模块参数，或者用于您的剧本需要它们的任何其他目的。

Ansible，就像许多语言一样，有专门保留的变量，在剧本中有特殊的含义。在 Ansible 中，这些被称为神奇变量，你可以在[https://docs . ansi ble . com/ansi ble/latest/reference _ appendals/special _ variables . html](https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html)找到它们的完整列表。不用说，您不应该试图为自己的变量使用任何神奇的变量名。您可能会遇到以下一些常见的神奇变量:

*   `inventory_hostname`:在游戏中迭代的当前主机的主机名
*   `groups`:清单中主机组的字典，以及每个组的主机成员资格
*   `group_names`:当前主机(由`inventory_hostname`指定)所属的组列表
*   `hostvars`:清单中所有主机以及分配给每个主机的变量的字典

例如，所有主机的主机变量都可以使用`hostvars`在行动手册中的任何点访问，即使您只在一台特定的主机上操作。神奇的变量在剧本中非常有用，你会很快发现自己在使用它们，所以意识到它们的存在是很重要的。

您还应该注意，您可以在多个位置指定 Ansible 变量。Ansible 有严格的变量优先级顺序，你可以通过在优先级较低的地方设置变量的默认值，然后在后面的游戏中覆盖它们来利用这一点。由于各种原因，这很有用，尤其是当一个未定义的变量可能在剧本运行时造成混乱(或者甚至剧本会因此而失败)时。我们还没有讨论变量可以存储的所有位置，所以这里没有给出变量优先顺序的完整列表。

此外，它可以在 Ansible 版本之间进行更改，因此在使用和理解变量优先级时参考文档非常重要—有关更多信息，请访问[https://docs . Ansible . com/Ansible/latest/user _ guide/playbooks _ variables . html # variable-preference-I-where-I-put-a-variable](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable)。

以上就是我们对 Ansible 中变量的简要概述，尽管我们将在本书后面的例子中再次看到它们的使用。现在让我们以 Jinja2 过滤器来结束这一章，它为您的变量定义增加了强大的功能。

# 了解 Jinja2 过滤器

由于 Ansible 是用 Python 编写的，它继承了一个非常有用和强大的模板引擎，称为 Jinja2。我们将在本书的后面讨论模板化的概念，所以现在，我们将关注 Jinja2 的一个特定方面，即过滤。Jinja2 过滤器提供了一个非常强大的框架，您可以使用它来操作和转换数据。例如，也许您有一个需要转换成小写的字符串——您可以应用 Jinja2 过滤器来实现这一点。您还可以使用它来执行模式匹配、搜索和替换等操作。有数百个过滤器可供您使用，在本节中，我们希望让您对 Jinja2 过滤器有一个基本的了解，并了解一些如何应用它们的实用知识，如果您希望进一步探索该主题，还可以向您展示在哪里可以获得关于它们的更多信息。

值得注意的是，Jinja2 操作是在 Ansible 控制主机上执行的，只有过滤操作的结果会发送到远程主机。这是通过设计完成的，既为了一致性，也为了尽可能减少单个节点上的工作负载。

让我们通过一个实际的例子来探讨这一点。假设我们有一个 YAML 文件，其中包含一些我们想要解析的数据。我们可以很容易地从机器文件系统中读取一个文件，并使用`register`关键字捕获结果(`register`捕获任务的结果并将其存储在一个变量中——在运行`shell`模块的情况下，它捕获运行的命令的所有输出)。

我们的 YAML 数据文件可能如下所示:

```
tags:
  - key: job
    value: developer
  - key: language
    value: java
```

现在，我们可以创建一个剧本来读取这个文件并注册结果，但是我们如何实际地将它转换成 Ansible 可以理解和使用的变量结构呢？让我们考虑以下行动手册:

```
---
- name: Jinja2 filtering demo 1
  hosts: localhost

  tasks:
    - copy:
        src: multiple-document-strings.yaml
        dest: /tmp/multiple-document-strings.yaml
    - shell: cat /tmp/multiple-document-strings.yaml
      register: result
    - debug:
        msg: '{{ item }}'
      loop: '{{ result.stdout | from_yaml_all | list }}'
```

`shell`模块不一定从存储剧本的目录运行，所以我们不能保证它会找到我们的`multiple-document-strings.yaml`文件。然而，`copy`模块确实从当前目录中获取文件，因此使用它将文件复制到一个已知位置(例如`/tmp`)对于`shell`模块读取文件是有用的。然后在`loop`模块中运行`debug`模块。`loop`模块用于迭代`shell`命令中的所有`stdout`行，因为我们使用了两个 Jinja2 过滤器— `from_yaml_all`和`list`。

`from_yaml_all`过滤器将源文档行解析为 YAML，然后`list`过滤器将解析的数据转换为有效的Ansible列表。如果我们运行剧本，我们应该在原始文件中看到 Ansible 的数据结构表示:

```
$ ansible-playbook -i localhost, jinja-filtering1.yml

PLAY [Jinja2 filtering demo 1] *************************************************

TASK [Gathering Facts] *********************************************************
ok: [localhost]

TASK [copy] ********************************************************************
ok: [localhost]

TASK [shell] *******************************************************************
changed: [localhost]

TASK [debug] *******************************************************************
ok: [localhost] => (item={'tags': [{'value': u'developer', 'key': u'job'}, {'value': u'java', 'key': u'language'}]}) => {
 "msg": {
 "tags": [
 {
 "key": "job",
 "value": "developer"
 },
 {
 "key": "language",
 "value": "java"
 }
 ]
 }
}

PLAY RECAP *********************************************************************
localhost : ok=4 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

如您所见，我们已经生成了一个本身包含键值对的字典列表。

如果这个数据结构已经存储在我们的行动手册中，我们可以更进一步，使用`items2dict`过滤器将列表变成真正的`key: value`对，从数据结构中删除`key`和`value`项。例如，考虑第二个剧本:

```
---
- name: Jinja2 filtering demo 2
  hosts: localhost
  vars:
    tags:
      - key: job
        value: developer
      - key: language
        value: java

  tasks:
    - debug:
        msg: '{{ tags | items2dict }}'
```

现在，如果我们运行这个，我们可以看到我们的数据被转换成一组漂亮整洁的`key: value`对:

```
$ ansible-playbook -i localhost, jinja2-filtering2.yml
[WARNING]: Found variable using reserved name: tags

PLAY [Jinja2 filtering demo 2] *************************************************

TASK [Gathering Facts] *********************************************************
ok: [localhost]

TASK [debug] *******************************************************************
ok: [localhost] => {
 "msg": {
 "job": "developer",
---
 "language": "java"
 }
}

PLAY RECAP *********************************************************************
localhost : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

请注意行动手册顶部的警告。如果您试图为变量使用保留名称，Ansible 会显示一条警告，就像我们在这里所做的那样。通常，您不应该创建具有保留名称的变量，但是这里的示例演示了过滤器是如何工作的，以及如果您做了一些可能会导致问题的事情，Ansible 将如何尝试警告您。

在本节的前面，我们使用`shell`模块读取一个文件，并使用`register`将结果存储在一个变量中。这很好，虽然有点不雅。Jinja2 包含一系列的`lookup`过滤器，除了别的以外，可以读取给定文件的内容。让我们检查以下剧本的行为:

```
---
- name: Jinja2 filtering demo 3
  hosts: localhost
  vars:
    ping_value: "{{ lookup('file', '/etc/hosts') }}"
  tasks:
    - debug:
        msg: "ping value is {{ ping_value }}"
```

当我们运行这个程序时，我们可以看到 Ansible 已经为我们捕获了`/etc/hosts`文件的内容，而我们不需要像前面那样求助于`copy`和`shell`模块:

```
$ ansible-playbook -i localhost, jinja2-filtering3.yml

PLAY [Jinja2 filtering demo 3] *************************************************

TASK [Gathering Facts] *********************************************************
ok: [localhost]

TASK [debug] *******************************************************************
ok: [localhost] => {
 "msg": "ping value is 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4\n::1 localhost localhost.localdomain localhost6 localhost6.localdomain6\n\n"
}

PLAY RECAP *********************************************************************
localhost : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

您可能有兴趣探索许多其他过滤器，完整列表可在官方 Jinja2 文档([https://jinja.palletsprojects.com/en/2.11.x/](https://jinja.palletsprojects.com/en/2.11.x/))中找到。以下是一些其他示例，这些示例将让您了解 Jinja2 过滤器可以为您实现的功能，从引用字符串到连接列表，再到获取文件的有用路径信息:

```
# Add some quotation in the shell
- shell: echo {{ string_value | quote }}

# Concatenate a list into a specific string
{{ list | join("$") }}

# Have the last name of a specific file path
{{ path | basename }}

# Have the directory from a specific path
{{ path | dirname }}

# Have the directory from a specific windows path
{{ path | win_dirname }}

```

我们对 Jinja2 过滤的研究到此结束。这是一个巨大的话题，值得一本独一无二的书，但是，和以往一样，我希望这本实用指南给了你一些关于如何开始和在哪里找到信息的建议。

# 摘要

Ansible 是一个非常强大和通用的自动化引擎，可以用于各种各样的任务。在解决剧本创作和大规模自动化的更复杂挑战之前，了解如何工作的基本知识是至关重要的。Ansible 依赖于一种称为 YAML 的语言，这是一种易于阅读(和编写)的语法，支持快速开发易于阅读和维护的代码，并继承了它所使用的 Python 语言的许多有价值的特性，包括 Jinja2 过滤。

在本章中，您学习了使用各种 Ansible 程序的基础知识。然后，您学习了 YAML 语法，以及如何将代码分解成易于管理的块，以便于阅读和维护。我们探讨了在 Ansible 中使用临时命令、变量定义和结构，以及如何使用 Jinja2 过滤器来操作行动手册中的数据。

在下一章中，我们将更深入地了解 Ansible 清单，并探索一些您可能会发现有用的更高级的使用概念。

# 问题

1.  Ansible 的哪个组件允许您定义一个块来执行任务组作为游戏？

A) `handler`

B) `service`

C) `hosts`

D) `tasks`

E) `name`

2.  您使用 YAML 格式的哪种基本语法来启动文件？

A) `###`

B) `---`

C) `%%%`

D) `===`

E) `***`

3.  True 或 false–为了在 Ansible 中解释和转换输出数据，您需要使用 Jinja2 模板。

真的吗

假的

# 进一步阅读

*   要了解更多配置变量，请访问[https://docs . ansi ble . com/ansi ble/latest/reference _ appendations/config . html # ansi ble-configuration-settings](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings)。