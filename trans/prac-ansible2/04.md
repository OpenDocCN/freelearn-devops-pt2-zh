# 行动手册和角色

到目前为止，在本书中，为了简单起见，我们主要使用了特定的 Ansible 命令来帮助您理解基础知识。然而，Ansible 的命脉无疑是剧本，这是一种在创建有用结果的结构中的任务的逻辑组织(想想临时命令)。这可能是为了在新构建的虚拟机上部署 web 服务器，也可能是为了应用安全策略。它甚至可以处理虚拟机的整个构建过程！可能性是无穷的。正如我们已经介绍过的，可操作的行动手册旨在编写简单且易于阅读，它们旨在自我记录，因此将成为您的 IT 流程中有价值的一部分。

在本章中，我们将更深入地探讨剧本，从剧本创作的基础到更高级的概念，如在循环和块中运行任务、执行条件逻辑，以及——也许是剧本组织和代码重用最重要的概念之一——Ansible 角色。我们将在后面更详细地介绍角色，但请注意，在创建可管理的行动手册代码时，您会希望尽可能多地使用这一点。

具体而言，在本章中，我们将涵盖以下主题:

*   理解行动手册框架
*   理解角色—行动手册组织者
*   在代码中使用条件
*   循环重复任务
*   使用块对任务进行分组
*   通过策略配置游戏执行
*   使用`ansible-pull`

# 技术要求

本章假设您已经使用 Ansible 设置了控制主机，详见[第 1 章](01.html)、*ansi ble 入门*，并且使用的是最新版本—本章中的示例使用 Ansible 2.9 进行了测试。本章还假设您至少有一个额外的主机要测试，理想情况下，这应该是基于 Linux 的。虽然我们将在本章中给出主机名的具体示例，但是您可以自由地用自己的主机名和/或 IP 地址来替换它们，并且如何做到这一点的详细信息将在适当的地方提供。

本章的代码包可在此处获得:[https://github . com/packt publishing/Ansible-2-cook book/tree/master/Chapter % 204](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%204)。

# 理解行动手册框架

行动手册允许您简单轻松地管理多台机器上的多种配置和复杂部署。这是使用 Ansible 交付复杂应用的主要好处之一。使用行动手册，您可以在逻辑结构中组织您的任务，因为任务(通常)是按照编写的顺序执行的，这允许您对自动化过程有很好的控制。也就是说，异步执行任务是可能的，所以在任务没有按顺序执行的地方，我们将强调这一点。我们的目标是，一旦您完成本章，您将了解编写自己的 Ansible 行动手册的最佳实践。

虽然 YAML 格式易于阅读和书写，但在间距方面却非常迂腐。例如，您不能使用制表符来设置缩进，即使在屏幕上一个制表符和四个空格看起来可能是相同的——在 YAML，它们不是。如果您是第一次这样做，我们建议您采用 YAML 支持的编辑器来帮助您编写剧本，可能是 Vim、Visual Studio Code 或 Eclipse，因为这些将帮助您确保缩进是正确的。为了测试我们在本章中开发的行动手册，我们将重用在[第 3 章](03.html)、*定义您的*、*库存*中创建的库存的变体(除非另有说明):

```
[frontends]
frt01.example.com https_port=8443
frt02.example.com http_proxy=proxy.example.com

[frontends:vars]
ntp_server=ntp.frt.example.com
proxy=proxy.frt.example.com

[apps]
app01.example.com
app02.example.com

[webapp:children]
frontends
apps

[webapp:vars]
proxy_server=proxy.webapp.example.com
health_check_retry=3
health_check_interal=60
```

让我们开始写剧本吧。在[第 2 章](02.html)*中题为*分解Ansible组件*的章节中，了解了Ansible的基本原理，*我们介绍了行动手册的一些基本方面，因此在此不再赘述，而是在此基础上向您展示行动手册开发的全部内容:

1.  创建一个简单的行动手册，在清单文件中定义的`frontends`主机组中的主机上运行。我们可以使用行动手册中的`remote_user`指令设置将访问主机的用户，如下所示(您也可以使用命令行上的`--user`开关，但是由于本章是关于行动手册开发的，我们暂时忽略这一点):

```
---
- hosts: frontends
  remote_user: danieloh

  tasks:
  - name: simple connection test
    ping:
    remote_user: danieloh
```

2.  在第一个任务下面添加另一个任务来运行`shell`模块(这将依次在远程主机上运行`ls`命令)。我们还将向该任务添加`ignore_errors`指令，以确保如果`ls`命令失败(例如，如果我们试图列出的目录不存在)，我们的剧本不会失败。小心缩进，确保它与文件第一部分的缩进相匹配:

```
  - name: run a simple command
    shell: /bin/ls -al /nonexistent
    ignore_errors: True
```

让我们看看我们新创建的行动手册在运行时的表现:

```
$ ansible-playbook -i hosts myplaybook.yaml

PLAY [frontends] ***************************************************************

TASK [Gathering Facts] *********************************************************
ok: [frt02.example.com]
ok: [frt01.example.com]

TASK [simple connection test] **************************************************
ok: [frt01.example.com]
ok: [frt02.example.com]

TASK [run a simple command] ****************************************************
fatal: [frt02.example.com]: FAILED! => {"changed": true, "cmd": "/bin/ls -al /nonexistent", "delta": "0:00:00.015687", "end": "2020-04-10 16:37:56.895520", "msg": "non-zero return code", "rc": 2, "start": "2020-04-10 16:37:56.879833", "stderr": "/bin/ls: cannot access /nonexistent: No such file or directory", "stderr_lines": ["/bin/ls: cannot access /nonexistent: No such file or directory"], "stdout": "", "stdout_lines": []}
...ignoring
fatal: [frt01.example.com]: FAILED! => {"changed": true, "cmd": "/bin/ls -al /nonexistent", "delta": "0:00:00.012160", "end": "2020-04-10 16:37:56.930058", "msg": "non-zero return code", "rc": 2, "start": "2020-04-10 16:37:56.917898", "stderr": "/bin/ls: cannot access /nonexistent: No such file or directory", "stderr_lines": ["/bin/ls: cannot access /nonexistent: No such file or directory"], "stdout": "", "stdout_lines": []}
...ignoring

PLAY RECAP *********************************************************************
frt01.example.com : ok=3 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=1
frt02.example.com : ok=3 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=1 
```

从剧本运行的输出中，您可以看到我们的两个任务是按照指定的顺序执行的。我们可以看到`ls`命令失败了，因为我们试图列出一个不存在的目录，但是行动手册没有注册任何`failed`任务，因为我们为这个任务(也只有这个任务)将`ignore_errors`设置为`true`。

大多数 Ansible 模块(除了那些运行用户定义命令的模块，如`shell`、`command`和`raw`)都被编码为幂等的，也就是说，如果您运行同一个任务两次，结果将是相同的，并且任务不会进行两次相同的更改——如果它检测到它被请求执行的操作已经完成，那么它不会再次执行它。当然，这对于上述模块来说是不可能的，因为它们可以用来执行几乎任何可以想象的任务——因此，模块怎么知道它被执行了两次？

每个模块都返回一组结果，其中包括任务状态。您可以在前面的行动手册运行输出的底部看到这些总结，它们的含义如下:

*   `ok`:任务运行成功，未进行任何更改。
*   `changed`:任务运行成功，进行了更改。
*   `failed`:任务运行失败。
*   `unreachable`:无法访问主机来运行任务。
*   `skipped`:该任务被跳过。
*   `ignored`:该任务被忽略(例如`ignore_errors`的情况)。
*   `rescued`:我们后面看拦网和救援任务的时候会看到这样的例子。

这些状态可能非常有用，例如，如果我们有一个任务要从模板部署一个新的 Apache 配置文件，我们知道必须重新启动 Apache 服务才能获得更改。但是，我们只希望在文件实际被更改的情况下这样做——如果没有进行任何更改，我们不希望不必要地重新启动 Apache，因为这会中断可能正在使用该服务的人。因此，我们可以使用`notify`动作，当(并且仅当)任务的结果是`changed`时，该动作告诉 Ansible 调用`handler`。简而言之，处理程序是一种特殊类型的任务，由于`notify`而运行。然而，与按顺序执行的 Ansible 剧本任务不同，处理程序都被分组在一起，并在剧本的最后运行。此外，它们可以被通知不止一次，但无论如何只会运行一次，这再次防止了不必要的服务重启。考虑以下行动手册:

```
---
- name: Handler demo 1
  hosts: frt01.example.com
  gather_facts: no
  become: yes

  tasks:
    - name: Update Apache configuration
      template:
        src: template.j2
        dest: /etc/httpd/httpd.conf
      notify: Restart Apache

  handlers:
    - name: Restart Apache
      service:
        name: httpd
        state: restarted
```

为了保持输出的简洁，我已经关闭了这个剧本的事实收集(我们不会在任何任务中使用它们)。为了简明起见，我也只在一台主机上运行这个程序，但是欢迎您按照自己的意愿扩展演示代码。如果我们第一次运行此任务，我们将看到以下结果:

```
$ ansible-playbook -i hosts handlers1.yml

PLAY [Handler demo 1] **********************************************************

TASK [Update Apache configuration] *********************************************
changed: [frt01.example.com]

RUNNING HANDLER [Restart Apache] ***********************************************
changed: [frt01.example.com]

PLAY RECAP *********************************************************************
frt01.example.com : ok=2 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

请注意，随着配置文件的更新，处理程序最后是如何运行的。但是，如果我们第二次运行此行动手册，而不对模板或配置文件进行任何更改，我们将看到如下内容:

```
$ ansible-playbook -i hosts handlers1.yml

PLAY [Handler demo 1] **********************************************************

TASK [Update Apache configuration] *********************************************
ok: [frt01.example.com]

PLAY RECAP *********************************************************************
frt01.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

这一次，作为配置任务的结果，处理程序没有被调用为 OK。所有处理程序都应该有一个全局唯一的名称，以便 notify 操作可以调用正确的处理程序。您也可以通过为使用`listen`指令设置一个公共名称来调用多个处理程序，这样，您可以调用处理程序`name`或`listen`字符串，如下例所示:

```
---
- name: Handler demo 1
  hosts: frt01.example.com
  gather_facts: no
  become: yes

  handlers:
    - name: restart chronyd
      service:
        name: chronyd
        state: restarted
      listen: "restart all services"
    - name: restart apache
      service:
        name: httpd
        state: restarted
      listen: "restart all services"

  tasks:
    - name: restart all services
      command: echo "this task will restart all services"
      notify: "restart all services"
```

我们在剧本中只有一个任务，但是当我们运行它时，两个处理程序都被调用。此外，请记住，我们之前说过`command`是一组特殊情况的模块之一，因为它们无法检测到是否发生了更改—因此，它们总是返回`changed`值，因此，在本演示剧本中，处理程序总是会得到通知:

```
$ ansible-playbook -i hosts handlers2.yml

PLAY [Handler demo 1] **********************************************************

TASK [restart all services] ****************************************************
changed: [frt01.example.com]

RUNNING HANDLER [restart chronyd] **********************************************
changed: [frt01.example.com]

RUNNING HANDLER [restart apache] ***********************************************
changed: [frt01.example.com]

PLAY RECAP *********************************************************************
frt01.example.com : ok=3 changed=3 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

这些是开始编写自己的行动手册时需要了解的一些基本知识。有了这些，让我们在下一节中对临时命令和行动手册进行比较。

# 比较行动手册和临时任务

即席命令允许您快速创建和执行一次性命令，而无需保存任何已完成操作的记录(除了您的 shell 历史记录)。这些服务于一个重要的目的，对于快速进行小的更改和学习 Ansible 及其模块非常有价值。

相比之下，行动手册是逻辑上组织好的任务集(每个任务集都可能是一个特别的命令)，按照执行一个更大动作的顺序放在一起。条件逻辑、错误处理等的增加意味着，通常情况下，行动手册的好处超过了临时命令的用处。此外，如果您保持它们的组织性，您将拥有您以前运行的所有行动手册的副本，因此您将能够回头查看(如果您需要的话)您运行的内容和时间。

让我们开发一个实际的例子——假设您想在 CentOS 上安装 Apache 2.4。即使默认配置已经足够，也需要执行许多步骤(这不太可能，但目前，我们将保持示例简单)。如果您要手动执行基本安装，您需要安装软件包，打开防火墙，并确保服务正在运行(并在启动时运行)。

要在 shell 中执行这些命令，您可以执行以下操作:

```
$ sudo yum install httpd
$ sudo firewall-cmd --add-service=http --permanent 
$ sudo firewall-cmd --add-service=https --permanent
$ sudo firewall-cmd --reload
$ sudo systemctl enable httpd.service
$ sudo systemctl restart httpd.service
```

现在，对于这些命令中的每一个，都有一个可以运行的等效的临时 Ansible 命令。为了太空的利益，我们不会在这里一一列举。但是，假设您想要重新启动 Apache 服务——在这种情况下，您可以运行类似于以下内容的临时命令(同样，为了简明起见，我们将只在一台主机上执行该命令):

```
$ ansible -i hosts frt01* -m service -a "name=httpd state=restarted"
```

当运行成功时，您将看到 shell 输出页面，其中包含以这种方式运行服务模块返回的所有变量数据。下面显示了其中的一个片段，供您检查自己的代码——关键是该命令导致了`changed`状态，这意味着它成功运行并且服务确实重新启动了:

```
frt01.example.com | CHANGED => {
 "ansible_facts": {
 "discovered_interpreter_python": "/usr/bin/python"
 },
 "changed": true,
 "name": "httpd",
 "state": "started",
```

您可以创建并执行一系列临时命令来复制前面给出的六个 shell 命令，并单独运行它们。稍微聪明一点，您应该将它从六个命令减少(例如，Ansible `service`模块既可以在启动时启用服务，也可以在一个临时命令中重新启动服务)。但是，您最终仍然会得到至少三四个临时命令，如果您想稍后在另一台服务器上再次运行这些命令，您需要参考您的笔记来找出您是如何做到的。

因此，行动手册是一种更有价值的方法，它不仅能一次性完成所有步骤，还能为您提供一份记录，让您日后参考。有多种方法可以做到这一点，但请考虑以下示例:

```
---
- name: Install Apache
  hosts: frt01.example.com
  gather_facts: no
  become: yes

  tasks:
    - name: Install Apache package
      yum:
        name: httpd
        state: latest
    - name: Open firewall for Apache
      firewalld:
        service: "{{ item }}"
        permanent: yes
        state: enabled
        immediate: yes
      loop:
        - "http"
        - "https"
    - name: Restart and enable the service
      service:
        name: httpd
        state: restarted
        enabled: yes
```

现在，当您运行此程序时，您应该会看到我们的所有安装要求都已由一个相当简单且易于阅读的行动手册完成。这里有一个新概念，循环，我们还没有涉及到，但是不用担心，我们将在本章的后面介绍:

```
$ ansible-playbook -i hosts installapache.yml

PLAY [Install Apache] **********************************************************

TASK [Install Apache package] **************************************************
changed: [frt01.example.com]

TASK [Open firewall for Apache] ************************************************
changed: [frt01.example.com] => (item=http)
changed: [frt01.example.com] => (item=https)

TASK [Restart and enable the service] ******************************************
changed: [frt01.example.com]

PLAY RECAP *********************************************************************
frt01.example.com : ok=2 changed=3 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

正如您所看到的，这对于捕获实际完成的工作并以其他人可以轻松获得的格式记录下来要好得多。尽管我们将在本书后面介绍循环，但从前面的内容中很容易看出它们是如何工作的。有了这些，让我们在下一部分更详细地看看我们已经使用过几次的几个术语，以确保您清楚它们的含义:**游戏**和**任务**。

# 定义游戏和任务

到目前为止，当我们使用行动手册时，我们一直在为每个行动手册创建一个单独的剧本(从逻辑上讲，这是您能做的最少的事情)。但是，在一个剧本中可以有多个剧本，用 Ansible 术语来说，“剧本”只是与一个主机(或一组主机)相关联的一组任务(以及角色、处理程序和其他 Ansible 方面)。任务是游戏中最小的元素，负责运行一个包含一组参数的模块来实现特定的目标。当然，从理论上讲，这听起来相当复杂，但当有实际例子支持时，理解起来就变得相当简单。

如果我们参考我们的示例清单，这描述了一个简单的两层架构(我们暂时省略了数据库层)。现在，假设我们想要编写一个剧本来配置前端服务器和应用服务器。我们可以使用两个单独的行动手册来配置前端和应用服务器，但这有可能会分割您的代码并使其难以组织。然而，前端服务器和应用服务器将会有本质上的不同，因此不太可能配置相同的任务集。

这个问题的解决方案是创建一个包含两个剧本的剧本。每场比赛的开始可以通过最低缩进处的线(即前面的零个空格)来识别。让我们开始构建我们的行动手册:

1.  将第一个剧本添加到剧本中，并定义一些简单的任务来在前端设置 Apache 服务器，如下所示:

```
---
- name: Play 1 - configure the frontend servers
  hosts: frontends
  become: yes

  tasks:
  - name: Install the Apache package
    yum:
      name: httpd
      state: latest
  - name: Start the Apache server
    service:
      name: httpd
      state: started
```

2.  紧接其后，在同一文件中，添加第二个剧本来配置应用层服务器:

```
- name: Play 2 - configure the application servers
  hosts: apps
  become: true

  tasks:
  - name: Install Tomcat
    yum:
      name: tomcat
      state: latest
  - name: Start the Tomcat server
    service:
      name: tomcat
      state: started
```

现在，您有两个剧本:一个在`frontends`组中安装 web 服务器，一个在`apps`组中安装应用服务器，所有这些都合并成一个简单的剧本。

当我们运行这个剧本时，我们将看到这两个剧本按照它们在剧本中出现的顺序依次执行。请注意`PLAY`关键字的存在，它表示每场比赛的开始:

```
$ ansible-playbook -i hosts playandtask.yml

PLAY [Play 1 - configure the frontend servers] *********************************

TASK [Gathering Facts] *********************************************************
changed: [frt02.example.com]
changed: [frt01.example.com]

TASK [Install the Apache package] *********************************************
changed: [frt01.example.com]
changed: [frt02.example.com]

TASK [Start the Apache server] *************************************************
changed: [frt01.example.com]
changed: [frt02.example.com]

PLAY [Play 2 - configure the application servers] *******************************

TASK [Gathering Facts] *********************************************************
changed: [app01.example.com]
changed: [app02.example.com]

TASK [Install Tomcat] **********************************************************
changed: [app02.example.com]
changed: [app01.example.com]

TASK [Start the Tomcat server] *************************************************
changed: [app02.example.com]
changed: [app01.example.com]

PLAY RECAP *********************************************************************
app01.example.com : ok=3 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
app02.example.com : ok=3 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
frt01.example.com : ok=3 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
frt02.example.com : ok=3 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

这就是我们的想法——一个剧本，但是两个不同的剧本在不同的主机上运行，来自提供的目录。这是非常强大的，尤其是当与角色结合时(这将在本书后面介绍)。当然，您的行动手册中可以只有一个剧本——您不必有多个剧本，但是能够开发多剧本是很重要的，因为随着您的环境变得更加复杂，您几乎肯定会发现它们很有用。

行动手册是 Ansible 自动化的命脉——它们将自动化从单一任务/命令(其本身的功能非常强大)扩展到以逻辑方式组织的一系列任务。然而，当你扩展你的剧本库的时候，你如何保持你的作品有条理？如何有效地重用相同的代码块？在前面的例子中，我们安装了 Apache，这可能是您的一些服务器的要求。但是，您是否应该尝试从一个剧本中管理它们？或者你应该一遍又一遍地复制和粘贴同一个代码块？有一个更好的方法，用简单的术语来说，我们需要开始考虑角色，这将在下一节中进行。

# 理解角色–行动手册组织者

角色旨在使您能够高效地重用 Ansible 代码。它们总是遵循一个已知的结构，并且通常包括变量、错误处理、处理程序等的合理默认值。从上一章的 Apache 安装示例中，我们知道这可能是我们想要一遍又一遍地做的事情，可能每次都使用不同的配置文件，也可能在每台服务器(或每个清单组)的基础上进行一些其他调整。在 Ansible 中，以这种方式支持代码重用的最有效方法是将其创建为角色。

创建角色的过程实际上非常简单——ansi ble 将(默认情况下)在运行剧本的同一个目录中寻找`roles/`目录，在这里，您将为每个角色创建一个子目录。角色名是从子目录名派生出来的——不需要创建复杂的元数据或其他任何东西——事实上就是这么简单。在每个子目录中有一个固定的目录结构，告诉 Ansible 每个角色的任务、默认变量、处理程序等是什么。

The `roles/` directory is not the only play Ansible will look for roles—this is the first directory it will look in, but it will then look in `/etc/ansible/roles` for any additional roles. This can be further customized through the Ansible configuration file, as discussed in [Chapter 2](02.html), *Understanding the Fundamentals of Ansible.*

让我们更详细地探讨一下这个问题。考虑以下目录结构:

```
site.yml
frontends.yml
dbservers.yml
roles/
   installapache/
     tasks/
     handlers/
     templates/
     vars/
     defaults/
   installtomcat/
     tasks/
     meta/
```

前面的目录结构显示了在我们假设的剧本目录中定义的两个角色，称为`installapache`和`installtomcat`。在每个目录中，您会注意到一系列子目录。这些子目录不需要存在(更多关于它们一分钟的意思，但是例如，如果您的角色没有处理程序，那么`handlers/`不需要创建)。但是，如果您确实需要这样一个目录，您应该用名为`main.yml`的 YAML 文件填充它。这些`main.yml`文件中的每一个都有特定的内容，这取决于包含它们的目录。

角色内部可以存在的子目录如下:

*   `tasks`:这是在角色中最常见的目录，它包含角色应该执行的所有 Ansible 任务。
*   `handlers`:角色中使用的所有处理程序都应该进入这个目录。
*   `defaults`:角色的所有默认变量都在这里。
*   `vars`:这些是其他角色变量——这些变量会覆盖`defaults/`目录中声明的变量，因为它们的优先级较高。
*   `files`:角色需要的文件应该放在这里——例如，任何需要部署到目标主机的配置文件。

*   `templates`:不同于`files/`目录，这个目录应该包含角色使用的所有模板。
*   `meta`:角色需要的任何元数据都在这里。例如，角色通常按照从父剧本中调用的顺序执行，但是，有时角色会有需要首先运行的依赖角色，如果是这种情况，可以在此目录中声明它们。

对于我们将在本章的这一部分中开发的示例，我们需要一个清单，因此让我们重用我们在上一节中使用的清单(为了方便起见，包含在下面):

```
[frontends]
frt01.example.com https_port=8443
frt02.example.com http_proxy=proxy.example.com

[frontends:vars]
ntp_server=ntp.frt.example.com
proxy=proxy.frt.example.com

[apps]
app01.example.com
app02.example.com

[webapp:children]
frontends
apps

[webapp:vars]
proxy_server=proxy.webapp.example.com
health_check_retry=3
health_check_interal=60
```

让我们从一些实践练习开始，帮助您学习如何创建和使用角色。我们将从创建一个名为`installapache`的角色开始，它将处理我们在上一节中看到的 Apache 安装过程。然而，在这里，我们将扩展它，以涵盖在 CentOS 和 Ubuntu 上安装 Apache。这是一个很好的实践，尤其是如果你希望将你的角色提交给社区，因为它们的目的越普遍(它们将工作的系统范围越广)，它们对人们就越有用。通过以下流程创建您的第一个角色:

1.  从您选择的行动手册目录中创建`installapache`角色的目录结构，就像这样简单:

```
$ mkdir -p roles/installapache/tasks
```

2.  现在，让我们在刚刚创建的`tasks`目录中创建强制的`main.yml`。这实际上不会执行 Apache 安装，而是会调用两个外部任务文件中的一个，具体取决于事实收集阶段在目标主机上检测到的操作系统。我们可以在`when`条件下使用这个特殊变量`ansible_distribution`，来确定要导入哪个任务文件:

```
---
- name: import a tasks based on OS platform 
  import_tasks: centos.yml 
  when: ansible_distribution == 'CentOS' 
- import_tasks: ubuntu.yml 
  when: ansible_distribution == 'Ubuntu'
```

2.  在`roles/installapache/tasks`中创建`centos.yml`，通过`yum`包管理器安装最新版本的 Apache 网络服务器。这应包含以下内容:

```
---
- name: Install Apache using yum
  yum:
    name: "httpd"
    state: latest
- name: Start the Apache server
  service:
    name: httpd
    state: started

```

3.  在`roles/installapache/tasks`中创建一个名为`ubuntu.yml`的文件，通过 Ubuntu 上的`apt`包管理器安装最新版本的 Apache 网络服务器。请注意 CentOS 和 Ubuntu 主机之间的内容差异:

```
---
- name: Install Apache using apt
  apt:
    name: "apache2"
    state: latest
- name: Start the Apache server
  service:
    name: apache2
    state: started
```

目前，我们保持我们的角色代码非常简单——然而，您可以看到前面的任务文件就像一个 Ansible 剧本，只是它们缺少剧本定义。因为它们不在剧本中，所以它们的缩进级别也比剧本中的低，但是除了这个区别，代码应该看起来非常熟悉。事实上，这也是角色之美的一部分:只要你注意把缩进级别做对，你就可以在剧本或角色中或多或少地使用相同的代码。

现在，角色不会自己运行——我们必须创建一个剧本来调用它们，所以让我们编写一个简单的剧本来调用我们新创建的角色。就像我们之前看到的那样，这有一个剧本定义，但是我们没有在剧本中有`tasks:`部分，而是有一个`roles:`部分，在那里角色被声明。按照惯例，这个文件被称为`site.yml`，但是你可以随意称呼它:

```
---
- name: Install Apache using a role
  hosts: frontends
  become: true

  roles:
    - installapache
```

为了清楚起见，您的最终目录结构应该如下所示:

```
.
├── roles
│   └── installapache
│   └── tasks
│   ├── centos.yml
│   ├── main.yml
│   └── ubuntu.yml
└── site.yml
```

完成后，您现在可以使用`ansible-playbook`以正常方式运行您的`site.yml`行动手册了，您应该会看到类似如下的输出:

```
$ ansible-playbook -i hosts site.yml

PLAY [Install Apache using a role] *********************************************

TASK [Gathering Facts] *********************************************************
ok: [frt01.example.com]
ok: [frt02.example.com]

TASK [installapache : Install Apache using yum] ********************************
changed: [frt02.example.com]
changed: [frt01.example.com]

TASK [installapache : Start the Apache server] *********************************
changed: [frt01.example.com]
changed: [frt02.example.com]

TASK [installapache : Install Apache using apt] ********************************
skipping: [frt01.example.com]
skipping: [frt02.example.com]

TASK [installapache : Start the Apache server] *********************************
skipping: [frt01.example.com]
skipping: [frt02.example.com]

PLAY RECAP *********************************************************************
frt01.example.com : ok=3 changed=2 unreachable=0 failed=0 skipped=2 rescued=0 ignored=0
frt02.example.com : ok=3 changed=2 unreachable=0 failed=0 skipped=2 rescued=0 ignored=0
```

就是这样——你已经在最简单的层面上创造了你的第一个角色。当然(正如我们之前所讨论的)，角色不仅仅是简单的任务，正如我们在这里所添加的，当我们完成本章时，我们将看到扩展的例子。但是，前面的示例旨在向您展示如何快速轻松地开始使用角色。

在我们了解与角色相关的一些其他方面之前，让我们先了解一下称呼您角色的其他方式。Ansible 允许您在编写剧本时静态导入或动态包含角色。导入或包含角色之间的语法略有不同，值得注意的是，两者都在行动手册的任务部分，而不是角色部分。下面是一个假设的例子，在一个非常简单的剧本中展示了这两个选项。包括`common`和`approle`角色的角色目录结构将以与前面示例类似的方式创建:

```
--- 
- name: Play to import and include a role
  hosts: frontends

  tasks:
  - import_role:
      name: common
  - include_role:
      name: approle
```

这些功能在 2.3 之前的 Ansible 版本中不可用，在 2.4 版本中，为了与其他 Ansible 功能的工作方式保持一致，它们的用法略有变化。我们不会在这里担心这方面的细节，因为 Ansible 现在在 2.9 版本上，所以除非您绝对必须运行 Ansible 的更早版本，否则假设这两个语句像我们将在下面概述的那样工作就足够了。

基本上，`import_role`语句在解析所有剧本代码时执行您指定的角色的静态导入。因此，当 Ansible 开始解析时，使用`import_role`语句带入您的剧本中的角色将被视为剧本或角色中的任何其他代码。使用`import_role`基本上等同于在`site.yml`中的`roles:`语句之后声明您的角色，就像我们在前面的示例中所做的那样。

`include_role`有细微但根本的不同，因为您指定的角色在最初解析剧本时不会被评估，而是在剧本运行期间遇到`include_role`时动态处理。

可能在前面给出的`include`或`import`语句之间进行选择的最基本原因是循环——如果您需要在循环中运行一个角色，您不能使用`import_role`这样做，因此必须使用`include_role`。然而，两者都有好处也有局限性，你需要选择最适合你的场景的一个——官方的 Ansible 文档([https://docs . ansi ble . com/ansi ble/latest/user _ guide/playbooks _ reuse . html # dynamic-vs-static](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html#dynamic-vs-static))将帮助你做出正确的决定。

正如我们在这一节中所看到的，角色非常容易上手，而且提供了一种非常强大的方式来组织和重用您的 Ansible 代码。在下一节中，我们将通过查看向代码中添加角色特定的变量和依赖项来扩展我们简单的基于任务的示例。

# 设置基于角色的变量和依赖关系

变量是使 Ansible 行动手册和角色可重用的核心，因为它们允许用稍微不同的值或配置数据重新调整相同代码的用途。Ansible 角色目录结构允许在两个位置声明特定于角色的变量。虽然，起初，这两个地点之间的差异似乎并不明显，但这是至关重要的。

基于角色的变量可以位于两个位置之一:

*   `defaults/main.yml`
*   `vars/main.yml`

这两个位置的区别在于它们在 Ansible 变量优先顺序中的位置。进入`defaults/`目录的变量是优先级最低的变量之一，因此很容易被覆盖。在这个位置，您可以放置想要轻松覆盖的变量，但不希望变量未定义。例如，如果您正在安装 Apache Tomcat，您可以构建一个角色来安装特定的版本。但是，如果有人忘记设置版本，您不希望角色因错误而退出，而是希望设置一个合理的默认值，如`7.0.76`，然后可以用库存变量或命令行(使用`-e`或`--extra-vars`开关)覆盖该默认值。这样，即使没有人显式设置该变量，您也知道该角色将会工作，但是如果需要，它可以很容易地更改为较新的 Tomcat 版本。

然而，进入`vars/`目录的变量在 Ansible 的变量优先顺序中要高得多。这不会被库存变量覆盖，因此应该用于变量数据，保持静态更重要。当然，这并不是说它们不能被覆盖——在 Ansible 中`-e`或`--extra-vars`开关是优先级最高的，因此会覆盖您定义的任何其他东西。

大多数情况下，您可能会单独使用基于`defaults/`的变量，但是毫无疑问会有这样的时候，让变量选项的优先顺序变得更高对您的自动化很有价值，所以知道这个选项对您来说是可用的是至关重要的。

除了前面描述的基于角色的变量，还可以选择使用`meta/`目录向角色添加元数据。和以前一样，要利用这一点，只需在这个目录中添加一个名为`main.yml`的文件。为了解释如何使用`meta/`目录，让我们构建并运行一个展示如何使用它的实际例子。在我们开始之前，需要注意的是，默认情况下，Ansible 解析器只允许您运行一次角色。这有点类似于我们前面讨论的处理程序的方式，它可以被调用多次，但最终在游戏结束时只运行一次。角色是相同的，因为它们可以被引用或引用多次，但实际上只会运行一次。对此有两个例外——第一个是如果角色被调用多次但使用不同的变量或参数，另一个是如果被调用的角色在其`meta/`目录中将`allow_duplicates`设置为`true`。我们将在构建示例时看到这两个示例:

1.  在我们的实际示例的顶层，我们将拥有一份我们在本章中一直使用的相同清单的副本。我们还将创建一个名为`site.yml`的简单剧本，其中包含以下代码:

```
---
- name: Role variables and meta playbook
  hosts: frt01.example.com

  roles:
    - platform
```

请注意，我们只是从本行动手册中调用了一个名为`platform`的角色，而没有从行动手册本身调用任何其他角色。

2.  让我们继续创建`platform`角色——与我们之前的角色不同，这将不包含任何任务甚至任何变量数据；相反，它将只包含一个`meta`目录:

```
$ mkdir -p roles/platform/meta
```

在该目录中，创建一个名为`main.yml`的文件，其内容如下:

```
---
dependencies:
- role: linuxtype
  vars:
    type: centos
- role: linuxtype
  vars:
    type: ubuntu
```

这段代码将告诉 Ansible 平台角色依赖于`linuxtype`角色。请注意，我们指定了依赖关系两次，但是对于我们指定的每种类型，我们都给它传递了一个名为`type`的不同值的变量——这样，Ansible 解析器允许我们调用角色两次，因为每次它被称为依赖关系时，都会给它传递不同的变量值。

3.  现在让我们继续创建`linuxtype`角色——同样，这将不包含任务，而是包含更多的依赖声明:

```
$ mkdir -p roles/linuxtype/meta/
```

再次，在`meta`目录中创建一个`main.yml`文件，但这次包含以下内容:

```
---
dependencies:
- role: version
- role: network
```

我们再一次创建了更多的依赖关系——这一次，当`linuxtype`角色被调用时，它反过来声明依赖于名为`version`和`network`的角色。

4.  让我们首先创建`version`角色—其中将包含`meta`和`tasks`目录:

```
$ mkdir -p roles/version/meta
$ mkdir -p roles/version/tasks
```

在`meta`目录下，我们将创建一个`main.yml`文件，内容如下:

```
---
allow_duplicates: true
```

这个声明在这个例子中很重要——如前所述，通常 Ansible 只允许一个角色被执行一次，即使它被多次调用。将`allow_duplicates`设置为`true`会告诉 Ansible 允许多次执行该角色。这是必需的，因为在`platform`角色中，我们两次调用(通过依赖项)`linuxtype`角色，这意味着我们将反过来调用`version`角色两次。

我们还将在任务目录中创建一个简单的`main.yml`文件，该文件打印传递给角色的`type`变量的值:

```
---
- name: Print type variable
  debug:
    var: type
```

5.  我们现在将使用`network`角色重复这个过程——为了保持我们的示例代码简单，我们将使用与`version`角色相同的内容来定义它:

```
$ mkdir -p roles/network/meta
$ mkdir -p roles/network/tasks
```

在`meta`目录中，我们将再次创建一个`main.yml`文件，其内容如下:

```
---
allow_duplicates: true
```

同样，我们将在`tasks`目录中创建一个简单的`main.yml`文件，该文件打印传递给角色的`type`变量的值:

```
---
- name: Print type variable
  debug:
    var: type
```

在此过程结束时，您的目录结构应该如下所示:

```
.
├── hosts
├── roles
│   ├── linuxtype
│   │   └── meta
│   │       └── main.yml
│   ├── network
│   │   ├── meta
│   │   │   └── main.yml
│   │   └── tasks
│   │       └── main.yml
│   ├── platform
│   │   └── meta
│   │       └── main.yml
│   └── version
│       ├── meta
│       │   └── main.yml
│       └── tasks
│           └── main.yml
└── site.yml

11 directories, 8 files
```

让我们看看当我们运行这个剧本时会发生什么。现在，您可能会认为剧本是这样运行的:使用我们在前面的代码中创建的依赖结构，我们的初始剧本静态地导入`platform`角色。`platform`角色随后声明它依赖于`linuxtype`角色，并且依赖关系在一个名为`type`的变量中用不同的值声明两次。`linuxtype`角色声明它依赖于`network`和`version`角色，这两个角色可以运行多次并打印`type`的值。因此，您可能会认为我们会看到`network`和`version`角色被调用两次，打印一次`centos`和第二次`ubuntu`(因为这是我们最初在`platform`角色中指定依赖关系的方式)。然而，当我们运行它时，我们实际上看到了这一点:

```
$ ansible-playbook -i hosts site.yml

PLAY [Role variables and meta playbook] ****************************************

TASK [Gathering Facts] *********************************************************
ok: [frt01.example.com]

TASK [version : Print type variable] *******************************************
ok: [frt01.example.com] => {
 "type": "ubuntu"
}

TASK [network : Print type variable] *******************************************
ok: [frt01.example.com] => {
 "type": "ubuntu"
}

TASK [version : Print type variable] *******************************************
ok: [frt01.example.com] => {
 "type": "ubuntu"
}

TASK [network : Print type variable] *******************************************
ok: [frt01.example.com] => {
 "type": "ubuntu"
}

PLAY RECAP *********************************************************************
frt01.example.com : ok=5 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

发生了什么事？虽然我们看到`network`和`version`角色被调用了两次(如预期的那样)，但是`type`变量的值始终是`ubuntu`。这突出了关于 Ansible 解析器工作方式的一个要点，以及静态导入(我们正在做)和动态包含(我们在上一节中讨论过)之间的区别。

使用静态导入，角色变量的作用域就像是在游戏级别而不是角色级别定义的一样。角色本身在解析时都被解析并合并到我们在`site.yml`剧本中创建的剧本中——因此，Ansible 解析器创建(在内存中)一个大剧本，其中包含我们目录结构中所有合并的变量和角色内容。这样做没有错，但这意味着每次声明`type`变量时都会被覆盖，因此我们声明的最后一个值(在本例中是`ubuntu`)是用于剧本运行的值。

那么，我们如何让这个剧本按照我们最初的计划运行——加载我们的从属角色，但是使用我们为`type`变量定义的两个不同的值？

这个问题的答案是，如果我们要继续使用静态导入的角色，那么我们在声明依赖关系时就不应该使用角色变量。相反，我们应该将`type`作为角色参数传递。这是一个很小但至关重要的区别——即使在运行 Ansible 解析器时，角色参数的作用域也保持在角色级别，因此我们可以声明我们的依赖关系两次，而不会覆盖变量。为此，将`roles/platform/meta/main.yml`文件的内容更改为以下内容:

```
---
dependencies:
- role: linuxtype
  type: centos
- role: linuxtype
  type: ubuntu
```

你注意到细微的变化了吗？`vars:`关键字已经没有了，`type`的声明现在处于较低的缩进级别，意味着它是一个角色参数。现在，当我们运行剧本时，我们得到了我们所希望的结果:

```
$ ansible-playbook -i hosts site.yml

PLAY [Role variables and meta playbook] ****************************************

TASK [Gathering Facts] *********************************************************
ok: [frt01.example.com]

TASK [version : Print type variable] *******************************************
ok: [frt01.example.com] => {
 "type": "centos"
}

TASK [network : Print type variable] *******************************************
ok: [frt01.example.com] => {
 "type": "centos"
}

TASK [version : Print type variable] *******************************************
ok: [frt01.example.com] => {
 "type": "ubuntu"
}

TASK [network : Print type variable] *******************************************
ok: [frt01.example.com] => {
 "type": "ubuntu"
}

PLAY RECAP *********************************************************************
frt01.example.com : ok=5 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

这是一个相当高级的 Ansible 角色依赖的例子，但是它已经被提供给你来演示稍微了解一下变量优先级(也就是变量的作用域)和解析器如何工作的重要性。如果您编写简单的、按顺序解析的任务，那么您可能永远不需要知道这一点，但是我建议您广泛使用 debug 语句并测试您的行动手册设计，以确保您在行动手册开发过程中不会违反这一点。

在详细了解了角色的许多方面之后，让我们在下一节中看看一个面向公众的Ansible角色的集中存储区——Ansible银河。

# `ansible-galaxy`

没有一个关于Ansible角色的章节是不完整的，除非提到Ansible星系。Ansible Galaxy 是一个由社区驱动的 Ansible 角色集合，由 Ansible 在[https://galaxy.ansible.com/](https://galaxy.ansible.com/)托管。它包含了许多社区贡献的 Ansible 角色，如果你能设想一个自动化任务，很有可能有人已经写了一个角色来做你想要它做的事情。这非常值得探索，并且可以让您的自动化项目快速启动，因为您可以使用一组现成的角色开始工作。

除了网站之外，`ansible-galaxy`客户端包含在 Ansible 中，这为您提供了一种快速方便的方法来下载角色并将其部署到您的行动手册结构中。假设您想在目标主机上更新当天的**消息**(**MOTD**)—这肯定是某人已经想通的事情。在 Ansible Galaxy 网站上的快速搜索返回(在撰写本文时)106 个设定 MOTD 的角色。如果我们想使用其中的一个，我们可以使用以下命令将其下载到我们的角色目录中:

```
$ ansible-galaxy role install -p roles/ arillso.motd
```

这就是您需要做的全部工作—下载完成后，您可以像本章中讨论的手动创建的角色一样，将该角色导入或包含在您的行动手册中。请注意，如果您没有指定`-p roles/`，`ansible-galaxy`会将角色安装到用户帐户的中心角色目录`~/.ansible/roles`中。当然，这可能是您想要的，但是如果您想要将角色直接下载到您的行动手册目录结构中，您可以添加此参数。

另一个巧妙的技巧是使用`ansible-galaxy`创建一个空的角色目录结构，以便您在其中创建自己的角色——这将保存我们在本章中进行的所有手动目录和文件创建，如本例所示:

```
$ ansible-galaxy role init --init-path roles/ testrole
- Role testrole was created successfully
$ tree roles/testrole/
roles/testrole/
├── defaults
│   └── main.yml
├── files
├── handlers
│   └── main.yml
├── meta
│   └── main.yml
├── README.md
├── tasks
│   └── main.yml
├── templates
├── tests
│   ├── inventory
│   └── test.yml
└── vars
 └── main.yml 
```

这应该会给你足够的信息来开始你的 Ansible 角色之旅。我再怎么强调作为角色开发您的代码有多重要也不为过——这在最初看起来并不重要，但是随着您的自动化用例的扩展，以及您对重用代码的需求的增长，您会很高兴您做到了。在下一节中，让我们扩展对 Ansible 行动手册的了解，讨论在 Ansible 代码中使用条件逻辑的方式。

# 在代码中使用条件

到目前为止，在我们的大多数示例中，我们已经创建了简单的任务集，这些任务集总是运行的。但是，当您生成要应用于更广泛的主机的任务(无论是角色还是行动手册)时，您迟早会想要执行某种有条件的操作。这可能是为了响应前一个任务的结果而只执行一个任务。或者，它可能只是为了响应从 Ansible 系统收集的特定事实而执行任务。在本节中，我们将提供一些应用于您的 Ansible 任务的条件逻辑的实际示例，以演示如何使用该功能。

和以往一样，我们需要一个清单来开始，我们将重复使用本章中使用的清单:

```
[frontends]
frt01.example.com https_port=8443
frt02.example.com http_proxy=proxy.example.com

[frontends:vars]
ntp_server=ntp.frt.example.com
proxy=proxy.frt.example.com

[apps]
app01.example.com
app02.example.com

[webapp:children]
frontends
apps

[webapp:vars]
proxy_server=proxy.webapp.example.com
health_check_retry=3
health_check_interal=60
```

假设您只想在某些操作系统上执行一个可执行的任务。我们已经讨论了 Ansible 事实，这些事实为您在行动手册中开始探索条件逻辑提供了完美的平台。请考虑这一点:已经为您的所有 CentOS 系统发布了紧急补丁，您希望立即应用它。当然，您可以浏览并为 CentOS 主机创建一个特殊的清单(或主机组)，但这是您不一定需要做的额外工作。

相反，让我们定义将执行我们的更新的任务，但是在一个简单的示例剧本中添加一个包含 Jinja 2 表达式的`when`子句:

```
---
- name: Play to patch only CentOS systems
  hosts: all
  become: true

  tasks:
  - name: Patch CentOS systems
    yum:
      name: httpd
      state: latest
    when: ansible_facts['distribution'] == "CentOS"
```

现在，当我们运行这个任务时，如果您的测试系统是基于 CentOS 的(我的也是)，您应该会看到类似如下的输出:

```
$ ansible-playbook -i hosts condition.yml

PLAY [Play to patch only CentOS systems] ***************************************

TASK [Gathering Facts] *********************************************************
ok: [frt02.example.com]
ok: [app01.example.com]
ok: [frt01.example.com]
ok: [app02.example.com]

TASK [Patch CentOS systems] ****************************************************
ok: [app01.example.com]
changed: [frt01.example.com]
ok: [app02.example.com]
ok: [frt02.example.com]

PLAY RECAP *********************************************************************
app01.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
app02.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
frt01.example.com : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
frt02.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

前面的输出显示我们所有的系统都是基于 CentOS 的，但是只有`frt01.example.com`需要应用补丁。现在我们可以使我们的逻辑更加精确——也许只有运行在 CentOS 6 上的遗留系统需要应用补丁。在这种情况下，我们可以扩展行动手册中的逻辑来检查发行版和主要版本，如下所示:

```
---
- name: Play to patch only CentOS systems
  hosts: all
  become: true

  tasks:
  - name: Patch CentOS systems
    yum:
      name: httpd
      state: latest
    when: (ansible_facts['distribution'] == "CentOS" and ansible_facts['distribution_major_version'] == "6")
```

现在，如果我们运行修改后的行动手册，根据您清单中的系统，您可能会看到类似以下的输出。在这种情况下，我的`app01.example.com`服务器基于 CentOS 6，所以应用了补丁。所有其他系统都被跳过，因为它们与我的逻辑表达式不匹配:

```
$ ansible-playbook -i hosts condition2.yml

PLAY [Play to patch only CentOS systems] ***************************************

TASK [Gathering Facts] *********************************************************
ok: [frt01.example.com]
ok: [app02.example.com]
ok: [app01.example.com]
ok: [frt02.example.com]

TASK [Patch CentOS systems] ****************************************************
changed: [app01.example.com]
skipping: [frt01.example.com]
skipping: [frt02.example.com]
skipping: [app02.example.com]

PLAY RECAP *********************************************************************
app01.example.com : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
app02.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=1 rescued=0 ignored=0
frt01.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=1 rescued=0 ignored=0
frt02.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=1 rescued=0 ignored=0
```

当然，这种条件逻辑并不局限于 Ansible 事实，在使用`shell`或`command`模块时可能会非常有价值。当您运行任何 Ansible 模块(无论是`shell`、`command`、`yum`、`copy`或其他模块)时，该模块都会返回详细说明其运行结果的数据。您可以使用`register`关键字在一个标准的 Ansible 变量中捕获它，然后在以后的剧本中进一步处理它。

考虑以下行动手册代码。它包含两个任务，第一个任务是获取当前目录的列表，并在名为`shellresult`的变量中捕获`shell`模块的输出。当这时打印一个简单的`debug`消息，但条件是`hosts`字符串是在`shell`命令的输出中:

```
---
- name: Play to patch only CentOS systems
  hosts: localhost
  become: true

  tasks:
    - name: Gather directory listing from local system
      shell: "ls -l"
      register: shellresult

    - name: Alert if we find a hosts file
      debug:
        msg: "Found hosts file!"
      when: '"hosts" in shellresult.stdout'
```

现在，当我们在当前目录中运行它时，如果您在本书附带的 GitHub 存储库中工作，它将包含一个名为`hosts`的文件，那么您应该会看到类似如下的输出:

```
$ ansible-playbook condition3.yml
[WARNING]: provided hosts list is empty, only localhost is available. Note that
the implicit localhost does not match 'all'

PLAY [Play to patch only CentOS systems] ***************************************

TASK [Gathering Facts] *********************************************************
ok: [localhost]

TASK [Gather directory listing from local system] ******************************
changed: [localhost]

TASK [Alert if we find a hosts file] *******************************************
ok: [localhost] => {
 "msg": "Found hosts file!"
}

PLAY RECAP *********************************************************************
localhost : ok=3 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

然而，如果文件不存在，那么您将看到`debug`消息被跳过:

```
$ ansible-playbook condition3.yml
[WARNING]: provided hosts list is empty, only localhost is available. Note that
the implicit localhost does not match 'all'

PLAY [Play to patch only CentOS systems] ***************************************

TASK [Gathering Facts] *********************************************************
ok: [localhost]

TASK [Gather directory listing from local system] ******************************
changed: [localhost]

TASK [Alert if we find a hosts file] *******************************************
skipping: [localhost]

PLAY RECAP *********************************************************************
localhost : ok=2 changed=1 unreachable=0 failed=0 skipped=1 rescued=0 ignored=0
```

还可以为生产中的 IT 运营任务创造复杂的条件；但是，请记住，在 Ansible 中，变量默认情况下不会转换为任何特定的类型，因此，即使变量(或事实)的内容看起来像一个数字，Ansible 默认情况下也会将其视为字符串。如果需要执行整数比较，必须首先将变量转换为整数类型。例如，这里有一个剧本的片段，它将只在 Fedora 25 和更新版本上运行一个任务:

```
tasks:
  - name: Only perform this task on Fedora 25 and later
    shell: echo "only on Fedora 25 and later"
    when: ansible_facts['distribution'] == "Fedora" and ansible_facts['distribution_major_version']|int >= 25

```

有许多不同类型的条件句可以应用到你的 Ansible 任务中，这部分只是触及表面；然而，它应该给你一个坚实的基础，在此基础上扩展你在 Ansible 中对任务应用条件的知识。您不仅可以将条件逻辑应用于 Ansible 任务，还可以在一组数据上循环运行它们，我们将在下一节对此进行探讨。

# 循环重复任务

通常，我们希望执行一个任务，但是使用这个任务来迭代一组数据。例如，您可能不想创建一个用户帐户，而是创建 10 个。或者您可能想要在一个系统上安装 15 个软件包。可能性是无穷无尽的，但重点是不变的——你不会想要编写 10 个独立的 Ansible 任务来创建 10 个用户帐户。幸运的是，Ansible 支持在数据集上循环，以确保您可以使用严格定义的代码执行大规模操作。在本节中，我们将探讨如何在您的 Ansible 行动手册中实际使用循环。

和以往一样，我们必须从一个清单开始，我们将使用我们现在已经熟悉的清单，这是我们在本章中一直使用的:

```
[frontends]
frt01.example.com https_port=8443
frt02.example.com http_proxy=proxy.example.com

[frontends:vars]
ntp_server=ntp.frt.example.com
proxy=proxy.frt.example.com

[apps]
app01.example.com
app02.example.com

[webapp:children]
frontends
apps

[webapp:vars]
proxy_server=proxy.webapp.example.com
health_check_retry=3
health_check_interal=60
```

让我们从一个非常简单的剧本开始，向您展示如何在单个任务中循环一组数据。虽然这是一个相当做作的例子，但它旨在简单地向您展示 Ansible 中循环工作的基本原理。我们将从清单中定义一个在单个主机上运行`command`模块的单个任务，并使用`command`模块在远程系统上依次对数字 1 到 6 进行`echo`(通过一些想象，这可以很容易地扩展到添加用户帐户或创建文件序列)。

考虑以下代码:

```
---
- name: Simple loop demo play
  hosts: frt01.example.com

  tasks:
    - name: Echo a value from the loop
      command: echo "{{ item }}"
      loop:
        - 1
        - 2
        - 3
        - 4
        - 5
        - 6
```

`loop:`语句定义了循环的开始，循环中的项目被定义为 YAML 列表。此外，请注意更高的缩进级别，它告诉解析器它们是循环的一部分。在处理循环数据时，我们使用了一个名为`item`的特殊变量，它包含了来自循环迭代的当前值。因此，如果我们运行这个剧本，我们应该会看到类似如下的输出:

```
$ ansible-playbook -i hosts loop1.yml

PLAY [Simple loop demo play] ***************************************************

TASK [Gathering Facts] *********************************************************
ok: [frt01.example.com]

TASK [Echo a value from the loop] **********************************************
changed: [frt01.example.com] => (item=1)
changed: [frt01.example.com] => (item=2)
changed: [frt01.example.com] => (item=3)
changed: [frt01.example.com] => (item=4)
changed: [frt01.example.com] => (item=5)
changed: [frt01.example.com] => (item=6)

PLAY RECAP *********************************************************************
frt01.example.com : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

您可以将我们在前一节中讨论的条件逻辑与循环结合起来，使循环只对其数据的一个子集进行操作。例如，考虑剧本的以下迭代:

```

---
- name: Simple loop demo play
  hosts: frt01.example.com

  tasks:
    - name: Echo a value from the loop
      command: echo "{{ item }}"
      loop:
        - 1
        - 2
        - 3
        - 4
        - 5
        - 6
      when: item|int > 3
```

现在，当我们运行这个时，我们看到任务被跳过，直到我们在循环内容中达到 4 或更高的整数值:

```
$ ansible-playbook -i hosts loop2.yml

PLAY [Simple loop demo play] ***************************************************

TASK [Gathering Facts] *********************************************************
ok: [frt01.example.com]

TASK [Echo a value from the loop] **********************************************
skipping: [frt01.example.com] => (item=1)
skipping: [frt01.example.com] => (item=2)
skipping: [frt01.example.com] => (item=3)
changed: [frt01.example.com] => (item=4)
changed: [frt01.example.com] => (item=5)
changed: [frt01.example.com] => (item=6)

PLAY RECAP *********************************************************************
frt01.example.com : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

当然，您可以按照我们之前讨论的方式，将这一点与基于 Ansible 事实和其他变量的条件逻辑相结合。就像我们之前使用`register`关键字捕获模块执行的结果一样，我们可以通过循环来实现。唯一的区别是，结果现在将存储在字典中，循环的每次迭代都有一个字典条目，而不是只有一组结果。

因此，让我们看看如果我们进一步改进剧本会发生什么，如下所示:

```
---
- name: Simple loop demo play
  hosts: frt01.example.com

  tasks:
    - name: Echo a value from the loop
      command: echo "{{ item }}"
      loop:
        - 1
        - 2
        - 3
        - 4
        - 5
        - 6
      when: item|int > 3
      register: loopresult

    - name: Print the results from the loop
      debug:
        var: loopresult
```

现在，当我们运行剧本时，您将看到页面输出，其中包含带有`loopresult`内容的字典。出于篇幅的考虑，以下输出被截断，但展示了运行本行动手册应该得到的结果:

```
$ ansible-playbook -i hosts loop3.yml

PLAY [Simple loop demo play] ***************************************************

TASK [Gathering Facts] *********************************************************
ok: [frt01.example.com]

TASK [Echo a value from the loop] **********************************************
skipping: [frt01.example.com] => (item=1)
skipping: [frt01.example.com] => (item=2)
skipping: [frt01.example.com] => (item=3)
changed: [frt01.example.com] => (item=4)
changed: [frt01.example.com] => (item=5)
changed: [frt01.example.com] => (item=6)

TASK [Print the results from the loop] *****************************************
ok: [frt01.example.com] => {
 "loopresult": {
 "changed": true,
 "msg": "All items completed",
 "results": [
 {
 "ansible_loop_var": "item",
 "changed": false,
 "item": 1,
 "skip_reason": "Conditional result was False",
 "skipped": true
 },
 {
 "ansible_loop_var": "item",
 "changed": false,
 "item": 2,
 "skip_reason": "Conditional result was False",
 "skipped": true
 },
```

如您所见，输出的结果部分是一个字典，我们可以清楚地看到列表中的前两个项目是`skipped`，因为我们的`when`子句(`Conditional`)的结果是`false`。

因此，到目前为止，我们可以看到循环很容易定义和使用——但是你可能会问，*你能创建嵌套循环吗？*这个问题的答案是*是的*，但是有一个问题——名为`item`的特殊变量会发生冲突，因为内部和外部循环将使用相同的变量名。这意味着嵌套循环运行的结果充其量是出乎意料的。

幸运的是，有一个名为`loop_control`的`loop`参数，允许您将包含数据的特殊变量的名称从当前的`loop`迭代从`item`更改为您选择的东西。让我们创建一个嵌套循环来看看这是如何工作的。

首先，我们将以通常的方式创建一个剧本，其中一个任务循环运行。为了生成嵌套循环，我们将使用`include_tasks`目录来动态地包含来自另一个 YAML 文件的单个任务，该文件也将包含一个循环。由于我们打算在嵌套循环中使用这个剧本，我们将使用`loop_var`指令将特殊循环内容变量的名称从`item`更改为`second_item`:

```
---
- name: Play to demonstrate nested loops
  hosts: localhost

  tasks:
    - name: Outer loop
      include_tasks: loopsubtask.yml
      loop:
        - a
        - b
        - c
      loop_control:
        loop_var: second_item
```

然后，我们将创建第二个名为`loopsubtask.yml`的文件，它包含内部循环，包含在前面的剧本中。因为我们已经在外部循环中更改了循环项变量名，所以我们不需要在这里再次更改它。请注意，该文件的结构非常像角色中的任务文件，它不是完整的行动手册，而是简单的任务列表:

```
---
- name: Inner loop
  debug:
    msg: "second item={{ second_item }} first item={{ item }}"
  loop:
    - 100
    - 200
    - 300
```

现在，您应该能够运行剧本了，您将看到 Ansible 首先在外循环上迭代，然后在外循环定义的数据上处理内循环。由于循环变量名不会冲突，所有的工作与我们预期的完全一样:

```
$ ansible-playbook loopmain.yml
[WARNING]: provided hosts list is empty, only localhost is available. Note that
the implicit localhost does not match 'all'

PLAY [Play to demonstrate nested loops] ****************************************

TASK [Gathering Facts] *********************************************************
ok: [localhost]

TASK [Outer loop] **************************************************************
included: /root/Practical-Ansible-2/Chapter 4/loopsubtask.yml for localhost
included: /root/Practical-Ansible-2/Chapter 4/loopsubtask.yml for localhost
included: /root/Practical-Ansible-2/Chapter 4/loopsubtask.yml for localhost

TASK [Inner loop] **************************************************************
ok: [localhost] => (item=100) => {
 "msg": "second item=a first item=100"
}
ok: [localhost] => (item=200) => {
 "msg": "second item=a first item=200"
}
ok: [localhost] => (item=300) => {
 "msg": "second item=a first item=300"
}

TASK [Inner loop] **************************************************************
ok: [localhost] => (item=100) => {
 "msg": "second item=b first item=100"
}
ok: [localhost] => (item=200) => {
 "msg": "second item=b first item=200"
}
ok: [localhost] => (item=300) => {
 "msg": "second item=b first item=300"
}

TASK [Inner loop] **************************************************************
ok: [localhost] => (item=100) => {
 "msg": "second item=c first item=100"
}
ok: [localhost] => (item=200) => {
 "msg": "second item=c first item=200"
}
ok: [localhost] => (item=300) => {
 "msg": "second item=c first item=300"
}

PLAY RECAP *********************************************************************
localhost : ok=7 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
```

循环使用起来很简单，但是非常强大，因为它们允许您轻松地使用一个任务来迭代一大组数据。在下一节中，我们将研究用于控制剧本流的 Ansible 语言的另一种构造——块。

# 使用块对任务进行分组

Ansible 中的块允许您将一组任务逻辑分组在一起，主要用于两个目的之一。一种可能是将条件逻辑应用于整个任务集；在本例中，您可以对每个任务应用一个相同的 when 子句，但是这既麻烦又低效——最好将所有任务放在一个块中，并将条件逻辑应用到块本身。这样，逻辑只需要声明一次。当涉及到错误处理时，特别是当涉及到从错误状态恢复时，块也是有价值的。我们将在本章中通过简单的实例来探讨这两个问题，以帮助您了解 Ansible 中的块。

和以往一样，让我们确保有一个可供使用的清单:

```
[frontends]
frt01.example.com https_port=8443
frt02.example.com http_proxy=proxy.example.com

[frontends:vars]
ntp_server=ntp.frt.example.com
proxy=proxy.frt.example.com

[apps]
app01.example.com
app02.example.com

[webapp:children]
frontends
apps

[webapp:vars]
proxy_server=proxy.webapp.example.com
health_check_retry=3
health_check_interal=60
```

现在，让我们直接来看一个如何使用块将条件逻辑应用于一组任务的例子。在高层次上，假设我们想要在所有的 Fedora Linux 主机上执行以下操作:

*   为 Apache 网络服务器安装软件包。
*   安装模板化配置。
*   启动适当的服务。

我们可以通过三个单独的任务来实现这一点，所有的任务都有一个相关的`when`子句，但是块为我们提供了一个更好的方法。以下示例行动手册显示了一个块中包含的三个讨论的任务(请注意表示它们在块中存在所需的额外缩进级别):

```
---
- name: Conditional block play
  hosts: all
  become: true

  tasks:
  - name: Install and configure Apache
    block:
      - name: Install the Apache package
        dnf:
          name: httpd
          state: installed
      - name: Install the templated configuration to a dummy location
        template:
          src: templates/src.j2
          dest: /tmp/my.conf
      - name: Start the httpd service
        service:
          name: httpd
          state: started
          enabled: True
    when: ansible_facts['distribution'] == 'Fedora'
```

当您运行本行动手册时，您应该会发现与 Apache 相关的任务只在您库存中可能有的任何 Fedora 主机上运行；您应该看到，这三个任务要么都在运行，要么都被跳过——根据清单的构成和内容，它可能如下所示:

```
$ ansible-playbook -i hosts blocks.yml

PLAY [Conditional block play] **************************************************

TASK [Gathering Facts] *********************************************************
ok: [app02.example.com]
ok: [frt01.example.com]
ok: [app01.example.com]
ok: [frt02.example.com]

TASK [Install the Apache package] **********************************************
changed: [frt01.example.com]
changed: [frt02.example.com]
skipping: [app01.example.com]
skipping: [app02.example.com]

TASK [Install the templated configuration to a dummy location] *****************
changed: [frt01.example.com]
changed: [frt02.example.com]
skipping: [app01.example.com]
skipping: [app02.example.com]

TASK [Start the httpd service] *************************************************
changed: [frt01.example.com]
changed: [frt02.example.com]
skipping: [app01.example.com]
skipping: [app02.example.com]

PLAY RECAP *********************************************************************
app01.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=3 rescued=0 ignored=0
app02.example.com : ok=1 changed=0 unreachable=0 failed=0 skipped=3 rescued=0 ignored=0
frt01.example.com : ok=4 changed=3 unreachable=0 failed=0 skipped=3 rescued=0 ignored=0
frt02.example.com : ok=4 changed=3 unreachable=0 failed=0 skipped=3 rescued=0 ignored=0
```

这是非常简单的构造，但是就它对你控制大型任务流的能力的影响而言，它非常强大。

这一次，让我们构建一个不同的示例来演示如何利用块来帮助 Ansible 优雅地处理错误情况。到目前为止，您应该已经体验到，如果您的行动手册遇到任何错误，它们很可能会在失败时停止执行。这在某些情况下远非理想，您可能希望在此事件中执行某种恢复操作，而不是简单地停止行动。

让我们创建一个新的行动手册，这次包含以下内容:

```
---
- name: Play to demonstrate block error handling
  hosts: frontends

  tasks:
    - name: block to handle errors
      block:
        - name: Perform a successful task
          debug:
            msg: 'Normally executing....'
        - name: Deliberately create an error
          command: /bin/whatever
        - name: This task should not run if the previous one results in an error
          debug:
            msg: 'Never print this message if the above command fails!!!!'
      rescue:
        - name: Catch the error (and perform recovery actions)
          debug:
            msg: 'Caught the error'
        - name: Deliberately create another error
          command: /bin/whatever
        - name: This task should not run if the previous one results in an error
          debug:
            msg: 'Do not print this message if the above command fails!!!!'
      always:
        - name: This task always runs!
          debug:
            msg: "Tasks in this part of the play will be ALWAYS executed!!!!"
```

请注意，在前面的游戏中，我们现在有了`block`的附加部分，以及`block`本身的任务，我们有了两个新的部分，分别标记为`rescue`和`always`。执行流程如下:

1.  `block`部分的所有任务都按照列出的顺序正常执行。
2.  如果`block`中的任务导致错误，则`block`中不再运行其他任务:
    *   `rescue`部分中的任务开始按照它们列出的顺序运行。
    *   如果`block`任务没有导致错误，则`rescue`部分中的任务不会运行。
3.  如果在`rescue`部分运行的任务导致错误，则不再执行`rescue`任务，执行转移到`always`部分。
4.  不管`block`或`rescue`部分是否有任何错误，`always`部分中的任务始终运行。它们甚至在没有遇到错误时运行。

考虑到这一执行流程，在执行本行动手册时，您应该会看到类似于以下内容的输出，请注意，我们特意创建了两个错误条件来演示该流程:

```
$ ansible-playbook -i hosts blocks-error.yml

PLAY [Play to demonstrate block error handling] ********************************

TASK [Gathering Facts] *********************************************************
ok: [frt02.example.com]
ok: [frt01.example.com]

TASK [Perform a successful task] ***********************************************
ok: [frt01.example.com] => {
    "msg": "Normally executing...."
}
ok: [frt02.example.com] => {
    "msg": "Normally executing...."
}

TASK [Deliberately create an error] ********************************************
fatal: [frt01.example.com]: FAILED! => {"changed": false, "cmd": "/bin/whatever", "msg": "[Errno 2] No such file or directory", "rc": 2}
fatal: [frt02.example.com]: FAILED! => {"changed": false, "cmd": "/bin/whatever", "msg": "[Errno 2] No such file or directory", "rc": 2}

TASK [Catch the error (and perform recovery actions)] **************************
ok: [frt01.example.com] => {
    "msg": "Caught the error"
}
ok: [frt02.example.com] => {
    "msg": "Caught the error"
}

TASK [Deliberately create another error] ***************************************
fatal: [frt01.example.com]: FAILED! => {"changed": false, "cmd": "/bin/whatever", "msg": "[Errno 2] No such file or directory", "rc": 2}
fatal: [frt02.example.com]: FAILED! => {"changed": false, "cmd": "/bin/whatever", "msg": "[Errno 2] No such file or directory", "rc": 2}

TASK [This task always runs!] **************************************************
ok: [frt01.example.com] => {
    "msg": "Tasks in this part of the play will be ALWAYS executed!!!!"
}
ok: [frt02.example.com] => {
    "msg": "Tasks in this part of the play will be ALWAYS executed!!!!"
}

PLAY RECAP *********************************************************************
frt01.example.com : ok=4 changed=0 unreachable=0 failed=1 skipped=0 rescued=1 ignored=0
frt02.example.com : ok=4 changed=0 unreachable=0 failed=1 skipped=0 rescued=1 ignored=0
```

Ansible 有两个特殊变量，其中包含您可能会发现对救援块执行恢复操作有用的信息:

*   `ansible_failed_task`:这是一本字典，里面包含了失败的`block`的任务细节，导致我们进入`rescue`部分。您可以通过使用`debug`显示其内容来探索这一点，但是例如，失败任务的名称可以从`ansible_failed_task.name` *获得。*
*   `ansible_failed_result`:这是失败任务的结果，其行为就像你给失败任务添加了`register`关键字一样。这样你就不用为区块中的每一个任务添加`register`以防失败。

随着您的行动手册变得越来越复杂，错误处理变得越来越重要(或者实际上条件逻辑变得更加重要)，blocks 将成为您编写优秀、健壮的行动手册的重要部分。让我们在下一部分继续探索执行策略，以进一步控制您的行动手册运行。

# 通过策略配置游戏执行

随着您的行动手册变得越来越复杂，拥有可靠的方法来调试可能出现的任何问题变得越来越重要。例如，有没有一种方法可以在执行过程中检查给定变量(或多个变量)的内容，而不需要在整个行动手册中插入`debug`语句？同样，到目前为止，我们已经看到，在继续下一个任务之前，Ansible 将确保特定任务在它所应用的所有库存主机上运行到完成，是否有办法改变这一点？

当您开始使用 Ansible 时，您默认看到的执行策略(我们在迄今为止执行的每本剧本中都看到了这一点，尽管我们没有提到它的名称)被称为`linear`。这正是它所描述的—在下一个任务开始之前，每个任务在所有适用的主机上依次执行。然而，还有一种不太常用的策略叫做`free`，它允许所有任务在每台主机上以最快的速度完成，而无需等待其他主机。

然而，当您开始使用 Ansible 时，最有用的策略将是`debug`策略，这使得 Ansible 能够在剧本中出现错误时直接将您放入其集成调试环境中。让我们通过创建一个故意出错的剧本来演示这一点。请注意游戏定义中的`strategy: debug`和`debugger: on_failed`语句:

```
---
- name: Play to demonstrate the debug strategy
  hosts: frt01.example.com
  strategy: debug
  debugger: on_failed
  gather_facts: no
  vars:
    username: daniel

  tasks:
    - name: Generate an error by referencing an undefined variable
      ping: data={{ mobile }}
```

现在，如果您执行这个剧本，您应该会看到它开始运行，但是当它遇到它包含的故意错误时，会将您放入集成调试器。输出的开始应该类似于以下内容:

```
$ ansible-playbook -i hosts debug.yml

PLAY [Play to demonstrate the debug strategy] **********************************

TASK [Generate an error by referencing an undefined variable] ******************
fatal: [frt01.example.com]: FAILED! => {"msg": "The task includes an option with an undefined variable. The error was: 'mobile' is undefined\n\nThe error appears to be in '/root/Practical-Ansible-2/Chapter 4/debug.yml': line 11, column 7, but may\nbe elsewhere in the file depending on the exact syntax problem.\n\nThe offending line appears to be:\n\n tasks:\n - name: Generate an error by referencing an undefined variable\n ^ here\n"}
[frt01.example.com] TASK: Generate an error by referencing an undefined variable (debug)>

[frt02.prod.com] TASK: make an error with refering incorrect variable (debug)> p task_vars
{'ansible_check_mode': False,
 'ansible_current_hosts': [u'frt02.prod.com'],
 'ansible_diff_mode': False,
 'ansible_facts': {},
 'ansible_failed_hosts': [],
 'ansible_forks': 5,
...
[frt02.prod.com] TASK: make an error with refering incorrect variable (debug)> quit
User interrupted execution
$ 
```

请注意，剧本开始执行，但在第一个任务中失败，并出现错误，因为变量未定义。然而，它不是退出回到外壳，而是进入一个交互式调试器。关于调试器使用的详尽指南超出了本书的范围，但如果您有兴趣学习，可以在此处获得更多详细信息:[https://docs . ansi ble . com/ansi ble/latest/user _ guide/playbooks _ debugger . html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.html)。

然而，为了带您浏览一个非常简单、实用的调试示例，请在提示符下输入`p task`命令——这将导致 Ansible 调试器打印失败任务的名称；如果您正在看大型剧本，这非常有用:

```
[frt01.example.com] TASK: Generate an error by referencing an undefined variable (debug)> p task
TASK: Generate an error by referencing an undefined variable
```

现在我们知道了这个游戏失败的地方，所以让我们通过发出`p task.args`命令来深入挖掘一下，它将向我们显示任务中传递给模块的参数:

```
[frt01.example.com] TASK: Generate an error by referencing an undefined variable (debug)> p task.args
{u'data': u'{{ mobile }}'}
```

因此，我们可以看到我们的模块被传递了名为`data`的参数，参数值是一个名为`mobile`的变量(由大括号对表示)。因此，合乎逻辑的做法可能是查看任务可用的变量，看看该变量是否存在，如果存在，该值是否合理(使用`p task_vars`命令执行此操作):

```
[frt01.example.com] TASK: Generate an error by referencing an undefined variable (debug)> p task_vars
{'ansible_check_mode': False,
 'ansible_current_hosts': [u'frt01.example.com'],
 'ansible_dependent_role_names': [],
 'ansible_diff_mode': False,
 'ansible_facts': {},
 'ansible_failed_hosts': [],
 'ansible_forks': 5,
```

前面的输出被截断，您将发现大量与任务相关的变量——这是因为任何收集的事实和内部Ansible变量都可以用于任务。但是，如果你滚动列表，你将能够确认没有名为`mobile`的变量。

因此，这应该是足够的信息来修正你的剧本。进入`q`退出调试器:

```
[frt01.example.com] TASK: Generate an error by referencing an undefined variable (debug)> q
User interrupted execution
$
```

Ansible 调试器是一个非常强大的工具，您应该学会有效地使用它，尤其是当您的剧本变得越来越复杂的时候。我们对行动手册设计的各个方面的实际观察到此结束——在下一节中，我们将了解如何将 Git 源代码管理集成到行动手册中。

# 使用可伸缩拉杆

`ansible-pull`命令是 Ansible 的一个特殊功能，它允许您一次从 Git 存储库中(例如，GitHub)拉出一个剧本，然后执行它，从而节省了通常的步骤，例如克隆(或更新)存储库的工作副本，然后执行剧本。`ansible-pull`的伟大之处在于，它允许您集中存储和版本控制您的剧本，然后用一个命令执行它们，因此能够使用`cron`调度器执行它们，甚至不需要在给定的盒子上安装 Ansible 剧本。

但是，需要注意的一点是，虽然`ansible`和`ansible-playbook`命令都可以操作整个清单，并针对一个或多个远程主机运行行动手册，但是`ansible-pull`命令仅用于运行它从本地主机上的源代码管理系统获得的行动手册。因此，如果您想在整个基础设施中使用`ansible-pull`，您必须将其安装到每台需要它的主机上。

尽管如此，让我们看看这是如何工作的。我们将简单地手工运行该命令来探索它的应用，但实际上，您几乎肯定会将它安装到您的`crontab`中，以便它定期运行，在版本控制系统中获取您对剧本所做的任何更改。

由于`ansible-pull`仅用于在本地系统上运行剧本，因此清单文件有些多余，相反，我们将使用一个很少使用的清单规范，您可以在命令行上将清单主机目录指定为逗号分隔的列表。如果您只有一台主机，只需在名称后面加上逗号。

让我们使用一个来自 GitHub 的简单剧本，它根据可变内容设置当天的消息。为此，我们将运行以下命令(稍后我们将详细介绍):

```
$ ansible-pull -d /var/ansible-set-motd -i ${HOSTNAME}, -U https://github.com/jamesfreeman959/ansible-set-motd.git site.yml -e "ag_motd_content='MOTD generated by ansible-pull'" >> /tmp/ansible-pull.log 2>&1
```

该命令分解如下:

*   `-d /var/ansible-set-motd`:这将设置包含从 GitHub 签出代码的工作目录。
*   `-i ${HOSTNAME},`:这仅在当前主机上运行，由相应外壳变量的主机名指定。
*   `-U https://github.com/jamesfreeman959/ansible-set-motd.git`:我们用这个网址获取行动手册。
*   `site.yml`:这是要运行的剧本名称。
*   `-e "ag_motd_content='MOTD generated by ansible-pull'"`:这将设置适当的 Ansible 变量来生成 MOTD 内容。
*   `>> /tmp/ansible-pull.log 2>&1`:这将命令的输出重定向到一个日志文件，以防我们以后需要分析它——如果在`cron job`中运行命令，输出永远不会打印到用户终端，这将特别有用。

运行此命令时，您应该会看到类似以下内容的一些输出(请注意，日志重定向已被删除，以便于查看输出):

```
$ ansible-pull -d /var/ansible-set-motd -i ${HOSTNAME}, -U https://github.com/jamesfreeman959/ansible-set-motd.git site.yml -e "ag_motd_content='MOTD generated by ansible-pull'"
Starting Ansible Pull at 2020-04-14 17:26:21
/usr/bin/ansible-pull -d /var/ansible-set-motd -i cookbook, -U https://github.com/jamesfreeman959/ansible-set-motd.git site.yml -e ag_motd_content='MOTD generated by ansible-pull'
cookbook |[WARNING]: SUCCESS = Your git > {
    "aversion isfter": "7d too old t3a191ecb2do fully suebe7f84f4fpport the a5817b0f1bdepth argu49c4cd54",ment.
Fall
    "ansing back tible_factso full che": {
     ckouts.
   "discovered_interpreter_python": "/usr/bin/python"
    },
    "before": "7d3a191ecb2debe7f84f4fa5817b0f1b49c4cd54",
    "changed": false,
    "remote_url_changed": false
}

PLAY [Update the MOTD on hosts] ************************************************

TASK [Gathering Facts] *********************************************************
ok: [cookbook]

TASK [ansible.motd : Add 99-footer file] ***************************************
skipping: [cookbook]

TASK [ansible.motd : Delete 99-footer file] ************************************
ok: [cookbook]

TASK [ansible.motd : Delete /etc/motd file] ************************************
skipping: [cookbook]

TASK [ansible.motd : Check motd tail supported] ********************************
fatal: [cookbook]: FAILED! => {"changed": true, "cmd": "test -f /etc/update-motd.d/99-footer", "delta": "0:00:00.004444", "end": "2020-04-14 17:26:25.489793", "msg": "non-zero return code", "rc": 1, "start": "2020-04-14 17:26:25.485349", "stderr": "", "stderr_lines": [], "stdout": "", "stdout_lines": []}
...ignoring

TASK [ansible.motd : Add motd tail] ********************************************
skipping: [cookbook]

TASK [ansible.motd : Add motd] *************************************************
changed: [cookbook]

PLAY RECAP *********************************************************************
cookbook : ok=4 changed=2 unreachable=0 failed=0 skipped=3 rescued=0 ignored=1
```

该命令可能是您的整体 Ansible 解决方案中非常强大的一部分，尤其是因为它意味着您不必过于担心集中运行您的所有行动手册，或者确保每次运行时它们都是最新的。在大型基础设施中，在`cron`中安排这种情况的能力尤其强大，理想情况下，自动化意味着事情应该自己处理。

我们对行动手册以及如何编写自己的代码的实际了解到此结束，通过对 Ansible 模块的一点研究，您现在应该有足够的能力轻松编写自己的健壮行动手册了。

# 摘要

行动手册是 Ansible 自动化的命脉，它提供了一个健壮的框架，在这个框架内定义任务的逻辑集合，并干净、健壮地处理错误情况。将角色添加到这个组合中不仅在组织代码方面有价值，而且在随着自动化需求的增长支持代码重用方面也有价值。Ansible 行动手册为您的技术需求提供了真正完整的自动化解决方案。

在本章中，您学习了行动手册框架以及如何开始构建自己的行动手册。然后，您学习了如何将代码组织成角色，并设计代码以有效地支持重用。然后，我们探索了一些更高级的剧本写作主题，例如使用条件逻辑、块和循环。最后，我们研究了行动手册的执行策略，特别是为了能够有效地调试您的行动手册，最后我们研究了如何直接从 GitHub 在本地机器上运行 Ansible 行动手册。

在下一章中，我们将学习如何使用和创建我们自己的模块，为您提供扩展 Ansible 功能所需的技能，以适应您自己的定制环境，并为社区做出贡献。

# 问题

1.  如何通过临时命令重启`frontends`主机组中的 Apache web 服务器？

A) `ansible frontends -i hosts -a "name=httpd state=restarted"`

B) `ansible frontends -i hosts -b service -a "name=httpd state=restarted"`

C) `ansible frontends -i hosts -b -m service -a "name=httpd state=restarted"`

D) `ansible frontends -i hosts -b -m server -a "name=httpd state=restarted"`

E) `ansible frontends -i hosts -m restart -a "name=httpd"`

2.  块是否允许您逻辑地创建一组任务，或者执行错误处理？

真的吗

假的

3.  默认策略是通过行动手册中的相关模块制定的。

真的吗

假的

# 进一步阅读

`ansible-galaxy`文件可以在这里找到:[https://galaxy.ansible.com/docs/](https://galaxy.ansible.com/docs/)。