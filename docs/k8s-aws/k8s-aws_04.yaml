- en: Managing Change in Your Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理应用程序中的变更
- en: In [Chapter 2](87aab5e7-ff37-4a46-831b-8ff62708b7d8.xhtml), *Start Your Engines*,
    we took a first look at running an application on Kubernetes using deployments.
    In this chapter, we are going to go into depth with tools that Kubernetes provides
    to manage the pods that we run on your cluster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](87aab5e7-ff37-4a46-831b-8ff62708b7d8.xhtml) *启动引擎*中，我们首次尝试使用部署在Kubernetes上运行应用程序。在本章中，我们将深入了解Kubernetes提供的用于管理在集群上运行的Pod的工具。
- en: We will learn how to ensure that batch tasks are successfully completed by using
    the `Job` resource
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将学习如何通过使用`Job`资源来确保批处理任务成功完成
- en: We will learn how to run jobs at scheduled intervals with the `CronJob` resource
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将学习如何使用`CronJob`资源在预定时间间隔运行作业
- en: Finally, we will learn how to use deployments to keep long-running applications
    running indefinitely, and to update them or their configuration when changes need
    to be made
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将学习如何使用部署来使长时间运行的应用程序无限期运行，并在需要进行更改时更新它们或其配置
- en: We will look at how we can launch pods in different ways with Kubernetes, depending
    on the workloads we are running.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看如何可以使用Kubernetes以不同的方式启动Pod，这取决于我们正在运行的工作负载。
- en: You will learn a lot more about how to use the deployment resource to control
    the way Kubernetes rolls out changes to long-running applications. You will discover
    the ways you can use Kubernetes to perform common deploy patterns, such as blue-green
    and canary deployments.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学到更多关于如何使用部署资源来控制Kubernetes如何推出对长时间运行的应用程序的更改。您将了解可以使用Kubernetes执行常见部署模式的方法，例如蓝绿部署和金丝雀部署。
- en: 'By design, pods are not intended to be durable in any way. As we have discussed
    previously, there is a whole raft of conditions that can cause the life of a pod
    to be terminated. They include:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 按设计，Pod不打算以任何方式持久。正如我们之前讨论过的，有一系列条件可能导致Pod的生命周期终止。它们包括：
- en: '**The failure of an underlying node**: Perhaps caused by some unexpected event,
    such as a hardware failure. Or perhaps by design; for example in a cluster utilizing
    spot priced instances nodes can be terminated without warning if demand for instances
    increases.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**底层节点的故障**：可能是由于一些意外事件，例如硬件故障。或者可能是出于设计考虑；例如，在使用按需定价实例的集群中，如果实例需求增加，节点可以在没有警告的情况下被终止。'
- en: '**Pod evictions initiated by the scheduler**: The scheduler can initiate pod
    evictions when it needs to in order to optimize the usage of resources on the
    cluster. This could be because some processes have a higher priority than others,
    or just to optimize bin packing on the cluster.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度程序启动的Pod驱逐**：调度程序在需要时可以启动Pod驱逐，以优化集群上资源的使用。这可能是因为某些进程的优先级比其他进程更高，或者只是为了优化集群上的装箱。'
- en: Pods manually removed by the user.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户手动删除的Pod。
- en: Pods removed due to planned maintenance; for example, by using the `kubectl
    drain` command.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于计划维护而删除的Pod；例如，使用`kubectl drain`命令。
- en: The node is no longer visible to the cluster due to a network partition.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于网络分区，节点不再对集群可见。
- en: Pods removed from the node in preparation of a scaling down action.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了准备缩减操作而从节点中删除的Pod。
- en: So, if the design of Kubernetes expects pods to ephemeral, how can we deploy
    reliable applications? Surely, we need some way to run our programs without fail?
    Thankfully, this is not exactly the case. The important part of this design is
    that it accurately models the wide range of issues that can occur in the system
    due to the underlying hardware and software, and as a result of management processes.
    Rather than trying to make the primitive building block (the pod) resilient to
    failures itself, Kubernetes provides a number of controllers that we, as users,
    can interact with directly to build resilient services. These controllers handle
    creating replacements for pods that have been lost for any number of reasons.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果Kubernetes的设计期望pod是短暂的，我们如何部署可靠的应用程序呢？当然，我们需要一种无法失败地运行我们的程序的方式。幸运的是，情况并非完全如此。这种设计的重要部分是它准确地模拟了由于底层硬件和软件以及管理过程而可能发生的各种问题。Kubernetes并不试图使基本构建块（pod）本身对故障具有弹性，而是提供了许多控制器，我们作为用户可以直接与之交互来构建具有弹性的服务。这些控制器负责为因任何原因丢失的pod创建替代品。
- en: 'These controllers fall into four groups, and our choice really depends on the
    type of workload we want to run:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制器分为四组，我们的选择取决于我们想要运行的工作负载的类型：
- en: For processes that we expect to end, such as batch jobs or other finite processes,
    Kubernetes provides the job abstraction. Jobs ensure that a pod runs to completion
    at least once.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我们期望结束的进程，比如批处理作业或其他有限的进程，Kubernetes提供了作业抽象。作业确保一个pod至少运行一次完成。
- en: For pods that we expect to be long-running, such as a web server or a background
    processing worker, Kubernetes provides deployments and the lower level ReplicationController
    or ReplicaSet.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我们期望长时间运行的pod，比如web服务器或后台处理工作者，Kubernetes提供了部署和较低级别的ReplicationController或ReplicaSet。
- en: For pods that we want to run on all machines (or a subset of them), Kubernetes
    provides DaemonSet. DaemonSet are typically used to provide machine-specific services
    that form part of your platform, such as log management or monitoring agents,
    and commonly to deploy per node components of an overlay network.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我们希望在所有机器（或其中一部分）上运行的pod，Kubernetes提供了DaemonSet。DaemonSet通常用于提供作为平台一部分的特定于机器的服务，比如日志管理或监控代理，通常用于部署覆盖网络的每个节点组件。
- en: For groups of pods where each pod requires a stable identity or to access persistent
    storage, Kubernetes provides `StatefulSets`. (We will cover `StatefulSets` in
    [Chapter 9](c2a3f846-f6cc-4fd1-af93-d325afeeffb6.xhtml), *Storing State*.)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个pod都需要稳定标识或访问持久存储的pod组，Kubernetes提供了`StatefulSets`。（我们将在[第9章](c2a3f846-f6cc-4fd1-af93-d325afeeffb6.xhtml)中介绍`StatefulSets`，*存储状态*。）
- en: If you think back to what we learned about the architecture of Kubernetes in
    [Chapter 1](19821a2b-bb32-408d-9f21-256dce5d644e.xhtml), *Google's Infrastructure
    for the Rest of Us*, it is important to remember that the controller manager (the
    Kubernetes micro service that runs all these controllers) is a separate and distinct
    process from the scheduler. The core lower-level parts of Kubernetes, such as
    the scheduler and the kubelet, only know about pods, whereas the higher-level
    controllers don't need to understand any of the details of actually scheduling
    and running pods on nodes. They just make a request to the API server for a pod
    to be created and the lower-level machinery ensures that they are scheduled and
    run correctly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果回想一下我们在[第1章](19821a2b-bb32-408d-9f21-256dce5d644e.xhtml)中学到的关于Kubernetes架构的知识，《谷歌的基础设施服务于我们其余的人》,
    重要的是要记住控制器管理器（运行所有这些控制器的Kubernetes微服务）是一个独立的、不同的进程，与调度器分开。Kubernetes的核心低级部分，比如调度器和kubelet，只知道pod，而高级控制器不需要了解实际调度和在节点上运行pod的任何细节。它们只是向API服务器发出请求创建一个pod，而较低级的机制确保它们被正确地调度和运行。
- en: In this chapter, we are going to walk through the important features and configuration
    options that jobs, deployments, and DaemonSet provide us. By working through some
    examples, you will start to get a feel for when to use each resource to deploy
    your applications. You should take your time to understand what each controller
    is doing and why you would want to use it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将逐步介绍作业、部署和DaemonSet提供给我们的重要功能和配置选项。通过一些示例，您将开始了解何时使用每个资源来部署您的应用程序。您应该花时间了解每个控制器正在做什么，以及为什么要使用它。
- en: Deploying software to a distributed environment can be a little bit unusual
    at first, because a lot of assumptions you might have made about the way that
    your software runs when deploying it to a single machine might not work in a distributed
    system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将软件部署到分布式环境可能会有点不同寻常，因为在部署到单台机器时可能会有很多假设不适用于分布式系统。
- en: Kubernetes does a great job of making it possible to deploy most software without
    any modifications at all. I like to think that Kubernetes lets us trade a little
    simplicity for a lot of reliability.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes非常擅长让我们能够部署大多数软件而无需进行任何修改。我认为Kubernetes让我们以一点简单性换取了很多可靠性。
- en: Running pods directly
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接运行pod
- en: Kubernetes doesn't really intend for users to directly submit and launch pods
    on the cluster. As we discussed previously, pods are designed to be ephemeral,
    so are not suitable for running workloads where we want to ensure that execution
    has completed or where we want to ensure that a process remains up and running.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes并不真的打算让用户直接在集群上提交和启动pod。正如我们之前讨论的，pod被设计为短暂存在，因此不适合运行需要确保执行已完成或需要确保进程保持运行的工作负载。
- en: 'Here, we will start from first principles, launching pods, before moving on
    to use a controller to help us manage them. Bear in mind that this is a learning
    exercise; you shouldn''t submit pods in this way if you need them to run reliably:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将从头开始，启动pod，然后再使用控制器来帮助我们管理它们。请记住，这是一个学习练习；如果您需要它们可靠地运行，就不应该以这种方式提交pod：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This pod launches an infinite loop that prints `hello world` every 2 seconds.
    Start by submitting the pod to the cluster with `kubectl`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个pod启动了一个无限循环，每2秒打印一次“hello world”。首先使用`kubectl`将pod提交到集群中：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It might take a few moments for the pod be created while the container runtime
    downloads the image. While this is happening, you could check on the status of
    the pod by running `kubectl describe pod/hello-loop` or by using the dashboard.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器运行时下载镜像的过程中，可能需要一些时间来创建pod。在此期间，您可以通过运行`kubectl describe pod/hello-loop`或使用仪表板来检查pod的状态。
- en: The fact that Kubernetes makes it possible to control even the lowest-level
    abstractions, such as pods, through the API makes it easy to extend Kubernetes
    with additional functionality using or building add-on tools that can be just
    as powerful as the built-in controllers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使得即使是最低级别的抽象，比如pod，也可以通过API来控制，这使得使用或构建附加工具来扩展Kubernetes的功能变得很容易，这些工具可以和内置的控制器一样强大。
- en: Once the pod is up and running, you can follow the output with `kubectl logs
    -f hello-loop` and you should see `hello world` output every 2 seconds.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦pod启动并运行，您可以使用`kubectl logs -f hello-loop`来跟踪输出，您应该每2秒看到一个“hello world”的输出。
- en: '`kubectl logs` allows us to display logs from pods that have run on the cluster.
    If you know the name of the pod you want logs from, you can just pass the name
    as an argument. But if you are using a controller to launch a pod, you can use
    the name of a job or deployment in place of the pod name just by prefixing the
    name with the resource type.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl logs` 允许我们显示在集群上运行的pod的日志。如果您知道要从中获取日志的pod的名称，您可以将名称作为参数传递。但是，如果您使用控制器来启动pod，您可以使用作业或部署的名称来代替pod名称，只需在名称前加上资源类型。'
- en: If you have a label selector for the pod or pods you are interested in, they
    can be passed with the `-l` flag. With the `-c` flag, you can target a specific
    named container in a pod with more than one container; if the pod only has one
    container, this can be omitted.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对感兴趣的pod或pod有标签选择器，可以使用 `-l` 标志传递它们。使用 `-c` 标志，您可以针对具有多个容器的pod中的特定命名容器进行定位；如果pod只有一个容器，则可以省略此选项。
- en: Try running `kubectl`. It helps logs to discover some more of the options you
    can use to view just the logs you are interested in, including limiting them to
    a particular time period.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行 `kubectl`。它可以帮助查看一些更多的选项，以便查看您感兴趣的日志，包括将其限制在特定时间段内。
- en: Jobs
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业
- en: The simplest use case for a job is to launch a single pod and ensure that it
    successfully runs to completion.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 作业的最简单用例是启动单个pod，并确保它成功运行完成。
- en: 'In our next example, we are going to use the Ruby programming language to compute
    and print out the first 100 Fibonacci numbers:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个示例中，我们将使用Ruby编程语言来计算并打印出前100个斐波那契数：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that the contents of `spec` and `template` are very similar to the specification
    we used to launch a pod directly. When we define a pod template for use in a job,
    we need to choose a `restartPolicy` of `Never` or `OnFailure`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`spec` 和 `template` 的内容与我们直接启动pod时使用的规范非常相似。当我们为作业中的pod模板定义一个pod模板时，我们需要选择
    `restartPolicy` 为 `Never` 或 `OnFailure`。
- en: The reason for this is that the end goal of a job is to run the pod until it
    exits successfully. If the underlying pod is restarted when it exits successfully,
    the pod would continue to be restarted and the job would never complete.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为作业的最终目标是运行pod直到成功退出。如果基础pod在成功退出时重新启动，那么pod将继续重新启动，作业将永远无法完成。
- en: 'Save the definition to a file and then submit it to the cluster using `kubectl
    create`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将定义保存到文件，然后使用 `kubectl create` 将其提交到集群：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you have submitted a job to Kubernetes, you can check on its status with
    the `kubectl describe` command. It might take a little while for the Docker image
    to download and Kubernetes to launch the pod. Once the pod is running, you should
    see first `1 Running` and then `1 Succeeded` in the `Pods Statues` field:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您向Kubernetes提交了作业，您可以使用 `kubectl describe` 命令来检查其状态。可能需要一点时间来下载Docker镜像并启动pod。一旦pod运行，您应该在
    `Pods Statues` 字段中看到首先是 `1 Running`，然后是 `1 Succeeded`：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When waiting for Kubernetes to take some action, repeatedly running `kubectl`
    to find out what is happening can get tedious. I like to use the `watch` command
    in conjunction with `kubectl`. To watch Kubernetes launch this job, I could run:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在等待Kubernetes执行某些操作时，反复运行 `kubectl` 以了解发生了什么可能会变得乏味。我喜欢将 `watch` 命令与 `kubectl`
    结合使用。要观察Kubernetes启动此作业，我可以运行：
- en: '`**$ watch kubectl describe jobs/fib**`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`**$ watch kubectl describe jobs/fib**`'
- en: 'Most Linux distributions will include the watch command by default, or make
    it simple to install with a package manager. If you are on macOS, it''s very simple
    to install with Homebrew:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Linux发行版将默认包含 `watch` 命令，或者可以通过软件包管理器轻松安装。如果您使用macOS，可以通过Homebrew轻松安装：
- en: '`**$ brew install watch**`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`**$ brew install watch**`'
- en: 'We can use `kubectl logs` to view the output from our job. Notice how we don''t
    need to know the name of the underlying pod(s); we can just refer to the job by
    name:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`kubectl logs`来查看我们作业的输出。注意我们不需要知道底层pod的名称；我们只需要通过名称引用作业即可：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also look at the underlying pod that was created by this job with `kubectl
    get` by using the `job-name` label that Kubernetes adds to the pods for us:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`kubectl get`查看由该作业创建的底层pod，通过使用Kubernetes为我们添加到pod的`job-name`标签：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `--show-all` flag means that all pods are shown (even those that no longer
    have a running status).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`--show-all`标志意味着显示所有的pod（即使那些不再具有运行状态的pod）。'
- en: Notice how Kubernetes created a unique name for our pod based on the job name.
    This is important because if the first pod to have been created failed in some
    way, Kubernetes would need to launch another pod based on the same pod specification.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Kubernetes根据作业名称为我们的pod创建了一个唯一的名称。这很重要，因为如果第一个被创建的pod在某种方式上失败了，Kubernetes需要根据相同的pod规范启动另一个pod。
- en: One of the key advantages jobs have over launching a pod directly is that a
    job is able to handle not only errors caused by the underlying infrastructure
    that might cause a pod to be lost before it has completed, but also errors that
    occur at runtime.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作业相对于直接启动pod的一个关键优势是，作业能够处理不仅是由底层基础设施引起的错误，可能导致pod在完成之前丢失，还有在运行时发生的错误。
- en: 'To illustrate how this works, this job simulates a process that (mostly) fails
    with a non-zero exit status, but sometimes exits with a (successful) zero exit
    status. This Ruby program chooses a random integer from 0 to 10 and exits with
    it. So, on average, Kubernetes will have to run the pod 10 times before it exits
    successfully:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这是如何工作的，这个作业模拟了一个（大部分）以非零退出状态失败的过程，但有时以（成功的）零退出状态退出。这个Ruby程序选择一个从0到10的随机整数并以它退出。因此，平均来说，Kubernetes将不得不运行该pod
    10次，直到它成功退出：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As before, submit the job to your cluster with `kubectl`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 像以前一样，使用`kubectl`将作业提交到你的集群中：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Unless you are very lucky, when you inspect the job, you should see that Kubernetes
    has to launch a number of pods before one exited with 0 status:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你非常幸运，当你检查作业时，你应该看到Kubernetes需要启动多个pod，直到有一个以0状态退出：
- en: '![](assets/84ee4ac9-b016-4699-ba25-d666146e64aa.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/84ee4ac9-b016-4699-ba25-d666146e64aa.png)'
- en: Inspecting the pods launched by the luck job using the Kubernetes dashboard
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes仪表板检查由luck作业启动的pod
- en: In this example, the pod spec has a `restartPolicy` of `Never`. This means that
    when the pod exits with a non-zero exit status, the pod is marked as terminated
    and the job controller launches another pod. It is also possible to run jobs with
    a `restartPolicy` of `OnFailure`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，pod规范具有`restartPolicy`为`Never`。这意味着当pod以非零退出状态退出时，该pod被标记为终止，作业控制器会启动另一个pod。还可以使用`restartPolicy`为`OnFailure`运行作业。
- en: 'Try editing `luck.yaml` to make this change. Remove the first version of the
    `luck` job and submit your new version:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编辑`luck.yaml`来进行这个更改。删除`luck`作业的第一个版本并提交你的新版本：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This time, you should notice that instead of quickly launching new pods until
    one exits successfully, Kubernetes restarts one pod until it is successful. You
    will notice that this takes quite a bit longer, because when Kubernetes restarts
    a pod locally with an exponential back-off, this behavior is useful if a failure
    was caused by an underlying resource that is overloaded or unavailable. You might
    notice the pod in a status of `CrashLoopBackoff` while Kubernetes is waiting to
    restart the pod:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，你应该注意到，Kubernetes不再快速启动新的pod，直到一个成功退出，而是重启一个pod直到成功。你会注意到这需要更长的时间，因为当Kubernetes使用指数回退本地重启一个pod时，这种行为对于由于底层资源过载或不可用而导致的失败是有用的。你可能会注意到pod处于`CrashLoopBackoff`状态，而Kubernetes正在等待重新启动pod：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Allowing the job controller to recreate a new pod each time it terminates in
    error ensures that the new pod is run in a new pristine environment and causes
    the job resource to retain a record of each execution attempt. For this reason,
    it is usually best not to utilize a pod restart policy in conjunction with a job,
    unless you have to deal with pods that regularly fail or if you want to retain
    the execution environment between attempts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 允许作业控制器在每次终止时重新创建一个新的pod，以确保新的pod在新的原始环境中运行，并导致作业资源保留每次执行尝试的记录。因此，通常最好不要在作业中使用pod重启策略，除非您必须处理定期失败的pod，或者您希望在尝试之间保留执行环境。
- en: CronJob
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CronJob
- en: Now you have learned how to run one-off or batch tasks with jobs, it is simple
    to extend the concept in order to run scheduled jobs. In Kubernetes, a `CronJob`
    is a controller that creates new jobs from a template on a given schedule.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何使用作业运行一次性或批量任务，可以简单地扩展该概念以运行定时作业。在Kubernetes中，`CronJob`是一个控制器，根据给定的计划从模板创建新的作业。
- en: 'Let''s begin with a simple example. The following example will launch a job
    every minute. This job will output the current date and time and then exit:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始。以下示例将每分钟启动一个作业。该作业将输出当前日期和时间，然后退出：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Push the CronJob to Kubernetes with `kubectl`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl`将CronJob推送到Kubernetes：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After some time (less than a minute), you should see the first job created:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 过一段时间（不到一分钟），您应该会看到第一个作业被创建：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The label we added to the pod template spec allows us to use `kubectl logs`
    to see the output of all the pods created by the CronJob:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到pod模板规范的标签允许我们使用`kubectl logs`来查看CronJob创建的所有pod的输出：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Cron syntax
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cron语法
- en: The syntax of the schedule field follows the standard Cron format, which should
    be familiar if you have ever set up CronJobs on a Unix-like system. Kubernetes
    supports standard cron strings with a few common extensions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 调度字段的语法遵循标准的Cron格式，如果您曾在类Unix系统上设置过CronJobs，这应该是很熟悉的。Kubernetes支持带有一些常见扩展的标准cron字符串。
- en: 'A standard cron string consists of five fields that each represent different
    units of time. Each can be set to an expression representing a particular time,
    or a wildcard (*) that would match every time. For example, a wildcard in the
    **Months** column would match every month:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的cron字符串由五个字段组成，每个字段代表不同的时间单位。每个字段可以设置为表示特定时间的表达式，或者通配符(*)，表示匹配每个时间。例如，在**月份**列中的通配符将匹配每个月：
- en: '| Minutes | Hours | Day of Month | Month | Day of Week |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 分钟 | 小时 | 月份中的日期 | 月份 | 星期中的日期 |'
- en: Order of cron fields
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Cron字段的顺序
- en: 'The cron format is simplest to understand if it is read from left to right.
    Here are some examples:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从左到右阅读，Cron格式最容易理解。以下是一些示例：
- en: '`0 * * * *`: On the hour, every hour'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0 * * * *`：每小时整点'
- en: '`15 * * * *`: 15 minutes past every hour'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`15 * * * *`：每小时15分钟'
- en: '`0 0 * * *`: At midnight, every day'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0 0 * * *`：每天午夜'
- en: '`30 5 1 * *`: 5:30 a.m. on the first day of the month, every month'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`30 5 1 * *`：每个月的第一天上午5:30'
- en: '`30 17 * * 1`: 15:30 p.m., every Monday'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`30 17 * * 1`：每周一下午3:30'
- en: As well as the wildcard, there are a few other characters with special meaning.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通配符之外，还有一些其他具有特殊含义的字符。
- en: 'Slashes are used to indicate steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 斜杠用于指示步长：
- en: '`0/15 * * * *`: Every 15 minutes, starting at 0; for example, 12:00, 12:15,
    12:30, and so on'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0/15 * * * *`：每15分钟一次，从0开始；例如，12:00, 12:15, 12:30等'
- en: '`15/15 * * * *`: Every 15 minutes, starting at 15; for example, 12:15, 12:30,
    12:45, 13:15, 13:30, and so on'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`15/15 * * * *`：每15分钟一次，从15开始；例如，12:15, 12:30, 12:45, 13:15, 13:30等'
- en: '`0 0 0/10 * *`: Every 10 days at midnight'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0 0 0/10 * *`：每10天的午夜'
- en: 'Hyphens indicate ranges:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 连字符表示范围：
- en: '`0 9-17 * * *`: Once an hour during office hours (9 a.m. till 5 p.m.)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0 9-17 * * *`：在办公时间（上午9点至下午5点）每小时一次'
- en: '`0 0 1-15/2 * *`: Every other day for the first 15 days of every month'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0 0 1-15/2 * *`：每月前15天隔一天'
- en: 'Commas indicate lists:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号表示列表：
- en: '`0 0 * * 6,0`: Midnight on Saturday and Sunday'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0 0 * * 6,0`：星期六和星期日午夜'
- en: '`0 9,12,17 * * 1-5`: At 9:00 a.m., 12 noon, and 5:00 p.m., Monday to Friday'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0 9,12,17 * * 1-5`：上午9:00，中午12:00和下午5:00，周一至周五'
- en: 'As an aid to readability, names can be used in the month and day of the week
    fields:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便阅读，月份和星期几字段可以使用名称：
- en: '`0 0 * * SUN`: Midnight on Sunday'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0 0 * * SUN`：星期日午夜'
- en: '`0 6 * MAR-MAY *`: 6 a.m. every day in Spring'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0 6 * MAR-MAY *`：每天上午6点在春季'
- en: 'If you don''t mind when exactly a job is run, you can specify a fixed interval
    and Kubernetes will create jobs at a fixed interval:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不介意作业的具体运行时间，你可以指定一个固定的间隔，Kubernetes会按固定的间隔创建作业：
- en: '`@every 15m`: Every 15 minutes'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@every 15m`：每15分钟'
- en: '`@every 1h30m`: Every 1-and-a half hours'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@every 1h30m`：每1个半小时'
- en: '`@every 12h`: Every 12 hours'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@every 12h`：每12小时'
- en: Bear in mind that the interval doesn't take the time that the job takes to run
    into account; it just ensures that the time that each job is scheduled is separated
    by the given interval.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，间隔不考虑作业运行所需的时间；它只是确保每个作业计划的时间间隔由给定的间隔分隔。
- en: 'Finally, there are several predefined schedules that can be used as a shortcut
    in place of a cron string:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有几个预定义的计划可以用作cron字符串的快捷方式：
- en: '| **Shortcut** | **Equivalent cron** |  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **快捷方式** | **等效的cron** |  |'
- en: '| `@hourly` | `0 0 * * * *` | Every hour, on the hour |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `@hourly` | `0 0 * * * *` | 每小时整点 |'
- en: '| `@daily` | `0 0 0 * * *` | Every day at midnight |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `@daily` | `0 0 0 * * *` | 每天午夜 |'
- en: '| `@weekly` | `0 0 0 * * 0` | Every week midnight on Sunday |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `@weekly` | `0 0 0 * * 0` | 每周星期日午夜 |'
- en: '| `@monthly` | `0 0 0 1 * *` | Monthly, at midnight on the 1st |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: 每月，每月1日午夜
- en: '| `@yearly` | `0 0 0 1 1 *` | Midnight, every New Year''s Eve |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `@yearly` | `0 0 0 1 1 *` | 每年除夕午夜 |'
- en: Concurrency policy
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发策略
- en: 'Kubernetes CronJob, in contrast to the traditional CronJob, allows us to decide
    what happens when a job overruns and we reach the scheduled time while the previous
    job is still running. We can control this behavior by setting the `spec.concurrencyPolicy`
    field on the CronJob. There are three possible policies that we can choose:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的CronJob相比，Kubernetes CronJob允许我们决定当作业超时并且在上一个作业仍在运行时到达计划时间时会发生什么。我们可以通过在CronJob上设置`spec.concurrencyPolicy`字段来控制这种行为。我们可以选择三种可能的策略：
- en: By default, if the field is unset then we get the `Allow` policy. This behaves
    just like a traditional CronJob and allows multiple instances of a job to run
    at the same time. If you stick with this, you should be sure that your jobs indeed
    get completed at some point, or your cluster could end up overwhelmed with many
    jobs running at the same time.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，如果字段未设置，则我们将获得`Allow`策略。这就像传统的CronJob一样工作，并允许多个作业实例同时运行。如果你坚持这一点，你应该确保你的作业确实在某个时候完成，否则你的集群可能会因为同时运行许多作业而不堪重负。
- en: The `Forbid` policy prevents any new jobs from starting while an existing job
    is still running. This means that if a job overruns, Kubernetes will skip the
    next run. This is a good choice if having two or more instances of a job running
    could cause conflicts or use up shared resources. Your job, of course, does need
    to be able to account for missing runs in this case.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Forbid`策略防止在现有作业仍在运行时启动任何新作业。这意味着如果作业超时，Kubernetes将跳过下一次运行。如果一个作业的两个或更多实例可能会导致冲突或使用共享资源，这是一个很好的选择。当然，你的作业需要能够处理在这种情况下缺少的运行。'
- en: Finally, the `Replace` policy also prevents more than one job from running at
    once, but rather than skipping a run, it first kills the existing job and then
    launches a new job.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`Replace`策略还可以防止多个作业同时运行，而不是跳过运行，它首先终止现有作业，然后启动新作业。
- en: History limits
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 历史限制
- en: By default, when you use a CronJob, the jobs that it creates will stick around,
    so you can check on what happened to a particular run of a job for debugging or
    reporting. You might, however, find that the number of jobs in the successful
    or failed state starts to pile up quite quickly when using CronJob. This is simple
    to manage with the `spec.successfulJobsHistoryLimit` and `spec.failedJobsHistoryLimit`
    fields. Once the successful, or failed jobs reach the number specified in the
    limit, the oldest job is deleted each time a new job is created. If you set a
    limit to 0, the jobs are removed as soon as they complete.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当您使用CronJob时，它创建的作业将保留下来，因此您可以检查特定作业运行的情况以进行调试或报告。但是，当使用CronJob时，您可能会发现成功或失败状态的作业数量开始迅速增加。这可以通过`spec.successfulJobsHistoryLimit`和`spec.failedJobsHistoryLimit`字段简单管理。一旦成功或失败的作业达到限制中指定的数量，每次创建新作业时，最旧的作业都会被删除。如果将限制设置为0，则作业在完成后立即删除。
- en: Managing long running processes with deployments
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用部署管理长时间运行的进程
- en: Updating batch processes, such as jobs and CronJobs, is relatively easy. Since
    they have a limited lifetime, the simplest strategy of updating code or configurations
    is just to update the resources in question before they are used again.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 更新批处理进程，例如作业和CronJobs，相对较容易。由于它们的寿命有限，更新代码或配置的最简单策略就是在再次使用之前更新相关资源。
- en: Long-running processes are a little harder to deal with, and even harder to
    manage if you are exposing a service to the network. Kubernetes provides us with
    the deployment resource to make deploying and, more importantly, updating long-running
    processes simpler.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间运行的进程更难处理，如果您将服务暴露给网络，管理起来更加困难。Kubernetes为我们提供了部署资源，使部署和更新长时间运行的进程变得更简单。
- en: In [Chapter 2](87aab5e7-ff37-4a46-831b-8ff62708b7d8.xhtml), *Start Your Engines*,
    we took a first look at the deployment resource, both creating deployments with
    `kubectl run` and by defining a deployment object in a YAML file. In this chapter,
    we will recap the process that the deployment controller uses to roll out changes,
    and then look in to some of the more advanced options for controlling exactly
    how new versions of the pods are made available. We will cover how we can use
    deployments in conjunction with services to make changes to services provided
    on the network without downtime.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](87aab5e7-ff37-4a46-831b-8ff62708b7d8.xhtml) *启动引擎*中，我们首次了解了部署资源，既可以使用`kubectl
    run`创建部署，也可以通过在YAML文件中定义部署对象。在本章中，我们将回顾部署控制器用于推出更改的过程，然后深入研究一些更高级的选项，以精确控制新版本的Pod的可用性。我们将介绍如何使用部署与服务结合，在不中断服务的情况下对网络上提供的服务进行更改。
- en: Much like CronJob is a controller for jobs, a deployment is a controller for
    ReplicaSets. A ReplicaSet makes sure that the required number of pods for a particular
    configuration is up and running. In order to manage a change to this configuration,
    the deployment controller creates a new ReplicaSet with the new configuration,
    and then scales the old ReplicaSet down and the new one up, according to a particular
    strategy. A deployment will maintain a reference to the old ReplicaSet even after
    the deployment of the new configuration is complete. This allows the deployment
    to also orchestrate a rollback to a previous version if required.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 就像CronJob是作业的控制器一样，部署是ReplicaSets的控制器。 ReplicaSet确保特定配置所需的Pod的数量正常运行。为了管理对此配置的更改，部署控制器创建一个具有新配置的新ReplicaSet，然后根据特定策略缩减旧的ReplicaSet并扩展新的ReplicaSet。即使新配置的部署完成后，部署也会保留对旧ReplicaSet的引用。这允许部署在需要时还可以协调回滚到以前的版本。
- en: Let's begin with an example application that will allow you to quickly understand
    how the different options offered by deployments allow you to manipulate the behavior
    of your application during an update to your code or configuration.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个示例应用程序开始，这将让您快速了解部署提供的不同选项如何允许您在更新代码或配置时操纵应用程序的行为。
- en: We will be deploying an application that I created to make it simple to illustrate
    deploying new versions of software with Kubernetes. It is a simple Ruby web application
    in a Docker repository that has many version tags. Each version displays a unique
    name and color scheme when the homepage is opened in a browser.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将部署一个我创建的应用程序，以便简单地说明如何使用Kubernetes部署新版本的软件。这是一个简单的Ruby Web应用程序，位于Docker存储库中，有许多版本标签。每个版本在浏览器中打开主页时都会显示一个独特的名称和颜色方案。
- en: When we deploy a long-running process to Kubernetes, we can roll out access
    to the application in a controlled manner using labels.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将长时间运行的进程部署到Kubernetes时，我们可以使用标签以受控的方式推出对应用程序的访问。
- en: The simplest strategy to implement is to use a single deployment to roll out
    changes to a new version of your applications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实施的最简单策略是使用单个部署来推出对应用程序新版本的更改。
- en: 'To implement this, we need to start by creating a service with a label selector
    that will match every version of the application that we might deploy now, or
    in the future:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要首先创建一个带有标签选择器的服务，该选择器将匹配我们现在或将来可能部署的应用程序的每个版本：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this case, we have achieved this by matching any pod that has a label matching
    the `selector` as `app: ver`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，我们通过匹配具有与`selector`相匹配的标签`app: ver`的任何pod来实现这一点。'
- en: When running a more complicated application that has several different processes
    managed by multiple deployments, your labels and selectors will need to be more
    complicated. A common pattern is to distinguish between the component parts of
    an application with a `component` label.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行一个更复杂的应用程序，该应用程序由多个部署管理的多个不同进程组成时，您的标签和选择器将需要更复杂。一个常见的模式是使用`component`标签区分应用程序的组件部分。
- en: It makes sense to submit the service definition before you start any pods. This
    is because the scheduler will, if possible, try to spread the pods used by a particular
    service across multiple nodes for greater reliability.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始任何pod之前提交服务定义是有意义的。这是因为调度程序将尽可能地尝试将特定服务使用的pod分布在多个节点上，以提高可靠性。
- en: Submit the service definition to your cluster using `kubectl apply -f service.yaml`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl apply -f service.yaml`将服务定义提交到您的集群。
- en: 'Once the service has been submitted to the cluster, we can prepare the initial
    deployment:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务提交到集群，我们可以准备初始部署：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To access the running service, the simplest way is to use `kubectl` to open
    a proxy to the Kubernetes API running on your cluster:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问正在运行的服务，最简单的方法是使用`kubectl`打开代理到运行在您的集群上的Kubernetes API：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once you have done, you should be able to view the app using your browser at
    `http://localhost:8001/api/v1/namespaces/default/services/ver/proxy`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您应该能够使用浏览器在`http://localhost:8001/api/v1/namespaces/default/services/ver/proxy`查看应用程序。
- en: '![](assets/43c3e4f1-135f-4c5a-b3e5-a02ef4f97e85.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/43c3e4f1-135f-4c5a-b3e5-a02ef4f97e85.png)'
- en: Version 0.0.1 running in our cluster
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的集群中运行的版本0.0.1
- en: There are a number of ways that we can now make changes to our deployment.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有许多方法可以对我们的部署进行更改。
- en: kubectl patch
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kubectl patch
- en: 'To upgrade to version 0.0.2, we will execute the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要升级到版本0.0.2，我们将执行以下命令：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because containers is a list, we need to specify the merge key `name` for Kubernetes
    to understand which container we want to update the image field on.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因为容器是一个列表，我们需要为Kubernetes指定合并键`name`，以便理解我们要更新图像字段的容器。
- en: With the `patch` command, Kubernetes performs a merge, merging the JSON provided
    with the current definition of the `deployment/versions` object.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`patch`命令，Kubernetes执行合并，将提供的JSON与`deployment/versions`对象的当前定义进行合并。
- en: Go ahead and reload the app in your browser, and then you should notice (after
    a few seconds) that the new version of the app becomes available.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 继续在浏览器中重新加载应用程序，然后您应该会注意到（几秒钟后）应用程序的新版本变为可用。
- en: kubectl edit
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kubectl edit
- en: 'To upgrade to version 0.0.3, we are going to use the `kubectl edit` command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要升级到版本0.0.3，我们将使用`kubectl edit`命令：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`kubectl edit` uses your system''s *standard* editor to edit Kubernetes resources.
    This is often vi, vim, or even ed, but if you have another text editor you prefer
    you should set up the `EDITOR` environment variable to point at your preferred
    choice.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl edit`使用您系统的*标准*编辑器来编辑Kubernetes资源。通常是vi、vim，甚至是ed，但如果您有其他更喜欢的文本编辑器，您应该设置`EDITOR`环境变量指向您的首选选择。'
- en: This should open your editor, so you can make changes to the deployment. Once
    this has happened, edit the image field to use version 0.0.3 and save the file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会打开您的编辑器，这样您就可以对部署进行更改。一旦发生这种情况，请将图像字段编辑为使用版本0.0.3并保存文件。
- en: You might notice that there are more fields in the object opened in your editor
    than the original file you submitted to Kubernetes. This is because Kubernetes
    is storing metadata about the current status of the deployment in this object.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到在您的编辑器中打开的对象中有比您提交给Kubernetes的原始文件中更多的字段。这是因为Kubernetes在此对象中存储有关部署当前状态的元数据。
- en: kubectl apply
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kubectl apply
- en: To update to version 0.0.4, we are going to use the `apply` command. This allows
    us to submit the full resource to Kubernetes just like when we made the initial
    deployment.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要升级到版本0.0.4，我们将使用`apply`命令。这允许我们将完整的资源提交给Kubernetes，就像我们进行初始部署时一样。
- en: 'Start by editing your deployment YAML file, and then update the image field
    to use version 0.0.4\. Save the file and then use `kubectl` to submit it to Kubernetes:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先编辑您的部署YAML文件，然后将图像字段更新为使用版本0.0.4。保存文件，然后使用`kubectl`将其提交到Kubernetes：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you use `kubectl apply` for a resource that doesn't yet exist, it will be
    created for you. This can be useful if you are using it in a scripted deployment.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`kubectl apply`来创建尚不存在的资源，它将为您创建。如果您在脚本化部署中使用它，这可能会很有用。
- en: The advantage of using `kubectl apply` rather than edit or patch is that you
    can keep a file checked into version control to represent the state of your cluster.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl apply`而不是edit或patch的优势在于，您可以保持将文件提交到版本控制以表示集群状态。
- en: Kubernetes dashboard
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes仪表板
- en: 'The Kubernetes dashboard includes a tree-based editor that allows you to edit
    resources right in the browser. On Minikube, you can run the Minikube dashboard
    to open the dashboard in your browser. You can then choose your deployment and
    click on the edit button at the top of the page:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes仪表板包括一个基于树的编辑器，允许您直接在浏览器中编辑资源。在Minikube上，您可以运行Minikube仪表板以在浏览器中打开仪表板。然后，您可以选择您的部署并单击页面顶部的编辑按钮：
- en: '![](assets/ed270944-d34b-428c-861b-769b43553495.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ed270944-d34b-428c-861b-769b43553495.png)'
- en: You should be able to find the container image field by scrolling or with the
    search function. It is simple to click on a value to edit it and then press **UPDATE**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够通过滚动或使用搜索功能找到容器图像字段。单击值进行编辑然后按**UPDATE**非常简单。
- en: While you are learning about Kubernetes and experimenting with different configurations,
    the method you use for updating your configuration should be your own personal
    preference. Using the Kubernetes dashboard or tools such as `kubectl edit` are
    great for learning and debugging. But when you move forward to a production environment,
    you will want to move toward checking your configuration into version control,
    or using a tool such as Helm (which we will discuss in [Chapter 5](90166a73-b677-467e-a198-c00b7c078bd0.xhtml),
    *Managing Complex Applications with Helm*).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当您了解Kubernetes并尝试不同的配置时，您用于更新配置的方法应该是您自己的个人偏好。使用Kubernetes仪表板或诸如`kubectl edit`之类的工具非常适合学习和调试。但是，当您进入生产环境时，您将希望开始将您的配置检入版本控制，或者使用诸如Helm（我们将在[第5章](90166a73-b677-467e-a198-c00b7c078bd0.xhtml)中讨论的*使用Helm管理复杂应用*）之类的工具。
- en: Greater control of your deployments
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好地控制您的部署
- en: By now we have covered a number of ways that we can update resources in Kubernetes.
    As we have observed, when we update a deployment in Kubernetes, eventually the
    pods in the cluster are updated to reflect the new configuration.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了一些在Kubernetes中更新资源的方法。正如我们所观察到的，当我们在Kubernetes中更新部署时，集群中的Pod最终会更新以反映新的配置。
- en: Kubernetes achieves this by managing ReplicaSets behind the scenes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes通过在幕后管理ReplicaSets来实现这一点。
- en: The ReplicaSet is purely concerned with managing a set of pods to ensure that
    the desired number of replicas are running on the cluster. During an update, the
    pod spec of the existing ReplicaSet is never changed. The deployment controller
    creates a new ReplicaSet with the new pod configuration. The roll-out of this
    new configuration is orchestrated by altering the desired number of replicas for
    each ReplicaSet.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet纯粹关注管理一组Pod，以确保集群上运行所需数量的副本。在更新期间，现有ReplicaSet的Pod规范永远不会更改。部署控制器会使用新的Pod配置创建一个新的ReplicaSet。通过改变每个ReplicaSet的所需副本数量来编排这种新配置的推出。
- en: This separation of concerns is typical of the way that resources are designed
    in Kubernetes. More complex behavior is achieved by orchestrating simpler objects,
    whose controllers implement simpler behaviors.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关注点的分离是Kubernetes中资源设计的典型方式。通过编排更简单的对象，其控制器实现更简单的行为来实现更复杂的行为。
- en: This design also makes it quite simple for us (the cluster operator) to decide
    exactly what behavior we want when we update our configuration. The `spec.stratergy`
    field is used to configure the behavior that is used when changes are rolled out.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计还使我们（集群操作员）能够非常简单地决定在更新配置时我们想要的确切行为。`spec.stratergy`字段用于配置推出更改时使用的行为。
- en: 'The `.spec.strategy.type` field defines the strategy that is used to replace
    the old pods with new ones. Currently, there are two strategies: `Recreate` and
    `RollingUpdate`. `RollingUpdate` is the default strategy, so normally you won''t
    need to specify it in your configuration.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`.spec.strategy.type`字段定义了用于用新的Pod替换旧的Pod的策略。目前有两种策略：`Recreate`和`RollingUpdate`。`RollingUpdate`是默认策略，因此通常您不需要在配置中指定它。'
- en: RollingUpdate deployment
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滚动更新部署
- en: '`.spec.strategy.type=RollingUpdate is the default strategy`. This is the strategy
    that we have been using in our examples so far.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`.spec.strategy.type=RollingUpdate是默认策略`。这是我们迄今为止在示例中使用的策略。'
- en: You would specifically choose a rolling update whenever you want to update without
    interruption to service. Conversely, your application has to work correctly when
    multiple versions are running at the same time if you use this strategy.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要在不中断服务的情况下进行更新时，您会明确选择滚动更新。相反，如果您使用此策略，您的应用程序必须在同时运行多个版本时正确工作。
- en: 'When using the `RollingUpdate` strategy, there are two settings that allow
    us to specify how quickly the new ReplicaSet is scaled up and how quickly the
    old ReplicaSet is scaled down:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`RollingUpdate`策略时，有两个设置允许我们指定新的ReplicaSet如何快速扩展，旧的ReplicaSet如何快速缩减：
- en: '`.spec.strategy.rollingUpdate.maxUnavailable`: It specifies the number of pods
    that can be unavailable (out of the desired total) during the deployment process'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.spec.strategy.rollingUpdate.maxUnavailable`：它指定在部署过程中可以不可用的Pod数量（超出所需总数）。'
- en: '`.spec.strategy.rollingUpdate.maxSurge`: It specifies the number of pods that
    can be created over and above the desired total during the deployment process'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.spec.strategy.rollingUpdate.maxSurge`：它指定在部署过程中可以创建的Pod数量，超出所需总数。'
- en: These settings accept either absolute values, such as 1 or 0, or a percentage
    of the total desired number of pods on the deployment. A percentage value is useful
    if you intend for this configuration to be reusable across different deployments
    that are scaled to different levels, or if you intend to control the desired number
    of pods with an auto-scaling mechanism.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置接受绝对值，例如1或0，或部署中所需的总Pod数量的百分比。百分比值在以下情况下很有用：如果您打算使此配置可在不同级别进行扩展的不同部署中重复使用，或者如果您打算使用自动扩展机制来控制所需的Pod数量。
- en: By setting `maxUnavailable` to `0`, Kubernetes will wait till replacement pod(s)
    have been scheduled and are running before killing any pods managed by the old
    ReplicationSet. If `maxUnavailable` is used in this way, then during the deployment
    process, Kubernetes will run more than the desired number of pods so `maxSurge`
    cannot be `0`, and you must have the required resources (in a cluster, and for
    backing services) to support temporarily running the extra instances during the
    deployment phase.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`maxUnavailable`设置为`0`，Kubernetes将等待替换的Pod被调度并运行，然后再杀死由旧的ReplicationSet管理的任何Pod。如果以这种方式使用`maxUnavailable`，那么在部署过程中，Kubernetes将运行超出所需数量的Pod，因此`maxSurge`不能为`0`，并且您必须具有所需的资源（在集群中和用于后备服务）来支持在部署阶段临时运行额外的实例。
- en: Once Kubernetes has launched all the instances, it it must wait until the new
    pods are in service and in the `Ready` state. This means that if you have set
    up health checks for your pod, the deployment will pause if these are failing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Kubernetes启动了所有实例，它必须等待新的Pod处于服务状态并处于`Ready`状态。这意味着如果您为Pod设置了健康检查，如果这些检查失败，部署将暂停。
- en: If `maxSurge` and/or `maxUnavailable` are set to low values, your deployments
    will take longer as the deployment will pause and wait for the new pod(s) to become
    available before moving forward. This can be useful, as it provides you a degree
    of protection against deploying broken code or configurations.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`maxSurge`和/或`maxUnavailable`设置为较低的值，部署将需要更长时间，因为部署将暂停并等待新的Pod可用后才能继续。这是有用的，因为它可以在部署损坏的代码或配置时提供一定程度的保护。
- en: Setting `maxSurge` to a bigger value will decrease the number of scaling steps
    the deployment takes to update the application. If, for example, you were to set
    `maxSurge` to 100% and `maxUnavailable` to 0 then Kubernetes would create all
    the replacement pods as soon as the deployment starts and kill the existing pods
    as the new ones enter the Ready state.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将`maxSurge`设置为更大的值将减少部署更新应用程序所需的扩展步骤的数量。例如，如果将`maxSurge`设置为100%，`maxUnavailable`设置为0，那么Kubernetes将在部署开始时创建所有替换的Pod，并在新的Pod进入Ready状态时杀死现有的Pod。
- en: Exactly how you want to configure your deployments will depend on the requirements
    of your application and the resources available to your cluster.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 确切地配置部署将取决于应用程序的要求和集群可用的资源。
- en: You should bear in mind that setting `maxSurge` to lower values will give you
    slower deployments that take longer to complete, but may be more resilient to
    errors, whereas, with higher `maxSurge` values, your deployments will progress
    faster. But your cluster will need to have enough capacity to support the additional
    running instances. If your application accesses other services, you should also
    be aware of the additional load that might be placed on them. For example, databases
    can be configured to have a limit to the number of connections that they accept.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该记住，将`maxSurge`设置为较低的值将使部署速度较慢，需要更长的时间来完成，但可能更具有错误的弹性，而较高的`maxSurge`值将使您的部署进展更快。但您的集群需要具有足够的容量来支持额外的运行实例。如果您的应用程序访问其他服务，您还应该注意可能对它们施加的额外负载。例如，数据库可以配置为接受的连接数量有限。
- en: Recreate deployment
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新创建部署
- en: '`.spec.strategy.type=Recreate` takes a much simpler approach to rolling out
    changes to your application. First, all the pods with the previous configuration
    are terminated by scaling down the active ReplicaSet, and then a new ReplicaSet
    is created that starts replacement pods.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`.spec.strategy.type=Recreate`采用了一种更简单的方法来推出对应用程序的更改。首先，通过缩减活动的ReplicaSet来终止具有先前配置的所有pod，然后创建一个启动替换pod的新ReplicaSet。'
- en: This strategy is particularly appropriate when you don't mind short periods
    of downtime. For example, with background processing, when workers or other tasks
    don't need to provide services that are accessed over the network. The advantages
    in these use cases are twofold. Firstly, you don't have to worry about any incompatibilities
    caused by two versions of your code running at the same time. Secondly, of course,
    with this strategy the process of updating your pods uses no more resources that
    your application would normally need.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不介意短暂的停机时间时，这种策略特别合适。例如，在后台处理中，当工作程序或其他任务不需要提供通过网络访问的服务时。在这些用例中的优势是双重的。首先，您不必担心由同时运行两个版本的代码引起的任何不兼容性。其次，当然，使用这种策略更新您的pod的过程不会使用比您的应用程序通常需要的更多资源。
- en: DaemonSet
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DaemonSet
- en: 'If you want a single instance of a particular pod to be running on every node
    of your cluster (or a subset of your nodes), then you need to use a DaemonSet.
    When you schedule a DaemonSet to your cluster, an instance of your pod will be
    scheduled to every node, and when you add new nodes, the pod is scheduled there
    too. DaemonSet are very useful for providing ubiquitous services that need to
    be available everywhere on your cluster. You might use DaemonSet to provide services
    such as:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望特定pod的单个实例在集群的每个节点（或节点的子集）上运行，则需要使用DaemonSet。当您将DaemonSet调度到集群时，您的pod的一个实例将被调度到每个节点，并且当您添加新节点时，该pod也会被调度到那里。DaemonSet非常适用于提供需要在集群的每个地方都可用的普遍服务。您可能会使用DaemonSet来提供以下服务：
- en: An agent to ingest and ship logs, such as Fluentd or Logstash
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于摄取和传送日志的代理，如Fluentd或Logstash
- en: A monitoring agent, such as collectd, Prometheus Node Exporter, datadog, NewRelic
    or SysDig, and so on
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控代理，如collectd、Prometheus Node Exporter、datadog、NewRelic或SysDig等
- en: A daemon for a distributed storage system, such as Gluster or Ceph
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于分布式存储系统的守护程序，如Gluster或Ceph
- en: Components for an overlay network, such as Calico or Flannel
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于覆盖网络的组件，如Calico或Flannel
- en: Per node components, a virtualization tool, such as OpenStack
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个节点组件，如OpenStack虚拟化工具
- en: Before Kubernetes, these sorts of services would require you to configure an
    init system, such as `systemd` or SysVnit, on every server in your infrastructure.
    When you came to update the service or its configuration, you would have to update
    that configuration and restart services across all your servers, which is not
    a problem when you are managing a few servers, but with tens, hundreds, or even
    thousands of servers, things quickly become much harder to manage.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes之前，这些类型的服务将要求您在基础设施中的每台服务器上配置一个init系统，例如`systemd`或SysVnit。当您要更新服务或其配置时，您将不得不更新该配置并重新启动所有服务器上的服务，当您管理少量服务器时，这并不是问题，但是当您有数十、数百甚至数千台服务器时，事情很快变得更加难以管理。
- en: DaemonSet lets you use exactly the same configuration and containerization we
    have been applying to the applications that run on your infrastructure to manage
    the infrastructure itself.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: DaemonSet允许您使用与您正在管理基础设施的应用程序相同的配置和容器化。
- en: Let's look at a simple example to understand how we can create a DaemonSet for
    a useful purpose. We will be deploying the Prometheus Node Exporter. The purpose
    of this application is to expose an HTTP endpoint that includes metrics about
    the Linux system it is running on.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子，以了解如何为有用的目的创建一个DaemonSet。我们将部署Prometheus Node Exporter。这个应用程序的目的是公开一个包含有关其正在运行的Linux系统的指标的HTTP端点。
- en: If you decide to monitor your cluster, PrometheusNode Exporter is a very useful
    tool. If you do decide to run it in your own cluster, I would recommend that you
    look at the extensive documentation available on the GitHub page at [https://github.com/prometheus/node_exporter](https://github.com/prometheus/node_exporter).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定监视您的集群，Prometheus Node Exporter是一个非常有用的工具。如果您决定在自己的集群中运行它，我建议您查看GitHub页面上提供的广泛文档[https://github.com/prometheus/node_exporter](https://github.com/prometheus/node_exporter)。
- en: 'This manifest causes the pod specified in the template section to be scheduled
    to every node in your cluster:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单会导致在模板部分指定的pod被调度到您集群中的每个节点上：
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once you have prepared the manifest file for the Node Exporter, submit it to
    Kubernetes by running the `kubectl apply -f node-exporter.yaml` command.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您准备好Node Exporter的清单文件，通过运行`kubectl apply -f node-exporter.yaml`命令将其提交到Kubernetes。
- en: You can check if the DaemonSet controller has scheduled our pod to the nodes
    in your cluster correctly by running the `kubectl describe ds/node-exporter` command.
    Assuming that the pod is successfully running, you should be able to make an HTTP
    request to port `9100` on one of your nodes to see the metrics that it exposes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行`kubectl describe ds/node-exporter`命令来检查DaemonSet控制器是否已正确将我们的pod调度到集群中的节点。假设pod成功运行，您应该能够在其中一个节点的端口`9100`上发出HTTP请求，以查看其公开的指标。
- en: If you are trying this example on Minikube, you can discover the IP address
    of the (only) node in your cluster by running `minikube ip`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Minikube上尝试此示例，可以通过运行`minikube ip`来发现集群中（唯一）节点的IP地址。
- en: 'Then you can use a tool such as `curl` to make a request:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您可以使用`curl`等工具发出请求：
- en: '`**curl 192.168.99.100:9100/metrics**`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`**curl 192.168.99.100:9100/metrics**`'
- en: One of the key advantages to using DaemonSet to manage infrastructure tools
    and components, rather than relying on static configuration on your nodes to manage
    them, is that they can be updated just as easily as any other application you
    are running on your cluster.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DaemonSet来管理基础设施工具和组件的一个关键优势是，它们可以像您在集群上运行的任何其他应用程序一样轻松更新，而不是依赖于节点上的静态配置来管理它们。
- en: By default, DaemonSet have an `updateStrategy` of `RollingUpdate`. This means
    if you edit the pod template in a DaemonSet, the existing pods currently running
    on the cluster are killed and replaced one by one.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，DaemonSet具有“updateStrategy”为“RollingUpdate”。这意味着如果您编辑了DaemonSet中的pod模板，当前在集群上运行的现有pod将被逐个杀死并替换。
- en: 'Let''s try using this functionality to upgrade to a newer version of the Prometheus
    Node Exporter:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用此功能来升级到Prometheus Node Exporter的新版本：
- en: '[PRE22]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can check on the progress of replacing the old pods with the new version
    by running: `kubectl rollout status ds/node-exporter` command. Once the update
    is completed, you should see the following message: `daemon set "node-exporter"
    successfully rolled out`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行`kubectl rollout status ds/node-exporter`命令来查看替换旧版本的pod的进度。一旦更新完成，您应该会看到以下消息：“daemon
    set "node-exporter" successfully rolled out”。
- en: You might be wondering what other `updateStrategys` are available for DaemonSet.
    The only other option is `OnDelete`. With this option, when a DaemonSet is updated,
    no changes are made to the running pods running on the cluster, and it is left
    up to you to manually delete the running pods before the new version is launched.
    This mainly exists to provide compatibility with the behavior in previous versions
    of Kubernetes and is not, in practice, very useful.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道DaemonSet还有哪些其他“updateStrategys”可用。唯一的其他选项是“OnDelete”。使用此选项时，当DaemonSet更新时，不会对集群上运行的现有pod进行任何更改，您需要手动删除运行的pod，然后再启动新版本。这主要是为了与Kubernetes先前版本中的行为兼容，并且在实践中并不是非常有用。
- en: It is worth bearing in mind that in order to roll out a new version of a pod
    with a DaemonSet, there will be a short period between the old pod being killed
    and the new one being launched, during which the service you are running will
    be unavailable.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，为了部署一个带有DaemonSet的新版本的pod，旧的pod被杀死并启动新的pod之间会有一个短暂的时间，在此期间您运行的服务将不可用。
- en: 'DaemonSet can also be used to run pods on a subset of the nodes in your cluster.
    This is achieved by labeling the nodes in your cluster and adding a `nodeSelector`
    to the pod spec of your DaemonSet:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: DaemonSet也可以用于在集群中的节点子集上运行pod。这可以通过为集群中的节点打标签并在DaemonSet的pod规范中添加“nodeSelector”来实现：
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once you have edited your manifest to add the `nodeSelector`, submit the new
    configuration to Kubernetes with: `kubectl apply -f node-exporter.yaml`.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您编辑了清单以添加“nodeSelector”，请使用以下命令将新配置提交给Kubernetes：`kubectl apply -f node-exporter.yaml`。
- en: 'You should notice that the running node exporter pods are terminated and removed
    from your cluster. This is because no nodes in your cluster match the label selector
    that we added to the DaemonSet. Nodes can be labeled on the fly by using `kubectl`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意到正在运行的节点导出器pod被终止并从集群中删除。这是因为您的集群中没有节点与我们添加到DaemonSet的标签选择器匹配。可以使用`kubectl`动态地为节点打标签。
- en: '[PRE24]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once a node is correctly labeled, you should notice that the DaemonSet controller
    schedules a pod to it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦节点被正确标记，您应该注意到DaemonSet控制器会将一个pod调度到该节点上。
- en: On AWS, nodes are automatically labeled with information including region, availability
    zone, instance type, and hostname. You might wish to use these labels to deploy
    services to certain nodes in your cluster, or to provide differently configured
    versions of tools for different types of node in your cluster.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS上，节点会自动带有标签，包括区域、可用区、实例类型和主机名等信息。您可能希望使用这些标签将服务部署到集群中的特定节点，或者为集群中不同类型的节点提供不同配置版本的工具。
- en: If you want to add additional labels, you can pass them as arguments to the
    kubelet using the `--node-labels` flag.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想添加额外的标签，可以使用`--node-labels`标志将它们作为参数传递给kubelet。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned how to use Kubernetes to run our applications
    and, importantly, how to roll out new versions of our applications and their configurations.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Kubernetes来运行我们的应用程序，以及如何推出新版本的应用程序和它们的配置。
- en: 'We built on our basic knowledge of pods and deployments from the previous chapters:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章基础知识的基础上构建了对pod和部署的了解。
- en: Pods are the lowest-level abstraction that Kubernetes provides us
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod是Kubernetes提供给我们的最低级抽象。
- en: All the other resources that deal with running containers, such as jobs, ScheduledJobs,
    deployments, and even DaemonSet, work by creating pods in specific ways.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他处理容器运行的资源，如作业、ScheduledJobs、部署，甚至DaemonSet，都是通过特定方式创建pod来工作的。
- en: Normally, we don't want to create pods directly because if the node a pod is
    running on stops working, then so will the pod. Using one of the higher-level
    controllers ensures that a new pod will be created to replace failed pods.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，我们不希望直接创建pod，因为如果运行pod的节点停止工作，那么pod也将停止工作。使用其中一个高级控制器可以确保创建新的pod来替换失败的pod。
- en: The higher-level resources, such as deployments and DaemonSet, provide a mechanism
    to replace one version of a pod with a different one in a controlled way. We learned
    about the different strategies that are available to do this.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级资源，如部署和DaemonSet，提供了一种以受控方式用不同版本的pod替换另一个版本的机制。我们了解了可用于执行此操作的不同策略。
- en: Before you move on to the next chapter, take some time to get a feel for how
    each of the deployment strategies work by observing how they behave during the
    deployment process. With a little experience, you will develop an understanding
    of which options to choose for a given application.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一章之前，花点时间通过观察部署过程中它们的行为来了解每种部署策略的工作方式。通过一些经验，您将了解在给定应用程序中选择哪些选项。
- en: In the next chapter, we are going to look at using a tool that builds upon these
    concepts to provide even more powerful ways to deploy and update your applications.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用一个工具，该工具基于这些概念提供了更强大的部署和更新应用程序的方式。
