- en: Google's Infrastructure for the Rest of Us
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谷歌的基础设施服务于我们其他人
- en: Kubernetes was originally built by some of the engineers at Google who were
    responsible for their internal container scheduler, Borg.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes最初是由谷歌的一些工程师构建的，他们负责谷歌内部的容器调度器Borg。
- en: Learning how to run your own infrastructure with Kubernetes can give you some
    of the same superpowers that the site reliability engineers at Google utilize
    to ensure that Google's services are resilient, reliable, and efficient. Using
    Kubernetes allows you to make use of the knowledge and expertise that engineers
    at Google and other companies have built up by virtue of their massive scale.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何使用Kubernetes运行自己的基础设施可以让你拥有一些谷歌的可靠性工程师利用的超能力，以确保谷歌的服务具有弹性、可靠和高效。使用Kubernetes可以让你利用谷歌和其他公司工程师通过其大规模积累的知识和专业技能。
- en: Your organization may never need to operate at the scale of a company such as
    Google. You will, however, discover that many of the tools and techniques developed
    in companies that operate on clusters of tens of thousands of machines are applicable
    to organizations running much smaller deployments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你的组织可能永远不需要像谷歌这样的公司那样运营。然而，你会发现，许多在操作数万台机器的公司中开发的工具和技术对于运行规模小得多的组织也是适用的。
- en: While it is clearly possible for a small team to manually configure and operate
    tens of machines, the automation needed at larger scales can make your life simpler
    and your software more reliable. And if you later need to scale up from tens of
    machines to hundreds or even thousands, you'll know that the tools you are using
    have already been battle tested in the harshest of environments.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一个小团队显然可以手动配置和操作数十台机器，但在更大规模上需要的自动化可以让你的生活更简单，你的软件更可靠。如果以后需要从数十台机器扩展到数百甚至数千台，你会知道你正在使用的工具已经在最恶劣的环境中经过了考验。
- en: The fact that Kubernetes even exists at all is both a measure of the success
    and a vindication of the open source/free software movement. Kubernetes began
    as a project to open source an implementation of the ideas and research behind
    Google's internal container orchestration system, Borg. Now it has taken on a
    life of its own, with the majority of its code now being contributed by engineers
    outside of Google.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的存在本身就是开源/自由软件运动成功的衡量标准和证明。Kubernetes最初是一个项目，旨在开源谷歌内部容器编排系统Borg背后的思想和研究成果。现在它已经有了自己的生命，大部分代码现在都是由谷歌以外的工程师贡献的。
- en: The story of Kubernetes is not only one of Google seeing the benefits that open
    sourcing its own knowledge would indirectly bring to its own cloud business, but
    it's also one of the open source implementations of the various underlying tools
    that were needed coming of age.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的故事不仅仅是谷歌看到开源自己的知识间接地为自己的云业务带来好处，而且也是各种基础工具的开源实现成熟的故事。
- en: Linux containers had existed in some form or another for almost a decade, but
    it took the Docker project (first open sourced in 2013) for them to become widely
    used and understood by a large enough number of users. While Docker did not itself
    bring any single new underlying technology to the table, its innovation was in
    packaging the tools that already existed in a simple and easy-to-use interface.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Linux容器在某种形式上已经存在了将近十年，但直到Docker项目（2013年首次开源）使它们成为足够多用户广泛使用和理解。虽然Docker本身并没有为底层技术带来任何新的东西，但它的创新在于将已经存在的工具打包成一个简单易用的界面。
- en: Kubernetes was also made possible by the existence of etcd, a key-value store
    based on the Raft consensus algorithm that was also first released in 2013 to
    form the underpinnings of another cluster scheduling tool that was being built
    by CoreOS. For Borg, Google had used an underlying state store based on the very
    similar Paxos algorithm, making etcd the perfect fit for Kubernetes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes也得益于etcd的存在，这是一个基于Raft一致性算法的键值存储，也是在2013年首次发布，用于构建CoreOS正在开发的另一个集群调度工具的基础。对于Borg，Google使用了基于非常相似的Paxos算法的底层状态存储，使etcd成为Kubernetes的完美选择。
- en: Google were prepared to take the initiative to create an open source implementation
    of the knowledge which, up until that point, had been a big competitive advantage
    for their engineering organization at a time when Linux containers were beginning
    to become more popular thanks to the influence of Docker.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌准备采取主动措施，创建一个开源实现这些知识的项目，这在那个时候对于他们的工程组织来说是一个巨大的竞争优势，因为Linux容器由于Docker的影响开始变得更加流行。
- en: Kubernetes, Docker, etcd, and many other tools that form the Linux container
    ecosystem are written with the Go programming language. Go provides all the features
    that are needed to build systems such as these, with excellent first-class support
    for concurrency and great networking libraries built in.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes、Docker、etcd和许多其他构成Linux容器生态系统的工具都是用Go编程语言编写的。Go提供了构建这些系统所需的所有功能，具有出色的并发支持和内置的优秀网络库。
- en: However, in my view, the simplicity of the language itself makes it such a good
    choice for open source infrastructure tools, because such a wide variety of developers
    can pick up the basics of the language in a few hours and start making productive
    contributions to a project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我看来，语言本身的简单性使其成为开源基础设施工具的绝佳选择，因为如此广泛的开发人员可以在几个小时内掌握语言的基础知识，并开始对项目做出有生产力的贡献。
- en: If you are interested in finding out more about the go programming language,
    you could try taking a look at [https://tour.golang.org/welcome/1](https://tour.golang.org/welcome/1) and
    then spend an hour looking at [https://gobyexample.com](https://gobyexample.com).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对了解Go编程语言感兴趣，可以尝试查看[https://tour.golang.org/welcome/1](https://tour.golang.org/welcome/1)，然后花一个小时查看[https://gobyexample.com](https://gobyexample.com)。
- en: Why do I need a Kubernetes cluster?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我为什么需要一个Kubernetes集群？
- en: At its core, Kubernetes is a container scheduler, but it is a much richer and
    fully featured toolkit that has many other features. It is possible to extend
    and augment the functionality that Kubernetes provides, as products such as RedHat's
    OpenShift have done. Kubernetes also allows you to extend it's core functionality
    yourself by deploying add-on tools and services to your cluster.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的核心是一个容器调度器，但它是一个更丰富和功能齐全的工具包，具有许多其他功能。可以扩展和增强Kubernetes提供的功能，就像RedHat的OpenShift产品所做的那样。Kubernetes还允许您通过部署附加工具和服务到您的集群来扩展其核心功能。
- en: 'Here are some of the key features that are built into Kubernetes:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是内置在Kubernetes中的一些关键功能：
- en: '**Self-healing**: Kubernetes controller-based orchestration ensures that containers
    are restarted when they fail, and rescheduled when the nodes they are running
    on fail. User-defined health checks allow users to make decisions about how and
    when to recover from failing services, and how to direct traffic when they do.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自愈**: Kubernetes基于控制器的编排确保容器在失败时重新启动，并在它们所在的节点失败时重新调度。用户定义的健康检查允许用户决定如何以及何时从失败的服务中恢复，以及在这样做时如何引导流量。'
- en: '**Service discovery**: Kubernetes is designed from the ground up to make service
    discovery simple without needing to make modifications to your applications. Each
    instance of your application gets its own IP address, and standard discovery mechanisms
    such as DNS and load balancing let your services communicate.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现**：Kubernetes从根本上设计为使服务发现变得简单，而无需对应用程序进行修改。您的应用程序的每个实例都有自己的IP地址，标准的发现机制，如DNS和负载均衡，让您的服务进行通信。'
- en: '**Scaling**: Kubernetes makes horizontal scaling possible at the push of a
    button, and also provides autoscaling facilities.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展**：Kubernetes可以通过按一下按钮实现水平扩展，并提供自动扩展功能。'
- en: '**Deployment orchestration**: Kubernetes not only helps you to manage running
    applications, but has tools to roll out changes to your application and its configuration.
    Its flexibility allows you to build complex deployment patterns for yourself or
    to use one of a number of add-on tools.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署编排**：Kubernetes不仅帮助您管理运行的应用程序，还具有工具来推出对应用程序及其配置的更改。其灵活性使您可以为自己构建复杂的部署模式，或者使用多个附加工具之一。'
- en: '**Storage management**: Kubernetes has built-in support for managing the underlying
    storage technology on cloud providers, such as AWS Elastic Block Store volumes,
    as well as other standard networked storage tools, such as NFS.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储管理**：Kubernetes内置支持管理云提供商的底层存储技术，如AWS Elastic Block Store卷，以及其他标准的网络存储工具，如NFS。'
- en: '**Cluster optimization**: The Kubernetes scheduler automatically assigns your
    workloads to machines based on their requirements, allowing for better utilization
    of resources.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群优化**：Kubernetes调度程序会根据工作负载的需求自动将其分配到机器上，从而更好地利用资源。'
- en: '**Batch workloads**: As well as long-running workloads, Kubernetes can also
    manage batch jobs, such as CI, batch processing, and cron jobs.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批量工作负载**：除了长时间运行的工作负载，Kubernetes还可以管理批处理作业，如CI、批处理处理和定期作业。'
- en: The roots of containers
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的根源
- en: Ask the average user what a Docker container is and you might get any one of
    a dozen responses. You might be told something about lightweight virtual machines,
    or how it is that this hot new disruptive technology is going to revolutionize
    computing. In reality, Linux containers are certainly not a new idea, nor are
    they really all that much like a virtual machine.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 询问普通用户Docker容器是什么，您可能会得到十几种回答之一。您可能会听到有关轻量级虚拟机的内容，或者这种炙手可热的新颠覆性技术将如何革新计算。实际上，Linux容器绝对不是一个新概念，也并不像虚拟机那样。
- en: Back in 1979, the `chroot syscall` was added to Version 7 of Unix. Calling chroot
    changes the apparent root directory for the current running process and its subprocesses.
    Running a program in a so-called chroot jail prevents it from accessing files
    outside of the specified directory tree.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 1979年，Unix的第7版中添加了`chroot syscall`。调用chroot会改变当前运行进程及其子进程的根目录。在所谓的chroot监狱中运行程序可以防止其访问指定目录树之外的文件。
- en: One of the first uses of chroot was for testing of the BSD build system, something
    that is inherited by the package build systems of most of our modern Linux distributions,
    such as Debian, RedHat, and SuSE. By testing packages in a clean chrooted environment,
    build scripts can detect missing dependency information.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: chroot的最初用途之一是用于测试BSD构建系统，这是大多数现代Linux发行版的软件包构建系统所继承的。通过在干净的chroot环境中测试软件包，构建脚本可以检测到缺少的依赖信息。
- en: Chroot is also commonly used to sandbox untrusted processes-for example, shell
    processes on shared FTP or SFTP servers. Systems designed specifically with security
    in mind, such as the Postfix mail transfer agent, utilize chroot to isolate individual
    components of a pipeline in order to prevent a security issue in one component
    from rippling across the system.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Chroot也常用于沙箱化不受信任的进程-例如，在共享FTP或SFTP服务器上的shell进程。专门考虑安全性的系统，例如Postfix邮件传输代理，利用chroot来隔离管道的各个组件，以防止一个组件的安全问题在系统中蔓延。
- en: Chroot is in fact a very simple isolation tool that was never intended to provide
    either security or control over anything other than the filesystem access of the
    processes. For its intended purpose of providing filesystem isolation for the
    likes of build tools, it is perfect. But for isolating applications in a production
    environment, we need a little more control.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Chroot实际上是一个非常简单的隔离工具，它从未旨在提供对文件系统访问以外的任何安全性或控制。对于提供类似构建工具的文件系统隔离的预期目的来说，它是完美的。但是对于在生产环境中隔离应用程序，我们需要更多的控制。
- en: Enter the container
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入容器
- en: 'Trying to understand what a Linux container is can be a little difficult. As
    far as the Linux kernel is concerned, there is no such thing as a container. The
    kernel has a number of features that allow a process to be isolated, but these
    features are much lower-level and granular than what we now think of as a container.
    Container engines such as Docker use two main kernel features to isolate processes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 试图理解Linux容器是什么可能有点困难。就Linux内核而言，根本不存在容器这样的东西。内核具有许多功能，允许对进程进行隔离，但这些功能比我们现在所认为的容器要低级和细粒度得多。诸如Docker之类的容器引擎使用两个主要的内核特性来隔离进程：
- en: Cgroups
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cgroups
- en: '**Cgroups**, or control groups, provide an interface for controlling one or
    a group of processes, hence the name. They allow the control of several aspects
    of the group''s use of resources. Resource utilization can be controlled using
    a limit (for example, by limiting memory usage). Cgroups also allow priorities
    to be set to give processes a greater or lesser share of time-bound resources,
    such as CPU utilization or I/O. Cgroups can also be used to snapshot (and restore)
    the state of running processes.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cgroups**，或者控制组，提供了一个控制一个或一组进程的接口，因此得名。它们允许控制组的资源使用的几个方面。资源利用可以通过限制（例如，限制内存使用）来控制。Cgroups还允许设置优先级，以便为进程提供更多或更少的时间限制资源，例如CPU利用率或I/O。Cgroups还可以用于快照（和恢复）运行进程的状态。'
- en: Namespaces
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: The other part of the container puzzle is kernel namespaces. They operate in
    a manner that is somewhat similar to our use of the chroot syscall in that a container
    engine instructs the kernel to only allow the process a particular view of the
    system's resources.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 容器隔离的另一部分是内核命名空间。它们的操作方式与我们使用chroot系统调用的方式有些相似，即容器引擎指示内核仅允许进程查看系统资源的特定视图。
- en: Instead of just limiting access to the filesystem kernel, namespaces limit access
    to a number of different resources.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与仅限制对文件系统内核的访问不同，命名空间限制对许多不同资源的访问。
- en: 'Each process can be assigned to a namespace and can then only see the resources
    connected to that namespace. The kinds of resources that can be namespaced are
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程可以分配到一个命名空间，然后只能看到与该命名空间连接的资源。可以命名空间化的资源类型如下：
- en: '**Mount**: Mount namespaces control access to the filesystem.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂载**：挂载命名空间控制对文件系统的访问。'
- en: '**Users**: Each namespace has its own set of user IDs. User ID namespaces are
    nested, and thus a user in a higher-level namespace can be mapped to another in
    a lower level. This is what allows a container to run processes as root, without
    giving that process full permission to the root system.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：每个命名空间都有自己的用户ID集。用户ID命名空间是嵌套的，因此高级命名空间中的用户可以映射到低级命名空间中的另一个用户。这就允许容器以root身份运行进程，而不会给予该进程对根系统的完全权限。'
- en: '**PID**: The process ID namespace, like the users namespace, is nested. This
    is why the host can see the processes running inside of the containers when inspecting
    the process list on a system that is running containers. However, inside of the
    namespace the numbers are different; this means that the first process created
    inside a PID namespace, can be assigned PID 1, and can inherit zombie processes
    if required.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PID**：进程ID命名空间与用户命名空间一样是嵌套的。这就是为什么主机可以在运行容器的系统上检查进程列表时看到容器内运行的进程。然而，在命名空间内部，数字是不同的；这意味着在PID命名空间内创建的第一个进程可以被分配为PID
    1，并且可以继承僵尸进程（如果需要）。'
- en: '**Network**: A network namespace contains one or more network interfaces. The
    namespace has its own private network resources, such as addresses, the routing
    table, and firewall.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：网络命名空间包含一个或多个网络接口。该命名空间拥有自己的私有网络资源，如地址、路由表和防火墙。'
- en: There are also namespaces for IPC, UTS, and for the Cgroups interface itself.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 还有用于IPC、UTS和Cgroups接口本身的命名空间。
- en: Putting the pieces together
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将这些部分组合在一起
- en: It is the job of the container engine (software such as Docker or rkt) to put
    these pieces together and make something usable and understandable for us mere
    mortals.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 容器引擎（如Docker或rkt等软件）的工作是将这些部分组合在一起，为我们这些凡人创造出可用和可理解的东西。
- en: While a system that directly exposed all of the details of Cgroups and namespaces
    would be very flexible, it would be far harder to understand and manage. Using
    a system such as Docker gives us a simple-to-understand abstraction over these
    low-level concepts, but necessarily makes many decisions for us about how these
    low-level concepts are used.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一个直接暴露Cgroups和命名空间所有细节的系统会非常灵活，但理解和管理起来会更加困难。使用诸如Docker之类的系统为我们提供了一个简单易懂的抽象，但必然会为我们做出许多关于这些低级概念如何使用的决定。
- en: The fundamental breakthrough that Docker made over previous container technologies
    was to take great defaults for isolating a single process and combine them with
    an image format that allows developers to provide all the dependencies that the
    process requires to run correctly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Docker在先前的容器技术上取得的根本突破是采用了良好的默认设置来隔离单个进程，并将它们与允许开发人员提供进程运行所需的所有依赖项的镜像格式相结合。
- en: This is an incredibly good thing because it allows anyone to install Docker
    and quickly understand what is going on. It also makes this kind of Linux container
    the perfect building block to build larger and more complex systems, such as Kubernetes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常好的一件事，因为它允许任何人安装Docker并快速理解发生了什么。它还使得这种Linux容器成为构建更大更复杂系统（如Kubernetes）的完美基石。
- en: Here, schedule this...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在这里，安排一下...
- en: At its heart, Kubernetes is a system for scheduling work to a cluster of computers—a
    scheduler. But why would you want a scheduler?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Kubernetes是一个将工作调度到一组计算机的系统——一个调度器。但是为什么你需要一个调度器呢？
- en: If you think about your own systems, then you'll realize that you probably already
    have a scheduler, but unless you are already using something like Kubernetes,
    it might look very different.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑一下你自己的系统，你会意识到你可能已经有了一个调度器，但除非你已经在使用类似Kubernetes的东西，否则它可能看起来会非常不同。
- en: Perhaps your scheduler is a team of people, with spreadsheets and documentation
    about which services run on each server in your data center. Perhaps that team
    of people looks at past traffic statistics to try and guess when there will be
    a heavy load in the future. Perhaps your scheduler relies on your users alerting
    members of your team at any time of the night if your applications stop functioning.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你的调度程序是一个团队，有关于数据中心每台服务器上运行的服务的电子表格和文档。也许这个团队会查看过去的流量统计数据，试图猜测未来会有重负载的时间。也许你的调度程序依赖于用户在任何时间通知团队成员，如果你的应用程序停止运行。
- en: This book is about these problems, about how we can move on from a world of
    manual processes and making guesses about the future usage of our systems. It
    is about harnessing the skill and experience of the humans that administer the
    systems to encode our operational knowledge into systems that can make decisions
    about your running system second by second, seamlessly responding to crashed processes,
    failed machines, and increased load without any human intervention.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书讨论了这些问题，讨论了我们如何摆脱手动流程和对系统未来使用的猜测。它是关于利用管理系统的人类的技能和经验，将我们的运营知识编码到可以每秒做出关于你的运行系统的决策的系统中，无缝地响应崩溃的进程、失败的机器和增加的负载，而无需任何人为干预。
- en: 'Kubernetes chooses to model its scheduler as a control loop so that the system
    is constantly discovering the current state of the cluster, comparing it to a
    desired state, and then taking actions to reduce the difference between the desired
    and the actual state. This is summarized in the following diagram:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes选择将其调度程序建模为控制循环，以便系统不断发现集群的当前状态，将其与期望状态进行比较，然后采取行动来减少期望状态和实际状态之间的差异。这在以下图表中总结如下：
- en: '![](assets/a60cc18f-6e83-4ad3-b732-160c2ccbeb76.png)A typical control loop'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的控制循环
- en: Being able to declare the state that we want the system to be in, and then have
    the system itself take the actions needed to manifest that desired state, is very
    powerful.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 能够声明我们希望系统处于的状态，然后让系统自己采取必要的行动来实现这种期望状态，是非常强大的。
- en: 'You may previously have used an imperative tool or a script to manage a system,
    or you may even have used a written playbook of the manual steps to take. This
    sort of approach is very much like a recipe: you take a set of actions one after
    another and hopefully end up in the state that you desire.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您以前可能使用了一种命令式工具或脚本来管理系统，甚至可能使用了手动步骤的书面操作手册。这种方法非常像食谱：你一步一步地采取一系列行动，希望最终达到你所期望的状态。
- en: This works well when describing how to install and bootstrap a system for the
    first time, but when you need to run your script against a system that is already
    running, your logic needs to become more complicated as, for each stage in your
    recipe, you have to stop and check what needs to be done before you do it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当描述如何首次安装和引导系统时，这种方法效果很好，但当你需要运行你的脚本来管理已经运行的系统时，你的逻辑需要变得更加复杂，因为对于食谱中的每个阶段，你都需要停下来检查在执行之前需要做什么。
- en: When using a declarative tool such as Kubernetes to manage your system, your
    configuration is simplified and becomes much easier to reason about. One important
    side effect of this approach is that Kubernetes will repair your configuration
    if an underlying failure causes it to drift away from your desired state.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用像Kubernetes这样的声明性工具来管理系统时，你的配置变得简化，更容易理解。这种方法的一个重要副作用是，如果底层故障导致配置偏离你的期望状态，Kubernetes将修复你的配置。
- en: By combining control loops and declarative configuration, Kubernetes allows
    you to tell it what to do for you, not how to do it. Kubernetes gives you, the
    operator, the role of the architect and Kubernetes takes the role of the builder.
    An architect provides a builder with detailed plans for a building, but doesn't
    need to explain how to build the walls with bricks and mortar. Your responsibility
    is to provide Kubernetes with a specification of your application and the resources
    it needs, but you don't need to worry about the details of exactly how and where
    it will run.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合控制循环和声明性配置，Kubernetes允许您告诉它为您做什么，而不是如何做。Kubernetes赋予您，操作者，建筑师的角色，而Kubernetes则扮演建造者的角色。建筑师向建造者提供了详细的建筑计划，但不需要解释如何用砖和灰浆建造墙壁。您的责任是向Kubernetes提供应用程序的规范和所需的资源，但您不需要担心它将在哪里以及如何运行的细节。
- en: The basics of Kubernetes
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes的基础知识
- en: Let's begin our look at Kubernetes by looking at some of the fundamental concepts
    that most of Kubernetes is built upon. Getting a clear understanding of how these
    core building blocks fit together will serve you well as we explore the multitude
    of features and tools that comprise Kubernetes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始了解Kubernetes，首先看一些大部分Kubernetes建立在其上的基本概念。清楚地了解这些核心构建块如何组合在一起将有助于我们探索组成Kubernetes的多种功能和工具。
- en: It can be a little confusing to use Kubernetes without a clear understanding
    of these core building blocks so, if you don't have any experience with Kubernetes,
    you should take your time to understand how these pieces fit together before moving
    on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有对Kubernetes有任何经验，那么在没有清楚理解这些核心构建块的情况下使用Kubernetes可能会有点困惑，因此，在继续之前，您应该花时间了解这些部分如何组合在一起。
- en: The pod
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pod
- en: 'Like a group of whales, or perhaps a pea pod, a Kubernetes pod is a group of
    linked containers. As the following diagram shows, a pod can be made up of one
    or more containers; often a pod might just be a single container:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 像一群鲸鱼，或者也许是豌豆荚一样，Kubernetes pod是一组链接的容器。如下图所示，一个pod可以由一个或多个容器组成；通常一个pod可能只是一个单一的容器：
- en: '![](assets/5ab14adc-a52d-4bfe-9609-b60fc3a2d288.png)Pods are a logical grouping
    of one or more containers'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5ab14adc-a52d-4bfe-9609-b60fc3a2d288.png)Pods是一个或多个容器的逻辑分组'
- en: Each pod that Kubernetes schedules is allocated its own unique IP address. The
    network namespace (and thus the pod's IP address) is shared by each container
    in the pod.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes调度的每个pod都被分配了独特的IP地址。网络命名空间（因此pod的IP地址）被每个pod中的每个容器共享。
- en: 'This means that it is convenient to deploy several containers together that
    closely collaborate over the network. For example, you might deploy a reverse
    proxy alongside a web application to add SSL or caching capabilities to an application
    that does not natively support them. In the following example, we achieve this
    by deploying a typical web application server-for example, Ruby on Rails—alongside
    a reverse proxy—for example, NGINX. This additional container provides further
    capabilities that might not be provided by the native application. This pattern
    of composing functionality together from smaller isolated containers means that
    you are able to reuse components more easily, and makes it simple to add additional
    functionality to existing tools. The setup is shown in the following diagram:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着方便地一起部署几个密切协作的容器。例如，您可以部署一个反向代理与Web应用程序一起，以为不本地支持它们的应用程序添加SSL或缓存功能。在下面的示例中，我们通过部署一个典型的Web应用程序服务器-例如Ruby
    on Rails-以及一个反向代理-例如NGINX来实现这一点。这个额外的容器提供了可能不被原生应用程序提供的进一步功能。将功能从较小的隔离容器中组合在一起的这种模式意味着您能够更容易地重用组件，并且可以简单地向现有工具添加额外的功能。设置如下图所示：
- en: '![](assets/4efcf9ca-12d3-4882-8570-fa432e46e81d.png)Providing additional capabilities
    by composing multiple containers'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/4efcf9ca-12d3-4882-8570-fa432e46e81d.png)通过组合多个容器提供额外的功能'
- en: As well as sharing the network namespace, Kubernetes also allows very flexible
    sharing of volume mounts between any number of containers in a pod. This allows
    for a number of scenarios where several components may collaborate to perform
    a particular task.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了共享网络命名空间外，Kubernetes还允许在一个pod中的任意数量的容器之间非常灵活地共享卷挂载。这允许出现多种情况，其中几个组件可以协作执行特定任务。
- en: In this example, we are using three containers that coordinate to serve a website
    built with a static-site generator using the NGINX webserver.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了三个容器来协调为使用NGINX web服务器构建的静态网站提供服务。
- en: The first container uses Git to pull and update the source code from a remote
    Git repository. This repository is cloned into a volume that is shared with the
    second container. This second container uses the Jekyll framework to build the
    static files that will be served by our webserver. Jekyll watches the shared directory
    for changes on the filesystem and regenerates any files that need to be updated.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个容器使用Git从远程Git存储库中拉取和更新源代码。该存储库被克隆到与第二个容器共享的卷中。第二个容器使用Jekyll框架构建将由我们的web服务器提供的静态文件。Jekyll监视文件系统上的共享目录的更改，并重新生成需要更新的任何文件。
- en: 'The directory that Jekyll writes the generated files to is shared with a container
    running NGINX that serves HTTP requests for our website, as shown in the following
    diagram:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Jekyll写入生成文件的目录与运行NGINX的容器共享，用于为我们的网站提供HTTP请求，如下图所示：
- en: We are using Jekyll here as an example, but there are many tools you can use
    to build static websites, such as Hugo, Hexo, and Gatsby. Splitting your application
    into separate containers like this means that it is simple to upgrade a single
    component, or even try an alternative tool.![](assets/850176d8-c5a3-4e36-a6e2-95b84c37c8f2.png)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用Jekyll作为例子，但是你可以使用许多工具来构建静态网站，比如Hugo、Hexo和Gatsby。像这样将应用程序拆分成单独的容器意味着很容易升级单个组件，甚至尝试替代工具。![](assets/850176d8-c5a3-4e36-a6e2-95b84c37c8f2.png)
- en: 'Another use for pods that share volume mounts is to support applications that
    communicate using Unix sockets, as shown in the following diagram. For example,
    an **extract transform load** (**ETL**) system could be modeled as several independent
    processes that communicate with UNIX sockets. This might be beneficial if you
    are able to make use of third-party tools for some or all of your pipeline, or
    reuse tools that you may have built for internal use in a variety of situations:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 共享卷挂载的pod的另一个用途是支持使用Unix套接字进行通信的应用程序，如下图所示。例如，**提取转换加载**（**ETL**）系统可以被建模为使用UNIX套接字进行通信的几个独立进程。如果您能够利用第三方工具来处理管道的一部分或全部内容，或者在各种情况下重用您为内部使用构建的工具，这可能是有益的：
- en: '![](assets/821eb4df-720d-48e4-9588-9d1121b9375f.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/821eb4df-720d-48e4-9588-9d1121b9375f.png)'
- en: In this example, a custom application designed to scrape data from webpages
    communicates with an instance of Fluentd over a Unix domain socket located in
    a shared volume. The pattern of using a third-party tool such as Fluentd to push
    data to a backing datastore not only simplifies the implementation of the custom
    tool, but also provides compatibility with any store that Fluentd chooses to support.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个定制的应用程序用于从网页中抓取数据，并通过共享卷中的Unix域套接字与Fluentd的实例进行通信。使用第三方工具（如Fluentd）将数据推送到后端数据存储的模式不仅简化了定制工具的实现，还提供了与Fluentd选择支持的任何存储兼容的功能。
- en: Kubernetes gives you some strong guarantees that the containers in your pod
    have a shared lifecycle. This means that when you launch a pod, you can be sure
    that each container will be scheduled to the same node; this is important because
    it means that you can depend on the fact that other containers in your pod will
    exist and will be local. Pods are often a convenient way to glue the functionality
    of several different containers together, enabling the reuse of common components.
    You might, for example, use a sidecar container to enhance the networking abilities
    of your application, or provide additional log management or monitoring facilities.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes为您提供了一些强有力的保证，即pod中的容器具有共享的生命周期。这意味着当您启动一个pod时，您可以确保每个容器将被调度到同一节点；这很重要，因为这意味着您可以依赖于pod中的其他容器将存在并且将是本地的。Pod通常是将几个不同容器的功能粘合在一起的便捷方式，从而实现常见组件的重用。例如，您可以使用sidecar容器来增强应用程序的网络能力，或提供额外的日志管理或监控设施。
- en: Labeling all the things
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给所有东西贴标签
- en: '**Labels** are key-value pairs that are attached to resources, such as pods.
    They are intended to contain information that helps you to identify a particular
    resource.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**标签**是附加到资源（如pod）的键值对，旨在包含帮助您识别特定资源的信息。'
- en: You might add labels to your pods to identify the application that is being
    run, as well as other metadata, such as a version number, an environment name,
    or other labels that pertain to your application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为您的pod添加标签，以标识正在运行的应用程序，以及其他元数据，例如版本号、环境名称或与您的应用程序相关的其他标签。
- en: Labels are very flexible, as Kubernetes leaves it up to you to label your own
    resources as you see fit.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 标签非常灵活，因为Kubernetes让您自行决定如何为自己的资源打上标签。
- en: Once you begin working with Kubernetes, you will discover that you are able
    to add labels to almost every resource that you create.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您开始使用Kubernetes，您将发现几乎可以为您创建的每个资源添加标签。
- en: 'The power of being able to add labels that reflect the architecture of your
    own application is that you are able to use selectors to query the resources using
    any combination of the labels that you have given your resources. This setup is
    shown in the following diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 能够添加反映您自己应用程序架构的标签的强大之处在于，您可以使用选择器使用您为资源指定的任何标签组合来查询资源。这种设置如下图所示：
- en: '![](assets/7dc60739-2e11-41fd-b612-8c727f9c35f4.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7dc60739-2e11-41fd-b612-8c727f9c35f4.png)'
- en: You can add labels to many of the resources that you will create in Kubernetes
    and then query them with selectors.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为在Kubernetes中创建的许多资源添加标签，然后使用选择器进行查询。
- en: 'Kubernetes doesn''t enforce any particular schema or layout for the labels
    you give to objects in your cluster; and you are free to label your applications
    however you choose. If you want a little more structure however. Kubernetes does
    make some suggestions for labels you might want to apply to objects that can be
    grouped together into a logical Application. You can read more about this in the
    Kubernetes documentation: [https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/](https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes不强制执行任何特定的模式或布局，用于给集群中的对象打标签；您可以自由地为应用程序打上标签。但是，如果您想要一些结构，Kubernetes确实对您可能想要应用于可以组合成逻辑应用程序的对象的标签提出了一些建议。您可以在Kubernetes文档中阅读更多信息：[https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/](https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/)。
- en: Replica sets
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 副本集
- en: In Kubernetes, a `ReplicaSet` is a resource that templates the creation of pods.
    The definition of a replica set contains a template definition of the pods that
    it creates, a desired count of replicas, and a selector to discover the pods under
    its management.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，`ReplicaSet`是一个模板化创建pod的资源。副本集的定义包含它创建的pod的模板定义，副本的期望数量和用于发现其管理下的pod的选择器。
- en: The `ReplicaSet` is used to ensure that the desired number of pods is always
    running. If the count of pods matching the selector drops below the desired count,
    then Kubernetes will schedule another.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReplicaSet`用于确保始终运行所需数量的pod。如果与选择器匹配的pod数量低于所需数量，则Kubernetes将安排另一个。'
- en: Because the life of a pod is tied to that of the node that it is running on,
    a pod can be considered ephemeral. There are a number of reasons why the life
    of a particular pod could come to an end. Perhaps it was removed by the operator
    or an automated process. Kubernetes could have evicted the pod to better utilize
    the resources of the cluster or prepare the node for shutdown or restart. Or perhaps
    the underlying node failed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于pod的生命周期与其运行的节点的生命周期相关，pod可以被视为短暂的。有许多原因可能导致特定pod的生命周期结束。也许它被操作员或自动化流程移除了。Kubernetes可能已经驱逐了pod以更好地利用集群的资源或准备节点进行关闭或重启。或者底层节点可能失败了。
- en: A `ReplicaSet` allows us to manage our application by asking the cluster to
    ensure that the correct number of replicas is running across the cluster as a
    whole. This is a strategy that Kubernetes embraces across many of its APIs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReplicaSet`允许我们通过要求集群确保整个集群中运行正确数量的副本来管理我们的应用程序。这是Kubernetes在其许多API中采用的一种策略。'
- en: 'As a cluster operator, Kubernetes takes some of the complexity of running applications
    away from the user. When I decide that I need three instances of my application
    running, I no longer need to think about the underlying infrastructure: I can
    just tell Kubernetes to carry out my wishes. And if the worst happens and one
    of the underlying machines that my application is running on fails, Kubernetes
    will know how to self-heal my application and launch a new pod. No more pager
    calls and trying to recover or replace failed instances in the middle of the night.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为集群操作员，Kubernetes会帮助用户减少运行应用程序的复杂性。当我决定需要运行我的应用程序的三个实例时，我不再需要考虑底层基础设施：我只需告诉Kubernetes执行我的愿望。如果最坏的情况发生，我的应用程序正在运行的底层机器之一失败，Kubernetes将知道如何自我修复我的应用程序并启动一个新的pod。不再需要寻呼机的呼叫，也不需要在半夜里尝试恢复或替换失败的实例。
- en: '`ReplicaSet` replaces the `ReplicationController` that you might have read
    about in older tutorials and documentation. They are almost entirely identical,
    but differ in a few small ways.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReplicaSet`取代了您可能在旧教程和文档中了解过的`ReplicationController`。它们几乎完全相同，但在一些细微的方面有所不同。'
- en: Often, we want to update the software we run on our cluster. Because of this,
    we don't normally directly use `ReplicaSet` but, instead, manage them with a `Deployment`
    object. Deployments are used in Kubernetes to gracefully roll out new versions
    of a `ReplicaSet`. You will learn more about deployments in [Chapter 4](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml),
    *Managing Change in Your Applications*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望更新集群上运行的软件。因此，我们通常不直接使用`ReplicaSet`，而是使用`Deployment`对象来管理它们。在Kubernetes中，部署用于优雅地推出`ReplicaSet`的新版本。您将在[第4章](81daf932-eb92-4cac-b2a6-daf8ee455648.xhtml)中了解更多关于部署的内容，*管理应用程序的变更*。
- en: Services
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: The final basic tool that Kubernetes gives us to manage our applications is
    the service. **Services** give us a convenient way of accessing our services within
    our cluster, something often referred to as *service discovery*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes为我们管理应用程序提供的最后一个基本工具是服务。**服务**为我们提供了一种方便的方式，在集群内访问我们的服务，通常被称为*服务发现*。
- en: In practice, a service allows us to define a label selector to refer to a group
    of pods and then map that to something that our application can consume, without
    having to be modified to query the Kubernetes API to gather this information.
    Typically, a service will provide a stable IP address or DNS name that can be
    used to access the underlying pods that it refers to in a round robin fashion.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，服务允许我们定义一个标签选择器来引用一组pod，然后将其映射到我们的应用程序可以使用的内容，而无需修改以查询Kubernetes API来收集这些信息。通常，服务将以轮询的方式提供一个稳定的IP地址或DNS名称，用于访问它所引用的底层pod。
- en: By using a service, our applications don't need to know that they are running
    on Kubernetes-we just need to configure them correctly with the DNS name or IP
    address of a service that they depend on.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用服务，我们的应用程序不需要知道它们正在Kubernetes上运行-我们只需要正确地配置它们，使用服务的DNS名称或IP地址。
- en: 'A service provides a way for other applications in the cluster to discover
    pods that match a particular label selector. It does this by providing a stable
    IP address and, optionally, a DNS name. This setup is shown in the following diagram:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 服务提供了一种让集群中的其他应用程序发现符合特定标签选择器的pod的方法。它通过提供一个稳定的IP地址，以及可选的DNS名称来实现这一点。这个设置如下图所示：
- en: '![](assets/f30aead5-832a-4fc8-965c-9e7271233a0b.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f30aead5-832a-4fc8-965c-9e7271233a0b.png)'
- en: Under the hood
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 底层
- en: Now we have learned a little about the functionality that Kubernetes provides
    to us, the user, let's go a little deeper and look at the components that Kubernetes
    uses to implement these features. Kubernetes makes this task a little easier for
    us by having a microservice architecture, so we can look at the function of each
    component in a certain degree of isolation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Kubernetes为我们提供的功能，让我们深入一点，看看Kubernetes用来实现这些功能的组件。Kubernetes通过具有微服务架构，使我们更容易查看每个组件的功能在一定程度上的隔离。
- en: 'We will get our hands dirty over the next few chapters by actually deploying
    and configuring these components ourselves. However for now, let''s start by getting
    a basic understanding of the function of each of these components by looking at
    the following diagram:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将亲自部署和配置这些组件。但是现在，让我们通过查看以下图表，对每个组件的功能有一个基本的了解：
- en: '![](assets/45a5297d-7bb6-4df0-be3c-0bcc226b0c1d.png)The main Kubernetes components
    on the master node'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/45a5297d-7bb6-4df0-be3c-0bcc226b0c1d.png)主节点上的主要Kubernetes组件'
- en: API server
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API服务器
- en: The **API server** acts as Kubernetes' central hub. All the other components
    in Kubernetes communicate by reading, watching, and updating resources in Kubernetes
    APIs. This central component is used for all of the access and manipulation of
    information about the current state of the cluster, allowing Kubernetes to be
    extended and augmented with new features while still maintaining a high degree
    of consistency.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**API服务器**充当Kubernetes的中央枢纽。Kubernetes中的所有其他组件通过读取、监视和更新Kubernetes API中的资源来进行通信。这个中央组件用于访问和操作集群当前状态的信息，允许Kubernetes在保持高度一致性的同时扩展和增强新功能。 '
- en: Kubernetes uses etcd to store the current state of the cluster. An etcd store
    is used because its design means that it is both resistant to failure and has
    strong guarantees of its consistency. However, the different components that make
    up Kubernetes never directly interact with etcd; instead, they communicate with
    the API server. This is a good design for us, the operator of a cluster, because
    it allows us to restrict access to etcd only to the API server component, improving
    security and simplifying management.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用etcd存储集群的当前状态。使用etcd存储是因为其设计意味着它既能抵抗故障，又能保证其一致性。然而，组成Kubernetes的不同组件从不直接与etcd交互；相反，它们与API服务器通信。对于我们作为集群的操作者来说，这是一个很好的设计，因为它允许我们将对etcd的访问限制在API服务器组件，提高安全性并简化管理。
- en: While the API server is the component in the Kubernetes architecture that everything
    else communicates with to access or update the state, it is stateless itself,
    with all storage being deferred to the backing etcd cluster. This again is an
    ideal design decision for us as cluster operators since it allows us to deploy
    multiple instances of the API server (if we wish) to provide high availability.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然API服务器是Kubernetes架构中的组件，其他所有组件都与其通信以访问或更新状态，但它本身是无状态的，所有存储都被推迟到后端etcd集群。对于我们作为集群操作员来说，这再次是一个理想的设计决策，因为它允许我们部署多个API服务器的实例（如果我们希望）以提供高可用性。
- en: Controller manager
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器管理器
- en: The **controller manager** is the service that runs the core control loops (or
    controllers) that implement some of core functionality that makes Kubernetes function.
    Each of these controllers watches the state of the cluster through the API server
    and then makes changes to try and move the state of the cluster closer to the
    desired state. The design of the controller manager means that only one instance
    of it should be running at a given time; however, to simplify deployment in a
    high-availability configuration, the controller manager has a built-in leader
    election functionality, so that several instances can be deployed side by side,
    but only one will actually carry out work at any one time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器管理器是运行实现Kubernetes功能的一些核心功能的核心控制循环（或控制器）的服务。这些控制器中的每一个都通过API服务器监视集群的状态，然后进行更改，以尝试将集群的状态移动到期望的状态。控制器管理器的设计意味着一次只能运行一个实例；然而，为了简化在高可用配置中的部署，控制器管理器具有内置的领导者选举功能，因此可以并排部署多个实例，但只有一个实际上会在任何时候执行工作。
- en: Scheduler
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度器
- en: The **scheduler** is perhaps the single most important component that makes
    Kubernetes a useful and practical tool. It watches for new pods in the unscheduled
    state, and then analyzes the current state of the cluster with regard to running
    workloads, available resources, and other policy-based issues. It then decides
    the best place for that pod to be run in. As with the controller manager, a single
    instance of the scheduler works at any one time, but in a high-availability configuration,
    leader election is available.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器可能是使Kubernetes成为有用和实用工具的最重要的组件。它会监视处于未调度状态的新pod，然后分析集群的当前状态，包括运行的工作负载、可用资源和其他基于策略的问题。然后决定最适合运行该pod的位置。与控制器管理器一样，调度器的单个实例一次只能工作一个，但在高可用配置中，可以进行领导者选举。
- en: Kubelet
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubelet
- en: The **kubelet** is the agent that runs on each node, and is responsible for
    launching pods. It doesn't directly run containers but instead controls a runtime,
    such as Docker or rkt. Typically, the kubelet watches the API server to discover
    which pods have been scheduled on its node.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: kubelet是在每个节点上运行的代理，负责启动pod。它不直接运行容器，而是控制运行时，比如Docker或rkt。通常，kubelet会监视API服务器，以发现已经在其节点上调度的pod。
- en: The kubelet operates at the level of `PodSpec`, so it only knows how to launch
    pods. Any of the higher-level concepts in the Kubernetes API are implemented by
    controllers that ultimately create or destroy pods with a specific configuration.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: kubelet在`PodSpec`级别操作，因此它只知道如何启动pod。Kubernetes API中的任何更高级的概念都是由控制器实现的，最终使用特定配置创建或销毁pod。
- en: The kubelet also runs a tool called **cadvisior** that collects metrics about
    resource usage on the node, and using each container that is running on the node,
    this information can then be used by Kubernetes when making scheduling decisions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: kubelet还运行一个名为**cadvisor**的工具，它收集有关节点上资源使用情况的指标，并使用节点上运行的每个容器，这些信息可以被Kubernetes用来做调度决策。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: By now, you should have a basic understanding of the stack of software that
    makes a modern container orchestrator like Kubernetes tick.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对构建现代容器编排器（如Kubernetes）的软件栈有基本的了解。
- en: 'You should now understand the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该理解以下内容：
- en: Containers are built on top of much lower-level features in the Linux kernel,
    such as namespaces and Cgroups.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是建立在Linux内核的更低级特性之上的，比如命名空间和Cgroups。
- en: In Kubernetes a pod is a powerful abstraction that is built on top of containers.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes中，pod是建立在容器之上的强大抽象。
- en: Kubernetes uses control loops to build a powerful system that allows the operator
    to declaratively specify what should be running. Kubernetes automatically takes
    actions to drive the system towards this state. This is the source of Kubernetes'
    self-healing properties.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes使用控制循环来构建一个强大的系统，允许操作员以声明方式指定应该运行什么。Kubernetes会自动采取行动，推动系统朝着这个状态发展。这是Kubernetes自我修复特性的来源。
- en: Nearly everything in Kubernetes can be given a label, and you should label your
    resources in order to make managing them simpler.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes中几乎所有的东西都可以被贴上标签，你应该给你的资源贴上标签，以便更简单地管理它们。
- en: In the next chapter, you will gain some practical experience using the Kubernetes
    APIs by running a small cluster on your workstation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将通过在工作站上运行一个小集群来获得一些使用Kubernetes API的实际经验。
