- en: 6\. Upcoming Serverless Features in Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. Kubernetes中即将推出的无服务器功能
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Utilize the concepts and components of Knative to deploy applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Knative的概念和组件部署应用程序
- en: Set up Knative on a GKE cluster
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GKE集群上设置Knative
- en: Deploy applications on Knative and configure autoscaling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Knative上部署应用程序并配置自动缩放
- en: Deploy applications on Google Cloud Run
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在谷歌云运行上部署应用程序
- en: Set up Virtual Kubelet on Azure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Azure上设置虚拟Kubelet
- en: Deploy applications with Virtual Kubelet
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用虚拟Kubelet部署应用程序
- en: This chapter covers Knative, Google Cloud Run, and Virtual Kubelet, which offers
    the advantages of serverless on top of a Kubernetes cluster.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了Knative、谷歌云运行和虚拟Kubelet，它们在Kubernetes集群之上提供了无服务器的优势。
- en: Introduction to Serverless with Kubernetes
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Kubernetes的无服务器功能
- en: In the previous chapter, we extensively studied the various setup options and
    platforms used in Kubernetes. We also covered the autoscaling feature of Kubernetes
    and implemented it in an application deployed on a cluster.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们广泛研究了Kubernetes中使用的各种设置选项和平台。我们还涵盖了Kubernetes的自动缩放功能，并在集群上部署的应用程序中实施了它。
- en: Kubernetes and serverless are two of the trending topics in the IT industry,
    but these two topics are often discussed independently of each other. Kubernetes
    is a platform for managing containerized applications, and serverless is an execution
    model that abstracts away the infrastructure so software developers can focus
    on their application logic. However, a combination of these two concepts will
    achieve the same goal of making the software developer's life much easier.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes和无服务器是IT行业中的两个热门话题，但这两个话题经常被独立讨论。Kubernetes是一个管理容器化应用程序的平台，而无服务器是一种执行模型，它抽象了基础设施，使软件开发人员可以专注于他们的应用逻辑。然而，这两个概念的结合将实现同样的目标，使软件开发人员的生活变得更加轻松。
- en: A few platforms have emerged recently that bring serverless features to containers
    by abstracting away the complexities of managing containers and any underlying
    infrastructure. These platforms run serverless workloads on Kubernetes clusters
    and provide many benefits, including autoscaling, scale to zero, per-usage billing,
    event-driven capabilities, integrated monitoring, and integrated logging features.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最近出现了一些平台，通过抽象管理容器和任何基础架构的复杂性，为容器带来了无服务器特性。这些平台在Kubernetes集群上运行无服务器工作负载，并提供许多好处，包括自动缩放、零缩放、按使用量计费、事件驱动功能、集成监控和集成日志记录功能。
- en: 'In this chapter, we will be discussing three technologies that offer the benefits
    of serverless on top of a Kubernetes cluster:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论三种技术，它们在Kubernetes集群之上提供了无服务器的好处：
- en: Knative
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knative
- en: Google Cloud Run
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌云运行
- en: Virtual Kubelet
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟Kubelet
- en: Introduction to Knative
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Knative简介
- en: Knative is an open source project started by Google with contributions from
    over 50 other companies, including Pivotal, Red Hat, IBM, and SAP. Knative extends
    Kubernetes by introducing a set of components to build and run serverless applications
    on top of it. This framework is great for application developers who are already
    using Kubernetes. Knative provides tools for them to focus on their code without
    worrying about the underlying architecture of Kubernetes. It introduces features
    such as automated container builds, autoscaling, scale to zero, and an eventing
    framework, which allows developers to get the benefits of serverless on top of
    Kubernetes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Knative是由谷歌发起的开源项目，得到了包括Pivotal、Red Hat、IBM和SAP在内的50多家其他公司的贡献。Knative通过引入一组组件来扩展Kubernetes，从而构建和运行无服务器应用程序。这个框架非常适合已经在使用Kubernetes的应用开发人员。Knative为他们提供了工具，让他们专注于他们的代码，而不用担心Kubernetes的底层架构。它引入了自动化容器构建、自动缩放、零缩放和事件框架等功能，使开发人员能够在Kubernetes之上获得无服务器的好处。
- en: The Knative framework is described as a "*Kubernetes-based platform to deploy
    and manage modern serverless workloads*" on the Knative website. The framework
    helps to bridge the gap between containerized applications and serverless applications
    by introducing serverless features such as autoscaling and scale to zero to the
    Kubernetes platform.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Knative框架在Knative网站上被描述为“*基于Kubernetes的平台，用于部署和管理现代无服务器工作负载*”。该框架通过引入无服务器特性，如自动缩放和零缩放，来弥合容器化应用程序和无服务器应用程序之间的差距。
- en: 'Knative consists of three main components:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Knative由三个主要组件组成：
- en: Build
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建
- en: Serving
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Eventing
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Note
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The Build component has been deprecated in favor of Tekton Pipelines in the
    latest version of Knative. The final release of the Knative Build component is
    available in version 0.7.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新版本的Knative中，构建组件已被弃用，而是更倾向于使用Tekton Pipelines。Knative构建组件的最终版本可在0.7版本中获得。
- en: Build is the process of building the container images from the source code and
    running them on a Kubernetes cluster. The Knative Serving component allows the
    deployment of serverless applications and functions. This enables serving traffic
    to containers and autoscaling based on the number of requests. The serving component
    is also responsible for taking snapshots of the code and configurations whenever
    a change is made to them. The Knative Eventing component helps us to build event-driven
    applications. This component allows the applications to produce events for and
    consume events from event streams.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 构建是从源代码构建容器映像并在Kubernetes集群上运行它们的过程。Knative Serving组件允许部署无服务器应用程序和函数。这使得可以向容器提供流量，并根据请求的数量进行自动缩放。该服务组件还负责在对代码和配置进行更改时进行快照。Knative
    Eventing组件帮助我们构建事件驱动的应用程序。该组件允许应用程序为事件流产生事件，并从事件流中消费事件。
- en: 'The following diagram illustrates a Knative framework with its dependencies
    and the stakeholders of each component:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了Knative框架及其依赖项以及每个组件的利益相关者：
- en: '![Figure 6.1: Knative dependencies and stakeholders'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1：Knative依赖项和利益相关者'
- en: '](image/C12607_06_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_01.jpg)'
- en: 'Figure 6.1: Knative dependencies and stakeholders'
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.1：Knative依赖项和利益相关者
- en: The bottom layer represents the Kubernetes framework, which is used as the container
    orchestration layer by the Knative framework. Kubernetes can be deployed on any
    infrastructure, such as Google Cloud Platform or an on-premises system. Next,
    we have the **Istio** service mesh layer, which manages network routing within
    the cluster. This layer provides many benefits, including traffic management,
    observability, and security. At the top layer, Knative runs on top of a Kubernetes
    cluster with **Istio**. In the Knative layer, at one end we can see contributors
    who contribute code to the Knative framework through the GitHub project, and at
    the other end we can see the application developers who build and deploy applications
    on top of the Knative framework.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 底层代表了Kubernetes框架，它作为Knative框架的容器编排层使用。Kubernetes可以部署在任何基础设施上，例如Google Cloud
    Platform或本地系统。接下来，我们有**Istio**服务网格层，它管理集群内的网络路由。这一层提供了许多好处，包括流量管理、可观察性和安全性。在顶层，Knative在**Istio**上运行在Kubernetes集群上。在Knative层，一端我们可以看到通过GitHub项目向Knative框架贡献代码的贡献者，另一端我们可以看到构建和部署应用程序在Knative框架之上的应用程序开发人员。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on Istio, please refer to [https://istio.io/](https://istio.io/).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Istio的更多信息，请参阅[https://istio.io/](https://istio.io/)。
- en: Now that we have this understanding of Knative, let's look at how to install
    Knative on a Kubernetes cluster in the following section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Knative有了这样的理解，让我们在下一节中看看如何在Kubernetes集群上安装Knative。
- en: Getting Started with Knative on GKE
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在GKE上开始使用Knative
- en: In this section, we will take you through the process of installing Knative
    on a Kubernetes cluster. We will be using Google Kubernetes Engine (GKE) to set
    up a Kubernetes cluster. GKE is the managed Kubernetes cluster service in the
    Google cloud. It allows us to run Kubernetes clusters without the burden of installing,
    managing and operating our own clusters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将带您完成在Kubernetes集群上安装Knative的过程。我们将使用Google Kubernetes Engine（GKE）来设置一个Kubernetes集群。GKE是Google云中的托管Kubernetes集群服务。它允许我们在不安装、管理和操作自己的集群的负担下运行Kubernetes集群。
- en: 'We need to have the following prerequisites installed and configured to continue
    with this section:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要安装和配置以下先决条件才能继续本节：
- en: A Google Cloud account
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Google Cloud账户
- en: The gcloud CLI
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gcloud CLI
- en: The kubectl CLI (v1.10 or newer)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl CLI（v1.10或更新版本）
- en: 'First, we need to set a few environment variables that we will be using with
    the **gcloud** CLI. You should update `<your-gcp-project-name>` with the name
    of your GCP project. We will be using `us-central1-a` as the GCP zone. Execute
    the following commands in your terminal window to set the required environment
    variables:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置一些环境变量，这些变量将与**gcloud** CLI一起使用。您应该使用您的GCP项目的名称更新`<your-gcp-project-name>`。我们将使用`us-central1-a`作为GCP区域。在您的终端窗口中执行以下命令以设置所需的环境变量：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output should be as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 6.2: Setting environment variables'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2：设置环境变量'
- en: '](image/C12607_06_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_02.jpg)'
- en: 'Figure 6.2: Setting environment variables'
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.2：设置环境变量
- en: 'Set our GCP project as the default project to be used by the `gcloud` CLI commands:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的GCP项目设置为`gcloud` CLI命令要使用的默认项目：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output should be as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 6.3: Setting the default GCP project'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3：设置默认的GCP项目'
- en: '](image/C12607_06_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_03.jpg)'
- en: 'Figure 6.3: Setting the default GCP project'
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.3：设置默认的GCP项目
- en: 'Now we can create the GKE cluster using the `gcloud` command. Knative requires
    a Kubernetes cluster with version 1.11 or newer. We will be using the **Istio**
    plugin provided by GKE for this cluster. The following is the recommended configuration
    for a Kubernetes cluster to run Knative components:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`gcloud`命令创建GKE集群。Knative需要一个版本为1.11或更新的Kubernetes集群。我们将使用GKE提供的**Istio**插件来为这个集群提供支持。以下是运行Knative组件所需的Kubernetes集群的推荐配置：
- en: Kubernetes version 1.11 or newer
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes版本1.11或更新
- en: Kubernetes nodes with four vCPUs (n1-standard-4)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有四个vCPU（n1-standard-4）的Kubernetes节点
- en: Node autoscaling enabled for up to 10 nodes
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用最多10个节点的节点自动缩放
- en: API scopes for `cloud-platform`
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cloud-platform`的API范围'
- en: 'Execute the following command to create a GKE cluster compatible with these
    requirements:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令来创建一个符合这些要求的GKE集群：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output should be as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 6.4: Creating a GKE cluster'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4：创建一个GKE集群'
- en: '](image/C12607_06_04.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_04.jpg)'
- en: 'Figure 6.4: Creating a GKE cluster'
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.4：创建一个GKE集群
- en: 'It may take a few minutes to set up the Kubernetes cluster. Once the cluster
    is ready, we will use the command `gcloud container clusters get-credentials`
    to fetch the credentials of the new cluster and configure the **kubectl** CLI
    as you can see in the following code snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Kubernetes集群可能需要几分钟的时间。一旦集群准备好，我们将使用命令`gcloud container clusters get-credentials`来获取新集群的凭据，并配置**kubectl**
    CLI，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output should be as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 6.5: Fetching credentials for the GKE cluster'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5：获取GKE集群的凭据'
- en: '](image/C12607_06_05.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_05.jpg)'
- en: 'Figure 6.5: Fetching credentials for the GKE cluster'
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.5：获取GKE集群的凭据
- en: Now you have successfully created the GKE cluster with **Istio** and configured
    `kubectl` to access the newly created cluster. We can now proceed with the next
    step of installing Knative. We will be installing Knative version 0.8, which is
    the latest available version at the time of writing this book.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已成功创建了带有**Istio**的GKE集群，并配置了`kubectl`以访问新创建的集群。我们现在可以继续进行下一步，安装Knative。我们将安装Knative版本0.8，这是撰写本书时可用的最新版本。
- en: 'We will use the `kubectl` CLI to apply the Knative components to the Kubernetes
    cluster. First, run the `kubectl apply` command with the `-l knative.dev/crd-install=true`
    flag to prevent race conditions during the installation process:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`kubectl` CLI将Knative组件应用到Kubernetes集群上。首先，运行`kubectl apply`命令，并使用`-l knative.dev/crd-install=true`标志来防止安装过程中的竞争条件：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, run the command again without the `-l knative.dev/crd-install=true` flag
    to complete the installation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，再次运行命令，不带`-l knative.dev/crd-install=true`标志来完成安装：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the command is completed, execute the following commands to check the
    status of the installation. Make sure that all pods have a status of **Running**:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令完成，执行以下命令来检查安装的状态。确保所有的pod都有**Running**的状态：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output should be as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![](image/C12607_06_06.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](image/C12607_06_06.jpg)'
- en: 'Figure 6.6: Verifying Knative installation'
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.6：验证Knative安装
- en: At this stage, you have set up a Kubernetes cluster on GKE and installed Knative.
    Now we are ready to deploy our first application on Knative.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，您已经在GKE上设置了一个Kubernetes集群并安装了Knative。现在我们准备在Knative上部署我们的第一个应用程序。
- en: 'Exercise 16: Deploying a Sample Application on Knative'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习16：在Knative上部署一个示例应用程序
- en: In the previous section, we successfully deployed Knative on top of Kubernetes
    and **Istio**. In this exercise, we will deploy our first application on the Knative
    framework. For this deployment, we are going to use a sample web application written
    with Node.js. A Docker image of this application is available in Google Container
    Registry at `gcr.io/knative-samples/helloworld-nodejs`. These steps can be adapted
    to deploy our own Docker image on Docker Hub or any other container registry.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们成功在Kubernetes和**Istio**之上部署了Knative。在这个练习中，我们将在Knative框架上部署我们的第一个应用程序。为了进行这次部署，我们将使用一个用Node.js编写的示例Web应用程序。这个应用程序的Docker镜像可以在Google容器注册表中找到，地址为`gcr.io/knative-samples/helloworld-nodejs`。这些步骤可以适应部署我们自己的Docker镜像到Docker
    Hub或任何其他容器注册表。
- en: This sample "hello world" application will read an environment variable named
    `TARGET` and print `Hello <VALUE_OF_TARGET>!` as the output. It will print `NOT
    SPECIFIED` as the output if no value is defined for the `TARGET` environment variable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的“hello world”应用程序将读取一个名为`TARGET`的环境变量，并打印`Hello <VALUE_OF_TARGET>!`作为输出。如果未为`TARGET`环境变量定义值，则它将打印`NOT
    SPECIFIED`作为输出。
- en: 'Let''s start by creating the service definition file for our application. This
    file defines application-related information including the application name and
    the application Docker image:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建应用程序的服务定义文件。这个文件定义了与应用程序相关的信息，包括应用程序名称和应用程序Docker镜像：
- en: Note
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Knative service objects and Kubernetes Service objects are two different types.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Knative服务对象和Kubernetes服务对象是两种不同的类型。
- en: 'Create a file named `hello-world.yaml` with the following content. This Knative
    service object defines values such as the namespace to deploy this service in,
    the Docker image to use for the container, and any environment variables:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`hello-world.yaml`的文件，其中包含以下内容。这个Knative服务对象定义了部署此服务的命名空间、用于容器的Docker镜像以及任何环境变量等数值：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once the `hello-world.yaml` file is ready, we can deploy our application with
    the `kubectl apply` command:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`hello-world.yaml`文件准备好，我们可以使用`kubectl apply`命令部署我们的应用程序：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output should be as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![ Figure 6.7: Deploying the helloworld-nodejs application'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7：部署helloworld-nodejs应用程序'
- en: '](image/C12607_06_07.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_07.jpg)'
- en: 'Figure 6.7: Deploying the helloworld-nodejs application'
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.7：部署helloworld-nodejs应用程序
- en: 'The previous command will create multiple objects, including the Knative service,
    configuration, revision, route, and Kubernetes Deployment. We can verify the application
    by listing the newly created objects as in the following commands:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一个命令将创建多个对象，包括Knative服务、配置、修订、路由和Kubernetes部署。我们可以通过列出新创建的对象来验证应用程序，就像以下命令一样：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output should be as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 6.8: Verifying helloworld-nodejs application deployment'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8：验证helloworld-nodejs应用程序部署'
- en: '](image/C12607_06_08.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_08.jpg)'
- en: 'Figure 6.8: Verifying helloworld-nodejs application deployment'
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.8：验证helloworld-nodejs应用程序部署
- en: 'Once our application is deployed successfully, we can invoke this application
    using an HTTP request. For this, we need to identify the external IP address of
    the Kubernetes cluster. Execute the following command to export the value of `EXTERNAL-IP`
    into an environment variable named `EXTERNAL_IP`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们的应用程序成功部署，我们可以使用HTTP请求调用这个应用程序。为此，我们需要确定Kubernetes集群的外部IP地址。执行以下命令将`EXTERNAL-IP`的值导出到名为`EXTERNAL_IP`的环境变量中：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output should be as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 6.9: Exporting the external IP of the istio-ingressgateway service'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9：导出istio-ingressgateway服务的外部IP'
- en: '](image/C12607_06_09.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_09.jpg)'
- en: 'Figure 6.9: Exporting the external IP of the istio-ingressgateway service'
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.9：导出istio-ingressgateway服务的外部IP
- en: Next, we need to find the host URL of the `helloworld-nodejs` application. Execute
    the following command and take note of the value of the **URL** column. This URL
    takes the form `http://<application-name>.<namespace>.example.com:`
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要找到`helloworld-nodejs`应用程序的主机URL。执行以下命令并注意**URL**列的值。此URL采用以下形式：`http://<application-name>.<namespace>.example.com:`
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output should be as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 6.10: Listing the helloworld-nodejs route'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.10：列出helloworld-nodejs路由'
- en: '](image/C12607_06_10.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_10.jpg)'
- en: 'Figure 6.10: Listing the helloworld-nodejs route'
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.10：列出helloworld-nodejs路由
- en: 'Now we can invoke our application using the `EXTERNAL_IP` and `URL` values
    that we noted in the earlier steps. Let''s make a `curl` request with the following
    command:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们在之前步骤中记录的`EXTERNAL_IP`和`URL`值来调用我们的应用程序。让我们使用以下命令进行`curl`请求：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output should be as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 6.11: Invoking the helloworld-nodejs application'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11：调用helloworld-nodejs应用程序'
- en: '](image/C12607_06_11.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_11.jpg)'
- en: 'Figure 6.11: Invoking the helloworld-nodejs application'
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.11：调用helloworld-nodejs应用程序
- en: You should receive the expected output as **Hello Knative NodeJS App!**. This
    indicates that we have successfully deployed and invoked our first application
    on the Knative platform.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该收到预期的输出为**Hello Knative NodeJS App!**。这表明我们已成功在Knative平台上部署和调用了我们的第一个应用程序。
- en: Knative Serving Component
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Knative服务组件
- en: 'In the previous section, we deployed our first Knative application using a
    YAML file of the service type. When deploying the service, it created multiple
    other objects, including configuration, revision, and route objects. In this section,
    let''s discuss each of these objects:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们使用服务类型的YAML文件部署了我们的第一个Knative应用程序。在部署服务时，它创建了多个其他对象，包括配置、修订和路由对象。在本节中，让我们讨论每个这些对象：
- en: 'There are four resource types in the Knative Serving component:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Knative服务组件中有四种资源类型：
- en: '**Configuration**: Defines the desired state of the application'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：定义应用程序的期望状态'
- en: '**Revision**: Read-only snapshots that track the changes in configurations'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修订**：只读快照，跟踪配置的更改'
- en: '**Route**: Provides traffic routing to revisions'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：提供到修订的流量路由'
- en: '**Service**: Top-level container for routes and configurations'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：路由和配置的顶层容器'
- en: 'The following diagram illustrates the relationship between each of these components:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了每个这些组件之间的关系：
- en: '![Figure 6.12: Relationship between Knative services, routes, configurations,
    and revisions'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.12：Knative服务、路由、配置和修订之间的关系'
- en: '](image/C12607_06_12.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_12.jpg)'
- en: 'Figure 6.12: Relationship between Knative services, routes, configurations,
    and revisions'
  id: totrans-131
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.12：Knative服务、路由、配置和修订之间的关系
- en: The **configuration** is used to define the desired state of the application.
    This will define the container image used for the application and any other configuration
    parameters that are required. A new **Revision** will be created each time a **Configuration**
    is updated. **Revision** refers to a snapshot of the code and the **Configuration**.
    This is used to record the history of **Configuration** changes. A **Route** is
    used to define the traffic routing policy of the application and provides an HTTP
    endpoint for the application. By default, the **Route** will send traffic to the
    latest **Revision** created by the **Configuration**. The **Route** can also be
    configured for more advanced scenarios, including sending traffic to a specific
    **Revision** or splitting traffic to different revisions based on defined percentages.
    **Service** objects are used to manage the whole life cycle of the application.
    While deploying a new application, it is required to create **Configuration**
    and **Route** objects manually, but the **Service** can be used to simplify this
    by creating and managing **Configuration** and **Route** objects automatically.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置**用于定义应用程序的期望状态。这将定义用于应用程序的容器映像和任何其他所需的配置参数。每次更新**配置**时都会创建一个新的**修订版**。**修订版**指的是代码和**配置**的快照。这用于记录**配置**更改的历史。**路由**用于定义应用程序的流量路由策略，并为应用程序提供HTTP端点。默认情况下，**路由**将流量发送到**配置**创建的最新**修订版**。**路由**还可以配置更高级的场景，包括将流量发送到特定的**修订版**或根据定义的百分比将流量分配到不同的修订版。**服务**对象用于管理应用程序的整个生命周期。在部署新应用程序时，需要手动创建**配置**和**路由**对象，但**服务**可以通过自动创建和管理**配置**和**路由**对象来简化这一过程。'
- en: In the following section, we will be using canary deployment to deploy applications
    with Knative. Let's first understand what exactly canary deployment is.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将使用金丝雀部署来部署Knative应用程序。让我们首先了解一下金丝雀部署到底是什么。
- en: Canary Deployment
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 金丝雀部署
- en: Canary deployment is a deployment strategy used when rolling out a new version
    of code to a production environment. This is a fail-safe process of deploying
    a new version of code into a production environment and switching a small percentage
    of traffic to the new version. This way, the development and deployment teams
    can verify the new version of the code with minimal impact on production traffic.
    Once the verifications are done, all traffic will be switched to the new version.
    In addition to canary deployments, there are several other deployment types, such
    as big bang deployments, rolling deployments, and blue-green deployments.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀部署是一种部署策略，用于在生产环境中推出新版本的代码。这是一种安全的部署新版本代码到生产环境并将一小部分流量切换到新版本的过程。这样，开发和部署团队可以在对生产流量影响最小的情况下验证新版本的代码。一旦验证完成，所有流量将切换到新版本。除了金丝雀部署之外，还有几种其他部署类型，例如大爆炸部署、滚动部署和蓝绿部署。
- en: In the `helloworld-nodejs` application that we deployed in *Exercise 16*, *Deploying
    a Sample App on Knative,* we used the Service object with the `spec.runLatest`
    field, which directs all traffic to the latest available revision. In the following
    exercise, we will be using separate configuration and route objects instead of
    the service object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在*练习16*中部署的`helloworld-nodejs`应用程序中，我们使用了带有`spec.runLatest`字段的服务对象，该字段将所有流量定向到最新可用的修订版。在接下来的练习中，我们将使用单独的配置和路由对象，而不是服务对象。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：
- en: For more information on canary deployment technique, refer to [https://dev.to/mostlyjason/intro-to-deployment-strategies-blue-green-canary-and-more-3a3](https://dev.to/mostlyjason/intro-to-deployment-strategies-blue-green-canary-and-more-3a3).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有关金丝雀部署技术的更多信息，请参阅[https://dev.to/mostlyjason/intro-to-deployment-strategies-blue-green-canary-and-more-3a3](https://dev.to/mostlyjason/intro-to-deployment-strategies-blue-green-canary-and-more-3a3)。
- en: 'Exercise 17: Canary Deployment with Knative'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习17：Knative的金丝雀部署
- en: In this exercise, we will be implementing a canary deployment strategy to deploy
    applications with Knative. First, we will deploy an initial version (version 1)
    of an application and route 100% traffic to that version. Next, we will create
    version 2 of the application and route 50% of traffic to version 1 and the remaining
    50% to version 2\. Finally, we will update the routes to send 100% of traffic
    to version 2.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实施金丝雀部署策略来部署Knative应用程序。首先，我们将部署应用程序的初始版本（版本1），并将100%的流量路由到该版本。接下来，我们将创建应用程序的第2个版本，并将50%的流量路由到版本1，剩下的50%路由到版本2。最后，我们将更新路由，将100%的流量发送到版本2。
- en: 'The following steps will help you complete the exercise:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成练习：
- en: 'First, start by creating the initial version (`v1`) of the application. Create
    a file named `canary-deployment.yaml` with the following content. This application
    uses the same Docker image (`gcr.io/knative-samples/helloworld-nodejs`) that we
    used previously and sets the `TARGET` environment variable as `This is the first
    version - v1`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从创建应用程序的初始版本（`v1`）开始。创建一个名为`canary-deployment.yaml`的文件，内容如下。这个应用程序使用与我们之前使用的相同的Docker镜像（`gcr.io/knative-samples/helloworld-nodejs`），并将`TARGET`环境变量设置为`This
    is the first version - v1`：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Deploy the first version of the application with the `kubectl apply` command
    using the YAML file created in the previous step:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在上一步中创建的YAML文件，使用`kubectl apply`命令部署应用程序的第一个版本：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output should be as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 6.13: Creating canary-deployment'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.13：创建金丝雀部署'
- en: '](image/C12607_06_13.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_13.jpg)'
- en: 'Figure 6.13: Creating canary-deployment'
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.13：创建金丝雀部署
- en: 'Let''s get the revision name created by this configuration as we need this
    value in the next step. Execute the `kubectl get configurations` command and retrieve
    the value of the `latestCreatedRevisionName` field:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们获取此配置创建的修订名称，因为我们在下一步中需要这个值。执行`kubectl get configurations`命令，并检索`latestCreatedRevisionName`字段的值：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output should be as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 6.14: Getting the latest revision of the canary-deployment configuration'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.14：获取金丝雀部署配置的最新修订版本'
- en: '](image/C12607_06_14.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_14.jpg)'
- en: 'Figure 6.14: Getting the latest revision of the canary-deployment configuration'
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.14：获取金丝雀部署配置的最新修订版本
- en: For me, the value returned from the preceding command is `canary-deployment-xgvl8`.
    Note that your value will be different.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，从前面的命令返回的值是`canary-deployment-xgvl8`。请注意，你的值将会不同。
- en: 'The next step is to create the route object. Let''s create a file named `canary-deployment-route.yaml`
    with the following content (please remember to replace `canary-deployment-xgvl8`
    with the revision name that you noted in the previous step). Under the `spec.traffic`
    section, you can see that 100% of traffic is routed to the revision that we created
    previously:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的步骤是创建路由对象。让我们创建一个名为`canary-deployment-route.yaml`的文件，内容如下（请记得用你在上一步中记录的修订名称替换`canary-deployment-xgvl8`）。在`spec.traffic`部分下，你可以看到100%的流量被路由到我们之前创建的修订版本：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the route object with the `kubectl apply` command:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl apply`命令创建路由对象：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output should be as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 6.15: Creating the canary-deployment route'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.15：创建金丝雀部署路由'
- en: '](image/C12607_06_15.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_15.jpg)'
- en: 'Figure 6.15: Creating the canary-deployment route'
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.15：创建canary-deployment路由
- en: 'Make a request to the application and observe the expected output of `Hello
    This is the first version - v1!`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对应用程序发出请求，并观察“Hello This is the first version - v1!”的预期输出：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output should be as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.16: Invoking canary-deployment'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.16：调用canary-deployment'
- en: '](image/C12607_06_16.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_16.jpg)'
- en: 'Figure 6.16: Invoking canary-deployment'
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.16：调用canary-deployment
- en: 'Once the application is successfully invoked, we can deploy version 2 of the
    application. Update `canary-deployment.yaml` with the following content. In version
    2 of the application, we only need to update the value of the `TARGET` environment
    variable from `This is the first version - v1` to `This is the second version
    - v2`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序成功调用，我们可以部署应用程序的第2个版本。使用以下内容更新“canary-deployment.yaml”。在应用程序的第2个版本中，我们只需要将“TARGET”环境变量的值从“This
    is the first version - v1”更新为“This is the second version - v2”：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Apply the updated configuration with `kubectl apply`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“kubectl apply”应用更新的配置：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output should be as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.17: Updating canary-deployment to version 2'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.17：将canary-deployment更新为版本2'
- en: '](image/C12607_06_17.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_17.jpg)'
- en: 'Figure 6.17: Updating canary-deployment to version 2'
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.17：将canary-deployment更新为版本2
- en: 'Now we can check the revisions created, while updating the configuration, using
    the `kubectl get revisions` command:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用“kubectl get revisions”命令检查创建的修订版本，同时更新配置：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output should be as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.18: Getting the revisions of canary-deployment'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.18：获取canary-deployment的修订版本'
- en: '](image/C12607_06_18.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_18.jpg)'
- en: 'Figure 6.18: Getting the revisions of canary-deployment'
  id: totrans-184
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.18：获取canary-deployment的修订版本
- en: 'Let''s get the latest revision created by the `canary-deployment` configuration:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们获取由“canary-deployment”配置创建的最新修订版本：
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output should be as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.19: Getting the latest revision of the canary-deployment configuration'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.19：获取canary-deployment配置的最新修订版本'
- en: '](image/C12607_06_19.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_19.jpg)'
- en: 'Figure 6.19: Getting the latest revision of the canary-deployment configuration'
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.19：获取canary-deployment配置的最新修订版本
- en: 'Now it''s time to send some traffic to our new version of the application.
    Update the `spec.traffic` section of `canary-deployment-route.yaml` to send 50%
    of the traffic to the old revision and 50% to the new revision:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候向我们应用程序的新版本发送一些流量了。更新“canary-deployment-route.yaml”的“spec.traffic”部分，将50%的流量发送到旧修订版本，50%发送到新修订版本：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Apply changes to the route using the following command:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令对路由进行更改：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output should be as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.20: Updating the canary-deployment route'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.20：更新canary-deployment路由'
- en: '](image/C12607_06_20.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_20.jpg)'
- en: 'Figure 6.20: Updating the canary-deployment route'
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.20：更新canary-deployment路由
- en: 'Now we can invoke the application multiple times to observe how traffic splits
    between two revisions:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以多次调用应用程序，观察流量如何在两个修订版本之间分配：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once we verify version 2 of the application successfully, we can update `canary-deployment-route.yaml`
    to route 100% of the traffic to the latest revision:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们成功验证了应用程序的第2个版本，我们可以将“canary-deployment-route.yaml”更新为将100%的流量路由到最新的修订版本：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Apply the changes to the route using the following command:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令对路由进行更改：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output should be as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.21: Updating the canary-deployment route'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.21：更新canary-deployment路由'
- en: '](image/C12607_06_21.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_21.jpg)'
- en: 'Figure 6.21: Updating the canary-deployment route'
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.21：更新canary-deployment路由
- en: 'Now invoke the application multiple times to verify that all traffic goes to
    version 2 of the application:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在多次调用应用程序，以验证所有流量都流向应用程序的第2个版本：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this exercise, we have successfully used configuration and route objects
    to perform a canary deployment with Knative.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们成功地使用配置和路由对象来执行Knative的金丝雀部署。
- en: Knative Monitoring
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Knative监控
- en: 'Knative comes with Grafana pre-installed, which is an open source metric analytics
    and visualization tool. The Grafana pod is available in the `knative-monitoring`
    namespace and can be listed with the following command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Knative预先安装了Grafana，这是一个开源的度量分析和可视化工具。Grafana pod可在`knative-monitoring`命名空间中找到，并且可以使用以下命令列出：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output should be as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 6.22: Listing the Grafana pod'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.22：列出Grafana pod'
- en: '](image/C12607_06_22.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_22.jpg)'
- en: 'Figure 6.22: Listing the Grafana pod'
  id: totrans-218
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.22：列出Grafana pod
- en: 'We can expose the Grafana UI with the `kubectl port-forward` command, which
    will forward local port `3000` to the port `3000` of the Grafana pod. Open a new
    terminal and execute the following command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`kubectl port-forward`命令暴露Grafana UI，该命令将本地端口`3000`转发到Grafana pod的端口`3000`。打开一个新的终端并执行以下命令：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output should be as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![](image/C12607_06_23.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](image/C12607_06_23.jpg)'
- en: 'Figure 6.23: Port forwarding to the Grafana pod'
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.23：将端口转发到Grafana pod
- en: Now we can navigate the Grafana UI from our web browser on `http://127.0.0.1:3000`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从我们的网络浏览器上的`http://127.0.0.1:3000`导航到Grafana UI。
- en: 'The output should be as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 6.24: The Grafana UI'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.24：Grafana UI'
- en: '](image/C12607_06_24.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_24.jpg)'
- en: 'Figure 6.24: The Grafana UI'
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.24：Grafana UI
- en: 'Knative''s Grafana dashboard comes with multiple dashboards, including the
    following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Knative的Grafana仪表板带有多个仪表板，包括以下内容：
- en: '![Figure 6.25: Dashboards'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.25：仪表板'
- en: '](image/C12607_06_25.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_25.jpg)'
- en: 'Figure 6.25: Dashboards'
  id: totrans-232
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.25：仪表板
- en: Knative Autoscaler
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Knative自动缩放器
- en: Knative has a built-in autoscaling feature that automatically scales the application
    pods based on the number of HTTP requests it receives. This will increase the
    pod count when there is increased demand and decrease the pod count when the demand
    decreases. The pod count will scale to zero when pods are idle and there are no
    incoming requests.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Knative具有内置的自动缩放功能，根据接收到的HTTP请求的数量自动调整应用程序pod的数量。当需求增加时，它将增加pod数量，当需求减少时，它将减少pod数量。当pod处于空闲状态且没有传入请求时，pod数量将缩减为零。
- en: 'Knative uses two components, the autoscaler, and the activator, to achieve
    the previously mentioned functionality. These components are deployed as pods
    in the `knative-serving` namespace, as you can see in the following snippet:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Knative使用两个组件，自动缩放器和激活器，来实现前面提到的功能。这些组件部署为`knative-serving`命名空间中的pod，如下面的代码片段所示：
- en: '[PRE31]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The activator component is responsible for collecting information about the
    number of concurrent requests to a revision and reporting these values to the
    autoscaler. The autoscaler component will increase or decrease the number of pods
    based on the metrics reported by the activator. By default, the autoscaler will
    try to maintain 100 concurrent requests per pod by scaling pods up or down. All
    Knative autoscaler-related configurations are stored in a configuration map named
    `config-autoscaler` in the `knative-serving` namespace. Knative can also be configured
    to use the **Horizontal Pod Autoscaler** (**HPA**), which is provided by Kubernetes.
    HPA will autoscale pods based on CPU usage.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 激活器组件负责收集有关修订版的并发请求数量的信息，并将这些值报告给自动缩放器。自动缩放器组件将根据激活器报告的指标增加或减少pod的数量。默认情况下，自动缩放器将尝试通过扩展或缩减pod来维持每个pod的100个并发请求。所有Knative与自动缩放器相关的配置都存储在`knative-serving`命名空间中名为`config-autoscaler`的配置映射中。Knative还可以配置为使用Kubernetes提供的**水平Pod自动缩放器**（**HPA**），HPA将根据CPU使用情况自动调整pod的数量。
- en: 'Exercise 18: Autoscaling with Knative'
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习18：使用Knative进行自动缩放
- en: 'In this exercise, we will perform Knative pod autoscaling by deploying a sample
    application:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过部署一个示例应用程序来执行Knative pod自动缩放：
- en: 'Create an `autoscale-app.yaml` service definition file with the following content.
    This file defines a service named `autoscale-app`, which will use the `gcr.io/knative-samples/autoscale-go:0.1`
    sample Docker image. `autoscaling.knative.dev/target` is used to configure the
    target number of concurrent requests per pod:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`autoscale-app.yaml`的服务定义文件，内容如下。该文件定义了一个名为`autoscale-app`的服务，该服务将使用`gcr.io/knative-samples/autoscale-go:0.1`示例Docker镜像。`autoscaling.knative.dev/target`用于配置每个pod的目标并发请求数量：
- en: '[PRE32]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Apply the service definition with the `kubectl apply` command:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl apply`命令应用服务定义：
- en: '[PRE33]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output should be as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.26: Creating autoscale-app'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.26：创建autoscale-app'
- en: '](image/C12607_06_26.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_26.jpg)'
- en: 'Figure 6.26: Creating autoscale-app'
  id: totrans-247
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.26：创建autoscale-app
- en: Once the application is ready, we can generate a load to the **autoscale-app**
    application to observe the autoscaling. For this, we will use a load generator
    named `hey`. Download the `hey` binary using the following `curl` command.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序准备就绪，我们可以生成一个负载到**autoscale-app**应用程序以观察自动缩放。为此，我们将使用一个名为`hey`的负载生成器。使用以下`curl`命令下载`hey`二进制文件。
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output should be as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.27: Installing hey'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.27：安装hey'
- en: '](image/C12607_06_27.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_27.jpg)'
- en: 'Figure 6.27: Installing hey'
  id: totrans-253
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.27：安装hey
- en: 'Add execution permission to the `hey` binary and move it into the `/usr/local/bin/`
    path:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`hey`二进制文件添加执行权限，并将其移动到`/usr/local/bin/`路径中：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output should be as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.28: Moving hey to /usr/local/bin'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.28：将hey移动到/usr/local/bin'
- en: '](image/C12607_06_28.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_28.jpg)'
- en: 'Figure 6.28: Moving hey to /usr/local/bin'
  id: totrans-259
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.28：将hey移动到/usr/local/bin
- en: 'Now we are ready to generate a load with the `hey` tool. The `hey` tool supports
    multiple options when generating a load. For this scenario, we will use a load
    with a concurrency of 50 (with the `-c flag`) for a duration of 60 seconds (with
    the `-z flag`):'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备使用`hey`工具生成负载。`hey`工具在生成负载时支持多个选项。对于这种情况，我们将使用并发数为50（使用`-c`标志）持续60秒（使用`-z`标志）的负载：
- en: '[PRE36]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In a separate terminal, watch for the number of pods created during the load:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单独的终端中，观察负载期间创建的pod数量：
- en: '[PRE37]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You will see output similar to the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似以下的输出：
- en: '[PRE38]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Open the **Knative Serving - Scaling Debugging** dashboard from Grafana to
    observe how autoscaling increased the pod count during the load and decreased
    the pod count back to zero once the load stopped, as you can see in the following
    screenshots:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Grafana中的**Knative Serving - Scaling Debugging**仪表板，观察自动缩放如何在负载期间增加了pod数量，并在负载停止后将pod数量减少到零，如下面的截图所示：
- en: '![Figure 6.29: Revision pod count metrics'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.29：修订pod计数指标'
- en: '](image/C12607_06_29.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_29.jpg)'
- en: 'Figure 6.29: Revision pod count metrics'
  id: totrans-269
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.29：修订pod计数指标
- en: '![Figure 6.30: Observed concurrency metrics'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.30：观察并发度指标'
- en: '](image/C12607_06_30.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_30.jpg)'
- en: 'Figure 6.30: Observed concurrency metrics'
  id: totrans-272
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.30：观察并发度指标
- en: We have successfully configured Knative's autoscaler and observed autoscaling
    with the Grafana dashboard.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功配置了Knative的自动缩放器，并通过Grafana仪表板观察到了自动缩放。
- en: Google Cloud Run
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Google Cloud Run
- en: In the previous sections, we discussed Knative. We learned how to install Istio
    and Knative on top of a Kubernetes cluster and how to run Docker images with Knative.
    But the advantages of the Knative platform come with the operational overhead
    of managing the underlying Kubernetes cluster with Istio. GKE, which is the managed
    Kubernetes service from Google Cloud, will help us manage the Kubernetes master
    components, but still, we have to manage all the Kubernetes nodes ourselves.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们讨论了Knative。我们学习了如何在Kubernetes集群上安装Istio和Knative，以及如何使用Knative运行Docker镜像。但是Knative平台的优势伴随着管理底层Kubernetes集群和Istio的运营开销。来自Google
    Cloud的托管Kubernetes服务GKE将帮助我们管理Kubernetes主控组件，但是我们仍然必须自己管理所有的Kubernetes节点。
- en: In order to abstract away all the infrastructure management tasks from the developer,
    Google introduced a new service named Cloud Run. This is a fully managed platform,
    built on the Knative project, to run stateless HTTP-driven containers. Cloud Run
    offers the same set of features as Knative, including autoscaling, scale to zero,
    versioning, and events. Cloud Run was introduced in the Google Cloud Next '19
    conference as the newest member of Google Cloud's serverless compute stack. At
    the time of writing this book, the Cloud Run service is still in beta and only
    available in a limited number of regions.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将开发人员的所有基础设施管理任务抽象出来，Google推出了一个名为Cloud Run的新服务。这是一个完全托管的平台，建立在Knative项目之上，用于运行无状态的HTTP驱动容器。Cloud
    Run提供与Knative相同的功能集，包括自动缩放、零缩放、版本控制和事件。Cloud Run在Google Cloud Next '19大会上作为Google
    Cloud无服务器计算堆栈的最新成员推出。在撰写本书时，Cloud Run服务仍处于测试阶段，仅在有限数量的地区提供。
- en: Let's now perform an exercise to deploy containers on Google Cloud Run.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进行一个练习，在Google Cloud Run上部署容器。
- en: 'Exercise 19: Deploying Containers on Google Cloud Run'
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习19：在Google Cloud Run上部署容器
- en: In this exercise, we will be deploying a pre-built Docker image on the Google
    Cloud Run platform.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在Google Cloud Run平台上部署一个预构建的Docker镜像。
- en: 'The following steps will help you complete the exercise:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成练习：
- en: 'Navigate to your GCP console from your browser and select **Cloud Run** from
    the menu (in the **Compute** category) as shown in the following figure:![Figure
    6.31: GCP menu for Cloud Run'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从浏览器导航到您的GCP控制台，并从菜单中选择**Cloud Run**（在**计算**类别中），如下图所示：![图6.31：Cloud Run的GCP菜单
- en: '](image/C12607_06_31.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_31.jpg)'
- en: 'Figure 6.31: GCP menu for Cloud Run'
  id: totrans-283
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.31：Cloud Run的GCP菜单
- en: Click on the **CREATE SERVICE** button to create a new service.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**创建服务**按钮以创建新服务。
- en: 'Fill the create service form with the following values:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下值填写创建服务表单：
- en: 'Container Image URL: [gcr.io/knative-samples/helloworld-nodejs](http://gcr.io/knative-samples/helloworld-nodejs)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像URL：[gcr.io/knative-samples/helloworld-nodejs](http://gcr.io/knative-samples/helloworld-nodejs)
- en: 'Deployment platform: **Cloud Run** (fully managed)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 部署平台：**Cloud Run**（完全托管）
- en: 'Location: Select any region you prefer from the options'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 位置：从选项中选择任何您喜欢的地区
- en: 'Service name: **hello-world**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 服务名称：**hello-world**
- en: 'Authentication: **Allow unauthenticated invocations**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证：**允许未经身份验证的调用**
- en: '![Figure 6.32: Cloud Run create service form'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.32：Cloud Run创建服务表单'
- en: '](image/C12607_06_32.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_32.jpg)'
- en: 'Figure 6.32: Cloud Run create service form'
  id: totrans-293
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.32：Cloud Run创建服务表单
- en: Click on the **CREATE** button.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**创建**按钮。
- en: 'Now we will be redirected to the deployed service page, which includes details
    about the newly deployed **hello-world** service. We can see that a revision has
    been created called **hello-world-00001**, as shown in the following figure:![Figure
    6.33: Service details page'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将被重定向到部署的服务页面，其中包括关于新部署的**hello-world**服务的详细信息。我们可以看到已创建一个名为**hello-world-00001**的修订版本，如下图所示：![图6.33：服务详细信息页面
- en: '](image/C12607_06_33.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_33.jpg)'
- en: 'Figure 6.33: Service details page'
  id: totrans-297
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.33：服务详细信息页面
- en: 'Click on the URL link displayed to run the container. Note that the URL will
    be different for every new instance:![Figure 6.34: Invoking the hello-world app'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击显示的URL链接来运行容器。请注意，每个新实例的URL都会有所不同：![图6.34：调用hello-world应用程序
- en: '](image/C12607_06_34.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_34.jpg)'
- en: 'Figure 6.34: Invoking the hello-world app'
  id: totrans-300
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.34：调用hello-world应用程序
- en: Next, we are going to deploy a new revision of the application by updating the
    **TARGET** environment variable. Navigate back to the **GCP** console and click
    on the **DEPLOY NEW REVISION** button.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过更新**TARGET**环境变量来部署应用程序的新修订版。返回**GCP**控制台，点击**部署新修订版**按钮。
- en: 'From the **Deploy revision to hello-world (us-central1)** form, click on the
    **SHOW OPTIONAL REVISION SETTINGS** link, which will point us to the additional
    setting section:![Figure 6.35: Optional revision settings'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**部署修订版到hello-world（us-central1）**表单中，点击**显示可选修订设置**链接，这将指向我们到附加设置部分：![图6.35：可选修订设置
- en: '](image/C12607_06_35.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_35.jpg)'
- en: 'Figure 6.35: Optional revision settings'
  id: totrans-304
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.35：可选修订设置
- en: 'Under the environment variables section, create a new environment variable
    named `TARGET` with the value `Cloud Run Deployment`:![Figure 6.36: Setting the
    TARGET environment variable'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在环境变量部分，创建一个名为`TARGET`的新环境变量，值为`Cloud Run Deployment`：![图6.36：设置TARGET环境变量
- en: '](image/C12607_06_36.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_36.jpg)'
- en: 'Figure 6.36: Setting the TARGET environment variable'
  id: totrans-307
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.36：设置TARGET环境变量
- en: Click on the **DEPLOY** button.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**部署**按钮。
- en: 'Now we can see the new revision of the **hello-world** application called `hello-world-00002`
    with 100% of traffic being routed to the latest revision:![Figure 6.37: The hello-world
    app''s new revision'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以看到**hello-world**应用程序的新修订版名为`hello-world-00002`，100%的流量被路由到最新的修订版：![图6.37：hello-world应用程序的新修订版
- en: '](image/C12607_06_37.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_37.jpg)'
- en: 'Figure 6.37: The hello-world app''s new revision'
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.37：hello-world应用程序的新修订版
- en: 'Click on the URL again to run the updated revision:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击URL来运行更新的修订版：
- en: '![Figure 6.38: Invoking the hello-world app'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.38：调用hello-world应用程序'
- en: '](image/C12607_06_38.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_38.jpg)'
- en: 'Figure 6.38: Invoking the hello-world app'
  id: totrans-315
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.38：调用hello-world应用程序
- en: We have successfully deployed a pre-built Docker image on the Google Cloud Run
    platform.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功在Google Cloud Run平台上部署了预构建的Docker镜像。
- en: Introduction to Virtual Kubelet
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Virtual Kubelet
- en: Virtual Kubelet is an open source implementation of Kubernetes' kubelet that
    acts as a kubelet. This is a sandbox project from the **Cloud Native Computing
    Foundation** (**CNCF**), and the first major version (v 1.0) of Virtual Kubelet
    was released on July 8, 2019.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Virtual Kubelet是Kubernetes kubelet的开源实现，充当kubelet。这是来自**Cloud Native Computing
    Foundation**（**CNCF**）的沙箱项目，Virtual Kubelet的第一个主要版本（v 1.0）于2019年7月8日发布。
- en: Before diving further into Virtual Kubelet, let's recap what a kubelet is in
    the Kubernetes architecture. A kubelet is an agent that runs on each node in a
    Kubernetes cluster and is responsible for managing pods within the nodes. A kubelet
    takes instructions from the Kubernetes API to identify the pods to be scheduled
    on the node and interacts with the underlying container runtime (for example,
    Docker) of the nodes to ensure that the desired number of pods are running and
    that they are healthy.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步深入Virtual Kubelet之前，让我们回顾一下Kubernetes架构中的kubelet是什么。kubelet是在Kubernetes集群中每个节点上运行的代理，负责管理节点内的pod。kubelet从Kubernetes
    API接收指令，以识别要在节点上调度的pod，并与节点的底层容器运行时（例如Docker）交互，以确保所需数量的pod正在运行并且它们是健康的。
- en: 'In addition to managing pods, the kubelet performs several other tasks:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 除了管理pod外，kubelet还执行几项其他任务：
- en: Updating the Kubernetes API with the current status of the pods
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新Kubernetes API与pod的当前状态
- en: Monitoring and reporting node health metrics such as CPU, memory, and disk utilization
    to the Kubernetes master
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控和报告节点的健康指标，如CPU、内存和磁盘利用率，到Kubernetes主节点
- en: Pulling Docker images from the Docker registry for the assigned pods
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Docker注册表中拉取分配的pod的Docker镜像
- en: Creating and mounting volumes for pods
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为pod创建和挂载卷
- en: Providing an interface for the API server to execute commands such as `kubectl
    logs`, `kubectl exec`, and `kubectl attach` for the pods
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为API服务器提供一个接口，以执行诸如`kubectl logs`、`kubectl exec`和`kubectl attach`等命令，用于pod
- en: 'The following figure displays a Kubernetes cluster with standard and virtual
    kubelets:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了一个具有标准和虚拟kubelet的Kubernetes集群：
- en: '![Figure 6.39: Kubernetes cluster with standard kubelets and Virtual Kubelets'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.39：具有标准kubelet和虚拟kubelet的Kubernetes集群'
- en: '](image/C12607_06_39.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_39.jpg)'
- en: 'Figure 6.39: Kubernetes cluster with standard kubelets and Virtual Kubelets'
  id: totrans-329
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.39：具有标准kubelet和虚拟kubelet的Kubernetes集群
- en: 'Virtual Kubelet will appear as a traditional kubelet from the viewpoint of
    the Kubernetes API. This will run in the existing Kubernetes cluster and register
    itself as a node within the Kubernetes API. Virtual Kubelet will run and manage
    the pods in the same way a kubelet does. But in contrast to the kubelet, which
    runs pods within the nodes, Virtual Kubelet will utilize external services to
    run the pods. This connects the Kubernetes cluster to other services such as serverless
    container platforms. Virtual Kubelet supports a growing number of providers, including
    the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 从Kubernetes API的视角来看，Virtual Kubelet将会像传统的kubelet一样。它将在现有的Kubernetes集群中运行，并在Kubernetes
    API中注册自己为一个节点。Virtual Kubelet将以与kubelet相同的方式运行和管理pod。但与在节点内运行pod的kubelet相反，Virtual
    Kubelet将利用外部服务来运行pod。这将把Kubernetes集群连接到其他服务，如无服务器容器平台。Virtual Kubelet支持越来越多的提供者，包括以下：
- en: Alibaba Cloud **Elastic Container Instance** (**ECI**)
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阿里巴巴云弹性容器实例（ECI）
- en: AWS Fargate
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Fargate
- en: Azure Batch
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Batch
- en: '**Azure Container Instances** (**ACI**)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure容器实例（ACI）
- en: Kubernetes **Container Runtime Interface** (**CRI**)
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes容器运行时接口（CRI）
- en: Huawei **Cloud Container Instance** (**CCI**)
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 华为云容器实例（CCI）
- en: HashiCorp Nomad
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HashiCorp Nomad
- en: OpenStack Zun
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenStack Zun
- en: Running pods on these platforms come with the benefits of the serverless world.
    We do not have to worry about the infrastructure as it is managed by the cloud
    provider. Pods will scale up and down automatically based on the number of requests
    received. Also, we have to pay only for the utilized resources.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些平台上运行pod带来了无服务器世界的好处。我们不必担心基础架构，因为它由云提供商管理。Pod将根据收到的请求数量自动扩展和缩减。此外，我们只需为使用的资源付费。
- en: 'Exercise 20: Deploying Virtual Kubelet on AKS'
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习20：在AKS上部署Virtual Kubelet
- en: In this exercise, we are going to configure Virtual Kubelet on **Azure Kubernetes
    Service** (**AKS**) with the ACI provider. For this exercise, we will be using
    the following services available in Azure.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在Azure Kubernetes Service（AKS）上配置Virtual Kubelet，并使用ACI提供程序。在这个练习中，我们将使用Azure中提供的以下服务。
- en: 'AKS: AKS is a managed Kubernetes service on Azure.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AKS：AKS是Azure上的托管Kubernetes服务。
- en: 'ACI: ACI provides a managed service for running containers on Azure.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACI：ACI提供了在Azure上运行容器的托管服务。
- en: 'Azure Cloud Shell: An interactive, browser-based shell that supports both Bash
    and PowerShell.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Cloud Shell：一个交互式的基于浏览器的shell，支持Bash和PowerShell。
- en: 'You need to have the following prerequisites for this exercise:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要具备以下先决条件才能进行这个练习：
- en: A Microsoft Azure account
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Azure账户
- en: The Azure CLI
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure CLI
- en: The kubectl CLI
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl CLI
- en: Helm
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm
- en: 'We will be using Azure Cloud Shell, which has all the previously mentioned
    CLIs pre-installed:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Azure Cloud Shell，其中预先安装了所有先前提到的CLI：
- en: 'Navigate to [https://shell.azure.com/](https://shell.azure.com/) to open Cloud
    Shell in a browser window. Select **Bash** from the **Welcome to Azure Cloud Shell**
    window:![Figure 6.40: The Welcome to Azure Cloud Shell window'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[https://shell.azure.com/](https://shell.azure.com/)在浏览器窗口中打开Cloud Shell。从“欢迎使用Azure
    Cloud Shell”窗口中选择**Bash**：![图6.40：欢迎使用Azure Cloud Shell窗口
- en: '](image/C12607_06_40.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_40.jpg)'
- en: 'Figure 6.40: The Welcome to Azure Cloud Shell window'
  id: totrans-353
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.40：欢迎使用Azure Cloud Shell窗口
- en: 'Click on the **Create storage** button to create a storage account for Cloud
    Shell. Note that this is a one-time task purely for when we are using Cloud Shell
    for the first time:![Figure 6.41: Mounting storage for Cloud Shell'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“创建存储”按钮以为Cloud Shell创建存储账户。请注意，这是一个一次性任务，仅在我们第一次使用Cloud Shell时需要执行：![图6.41：为Cloud
    Shell挂载存储
- en: '](image/C12607_06_41.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_41.jpg)'
- en: 'Figure 6.41: Mounting storage for Cloud Shell'
  id: totrans-356
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.41：为Cloud Shell挂载存储
- en: 'The Cloud Shell window will look as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Shell窗口将如下所示：
- en: '![Figure 6.42: Cloud Shell window'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.42：Cloud Shell窗口'
- en: '](image/C12607_06_42.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_42.jpg)'
- en: 'Figure 6.42: Cloud Shell window'
  id: totrans-360
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.42：Cloud Shell窗口
- en: Once Cloud Shell is ready, we can start creating the AKS cluster.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Cloud Shell准备就绪，我们就可以开始创建AKS集群。
- en: 'First, we need to create an Azure resource group that allows us to group related
    Azure resources logically. Execute the following command to create a resource
    group named `serverless-kubernetes-group` in the West US (`westus`) region:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个Azure资源组，以便逻辑上将相关的Azure资源分组。执行以下命令，在West US（`westus`）地区创建一个名为`serverless-kubernetes-group`的资源组：
- en: '[PRE39]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output should be as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 6.43: Creating an Azure resource group'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.43：创建Azure资源组'
- en: '](image/C12607_06_43.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_43.jpg)'
- en: 'Figure 6.43: Creating an Azure resource group'
  id: totrans-367
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.43：创建Azure资源组
- en: 'Register your subscription to use the `Microsoft.Network` namespace:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册您的订阅以使用`Microsoft.Network`命名空间：
- en: '[PRE40]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output should be as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 6.44: Registering the subscription'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.44：注册订阅'
- en: '](image/C12607_06_44.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_44.jpg)'
- en: 'Figure 6.44: Registering the subscription'
  id: totrans-373
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.44：注册订阅
- en: 'Next, we will create an Azure Kubernetes cluster. The following command will
    create an AKS cluster named `virtual-kubelet-cluster` with one node. This command
    will take a few minutes to execute:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个Azure Kubernetes集群。以下命令将创建一个名为`virtual-kubelet-cluster`的AKS集群，其中包含一个节点。此命令将需要几分钟来执行：
- en: '[PRE41]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once AKS cluster creation is successful, the preceding command will return
    some JSON output with the details of the cluster:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: AKS集群创建成功后，上述命令将返回一些JSON输出，其中包含集群的详细信息：
- en: '![Figure 6.45: Creating the AKS cluster'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.45：创建AKS集群'
- en: '](image/C12607_06_45.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_45.jpg)'
- en: 'Figure 6.45: Creating the AKS cluster'
  id: totrans-379
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.45：创建AKS集群
- en: 'Next, we need to configure the kubectl CLI to communicate with the newly created
    AKS cluster. Execute the `az aks get-credentials` command to download the credentials
    and configure the kubectl CLI to work with the `virtual-kubelet-cluster` cluster
    with the following command:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置kubectl CLI以与新创建的AKS集群通信。执行`az aks get-credentials`命令来下载凭据并配置kubectl
    CLI以与`virtual-kubelet-cluster`集群一起工作的命令如下：
- en: Note
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We are not required to install the kubectl CLI because Cloud Shell comes with
    kubectl pre-installed.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要安装kubectl CLI，因为Cloud Shell已经预装了kubectl。
- en: '[PRE42]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output should be as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 6.46: Configuring kubectl'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.46：配置kubectl'
- en: '](image/C12607_06_46.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_46.jpg)'
- en: 'Figure 6.46: Configuring kubectl'
  id: totrans-387
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.46：配置kubectl
- en: 'Now we can verify the connection to the cluster from Cloud Shell by executing
    the `kubectl get nodes` command, which will list the nodes available in the AKS
    cluster:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过执行 `kubectl get nodes` 命令来验证从 Cloud Shell 到集群的连接，该命令将列出 AKS 集群中可用的节点：
- en: '[PRE43]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output should be as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.47: Listing Kubernetes nodes'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.47：列出 Kubernetes 节点'
- en: '](image/C12607_06_47.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_47.jpg)'
- en: 'Figure 6.47: Listing Kubernetes nodes'
  id: totrans-393
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.47：列出 Kubernetes 节点
- en: 'If this is the first time you are using the ACI service, you need to register
    the `Microsoft.ContainerInstance` provider with your subscription. We can check
    the registration state of the `Microsoft.ContainerInstance` provider with the
    following command:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这是您第一次使用 ACI 服务，您需要在订阅中注册 `Microsoft.ContainerInstance` 提供程序。我们可以使用以下命令检查
    `Microsoft.ContainerInstance` 提供程序的注册状态：
- en: '[PRE44]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output should be as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.48: Checking the registration status of the Microsoft.ContainerInstace
    provider'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.48：检查 Microsoft.ContainerInstace 提供程序的注册状态'
- en: '](image/C12607_06_48.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_48.jpg)'
- en: 'Figure 6.48: Checking the registration status of the Microsoft.ContainerInstace
    provider'
  id: totrans-399
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.48：检查 Microsoft.ContainerInstace 提供程序的注册状态
- en: 'If the **RegistrationStatus** column contains a value of **NotRegistered**,
    execute the `az provider register` command to register the `Microsoft.ContainerInstance`
    provider. If the **RegistrationStatus** column contains a value of **Registered**,
    you can continue to the next step:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 **RegistrationStatus** 列包含值 **NotRegistered**，则执行 `az provider register`
    命令来注册 `Microsoft.ContainerInstance` 提供程序。如果 **RegistrationStatus** 列包含值 **Registered**，则可以继续下一步：
- en: '[PRE45]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output should be as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.49: Registering for Microsoft.ContainerInstance provider'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.49：注册 Microsoft.ContainerInstance 提供程序'
- en: '](image/C12607_06_49.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_49.jpg)'
- en: 'Figure 6.49: Registering for Microsoft.ContainerInstance provider'
  id: totrans-405
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.49：注册 Microsoft.ContainerInstance 提供程序
- en: 'The next step is to create the necessary `ServiceAccount` and `ServiceAccount`
    objects for the tiller. Create a file named `tiller-rbac.yaml` with the following
    code:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是为 tiller 创建必要的 `ServiceAccount` 和 `ServiceAccount` 对象。创建一个名为 `tiller-rbac.yaml`
    的文件，其中包含以下代码：
- en: '[PRE46]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then execute the `kubectl apply` command to create the necessary `ServiceAccount`
    and `ClusterRoleBinding` objects:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后执行 `kubectl apply` 命令来创建必要的 `ServiceAccount` 和 `ClusterRoleBinding` 对象：
- en: '[PRE47]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output should be as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.50: Creating the ServiceAccount and ClusterRoleBinding objects'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.50：创建 ServiceAccount 和 ClusterRoleBinding 对象'
- en: '](image/C12607_06_50.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_50.jpg)'
- en: 'Figure 6.50: Creating the ServiceAccount and ClusterRoleBinding objects'
  id: totrans-413
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.50：创建 ServiceAccount 和 ClusterRoleBinding 对象
- en: 'Now we can configure Helm to use the tiller service account that we created
    in the previous step:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以配置 Helm 使用我们在上一步中创建的 tiller 服务账户：
- en: '[PRE48]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output should be as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.51: Configuring tiller'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.51：配置 tiller'
- en: '](image/C12607_06_51.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_51.jpg)'
- en: 'Figure 6.51: Configuring tiller'
  id: totrans-419
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.51：配置 tiller
- en: 'Once all configurations are done, we can install Virtual Kubelet using the
    `az aks install-connector` command. We will be deploying both Linux and Windows
    connectors with the following command:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有配置都完成，我们可以使用 `az aks install-connector` 命令安装虚拟 Kubelet。我们将使用以下命令部署 Linux
    和 Windows 连接器：
- en: '[PRE49]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output should be as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.52: Installing Virtual Kubelet'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.52：安装虚拟 Kubelet'
- en: '](image/C12607_06_52.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_52.jpg)'
- en: 'Figure 6.52: Installing Virtual Kubelet'
  id: totrans-425
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.52：安装虚拟 Kubelet
- en: 'Once the installation is complete, we can verify it by listing the Kubernetes
    nodes. There will be two new nodes, one for Windows and one for Linux:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以通过列出 Kubernetes 节点来验证它。将会有两个新节点，一个用于 Windows，一个用于 Linux：
- en: '[PRE50]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output should be as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.53: Listing Kubernetes nodes'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.53：列出Kubernetes节点'
- en: '](image/C12607_06_53.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_53.jpg)'
- en: 'Figure 6.53: Listing Kubernetes nodes'
  id: totrans-431
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.53：列出Kubernetes节点
- en: Now we have Virtual Kubelet installed in the AKS cluster. We can deploy an application
    to a new node introduced by Virtual Kubelet. We will be creating a Kubernetes
    Deployment named `hello-world` with the `microsoft/aci-helloworld` Docker image.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经在AKS集群中安装了Virtual Kubelet。我们可以将一个应用程序部署到Virtual Kubelet引入的新节点上。我们将创建一个名为`hello-world`的Kubernetes
    Deployment，使用`microsoft/aci-helloworld` Docker镜像。
- en: We need to add a **nodeSelector** to assign this pod specifically to the Virtual
    Kubelet node. Note that Virtual Kubelet nodes are tainted by default to prevent
    unexpected pods from being run on them. We need to add tolerations to the pods
    to allow them to be scheduled for these nodes.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个**nodeSelector**，将此pod专门分配给Virtual Kubelet节点。请注意，Virtual Kubelet节点默认会被标记，以防止意外的pod在其上运行。我们需要为pod添加tolerations，以允许它们被调度到这些节点上。
- en: 'Let''s create a file named `hello-world.yaml` with the following content:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`hello-world.yaml`的文件，内容如下：
- en: '[PRE51]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Deploy the `hello-world` application with the `kubectl apply` command:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl apply`命令部署`hello-world`应用程序：
- en: '[PRE52]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output should be as follows:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.54: Creating the hello-world deployment'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.54：创建hello-world部署'
- en: '](image/C12607_06_54.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_54.jpg)'
- en: 'Figure 6.54: Creating the hello-world deployment'
  id: totrans-441
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.54：创建hello-world部署
- en: 'Execute the `kubectl get pods` command with the `-o wide` flag to output a
    list of pods and their respective nodes. Note that the `hello-world-57f597bc59-q9w9k`
    pod has been scheduled on the `virtual-kubelet-virtual-kubelet-linux-westus` node:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl get pods`命令和`-o wide`标志执行，以输出一个包含各个pod及其相应节点的列表。请注意，`hello-world-57f597bc59-q9w9k`
    pod已被调度到`virtual-kubelet-virtual-kubelet-linux-westus`节点上：
- en: '[PRE53]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output should be as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.55: Listing all pods with the -o wide flag'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.55：使用-o wide标志列出所有pod'
- en: '](image/C12607_06_55.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_55.jpg)'
- en: 'Figure 6.55: Listing all pods with the -o wide flag'
  id: totrans-447
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.55：使用-o wide标志列出所有pod
- en: Thus, we have successfully configured Virtual Kubelet on AKS with ACI and have
    deployed a pod in the Virtual Kubelet node.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已成功在AKS上配置了带有ACI的Virtual Kubelet，并在Virtual Kubelet节点上部署了一个pod。
- en: Let's now complete an activity where we will be deploying a containerized application
    in a serverless environment.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们完成一个活动，我们将在无服务器环境中部署一个容器化应用程序。
- en: 'Activity 6: Deploy a Containerized Application in a Serverless Environment'
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动6：在无服务器环境中部署容器化应用程序
- en: Imagine that you are working for a start-up company and your manager wants you
    to create an application that can return the current date and time for a given
    timezone. This application is expected to receive only a few requests during the
    initial phase but will receive millions of requests in the long run. The application
    should be able to scale automatically based on the number of requests received
    without any modifications. Also, your manager does not want to have the burden
    of managing the infrastructure and expects this application to run with the lowest
    possible cost.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在一家初创公司工作，你的经理希望你创建一个可以根据给定时区返回当前日期和时间的应用程序。在初始阶段，预计该应用程序只会收到少量请求，但从长远来看将收到数百万个请求。该应用程序应能根据收到的请求数量自动扩展，无需进行任何修改。此外，你的经理不希望承担管理基础设施的负担，并希望该应用程序以尽可能低的成本运行。
- en: 'Execute the following steps to complete this activity:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此活动：
- en: Create an application (in any language you want) that can provide the current
    date and time based on the given `timezone` value.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个应用程序（使用任何你想要的语言），可以根据给定的`timezone`值提供当前日期和时间。
- en: 'The following is some sample application code written in PHP:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用PHP编写的一些示例应用程序代码：
- en: '[PRE54]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Containerize the application according to the guidelines provided by Google
    Cloud Run.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据Google Cloud Run提供的指南对应用程序进行容器化。
- en: 'The following is the content of a sample Dockerfile:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例Dockerfile的内容：
- en: '[PRE55]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Push the Docker image to a Docker registry.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Docker镜像推送到Docker注册表。
- en: Run the application with Cloud Run.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Cloud Run运行应用程序。
- en: 'The output should be as follows:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 6.56: Deployment of the application in a serverless environment'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.56：在无服务器环境中部署应用程序'
- en: '](image/C12607_06_56.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_06_56.jpg)'
- en: 'Figure 6.56: Deployment of the application in a serverless environment'
  id: totrans-464
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.56：在无服务器环境中部署应用程序
- en: Note
  id: totrans-465
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to the activity can be found on page 417.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 活动的解决方案可以在第417页找到。
- en: Summary
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the advantages of using serverless on Kubernetes.
    We discussed three technologies that offer the benefits of serverless on top of
    a Kubernetes cluster. These are Knative, Google Cloud Run, and Virtual Kubelet.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在Kubernetes上使用无服务器的优势。我们讨论了三种技术，它们在Kubernetes集群之上提供了无服务器的好处。这些技术是Knative、Google
    Cloud Run和Virtual Kubelet。
- en: First, we created a GKE cluster with Istio and deployed Knative on top of it.
    Then we learned how to deploy an application on Knative. Next, we discussed the
    serving component of Knative and how to perform a canary deployment with configuration
    and route objects. Then we discussed monitoring on Knative and observed how Knative
    autoscaling works based on the number of requests received.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个带有Istio的GKE集群，并在其上部署了Knative。然后我们学习了如何在Knative上部署应用程序。接下来，我们讨论了Knative的serving组件，以及如何使用配置和路由对象执行金丝雀部署。然后我们讨论了Knative上的监控，并观察了Knative根据收到的请求数进行自动扩展的工作原理。
- en: We also discussed Google Cloud Run, which is a fully managed platform, built
    on the Knative project, to run stateless HTTP-driven containers. Then we learned
    how to deploy an application with the Cloud Run service.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了Google Cloud Run，这是一个完全托管的平台，建立在Knative项目之上，用于运行无状态的HTTP驱动容器。然后我们学习了如何使用Cloud
    Run服务部署应用程序。
- en: In the final section, we studied Virtual Kubelet, which is an open source implementation
    of Kubernetes' kubelet. We learned the differences between normal kubelets and
    Virtual Kubelet. Finally, we deployed Virtual Kubelet on an AKS cluster and deployed
    an application to a Virtual Kubelet node.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们学习了Virtual Kubelet，这是Kubernetes kubelet的开源实现。我们了解了普通kubelet和Virtual
    Kubelet之间的区别。最后，我们在AKS集群上部署了Virtual Kubelet，并将应用程序部署到了Virtual Kubelet节点。
- en: In the next three chapters, we will be focusing on three different Kubernetes
    serverless frameworks, namely Kubeless, OpenWhisk, and OpenFaaS.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三章中，我们将专注于三种不同的Kubernetes无服务器框架，分别是Kubeless、OpenWhisk和OpenFaaS。
