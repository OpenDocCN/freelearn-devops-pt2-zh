- en: 4\. Kubernetes Deep Dive
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. Kubernetes深入探讨
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够：
- en: Set up a local Kubernetes cluster on your computer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计算机上设置本地Kubernetes集群
- en: Access a Kubernetes cluster using the dashboard and the Terminal
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用仪表板和终端访问Kubernetes集群
- en: Identify the fundamental Kubernetes resources, the building blocks of Kubernetes
    applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别基本的Kubernetes资源，Kubernetes应用程序的构建模块
- en: Install complex applications on a Kubernetes cluster
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes集群上安装复杂的应用程序
- en: In this chapter, we will explain the basics of the Kubernetes architecture,
    the methods of accessing the Kubernetes API, and fundamental Kubernetes resources.
    In addition to that, we will deploy a real-life application into Kubernetes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释Kubernetes架构的基础知识，访问Kubernetes API的方法以及基本的Kubernetes资源。除此之外，我们还将在Kubernetes中部署一个真实的应用程序。
- en: Introduction to Kubernetes
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes简介
- en: In the previous chapter, we studied serverless frameworks, created serverless
    applications using these frameworks, and deployed these applications to the major
    cloud providers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了无服务器框架，使用这些框架创建了无服务器应用程序，并将这些应用程序部署到主要的云提供商。
- en: 'As we have seen in the previous chapters, Kubernetes and serverless architectures
    started to gain traction at the same time in the industry. Kubernetes got a high
    level of adoption and became the de facto container management system with its
    design principles based on scalability, high availability, and portability. For
    serverless applications, Kubernetes provides two essential benefits: **removal
    of vendor lock-in** and **reuse of services**.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中所看到的，Kubernetes和无服务器架构在行业中开始同时受到关注。Kubernetes以其基于可扩展性、高可用性和可移植性的设计原则获得了高度的采用，并成为事实上的容器管理系统。对于无服务器应用程序，Kubernetes提供了两个基本的好处：**消除供应商锁定**和**服务的重复使用**。
- en: Kubernetes creates an infrastructure layer of abstraction to remove vendor lock-in.
    Vendor lock-in is a situation where transition from one service provider to another
    is very difficult or even infeasible. In the previous chapter, we studied how
    serverless frameworks make it easy to develop cloud-agnostic serverless applications.
    Let's assume you are running your serverless framework on an **AWS EC2** instance
    and want to move to **Google Cloud**. Although your serverless framework creates
    a layer between the cloud provider and serverless applications, you are still
    deeply attached to the cloud provider for the infrastructure. Kubernetes breaks
    this connection by creating an abstraction between the infrastructure and the
    cloud provider. In other words, serverless frameworks running on Kubernetes are
    unaware of the underlying infrastructure. If your serverless framework runs on
    Kubernetes in AWS, it is expected to run on **Google Cloud Platform** (**GCP**)
    or Azure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes创建了一个基础设施抽象层，以消除供应商锁定。供应商锁定是指从一个服务提供商转移到另一个服务提供商非常困难甚至不可行的情况。在上一章中，我们学习了无服务器框架如何轻松开发与云无关的无服务器应用程序。假设您正在**AWS
    EC2**实例上运行您的无服务器框架，并希望迁移到**Google Cloud**。尽管您的无服务器框架在云提供商和无服务器应用程序之间创建了一层，但您仍然对基础设施的云提供商有很深的依赖。Kubernetes通过在基础设施和云提供商之间创建一个抽象来打破这种联系。换句话说，在Kubernetes上运行的无服务器框架对基础设施一无所知。如果您的无服务器框架在AWS上运行Kubernetes，则预计它也可以在**Google
    Cloud Platform**（**GCP**）或Azure上运行。
- en: As the defacto container management system, Kubernetes manages most microservices
    applications in the cloud and in on-premise systems. Let's assume you have already
    converted your big monolith application to cloud-native microservices and you're
    running them on Kubernetes. And now you've started developing serverless applications
    or turning some of your microservices to serverless *nanoservices*. At this stage,
    your serverless applications will need to access the data and other services.
    If you can run your serverless applications in your Kubernetes clusters, you will
    have the chance to reuse the services and be close to your data. Besides, it will
    be easier to manage and operate both microservices and serverless applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 作为事实上的容器管理系统，Kubernetes管理云中和本地系统中的大多数微服务应用程序。假设您已经将大型单体应用程序转换为云原生微服务，并在Kubernetes上运行它们。现在，您已经开始开发无服务器应用程序或将一些微服务转换为无服务器*纳米服务*。在这个阶段，您的无服务器应用程序将需要访问数据和其他服务。如果您可以在Kubernetes集群中运行您的无服务器应用程序，您将有机会重复使用服务并接近您的数据。此外，管理和操作微服务和无服务器应用程序将更容易。
- en: As a solution to vendor lock-in, and for potential reuse of data and services,
    it is crucial to learn how to run serverless architectures on Kubernetes. In this
    chapter, a Kubernetes recap is presented to introduce the origin and design of
    Kubernetes. Following that, we will install a local Kubernetes cluster, and you
    will be able to access the cluster by using a dashboard or a client tool such
    as `kubectl`. In addition to that, we will discuss the building blocks of Kubernetes
    applications, and finally, we'll deploy a real-life application to the cluster.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为解决供应商锁定问题，并为了数据和服务的潜在重复使用，学习如何在Kubernetes上运行无服务器架构至关重要。在本章中，将介绍Kubernetes的概述，介绍Kubernetes的起源和设计。接下来，我们将安装一个本地Kubernetes集群，您将能够通过仪表板或使用`kubectl`等客户端工具访问集群。除此之外，我们还将讨论Kubernetes应用程序的构建模块，最后，我们将在集群中部署一个真实的应用程序。
- en: Kubernetes Design and Components
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes设计和组件
- en: Kubernetes, which is also known as **k8s**, is a platform for managing containers.
    It is a complex system focused on the complete life cycle of containers, including
    configuration, installation, health checking, troubleshooting, and scaling. With
    Kubernetes, it is possible to run microservices in a scalable, flexible, and reliable
    way. Let's assume you are a DevOps engineer at a fin-tech company, focusing on
    online banking for your customers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes，也被称为**k8s**，是一个用于管理容器的平台。它是一个复杂的系统，专注于容器的完整生命周期，包括配置、安装、健康检查、故障排除和扩展。通过Kubernetes，可以以可伸缩、灵活和可靠的方式运行微服务。假设您是一家金融科技公司的DevOps工程师，专注于为客户提供在线银行服务。
- en: You can configure and install the complete backend and frontend of an online
    bank application to Kubernetes in a secure and cloud-native way. With the Kubernetes
    controllers, you can manually or automatically scale your services up and down
    to match customer demand. Also, you can check the logs, perform health checks
    on each service, and even SSH into the containers of your applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以安全和云原生的方式配置和安装在线银行应用程序的完整后端和前端到Kubernetes。通过Kubernetes控制器，您可以手动或自动地扩展服务，以满足客户需求。此外，您可以检查日志，对每个服务执行健康检查，甚至可以SSH到应用程序的容器中。
- en: In this section, we will focus on how Kubernetes is designed and how its components
    work in harmony.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注Kubernetes的设计以及其组件如何和谐地工作。
- en: 'Kubernetes clusters consist of one or more servers, and each server is assigned
    with a set of logical roles. There are two essential roles assigned to the servers
    of a cluster: **master** and **node**. If the server is in the **master** role,
    **control plane** components of the Kubernetes run on these nodes. Control plane
    components are the primary set of services used to run the Kubernetes API, including
    REST operations, authentication, authorization, scheduling, and cloud operations.
    With the recent version of Kubernetes, four services are running as the control
    plane:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群由一个或多个服务器组成，每个服务器分配了一组逻辑角色。集群的服务器分配了两个基本角色：**master**和**node**。如果服务器处于**master**角色，则Kubernetes的控制平面组件运行在这些节点上。控制平面组件是用于运行Kubernetes
    API的主要服务集，包括REST操作、身份验证、授权、调度和云操作。在最新版本的Kubernetes中，有四个服务作为控制平面运行：
- en: '**etcd**: `etcd` is an open source key/value store, and it is the database
    of all Kubernetes resources.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**etcd**：`etcd`是一个开源的键/值存储，它是所有Kubernetes资源的数据库。'
- en: '**kube-apiserver**: API server is the component that runs the Kubernetes REST
    API. It is the most critical component for interacting with other parts of the
    plane and client tools.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-apiserver**：API服务器是运行Kubernetes REST API的组件。这是与飞机其他部分和客户端工具交互的最关键组件。'
- en: '**kube-scheduler**: A scheduler assigns workloads to nodes based on the workload
    requirements and node status.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-scheduler**：调度程序根据工作负载的要求和节点状态将工作负载分配给节点。'
- en: '**kube-controller-manager**: `kube-controller-manager` is the control plane
    component used to manage core controllers of Kubernetes resources. *Controllers*
    are the primary life cycle managers of the Kubernetes resources. For each Kubernetes
    resource, there is one or more controller that works in the **observe**, **decide**,
    and **act** loop diagrammed in *Figure 4.1*. Controllers check the current status
    of the resources in the observe stage and then analyze and decide on the required
    actions to reach the desired state. In the act stage, they execute the actions
    and continue to observe the resources.![ Figure 4.1: Controller loop in Kubernetes'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-controller-manager**：`kube-controller-manager`是用于管理Kubernetes资源的核心控制器的控制平面组件。*控制器*是Kubernetes资源的主要生命周期管理器。对于每个Kubernetes资源，都有一个或多个控制器在*图4.1*中的**观察**、**决策**和**执行**循环中工作。控制器在观察阶段检查资源的当前状态，然后分析并决定达到所需状态所需的操作。在执行阶段，它们执行操作并继续观察资源。![图4.1：Kubernetes中的控制器循环'
- en: '](image/C12607_04_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_01.jpg)'
- en: 'Figure 4.1: Controller loop in Kubernetes'
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.1：Kubernetes中的控制器循环
- en: 'Servers with the **node** role are responsible for running the workload in
    Kubernetes. Therefore, there are two essential Kubernetes components required
    in every node:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 具有**node**角色的服务器负责在Kubernetes中运行工作负载。因此，每个节点都需要两个基本的Kubernetes组件：
- en: '**kubelet**: `kubelet` is the management gateway of the control plane in the
    nodes. `kubelet` communicates with the API server and implements actions needed
    on the nodes. For instance, when a new workload is assigned to a node, `kubelet`
    creates the container by interacting with the container runtime, such as Docker.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubelet**：`kubelet`是节点中控制平面的管理网关。`kubelet`与API服务器通信并在节点上实施所需的操作。例如，当将新的工作负载分配给节点时，`kubelet`通过与容器运行时（如Docker）交互来创建容器。'
- en: '**kube-proxy**: Containers run on the server nodes, but they interact with
    each other as they are running in a unified networking setup. `kube-proxy` makes
    it possible for containers to communicate, although they are running on different
    nodes.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-proxy**：容器在服务器节点上运行，但它们在统一的网络设置中相互交互。`kube-proxy`使容器能够通信，尽管它们在不同的节点上运行。'
- en: 'The control plane and the roles, such as master and node, are logical groupings
    of components. However, it is recommended to have a highly available control plane
    with multiple master role servers. Besides, servers with node roles are connected
    to the control plane to create a scalable and cloud-native environment. The relationship
    and interaction of the control plane and the master and node servers are presented
    in the following figure:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 控制平面和角色（如主节点和工作节点）是组件的逻辑分组。然而，建议使用具有多个主节点角色服务器的高可用控制平面。此外，具有节点角色的服务器连接到控制平面，以创建可扩展和云原生环境。控制平面与主节点服务器和节点服务器的关系和交互如下图所示：
- en: '![Figure 4.2: The control plane and the master and node servers in a Kubernetes
    cluster'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2：Kubernetes集群中的控制平面、主节点和节点服务器'
- en: '](image/C12607_04_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_02.jpg)'
- en: 'Figure 4.2: The control plane and the master and node servers in a Kubernetes
    cluster'
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.2：Kubernetes集群中的控制平面、主节点和节点服务器
- en: In the following exercise, a Kubernetes cluster will be created locally, and
    Kubernetes components will be checked. Kubernetes clusters are sets of servers
    with master or worker nodes. On these nodes, both control plane components and
    user applications are running in a scalable and highly available way. With the
    help of local Kubernetes cluster tools, it is possible to create single-node clusters
    for development and testing. `minikube` is the officially supported and maintained
    local Kubernetes solution, and it will be used in the following exercise.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，将在本地创建一个Kubernetes集群，并检查Kubernetes组件。Kubernetes集群是具有主节点或工作节点的服务器集合。在这些节点上，控制平面组件和用户应用程序以可扩展和高可用的方式运行。借助本地Kubernetes集群工具，可以创建用于开发和测试的单节点集群。`minikube`是官方支持和维护的本地Kubernetes解决方案，并将在接下来的练习中使用。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：...]
- en: 'You will use `minikube` in the following exercise as the official local Kubernetes
    solution, and it runs the Kubernetes components on hypervisors. Hence you must
    install a hypervisor such as **Virtualbox**, **Parallels**, **VMWareFusion**,
    **Hyperkit**, or **VMWare**. Refer to this link for more information:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，您将使用`minikube`作为官方本地Kubernetes解决方案，并在虚拟化程序上运行Kubernetes组件。因此，您必须安装虚拟化程序，如**Virtualbox**、**Parallels**、**VMWareFusion**、**Hyperkit**或**VMWare**。有关更多信息，请参阅此链接：
- en: '[https://kubernetes.io/docs/tasks/tools/install-minikube/#install-a-hypervisor](https://kubernetes.io/docs/tasks/tools/install-minikube/#install-a-hypervisor)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/tasks/tools/install-minikube/#install-a-hypervisor](https://kubernetes.io/docs/tasks/tools/install-minikube/#install-a-hypervisor)'
- en: 'Exercise 10: Starting a Local Kubernetes Cluster'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习10：启动本地Kubernetes集群
- en: In this exercise, we will install `minikube` and use it to start a one-node
    Kubernetes cluster. When the cluster is up and running, it will be possible to
    check the master and node components.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将安装`minikube`并使用它启动一个单节点Kubernetes集群。当集群启动并运行时，将可以检查主节点和节点组件。
- en: 'To complete the exercise, we need to ensure the following steps are executed:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为完成练习，需要确保执行以下步骤：
- en: 'Install `minikube` to the local system by running these commands in your Terminal:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行以下命令将`minikube`安装到本地系统：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These commands download the binary file of `minikube`, make it executable, and
    move it into the `bin` folder for Terminal access.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令下载`minikube`的二进制文件，使其可执行，并将其移动到`bin`文件夹以供终端访问。
- en: 'Start the `minikube` cluster by running the following command:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令启动`minikube`集群：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This command downloads the images and creates a single-node virtual machine.
    Following that, it configures the machine and waits until the Kubernetes control
    plane is up and running, as shown in the following figure:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令下载镜像并创建单节点虚拟机。随后，它配置该机器并等待Kubernetes控制平面启动，如下图所示：
- en: '![Figure 4.3: Starting a new cluster in minikube'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3：在minikube中启动新集群'
- en: '](image/C12607_04_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_03.jpg)'
- en: 'Figure 4.3: Starting a new cluster in minikube'
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.3：在minikube中启动新集群
- en: 'Check the status of Kubernetes cluster:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查Kubernetes集群的状态：
- en: '`minikube status`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`minikube status`'
- en: 'As the output in the following figure indicates, the host system, `kubelet`,
    and `apiserver` are running:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图中的输出所示，主机系统、`kubelet`和`apiserver`正在运行：
- en: '![Figure 4.4: Kubernetes cluster status'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4：Kubernetes集群状态'
- en: '](image/C12607_04_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_04.jpg)'
- en: 'Figure 4.4: Kubernetes cluster status'
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.4：Kubernetes集群状态
- en: 'Connect to the virtual machine of `minikube` by running the following command:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令连接到`minikube`的虚拟机：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see the output shown in the following figure:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下图中显示的输出：
- en: '![Figure 4.5: minikube virtual machine'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5：minikube虚拟机'
- en: '](image/C12607_04_05.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_05.jpg)'
- en: 'Figure 4.5: minikube virtual machine'
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.5：minikube虚拟机
- en: 'Check for the four control-plane components with the following command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查四个控制平面组件：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command lists the processes and captures the mentioned command names.
    There are total of four lines corresponding to each control plane component and
    its process IDs, as depicted in the following figure:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令列出进程并捕获所提到的命令名称。每个控制平面组件及其进程ID对应四行，如下图所示：
- en: '![Figure 4.6: Control plane components'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6：控制平面组件'
- en: '](image/C12607_04_06.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_06.jpg)'
- en: 'Figure 4.6: Control plane components'
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.6：控制平面组件
- en: 'Check for the node components with the following command:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查节点组件：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command lists two components running in the node role, with their process
    IDs, as shown in the following figure:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令列出了在节点角色中运行的两个组件及其进程ID，如下图所示：
- en: '![Figure 4.7: Node components'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7：节点组件'
- en: '](image/C12607_04_07.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_07.jpg)'
- en: 'Figure 4.7: Node components'
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.7：节点组件
- en: 'Exit the terminal started in *Step 4* with the following command:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令退出*步骤4*中启动的终端：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see the output shown in the following figure:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下图中显示的输出：
- en: '![Figure 4.8: Exiting the minikube virtual machine'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8：退出minikube虚拟机'
- en: '](image/C12607_04_08.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_08.jpg)'
- en: 'Figure 4.8: Exiting the minikube virtual machine'
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.8：退出minikube虚拟机
- en: In this exercise, we installed a single-node Kubernetes cluster using `minikube`.
    In the next section, we will discuss using the official client tool of Kubernetes
    to connect to and operate the cluster from the previous exercise.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们使用`minikube`安装了单节点Kubernetes集群。在下一节中，我们将讨论使用Kubernetes的官方客户端工具连接到并操作前面练习中的集群。
- en: 'Kubernetes Client Tool: kubectl'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes客户端工具：kubectl
- en: The Kubernetes control plane runs a REST API server for accessing Kubernetes
    resources and undertaking operational activities. Kubernetes comes with an open
    source official command-line tool named `kubectl` in order to consume the REST
    API. It is installed on the local system and configured to connect remote clusters
    securely and reliably. `kubectl` is the primary tool for the complete life cycle
    of applications running in Kubernetes. For instance, say you deploy a **WordPress**
    blog in your cluster. First, you start creating your database passwords as secrets
    using `kubectl`. Following that, you deploy your blog application and check its
    status. In addition to that, you may trace the logs of your applications or even
    SSH into the containers for further analysis. Therefore, it is a powerful CLI
    tool that can handle both basic **create, read, update, and delete (CRUD)** actions
    and troubleshooting.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes控制平面运行一个REST API服务器，用于访问Kubernetes资源和进行操作活动。Kubernetes配备了一个名为`kubectl`的官方开源命令行工具，以便消费REST
    API。它安装在本地系统上，并配置为安全可靠地连接远程集群。`kubectl`是Kubernetes中运行应用程序的完整生命周期的主要工具。例如，假设您在集群中部署了一个**WordPress**博客。首先，您可以使用`kubectl`创建数据库密码作为secrets。然后，您部署博客应用程序并检查其状态。除此之外，您还可以跟踪应用程序的日志，甚至可以SSH到容器进行进一步分析。因此，它是一个强大的CLI工具，可以处理基本的**创建、读取、更新和删除（CRUD）**操作和故障排除。
- en: In addition to application management, `kubectl` is also a powerful tool for
    cluster operations. It is possible to check the Kubernetes API status or the status
    of the servers in the cluster using `kubectl`. Let's assume you need to restart
    a server in your cluster and you need to move the workload to other nodes. Using
    `kubectl` commands, you can mark the node as *unschedulable* and let the Kubernetes
    scheduler move the workload to other nodes. When you complete the maintenance,
    you can mark the node back as **Ready** and let a Kubernetes scheduler assign
    workloads.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了应用程序管理外，`kubectl`还是集群操作的强大工具。可以使用`kubectl`检查Kubernetes API状态或集群中服务器的状态。假设您需要重新启动集群中的服务器，并且需要将工作负载移动到其他节点。使用`kubectl`命令，您可以将节点标记为*不可调度*，并让Kubernetes调度程序将工作负载移动到其他节点。完成维护后，您可以将节点标记为**Ready**，并让Kubernetes调度程序分配工作负载。
- en: '`kubectl` is a vital command-line tool for daily Kubernetes operations. Therefore,
    learning the basics and getting hands-on experience with `kubectl` is crucial.
    In the following exercise, you will install and configure `kubectl` to connect
    to a local Kubernetes cluster.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`是日常Kubernetes操作的重要命令行工具。因此，学习基础知识并获得`kubectl`的实际经验至关重要。在接下来的练习中，您将安装和配置`kubectl`以连接到本地Kubernetes集群。'
- en: 'Exercise 11: Accessing Kubernetes Clusters Using the Client Tool: kubectl'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习11：使用客户端工具kubectl访问Kubernetes集群
- en: In this exercise, we aim to access the Kubernetes API using `kubectl` and explore
    its capabilities.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们旨在使用`kubectl`访问Kubernetes API并探索其功能。
- en: 'To complete the exercise, we need to ensure the following steps are executed:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成练习，我们需要确保执行以下步骤：
- en: 'Download the `kubectl` executable by running these commands in the Terminal:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中运行以下命令下载`kubectl`可执行文件：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These commands download the binary of `kubectl`, make it executable, and move
    it into the `bin` folder for Terminal access.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令下载`kubectl`的二进制文件，使其可执行，并将其移动到`bin`文件夹以供终端访问。
- en: 'Configure `kubectl` to connect to the `minikube` cluster:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`kubectl`以连接到`minikube`集群：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This command configures `kubectl` to use the `minikube` context, which is the
    set of credentials used to connect to the `kubectl` cluster, as shown in the following
    figure:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令配置`kubectl`以使用`minikube`上下文，该上下文是用于连接到`kubectl`集群的一组凭据，如下图所示：
- en: '![Figure 4.9: kubectl context setting'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9：kubectl上下文设置'
- en: '](image/C12607_04_09.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_09.jpg)'
- en: 'Figure 4.9: kubectl context setting'
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.9：kubectl 上下文设置
- en: 'Check the available nodes with the following command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查可用节点：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This command lists all the nodes connected to the cluster. As a single-node
    cluster, there is only one node, named `minikube`, as shown in the following figure:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令列出了连接到集群的所有节点。作为单节点集群，只有一个名为`minikube`的节点，如下图所示：
- en: '![Figure 4.10: kubectl get nodes'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.10：kubectl get nodes'
- en: '](image/C12607_04_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_10.jpg)'
- en: 'Figure 4.10: kubectl get nodes'
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.10：kubectl get nodes
- en: 'Get more information about the `minikube` node with the following command:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令获取有关`minikube`节点的更多信息：
- en: '`kubectl describe node minikube`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl describe node minikube`'
- en: 'This command lists all the information about the node, starting with its metadata,
    such as `Roles`, `Labels`, and `Annotations`. The role of this node is specified
    as `master` in the **Roles** section, as shown in the following figure:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令列出有关节点的所有信息，从其元数据开始，例如`Roles`、`Labels`和`Annotations`。此节点的角色在**Roles**部分中被指定为`master`，如下图所示：
- en: '![Figure 4.11: Node metadata'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.11：节点元数据'
- en: '](image/C12607_04_11.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_11.jpg)'
- en: 'Figure 4.11: Node metadata'
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.11：节点元数据
- en: Following the metadata, `Conditions` lists the health status of the node. It
    is possible to check available memory, disk, and process IDs in tabular form,
    as shown in the following figure.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在元数据之后，`Conditions` 列出了节点的健康状态。可以以表格形式检查可用内存、磁盘和进程 ID，如下图所示。
- en: '![Figure 4.12: Node conditions'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.12：节点条件'
- en: '](image/C12607_04_12.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_12.jpg)'
- en: 'Figure 4.12: Node conditions'
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.12：节点条件
- en: 'Then, available and allocatable capacity and system information are listed,
    as shown in the following figure:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，列出可用和可分配的容量以及系统信息，如下图所示：
- en: '![Figure 4.13: Node capacity information'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.13：节点容量信息'
- en: '](image/C12607_04_13.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_13.jpg)'
- en: 'Figure 4.13: Node capacity information'
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.13：节点容量信息
- en: 'Finally, the running workload on the node and allocated resources are listed,
    as shown in the following figure:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，列出了节点上运行的工作负载和分配的资源，如下图所示：
- en: '![Figure 4.14: Node workload information'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.14：节点工作负载信息'
- en: '](image/C12607_04_14.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_14.jpg)'
- en: 'Figure 4.14: Node workload information'
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.14：节点工作负载信息
- en: 'Get the supported API resources with the following command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令获取支持的 API 资源：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see the output shown in the following figure:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下图中显示的输出：
- en: '![Figure 4.15: Output of kubectl api-resources'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.15：kubectl api-resources 的输出'
- en: '](image/C12607_04_15.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_15.jpg)'
- en: 'Figure 4.15: Output of kubectl api-resources'
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4.15：kubectl api-resources 的输出
- en: This command lists all the resources supported by the Kubernetes cluster. The
    length of the list indicates the power and comprehensiveness of Kubernetes in
    the senseof application management. In this exercise, the official Kubernetes
    client tool was installed, configured, and explored. In the following section,
    the core building block resources from the resource list will be presented.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令列出 Kubernetes 集群支持的所有资源。列表的长度表示了 Kubernetes 在应用程序管理方面的强大和全面性。在本练习中，安装、配置和探索了官方
    Kubernetes 客户端工具。在接下来的部分中，将介绍资源列表中的核心构建块资源。
- en: Kubernetes Resources
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 资源
- en: Kubernetes comes with a rich set of **resources** to define and manage cloud-native
    applications as containers. In the Kubernetes API, every container, secret, configuration,
    or custom definition is defined as a **resource**. The control plane manages these
    resources while the node components try to achieve the *desired state* of the
    applications. The *desired state* could be running 10 instances of the application
    or mounting disk volumes to database applications. The control plane and node
    components work in harmony to make all resources in the cluster reach their *desired
    state*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes配备了丰富的资源来定义和管理云原生应用程序作为容器。在Kubernetes API中，每个容器、秘钥、配置或自定义定义都被定义为资源。控制平面管理这些资源，而节点组件则尝试实现应用程序的期望状态。期望状态可能是运行10个应用程序实例或者挂载磁盘卷到数据库应用程序。控制平面和节点组件协同工作，使集群中的所有资源达到其期望状态。
- en: In this section, we will study the fundamental Kubernetes resources used to
    run serverless applications.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习用于运行无服务器应用程序的基本Kubernetes资源。
- en: Pod
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pod
- en: 'The `pod` is the building block resource for computation in Kubernetes. A pod
    consists of containers scheduled to run into the same node as a single application.
    Containers in the same pod share the same resources, such as network and memory
    resources. In addition, the containers in the pod share life cycle events such
    as scaling up or down. A pod can be defined with an `ubuntu` image and the `echo`
    command as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`pod`是Kubernetes中用于计算的基本资源。一个pod由安排在同一节点上运行的容器组成，作为单个应用程序。同一pod中的容器共享相同的资源，如网络和内存资源。此外，pod中的容器共享生命周期事件，如扩展或缩减。可以使用`ubuntu`镜像和`echo`命令定义一个pod，如下所示：'
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When the `echo` pod is created in Kubernetes API, the scheduler will assign
    it to an available node. Then the `kubelet` in the corresponding node will create
    a container and attach networking to it. Finally, the container will start to
    run the `echo` and `sleep` commands. Pods are the essential Kubernetes resource
    for creating applications, and Kubernetes uses them as building blocks for more
    complex resources. In the following resources, the pod will be encapsulated to
    create more complex cloud-native applications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Kubernetes API中创建`echo` pod时，调度程序将其分配给一个可用节点。然后，相应节点中的`kubelet`将创建一个容器并将网络连接到它。最后，容器将开始运行`echo`和`sleep`命令。Pod是创建应用程序的基本Kubernetes资源，并且Kubernetes将它们用作更复杂资源的构建块。在接下来的资源中，pod将被封装以创建更复杂的云原生应用程序。
- en: Deployment
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署
- en: 'Deployments are the most commonly used Kubernetes resource to manage highly
    available applications. Deployments enhance pods by making it possible to scale
    up, scale down, or roll out new versions. The deployment definition looks similar
    to a pod with two important additions: **labels** and **replicas**.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 部署是管理高可用应用程序的最常用的Kubernetes资源。部署通过扩展pod，使其能够进行扩展、缩减或者部署新版本。部署定义看起来类似于一个带有两个重要附加项的pod：标签和副本。
- en: 'Consider the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The deployment named `webserver` defines five `replicas` of the application
    running with the label `app:server`. In the `template` section, the application
    is defined with the exact same label and one `nginx` container. The deployment
    controller in the control plane ensures that five instances of this application
    are running inside the cluster. Let's assume you have three nodes, A, B, and C,
    with one, two, and two instances of webserver application running, respectively.
    If node C goes offline, the deployment controller will ensure that the two lost
    instances will be recreated in nodes A and B. Kubernetes ensures that scalable
    and highly available applications are running reliably as deployments. In the
    following section, Kubernetes resources for stateful applications such as databases
    will be presented.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`webserver`的部署定义了应用程序的五个`副本`，这些副本带有标签`app:server`。在`模板`部分，应用程序使用完全相同的标签和一个`nginx`容器进行定义。控制平面中的部署控制器确保集群内运行着这个应用程序的五个实例。假设你有三个节点，A、B和C，分别运行着一个、两个和两个webserver应用程序的实例。如果节点C下线，部署控制器将确保丢失的两个实例在节点A和B中重新创建。Kubernetes确保可伸缩和高可用的应用程序作为部署可靠地运行。在接下来的部分中，将介绍用于有状态应用程序的Kubernetes资源，如数据库。
- en: StatefulSet
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有状态集
- en: Kubernetes supports running both stateless ephemeral applications and stateful
    applications. In other words, it is possible to run database applications or disk-oriented
    applications in a scalable way inside your clusters. The `StatefulSet` definition
    is similar to deployment with volume-related additions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes支持运行无状态的短暂应用程序和有状态的应用程序。换句话说，可以以可伸缩的方式在集群内运行数据库应用程序或面向磁盘的应用程序。`StatefulSet`的定义与部署类似，但有与卷相关的附加内容。
- en: 'Consider the following code snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `mysql` `StatefulSet` state creates a MySQL database with 1 GB volume data.
    The volume is created by Kubernetes and attached to the container at `/var/lib/mysql`.
    With the `StatefulSet` controllers, it is possible to create applications that
    need disk access in a scalable and reliable way. In the following section, we'll
    discuss how to connect applications in a Kubernetes cluster.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql` `StatefulSet`状态创建了一个带有1GB卷数据的MySQL数据库。卷是由Kubernetes创建并附加到容器的`/var/lib/mysql`目录。通过`StatefulSet`控制器，可以以可伸缩和可靠的方式创建需要磁盘访问的应用程序。在接下来的部分中，我们将讨论如何在Kubernetes集群中连接应用程序。'
- en: Service
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务
- en: In Kubernetes, multiple applications run in the same cluster and connect to
    each other. Since each application has multiple pods running on different nodes,
    it is not straightforward to connect applications. In Kubernetes, `Service` is
    the resource used to define a set of pods, and you access them by using the name
    of the `Service`. Service resources are defined using the labels of the pods.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，多个应用程序在同一个集群中运行并相互连接。由于每个应用程序在不同节点上运行着多个pod，因此连接应用程序并不是一件简单的事情。在Kubernetes中，`Service`是用于定义一组pod的资源，并且可以通过`Service`的名称来访问它们。Service资源是使用pod的标签来定义的。
- en: 'Consider the following code snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the `my-database` service, the pods with the label `app: mysql` are grouped.
    When the `3306` port of `my-database` address is called, Kubernetes networking
    will connect to the `3306` port of a pod with the label `app:mysql`. Service resources
    create an abstraction layer between applications and enable decoupling. Let''s
    assume you have a three-instance backend and a three-instance frontend in your
    application. Frontend pods can easily connect to backend instances using the `Service`
    resource without knowing where the backend instances are running. It creates abstraction
    and decoupling between the applications running in the cluster. In the following
    section, resources focusing on tasks and scheduled tasks will be presented.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '使用`my-database`服务，具有标签`app: mysql`的pod被分组在一起。当调用`my-database`地址的`3306`端口时，Kubernetes网络将连接到具有标签`app:mysql`的pod的`3306`端口。服务资源在应用程序之间创建了一个抽象层，并实现了解耦。假设您的应用程序中有三个后端实例和三个前端实例。前端pod可以使用`Service`资源轻松连接到后端实例，而无需知道后端实例运行在何处。它在集群中运行的应用程序之间创建了抽象和解耦。在接下来的部分中，将介绍关注任务和定时任务的资源。'
- en: Job and CronJob
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Job和CronJob
- en: 'Kubernetes resources such as `deployments` and `StatefulSets` focus on running
    applications and keeping them up and running. However, Kubernetes also provides
    `Job` and `CronJob` resources to run applications to completion. For instance,
    if your application needs to do one-time tasks, you can create a `Job` resource
    as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes资源，如`deployments`和`StatefulSets`，专注于运行应用程序并保持其运行。但是，Kubernetes还提供了`Job`和`CronJob`资源来完成应用程序的运行。例如，如果您的应用程序需要执行一次性任务，可以创建一个`Job`资源，如下所示：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When the `echo` Job is created, Kubernetes will create a pod, schedule it, and
    run it. When the container terminates after the `echo` command, Kubernetes will
    not try to restart it or keep it running.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建`echo` Job时，Kubernetes将创建一个pod，对其进行调度并运行。当容器在执行`echo`命令后终止时，Kubernetes不会尝试重新启动它或保持其运行。
- en: 'In addition to one-time tasks, it is possible to run scheduled jobs using the
    `CronJob` resource, as shown in the following code snippet:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一次性任务外，还可以使用`CronJob`资源来运行定时作业，如下面的代码片段所示。
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With the `hourly-echo` CronJob, an additional `schedule` parameter is provided.
    With the schedule of `"0 * * * *"`, Kubernetes will create a new Job instance
    of this CronJob and run it every hour. Jobs and CronJobs are Kubernetes-native
    ways of handling manual and automated tasks required for your applications. In
    the following exercise, Kubernetes resources will be explored using `kubectl`
    and a local Kubernetes cluster.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`hourly-echo` CronJob，提供了一个额外的`schedule`参数。使用`"0 * * * *"`的计划，Kubernetes将创建此CronJob的新Job实例，并每小时运行一次。Job和CronJob是处理应用程序所需的手动和自动化任务的Kubernetes本机方式。在接下来的练习中，将使用`kubectl`和本地Kubernetes集群来探索Kubernetes资源。
- en: 'Exercise 12: Installing a Stateful MySQL Database and Connecting inside Kubernetes'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习12：在Kubernetes内部安装有状态的MySQL数据库并进行连接
- en: In this exercise, we will install a MySQL database as `StatefulSet`, check its
    status, and connect to the database using a job for creating tables.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将安装一个MySQL数据库作为`StatefulSet`，检查其状态，并使用一个用于创建表的作业连接到数据库。
- en: 'To complete the exercise, we need to ensure the following steps are executed:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成练习，我们需要确保执行以下步骤：
- en: 'Create a file named `mysql.yaml` on your local computer with the following
    content:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地计算机上创建一个名为`mysql.yaml`的文件，并包含以下内容：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`mysql.yaml` is available on GitHub at [https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/mysql.yaml](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/mysql.yaml).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql.yaml`可在GitHub上找到[https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/mysql.yaml](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/mysql.yaml)。'
- en: 'Deploy the `StatefulSet` MySQL database with the following command in your
    Terminal:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中使用以下命令部署`StatefulSet` MySQL数据库：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This command submits the `mysql.yaml` file, which includes a `StatefulSet`
    called `mysql` and a 1 GB volume claim. The output will look like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令提交了`mysql.yaml`文件，其中包括一个名为`mysql`的`StatefulSet`和一个1GB的卷索赔。输出如下：
- en: '![Figure 4.16: StatefulSet creation'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.16：StatefulSet创建'
- en: '](image/C12607_04_16.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_16.jpg)'
- en: 'Figure 4.16: StatefulSet creation'
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.16：StatefulSet创建
- en: 'Check the pods with the following command:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查pod：
- en: '`kubectl get pods`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get pods`'
- en: 'This command lists the running pods, and we expect to see the one instance
    of `mysql`, as shown in the following figure:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令列出了运行中的pod，我们期望看到一个`mysql`实例，如下图所示：
- en: '![Figure 4.17: Pod listing'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.17：Pod列表'
- en: '](image/C12607_04_17.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_17.jpg)'
- en: 'Figure 4.17: Pod listing'
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.17：Pod列表
- en: Note
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If the pod status is `Pending`, wait a couple of minutes until it becomes `Running`
    before continuing to the next step.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果pod状态为`Pending`，请等待几分钟直到变为`Running`，然后再继续下一步。
- en: 'Check the persistent volumes with the following command:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查持久卷：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This command lists the persistent volumes, and we expect to see the one-volume
    instance created for the `StatefulSet`, as shown in the following figure:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令列出了持久卷，我们期望看到为`StatefulSet`创建的单卷实例，如下图所示：
- en: '![Figure 4.18: Persistent volume listing'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.18：持久卷列表'
- en: '](image/C12607_04_18.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_18.jpg)'
- en: 'Figure 4.18: Persistent volume listing'
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.18：持久卷列表
- en: 'Create the `service.yaml` file with the following content:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容创建`service.yaml`文件：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`service.yaml` is available on GitHub at [https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/service.yaml](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/service.yaml).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`service.yaml`可在GitHub上找到[https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/service.yaml](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/service.yaml)。'
- en: 'Deploy the `my-database` service with the following command in your Terminal:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在终端中部署`my-database`服务：
- en: '`kubectl apply -f service.yaml`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl apply -f service.yaml`'
- en: 'This command submits the `Service` named `my-database` to group pods with the
    label `app:mysql`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令提交了名为`my-database`的`Service`，以便将标签为`app:mysql`的pod分组：
- en: '![Figure 4.19: Service creation'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.19：服务创建'
- en: '](image/C12607_04_19.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_19.jpg)'
- en: 'Figure 4.19: Service creation'
  id: totrans-191
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.19：服务创建
- en: 'Create the `create-table.yaml` file with the following content:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容创建`create-table.yaml`文件：
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`create-table.yaml` is available on GitHub at [https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/create-table.yaml](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/create-table.yaml).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`create-table.yaml`可在GitHub上找到[https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/create-table.yaml](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Exercise12/create-table.yaml)。'
- en: 'Deploy the job with the following command:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令部署作业：
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This command submits the Job named `create-table` and within a couple of minutes,
    the pod will be created to run the `CREATE TABLE` command, as shown in the following
    figure:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令提交名为`create-table`的作业，并在几分钟内，将创建一个pod来运行`CREATE TABLE`命令，如下图所示：
- en: '![Figure 4.20: Job creation'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.20：作业创建'
- en: '](image/C12607_04_20.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_20.jpg)'
- en: 'Figure 4.20: Job creation'
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.20：作业创建
- en: 'Check for the pods with the following command:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查pod：
- en: '`kubectl get pods`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get pods`'
- en: 'This command lists the running pods, and we expect to see the one instance
    of `create-table`, as shown in the following figure:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令列出正在运行的pod，我们期望看到一个`create-table`的实例，如下图所示：
- en: '![Figure 4.21: Pod listing'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.21：Pod清单'
- en: '](image/C12607_04_21.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_21.jpg)'
- en: 'Figure 4.21: Pod listing'
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.21：Pod清单
- en: Note
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If the pod status is **Pending** or **Running**, wait a couple of minutes until
    it becomes **Completed** before continuing to the next step.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果pod状态为**Pending**或**Running**，请等待几分钟，直到它变为**Completed**，然后再继续下一步。
- en: 'Run the following command to check the tables in the MySQL database:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来检查MySQL数据库中的表格：
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This command runs a temporary instance of the `mysql:5.7` image and runs the
    `mysql` command, as shown in the following figure:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令运行一个临时实例的`mysql:5.7`镜像，并运行`mysql`命令，如下图所示：
- en: '![Figure 4.22: Table listing'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.22：表格清单'
- en: '](image/C12607_04_22.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_22.jpg)'
- en: 'Figure 4.22: Table listing'
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.22：表格清单
- en: In the MySQL database, a table with the name `messages` is available, as shown
    in the preceding output. It shows that `MySQL` `StatefulSet` is up and running
    the database successfully. In addition, the `create-table` Job has created a pod,
    connected to the database using the service, and created the table.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL数据库中，有一个名为`messages`的表格，如前面的输出所示。它显示`MySQL` `StatefulSet`已经成功运行数据库。此外，`create-table`作业已经创建了一个连接到数据库的pod，并创建了表格。
- en: 'Clean the resources by running the following command:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令清理资源：
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should see the output shown in the following figure:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到下图所示的输出：
- en: '![Figure 4.23: Cleanup'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.23：清理'
- en: '](image/C12607_04_23.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_23.jpg)'
- en: 'Figure 4.23: Cleanup'
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.23：清理
- en: In the following activity, the database will be filled with the information
    retrieved by automated tasks in Kubernetes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的活动中，数据库将被自动化任务在Kubernetes中检索到的信息填充。
- en: Note
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You will need a Docker Hub account to push the images into the registry in the
    following activity. Docker Hub is a free service, and you can sign up to it at
    [https://hub.docker.com/signup](https://hub.docker.com/signup).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的活动中，您将需要一个Docker Hub账户将图像推送到注册表中。Docker Hub是一个免费的服务，您可以在[https://hub.docker.com/signup](https://hub.docker.com/signup)注册。
- en: 'Activity 4: Collect Gold Prices in a MySQL Database in Kubernetes'
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动4：在Kubernetes中收集MySQL数据库中的黄金价格
- en: 'The aim of this activity to create a real-life serverless application that
    runs in a Kubernetes cluster using Kubernetes-native resources. The serverless
    function will get gold prices from the live market and will push the data to the
    database. The function will run with predefined intervals to keep a history and
    make statistical analyses. Gold prices can be retrieved from the *CurrencyLayer*
    API, which provides a free API for exchange rates. Once completed, you will have
    a CronJob running every minute:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的目的是创建一个在Kubernetes集群中运行的真实无服务器应用程序，使用Kubernetes本地资源。无服务器函数将从实时市场获取黄金价格，并将数据推送到数据库。该函数将以预定义的间隔运行，以保留历史记录并进行统计分析。黄金价格可以从*CurrencyLayer*
    API中检索，该API提供免费的汇率API。完成后，您将拥有一个每分钟运行的CronJob：
- en: Note
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In order to complete the following activity, you need to have a CurrencyLayer
    API access key. It is a free currency and exchange rate service, and you can sign
    up to it on the official website.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成以下活动，您需要拥有CurrencyLayer API访问密钥。这是一个免费的货币和汇率服务，您可以在官方网站上注册。
- en: '![Figure 4.24: Kubernetes Job for gold price'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.24：用于黄金价格的Kubernetes作业'
- en: '](image/C12607_04_24.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_24.jpg)'
- en: 'Figure 4.24: Kubernetes Job for gold price'
  id: totrans-232
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.24：用于黄金价格的Kubernetes作业
- en: 'Finally, with each run of the Kubernetes Job, you will have a real-time gold
    price in the database:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每次运行Kubernetes作业时，您将在数据库中获得实时黄金价格：
- en: '![Figure 4.25: Price data in the database'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.25：数据库中的价格数据'
- en: '](image/C12607_04_25.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_04_25.jpg)'
- en: 'Figure 4.25: Price data in the database'
  id: totrans-236
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.25：数据库中的价格数据
- en: 'Execute the following steps to complete this activity:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成这个活动：
- en: 'Create an application to retrieve the gold price from *CurrencyLayer* and insert
    it into the MySQL database. It is possible to implement this function in Go with
    the following structure in a `main.go` file:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个应用程序，从*CurrencyLayer*检索黄金价格并将其插入到MySQL数据库中。可以在`main.go`文件中使用以下结构来实现这个功能：
- en: '[PRE24]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `main` function, first you need to connect to the database, and then
    retrieve the price from *CurrencyLayer*. Then you need to create a SQL statement
    and execute on the database connection. The complete code for main.go can be found
    here: [https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Activity4/main.go](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Activity4/main.go).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，首先需要连接到数据库，然后从*CurrencyLayer*检索价格。然后需要创建一个SQL语句并在数据库连接上执行。main.go的完整代码可以在这里找到：[https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Activity4/main.go](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Activity4/main.go)。
- en: Build the application as a Docker container.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序构建为Docker容器。
- en: Push the Docker container to the Docker registry.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Docker容器推送到Docker注册表。
- en: Deploy the MySQL database into the Kubernetes cluster.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将MySQL数据库部署到Kubernetes集群中。
- en: Deploy a Kubernetes service to expose the MySQL database.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署一个Kubernetes服务来暴露MySQL数据库。
- en: Deploy a `CronJob` to run every minute.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署一个`CronJob`，每分钟运行一次。
- en: Wait for a couple of minutes and check the instances of `CronJob`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几分钟并检查`CronJob`的实例。
- en: Connect to the database and check for the entries.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到数据库并检查条目。
- en: Clean the database and automated tasks from Kubernetes.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Kubernetes中清除数据库和自动化任务。
- en: Note
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution of the activity can be found on page 403.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 活动的解决方案可以在第403页找到。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we first described the origins and characteristics of Kubernetes.
    Following that, we studied the Kubernetes design and components with the details
    of master and node components. Then, we installed a local single-node Kubernetes
    cluster and checked the Kubernetes components. Following the cluster setup, we
    studied the official Kubernetes client tool, `kubectl`, which is used to connect
    to a cluster. We also saw how `kubectl` is used to manage clusters and the life
    cycle of applications. Finally, we discussed the fundamental Kubernetes resources
    for serverless applications, including pods, deployments, and `StatefulSets`.
    In addition to that, we also studied how to connect applications in a cluster
    using services. Kubernetes resources for one-time and automated tasks were presented
    using `Jobs` and `CronJobs`. At the end of this chapter, we developed a real-time
    data collection function using Kubernetes-native resources.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先描述了Kubernetes的起源和特点。接着，我们研究了Kubernetes的设计和组件，包括主控组件和节点组件的细节。然后，我们安装了一个本地单节点的Kubernetes集群，并检查了Kubernetes的组件。在集群设置之后，我们学习了官方的Kubernetes客户端工具`kubectl`，它用于连接到集群。我们还看到了`kubectl`如何用于管理集群和应用程序的生命周期。最后，我们讨论了用于无服务器应用程序的基本Kubernetes资源，包括pod、部署和`StatefulSets`。除此之外，我们还学习了如何使用服务在集群中连接应用程序。使用`Jobs`和`CronJobs`来呈现一次性和自动化任务的Kubernetes资源。在本章的最后，我们使用Kubernetes本地资源开发了一个实时数据收集功能。
- en: In the next chapter, we will be studying the features of Kubernetes clusters
    and using a popular cloud platform to deploy them.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Kubernetes集群的特性，并使用流行的云平台来部署它们。
