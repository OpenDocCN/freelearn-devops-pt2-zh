- en: 1\. Introduction to Serverless
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 无服务器介绍
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，您将能够：
- en: Identify the benefits of serverless architectures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别无服务器架构的好处
- en: Create and invoke simple functions on a serverless platform
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在无服务器平台上创建和调用简单函数
- en: Create a cloud-native serverless function and package it as a container using
    Kubernetes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes创建云原生无服务器函数并将其打包为容器
- en: Create a Twitter Bot Backend application and package it in a Docker container
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Twitter Bot后端应用程序并将其打包到Docker容器中
- en: In this chapter, we will explain the serverless architecture, then create our
    first serverless function and package it as a container.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释无服务器架构，然后创建我们的第一个无服务器函数并将其打包为容器。
- en: Introduction to Serverless
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无服务器介绍
- en: Cloud technology right now is in a state of constant transformation to create
    scalable, reliable, and robust environments. In order to create such an environment,
    every improvement in cloud technology aims to increase both the end user experience
    and the developer experience. End users demand fast and robust applications that
    are reachable from everywhere in the world. At the same time, developers demand
    a better development environment to design, deploy, and maintain their applications
    in. In the last decade, the journey of cloud technology has started with cloud
    computing, where servers are provisioned in cloud data centers and applications
    are deployed on the servers. The transition to cloud data centers decreased costs
    and removed the need for responsibility for data centers. However, as billions
    of people are accessing the internet and demanding more services, scalability
    has become a necessity. In order to scale applications, developers have created
    smaller microservices that can scale independently of each other. Microservices
    are packaged into containers as building blocks of software architectures to better
    both the developer and end user experience. Microservices enhance the developer
    experience by providing better maintainability while offering high scalability
    to end users. However, the flexibility and scalability of microservices cannot
    keep up with the enormous user demand. Today, for instance, millions of banking
    transactions take place daily, and millions of business-to-business requests are
    made to backend systems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，云技术正处于不断变革的状态，以创建可扩展、可靠和强大的环境。为了创建这样的环境，云技术的每一项改进都旨在提高最终用户体验和开发人员体验。最终用户要求快速、强大的应用程序，可以从世界各地访问。与此同时，开发人员要求更好的开发环境来设计、部署和维护他们的应用程序。在过去的十年中，云技术的旅程始于云计算，其中服务器在云数据中心中进行配置，并在服务器上部署应用程序。向云数据中心的过渡降低了成本，并消除了对数据中心的责任。然而，随着数十亿人访问互联网并要求更多服务，可扩展性已成为必需。为了扩展应用程序，开发人员创建了可以独立扩展的较小的微服务。微服务被打包成容器，作为软件架构的构建块，以改善开发人员和最终用户的体验。微服务通过提供更好的可维护性来增强开发人员体验，同时为最终用户提供高可扩展性。然而，微服务的灵活性和可扩展性无法满足巨大的用户需求。例如，今天，每天进行数百万笔银行交易，并向后端系统发出数百万笔业务请求。
- en: Finally, serverless started gaining attention for creating *future-proof* and
    *ad hoc-scalable* applications. Serverless designs focus on creating even smaller
    services than microservices and they are designed to last much longer into the
    future. These *nanoservices*, or functions, help developers to create more flexible
    and easier-to-maintain applications. On the other hand, serverless designs are
    ad hoc-scalable, which means if you adopt a serverless design, your services are
    naturally scaled up or down with the user requests. These characteristics of serverless
    have made it the latest big trend in the industry, and it is now shaping the cloud
    technology landscape. In this section, an introduction to serverless technology
    will be presented, looking at serverless's evolution, origin, and use cases.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，无服务器开始引起人们的关注，用于创建“未来可靠”和“即时可扩展”的应用程序。无服务器设计专注于创建比微服务更小的服务，并且它们被设计为更持久地存在于未来。这些“纳米服务”或函数帮助开发人员创建更灵活、更易于维护的应用程序。另一方面，无服务器设计是即时可扩展的，这意味着如果您采用无服务器设计，您的服务会随着用户请求自然地扩展或缩小。无服务器的这些特性使其成为行业中最新的大趋势，它现在正在塑造云技术的格局。在本节中，将介绍无服务器技术的概述，重点关注无服务器的演变、起源和用例。
- en: 'Before diving deeper into serverless design, let''s understand the evolution
    of cloud technology. In bygone days, the expected process of deploying applications
    started with the procurement and deployment of hardware, namely servers. Following
    that, operating systems were installed on the servers, and then application packages
    were deployed. Finally, the actual code in application packages was executed to
    implement business requirements. These four steps are shown in *Figure 1.1*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究无服务器设计之前，让我们了解一下云技术的演变。在过去，部署应用程序的预期流程始于硬件的采购和部署，即服务器。随后，在服务器上安装操作系统，然后部署应用程序包。最后，执行应用程序包中的实际代码以实现业务需求。这四个步骤如*图1.1*所示：
- en: '![Figure 1.1: Traditional software development'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1：传统软件开发'
- en: '](image/C12607_01_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_01.jpg)'
- en: 'Figure 1.1: Traditional software development'
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.1：传统软件开发
- en: 'Organizations started to outsource their data center operations to cloud providers
    to improve the scalability and utilization of servers. For instance, if you were
    developing an online shopping application, you first needed to buy some servers,
    wait for their installation, and operate them daily and deal with their potential
    problems, caused by electricity, networking, and misconfiguration. It was difficult
    to predict the usage level of servers and not feasible to make huge investments
    in servers to run applications. Therefore, both start-ups and large enterprises
    started to outsource data center operations to cloud providers. This cleared away
    the problems related to the first step of hardware deployment, as shown in *Figure
    1.2*:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 组织开始将其数据中心运营外包给云提供商，以改善服务器的可伸缩性和利用率。例如，如果您正在开发一个在线购物应用程序，您首先需要购买一些服务器，等待它们的安装，并每天操作它们并处理由电力、网络和错误配置引起的潜在问题。很难预测服务器的使用水平，也不可行大规模投资于服务器来运行应用程序。因此，初创公司和大型企业开始将数据中心运营外包给云提供商。这清除了与硬件部署的第一步相关的问题，如*图1.2*所示：
- en: '![Figure 1.2: Software development with cloud computing'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2：云计算软件开发'
- en: '](image/C12607_01_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_02.jpg)'
- en: 'Figure 1.2: Software development with cloud computing'
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.2：云计算软件开发
- en: 'With the start of virtualization in cloud computing, operating systems became
    virtualized so that multiple virtual machines (VMs) could run on the same bare-metal
    machine. This transition removed the second step, and service providers provision
    VMs as shown in *Fig 1.3*. With multiple VMs running on the same hardware, the
    costs of running servers decreases and the flexibility of operations increases.
    In other words, the low-level concerns of software developers are cleared since
    both the hardware and the operating system are now someone else''s problem:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算中虚拟化的开始，操作系统变得虚拟化，以便多个虚拟机（VMs）可以在同一台裸机上运行。这种转变消除了第二步，服务提供商按照*图1.3*所示提供VMs。在同一硬件上运行多个VMs，服务器运行成本降低，操作灵活性增加。换句话说，软件开发人员的底层问题得到解决，因为硬件和操作系统现在都是别人的问题：
- en: '![Figure 1.3: Software development with virtualization'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3：虚拟化软件开发'
- en: '](image/C12607_01_03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_03.jpg)'
- en: 'Figure 1.3: Software development with virtualization'
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.3：虚拟化软件开发
- en: VMs enable the running of multiple instances on the same hardware. However,
    using VMs requires installing a complete operating system for every application.
    Even for a basic frontend application, you need to install an operating system,
    which results in an overhead of operating system management, leading to limited
    scalability. Application developers and the high-level usage of modern applications
    requires faster and simpler solutions with better isolation than creating and
    managing VMs. Containerization technology solves this issue by running multiple
    instances of "containerized" applications on the same operating system. With this
    level of abstraction, problems related to operating systems are also removed,
    and containers are delivered as application packages, as illustrated in *Figure
    1.4*. Containerization technology enables a microservices architecture where software
    is designed as small and scalable services that interact with each other.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: VMs使得在同一硬件上运行多个实例成为可能。然而，使用VMs需要为每个应用程序安装完整的操作系统。即使对于基本的前端应用程序，您也需要安装操作系统，这导致操作系统管理的开销，从而导致可扩展性受限。应用程序开发人员和现代应用程序的高级使用需要比创建和管理VMs更快速、更简单、更具隔离性的解决方案。容器化技术通过在同一操作系统上运行多个“容器化”应用程序来解决这个问题。通过这种抽象级别，与操作系统相关的问题也被解决，容器被作为应用程序包交付，如*图1.4*所示。容器化技术实现了微服务架构，其中软件被设计为小型且可扩展的服务，彼此之间进行交互。
- en: 'This architectural approach makes it possible to run modern applications such
    as collaborative spreadsheets in Google Drive, live streams of sports events on
    YouTube, video conferences on Skype, and many more:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构方法使得能够运行现代应用程序，如Google Drive中的协作电子表格，YouTube上的体育赛事直播，Skype上的视频会议等等：
- en: '![Figure 1.4: Software development with containerization'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4：容器化软件开发'
- en: '](image/C12607_01_04.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_04.jpg)'
- en: 'Figure 1.4: Software development with containerization'
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.4：容器化软件开发
- en: 'The next architectural phenomena, serverless, removes the burden of managing
    containers and focuses on running the actual code itself. The essential characteristic
    of serverless architecture is ad hoc scalability. Applications in serverless architecture
    are ad hoc-scalable, which means they are scaled up or down automatically when
    they are needed. They could also be scaled down to zero, which means no hardware,
    network, or operation costs. With serverless applications, all low-level concerns
    are outsourced and managed, and the focus is on the last step – **Run the code**
    – as shown in *Figure 1.5*. With the serverless design, the focus is on the last
    step of traditional software development. In the following section, we will focus
    on the origin and manifesto of serverless for a more in-depth introduction:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个架构现象，无服务器，消除了管理容器的负担，专注于运行实际的代码本身。无服务器架构的基本特征是临时可伸缩性。无服务器架构中的应用程序是临时可伸缩的，这意味着它们在需要时会自动扩展或缩减。它们也可以缩减到零，这意味着没有硬件、网络或运营成本。在无服务器应用程序中，所有低级别的问题都被外包和管理，重点是最后一步——**运行代码**——如图1.5所示。无服务器设计的重点是传统软件开发的最后一步。在接下来的部分中，我们将专注于无服务器的起源和宣言，以便更深入地介绍：
- en: '![Figure 1.5: Software development with serverless'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.5：使用无服务器进行软件开发'
- en: '](image/C12607_01_05.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_05.jpg)'
- en: 'Figure 1.5: Software development with serverless'
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.5：使用无服务器进行软件开发
- en: Serverless Origin and Manifesto
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无服务器起源和宣言
- en: '**Serverless** is a confusing term since there are various definitions used
    in conferences, books, and blogs. Although it theoretically means not having any
    servers, it practically means leaving the responsibility of servers to third-party
    organizations. In other words, it means not getting rid of servers but server
    operations. When you run serverless, someone else handles the procurement, shipping,
    and installation of your server operations. This decreases your costs because
    you do not need to operate servers or even data centers; furthermore, it lets
    you focus on the application logic, which implements your core business function.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**无服务器**是一个令人困惑的术语，因为在会议、书籍和博客中有各种定义。尽管从理论上讲它意味着没有任何服务器，但实际上它意味着将服务器的责任留给第三方组织。换句话说，它并不意味着摆脱服务器，而是服务器操作。当你运行无服务器时，其他人会处理服务器操作的采购、运输和安装。这降低了你的成本，因为你不需要运营服务器甚至数据中心；此外，它让你专注于实现核心业务功能的应用逻辑。'
- en: The first uses of serverless were seen in articles related to continuous integration
    around 2010\. When it was first discussed, serverless was considered for building
    and packaging applications on the servers of cloud providers. The dramatic increase
    in popularity came with the **Amazon Web Services** (**AWS**) **Lambda** launch
    in 2014\. Furthermore, in 2015, AWS presented **API Gateway** for the management
    and triggering of Lambda functions as it's a single entry point for multiple functions.
    Therefore, serverless functions gained traction in 2014 and it became possible
    to create serverless architecture applications by using **AWS API Gateway** in
    2015.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器的最初用途出现在2010年左右与持续集成相关的文章中。当它首次讨论时，无服务器被认为是用于在云服务提供商的服务器上构建和打包应用程序。随着2014年**亚马逊网络服务**（**AWS**）推出**Lambda**，其受欢迎程度急剧增加。此外，2015年，AWS推出了**API
    Gateway**用于管理和触发Lambda函数，作为多个函数的单一入口点。因此，无服务器函数在2014年开始受到关注，并且在2015年可以使用**AWS
    API Gateway**创建无服务器架构应用程序。
- en: 'However, the most definitive and complete explanation of serverless was presented
    in 2016, at the AWS developer conference, as the *Serverless Compute Manifesto*.
    It consists of eight strict rules that define the core ideas behind serverless
    architecture:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对无服务器的最明确和完整的解释是在2016年在AWS开发者大会上提出的，称为*无服务器计算宣言*。它包括八条严格的规则，定义了无服务器架构背后的核心思想：
- en: Note
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'Although it was discussed in various talks at the AWS Summit 2016 conference,
    the Serverless Compute Manifesto has no official website or documentation. A complete
    list of what the manifesto details can be seen in a presentation by Dr. Tim Wagner:
    [https://www.slideshare.net/AmazonWebServices/getting-started-with-aws-lambda-and-the-serverless-cloud](https://www.slideshare.net/AmazonWebServices/getting-started-with-aws-lambda-and-the-serverless-cloud).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在AWS Summit 2016年会议的各种讨论中讨论过，但无服务器计算宣言没有官方网站或文档。宣言详细内容的完整列表可以在Tim Wagner博士的演示中看到：[https://www.slideshare.net/AmazonWebServices/getting-started-with-aws-lambda-and-the-serverless-cloud](https://www.slideshare.net/AmazonWebServices/getting-started-with-aws-lambda-and-the-serverless-cloud)。
- en: '**Functions as the building blocks**: In serverless architecture, the building
    blocks of development, deployment, and scaling should be the functions. Each function
    should be deployed and scaled in isolation, independently of other functions.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为构建块的功能**：在无服务器架构中，开发、部署和扩展的构建块应该是函数。每个函数应该独立部署和扩展，与其他函数无关。'
- en: '**No servers, VMs, or containers**: The service provider should operate all
    computation abstractions for serverless functions, including servers, VMs, and
    containers. Users of serverless architecture should not need any further information
    about the underlying infrastructure.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有服务器、虚拟机或容器**：服务提供商应该为无服务器函数操作所有计算抽象，包括服务器、虚拟机和容器。无服务器架构的用户不需要了解底层基础设施的任何进一步信息。'
- en: '**No storage**: Serverless applications should be designed as ephemeral workloads
    that have a fresh environment for every request. If they need to persist some
    data, they should use a remote service such as a **Database as a Service** (**DbaaS**).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有存储**：无服务器应用程序应设计为临时工作负载，每个请求都有一个新鲜的环境。如果它们需要保留一些数据，它们应该使用远程服务，如**数据库即服务**（**DbaaS**）。'
- en: '**Implicitly fault-tolerant functions**: Both the serverless infrastructure
    and the deployed applications should be fault-tolerant in order to create a robust,
    scalable, and reliable application environment.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式容错函数**：无服务器基础架构和部署的应用程序都应该是容错的，以创建一个强大、可扩展和可靠的应用程序环境。'
- en: '**Scalability with the request**: The underlying infrastructure, including
    the computation and network resources, should enable a high level of scalability.
    In other words, it is not an option for a serverless environment to fail to scale
    up when requests are rising.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求的可伸缩性**：包括计算和网络资源在内的基础架构应该能够实现高度的可伸缩性。换句话说，当请求增加时，无服务器环境不应该无法扩展。'
- en: '**No cost for idle time**: Serverless providers should only incur costs when
    serverless workloads are running. If your function has not received an HTTP request
    for a long period, you should not pay any money for the idleness.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空闲时间没有成本**：无服务器提供商只有在无服务器工作负载运行时才会产生成本。如果您的函数长时间没有收到HTTP请求，您不应该为空闲支付任何费用。'
- en: '**Bring Your Own Code** (**BYOC**): Serverless architectures should enable
    the running of any code developed and packaged by end users. If you are a Node.Js
    should appear together or Go developer, it should be possible for you to deploy
    your function within your preferred language to the serverless infrastructure.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自带代码**（**BYOC**）：无服务器架构应该能够运行由最终用户开发和打包的任何代码。如果您是Node.Js或Go开发人员，应该可以在您喜欢的语言中部署您的函数到无服务器基础架构中。'
- en: '**Instrumentation**: Logs of the functions and the metrics collected over the
    function calls should be available to the developers. This makes it possible to
    debug and solve problems related to functions. Since they are already running
    on remote servers, instrumentation should not create any further burden in terms
    of analyzing potential problems.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪器仪表**：应该向开发人员提供有关函数日志和函数调用收集的指标。这使得能够调试和解决与函数相关的问题。由于它们已经在远程服务器上运行，仪器仪表不应该在分析潜在问题方面产生进一步的负担。'
- en: The original manifesto introduced some best practices and limitations; however,
    as cloud technology evolves, the world of serverless applications evolves. This
    evolution will make some rules from the manifesto obsolete and will add new rules.
    In the following section, use cases of serverless applications are discussed to
    explain how serverless is adopted in the industry.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 原始宣言介绍了一些最佳实践和限制；然而，随着云技术的发展，无服务器应用程序的世界也在不断发展。这种演变将使宣言中的一些规则过时，并增加新规则。在接下来的部分中，讨论了无服务器应用程序的用例，以解释无服务器在行业中的应用情况。
- en: Serverless Use Cases
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无服务器用例
- en: 'Serverless applications and designs seem to be avant-garde technologies; however,
    they are highly adopted in the industry for reliable, robust, and scalable applications.
    Any traditional application that is running on VMs, Docker containers, or Kubernetes
    can be designed to run serverless if you want the benefits of serverless designs.
    Some of the well-known use cases of serverless architectures are listed here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器应用程序和设计似乎是前卫的技术；然而，它们在行业中被广泛采用，用于可靠、强大和可伸缩的应用程序。如果您希望获得无服务器设计的好处，任何在VM、Docker容器或Kubernetes上运行的传统应用程序都可以设计为无服务器运行。以下是一些无服务器架构的知名用例：
- en: '**Data processing**: Interpreting, analyzing, cleansing, and formatting data
    are essential steps in big data applications. With the scalability of serverless
    architectures, you can quickly filter millions of photos and count the number
    of people in them, for instance, without buying any pricey servers. According
    to a case report ([https://azure.microsoft.com/en-in/blog/a-fast-serverless-big-data-pipeline-powered-by-a-single-azure-function/](https://azure.microsoft.com/en-in/blog/a-fast-serverless-big-data-pipeline-powered-by-a-single-azure-function/)),
    it is possible to create a serverless application to detect fraudulent transitions
    from multiple sources with Azure Functions. To handle 8 million data processing
    requests, serverless platforms would be the appropriate choice, with their ad
    hoc scalability.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据处理**：解释、分析、清洗和格式化数据是大数据应用中必不可少的步骤。借助无服务器架构的可伸缩性，您可以快速过滤数百万张照片并计算其中的人数，例如，而无需购买任何昂贵的服务器。根据一份案例报告（[https://azure.microsoft.com/en-in/blog/a-fast-serverless-big-data-pipeline-powered-by-a-single-azure-function/](https://azure.microsoft.com/en-in/blog/a-fast-serverless-big-data-pipeline-powered-by-a-single-azure-function/)），可以使用
    Azure Functions 创建一个无服务器应用程序，以检测来自多个来源的欺诈交易。为了处理800万个数据处理请求，无服务器平台将是适当的选择，因为它们具有临时可伸缩性。'
- en: '**Webhooks**: Webhooks are HTTP API calls to third-party services to deliver
    real-time data. Instead of having servers up and running for webhook backends,
    serverless infrastructures can be utilized with lower costs and less maintenance.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webhooks：Webhooks是向第三方服务发送实时数据的HTTP API调用。与为Webhook后端运行服务器不同，可以利用无服务器基础架构以更低的成本和更少的维护。
- en: '**Check-out and payment**: It is possible to create shopping systems as serverless
    applications where each core functionality is designed as an isolated component.
    For instance, you can integrate the Stripe API as a remote payment service and
    use the Shopify service for cart management in your serverless backend.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结账和付款：可以将购物系统创建为无服务器应用程序，其中每个核心功能都设计为独立的组件。例如，您可以集成Stripe API作为远程支付服务，并在无服务器后端中使用Shopify服务进行购物车管理。
- en: '**Real-time chat applications**: Real-time chat applications integrated into
    Facebook Messenger, Telegram, or Slack, for instance, are very popular for handling
    customer operations, distributing news, tracking sports results, or just for entertainment.
    It is possible to create ephemeral serverless functions to respond to messages
    or take actions based on message content. The main advantage of serverless for
    real-time chat is that it can scale when many people are using it. It could also
    scale to zero and cost no money when there is no one using the chat application.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时聊天应用程序：集成到Facebook Messenger、Telegram或Slack等应用程序的实时聊天应用程序非常受欢迎，用于处理客户操作、分发新闻、跟踪体育比赛结果，或者只是用于娱乐。可以创建临时无服务器函数来响应消息或根据消息内容采取行动。无服务器实时聊天的主要优势在于，当许多人在使用时，它可以扩展。当没有人使用聊天应用程序时，它也可以缩减到零成本。
- en: These use cases illustrate that serverless architectures can be used to design
    any modern application. It is also possible to move some parts of monolithic applications
    and convert them into serverless functions. If your current online shop is a single
    Java web application packaged as a JAR file, you can separate its business functions
    and convert them into serverless components. The dissolution of giant monoliths
    into small serverless functions helps to solve multiple problems at once. First
    of all, scalability will never be an issue for the serverless components of your
    application. For instance, if you cannot handle a high amount of payments during
    holidays, a serverless platform will automatically scale up the payment functions
    with the usage levels. Secondly, you do not need to limit yourself to the programming
    language of the monolith; you can develop your functions in any programming language.
    For instance, if your database clients are better implemented with Node.js, you
    can code the database operations of your online shop in Node.js.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用例说明了无服务器架构可以用于设计任何现代应用程序。还可以将单体应用程序的某些部分移动并转换为无服务器函数。如果您当前的在线商店是打包为JAR文件的单个Java
    Web应用程序，可以将其业务功能分离并转换为无服务器组件。将巨大的单体应用程序分解为小的无服务器函数有助于同时解决多个问题。首先，无服务器应用程序的可扩展性永远不会成为问题。例如，如果在假期期间无法处理大量付款，无服务器平台将根据使用水平自动扩展付款功能。其次，您不需要局限于单体的编程语言；您可以使用任何编程语言开发函数。例如，如果您的数据库客户端最好使用Node.js实现，您可以使用Node.js编写在线商店的数据库操作。
- en: Finally, you can reuse the logic implemented in your monolith since now it is
    a shared serverless service. For instance, if you separate the payment operations
    of your online shop and create serverless payment functions, you can reuse these
    payment functions in your next project. All these benefits make it appealing for
    start-ups as well as large enterprises to adopt serverless architectures. In the
    following section, serverless architectures will be discussed in more depth, looking
    specifically at some implementations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以重用在您的单体中实现的逻辑，因为现在它是一个共享的无服务器服务。例如，如果您将在线商店的支付操作分离出来并创建无服务器支付功能，您可以在下一个项目中重用这些支付功能。所有这些好处使得创业公司和大型企业都愿意采用无服务器架构。在接下来的部分中，将更深入地讨论无服务器架构，特别关注一些实现。
- en: 'Possible answers:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的答案：
- en: Applications with high latency
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有高延迟的应用程序
- en: When observability and metrics are critical for business
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当可观察性和指标对业务至关重要时
- en: When vendor lock-in and ecosystem dependencies are an issue
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当供应商锁定和生态系统依赖成为问题时
- en: Serverless Architecture and Function as a Service (FaaS)
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无服务器架构和函数即服务（FaaS）
- en: '**Serverless** is a cloud computing design where cloud providers handle the
    provisioning of servers. In the previous section, we discussed how operational
    concerns are layered and handed over. In this section, we will focus on serverless
    architectures and application design using serverless architecture.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**无服务器**是一种云计算设计，云提供商处理服务器的供应。在前一节中，我们讨论了操作方面的分层和移交。在本节中，我们将重点讨论无服务器架构和使用无服务器架构的应用程序设计。'
- en: 'In traditional software architecture, all of the components of an application
    are installed on servers. For instance, let''s assume that you are developing
    an e-commerce website in Java and your product information is stored in **MySQL**.
    In this case, the frontend, backend, and database are installed on the same server.
    End users are expected to reach the shopping website with the IP address of the
    server, and thus an application server such as **Apache Tomcat** should be running
    on the server. In addition, user information and security components are also
    included in the package, which is installed on the server. A monolithic e-commerce
    application is shown in Figure 1.6, with all four parts, namely the frontend,
    backend, security, and database:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统软件架构中，应用程序的所有组件都安装在服务器上。例如，假设您正在用Java开发一个电子商务网站，您的产品信息存储在**MySQL**中。在这种情况下，前端、后端和数据库都安装在同一台服务器上。预期最终用户将通过服务器的IP地址访问购物网站，因此服务器上应该运行应用服务器，比如**Apache
    Tomcat**。此外，用户信息和安全组件也包含在安装在服务器上的软件包中。图1.6显示了一个单体电子商务应用程序，包括前端、后端、安全和数据库部分：
- en: '![Figure 1.6: Traditional software architecture'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6：传统软件架构'
- en: '](image/C12607_01_06.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_06.jpg)'
- en: 'Figure 1.6: Traditional software architecture'
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.6：传统软件架构
- en: '**Microservices** architecture focuses on creating a loosely coupled and independently
    deployable collection of services. For the same e-commerce system, you would still
    have frontend, backend, database, and security components, but they would be isolated
    units. Furthermore, these components would be packaged as containers and would
    be managed by a container orchestrator such as Kubernetes. This enables the installing
    and scaling of components independently since they are distributed over multiple
    servers. In Figure 1.7, the same four components are installed on the servers
    and communicating with each other via Kubernetes networking:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务**架构侧重于创建松散耦合且可独立部署的服务集合。对于同一个电子商务系统，您仍然会有前端、后端、数据库和安全组件，但它们将是隔离的单元。此外，这些组件将被打包为容器，并由诸如Kubernetes之类的容器编排器进行管理。这使得能够独立安装和扩展组件，因为它们分布在多台服务器上。在图1.7中，相同的四个组件安装在服务器上，并通过Kubernetes网络相互通信：'
- en: '![Figure 1.7: Microservices software architecture'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.7：微服务软件架构'
- en: '](image/C12607_01_07.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_07.jpg)'
- en: 'Figure 1.7: Microservices software architecture'
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.7：微服务软件架构
- en: Microservices are deployed to the servers, which are still managed by the operations
    teams. With the serverless architecture, the components are converted into third-party
    services or functions. For instance, the security of the e-commerce website could
    be handled by an Authentication-as-a-Service offering such as **Auth0**. **AWS
    Relational Database Service (RDS)** can be used as the database of the system.
    The best option for the backend logic is to convert it into functions and deploy
    them into a serverless platform such as **AWS Lambda** or **Google Cloud Functions**.
    Finally, the frontend could be served by storage services such as **AWS Simple
    Storage Service (S3)** or **Google Cloud Storage**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务部署到服务器上，仍然由运维团队管理。采用无服务器架构后，这些组件将转换为第三方服务或函数。例如，电子商务网站的安全性可以由诸如**Auth0**之类的身份验证即服务提供商来处理。**AWS关系型数据库服务（RDS）**可以用作系统的数据库。后端逻辑的最佳选择是将其转换为函数，并部署到无服务器平台，如**AWS
    Lambda**或**Google Cloud Functions**。最后，前端可以由存储服务提供，如**AWS简单存储服务（S3）**或**Google
    Cloud存储**。
- en: 'With a serverless design, it is only required to define these services for
    you to have scalable, robust, and managed applications running in harmony, as
    shown in Figure 1.8:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 采用无服务器设计，只需为您定义这些服务，您就可以拥有可扩展、强大和管理良好的应用程序，如图1.8所示。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`Auth0` is a platform for providing authentication and authorization for web,
    mobile, and legacy applications. In short, it provides **authentication and authorization
    as a service**, where you can connect any application written in any language.
    Further details can be found on its official website: [https://auth0.com](https://auth0.com).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Auth0`是一个用于为Web、移动和传统应用程序提供身份验证和授权的平台。简而言之，它提供**身份验证和授权即服务**，您可以连接任何使用任何语言编写的应用程序。更多详细信息可以在其官方网站上找到：[https://auth0.com](https://auth0.com)。'
- en: '![Figure 1.8: Serverless software architecture'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.8：无服务器软件架构'
- en: '](image/C12607_01_08.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_08.jpg)'
- en: 'Figure 1.8: Serverless software architecture'
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.8：无服务器软件架构
- en: 'Starting from a monolith architecture and first dissolving it into microservice,
    and then serverless components is beneficial for multiple reasons:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从单体架构开始，首先将其分解为微服务，然后再转换为无服务器组件，这样做有多种好处：
- en: '**Cost**: Serverless architecture helps to decrease costs in two critical ways.
    The first is that the management of the servers is outsourced, and the second
    is that it only costs money when the serverless applications are in use.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**：无服务器架构有助于通过两种关键方式降低成本。首先，服务器的管理被外包，其次，只有在使用无服务器应用程序时才会产生费用。'
- en: '**Scalability**: If an application is expected to grow, the current best choice
    is to design it as a serverless application since that removes the scalability
    constraints related to the infrastructure.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：如果预计应用程序会增长，当前最佳选择是将其设计为无服务器应用程序，因为这样可以消除与基础设施相关的可扩展性约束。'
- en: '**Flexibility**: When the scope of deployable units is decreased, serverless
    provides more flexibility to innovate, choose better programming languages, and
    manage with smaller teams.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：当部署单元的范围减少时，无服务器提供更多灵活性，可以选择更好的编程语言，并且可以用更小的团队进行管理。'
- en: 'These dimensions and how they vary between software architectures is visualized
    in *Figure 1.9*:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些维度以及它们在软件架构之间的变化在*图1.9*中可视化。
- en: '![Figure 1.9: Benefits of the transition from cost to serverless'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.9：从成本到无服务器过渡的好处'
- en: '](image/C12607_01_09.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_09.jpg)'
- en: 'Figure 1.9: Benefits of the transition from cost to serverless'
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.9：从成本到无服务器过渡的好处
- en: When you start with a traditional software development architecture, the transition
    to microservices increases scalability and flexibility. However, it does not directly
    decrease the cost of running the applications since you are still dealing with
    the servers. Further transition to serverless improves both scalability and flexibility
    while decreasing the cost. Therefore, it is essential to learn about and implement
    serverless architectures for future-proof applications. In the following section,
    the implementation of serverless architecture, namely **Function as a Service**
    (**FaaS**), will be presented.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从传统的软件开发架构开始时，转向微服务会增加可扩展性和灵活性。然而，它并没有直接降低运行应用程序的成本，因为您仍然在处理服务器。进一步转向无服务器可以提高可扩展性和灵活性，同时降低成本。因此，了解并实施无服务器架构对于未来的应用程序至关重要。在接下来的部分中，将介绍无服务器架构的实现，即**函数即服务**（**FaaS**）。
- en: Function as a Service (FaaS)
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数即服务（FaaS）
- en: '**FaaS** is the most popular and widely adopted implementation of serverless
    architecture. All major cloud providers have FaaS products, such as AWS Lambda,
    Google Cloud Functions, and Azure Functions. As its name implies, the unit of
    deployment and management in FaaS is the function. Functions in this context are
    no different from any other function in any other programming language. They are
    expected to take some arguments and return values to implement business needs.
    FaaS platforms handle the management of servers and make it possible to run event-driven,
    scalable functions. The essential properties of a FaaS offering are these:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**FaaS**是最受欢迎和广泛采用的无服务器架构实现。所有主要的云提供商都有FaaS产品，如AWS Lambda、Google Cloud Functions和Azure
    Functions。顾名思义，在FaaS中，部署和管理的单位是函数。在这种情况下，函数与任何其他编程语言中的函数没有区别。它们预期接受一些参数并返回值以实现业务需求。FaaS平台处理服务器的管理，并且可以运行事件驱动的可扩展函数。FaaS提供的基本属性如下：'
- en: '**Stateless**: Functions are designed to be stateless and ephemeral operations
    where no file is saved to disk and no caches are managed. At every invocation
    of a function, it starts quickly with a new environment, and it is removed when
    it is done.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：函数被设计为无状态和短暂的操作，不会将文件保存到磁盘，也不会管理缓存。每次调用函数时，它都会快速启动一个新环境，并在完成时被移除。'
- en: '**Event-triggered**: Functions are designed to be triggered directly and based
    on events such as `cron` time expressions, HTTP requests, message queues, and
    database operations. For instance, it is possible to call the `startConversation`
    function via an HTTP request when a new chat is started. Likewise, it is possible
    to launch the `syncUsers` function when a new user is added to a database.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件触发**：函数设计为直接触发，并基于事件，如`cron`时间表达式、HTTP请求、消息队列和数据库操作。例如，可以在启动新聊天时通过HTTP请求调用`startConversation`函数。同样，可以在向数据库添加新用户时启动`syncUsers`函数。'
- en: '**Scalable**: Functions are designed to run as much as needed in parallel so
    that every incoming request is answered and every event is covered.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展**：函数被设计为能够并行运行，以便每个传入请求都得到响应，每个事件都得到处理。'
- en: '**Managed**: Functions are governed by their platform so that the servers and
    underlying infrastructure is not a concern for FaaS users.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**托管**：函数受其平台管理，因此服务器和基础设施不是FaaS用户的关注点。'
- en: These properties of functions are covered by cloud providers' offerings, such
    as **AWS Lambda**, **Google Cloud Functions**, and **Azure Functions**; and on-premises
    offerings, such as **Kubeless**, **Apache OpenWhisk**, and **OpenFass**. With
    its high popularity, the term FaaS is mostly used interchangeably with the term
    serverless. In the following exercise, we will create a function to handle HTTP
    requests and illustrate how a serverless function should be developed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的属性由云提供商的产品提供，如**AWS Lambda**、**Google Cloud Functions**和**Azure Functions**；以及本地产品，如**Kubeless**、**Apache
    OpenWhisk**和**OpenFass**。由于其高度的流行度，术语FaaS通常与无服务器术语互换使用。在接下来的练习中，我们将创建一个处理HTTP请求的函数，并说明如何开发无服务器函数。
- en: 'Exercise 1: Creating an HTTP Function'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：创建一个HTTP函数
- en: In this exercise, we will create an HTTP function to be a part of a serverless
    platform and then invoke it via an HTTP request. In order to execute the steps
    of the exercise, you will use Docker, text editors, and a terminal.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个HTTP函数，作为无服务器平台的一部分，然后通过HTTP请求来调用它。为了执行练习的步骤，您将使用Docker、文本编辑器和终端。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for the exercises in this chapter can be found here: [https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson01/Exercise1](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson01/Exercise1).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本章练习的代码文件可以在这里找到：[https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson01/Exercise1](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson01/Exercise1)。
- en: 'To successfully complete the exercise, we need to ensure the following steps
    are executed:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功完成这个练习，我们需要确保执行以下步骤：
- en: 'Create a file named `function.go` with the following content in your favorite
    text editor:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您喜欢的文本编辑器中创建一个名为`function.go`的文件，并包含以下内容：
- en: '[PRE0]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this file, we have created an actual function handler to respond when this
    function is invoked.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们已经创建了一个实际的函数处理程序，以便在调用该函数时做出响应。
- en: 'Create a file named `main.go` with the following content:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件，并包含以下内容：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this file, we have created the environment to serve this function. In general,
    this part is expected to be handled by the serverless platform.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们已经创建了用于提供该函数的环境。一般来说，这部分应该由无服务器平台来处理。
- en: 'Start a Go development environment with the following command in your terminal:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中使用以下命令启动一个Go开发环境：
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With that command, a shell prompt will start inside a Docker container for
    Go version `1.12.5`. In addition, port `8080` of the host system is mapped to
    the container, and the current working directory is mapped to `/go/src`. You will
    be able to run commands inside the started Docker container:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过该命令，将在Go版本`1.12.5`的Docker容器内启动一个shell提示符。此外，主机系统的端口`8080`被映射到容器，并且当前工作目录被映射到`/go/src`。您将能够在启动的Docker容器内运行命令：
- en: '![Figure 1.10: The Go development environment inside the container'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.10：容器内的Go开发环境'
- en: '](image/C12607_01_10.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_10.jpg)'
- en: 'Figure 1.10: The Go development environment inside the container'
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.10：容器内的Go开发环境
- en: 'Start the function handlers with the following command in the shell prompt
    opened in *step 3*: `go run *.go`.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*步骤3*中打开的shell提示符中使用以下命令启动函数处理程序：`go run *.go`。
- en: 'With the start of the applications, you will see the following lines:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的启动，您将看到以下行：
- en: '![Figure 1.11: The start of the function server'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.11：函数服务器的开始'
- en: '](image/C12607_01_11.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_11.jpg)'
- en: 'Figure 1.11: The start of the function server'
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.11：函数服务器的开始
- en: These lines indicate that the `main` function inside the `main.go` file is running
    as
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行表明`main.go`文件中的`main`函数正在运行
- en: expected.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 预期。
- en: 'Open `http://localhost:8080` in your browser:![Figure 1.12: The WelcomeServerless
    output'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`http://localhost:8080`：![图1.12：WelcomeServerless输出
- en: '](image/C12607_01_12.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_12.jpg)'
- en: 'Figure 1.12: The WelcomeServerless output'
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.12：WelcomeServerless输出
- en: The message displayed on the web page reveals that the `WelcomeServerless` function
    is successfully invoked via the HTTP request and the response is retrieved.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 网页上显示的消息显示`WelcomeServerless`函数通过HTTP请求成功调用，并且已检索到响应。
- en: 'Press *Ctrl + C* to exit the function handler and then write `exit` to stop
    the container:![Figure 1.13: Exiting the function handler and container'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl + C*退出函数处理程序，然后输入`exit`停止容器：![图1.13：退出函数处理程序和容器
- en: '](image/C12607_01_13.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_13.jpg)'
- en: 'Figure 1.13: Exiting the function handler and container'
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.13：退出函数处理程序和容器
- en: With this exercise, we demonstrated how we can create a simple function. In
    addition, the serverless environment was presented to show how functions are served
    and invoked. In the following section, an introduction to Kubernetes and the serverless
    environment is given to connect the two cloud computing phenomena.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，我们演示了如何创建一个简单的函数。此外，展示了无服务器环境如何提供和调用函数。在接下来的部分中，将介绍Kubernetes和无服务器环境，以连接这两个云计算现象。
- en: Kubernetes and Serverless
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes和无服务器
- en: Serverless and Kubernetes arrived on the cloud computing scene at about the
    same time, in 2014\. AWS supports serverless through **AWS Lambda**, whereas **Kubernetes**
    became open source with the support of Google and its long and successful history
    in container management. Organizations started to create AWS Lambda functions
    for their short-lived temporary tasks, and many start-ups have been focused on
    products running on the serverless infrastructure. On the other hand, Kubernetes
    gained dramatic adoption in the industry and became the de facto container management
    system. It enables running both stateless applications, such as web frontends
    and data analysis tools, and stateful applications, such as databases, inside
    containers. The containerization of applications and microservices architectures
    have proven to be effective for both large enterprises and start-ups.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器和Kubernetes大约在2014年同时出现在云计算领域。AWS通过AWS Lambda支持无服务器，而Kubernetes在Google的支持下成为开源，并在容器管理方面拥有悠久而成功的历史。组织开始为他们的短暂临时任务创建AWS
    Lambda函数，许多初创公司专注于在无服务器基础设施上运行的产品。另一方面，Kubernetes在行业中获得了巨大的采用，并成为事实上的容器管理系统。它能够在容器内运行无状态应用程序，如Web前端和数据分析工具，以及有状态应用程序，如数据库。应用程序和微服务架构的容器化已被证明对大型企业和初创公司都是有效的。
- en: 'Therefore, running microservices and containerized applications is a crucial
    factor for successful, scalable, and reliable cloud-native applications. Also,
    the following two essential elements strengthen the connection between Kubernetes
    and serverless architectures:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，运行微服务和容器化应用是成功、可扩展和可靠的云原生应用的关键因素。此外，以下两个重要元素加强了Kubernetes和无服务器架构之间的联系：
- en: '**Vendor lock-in**: Kubernetes isolates the cloud provider and creates a managed
    environment for running serverless workloads. In other words, it is not straightforward
    to run your AWS Lambda functions in Google Cloud Functions if you want to move
    to a new provider next year. However, if you use a Kubernetes-backed serverless
    platform, you will be able to quickly move between cloud providers or even on-premises
    systems.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商锁定：Kubernetes隔离了云提供商，并为运行无服务器工作负载创建了托管环境。换句话说，如果您想明年转移到新的提供商，要在Google Cloud
    Functions中运行您的AWS Lambda函数并不是一件简单的事情。然而，如果您使用基于Kubernetes的无服务器平台，您将能够快速在云提供商之间甚至本地系统之间进行迁移。
- en: '**Reuse of services**: As the mainstream container management system, Kubernetes
    runs most of its workload in your cloud environment. It offers an opportunity
    to deploy serverless functions side by side with existing services. It makes it
    easier to operate, install, connect, and manage both serverless and containerized
    applications.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务重用**：作为主流的容器管理系统，Kubernetes在您的云环境中运行大部分工作负载。它提供了一个机会，可以将无服务器函数与现有服务并行部署。这使得操作、安装、连接和管理无服务器和容器化应用变得更加容易。'
- en: Cloud computing and deployment strategies are always evolving to create more
    developer-friendly environments with lower costs. Kubernetes and containerization
    adoption has already won the market and the love of developers such that any cloud
    computation without Kubernetes won't be seen for a very long time. By providing
    the same benefits, serverless architectures are gaining popularity; however, this
    does not pose a threat to Kubernetes. On the contrary, serverless applications
    will make containerization more accessible, and consequently, Kubernetes will
    profit. Therefore, it is essential to learn how to run serverless architectures
    on Kubernetes to create future-proof, cloud-native, scalable applications. In
    the following exercise, we will combine functions and containers and package our
    functions as containers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算和部署策略一直在不断发展，以创造更具开发者友好性和更低成本的环境。Kubernetes和容器化的采用已经赢得了市场和开发者的喜爱，以至于在很长一段时间内，没有Kubernetes的云计算将不会被看到。通过提供相同的好处，无服务器架构正在变得越来越受欢迎；然而，这并不构成对Kubernetes的威胁。相反，无服务器应用程序将使容器化更易于访问，因此Kubernetes将受益。因此，学习如何在Kubernetes上运行无服务器架构以创建未来可靠、云原生、可扩展的应用程序至关重要。在接下来的练习中，我们将结合函数和容器，并将我们的函数打包为容器。
- en: 'Possible answers:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的答案：
- en: Serverless – data preparation
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器 – 数据准备
- en: Serverless – ephemeral API operations
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器 – 短暂的API操作
- en: Kubernetes – databases
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes – 数据库
- en: Kubernetes – server-related operations
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes – 与服务器相关的操作
- en: 'Exercise 2: Packaging an HTTP Function as a Container'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：将HTTP函数打包为容器
- en: In this exercise, we will package the HTTP function from *Exercise 1* as a container
    to be a part of a Kubernetes workload. Also, we will run the container and trigger
    the function via its container.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将把*练习1*中的HTTP函数打包为一个容器，作为Kubernetes工作负载的一部分。此外，我们将运行容器，并通过容器触发函数。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for the exercises in this chapter can be found here: [https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson01/Exercise2](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson01/Exercise2).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本章练习的代码文件可以在此处找到：[https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson01/Exercise2](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson01/Exercise2)。
- en: 'To successfully complete the exercise, we need to ensure the following steps
    are executed:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功完成练习，我们需要确保执行以下步骤：
- en: 'Create a file named `Dockerfile` in the same folder as the files from *Exercise
    1*:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与*练习1*相同的文件夹中创建一个名为`Dockerfile`的文件。
- en: '[PRE3]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this multi-stage `Dockerfile`, the function is built inside the `golang:1.12.5-alpine3.9`
    container. Then, the binary is copied into the `alpine:3.9` container as the final
    application package.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个多阶段的`Dockerfile`中，函数是在`golang:1.12.5-alpine3.9`容器内构建的。然后，将二进制文件复制到`alpine:3.9`容器中作为最终的应用程序包。
- en: 'Build the Docker image with the following command in the terminal: `docker
    build . -t hello-serverless`.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中使用以下命令构建Docker镜像：`docker build . -t hello-serverless`。
- en: 'Each line of `Dockerfile` is executed sequentially, and finally, with the last
    step, the Docker image is built and tagged: `Successfully tagged hello-serverless:latest`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`的每一行都是按顺序执行的，最后，通过最后一步，Docker镜像被构建并标记为：`Successfully tagged hello-serverless:latest`：'
- en: '![Figure 1.14: The build of the Docker container'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.14：Docker容器的构建'
- en: '](image/C12607_01_14.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_14.jpg)'
- en: 'Figure 1.14: The build of the Docker container'
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.14：Docker容器的构建
- en: 'Start a Docker container from the `hello-serverless` image with the following
    command in your Terminal: `docker run -it --rm -p 8080:8080 hello-serverless`.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在终端中从`hello-serverless`镜像启动Docker容器：`docker run -it --rm -p 8080:8080
    hello-serverless`。
- en: 'With that command, an instance of the Docker image is instantiated with port
    `8080` mapping the host system to the container. Furthermore, the `--rm` flag
    will remove the container when it is exited. The log lines indicate that the container
    of the function is running as expected:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过该命令，使用端口`8080`实例化Docker镜像，将主机系统映射到容器。此外，`--rm`标志将在退出时删除容器。日志行表明函数的容器正在按预期运行：
- en: '![Figure 1.15: The start of the function container'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.15：函数容器的启动'
- en: '](image/C12607_01_15.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_15.jpg)'
- en: 'Figure 1.15: The start of the function container'
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.15：函数容器的启动
- en: 'Open `http://localhost:8080` in your browser:![Figure 1.16: The WelcomeServerless
    output'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`http://localhost:8080`：![图1.16：WelcomeServerless输出
- en: '](image/C12607_01_16.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_16.jpg)'
- en: 'Figure 1.16: The WelcomeServerless output'
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.16：WelcomeServerless输出
- en: It reveals that the `WelcomeServerless` function running in the container was
    successfully invoked via the HTTP request, and the response is retrieved.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了在容器中运行的`WelcomeServerless`函数通过HTTP请求成功调用，并且已检索到响应。
- en: 'Press *Ctrl + C* to exit the container:![Figure 1.17: Exiting the container'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Ctrl + C*退出容器：![图1.17：退出容器
- en: '](image/C12607_01_17.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_17.jpg)'
- en: 'Figure 1.17: Exiting the container'
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.17：退出容器
- en: In this exercise, we saw how we can package a simple function as a container.
    In addition, the container was started and the function was triggered with the
    help of Docker's networking capabilities. In the following exercise, we will implement
    a parameterized function to show how to pass values to functions and return different
    responses.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何将一个简单的函数打包为一个容器。此外，容器已启动，并且借助Docker的网络功能触发了函数。在接下来的练习中，我们将实现一个参数化函数，以展示如何向函数传递值并返回不同的响应。
- en: 'Exercise 3: Parameterized HTTP Functions'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习3：参数化HTTP函数
- en: In this exercise, we will convert the `WelcomeServerless` function from *Exercise
    2* into a parameterized HTTP function. Also, we will run the container and trigger
    the function via its container.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将把*Exercise 2*中的`WelcomeServerless`函数转换为参数化的HTTP函数。此外，我们将运行容器，并通过容器触发函数。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for the exercises in this chapter can be found here: [https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson01/Exercise3](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson01/Exercise3).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本章练习的代码文件可以在这里找到：[https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson01/Exercise3](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson01/Exercise3)。
- en: 'To successfully complete the exercise, we need to ensure that the following
    steps are executed:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功完成练习，我们需要确保执行以下步骤：
- en: 'Change the contents of `function.go` from *Exercise 2* to the following:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`function.go`的内容从*Exercise 2*更改为以下内容：
- en: '[PRE4]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the new version of the `WelcomeServerless` function, we now take URL parameters
    and return responses accordingly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在新版本的`WelcomeServerless`函数中，我们现在接受URL参数并相应返回响应。
- en: 'Build the Docker image with the following command in your terminal: `docker
    build . -t hello-serverless`.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中使用以下命令构建Docker镜像：`docker build . -t hello-serverless`。
- en: 'Each line of `Dockerfile` is executed sequentially, and with the last step,
    the Docker image is built and tagged: `Successfully tagged hello-serverless:latest`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`的每一行都按顺序执行，最后一步，Docker镜像被构建并标记为：`Successfully tagged hello-serverless:latest`：'
- en: '![Figure 1.18: The build of the Docker container'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.18：Docker容器的构建'
- en: '](image/C12607_01_18.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_18.jpg)'
- en: 'Figure 1.18: The build of the Docker container'
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.18：Docker容器的构建
- en: 'Start a Docker container from the `hello-serverless` image with the following
    command in the terminal: `docker run -it –rm -p 8080:8080 hello-serverless`.'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中使用以下命令从`hello-serverless`镜像启动Docker容器：`docker run -it –rm -p 8080:8080 hello-serverless`。
- en: 'With that command, the function handlers will start on port `8080` of the host
    system:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该命令，函数处理程序将在主机系统的端口`8080`上启动：
- en: '![Figure 1.19: The start of the function container'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.19：函数容器的开始'
- en: '](image/C12607_01_19.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_19.jpg)'
- en: 'Figure 1.19: The start of the function container'
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.19：函数容器的开始
- en: 'Open `http://localhost:8080` in your browser:![Figure 1.20: The WelcomeServerless
    output'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`http://localhost:8080`：![图1.20：WelcomeServerless输出
- en: '](image/C12607_01_20.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_20.jpg)'
- en: 'Figure 1.20: The WelcomeServerless output'
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.20：WelcomeServerless输出
- en: It reveals the same response as in the previous exercise. If we provide URL
    parameters, we should get personalized `Hello Serverless World` messages.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示与上一个练习中相同的响应。如果我们提供URL参数，我们应该会得到个性化的`Hello Serverless World`消息。
- en: 'Change the address to `http://localhost:8080?name=Ece` in your browser and
    reload the page. We are now expecting to see a personalized `Hello Serverless
    World` message with the name provided in URL parameters:![Figure 1.21: Personalized
    WelcomeServerless output'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将地址更改为`http://localhost:8080?name=Ece`并重新加载页面。我们现在期望看到一个带有URL参数中提供的名称的个性化`Hello
    Serverless World`消息：![图1.21：个性化的WelcomeServerless输出
- en: '](image/C12607_01_21.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_21.jpg)'
- en: 'Figure 1.21: Personalized WelcomeServerless output'
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.21：个性化的WelcomeServerless输出
- en: 'Press *Ctrl + C* to exit the container:![Figure 1.22: Exiting the container'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Ctrl + C*退出容器：![图1.22：退出容器
- en: '](image/C12607_01_22.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_22.jpg)'
- en: 'Figure 1.22: Exiting the container'
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.22：退出容器
- en: In this exercise, how generic functions are used with different parameters was
    shown. Personal messages based on input values were returned by a single function
    that we deployed. In the following activity, a more complex function will be created
    and managed as a container to show how they are implemented in real life.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，展示了如何使用不同参数的通用函数。我们部署的单个函数返回了基于输入值的个人消息。在接下来的活动中，将创建一个更复杂的函数，并将其作为容器进行管理，以展示它们在现实生活中的实现方式。
- en: 'Activity 1: Twitter Bot Backend for Bike Points in London'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：伦敦自行车点的Twitter机器人后端
- en: The aim of this activity is to create a real-life function for a Twitter bot
    backend. The Twitter bot will be used to search for available bike points in London
    and the number of available bikes in the corresponding locations. The bot will
    answer in a natural language form; therefore, your function will take input for
    the street name or landmark and output a complete human-readable sentence.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这项活动的目的是为Twitter机器人后端创建一个真实的功能。Twitter机器人将用于搜索伦敦的可用自行车点和相应位置的可用自行车数量。机器人将以自然语言形式回答；因此，您的函数将接受街道名称或地标的输入，并输出完整的人类可读句子。
- en: Transportation data for London is publicly available and accessible via the
    **Transport for London** (**TFL**) **Unified API** ([https://api.tfl.gov.uk](https://api.tfl.gov.uk)).
    You are required to use the TFL API and run your functions inside containers.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 伦敦的交通数据是公开可用的，并且可以通过**伦敦交通局**（**TFL**）**统一API**（[https://api.tfl.gov.uk](https://api.tfl.gov.uk)）进行访问。您需要使用TFL
    API并在容器内运行您的函数。
- en: 'Once completed, you will have a container running for the function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您将有一个运行函数的容器：
- en: '![Figure 1.23: The running function inside the container'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.23：容器内运行的函数'
- en: '](image/C12607_01_23.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_23.jpg)'
- en: 'Figure 1.23: The running function inside the container'
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.23：容器内运行的函数
- en: 'When you query via an HTTP REST API, it should return sentences similar to
    the following when bike points are found with available bikes:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当您通过HTTP REST API查询时，如果找到可用的自行车点，它应返回类似以下的句子：
- en: '![Figure 1.24: Function response when bikes are available'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.24：当自行车可用时的功能响应'
- en: '](image/C12607_01_24.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_24.jpg)'
- en: 'Figure 1.24: Function response when bikes are available'
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.24：当自行车可用时的功能响应
- en: 'When there are no bike points found or no bikes are available at those locations,
    the function will return a response similar to the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当找不到自行车点或这些位置没有可用的自行车时，函数将返回类似以下的响应：
- en: '![Figure 1.25: Function response when a bike point is located but no bike is
    found'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.25：当找到自行车点但没有找到自行车时的功能响应'
- en: '](image/C12607_01_25.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_25.jpg)'
- en: 'Figure 1.25: Function response when a bike point is located but no bike is
    found'
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.25：当找到自行车点但没有找到自行车时的功能响应
- en: 'The function may also provide the following response:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 函数还可能提供以下响应：
- en: '![Figure 1.26: Function response when no bike point or bike is found'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.26：当找不到自行车点或自行车时的功能响应'
- en: '](image/C12607_01_26.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/C12607_01_26.jpg)'
- en: 'Figure 1.26: Function response when no bike point or bike is found'
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.26：当找不到自行车点或自行车时的功能响应
- en: 'Execute the following steps to complete this activity:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此活动：
- en: Create a `main.go` file to register function handlers, as in *Exercise 1*.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main.go`文件来注册函数处理程序，就像*练习1*中一样。
- en: Create a `function.go` file for the `FindBikes` function.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`FindBikes`函数创建一个`function.go`文件。
- en: Create a `Dockerfile` for building and packaging the function, as in *Exercise
    2*.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为构建和打包函数创建一个`Dockerfile`，就像*练习2*中一样。
- en: Build the container image with Docker commands.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Docker命令构建容器映像。
- en: Run the container image as a Docker container and make the ports available from
    the host system.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为Docker容器运行容器映像，并使端口从主机系统可用。
- en: Test the function's HTTP endpoint with different queries.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不同的查询测试函数的HTTP端点。
- en: Exit the container.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出容器。
- en: Note
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The files `main.go`, `function.go` and `Dockerfile` can be found here: [https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson01/Activity1](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson01/Activity1).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`main.go`，`function.go`和`Dockerfile`可以在这里找到：[https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson01/Activity1](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/tree/master/Lesson01/Activity1)。
- en: The solution for the activity can be found on page 372.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 活动的解决方案可以在第372页找到。
- en: In this activity, we built the backend of a Twitter bot. We started by defining
    `main` and `FindBikes` functions. Then we built and packaged this serverless backend
    as a Docker container. Finally, we tested it with various inputs to find the closest
    bike station. With this real-life example, the background operations of a serverless
    platform and how to write serverless functions were illustrated.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们构建了Twitter机器人的后端。我们首先定义了`main`和`FindBikes`函数。然后我们将这个无服务器后端构建和打包为Docker容器。最后，我们用各种输入测试它，以找到最近的自行车站。通过这个现实生活中的例子，展示了无服务器平台的后台操作以及如何编写无服务器函数。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first described the journey from traditional to serverless
    software development. We discussed how software development has changed over the
    years to create a more developer-friendly environment. Following that, we presented
    the origin of serverless technology and its official manifesto. Since serverless
    is a popular term in the industry, defining some rules helps to design better
    serverless applications that integrate easily into various platforms. We then
    listed use cases for serverless technology to illustrate how serverless architectures
    can be used to create any modern application.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先描述了从传统软件开发到无服务器软件开发的过程。我们讨论了多年来软件开发如何改变，以创造一个更加开发者友好的环境。在此之后，我们介绍了无服务器技术的起源及其官方宣言。由于无服务器是行业中流行的术语，定义一些规则有助于设计更好的无服务器应用程序，使其能够轻松集成到各种平台中。然后，我们列举了无服务器技术的用例，以说明无服务器架构如何用于创建任何现代应用程序。
- en: Following an introduction to serverless, FaaS was explored as an implementation
    of serverless architectures. We showed how applications are designed in traditional,
    microservices, and serverless designs. In addition, the benefits of the transition
    to serverless architectures were discussed in detail.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍无服务器之后，探讨了FaaS作为无服务器架构的一种实现。我们展示了应用程序在传统、微服务和无服务器设计中的设计方式。此外，还详细讨论了过渡到无服务器架构的好处。
- en: Finally, Kubernetes and serverless technologies were discussed to show how they
    support each other. As the mainstream container management system, Kubernetes
    was presented, which involved looking at the advantages of running serverless
    platforms with it. Containerization and microservices are highly adopted in the
    industry, and therefore running serverless workloads as containers was covered,
    with exercises. Finally, a real-life example of functions as a backend for a Twitter
    bot was explored. In this activity, functions were packaged as containers to show
    the relationship between microservices-based, containerized, and FaaS-backed designs.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，讨论了Kubernetes和无服务器技术，以展示它们如何相互支持。作为主流的容器管理系统，介绍了Kubernetes，涉及了在其上运行无服务器平台的优势。容器化和微服务在工业界得到了广泛采用，因此涵盖了作为容器运行无服务器工作负载的内容，并提供了相关练习。最后，探讨了将函数作为Twitter机器人的后端的真实案例。在这个活动中，函数被打包为容器，以展示基于微服务、容器化和FaaS支持设计之间的关系。
- en: In the next chapter, we will be introducing serverless architecture in the cloud
    and working with cloud services.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍云中的无服务器架构，并使用云服务进行工作。
