- en: Advanced Cluster Administration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级集群管理
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Advanced settings in kubeconfig
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubeconfig中的高级设置
- en: Setting resources in nodes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在节点中设置资源
- en: Playing with WebUI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WebUI玩耍
- en: Working with a RESTful API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RESTful API工作
- en: Working with Kubernetes DNS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes DNS工作
- en: Authentication and authorization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证和授权
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: We will go through some advanced administration topics in this chapter. First,
    you will learn how to use kubeconfig to manage different clusters. Then, we will
    work on computing resources in nodes. Kubernetes provides a friendly user interface
    that illustrates the current status of resources, such as deployments, nodes,
    and pods. You will learn how to build and administrate it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些高级管理主题。首先，您将学习如何使用kubeconfig来管理不同的集群。然后，我们将在节点中处理计算资源。Kubernetes提供了友好的用户界面，用于展示资源的当前状态，例如部署、节点和Pod。您将学习如何构建和管理它。
- en: Next, you will learn how to work with the RESTful API that Kubernetes exposes.
    It will be a handy way to integrate with other systems. Finally, we want to build
    a secure cluster; the last section will go through how to set up authentication
    and authorization in Kubernetes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习如何使用Kubernetes公开的RESTful API。这将是与其他系统集成的便捷方式。最后，我们希望构建一个安全的集群；最后一节将介绍如何在Kubernetes中设置认证和授权。
- en: Advanced settings in kubeconfig
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kubeconfig中的高级设置
- en: '**kubeconfig** is a configuration file that manages cluster, context, and authentication
    settings in Kubernetes, on the client side. Using the `kubeconfig` file, we are
    able to set different cluster credentials, users, and namespaces to switch between
    clusters or contexts within a cluster. It can be configured via the command line
    using the `kubectl config` subcommand or by updating a configuration file directly.
    In this section, we''ll describe how to use `kubectl config` to manipulate kubeconfig
    and how to input a kubeconfig file directly.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubeconfig**是一个配置文件，在客户端上管理Kubernetes中的集群、上下文和认证设置。使用`kubeconfig`文件，我们可以设置不同的集群凭据、用户和命名空间，以在集群之间或集群内的上下文之间切换。它可以通过使用`kubectl
    config`子命令来配置命令行，也可以通过直接更新配置文件来配置。在本节中，我们将描述如何使用`kubectl config`来操作kubeconfig以及如何直接输入kubeconfig文件。'
- en: 'If you have gone through the *Working with namespace* recipe in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*, where we first mentioned kubeconfig, you
    will know of its basic concepts. Let''s review some key points:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经阅读了[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中的*使用命名空间*，即*走进Kubernetes概念*，那里我们首次提到了kubeconfig，您将了解其基本概念。让我们回顾一些关键点：
- en: '![](assets/e705eb01-9990-424f-8967-f63d4de49904.png)kubeconfig contains three
    parameters: user, cluster, and context'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/e705eb01-9990-424f-8967-f63d4de49904.png)kubeconfig包含三个参数：用户、集群和上下文'
- en: 'From the preceding diagram, we can note the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图可以注意到以下内容：
- en: '**There are three parameters in kubeconfig**: User, cluster, and context—user
    has its own authentication, while cluster determines the specific API server with
    dedicated computing resources. Context is both *user* and cluster.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubeconfig中有三个参数**：用户、集群和上下文—用户有自己的认证，而集群确定了具有专用计算资源的特定API服务器。上下文既是*用户*又是集群。'
- en: '**Building multiple contexts for various combinations of settings**: Users
    and clusters can be shared across different contexts.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为各种设置组合构建多个上下文**：用户和集群可以在不同的上下文中共享。'
- en: '**Namespace can be aligned in one context**: The current context of a namespace
    sets up the rules. Any requests should follow the mapping user and cluster in
    the current  context.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间可以在一个上下文中对齐**：命名空间的当前上下文设置了规则。任何请求都应遵循当前上下文中的用户和集群映射。'
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: Please run two Kubernetes clusters and give them the specified host name. You
    may just update the hostfile (`/etc/hosts`) on the master nodes. One is under
    localhost with the API server endpoint `http://localhost:8080` and the other is
    on the remote side with the endpoint `http://$REMOTE_MASTER_NODE:8080`. We will
    use these two clusters for our demonstration. The endpoints of the API server
    here are insecure channels. It is a simple configuration of an API server for
    the dummy accessing permissions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请运行两个Kubernetes集群，并为它们指定主机名。您可以在主节点上更新hostfile（`/etc/hosts`）。一个在本地主机上，API服务器端点为`http://localhost:8080`，另一个在远程端点，端点为`http://$REMOTE_MASTER_NODE:8080`。我们将使用这两个集群进行演示。这里的API服务器端点是不安全的通道。这是一个简单的API服务器配置，用于虚拟访问权限。
- en: '**Enableing the API server''s insecure endpoint on kubeadm**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**在kubeadm上启用API服务器的不安全端点**'
- en: 'We have to pass additional arguments to the API server while running `kubeadm
    init`. In this case, a custom configuration file indicated by flag `--config`
    should be applied:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`kubeadm init`时，我们必须传递额外的参数给API服务器。在这种情况下，应用标志`--config`指示的自定义配置文件：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After you boot up two clusters that have an insecure-accessing API server endpoint,
    make sure you can approach them on the localhost cluster:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动了两个具有不安全访问API服务器端点的集群之后，确保您可以在本地主机集群上访问它们：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Please note that the insecure address configuration is just for our upcoming
    tutorial. Users should be careful to set it properly on a practical system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不安全的地址配置只是为了我们即将进行的教程。用户应该小心在实际系统中正确设置它。
- en: 'Before we start, we should check the default kubeconfig in order to observe
    the changes after any updates. Fire the command `kubectl config view` to see your
    initial kubeconfig:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们应该检查默认的kubeconfig，以便观察任何更新后的更改。执行命令`kubectl config view`来查看您的初始kubeconfig：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There will be some different settings based on your installation method. But
    we may also find a basic context has been initialized by the tool, which is `kubernetes-admin@kubernetes`
    in kubeadm. Go ahead and copy the physical `kubeconfig` file as the base for later
    updating, and also for resuming our original environment after our practice.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的安装方法，可能会有一些不同的设置。但是我们也可以发现工具已经初始化了一个基本上下文，即`kubeadm`中的`kubernetes-admin@kubernetes`。继续复制物理的`kubeconfig`文件作为以后更新的基础，并在练习后恢复我们的原始环境。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we''ll use localhost cluster as the main console to switch
    the cluster via context changes. First, run a different number of `nginx` into
    both the clusters and make sure the pods are all running:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用本地主机集群作为主控制台，通过上下文更改来切换集群。首先，在两个集群中运行不同数量的`nginx`，并确保所有的pod都在运行：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Setting new credentials
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新的凭据
- en: 'Next, we are going to set up two credentials for each cluster. Use the subcommand
    `set-credentials` as `kubectl config set-credentials <CREDENTIAL_NAME>` to add
    a credential into kubeconfig. There are different authentication methods supported
    in Kubernetes. We could use a password, client-certificate, or token. In this
    example, we''ll use HTTP basic authentication to simplify the scenario. Kubernetes
    also supports client certificate and token authentications. For more information,
    please fire the `set-credentials` command with the flag `-h` for a detailed introduction
    to its functionalities:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为每个集群设置两个凭据。使用子命令`set-credentials`，如`kubectl config set-credentials <CREDENTIAL_NAME>`，将凭据添加到kubeconfig中。Kubernetes支持不同的身份验证方法。我们可以使用密码、客户端证书或令牌。在这个例子中，我们将使用HTTP基本身份验证来简化场景。Kubernetes还支持客户端证书和令牌身份验证。有关更多信息，请使用标志`-h`执行`set-credentials`命令，以详细介绍其功能：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Through the preceding procedures, we successfully add a new credential in the `"new-kubeconfig"`
    `kubeconfig` file. The kubeconfig file will be formatted in YAML by default—you
    may check the file through a text editor. With this method, we are able to customize
    new configurations without interfering with the current settings. On the other
    hand, if there is no `--kubeconfig` flag, the update will be directly attached
    to the `live kubeconfig`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述步骤，我们成功在“new-kubeconfig” kubeconfig文件中添加了新的凭据。kubeconfig文件将默认格式化为YAML-您可以通过文本编辑器检查文件。通过这种方法，我们能够定制新的配置而不干扰当前的设置。另一方面，如果没有`--kubeconfig`标志，更新将直接附加到`live
    kubeconfig`上：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At this moment, check your live kubeconfig settings and find out the new credentials:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，请检查您的live kubeconfig设置，并找出新的凭据：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Setting new clusters
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新的集群
- en: 'To set a new cluster, we use the command `kubectl config set-cluster <CLUSTER_NAME>`.
    The additional flag `--server` is required to indicate the accessing cluster.
    Other flags work to define the security level, such as the `--insecure-skip-tls-verify` flag,
    which bypasses checking the server''s certificate. If you are setting up a trusted
    server with HTTPS, you will need to use `--certificate-authority=$PATH_OF_CERT
    --embed-certs=true` instead. For more information, fire the command with the `-h`
    flag for more information. In the following commands, we set up two cluster configurations
    in our localhost environment:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个新的集群，我们使用命令`kubectl config set-cluster <CLUSTER_NAME>`。需要额外的`--server`标志来指示访问集群。其他标志用于定义安全级别，例如`--insecure-skip-tls-verify`标志，它可以绕过对服务器证书的检查。如果您正在设置一个带有HTTPS的受信任服务器，您将需要使用`--certificate-authority=$PATH_OF_CERT
    --embed-certs=true`代替。要获取更多信息，请使用`-h`标志执行命令以获取更多信息。在接下来的命令中，我们在本地主机环境中设置了两个集群配置：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We do not associate anything with **users** and **clusters** yet. We will link
    them via **context** in the next section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未将任何内容与**用户**和**集群**关联起来。我们将在下一节通过**上下文**将它们关联起来。
- en: Setting contexts and changing current-context
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置上下文并更改当前上下文
- en: 'One context contains a cluster, namespace, and user. According to the current
    context, the client will use the specified *user* information and namespace to
    send requests to the cluster. To set up a context, we will use the `kubectl config
    set-context <CONTEXT_NAME> --user=<CREDENTIAL_NAME> --namespace=<NAMESPACE> --cluster=<CLUSTER_NAME>` command
    to create or update it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个上下文包含一个集群、命名空间和用户。根据当前上下文，客户端将使用指定的*用户*信息和命名空间向集群发送请求。要设置上下文，我们将使用`kubectl
    config set-context <CONTEXT_NAME> --user=<CREDENTIAL_NAME> --namespace=<NAMESPACE>
    --cluster=<CLUSTER_NAME>`命令来创建或更新它：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s check our current kubeconfig. We can find two new contexts:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查当前的kubeconfig。我们可以找到两个新的上下文：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After creating contexts, we can switch contexts in order to manage different
    clusters. Here, we will use the `kubectl config use-context <CONTEXT_NAME>` command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建上下文后，我们可以切换上下文以管理不同的集群。在这里，我们将使用`kubectl config use-context <CONTEXT_NAME>`命令：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Yes, it looks fine. How about if we switch to the context with the remote cluster
    setting:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，看起来不错。如果我们切换到具有远程集群设置的上下文呢？
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All the operations we have done are in the localhost cluster. kubeconfig makes
    the scenario of working on multiple clusters with multiple users easier.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的所有操作都是在本地主机集群中进行的。kubeconfig使得在多个集群上以多个用户的身份工作变得更加容易。
- en: Cleaning up kubeconfig
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理kubeconfig
- en: 'We can still leverage`kubectl config` to remove configurations in kubeconfig.
    For cluster sand context, you can delete the neglected one with the subcommands `delete-cluster`
    and `delete-context`. Alternatively, for these three categories, the `unset` subcommand
    can complete the deletion:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以利用`kubectl config`来删除kubeconfig中的配置。对于集群和上下文，您可以使用子命令`delete-cluster`和`delete-context`来删除被忽略的配置。或者，对于这三个类别，`unset`子命令可以完成删除：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Although the effects of the preceding command would apply to the live kubeconfig
    right away, an even faster and more reliable way is updating another kubeconfig
    file for the replacement. A kubeconfig file is the text file `new-kubeconfig`,
    the one we just updated, or the one we copied from the initial statement, `original-kubeconfig`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的命令会立即应用于实时kubeconfig，但更新另一个kubeconfig文件以进行替换的方式更快、更可靠。kubeconfig文件是文本文件`new-kubeconfig`，我们刚刚更新的文件，或者我们从初始语句中复制的文件`original-kubeconfig`：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There's more...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As we mentioned in the previous section, real use cases with credentials and
    permissions cannot be ignored like walking cross insecure endpoints, just like
    in our demonstration. To avoid security issues, you may take the official documentation
    (found at [https://kubernetes.io/docs/admin/authentication/](https://kubernetes.io/docs/admin/authentication/))
    while granting permissions to users.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中提到的，凭据和权限的实际用例不能被忽视，就像在我们的演示中穿越不安全的端点一样。为了避免安全问题，您可以在授予用户权限时查看官方文档（位于[https://kubernetes.io/docs/admin/authentication/](https://kubernetes.io/docs/admin/authentication/)）。
- en: See also
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'kubeconfig manages  cluster, credential, and namespace settings. Check out
    the following recipes for complete concepts:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: kubeconfig管理集群、凭据和命名空间设置。查看以下完整概念的配方：
- en: The *Working with Secrets* recipe in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中的*使用秘密*配方，*深入了解Kubernetes概念*
- en: The *Working with Namespaces* recipe in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中的*使用命名空间*配方，*深入了解Kubernetes概念*
- en: Setting resources in nodes
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在节点中设置资源
- en: Computing resource management is very important in any infrastructure. We should
    know our application well and preserve enough CPU and memory capacity to avoid
    running out of resources. In this section, we'll introduce how to manage node
    capacity in Kubernetes nodes. Furthermore, we'll also describe how to manage pod
    computing resources.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何基础设施中，计算资源管理都非常重要。我们应该很好地了解我们的应用程序，并保留足够的CPU和内存容量，以避免资源耗尽。在本节中，我们将介绍如何管理Kubernetes节点中的节点容量。此外，我们还将描述如何管理Pod计算资源。
- en: 'Kubernetes has the concept of resource **Quality of Service**(**QoS**). It
    allows an administrator to prioritize pods to allocate resources. Based on the
    pod''s setting, Kubernetes classifies each pod as one of the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes具有资源**服务质量**（**QoS**）的概念。它允许管理员优先考虑分配资源。根据Pod的设置，Kubernetes将每个Pod分类为以下之一：
- en: Guaranteed pod
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保证的Pod
- en: Burstable pod
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可突发的Pod
- en: BestEffort pod
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳努力的Pod
- en: The priority is Guaranteed > Burstable > BestEffort. For example, if a BestEffort
    pod and a Guaranteed pod exist in the same Kubernetes node, and that node encounters
    CPU problems or runs out of memory, the Kubernetes master terminates the BestEffort
    pod first. Let's take a look at how it works.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级为保证 > 可突发 > 最佳努力。例如，如果在同一Kubernetes节点中存在一个最佳努力的Pod和一个保证的Pod，并且该节点遇到CPU问题或内存耗尽，Kubernetes主节点将首先终止最佳努力的Pod。让我们看看它是如何工作的。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'There are two ways to set a Resource QoS: pod configuration or namespace configuration.
    If you set a Resource QoS to the Namespace, it will apply to all pods that belong
    to the same Namespace. If you set a Resource QoS to a pod, it will apply to the
    pod only. In addition, if you set it to both namespace and pod, it takes a value
    from the namespace configuration first, and then overwrite it with the pod configuration.
    Thus, we will set up two Namespaces, one which has a Resource QoS, and one that
    does not, to see how different they are:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种设置资源QoS的方法：pod配置或命名空间配置。如果将资源QoS设置为命名空间，它将应用于属于同一命名空间的所有pod。如果将资源QoS设置为pod，它将仅应用于该pod。此外，如果同时将其设置为命名空间和pod，它将首先从命名空间配置中获取一个值，然后用pod配置覆盖它。因此，我们将设置两个命名空间，一个具有资源QoS，另一个没有资源QoS，以查看它们之间的不同：
- en: 'Create two namespaces by using the `kubectl` command as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl`命令创建两个命名空间：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Prepare a YAML file that sets `spec.limits.defaultRequest.cpu: 0.1` as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '准备一个YAML文件，设置`spec.limits.defaultRequest.cpu: 0.1`如下：'
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Do this by typing the `kubectl` command so that it applies to the `chap8-qos`
    namespace only:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入`kubectl`命令，使其仅适用于`chap8-qos`命名空间：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Check the resource limit on both `chap8-qos` and `chap8-no-qos` with the `kubectl`
    command:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl`命令检查`chap8-qos`和`chap8-no-qos`上的资源限制：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's configure a BestEffort pod, a Guaranteed pod, and then a Burstable pod
    step by step.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步配置一个BestEffort pod，一个Guaranteed pod，然后是一个Burstable pod。
- en: Configuring a BestEffort pod
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置一个BestEffort pod
- en: The BestEffort pod has the lowest priority in the Resource QoS classes. Therefore,
    in the case of a resource shortage, this BestEffort pod will be terminated by
    the Kubernetes scheduler, then will yield CPU and memory resources to other, higher
    priority pods.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: BestEffort pod在资源QoS类中具有最低的优先级。因此，在资源短缺的情况下，Kubernetes调度程序将终止此BestEffort pod，然后将CPU和内存资源让给其他优先级更高的pod。
- en: In order to configure a pod as a BestEffort, you need to set the resource limit
    as `0` (explicit), or specify no resource limit (implicit).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将pod配置为BestEffort，您需要将资源限制设置为`0`（显式），或者不指定资源限制（隐式）。
- en: 'Prepare a pod configuration that explicitly sets the `spec.containers.resources.limits`
    as `0`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个pod配置，明确将`spec.containers.resources.limits`设置为`0`：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create the pod on both the `chap8-qos` and `chap8-no-qos` namespaces:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chap8-qos`和`chap8-no-qos`命名空间上创建pod：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Check the `QoS` class; both pods have the `BestEffort` class:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`QoS`类；两个pod都有`BestEffort`类：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There is a pitfall :  if you don''t set any resource settings in the pod configuration,
    the pod takes a value from the namespace''s default settings. Therefore, if you
    create a pod with no resource settings, the result will be different between `chap8-qos`
    and `chap8-no-qos`. The following example demonstrates how the namespace settings
    affect the result:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个陷阱：如果在pod配置中没有设置任何资源设置，pod将从命名空间的默认设置中获取一个值。因此，如果创建一个没有资源设置的pod，在`chap8-qos`和`chap8-no-qos`之间的结果将会不同。以下示例演示了命名空间设置如何影响结果：
- en: 'Delete the preceding pods from the `chap8-qos` and `chap8-no-qos` namespaces:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`chap8-qos`和`chap8-no-qos`命名空间中删除之前的pod：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Prepare a pod configuration that doesn''t have resource settings:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个没有资源设置的pod配置：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create the pod on both namespaces:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个命名空间上创建pod：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result of the `QoS` class is different:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QoS`类的结果是不同的：'
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Because the `chap8-qos` namespace has the default setting `request.cpu: 0.1`,
    it causes the pod to configure with the `Burstable` class. Therefore, we will
    use the `chap8-no-qos` namespace, which avoids this unexpected result.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '因为`chap8-qos`命名空间具有默认设置`request.cpu: 0.1`，这导致pod配置为`Burstable`类。因此，我们将使用`chap8-no-qos`命名空间，避免这种意外结果。'
- en: Configuring a Guaranteed pod
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置一个Guaranteed pod
- en: The Guaranteed class has the highest priority of resource `QoS` classes. In
    the case of a resource shortage, the Kubernetes scheduler will try to retain the
    Guaranteed pod to the last.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 保证类具有资源`QoS`类的最高优先级。在资源短缺的情况下，Kubernetes调度程序将尽量保留保证的pod。
- en: 'In order to configure a pod to have the `guaranteed` class, explicitly set
    the resource limit and resource request as the same value, or only set the resource
    limit:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将pod配置为具有`保证`类，明确设置资源限制和资源请求为相同的值，或者只设置资源限制：
- en: 'Prepare a pod configuration that has the same value for `resources.limit` and
    `resources.request`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个pod配置，`resources.limit`和`resources.request`具有相同的值：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create the pod on the `chap8-no-qos` namespace:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chap8-no-qos`命名空间上创建pod：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Check the `QoS class`; it has the `Guaranteed` class:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`QoS`类；它有`保证`类：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Configuring a Burstable pod
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置一个可突发的pod
- en: 'The Burstable pod has a priority that is higher than BestEffort but lower than
    Guaranteed. In order to configure a pod to be a Burstable Pod, you need to set `resources.request`. `resources.limit` is
    optional, but the value of `resources.request` and `resources.limit` must not
    be equal:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可突发的pod的优先级高于BestEffort，但低于Guaranteed。为了将pod配置为可突发Pod，您需要设置`resources.request`。`resources.limit`是可选的，但`resources.request`和`resources.limit`的值不能相等：
- en: 'Prepare a pod configuration that has `resources.request` only:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个只有`resources.request`的pod配置：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create the pod:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建pod：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Check the `QoS` class; it is `Burstable`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`QoS`类；它是`可突发`：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Let''s see how resource requests/limits affect resource management. A preceding
    burstable YAML configuration declares both requests and limits by a different
    threshold as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看资源请求/限制如何影响资源管理。先前的可突发的YAML配置通过不同的阈值声明了请求和限制：
- en: '| **Type of resource definition** | **Resource name** | **Value** | **Description**
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **资源定义类型** | **资源名称** | **值** | **描述** |'
- en: '| **requests** | CPU | 0.1 | At least 10% of 1CPU core |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **请求** | CPU | 0.1 | 至少占用1个CPU核心的10% |'
- en: '| Memory | 10Mi | At least 10 Mbytes of memory |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 内存 | 10Mi | 至少10兆字节的内存 |'
- en: '| **limits** | CPU | 0.5 | Maximum 50% of 1 CPU core |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **限制** | CPU | 0.5 | 最大1个CPU核心的50% |'
- en: '| Memory | 300Mi | Maximum 300 Mbytes of memory |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 内存 | 300Mi | 最大300兆字节的内存 |'
- en: 'For the CPU resources, acceptable value expressions are either cores (0.1,
    0.2 ... 1.0, 2.0) or millicpu (100 m, 200 m ... 1000 m, 2000 m). 1000 m is equivalent
    to 1.0 core. For example, if a Kubernetes node has 2 cores CPU (or 1 core with
    hyperthreading), there are a total of 2.0 cores or 2000 millicpu, as shown in
    the following figure:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CPU资源，可接受的值表达式要么是核心（0.1、0.2...1.0、2.0），要么是毫核（100 m、200 m...1000 m、2000 m）。1000
    m相当于1.0个核心。例如，如果Kubernetes节点有2个核心CPU（或者1个带超线程的核心），则总共有2.0个核心或2000毫核，如下图所示：
- en: '![](assets/8ce2f36e-be54-4b02-8fa7-48e38ba68343.png)Representing a 2.0 CPU
    resource'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/8ce2f36e-be54-4b02-8fa7-48e38ba68343.png)代表2.0个CPU资源'
- en: 'By typing `kubectl describe node <node name>`, you can check what resources
    are available on the node:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入`kubectl describe node <node name>`，您可以检查节点上有哪些资源：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This shows the node `minikube` , which has 2.0 CPU and approximately 1,945
    MB memory. If you run the nginx example (`requests.cpu: 0.1`), it occupies at
    least 0.1 core, as shown in the following figure:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '这显示了节点`minikube`，它有2.0个CPU和大约1945 MB的内存。如果运行nginx示例（`requests.cpu: 0.1`），它至少占用0.1个核心，如下图所示：'
- en: '![](assets/6dbfa34c-d9ef-4cd8-9d73-4026023fd281.png)Requesting a 0.1 CPU resource'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6dbfa34c-d9ef-4cd8-9d73-4026023fd281.png)请求0.1个CPU资源'
- en: 'As long as the CPU has enough spaces, it may occupy up to 0.5 cores (`limits.cpu:
    0.5`), as shown in the following figure:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '只要CPU有足够的空间，它可以占用高达0.5个核心（`limits.cpu: 0.5`），如下图所示：'
- en: '![](assets/e4e58894-3e05-489c-903f-ebac4cb546de.png)It can occupy up to 0.5
    CPU resources'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/e4e58894-3e05-489c-903f-ebac4cb546de.png)它可能占用高达0.5个CPU资源'
- en: Therefore, if you set `requests.cpu` to be more than 2.0, the pod won't be assigned
    to this node, because the allocatable CPU is 2.0 and the nginx pod already occupies
    at least 0.1 CPU.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果将`requests.cpu`设置为大于2.0，则该pod将不会分配给此节点，因为可分配的CPU为2.0，而nginx pod已经占用了至少0.1个CPU。
- en: See also
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In this section, you learned how to configure Resource QoS by setting a resource
    request and limit. The Namespace's default value affects the resulting pod configuration,
    so you should explicitly specify resource requests and limits.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学会了如何通过设置资源请求和限制来配置资源QoS。命名空间的默认值会影响生成的pod配置，因此您应该明确指定资源请求和限制。
- en: 'Please revisit the following chapter to recap how to configure namespaces as
    well:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请回顾以下章节，以复习如何配置命名空间：
- en: '*Working with Namespaces* in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),* Walking
    through Kubernetes Concepts*'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中的*使用命名空间*，*深入了解Kubernetes概念*'
- en: Playing with WebUI
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转WebUI
- en: Kubernetes has a WebUI that visualizes the status of resources and machines,
    and also works as an additional interface for managing your application without
    command lines. In this recipe, we are going to introduce Kubernetes dashboard.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes有一个WebUI，可以可视化资源和机器的状态，并且还可以作为管理应用程序的附加界面，无需使用命令行。在这个示例中，我们将介绍Kubernetes仪表板。
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Kubernetes dashboard ([https://github.com/kubernetes/dashboard](https://github.com/kubernetes/dashboard))
    is like a server-side application. In the beginning, just make sure you have a
    healthy Kubernetes cluster running, and we will go through the installation and
    related setup in the coming pages. Since the dashboard will be accessed by the
    browser, we can use a minikube-booted, laptop-running Kubernetes system, and reduce
    procedures for forwarding network ports or setting firewall rules.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes仪表板（[https://github.com/kubernetes/dashboard](https://github.com/kubernetes/dashboard)）就像一个服务器端应用程序。首先确保您有一个正常运行的Kubernetes集群，我们将在接下来的页面中进行安装和相关设置。由于仪表板将被浏览器访问，我们可以使用通过minikube引导的笔记本电脑运行的Kubernetes系统，并减少转发网络端口或设置防火墙规则的程序。
- en: 'For Kubernetes systems booting up by minikube, check that both minikube and
    the system itself are working:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通过minikube引导的Kubernetes系统，请检查minikube和系统本身是否正常工作：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: While booting up your Kubernetes system with minikube, it would help to create
    the dashboard by default. So, we will talk about both scenarios separately.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用minikube引导Kubernetes系统时，默认情况下会创建仪表板。因此，我们将分别讨论这两种情况。
- en: Relying on the dashboard created by minikube
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖于minikube创建的仪表板
- en: 'Because the Kubernetes dashboard has been started, what we have do is to open
    the web UI with a specific URL. It is convenient; you just need to fire a command
    on your terminal:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Kubernetes仪表板已经启动，我们所要做的就是使用特定的URL打开Web UI。这很方便；您只需在终端上输入一个命令：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Then, you will see your favourite browser opening a new webpage, as we introduced
    in [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml), *Building Your Own
    Kubernetes Cluster*. Its URL will look like [http://MINIKUBE_VM_IP:30000/#!/overview?namespace=default](http://MINIKUBE_VM_IP:30000/#!/overview?namespace=default).
    Most of all, we bypass the expected network proxy and authentication procedures.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将看到您喜爱的浏览器打开一个新的网页，就像我们在[第1章](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml)中介绍的那样，*构建您自己的Kubernetes集群*。其URL将类似于[http://MINIKUBE_VM_IP:30000/#!/overview?namespace=default](http://MINIKUBE_VM_IP:30000/#!/overview?namespace=default)。最重要的是，我们绕过了预期的网络代理和身份验证程序。
- en: Creating a dashboard manually on a system using other booting tools
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动在系统上使用其他引导工具创建仪表板
- en: 'To run Kubernetes dashboard, we simply fire a command to apply a configuration
    file, and every resource is created automatically:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行Kubernetes仪表板，我们只需执行一个命令来应用一个配置文件，然后每个资源将自动创建：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, let''s use the command `kubectl proxy` to open a gateway connecting localhost
    and the API server. Then, we are good to access the dashboard via a browser:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用命令`kubectl proxy`打开一个连接本地主机和API服务器的网关。然后，我们就可以通过浏览器访问仪表板了：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once you see a halting result showing, as in the preceding code, you can now
    access the dashboard by URL: [http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/](http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/).
    There, you will see the following screen in your browser:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您看到类似于上述代码的停止结果，您现在可以通过URL访问仪表板：[http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/](http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/)。在那里，您将在浏览器中看到以下屏幕：
- en: '![](assets/1b64d4fc-7349-4385-bf46-7877f2e3fc06.png)The login portal of Kubernetes
    dashboard'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](assets/1b64d4fc-7349-4385-bf46-7877f2e3fc06.png)Kubernetes仪表板的登录门户
- en: 'To step into our demonstration quickly, we will take the token of an existed
    service account to log in with. No matter what booting tool you use, leveraging
    the one created by the dashboard is suitable in every case:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速进入我们的演示，我们将使用现有服务帐户的令牌进行登录。无论您使用什么引导工具，都可以在任何情况下利用仪表板创建的工具：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Copy the token and paste it into console on the browser, then, click SIGN IN:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 复制令牌并粘贴到浏览器控制台中，然后点击“登录”：
- en: '![](assets/fe682158-1db8-4f8a-8f62-041683a327a0.png)Authentication with the
    token of a service account'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](assets/fe682158-1db8-4f8a-8f62-041683a327a0.png)使用服务帐户的令牌进行身份验证
- en: 'Welcome to the dashboard home page:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到仪表板主页：
- en: '![](assets/9319f189-19d4-40e2-a573-e10dd4ec8e91.png)The home page of the Kubernetes
    dashboard'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](assets/9319f189-19d4-40e2-a573-e10dd4ec8e91.png)Kubernetes仪表板的主页
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Kubernetes dashboard has two main functions: inspecting the status of resources,
    and deploying resources. It can cover most of our works in the client terminal
    using the command `kubectl`, however, the graphic interface is more friendly.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes仪表板有两个主要功能：检查资源的状态和部署资源。它可以覆盖我们在客户端终端使用`kubectl`命令的大部分工作，但是图形界面更加友好。
- en: Browsing your resource by dashboard
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过仪表板浏览您的资源
- en: 'We can check both hardware and software resources on the dashboard. For example,
    to take a look at the nodes a cluster, click on **Nodes** under the **Cluster**
    section in the left-hand menu; every node in the current cluster will be shown
    on the page, with some basic information:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在仪表板上检查硬件和软件资源。例如，要查看集群中的节点，请在左侧菜单的“集群”部分下点击“节点”；当前集群中的每个节点将显示在页面上，并附有一些基本信息：
- en: '![](assets/9d2d70c8-65d3-4df0-aebb-133b8dda5fb4.png)The status of Kubernetes
    nodes on the dashboard'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](assets/9d2d70c8-65d3-4df0-aebb-133b8dda5fb4.png)仪表板上Kubernetes节点的状态
- en: 'Your result on screen may be different from the preceding screenshot, since
    it will be based on your environment. Go ahead and click on the name of one node;
    even more details will be shown. Some of them are illustrated in beautiful graphs:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您屏幕上的结果可能与上述截图不同，因为它将基于您的环境。继续点击一个节点的名称；甚至会显示更多详细信息。其中一些以美丽的图表呈现：
- en: '![](assets/b21650a8-65fe-4a70-91b4-40202faef84a.png)Computing the resource
    status of a node'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](assets/b21650a8-65fe-4a70-91b4-40202faef84a.png)计算节点资源状态
- en: 'To show software resources, let''s take a look at the one holding this dashboard.
    In the left-hand menu, change the Namespace to kube-system and click Overview,
    which gathers all the resources under this Namespace. It is easy to find out any
    issue by putting resources together on a single page with a clear diagram:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 展示软件资源，让我们来看看持有这个仪表板的资源。在左侧菜单中，将Namespace更改为kube-system，并单击概述，这将汇总该Namespace下的所有资源。通过在单个页面上将资源放在一起并使用清晰的图表，很容易找出任何问题：
- en: '![](assets/11aa609b-d4d3-4783-87b8-57b89b183d4c.png)Resource overview of the
    namespace kube-system'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/11aa609b-d4d3-4783-87b8-57b89b183d4c.png)kube-system命名空间的资源概述'
- en: 'There''s more; click on the Deployments kubernetes-dashboard, and then click
    the small text-file icon on the right side of the only pod in the replica set.
    You can see the logs for the container:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多；单击kubernetes-dashboard的部署，然后单击副本集中唯一pod右侧的小文本文件图标。您可以查看容器的日志：
- en: '![](assets/7a0b7ba5-205e-4995-b015-6208a8201d26.png)Deployment information
    of kubernetes-dashboard![](assets/19522040-4c1e-4172-8d41-472b089eb917.png) Logs
    of the dashboard application'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/7a0b7ba5-205e-4995-b015-6208a8201d26.png)kubernetes-dashboard的部署信息![](assets/19522040-4c1e-4172-8d41-472b089eb917.png)仪表板应用程序的日志'
- en: Now, we have seen that Kubernetes dashboard provides a brilliant interface for
    displaying resource status, covering nodes, Kubernetes workloads and controllers,
    and the application log.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经看到Kubernetes仪表板提供了一个出色的界面，用于显示资源状态，包括节点、Kubernetes工作负载和控制器，以及应用程序日志。
- en: Deploying resources by dashboard
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过仪表板部署资源
- en: 'Here, we will prepare a YAML configuration file for creating Kubernetes Deployments
    and related Services under a new Namespace. It will be used to build resources
    through the dashboard:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将准备一个YAML配置文件，用于在新的Namespace下创建Kubernetes部署和相关服务。它将用于通过仪表板构建资源：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: First, click the CREATE button on the top right side of the web page.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，单击网页右上角的CREATE按钮。
- en: 'There are three methods for deployment. Let''s choose the second one and upload
    the configuration file introduced previously. Click the UPLOAD button:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 部署有三种方法。让我们选择第二种方法并上传先前介绍的配置文件。单击UPLOAD按钮：
- en: '![](assets/68c65a6f-4f65-4b33-938f-092e0f640ffb.png)Creating a resource by
    configuration file'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/68c65a6f-4f65-4b33-938f-092e0f640ffb.png)通过配置文件创建资源'
- en: 'Unfortunately, errors happened:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，发生了错误：
- en: '![](assets/e78630f7-bc05-4fae-a611-b9fe02e43992.png)Error message for problems
    due to bad deployment'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/e78630f7-bc05-4fae-a611-b9fe02e43992.png)由于错误部署而导致的问题的错误消息'
- en: Dashboard displays the resource according to a given Namespace, which is picked
    by *user* on the left-hand menu. This error message popped up and told users that
    the Namespace mentioned in the file does not match to dashboard one. What we have
    to do is to create a new Namespace and switch to it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板根据左侧菜单上*用户*选择的Namespace显示资源。此错误消息弹出并告诉用户，文件中提到的Namespace与仪表板中的不匹配。我们需要做的是创建一个新的Namespace并切换到它。
- en: 'This time, we are going to create a Namespace using plain text. Click the CREATE button
    again, and pick the create from text input method. Paste the following lines for
    a new Namespace to the web page:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将使用纯文本创建一个Namespace。再次单击CREATE按钮，并选择从文本输入方法创建。将以下行粘贴到网页上以创建一个新的Namespace：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we have a new Namespace, `dashboard-test`. Choose it as the main Namespace
    on the dashboard, and submit the `my-nginx.yaml` file again:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个新的Namespace，`dashboard-test`。在仪表板上选择它作为主Namespace，并再次提交`my-nginx.yaml`文件：
- en: '![](assets/f458157c-6ead-44c7-b3e5-deaaf4022df2.png)Picking a correct Namespace
    before submitting the configuration file'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/f458157c-6ead-44c7-b3e5-deaaf4022df2.png)在提交配置文件之前选择正确的Namespace'
- en: 'Now you can see the overview of this deployment! Yellow circles mean the pending
    status. They will turn to green once the pods are ready, or turn to red if they
    failed, but you will not see red ones if you are following these steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以查看此部署的概述！黄色圆圈表示挂起状态。一旦pod准备就绪，它们将变为绿色，或者如果失败，它们将变为红色，但是如果您按照以下步骤操作，您将看不到红色的圆圈：
- en: '![](assets/68af09be-08da-4a67-a923-44a844f8d51b.png)Status graph of creating
    a resource'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 创建资源的状态图
- en: Removing resources by dashboard
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过仪表板删除资源
- en: 'We can also remove Kubernetes resources through the dashboard. Try to find
    the Service `my-nginx` we just created by yourself! Perform the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过仪表板删除Kubernetes资源。尝试自己找到我们刚刚创建的Service `my-nginx`！执行以下操作：
- en: Change the Namespace on the left-hand menu to dashboard-test
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左侧菜单上更改Namespace为dashboard-test
- en: Click Services under the Discovery and load balancing section on left-hand menu
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击左侧菜单中的Discovery and load balancing部分下的Services
- en: Click the Service my-nginx on the hyperlinked name
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击超链接名称上的Service my-nginx
- en: Click DELETE at the top right of the page, below the CREATE button
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击页面右上角的DELETE，位于CREATE按钮下方
- en: That's it! Once you see your screen launching a message for confirmation, just
    click it. Finally, you have not only created a resource but also removed it from
    the Kubernetes dashboard.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！一旦您看到屏幕上弹出确认消息，只需单击即可。最后，您不仅创建了一个资源，还从Kubernetes仪表板中删除了它。
- en: See also
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: This recipe described how to launch a web interface that will help with easily
    exploring and managing Kubernetes instances, such as pods, deployments, and services,
    without the `kubectl` command. Please refer to the following recipes on how to
    get detailed information via the `kubectl` command.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程介绍了如何启动一个Web界面，以便轻松地探索和管理Kubernetes实例，如pod、部署和服务，而无需使用`kubectl`命令。请参考第2章中的以下教程，了解如何通过`kubectl`命令获取详细信息。
- en: The *Working with Pods*, *Deployment API*, and *Working with Services* recipes
    in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking through Kubernetes
    Concepts*
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中的*使用Pod*、*部署API*和*使用服务*教程，深入了解Kubernetes概念
- en: Working with the RESTful API
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RESTful API进行操作
- en: Users can control Kubernetes clusters via the `kubectl` command; it supports
    local and remote execution. However, some administrators or operators may need
    to integrate a program to control the Kubernetes cluster.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过`kubectl`命令控制Kubernetes集群；它支持本地和远程执行。但是，一些管理员或操作员可能需要集成一个程序来控制Kubernetes集群。
- en: Kubernetes has a RESTful API that controls Kubernetes clusters via an API, similar
    to the `kubectl` command. Let's learn how to manage Kubernetes resources by submitting
    API requests.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes具有一个RESTful API，通过API控制Kubernetes集群，类似于`kubectl`命令。让我们学习如何通过提交API请求来管理Kubernetes资源。
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, to bypass additional network settings and having to verify
    permissions, we will demonstrate the a *minikube-*created cluster with a Kubernetes
    proxy: it is easy to create a Kubernetes cluster on the host, and enable local
    proximity to an API server with a proxy entry.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，为了绕过额外的网络设置和验证权限，我们将演示使用*minikube-*创建的集群与Kubernetes代理：在主机上轻松创建Kubernetes集群，并使用代理条目启用对API服务器的本地接近。
- en: 'First, run up a proxy for fast API request forwarding:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，运行代理以快速转发API请求：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Having worked with Kubernetes proxy for a while, you may find it is somehow
    annoying that the command `kubectl proxy` is a halt process on your terminal,
    forcing you to open a new channel for the following commands. To avoid this, just
    add & as the last parameter in your command. This `&` symbol in the shell will
    make your command run in the background:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Kubernetes代理工作一段时间后，您可能会发现`kubectl proxy`命令会在终端上停止，迫使您为后续命令打开一个新的通道，这有点让人讨厌。为了避免这种情况，只需在命令的最后一个参数中添加`&`。在shell中，这个`&`符号将使您的命令在后台运行：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Be aware that you should kill this process manually if you don''t use the proxy:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您不使用代理，应手动终止此进程：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, it is good to try the endpoint with a simple path, `/api`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，尝试使用简单的路径“/api”来测试终端点：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once you see some basic API server information showing as in the preceding code,
    congratulations! You can now play with the kubernetes RESTful API of Kubernetes.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您看到一些基本的API服务器信息显示在前面的代码中，恭喜！您现在可以使用Kubernetes的Kubernetes RESTful API进行操作。
- en: '**A secured way to access the Kubernetes API server**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问Kubernetes API服务器的安全方式**'
- en: 'However, if you consider accessing a more secure API server, likes a kubeadm
    cluster, the following items should be taken care of:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您考虑访问更安全的API服务器，比如kubeadm集群，则应注意以下事项：
- en: The endpoint of the API server
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API服务器的终端点
- en: Token for authentication
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于身份验证的令牌
- en: 'We can get the required information through the following commands. And you
    can successfully fire the API request for the version:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令获取所需的信息。然后，您可以成功地请求版本的API：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'On the other hand, you may see a message showing `permission denied` when accessing
    resources in kubeadm. If so, the solution is to bind the default service account
    to the role of administrator, that is `cluster-admin` in kubeadm system. We provide
    the configuration file `rbac.yaml` in the code bundle; please check it out if
    you need it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当在kubeadm中访问资源时，您可能会看到显示“权限被拒绝”的消息。如果是这样，解决方案是将默认服务账户绑定到管理员角色，即kubeadm系统中的`cluster-admin`。我们在代码包中提供了配置文件`rbac.yaml`，如果需要，请查看：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Be careful of the  `--insecure` flags, since the endpoint using HTTPS protocol,
    and `-H`, add headers with a token. These are the additional ones comparing with
    our naive demonstration settings.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 小心使用`--insecure`标志，因为终端点使用HTTPS协议，而`-H`则添加带有令牌的标头。这些是与我们的天真演示设置相比的额外设置。
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In this section, we will show you how to manage resources through the RESTful
    API. Generally, the command line pattern of `curl` will cover the following ideas:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何通过RESTful API管理资源。通常，`curl`的命令行模式将涵盖以下想法：
- en: '**The operation**: `curl` without an indicating operation will fire `GET` by
    default. To specify your operation, add one with the `X` flag.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作**：`curl`没有指定操作将默认触发`GET`。要指定操作，请添加`X`标志。'
- en: '**The body data**: Like creating a Kubernetes resource through `kubectl`, we
    apply resource configuration with the `d` flag. The value with symbol `@` can
    attach a file. Additionally, the `h` flag helps to add request headers; here we
    need to add content type in the JSON format.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主体数据**：就像使用`kubectl`创建Kubernetes资源一样，我们使用`d`标志应用资源配置。带有`@`符号的值可以附加一个文件。此外，`h`标志有助于添加请求标头；在这里，我们需要以JSON格式添加内容类型。'
- en: '**The URL**: There are various paths after the endpoint, based on different
    functions.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL**：在终端点之后有各种路径，基于不同的功能。'
- en: 'Let''s create a deployment using the following JSON configuration file:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下JSON配置文件创建一个部署：
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can get every function in the API reference page ([https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/)).
    It is similar to searching for the configuration of a resource while writing up
    a configuration file. To submit an API request, you should know what kind of resource
    to work on, and what operation to perform on it. Perform the following procedures
    to find the corresponding information on the reference webpage:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在API参考页面中找到每个功能（[https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/)）。这类似于在编写配置文件时搜索资源的配置。要提交API请求，您应该知道要处理哪种资源，以及要在其上执行什么操作。执行以下步骤在参考网页上找到相应的信息：
- en: Choose an resource.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个资源。
- en: Choose an operation, for example, read or write.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个操作，例如读取或写入。
- en: Choose the details of the operation, for example, Create or Delete.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择操作的详细信息，例如创建或删除。
- en: The information will show in the middle panel of the webpage. An optional step
    is to switch `kubectl` to `curl` on the top right of the console. More details
    such as command flags will show on the right panel.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信息将显示在网页的中间面板上。一个可选的步骤是在控制台右上角将`kubectl`切换到`curl`。更多细节，比如命令标志，将显示在右侧面板上。
- en: 'To check the information for creating a Deployment, your web console may look
    as it does in this screenshot:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查创建部署的信息，您的Web控制台可能看起来像这个屏幕截图一样：
- en: '![](assets/27576170-067f-4473-ad48-66beacb359aa.png)The steps finding the path
    for API using to create a deployment'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/27576170-067f-4473-ad48-66beacb359aa.png)使用API创建部署的路径查找步骤'
- en: 'Based on the reference page, we can combine a specified `curl` command and
    fire a request now:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 根据参考页面，我们可以组合一个指定的`curl`命令并立即发出请求：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For a successful request, the server returns the status of the resource. Go
    ahead and check if we can find the new Deployment through the `kubectl` command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于成功的请求，服务器将返回资源的状态。继续检查是否可以通过`kubectl`命令找到新的部署：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Of course, it also works while checking it via the RESTful API:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以通过RESTful API进行检查：
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, try to delete this new Deployment, `my-nginx`, as well. It is a kind
    of `write` operation:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试删除这个新的Deployment，`my-nginx`，这也是一种`写`操作：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The RESTful API allows CRUD (Create, Read, Update, and Delete) operations, which
    are the same concepts behind every modern web application. For more details, please
    refer to [https://en.wikipedia.org/wiki/Create,_read,_update_and_delete](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API允许CRUD（创建、读取、更新和删除）操作，这是每个现代Web应用程序背后的相同概念。有关更多详细信息，请参阅[https://en.wikipedia.org/wiki/Create,_read,_update_and_delete](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete)。
- en: 'According to the CRUD structure, the Kubernetes RESTful API has the following
    basic method:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 根据CRUD结构，Kubernetes RESTful API具有以下基本方法：
- en: '| **Operation** | **HTTP Method** | **Example** |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **HTTP方法** | **示例** |'
- en: '| Create | `POST` | `POST /api/v1/namespaces/default/pods` |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | `POST` | `POST /api/v1/namespaces/default/pods` |'
- en: '| Read | `GET` | `GET /api/v1/componentstatuses` |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 读取 | `GET` | `GET /api/v1/componentstatuses` |'
- en: '| Update | `PUT` | `PUT /apis/apps/v1/namespaces/default/deployments/my-nginx`
    |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 更新 | `PUT` | `PUT /apis/apps/v1/namespaces/default/deployments/my-nginx`
    |'
- en: '| Delete | `DELETE` | `DELETE /api/v1/namespaces/default/services/nginx-service`
    |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | `DELETE` | `DELETE /api/v1/namespaces/default/services/nginx-service`
    |'
- en: As we mentioned in the recipe *Working with configuration files* in [Chapter
    3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml), *Playing with Containers*, Kubernetes
    builds the RESTful API with *swagger* ([https://swagger.io/](https://swagger.io))
    and OpenAPI ([https://www.openapis.org](https://www.openapis.org)). We can open
    the swagger UI console of your cluster to check the API functions. Nevertheless,
    it is recommended that you check them through the official website, the one we
    demonstrated in the last section. The description on the website is more elaborate
    and user-friendly.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)的*使用配置文件*配方中提到的，Kubernetes使用*swagger*（[https://swagger.io/](https://swagger.io)）和OpenAPI（[https://www.openapis.org](https://www.openapis.org)）构建RESTful
    API。我们可以打开集群的swagger UI控制台来检查API功能。然而，建议您通过官方网站进行检查，就像我们在上一节中演示的那样。网站上的描述更加详细和用户友好。
- en: There's more...
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'An even more programmatic way to utilize Kubernetes API is to use the client
    library ([https://kubernetes.io/docs/reference/client-libraries/](https://kubernetes.io/docs/reference/client-libraries/)).
    Making good use of these client tools not only saves you time in resource management,
    but also produce a robust and reliable CI/CD environment. Here, we would like
    to introduce the Kubernetes client library for Python: [https://github.com/kubernetes-client/python](https://github.com/kubernetes-client/python).
    To start, you should install the Python library for Kubernetes:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 更加程序化的利用Kubernetes API的方法是使用客户端库（[https://kubernetes.io/docs/reference/client-libraries/](https://kubernetes.io/docs/reference/client-libraries/)）。充分利用这些客户端工具不仅可以节省资源管理时间，还可以产生稳健可靠的CI/CD环境。在这里，我们想介绍Python的Kubernetes客户端库：[https://github.com/kubernetes-client/python](https://github.com/kubernetes-client/python)。首先，您应该安装Kubernetes的Python库：
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, please put the following Python file at the same location as the JSON
    configuration file, `nginx-deployment.json`, where firing `kubectl` does work
    on the system:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，请将以下Python文件放在与JSON配置文件`nginx-deployment.json`相同的位置，其中在系统上运行`kubectl`有效：
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You don''t even enable the Kubernetes proxy now; continue to run this script
    directly and see what happens:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在甚至不需要启用Kubernetes代理；继续直接运行此脚本，看看会发生什么：
- en: '[PRE53]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: See also
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'This recipe described how to use the Kubernetes RESTful API via a program.
    It is important to integrate this with your automation program remotely. For detailed
    parameter and security enhancement, please refer to the following recipes:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本文介绍了如何通过程序使用Kubernetes RESTful API。将其与远程自动化程序集成非常重要。有关详细参数和安全增强，请参考以下配方：
- en: The *Working with configuration files* recipe in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)中的*使用配置文件*配方，*与容器一起玩*'
- en: The *Authentication and authorization* recipe in [Chapter 7](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Building Kubernetes on GCP*
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)中的*身份验证和授权*配方，*在GCP上构建Kubernetes*'
- en: Working with Kubernetes DNS
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes DNS
- en: When you deploy many pods to a Kubernetes cluster, service discovery is one
    of the most important functions, because pods may depend on other pods but the
    IP address of a pod will be changed when it restarts. You need to have a flexible
    way to communicate a pod's IP address to other pods. Kubernetes has an add-on
    feature called `kube-dns` that helps in this scenario. It can register and look
    up an IP address for pods and Kubernetes Services.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将许多Pod部署到Kubernetes集群时，服务发现是最重要的功能之一，因为Pod可能依赖于其他Pod，但是当Pod重新启动时，其IP地址将发生变化。您需要一种灵活的方式来将Pod的IP地址传达给其他Pod。Kubernetes有一个名为`kube-dns`的附加功能，可以帮助解决这种情况。它可以为Pod和Kubernetes服务注册和查找IP地址。
- en: In this section, we will explore how to use `kube-dns`, which gives you a flexible
    way to configure DNS in your Kubernetes cluster.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用`kube-dns`，它为您提供了一种灵活的方式来配置Kubernetes集群中的DNS。
- en: Getting ready
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Since Kubernetes version 1.3, `kube-dns` has come with Kubernetes and is enabled
    by default. To check whether `kube-dns` is working or not, check the `kube-system`
    namespace with the following command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 自Kubernetes版本1.3以来，`kube-dns`已经随Kubernetes一起提供，并且默认情况下已启用。要检查`kube-dns`是否工作，请使用以下命令检查`kube-system`命名空间：
- en: '[PRE54]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you are using minikube, type the following command to see the addon''s status:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用minikube，请输入以下命令来查看插件的状态：
- en: '[PRE55]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If it shows as disabled, you need to enable it using the following command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果显示为禁用状态，则需要使用以下命令启用它：
- en: '[PRE56]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In addition, prepare two namespaces, `chap8-domain1` and `chap8-domain2`, to
    demonstrate how `kube-dns` assigns domain names:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，准备两个命名空间`chap8-domain1`和`chap8-domain2`，以演示`kube-dns`如何分配域名：
- en: '[PRE57]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How to do it...
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: '`kube-dns` assigns the **fully** **qualified domain name** (**FQDN**) to pods
    and Kubernetes Services. Let''s look at some differences.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`kube-dns`为pod和Kubernetes服务分配**完全** **限定域名**（**FQDN**）。让我们看看一些不同之处。'
- en: DNS for pod
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pod的DNS
- en: Kubernetes assigns the domain name for the pod as `<IP address>.<Namespace name>.pod.cluster.local`.
    Because it uses the pod's IP address, FQDN is not guaranteed to be present permanently,
    but it is nice to have in case an application needs FQDN.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes为pod分配的域名为`<IP地址>.<命名空间名称>.pod.cluster.local`。因为它使用了pod的IP地址，所以FQDN不能保证永久存在，但如果应用程序需要FQDN，那么拥有它是很好的。
- en: 'Let''s deploy apache2 (`httpd`) on `chap8-domain1` and `chap8-domain2`, as
    follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`chap8-domain1`和`chap8-domain2`上部署apache2（`httpd`），如下所示：
- en: '[PRE58]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Type `kubectl get pod -o wide` to capture an IP address for those pods:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 键入`kubectl get pod -o wide`以捕获这些pod的IP地址：
- en: '[PRE59]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This shows that `my-apache-55fb679f49-qw58f` on `chap8-domain1` uses `172.17.0.4`.
    On the other hand, `my-apache-55fb679f49-z9gsr` on `chap8-domain2` uses `172.17.0.5`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了`chap8-domain1`上的`my-apache-55fb679f49-qw58f`使用`172.17.0.4`。另一方面，`chap8-domain2`上的`my-apache-55fb679f49-z9gsr`使用`172.17.0.5`。
- en: 'In this case, the FQDN would be:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，FQDN将是：
- en: '`172-17-0-4.chap8-domain1.pod.cluster.local` (`chap8-domain1`)'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`172-17-0-4.chap8-domain1.pod.cluster.local` (`chap8-domain1`)'
- en: '`172-17-0-5.chap8-domain2.pod.cluster.local` (`chap8-domain2`)'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`172-17-0-5.chap8-domain2.pod.cluster.local` (`chap8-domain2`)'
- en: Note that the dots (`.`) in the IP address are changed to hyphens (`-`). This
    is because the dot is a delimiter to determine subdomains.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，IP地址中的点（`.`）被更改为连字符（`-`）。这是因为点是用来确定子域的分隔符。
- en: 'To check whether name resolution works or not, launch the busybox pod in the
    foreground (using the `-it` option). Then use the `nslookup` command to resolve
    FQDN to the IP address, as in the following steps:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查名称解析是否有效，请在前台启动`busybox` pod（使用`-it`选项）。然后使用`nslookup`命令来解析FQDN到IP地址，如下面的步骤所示：
- en: 'Run `busybox` with the `-it` option:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-it`选项运行`busybox`：
- en: '[PRE60]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the busybox pod, type `nslookup` to resolve the FQDN of apache on `chap8-domain1`:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在busybox pod中，键入`nslookup`来解析`chap8-domain1`上apache的FQDN：
- en: '[PRE61]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Also, type `nslookup` to resolve the FQDN of apache on `chap8-domain`2:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要输入`nslookup`来解析`chap8-domain`2上apache的FQDN：
- en: '[PRE62]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Exit the busybox pod, then delete it to release a resource:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出busybox pod，然后删除它以释放资源：
- en: '[PRE63]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: DNS for Kubernetes Service
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes服务的DNS
- en: First of all, DNS for Kubernetes Service is most important from the service
    discovery point of view. This is because an application usually connects to Kubernetes
    Service instead of connecting to the pod. This is why the application looks up
    the DNS entry for Kubernetes Service more often than for the pod.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从服务发现的角度来看，Kubernetes服务的DNS是最重要的。这是因为应用程序通常连接到Kubernetes服务，而不是连接到pod。这就是为什么应用程序更经常查找Kubernetes服务的DNS条目，而不是查找pod的原因。
- en: Secondly, the DNS entry for Kubernetes Service will use the name of Kubernetes
    Service instead of an IP address. For instance, it will look like this: `<Service
    Name>.<Namespace name>.svc.cluster.local`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，Kubernetes服务的DNS条目将使用Kubernetes服务的名称而不是IP地址。例如，它看起来像这样：`<服务名称>.<命名空间名称>.svc.cluster.local`。
- en: Lastly, Kubernetes Service has 2 different behaviors for DNS; either normal
    service or headless service. Normal service has its own IP address, while headless
    service uses the pod's IP address(es). Let's go through normal service first.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Kubernetes服务对DNS有两种不同的行为；普通服务或无头服务。普通服务有自己的IP地址，而无头服务使用pod的IP地址。让我们先了解普通服务。
- en: 'Normal service is the default Kubernetes Service. It will assign an IP address.
    Perform the following steps to create a normal service and check how DNS works:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 普通服务是默认的Kubernetes服务。它将分配一个IP地址。执行以下步骤来创建一个普通服务并检查DNS的工作原理：
- en: 'Create a normal service for apache on `chap8-domain1` and `chap8-domain2`:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`chap8-domain1`和`chap8-domain2`上的apache创建一个普通服务：
- en: '[PRE64]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Check the IP address for those two services by running the following command:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令检查这两个服务的IP地址：
- en: '[PRE65]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In order to perform name resolution, use the busybox pod in the foreground:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进行名称解析，在前台使用busybox pod：
- en: '[PRE66]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the busybox pod, use the `nslookup` command to query the IP address of those
    two services:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在busybox pod中，使用`nslookup`命令查询这两个服务的IP地址：
- en: '[PRE67]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Access to service for apache whether traffic can dispatch to the backend apache
    pod:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问apache服务以查看流量是否可以分发到后端apache pod：
- en: '[PRE68]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Quit the `busybox` pod and delete it:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出`busybox` pod并删除它：
- en: '[PRE69]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: DNS for a normal service behaves as a proxy; traffic goes to the normal service,
    then dispatches to the pod. What about the headless service? This will be discussed
    in the *How it works...* section.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: DNS对于普通服务的行为类似于代理；流量会先到达普通服务，然后再分发到pod。那么无头服务呢？这将在*它是如何工作的...*部分进行讨论。
- en: DNS for StatefulSet
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StatefulSet的DNS
- en: StatefulSet was described in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*. It assigns a pod name with a sequence number—for example, `my-nginx-0`,
    `my-nginx-1`, `my-nginx-2`. StatefulSet also uses these pod names to assign a
    DNS entry instead of IP addresses. Because it uses Kubernetes Service, FQDN appear
    as follows: `<StatefulSet name>-<sequence number>.<Service name>.<Namespace name>.svc.cluster.local`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSet在[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)中有描述，*与容器一起玩耍*。它为pod名称分配一个序列号，例如，`my-nginx-0`，`my-nginx-1`，`my-nginx-2`。StatefulSet还使用这些pod名称来分配DNS条目，而不是IP地址。因为它使用Kubernetes服务，FQDN看起来如下：`<StatefulSet名称>-<序列号>.<服务名称>.<命名空间名称>.svc.cluster.local`。
- en: 'Let''s create StatefulSet to examine how DNS works in StatefulSet:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建StatefulSet来检查StatefulSet中DNS是如何工作的：
- en: 'Prepare StatefulSet and normal service YAML configurations as follows:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备StatefulSet和普通服务的YAML配置如下：
- en: '[PRE70]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Create StatefulSet on `chap8-domain2`:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chap8-domain2`上创建StatefulSet：
- en: '[PRE71]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Use the `kubectl` command to check the status of the pod and service creation:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl`命令检查pod和服务创建的状态：
- en: '[PRE72]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Launch the `busybox` pod in the foreground:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前台启动`busybox` pod：
- en: '[PRE73]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Use the `nslookup` command to query the service''s IP address:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`nslookup`命令查询服务的IP地址：
- en: '[PRE74]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Use the `nslookup` command to query the individual pod''s IP address:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`nslookup`命令查询单个pod的IP地址：
- en: '[PRE75]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Clean up the `busybox` pod:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理`busybox` pod：
- en: '[PRE76]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: How it works...
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have set up several components to see how DNS entries are created initially.
    The Kubernetes Service name is especially important for determining the name of
    a DNS.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了几个组件来查看最初如何创建DNS条目。Kubernetes服务名称对于确定DNS的名称尤为重要。
- en: However, Kubernetes Service has 2 modes, either normal service or headless service.
    Normal service has already been described in the preceding section; it has its
    own IP address. On the other hand, headless service doesn't have an IP address.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Kubernetes服务有两种模式，即普通服务或无头服务。普通服务已在前一节中描述过；它有自己的IP地址。另一方面，无头服务没有IP地址。
- en: 'Let''s see how to create a headless service and how name resolution works:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个无头服务以及名称解析是如何工作的：
- en: 'Create a headless service (specify `--cluster-ip=None`) for apache on `chap8-domain1`
    and `chap8-domain2`:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`chap8-domain1`和`chap8-domain2`上的apache创建一个无头服务（指定`--cluster-ip=None`）：
- en: '[PRE77]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Check there is no IP address for those two headless services with the following
    command:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查这两个无头服务是否没有IP地址：
- en: '[PRE78]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Launch the `busybox` pod in the foreground:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前台启动`busybox` pod：
- en: '[PRE79]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In the `busybox` pod, query those two services. It must show the addresses
    as the pod''s address (`172.168.0.4` and `172.168.0.5`):'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`busybox` pod中，查询这两个服务。它必须显示地址作为pod的地址（`172.168.0.4`和`172.168.0.5`）：
- en: '[PRE80]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Exit the `busybox` pod and delete it:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出`busybox` pod并删除它：
- en: '[PRE81]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Headless service when pods scale out
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无头服务在pod扩展时
- en: The preceding example shows only one IP address, because we have been setup
    only one Pod. What happens if you increase an instance using the `kubectl scale`
    command?
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例只显示一个IP地址，因为我们只设置了一个Pod。如果使用`kubectl scale`命令增加一个实例会发生什么？
- en: 'Let''s increase the Apache instances on `chap8-domain1` from 1 to 3, then see
    how the headless service DNS works:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`chap8-domain1`上的Apache实例数量从1增加到3，然后看看无头服务DNS是如何工作的：
- en: '[PRE82]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The result is straightforward: one DNS entry, `my-apache-svc-hl.chap8-domain1.svc.cluster.local` returns
    3 IP addresses. Therefore, when your HTTP client tries to access the Kubernetes
    Service `my-apache-svc-hl.chap8-domain1.svc.cluster.local`, it gets these 3 IP
    addresses from `kube-dns`, then accesses one of them directly, as shown in the
    following diagram:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 结果很简单：一个DNS条目，`my-apache-svc-hl.chap8-domain1.svc.cluster.local`返回3个IP地址。因此，当您的HTTP客户端尝试访问Kubernetes服务`my-apache-svc-hl.chap8-domain1.svc.cluster.local`时，它会从`kube-dns`获取这3个IP地址，然后直接访问其中一个，如下图所示：
- en: '![](assets/f93148d8-eea0-4c05-bc39-49c50ef4edcf.png)Sequence of accessing to
    Headless Service and pod'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/f93148d8-eea0-4c05-bc39-49c50ef4edcf.png)访问无头服务和pod的顺序'
- en: Therefore, Kubernetes headless service doesn't do any traffic dispatches. This
    is why it is called headless.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Kubernetes无头服务不进行任何流量分发。这就是为什么它被称为无头的。
- en: See also
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'This section described how `kube-dns` names pods and services in DNS. It is
    important to understand the differences between normal service and headless service
    to understand how to connect to your application. The StatefulSet use case was
    also described in the following recipe:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了`kube-dns`如何在DNS中为pod和服务命名。了解普通服务和无头服务之间的区别对于理解如何连接到您的应用程序非常重要。下一节还描述了StatefulSet的用例：
- en: '*Ensuring flexible usage of your containers* in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)中*，*确保容器的灵活使用*，*玩转容器*'
- en: Authentication and authorization
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证和授权
- en: Authentication and authorization are both crucial for a platform such as Kubernetes.
    Authentication ensures users are who they claim to be. Authorization verifies
    if users have sufficient permission to perform certain operations. Kubernetes
    supports various authentication and authorization plugins.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Kubernetes这样的平台，身份验证和授权都至关重要。身份验证确保用户是他们声称的那个人。授权验证用户是否有足够的权限执行某些操作。Kubernetes支持各种身份验证和授权插件。
- en: Getting ready
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: When a request comes to an API server, it firstly establishes a TLS connection
    by validating the clients' certificate with the **certificate authority** (**CA**)
    in the API server. The CA in the API server is usually at `/etc/kubernetes/`,
    and the clients' certificate is usually at `$HOME/.kube/config`. After the handshake,
    it goes to the authentication stage. In Kubernetes, authentication modules are
    chain-based. We can use more than one authentication module. When the request
    comes, Kubernetes will try all the authenticators one by one until it succeeds.
    If the request fails on all authentication modules, it will be rejected as HTTP
    401 unauthorized. Otherwise, one of the authenticators verifies the user's identity,
    and the requests are authenticated. Then, the Kubernetes authorization modules
    come into play. They verify if the *user* has the permission to do the action
    that they requested using a set of policies. Authorization modules are checked
    one by one. Just like authentication modules, if all modules are failed, the request
    will be denied. If the user is eligible to make the request, the request will
    pass through the authentication and authorization modules and go into admission
    control modules. The request will be checked by various admission controllers
    one by one. If any admission controller fails the request, the request will be
    rejected immediately.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求到达API服务器时，首先通过验证客户端的证书与API服务器中的**证书颁发机构**（**CA**）建立TLS连接。API服务器中的CA通常位于`/etc/kubernetes/`，客户端的证书通常位于`$HOME/.kube/config`。握手完成后，进入认证阶段。在Kubernetes中，认证模块是基于链的。我们可以使用多个认证模块。当请求到来时，Kubernetes将依次尝试所有认证器，直到成功。如果请求在所有认证模块上失败，将被拒绝为HTTP
    401未经授权。否则，其中一个认证器将验证用户的身份，并对请求进行认证。然后，Kubernetes授权模块开始发挥作用。它们验证*用户*是否有权限执行他们请求的操作，使用一组策略。授权模块逐一检查。就像认证模块一样，如果所有模块都失败，请求将被拒绝。如果用户有资格发出请求，请求将通过认证和授权模块，并进入准入控制模块。请求将逐一通过各种准入控制器进行检查。如果任何准入控制器拒绝请求，请求将立即被拒绝。
- en: 'The following diagram demonstrates this sequence:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表演示了这个顺序：
- en: '![](assets/34ebdbc5-c58c-44cb-af44-76c75ee70733.png)Requests passing through
    a Kubernetes API server'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/34ebdbc5-c58c-44cb-af44-76c75ee70733.png)通过Kubernetes API服务器传递的请求'
- en: How to do it...
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In Kubernetes, there are two types of account; service accounts and user accounts.
    The major difference between them is that user accounts are not stored and managed
    in Kubernetes itself. They cannot be added through API calls. The following table
    is a simple comparison:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，有两种类型的账户；服务账户和用户账户。它们之间的主要区别在于用户账户不存储和管理在Kubernetes本身。它们不能通过API调用添加。以下表格是一个简单的比较：
- en: '|  | **Service account** | **User account** |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '|  | **服务账户** | **用户账户** |'
- en: '| **Scope** | Namespaced | Global |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| **范围** | 命名空间 | 全局 |'
- en: '| **Used by** | Processes | Normal user |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| **被使用** | 进程 | 普通用户 |'
- en: '| **Created by** | API server or via API calls | Administrators, can''t be
    added via API calls |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| **由谁创建** | API服务器或通过API调用 | 管理员，不能通过API调用添加 |'
- en: '| **Managed by** | API server | Outside the cluster |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| **由谁管理** | API服务器 | 集群外部 |'
- en: 'Service accounts are used by processes inside a Pod to contact the API server.
    Kubernetes by default will create a service account named **default**. If there
    is no service account associated with a Pod, it''ll be assigned to the default
    service account:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户用于Pod内的进程与API服务器联系。Kubernetes默认会创建一个名为**default**的服务账户。如果一个Pod没有与服务账户关联，它将被分配给默认服务账户：
- en: '[PRE83]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We may find there is a Secret associated with this service account. This is
    controlled by the token controller manager. When a new service account is created,
    the controller will create a token and associate it with the service account with
    the `kubernetes.io/service-account.name` annotation, allowing API access. Token
    is in the Secret format in Kubernetes. Anybody with the Secret view permission
    can see the token. The following is an example of creating a service account:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会发现与此服务帐户关联的一个Secret。这由令牌控制器管理。当创建新的服务帐户时，控制器将创建一个令牌，并使用`kubernetes.io/service-account.name`注释将其与服务帐户关联，从而允许API访问。在Kubernetes中，令牌以Secret格式存在。拥有Secret查看权限的任何人都可以看到令牌。以下是创建服务帐户的示例：
- en: '[PRE84]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Authentication
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证
- en: There are several account authentication strategies supported in Kuberentes,
    from client certificates, bearer tokens, and static files to OpenID connect tokens.
    More than one option could be chosen and combined with others in authentication
    chains. In this recipe, we'll introduce how to use token, client certs, and OpenID
    connect token authenticators.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Kuberentes支持几种帐户认证策略，从客户端证书、持有者令牌和静态文件到OpenID连接令牌。可以选择多个选项，并与其他认证链组合使用。在本教程中，我们将介绍如何使用令牌、客户端证书和OpenID连接令牌进行认证。
- en: Service account token authentication
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务帐户令牌认证
- en: 'We''ve created a service account in the previous section; now, let''s see how
    to use a service account token to do the authentication. We''ll have to retrieve
    the token first:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个服务帐户；现在，让我们看看如何使用服务帐户令牌进行认证。我们首先需要检索令牌：
- en: '[PRE85]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We can see that the three items under the data are all base64-encoded. We can
    decode them easily with the `echo "encoded content" | base64 --decode` command
    in Linux. For example, we can decode encoded namespace content:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到数据下的三个项目都是base64编码的。我们可以在Linux中使用`echo "encoded content" | base64 --decode`命令轻松解码它们。例如，我们可以解码编码的命名空间内容：
- en: '[PRE86]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Using the same command we can get the bearer token and use it in a request.
    The API server expects a HTTP header of `Authorization: Bearer $TOKEN` along with
    the request. The following is an example of how to use the token to authenticate
    and make a request directly to the API server.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '使用相同的命令，我们可以获取令牌并在请求中使用它。API服务器期望在请求中使用`Authorization: Bearer $TOKEN`的HTTP头。以下是如何使用令牌进行身份验证并直接向API服务器发出请求的示例。'
- en: 'Firstly, we''ll have to get our decoded token:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要获取我们解码后的令牌：
- en: '[PRE87]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Secondly, we''ll have to decode `ca.crt` as well:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们还需要解码`ca.crt`：
- en: '[PRE88]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, we''ll need to know what the API server is. Using the `kubectl config
    view` command, we can get a list of servers:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要知道API服务器是什么。使用`kubectl config view`命令，我们可以得到服务器列表：
- en: '[PRE89]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Find the one you're currently using. In this example, we're using minikube.
    The server is at `https://192.168.99.100:8443`.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 找到您当前正在使用的。在这个例子中，我们正在使用minikube。服务器位于`https://192.168.99.100:8443`。
- en: You can use the `kubectl config current-context` command to find the current
    context.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`kubectl config current-context`命令找到当前上下文。
- en: Then we should be good to go! We'll request the API endpoint directly via `https://$APISERVER/api`
    with`--cacert` and `--header`
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们应该可以开始了！我们将通过`https://$APISERVER/api`直接请求API端点，使用`--cacert`和`--header`。
- en: '[PRE90]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We can see that the available version is `v1`. Let''s see what we have in `/api/v1`
    endpoint:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到可用版本是`v1`。让我们看看在`/api/v1`端点中有什么：
- en: '[PRE91]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'It will list all the endpoints and verbs we requested. Let''s take `configmaps`
    as an example and `grep` the name:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 它将列出我们请求的所有端点和动词。让我们以`configmaps`为例，并使用`grep`命令查找名称：
- en: '[PRE92]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'There are four default configmaps listed in my cluster in this example. We
    can use `kubectl` to verify this. The result should match the ones we previously
    got:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我的集群中列出了四个默认的configmaps。我们可以使用`kubectl`来验证这一点。结果应该与我们之前得到的相匹配：
- en: '[PRE93]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: X509 client certs
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: X509客户端证书
- en: 'A common authentication strategy for user accounts is to use client certificates.
    In the following example, we''ll create a user named Linda and generate a client
    cert for her:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 用户帐户的常见身份验证策略是使用客户端证书。在下面的示例中，我们将创建一个名为琳达的用户，并为她生成一个客户端证书：
- en: '[PRE94]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Next, we''ll generate a cert for Linda via a private key and sign request files,
    along with the CA and private key of our cluster:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过私钥和签名请求文件为琳达生成一个证书，以及我们集群的CA和私钥：
- en: In minikube, it's under `~/.minikube/`. For other self-hosted solutions, normally
    it's under `/etc/kubernetes/`. If you use `kops` to deploy the cluster, the location
    is under `/srv/kubernetes`, where you can find the path in the`/etc/kubernetes/manifests/kube-apiserver.manifest`
    file.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在minikube中，它位于`~/.minikube/`。对于其他自托管解决方案，通常位于`/etc/kubernetes/`下。如果您使用`kops`部署集群，则位置位于`/srv/kubernetes`下，您可以在`/etc/kubernetes/manifests/kube-apiserver.manifest`文件中找到路径。
- en: '[PRE95]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We got Linda signed by our cluster cert; now we can set it into our `kubeconfig`
    file:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用我们集群证书签署了琳达；现在我们可以将其设置到我们的`kubeconfig`文件中：
- en: '[PRE96]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We can use `kubectl config view` to verify the user is set:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`kubectl config view`来验证用户是否已设置：
- en: '[PRE97]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'After the user is created, we can create a context to associate the namespace
    and cluster with this user:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户后，我们可以创建一个上下文，将命名空间和集群与该用户关联起来：
- en: '[PRE98]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: After that, Kubernetes should be able to identify linda and pass it to the authorization
    stage.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，Kubernetes应该能够识别琳达并将其传递到授权阶段。
- en: OpenID connect tokens
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenID连接令牌
- en: 'Another popular authentication strategy is OpenID connect tokens. Delegating
    the identity verification to OAuth2 providers, is a convenient way to manage users.
    To enable the feature, two required flags have to be set to the API server: `--oidc-issuer-url`,
    which indicates the issuer URL that allows the API server to discover public signing
    keys, and `--oidc-client-id`, which is the client ID of your app to associate
    with your issuer. For full information, please refer to the official documentation
    [https://kubernetes.io/docs/admin/authentication/#configuring-the-api-server](https://kubernetes.io/docs/admin/authentication/#configuring-the-api-server).
    The following is an example of how we set Google OpenID authentication with our
    minikube cluster. The following steps can be programmed easily for authentication
    usage.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种流行的身份验证策略是OpenID连接令牌。将身份验证委托给OAuth2提供程序是管理用户的一种便利方式。要启用该功能，必须将两个必需的标志设置为API服务器：`--oidc-issuer-url`，它指示发行者URL，允许API服务器发现公共签名密钥，以及`--oidc-client-id`，它是要与发行者关联的应用程序的客户端ID。有关完整信息，请参阅官方文档[https://kubernetes.io/docs/admin/authentication/#configuring-the-api-server](https://kubernetes.io/docs/admin/authentication/#configuring-the-api-server)。以下是我们如何在minikube集群中设置Google
    OpenID身份验证的示例。以下步骤可以轻松地用于身份验证用途。
- en: 'To start, we''ll have to request a set consisting of the client ID, client
    secret, and redirect URL from Google. The following are the steps for requesting
    and downloading the secret from Google:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将不得不从Google请求一组由客户端ID、客户端密钥和重定向URL组成的集合。以下是从Google请求和下载密钥的步骤：
- en: In GCP console, go to APIs & Services | Credentials | Create credentials | OAuth
    client ID.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GCP控制台中，转到API和服务|凭据|创建凭据|OAuth客户端ID。
- en: Choose Other in application type and click Create.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序类型中选择其他，然后单击创建。
- en: Download the JSON file.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载JSON文件。
- en: 'After this, the credential is successfully created. We can take a look at the
    JSON file. The following is the file we got from our example project kubernetes-cookbook:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，凭据已成功创建。我们可以查看JSON文件。以下是我们从示例项目kubernetes-cookbook中获得的文件：
- en: '[PRE99]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now, we should be able to start our cluster. Don''t forget the OIDC flags have
    to be passed on. In minikube, this is done via the `--extra-config` parameter:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够启动我们的集群。不要忘记必须传递OIDC标志。在minikube中，可以通过`--extra-config`参数来完成：
- en: '[PRE100]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'After the cluster is started, the user has to log in to the identity provider
    in order to get `access_token`*,* `id_token`*,* and `refresh_token`. In Google, you''ll
    get a code after login, and you pass the code with the request to get the tokens.
    Then we pass the token to the request to the API server via kubectl. The following
    is the sequence diagram for this:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 集群启动后，用户必须登录到身份提供者以获取`access_token`、`id_token`和`refresh_token`。在Google中，登录后您将获得一个代码，然后将代码与请求一起传递以获取令牌。然后，我们通过kubectl将令牌传递给API服务器的请求。以下是此过程的顺序图：
- en: '![](assets/d0012bfc-9d77-400a-9ba7-1ff5acc5f21c.png)Time diagram of Google
    OpenID connect authentication'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/d0012bfc-9d77-400a-9ba7-1ff5acc5f21c.png)Google OpenID连接身份验证的时间图'
- en: 'To request the code, your app should send the HTTP request in the following
    format:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 要请求代码，您的应用程序应以以下格式发送HTTP请求：
- en: '[PRE101]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Then, a browser window will pop out to ask for sign in to Google. After signing
    in, the code will be shown in the console:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一个浏览器窗口将弹出要求登录到Google。登录后，代码将显示在控制台中：
- en: '![](assets/d7a66cd3-ece7-4f59-b157-7f5c33543105.png)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d7a66cd3-ece7-4f59-b157-7f5c33543105.png)'
- en: 'Next, we pass the code for requesting the token to `https://www.googleapis.com/oauth2/v4/token`.
    Then, we should be able to get `access_token`, `refresh_token`, and `id_token`
    from the response:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们传递请求令牌的代码到`https://www.googleapis.com/oauth2/v4/token`。然后，我们应该能够从响应中获取`access_token`、`refresh_token`和`id_token`：
- en: '[PRE102]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Assume we''ll have the user `chloe-k8scookbook@gmail.com` to associate with
    this Google account. Let''s create it in our cluster. We can append user information
    into our kubeconfig. The default location of the file is `$HOME/.kube/config`:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将用户`chloe-k8scookbook@gmail.com`与此Google帐户关联。让我们在我们的集群中创建它。我们可以将用户信息附加到我们的kubeconfig中。文件的默认位置是`$HOME/.kube/config`：
- en: '[PRE103]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'After that, let''s use the user to list nodes and see if it can pass the authentication:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，让我们使用用户列出节点并查看是否可以通过身份验证：
- en: '[PRE104]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We encounter an authorization error! After verifying the identity, the next
    step will be checking if the user has sufficient rights to perform the request.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了授权错误！在验证身份后，下一步将是检查用户是否有足够的权限来执行请求。
- en: Authorization
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: After passing the authentication phase, authorizers take place. Before we move
    on to authorization strategies, let's talk about `Role` and `RoleBinding` first.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 经过身份验证阶段后，授权者开始工作。在我们继续讨论授权策略之前，让我们先谈谈`Role`和`RoleBinding`。
- en: Role and RoleBinding
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Role和RoleBinding
- en: '`Role` in Kubernetes contains a set of rules. A rule defines a set of permissions
    for certain operations and resources by specifying `apiGroups`, `resources`, and
    `verbs`. For example, the following role defines a read-only rule for `configmaps`:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的`Role`包含一组规则。规则通过指定`apiGroups`、`resources`和`verbs`来定义某些操作和资源的权限集。例如，以下角色定义了对`configmaps`的只读规则：
- en: '[PRE105]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'A `RoleBinding` is used to associate a role with a list of accounts. The following
    example shows we assign the `configmap-ro` role to a list of subjects. It only
    has the user `linda` in this case:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoleBinding`用于将角色与帐户列表关联。以下示例显示我们将`configmap-ro`角色分配给一组主体。在这种情况下，只有用户`linda`：'
- en: '[PRE106]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '`Role` and `RoleBinding` are namespaced. Their scope is only within a single
    namespace. For accessing `cluster-wide` resources, we''ll need `ClusterRole` and
    `ClusterRoleBinding`.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`Role`和`RoleBinding`是有命名空间的。它们的范围仅限于单个命名空间。要访问`整个集群`资源，我们需要`ClusterRole`和`ClusterRoleBinding`。'
- en: For adding namespace into `Role` or `RoleBinding`, simply add a namespace field
    into the metadata in the configuration file.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 要将命名空间添加到`Role`或`RoleBinding`中，只需在配置文件的元数据中添加一个命名空间字段。
- en: ClusterRole and ClusterRoleBinding
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ClusterRole和ClusterRoleBinding
- en: '`ClusterRole` and `ClusterRoleBinding` are basically similar to `Role` and
    `RoleBinding`. Unlike how `Role` and `RoleBinding` are scoped into a single namespace,
    `ClusterRole` and `ClusterRoleBinding` are used to grant cluster-wide resources.
    Therefore, access to resources across all namespaces, non-namespaced resources,
    and non-resource endpoints can be granted to `ClusterRole`, and we can use `ClusterRoleBinding`
    to bind the users and the role.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClusterRole`和`ClusterRoleBinding`基本上类似于`Role`和`RoleBinding`。与`Role`和`RoleBinding`仅限于单个命名空间的方式不同，`ClusterRole`和`ClusterRoleBinding`用于授予整个集群范围的资源。因此，可以将对所有命名空间、非命名空间资源和非资源端点的访问授予`ClusterRole`，并且我们可以使用`ClusterRoleBinding`将用户和角色绑定。'
- en: 'We can also bind a service account with `ClusterRole`. As a service account
    is namespaced, we''ll have to specify its full name, which includes the namespace
    it''s created in:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将服务账户与`ClusterRole`绑定。由于服务账户是有命名空间的，我们必须指定其完整名称，其中包括它所在的命名空间：
- en: '[PRE107]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The following is an example of `ClusterRole` and `ClusterRoleBinding`. In this
    role, we grant all operations for lots of resources, such as `deployments`, `replicasets`,
    `ingresses`, `pods`, and `services` to it, and we limit the permission to read-only
    for namespaces and events:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`ClusterRole`和`ClusterRoleBinding`的示例。在此角色中，我们授予了许多资源的所有操作权限，例如`deployments`、`replicasets`、`ingresses`、`pods`和`services`，并且我们将命名空间和事件的权限限制为只读：
- en: '[PRE108]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Note [`""`] in `apiGroup`; this indicates the core group in Kubernetes. To
    see the full list of resources and verbs, check out the Kubernetes API reference
    site: [https://kubernetes.io/docs/reference/](https://kubernetes.io/docs/reference/).'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在`apiGroup`中的[`""`]表示Kubernetes中的核心组。要查看资源和动词的完整列表，请查看Kubernetes API参考站点：[https://kubernetes.io/docs/reference/](https://kubernetes.io/docs/reference/)。
- en: In this case, we create a `cd-role`, which is the role for performing continuous
    deployment. Also, we create a `ClusterRoleBinding` to associate the service account
    `chapter8-serviceaccount` with `cd-role`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建了一个`cd-role`，这是执行持续部署的角色。此外，我们创建了一个`ClusterRoleBinding`，将服务账户`chapter8-serviceaccount`与`cd-role`关联起来。
- en: Role-based access control (RBAC)
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于角色的访问控制（RBAC）
- en: 'The concept of role-based access control is surrounded by `Role`, `ClusterRole`,
    `RoleBinding`, and `ClusterRoleBinding`. By `role.yaml` and `rolebinding.yaml`,
    as we showed previously, Linda should get read-only access to the `configmaps`
    resource. To apply authorization rules to `chloe-k8scookbook@gmail.com`, simply
    associate a `ClusterRole` and `ClusteRoleBinding` with it:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 基于角色的访问控制的概念围绕着`Role`、`ClusterRole`、`RoleBinding`和`ClusterRoleBinding`。通过`role.yaml`和`rolebinding.yaml`，正如我们之前展示的，Linda应该对`configmaps`资源获得只读访问权限。要将授权规则应用于`chloe-k8scookbook@gmail.com`，只需将`ClusterRole`和`ClusteRoleBinding`与其关联即可：
- en: '[PRE109]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Then, we should be able to see if we can get nodes with the `chloe-k8scookbook@gmail.com`
    user:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该能够看到我们是否可以使用`chloe-k8scookbook@gmail.com`用户获取节点：
- en: '[PRE110]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: It works like a charm. We didn't encounter the Forbidden error anymore.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 它的运行效果很好。我们不再遇到Forbidden错误。
- en: Before RBAC, Kubernetes provided **Attribute-based access control** (**ABAC**),
    which allows a cluster administrator to define a set of user authorization polices
    into a file with one JSON per line format. However, the file has to exist when
    launching the API server, which makes it unusable in the real world. After RBAC
    was introduced in Kubernetes 1.6, ABAC became legacy and was deprecated.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在RBAC之前，Kubernetes提供了**基于属性的访问控制**（**ABAC**），允许集群管理员将一组用户授权策略定义为一个JSON格式的文件。然而，该文件必须在启动API服务器时存在，这使得它在现实世界中无法使用。在Kubernetes
    1.6中引入RBAC之后，ABAC变得过时并被弃用。
- en: Admission control
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准入控制
- en: Admission control modules come into play after Kubernetes verifies who makes
    requests and whether the requester has sufficient permission to perform them.
    Unlike authentication and authorization, admission control can see the content
    of the request, or even have the ability to validate or mutate it. If the request
    doesn't pass through one of admission controllers, the request will be rejected
    immediately. For turning on admission controllers in Kubernetes, simply pass `--admission-control
    (version < 1.10) --enable-admission-plugins (version >= 1.10)` parameters when
    starting the API server.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 准入控制模块在Kubernetes验证谁发出请求以及请求者是否具有足够的权限执行它们之后开始发挥作用。与身份验证和授权不同，准入控制可以查看请求的内容，甚至有能力对其进行验证或修改。如果请求未经过准入控制器之一，请求将立即被拒绝。要在Kubernetes中启用准入控制器，只需在启动API服务器时传递`--admission-control（版本<1.10）--enable-admission-plugins（版本>=1.10）`参数。
- en: Depending on how you provision your cluster, the method for passing on the `--enable-admission-plugin`
    parameter may vary. In minikube, adding `--extra-config=apiserver.Admission.PluginNames=
    $ADMISSION_CONTROLLERS` and separate controllers with commas should do the trick.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 根据集群的配置方式，传递`--enable-admission-plugin`参数的方法可能会有所不同。在minikube中，添加`--extra-config=apiserver.Admission.PluginNames=$ADMISSION_CONTROLLERS`并用逗号分隔不同的控制器应该就可以了。
- en: 'Different admission controllers are designed for different purposes. In the
    following recipe, we''ll introduce some important admission controllers and those
    that Kubernetes officially recommends that users have. The recommended list for
    version >= 1.6.0 is as follows: `NamespaceLifecycle`, `LimitRanger`, `ServiceAccount`,
    `PersistentVolumeLabel`, `DefaultStorageClass`, `DefaultTolerationSeconds`, `ResourceQuota`.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的准入控制器设计用于不同的目的。在接下来的教程中，我们将介绍一些重要的准入控制器以及Kubernetes官方建议用户拥有的准入控制器。版本>=1.6.0的推荐列表如下：`NamespaceLifecycle`、`LimitRanger`、`ServiceAccount`、`PersistentVolumeLabel`、`DefaultStorageClass`、`DefaultTolerationSeconds`、`ResourceQuota`。
- en: Please note that the sequence of admission controllers matters since the requests
    pass one by one in sequence (this is true for versions before 1.10, using the `--admission-control`
    option; in v1.10, the parameter is replaced by `--enable-admission-plugins` and
    the sequence no longer matters). We don't want to have `ResourceQuota` checking
    first and finding out that the resource information is outdated after checking
    the long chain of admission controllers.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，准入控制器的顺序很重要，因为请求会依次通过（这对于1.10版本之前使用`--admission-control`选项的情况是正确的；在v1.10中，该参数被`--enable-admission-plugins`替换，顺序就不再重要）。我们不希望首先进行`ResourceQuota`检查，然后在检查了一长串准入控制器后发现资源信息已过时。
- en: If the version is >= 1.9.0, `MutatingAdmissionWebhook` and `ValidatingAdmissionWebhook`
    will be added before `ResourceQuota`. For more information about `MutatingAdmissionWebhook`
    and `ValidatingAdmissionWebhook`, please refer to the *There's more* section in
    this recipe.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 如果版本是>=1.9.0，则`MutatingAdmissionWebhook`和`ValidatingAdmissionWebhook`将在`ResourceQuota`之前添加。有关`MutatingAdmissionWebhook`和`ValidatingAdmissionWebhook`的更多信息，请参阅本教程中的*更多内容*部分。
- en: NamespaceLifecycle
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NamespaceLifecycle
- en: When a namespace is deleted, all objects in that namespace will be evicted as
    well. This plugin ensures no new object creation requests can be made in a namespace
    that is terminating or non-existent. It also saves Kubernetes native Namespaces
    from deletion.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 当命名空间被删除时，该命名空间中的所有对象也将被清除。此插件确保在终止或不存在的命名空间中无法进行新对象的创建请求。它还可以防止Kubernetes本机命名空间被删除。
- en: LimitRanger
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LimitRanger
- en: This plugin ensures `LimitRange` can work properly. With `LimitRange`, we can
    set default requests and limits in a namespace, be used when launching a pod without
    specifying the requests and limits.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件确保 `LimitRange` 可以正常工作。使用 `LimitRange`，我们可以在命名空间中设置默认请求和限制，在启动 pod 时使用，而无需指定请求和限制。
- en: ServiceAccount
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ServiceAccount
- en: The ServiceAccount plugin must be added if you intend to leverage ServiceAccount
    objects in your use cases. For more information about ServiceAccount, revisit
    ServiceAccount as we learned it in this recipe.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算在用例中利用 ServiceAccount 对象，则必须添加 ServiceAccount 插件。有关 ServiceAccount 的更多信息，请重新查看本教程中学到的
    ServiceAccount 部分。
- en: PersistentVolumeLabel (deprecated from v1.8)
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PersistentVolumeLabel（从 v1.8 版本开始已弃用）
- en: '`PersistentVolumeLabel` adds labels to newly-created PV''s, based on the labels
    provided by the underlying cloud provider. This admission controller has been
    deprecated from 1.8\. The function of this controller is now taken care of by
    cloud controller manager, which defines cloud-specific control logic and runs
    as a daemon.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '`PersistentVolumeLabel` 根据底层云提供商提供的标签，为新创建的 PV 添加标签。从 1.8 版本开始，此准入控制器已被弃用。此控制器的功能现在由云控制器管理器负责，它定义了特定于云的控制逻辑并作为守护程序运行。'
- en: DefaultStorageClass
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认存储类
- en: This plugin ensures default storage classes can work as expected if no `StorageClass`
    is set in a `PersistentVolumeClaim`. Different provisioning tools with different
    cloud providers will leverage `DefaultStorageClass` (such as GKE, which uses Google
    Cloud Persistent Disk). Ensure you have this enabled.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件确保默认存储类在未在 `PersistentVolumeClaim` 中设置 `StorageClass` 的情况下可以正常工作。不同的云提供商使用不同的供应工具来利用
    `DefaultStorageClass`（例如 GKE 使用 Google Cloud Persistent Disk）。请确保您已启用此功能。
- en: DefaultTolerationSeconds
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认容忍时间
- en: Taints and tolerations are used to prevent a set of pods from scheduling running
    on some nodes. Taints are applied to nodes, while tolerations are specified for
    pods. The value of taints could be `NoSchedule` or `NoExecute`. If pods running
    one tainted node have no matching toleration, the pods will be evicted.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 污点和容忍度用于阻止一组 pod 在某些节点上调度运行。污点应用于节点，而容忍度则针对 pod 进行指定。污点的值可以是 `NoSchedule` 或
    `NoExecute`。如果在一个带有污点的节点上运行的 pod 没有匹配的容忍度，那么这些 pod 将被驱逐。
- en: The `DefaultTolerationSeconds` plugin is used to set those pods without any
    toleration set. It will then apply for the default toleration for the taints `notready:NoExecute`
    and unreachable:NoExecute for 300 s. If a node is not ready or unreachable, wait
    for 300 seconds before the pod is evicted from the node.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultTolerationSeconds` 插件用于设置那些没有设置容忍度的 pod。然后，它将为 `notready:NoExecute`
    和 `unreachable:NoExecute` 的默认容忍度申请 300 秒。如果节点不可用或不可达，等待 300 秒后再将 pod 从节点中驱逐。'
- en: ResourceQuota
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ResourceQuota
- en: Just like `LimitRange`, if you're using the `ResourceQuota` object to administer
    different levels of QoS, this plugin must be enabled. The `ResourceQuota` should
    be always be put at the end of the admission control plugin list. As we mentioned
    in the `ResourceQuota` section, if the used quota is less than the hard quota,
    resource quota usage will be updated to ensure that clusters have sufficient resources
    to accept requests. Putting it into the end of ServiceAccount admission controller
    list could prevent the request from increasing quota usage prematurely if it eventually
    gets rejected by the following controllers.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `LimitRange` 一样，如果您正在使用 `ResourceQuota` 对象来管理不同级别的 QoS，则必须启用此插件。`ResourceQuota`
    应始终放在准入控制插件列表的末尾。正如我们在 `ResourceQuota` 部分提到的，如果使用的配额少于硬配额，资源配额使用将被更新，以确保集群有足够的资源来接受请求。将其放在
    ServiceAccount 准入控制器列表的末尾可以防止请求在被后续控制器拒绝之前过早增加配额使用。
- en: DenyEscalatingExec
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DenyEscalatingExec
- en: This plugin denies any kubectl exec and kubectl attach command escalated privilege
    mode. Pods with privilege mode have access to the host namespace, which could
    become a security risk.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件拒绝了任何 kubectl exec 和 kubectl attach 命令的提升特权模式。具有特权模式的 pod 可以访问主机命名空间，这可能会带来安全风险。
- en: AlwaysPullImages
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AlwaysPullImages
- en: The pull policy defines the behavior when kubelet is pulling images. The default
    pull policy is `IfNotPresent`; that is, it will pull the image if it is not present
    locally. If this plugin is enabled, the default pull policy will become Always,
    which is, always pull the latest image. This plugin also provides another benefit
    if your cluster is shared by different teams. Whenever a pod is scheduled, it'll
    always pull the latest image whether the image exists locally or not. Then we
    can ensure pod creation requests always go through an authorization check against
    the image.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取策略定义了 kubelet 拉取镜像时的行为。默认的拉取策略是 `IfNotPresent`，也就是说，如果本地不存在镜像，它会拉取镜像。如果启用了这个插件，那么默认的拉取策略将变为
    Always，也就是说，总是拉取最新的镜像。这个插件还提供了另一个好处，如果你的集群被不同的团队共享。每当一个 pod 被调度，它都会拉取最新的镜像，无论本地是否存在该镜像。这样我们就可以确保
    pod 创建请求始终通过镜像的授权检查。
- en: For a full list of admission controllers, visit the official site ([https://kubernetes.io/docs/admin/admission-controllers](https://kubernetes.io/docs/admin/admission-controllers))
    for more information.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 有关准入控制器的完整列表，请访问官方网站（[https://kubernetes.io/docs/admin/admission-controllers](https://kubernetes.io/docs/admin/admission-controllers)）获取更多信息。
- en: There's more…
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Before Kubernetes 1.7, admission controllers needed to compile with the API
    server, and configure before the API server starts. **Dynamic admission control**
    is designed to break these limitations. As two major components in dynamic admission
    control are both not GA at the moment we wrote this book, excepting adding them
    into the admission control chain, additional runtime configuration is required
    in the API server: `--runtime-config=admissionregistration.k8s.io/v1alpha1`.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 1.7 之前，准入控制器需要与 API 服务器一起编译，并在 API 服务器启动之前进行配置。**动态准入控制**旨在打破这些限制。由于我们撰写本书时，动态准入控制的两个主要组件都还不是
    GA，除了将它们添加到准入控制链中，还需要在 API 服务器中进行额外的运行时配置：`--runtime-config=admissionregistration.k8s.io/v1alpha1`。
- en: In minikube, ServiceAccount runtime config is set to `api/all`, so it's enabled
    by default.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在 minikube 中，ServiceAccount 运行时配置设置为 `api/all`，因此默认情况下已启用。
- en: Initializers (alpha)
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Initializers（alpha）
- en: Initializers are a set of tasks during the object initialization stage. They
    could be a set of checks or mutations to perform force policies or inject defaults.
    For example, you could implement an initializer to inject a sidecar container
    or a volume containing test data to a pod. Initializers are configured in `metadata.initializers.pending`
    for an object. After the corresponding initializer controller (identified by name)
    performs the task, it'll remove its name from the metadata. If for some reasonsone
    initializer doesn't work well, all the objects with that initializer will be stuck
    in ServiceAccount uninitialized stage, and not visible in the API. Use it with
    caution.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: Initializers 是对象初始化阶段的一组任务。它们可以是一组检查或变更，用于执行强制策略或注入默认值。例如，你可以实现一个 Initializer
    来向 pod 注入一个 sidecar 容器或包含测试数据的卷。Initializers 在对象的 `metadata.initializers.pending`
    中进行配置。在相应的 Initializer 控制器（通过名称标识）执行任务后，它将从元数据中删除其名称。如果由于某些原因某个 Initializer 不起作用，所有具有该
    Initializer 的对象将被卡在未初始化阶段，并且在 API 中不可见。请谨慎使用。
- en: Webhook admission controllers (beta in v1.9)
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webhook 准入控制器（v1.9 中的 beta 版本）
- en: 'There are two types of webhook admission controller as of v1.10:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 v1.10，有两种类型的 webhook 准入控制器：
- en: '`ValidatingAdmissionWebhook`: It can do extra customized validation to reject
    the request'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValidatingAdmissionWebhook`：它可以进行额外的自定义验证来拒绝请求'
- en: '`MutatingAdmissionWebhooks`: It can mutate the object to force default policies'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MutatingAdmissionWebhooks`：它可以改变对象以强制执行默认策略'
- en: 'For more implementation information, please refer to the official documents:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多实施信息，请参考官方文档：
- en: '[https://kubernetes.io/docs/admin/extensible-admission-controllers/](https://kubernetes.io/docs/admin/extensible-admission-controllers/)'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/admin/extensible-admission-controllers/](https://kubernetes.io/docs/admin/extensible-admission-controllers/)'
- en: See also
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes are of relevance to this section:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 以下食谱与本节相关：
- en: '*Working with Namespaces* in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中的*使用命名空间*'
- en: '*Setting up continuous delivery pipelines* in [Chapter 5](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml),
    *Building Continuous Delivery Pipelines*'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第5章](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml)*中的*设置持续交付流水线*，构建持续交付流水线*'
- en: '*Advanced settings in kubeconfig* in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第8章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)*中的*kubeconfig的高级设置*，高级集群管理*'
- en: '*Working with ServiceAccount RESTful API* in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)*,
    Advanced Cluster Administration*'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第8章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)*中的*使用ServiceAccount RESTful
    API*，高级集群管理*'
