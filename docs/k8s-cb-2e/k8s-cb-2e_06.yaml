- en: Building Kubernetes on AWS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS上构建Kubernetes
- en: 'The following recipes are covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下内容：
- en: Playing with Amazon Web Services
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用亚马逊网络服务
- en: Setting up Kubernetes by kops
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过kops设置Kubernetes
- en: Using AWS as Kubernetes Cloud Provider
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS作为Kubernetes云提供商
- en: Managing Kubernete cluster on AWS by kops
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过kops在AWS上管理Kubernetes集群
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Based on a recent survey of the Cloud Native Computing Foundation, CNCF, **Amazon
    Web Services** (**AWS**) is a dominant solution for production-level Kubernetes
    systems ([https://www.cncf.io/blog/2017/12/06/cloud-native-technologies-scaling-production-applications/](https://www.cncf.io/blog/2017/12/06/cloud-native-technologies-scaling-production-applications/)).
    In this chapter, you will learn about the cloud services of AWS, and how these
    services work together to deliver a robust Kubernetes system. We will also introduce
    how kops works, a tool for Kubernetes operation, which helps us manage the Kubernetes
    cluster. Let's explore the world of Kubernetes in AWS!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 根据最近的云原生计算基金会（CNCF）的调查，**亚马逊网络服务**（**AWS**）是生产级Kubernetes系统的主要解决方案([https://www.cncf.io/blog/2017/12/06/cloud-native-technologies-scaling-production-applications/](https://www.cncf.io/blog/2017/12/06/cloud-native-technologies-scaling-production-applications/))。在本章中，您将了解AWS的云服务，以及这些服务如何共同工作以提供强大的Kubernetes系统。我们还将介绍kops的工作原理，这是一个用于Kubernetes操作的工具，可以帮助我们管理Kubernetes集群。让我们一起探索AWS中的Kubernetes世界！
- en: Playing with Amazon Web Services
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用亚马逊网络服务
- en: Amazon Web Services ([https://aws.amazon.com](https://aws.amazon.com/)) is the
    most popular public cloud service. It provides the online service for Virtual
    Server (EC2), Software Defined Network (VPC), Object Store (S3), and so on. It
    is a suitable infrastructure to set up a Kubernetes cluster. We will explore AWS
    to understand the fundamental function of AWS.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊网络服务([https://aws.amazon.com](https://aws.amazon.com/))是最受欢迎的公共云服务。它提供虚拟服务器（EC2）、软件定义网络（VPC）、对象存储（S3）等在线服务。这是一个适合建立Kubernetes集群的基础设施。我们将探索AWS以了解AWS的基本功能。
- en: Getting ready
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: First of all, you need to sign up to AWS. AWS gives a free tier that allows
    you to use some amount of AWS resources, free for 12 months. Go to [https://aws.amazon.com/free/](https://aws.amazon.com/free/) to
    register your information and credit card. It may take 24 hours to verify and
    activate your account.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要注册AWS。AWS提供免费套餐，允许您免费使用一定数量的AWS资源，有效期为12个月。访问[https://aws.amazon.com/free/](https://aws.amazon.com/free/)注册您的信息和信用卡。可能需要24小时来验证和激活您的账户。
- en: Once your AWS account is activated, we need to create one **Identity and Access
    Management** (**IAM**) user, which will control your AWS infrastructure via APIs.
    Then, install the AWS CLI on to your computer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的AWS账户激活，我们需要创建一个**身份和访问管理**（**IAM**）用户，通过API来控制您的AWS基础设施。然后，在您的计算机上安装AWS
    CLI。
- en: Creating an IAM user
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建IAM用户
- en: 'Perform the following steps to create an IAM user:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤创建IAM用户：
- en: Go to AWS Web console [https://console.aws.amazon.com](https://console.aws.amazon.com).
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到AWS Web控制台[https://console.aws.amazon.com](https://console.aws.amazon.com)。
- en: 'Click on IAM (use the search box, which makes it easier to find):'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击IAM（使用搜索框，这样更容易找到）：
- en: '![](assets/e5cf92cc-6868-4735-a725-6d57a0725e32.png)Access to IAM console'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/e5cf92cc-6868-4735-a725-6d57a0725e32.png)访问IAM控制台'
- en: 'Click on Users in the left navigation and then click on Add user:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧导航中的用户，然后点击添加用户：
- en: '![](assets/35a36126-64d0-49e6-9a79-103209103aaa.png)Creating an IAM user'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/35a36126-64d0-49e6-9a79-103209103aaa.png)创建IAM用户'
- en: 'Type User name `chap6`, then choose Programmatic access:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入用户名`chap6`，然后选择编程访问：
- en: '![](assets/fe599cfc-8532-499e-9784-30dfc41a75cd.png)Creating chap6 user'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/fe599cfc-8532-499e-9784-30dfc41a75cd.png)创建chap6用户'
- en: 'Choose Attach existing policies directly, as shown in the following screenshot, and
    then select the following policies:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择直接附加现有策略，如下截图所示，然后选择以下策略：
- en: AmazonEC2FullAccess
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonEC2FullAccess
- en: AmazonRoute53FullAcccess
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonRoute53FullAcccess
- en: AmazonS3FullAccess
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonS3FullAccess
- en: AmazonVPCFullAccess
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonVPCFullAccess
- en: IAMFullAccess
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IAMFullAccess
- en: '![](assets/301e2810-98e5-4151-94f4-c7983a5d6d22.png)Attaching the necessary
    Policy'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 附加必要的策略
- en: 'Eventually, it generates Access key ID and Secret access key. Copy and paste
    into your text editor or click on Download .csv to preserve to your computer:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，它会生成访问密钥ID和秘密访问密钥。将其复制并粘贴到文本编辑器中，或单击下载 .csv 以保存到您的计算机：
- en: '![](assets/15b0a0e3-91ca-4c49-9074-48a042f112e9.png)Downloading Access key
    ID and Secret access key'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下载访问密钥ID和秘密访问密钥
- en: Installing AWS CLI on macOS
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在macOS上安装AWS CLI
- en: Install `awscli` to macOS using HomeBrew ([https://brew.sh](https://brew.sh));
    this is the easiest way. HomeBrew has already been introduced in [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml), *Building
    your own Kubernetes Cluster*, while installing minikube.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HomeBrew（[https://brew.sh](https://brew.sh)）将`awscli`安装到macOS；这是最简单的方法。在[第1章](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml)中已经介绍了HomeBrew，*构建您自己的Kubernetes集群*，同时安装minikube。
- en: 'To install awscli by HomeBrew on your Mac, perform the following steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Mac上通过HomeBrew安装awscli，请执行以下步骤：
- en: 'Type the following command to update the latest formula:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键入以下命令以更新最新的公式：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Specify `awscli` to install:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定`awscli`进行安装：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Verify the `aws` command using the` --version` option:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`--version`选项验证`aws`命令：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installing AWS CLI on Windows
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上安装AWS CLI
- en: 'Install awscli on Windows; there is a Windows installer package, which is the
    easiest way to install  awscli on to your Windows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上安装awscli；有一个Windows安装程序包，这是在Windows上安装awscli的最简单方式：
- en: Go to AWS Command Line Interface page ([https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到AWS命令行界面页面（[https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)）。
- en: Download Windows installer 64 bit ([https://s3.amazonaws.com/aws-cli/AWSCLI64.msi](https://s3.amazonaws.com/aws-cli/AWSCLI64.msi))
    or 32 bit ([https://s3.amazonaws.com/aws-cli/AWSCLI32.msi](https://s3.amazonaws.com/aws-cli/AWSCLI32.msi)),
    based on your Windows OS.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您的Windows操作系统，下载64位（[https://s3.amazonaws.com/aws-cli/AWSCLI64.msi](https://s3.amazonaws.com/aws-cli/AWSCLI64.msi)）或32位（[https://s3.amazonaws.com/aws-cli/AWSCLI32.msi](https://s3.amazonaws.com/aws-cli/AWSCLI32.msi)）的Windows安装程序。
- en: 'Launch AWS CLI installer, and then choose the default option to proceed with
    the installation:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动AWS CLI安装程序，然后选择默认选项继续安装：
- en: '![](assets/d30f75b4-ae98-4293-9f1c-bfde62241948.png)Installing AWS CLI for
    Windows'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为Windows安装AWS CLI
- en: 'After complete installation, launch Command Prompt. Then, type the `aws` command
    with the `--version` option to verify:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，启动命令提示符。然后，键入带有`--version`选项的`aws`命令进行验证：
- en: '![](assets/5f175700-22de-4607-9433-3c09cd6f7fad.png)Showing aws command on
    Windows'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上显示aws命令
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: First of all, you need to set your AWS Access Key ID and AWS Secret Access Key
    for awscli. We've already acquired `chap6` for the IAM user. We will use this
    user's Access Key ID and Secret Access Key.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要为awscli设置AWS访问密钥ID和AWS秘密访问密钥。我们已经为IAM用户获得了`chap6`。我们将使用此用户的访问密钥ID和秘密访问密钥。
- en: 'Launch terminal (Command Prompt for Windows), and then use the `aws` command
    to set `Access Key ID` and `Secret Access Key`. Also, set the default region as
    `us-east-1`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动终端（Windows的命令提示符），然后使用`aws`命令设置`访问密钥ID`和`秘密访问密钥`。还要将默认区域设置为`us-east-1`：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Check `chap6` IAM user using the following command:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查`chap6` IAM用户：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That's it! Now you can start using AWS to launch your own network and instances.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在您可以开始使用AWS来启动您自己的网络和实例。
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's explorer AWS to launch a typical infrastructure. Using awscli to build
    your own VPC, Subnet, Gateway, and Security group. Then, launch the EC2 instance
    to understand the basic usage of AWS.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索AWS，启动一个典型的基础架构。使用awscli构建您自己的VPC、子网、网关和安全组。然后，启动EC2实例以了解AWS的基本用法。
- en: Creating VPC and Subnets
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建VPC和子网
- en: '**Virtual Private Cloud** (**VPC**) is a Software-Defined Network. You can
    configure a virtual network on AWS. Subnets are inside of VPC that define network
    block (**Classless Inter Domain Routing** (**CIDR**)) such as `192.168.1.0/24`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟私有云**（**VPC**）是一个软件定义的网络。您可以在AWS上配置一个虚拟网络。子网位于VPC内，定义了网络块（**无类域间路由**（**CIDR**）），例如`192.168.1.0/24`。'
- en: 'Let''s create one VPC and two subnets using the following steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下步骤创建一个VPC和两个子网：
- en: 'Create a new VPC that has `192.168.0.0/16` CIDR block (IP range: `192.168.0.0`
    – `192.168.255.255`). Then, capture `VpcId`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有`192.168.0.0/16` CIDR块（IP范围：`192.168.0.0` – `192.168.255.255`）的新VPC。然后，捕获`VpcId`：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create the first subnet under the VPC (`vpc-69cfbd12`) that has `192.168.0.0/24`
    CIDR block (IP range: `192.168.0.0` – `192.168.0.255`) and specify the availability
    zone as `us-east-1a`. Then, capture `SubnetId:`'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VPC（`vpc-69cfbd12`）下创建第一个子网，其CIDR块为`192.168.0.0/24`（IP范围：`192.168.0.0` – `192.168.0.255`），并指定可用区为`us-east-1a`。然后，捕获`SubnetId`：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the second subnet on `us-east-1b`, which has `192.168.1.0/24` CIDR block
    (IP range: `192.168.1.0` – `192.168.1.255`). Then, capture `SubnetId`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`us-east-1b`上创建第二个子网，其CIDR块为`192.168.1.0/24`（IP范围：`192.168.1.0` – `192.168.1.255`）。然后，捕获`SubnetId`：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Check the subnet list under VPC (`vpc-69cfbd12`) using the following command:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查VPC（`vpc-69cfbd12`）下的子网列表：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This looks good!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！
- en: Internet gateway
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网网关
- en: To access your VPC network, you need to have a gateway that accesses it from
    the internet. **Internet Gateway** (**IGW**) is the one that connects the internet
    to your VPC.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 访问您的VPC网络，您需要有一个从互联网访问它的网关。**互联网网关**（**IGW**）是将互联网连接到您的VPC的网关。
- en: Then, in the subnets under VPC, you can set the default route to go to IGW or
    not. If it routes to IGW, the subnet is classified as the public subnet. Then,
    you can assign the global IP address on the public subnet.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在VPC的子网中，您可以设置默认路由是否去往IGW。如果路由到IGW，该子网被归类为公共子网。然后，您可以在公共子网上分配全局IP地址。
- en: 'Let''s configure the first subnet (`192.168.0.0/24`) as the public subnet that
    routes to IGW using the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下步骤将第一个子网（`192.168.0.0/24`）配置为路由到IGW的公共子网：
- en: 'Create IGW and capture `InternetGatewayId`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建IGW并捕获`InternetGatewayId`：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Attach IGW (`igw-e50b849d`) to your VPC (`vpc-69cfbd12`):'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将IGW（`igw-e50b849d`）附加到您的VPC（`vpc-69cfbd12`）：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Create a routing table on VPC (`vpc-69cfbd12`) and then capture `RouteTableId:`
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VPC（`vpc-69cfbd12`）上创建一个路由表，然后捕获`RouteTableId`：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Set the default route (`0.0.0.0/0`) for route table (`rtb-a9e791d5`) as IGW
    (`igw-e50b849d`):'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为路由表（`rtb-a9e791d5`）设置默认路由（`0.0.0.0/0`）为IGW（`igw-e50b849d`）：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Associate route table (`rtb-a9e791d5`) to public subnet (`subnet-6296863f`):'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路由表（`rtb-a9e791d5`）关联到公共子网（`subnet-6296863f`）：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Enable autoassign public IP on the public subnet (`subnet-6296863f`):'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在公共子网（`subnet-6296863f`）上启用自动分配公共IP：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: NAT-GW
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NAT-GW
- en: What happens if the subnet default route is not pointing to IGW? The subnet
    is classified as a private subnet with no connectivity to the internet. However,
    some of situation, your VM in private subnet needs to access to the Internet.
    For example, download some security patch.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子网的默认路由没有指向IGW会发生什么？该子网被归类为私有子网，无法连接到互联网。然而，在某些情况下，您的私有子网中的虚拟机需要访问互联网。例如，下载一些安全补丁。
- en: In this case, you can setup NAT-GW. It allows you access to the internet from
    the private subnet. However, it allows outgoing traffic only, so you cannot assign
    public IP address for a private subnet. Therefore, it is suitable for backend
    instances, such as the database.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以设置NAT-GW。它允许您从私有子网访问互联网。但是，它只允许出站流量，因此您不能为私有子网分配公共IP地址。因此，它适用于后端实例，如数据库。
- en: 'Let''s create NAT-GW and configure a second subnet (`192.168.1.0/24`) as a
    private subnet that routes to NAT-GW using the following steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建NAT-GW，并配置第二个子网（`192.168.1.0/24`）作为私有子网，通过以下步骤路由到NAT-GW：
- en: 'NAT-GW needs a Global IP address, so create **Elastic IP** (**EIP**):'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NAT-GW需要全局IP地址，因此创建**弹性IP**（**EIP**）：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Create NAT-GW on the public subnet (`subnet-6296863f`) and assign EIP (`eipalloc-bad28bb3`).
    Then, capture `NatGatewayId`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在公共子网（`subnet-6296863f`）上创建NAT-GW并分配EIP（`eipalloc-bad28bb3`）。然后，捕获`NatGatewayId`。
- en: Since NAT-GW needs to access the internet, it must be located on the public
    subnet instead of the private subnet.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NAT-GW需要访问互联网，它必须位于公共子网而不是私有子网。
- en: 'Input the following command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the route table and capture `RouteTableId`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建路由表并捕获`RouteTableId`：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Set the default route (`0.0.0.0/0`) of the route table (`rtb-70f1870c`) to
    NAT-GW (`nat-0b12be42c575bba43`):'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路由表（`rtb-70f1870c`）的默认路由（`0.0.0.0/0`）设置为NAT-GW（`nat-0b12be42c575bba43`）：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Associate route table (`rtb-70f1870c`) to private subnet (`subnet-ce947da`9):'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路由表（`rtb-70f1870c`）关联到私有子网（`subnet-ce947da`9）：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Security group
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全组
- en: 'Before launching your Virtual Server (EC2), you need to create a Security Group
    that has an appropriate security rule. Now, we have two subnets, public and private.
    Let''s set public subnet such that it allows `ssh` (`22/tcp`) and `http` (`80/tcp`)
    from the internet. Then, set the private subnet such that it allows ssh from the
    public subnet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动虚拟服务器（EC2）之前，您需要创建一个具有适当安全规则的安全组。现在，我们有两个子网，公共和私有。让我们设置公共子网，使其允许来自互联网的`ssh`（`22/tcp`）和`http`（`80/tcp`）。然后，设置私有子网，使其允许来自公共子网的ssh：
- en: 'Create one security group for the public subnet on VPC (`vpc-69cfbd12`):'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VPC上为公共子网创建一个安全组（`vpc-69cfbd12`）：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the ssh allow rule to the public security group (`sg-dd8a3f94`):'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向公共安全组（`sg-dd8a3f94`）添加ssh允许规则：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the `http` allow rule to the public security group (`sg-dd8a3f94`):'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向公共安全组（`sg-dd8a3f94`）添加`http`允许规则：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a second security group for the private subnet on VPC (`vpc-69cfbd12`):'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VPC上为私有子网创建第二个安全组（`vpc-69cfbd12`）：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add an `ssh` allow rule to the private security group (`sg-a18c39e8`):'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向私有安全组（`sg-a18c39e8`）添加一个`ssh`允许规则：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Check the Security Group list using the following command:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查安全组列表：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: EC2
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EC2
- en: 'Now you need to upload your ssh public key and then launch the EC2 instance
    on both the public subnet and the private subnet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要上传您的ssh公钥，然后在公共子网和私有子网上启动EC2实例：
- en: 'Upload your ssh public key (assume you have a public key that is located at `~/.ssh/id_rsa.pub`):'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传您的ssh公钥（假设您的公钥位于`~/.ssh/id_rsa.pub`）：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Launch the first EC2 instance with the following parameters:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下参数启动第一个EC2实例：
- en: 'Use Amazon Linux image: `ami-1853ac65` (Amazon Linux)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Amazon Linux映像：`ami-1853ac65`（Amazon Linux）
- en: 'T2.nano instance type: `t2.nano`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T2.nano实例类型：`t2.nano`
- en: 'Ssh key: `chap6-key`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ssh密钥：`chap6-key`
- en: 'Public Subnet: `subnet-6296863f`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共子网：`subnet-6296863f`
- en: 'Public Security Group: `sg-dd8a3f94`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共安全组：`sg-dd8a3f94`
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Launch the second EC2 instance with the following parameters:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下参数启动第二个EC2实例：
- en: 'Use Amazon Linux image: `ami-1853ac65`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Amazon Linux映像：`ami-1853ac65`
- en: 'T2.nano instance type: `t2.nano`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T2.nano实例类型：`t2.nano`
- en: 'Ssh key: `chap6-key`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ssh密钥：`chap6-key`
- en: 'Private subnet: `subnet-ce947da9`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有子网：`subnet-ce947da9`
- en: 'Private Secuity Group: `sg-a18c39e8`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有安全组：`sg-a18c39e8`
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Check the status of the EC2 instances:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查EC2实例的状态：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'SSH (use the `-A` option to forward your authentication info) to the public
    EC2 host from your computer:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的计算机通过SSH（使用`-A`选项转发您的身份验证信息）到公共EC2主机：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Install and launch nginx to the public EC2 host:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在公共EC2主机上安装并启动nginx：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Make sure you can access the nginx server from your machine (see the following
    screenshot):'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您可以从您的机器访问nginx服务器（请参见以下截图）：
- en: '![](assets/ecb8ab27-c187-49c4-ab25-ce68e6d67977.png)Accessing nginx web server
    on public host'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/ecb8ab27-c187-49c4-ab25-ce68e6d67977.png)访问公共主机上的nginx web服务器'
- en: 'SSH from the public host to the private host (you must use a private IP address):'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从公共主机到私有主机的SSH（您必须使用私有IP地址）：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Make sure the private host can perform yum update via NAT-GW:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保私有主机可以通过NAT-GW执行yum更新：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Congratulations! You can set up your own infrastructure on AWS, as shown in
    the following diagram, which has the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您可以在AWS上设置自己的基础架构，如下图所示，其中包括以下内容：
- en: One VPC with CIDR `192.168.0.0/16`
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个VPC，CIDR为`192.168.0.0/16`
- en: IGW
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IGW
- en: NAT-GW
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NAT-GW
- en: Two Subnets
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个子网
- en: 'public subnet: `192.168.0.0/24` route to IGW'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共子网：`192.168.0.0/24`路由到IGW
- en: 'private subnet: 192.168.1.0/24 route to NAT-GW'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有子网：192.168.1.0/24路由到NAT-GW
- en: Two EC2 instances (public and private)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个EC2实例（公共和私有）
- en: Two Security Groups (allow public http/ssh and private ssh)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个安全组（允许公共http/ssh和私有ssh）
- en: 'Now, take a look at the diagram:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下图表：
- en: '![](assets/97480e7b-4918-4383-841c-372a6992a957.png)AWS components diagram'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/97480e7b-4918-4383-841c-372a6992a957.png)AWS组件图'
- en: In this section, you have learned how to use AWS from scratch. We have covered
    its basic uses, but it is important to know while setup Kubernetes on AWS. Next,
    we will explore how to set up Kubernetes on AWS.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经学会了如何从头开始使用AWS。我们已经涵盖了它的基本用途，但在AWS上设置Kubernetes时，这一点很重要。接下来，我们将探讨如何在AWS上设置Kubernetes。
- en: Setting up Kubernetes with kops
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用kops设置Kubernetes
- en: What is kops? It is the abbreviated term of Kubernetes Operation ([https://github.com/kubernetes/kops](https://github.com/kubernetes/kops)).
    Similar to kubeadm, minikube, and kubespray, kops reduces the heavy duty of building
    up a Kubernetes cluster by ourselves. It helps in creation, and provides an interface
    to users for managing the clusters. Furthermore, kops achieves a more automatic
    installing procedure and delivers a production-level system. It targets to support
    dominate cloud platforms, such as AWS, GCE, and VMware vSphere. In this recipe,
    we will talk about how to run a Kubernetes cluster with kops.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是kops？这是Kubernetes Operation的缩写（[https://github.com/kubernetes/kops](https://github.com/kubernetes/kops)）。类似于kubeadm、minikube和kubespray，kops减少了我们自己构建Kubernetes集群的繁重工作。它帮助创建，并为用户提供管理集群的接口。此外，kops实现了更自动化的安装过程，并提供了一个生产级系统。它旨在支持主要的云平台，如AWS、GCE和VMware
    vSphere。在本教程中，我们将讨论如何使用kops运行Kubernetes集群。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before our major tutorial, we will need to install kops on to your local host.
    It is a straightforward step for downloading the binary file and moving it to
    the system directory of the execution file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主要教程之前，我们需要在您的本地主机上安装kops。这是一个简单的步骤，下载二进制文件并将其移动到执行文件的系统目录：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we have to prepare some AWS configuration on your host and required services
    for cluster. Refer to the following items and make sure that they are ready:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在您的主机上准备一些AWS配置和集群所需的服务。参考以下项目，并确保它们已准备就绪：
- en: '**IAM user**: Since kops would create and build several AWS service components
    together for you, you must have an IAM user with kops required permissions. We''ve
    created an IAM user named chap6 in the previous section that has the following
    policies with the necessary permissions for kops:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IAM用户**：由于kops将为您创建和构建多个AWS服务组件，您必须拥有具有kops所需权限的IAM用户。我们在上一节中创建了一个名为chap6的IAM用户，该用户具有以下策略和kops所需的必要权限：'
- en: AmazonEC2FullAccess
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonEC2FullAccess
- en: AmazonRoute53FullAccess
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonRoute53FullAccess
- en: AmazonS3FullAccess
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonS3FullAccess
- en: IAMFullAccess
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IAMFullAccess
- en: AmazonVPCFullAccess
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AmazonVPCFullAccess
- en: 'Then, exposing the AWS access key ID and secret key as environment variables
    can make this role applied on host while firing `kops` commands:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，暴露AWS访问密钥ID和秘钥作为环境变量，可以在执行`kops`命令时将此角色应用于主机：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Prepare an S3 bucket for storing cluster configuration**: In our demonstration
    later, the S3 bucket name will be `kubernetes-cookbook`.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为存储集群配置准备S3存储桶**：在我们之后的演示中，S3存储桶的名称将是`kubernetes-cookbook`。'
- en: '**Prepare a Route53 DNS domain for accessing points of cluster**: In our demonstration
    later, the domain name we use will be `k8s-cookbook.net`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为访问集群的访问点准备Route53 DNS域**：在我们之后的演示中，我们将使用的域名是`k8s-cookbook.net`。'
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We can easily run up a Kubernetes cluster using a single command with parameters
    containing complete configurations. These parameters are described in the following
    table:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用包含完整配置的参数，通过单个命令轻松运行Kubernetes集群。这些参数在下表中进行了描述：
- en: '| **Parameter** | **Description** | **Value in example** |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **描述** | **示例中的值** |'
- en: '| `--name` | This is the name of the cluster. It will also be the domain name
    of the cluster''s entry point. So you can utilize your Route53 DNS domain with
    a customized name, for example, `{your cluster name}.{your Route53 domain name}`.
    | `my-cluster.k8s-cookbook.net` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `--name` | 这是集群的名称。它也将是集群入口点的域名。因此，您可以利用您的Route53 DNS域名来使用自定义名称，例如，`{您的集群名称}.{您的Route53域名}`。
    | `my-cluster.k8s-cookbook.net` |'
- en: '| `--state` | This indicates the S3 bucket that stores the status of the cluster
    in the format `s3://{bucket name}`. | `s3://kubernetes-cookbook` |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `--state` | 这指示存储集群状态的S3存储桶的格式为`s3://{存储桶名称}`。 | `s3://kubernetes-cookbook`
    |'
- en: '| `--zones` | This is the availability zone where you need to build your cluster.
    | `us-east-1a` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `--zones` | 这是您需要构建集群的可用区。 | `us-east-1a` |'
- en: '| `--cloud` | This is the cloud provider. | `aws` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `--cloud` | 这是云提供商。 | `aws` |'
- en: '| `--network-cidr` | Here, kops helps to create independent CIDR range for
    the new VPC. | `10.0.0.0/16` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `--network-cidr` | 在这里，kops帮助创建新VPC的独立CIDR范围。 | `10.0.0.0/16` |'
- en: '| `--master-size` | This is the instance size of Kubernetes master. | `t2.large`
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `--master-size` | 这是Kubernetes主节点的实例大小。 | `t2.large` |'
- en: '| `--node-size` | This is the instance size of Kubernetes nodes. | `t2.medium`
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `--node-size` | 这是Kubernetes节点的实例大小。 | `t2.medium` |'
- en: '| `--node-count` | This is the number of nodes in the cluster. | `2` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `--node-count` | 这是集群中节点的数量。 | `2` |'
- en: '| `--network` | This is the overlay network used in this cluster. | `calico`
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `--network` | 这是集群中使用的覆盖网络。 | `calico` |'
- en: '| `--topology` | This helps you decide whether the cluster is public facing.
    | `private` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `--topology` | 这有助于您决定集群是否面向公众。 | `private` |'
- en: '| `--ssh-public-key` | This helps you assign an SSH public key for bastion
    server, then we may log in through the private key. | `~/.ssh/id_rsa.pub` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `--ssh-public-key` | 这有助于为堡垒服务器分配一个SSH公钥，然后我们可以通过私钥登录。 | `~/.ssh/id_rsa.pub`
    |'
- en: '| `--bastion` | This gives you an indication to create the bastion server.
    | N/A |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `--bastion` | 这会指示您创建堡垒服务器。 | N/A |'
- en: '| `--yes` | This gives you the confirmation for executing immediately. | N/A
    |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `--yes` | 这会给您立即执行的确认。 | N/A |'
- en: 'Now we are ready to compose the configurations into a command and fire it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备将配置组合成一个命令并执行它：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After a few minutes, the command takes out the preceding logs showing what
    AWS services have been created and served for you kops-built Kubernetes cluster.
    You can even check your AWS console to verify their relationships, which will
    look similar to the following diagram:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，该命令会输出之前的日志，显示为您构建的kops Kubernetes集群创建了哪些AWS服务并为您提供了哪些服务。您甚至可以检查您的AWS控制台来验证它们的关系，它们看起来类似于以下图表：
- en: '![](assets/43f90e6c-c355-49df-8f2b-f59719ddca51.png)The components of Kubernetes
    cluster in AWS created by kops'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/43f90e6c-c355-49df-8f2b-f59719ddca51.png)由kops在AWS中创建的Kubernetes集群的组件'
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'From localhost, users can interact with the cluster on AWS using the kops command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从本地主机，用户可以使用kops命令与AWS上的集群进行交互：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Working with kops-built AWS cluster
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用kops构建的AWS集群
- en: 'Furthermore, as you can see in the previous section, the last few logs of kops
    cluster creation shows that the environment of the client is also ready. It means
    that kops helps to bind the API server to our host securely as well. We may use
    the `kubectl` command like we were in Kubernetes master. What we need to do is
    install kubectl manually. It would be as simple as installing kops; just download
    the binary file:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如您在前一节中所看到的，kops集群创建的最后几条日志显示客户端的环境也已准备就绪。这意味着kops还帮助将API服务器安全地绑定到我们的主机。我们可以像在Kubernetes主节点中一样使用kubectl命令。我们需要做的就是手动安装kubectl。这与安装kops一样简单；只需下载二进制文件：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, you can still access the nodes in the cluster. Since the cluster is
    set down in a private network, we will require to login to the bastion server
    first, and jump to the nodes for the next:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您仍然可以访问集群中的节点。由于集群设置在私有网络中，我们需要先登录到堡垒服务器，然后跳转到下一个节点：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Deleting kops-built AWS cluster
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除kops构建的AWS集群
- en: 'We can simply remove our cluster using the kops command as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用kops命令简单地删除我们的集群，如下所示：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It will clean the AWS services for you. But some other services created by
    yourself: S3 bucket, IAM role with powerful authorization, and Route53 domain
    name; kops will not remove them on user''s behavior. Remember to delete the no
    used AWS services on your side.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 它将为您清理AWS服务。但是一些其他服务是由您自己创建的：S3存储桶，具有强大授权的IAM角色和Route53域名；kops不会在用户行为上删除它们。请记住删除您一侧未使用的AWS服务。
- en: See also
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Playing with Amazon Web Services*'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用亚马逊网络服务玩耍
- en: '*Using AWS as Kubernetes Cloud Provider*'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用AWS作为Kubernetes云提供商*'
- en: '*Managing Kubernetes cluster on AWS by kops*'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过kops在AWS上管理Kubernetes集群
- en: '*Setting up the Kubernetes cluster on Linux by kubeadm* in [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml),
    *Building your own Kubernetes Cluster*'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过kubeadm在Linux上设置Kubernetes集群[第1章]，构建您自己的Kubernetes集群
- en: '*Setting up Kubernetes cluster on Linux by kubespray* in [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml),
    *Building your own Kubernetes* *Cluster*'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章]中通过kubespray在Linux上设置Kubernetes集群，构建您自己的Kubernetes集群
- en: Using AWS as Kubernetes Cloud Provider
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS作为Kubernetes云提供商
- en: 'From Kubernetes 1.6, **Cloud Controller Manager** (**CCM**) was introduced,
    which defines a set of interfaces so that different cloud providers could evolve
    their own implementations out of the Kubernetes release cycle. Talking to the
    cloud providers, you can''t ignore the biggest player: Amazon Web Service. According
    to the Cloud Native Computing Foundation, in 2017, 63% of Kubernetes workloads
    run on AWS. AWS CloudProvider supports Service as **Elastic Load Balancer** (**ELB**)
    and Amazon **Elastic Block Store** (**EBS**) as StorageClass.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从Kubernetes 1.6开始，引入了**Cloud Controller Manager**（**CCM**），它定义了一组接口，以便不同的云提供商可以在Kubernetes发布周期之外演进自己的实现。与云提供商交谈时，您不能忽视最大的参与者：亚马逊网络服务。根据Cloud
    Native Computing Foundation的数据，2017年，63%的Kubernetes工作负载在AWS上运行。AWS CloudProvider支持**Elastic
    Load Balancer**（**ELB**）作为服务和Amazon **Elastic Block Store**（**EBS**）作为StorageClass。
- en: At the time this book was written, Amazon Elastic Container Service for Kubernetes
    (Amazon EKS) was under preview, which is a hosted Kubernetes service in AWS. Ideally,
    it'll have better integration with Kubernetes, such as **Application Load Balancer**
    (**ALB**) for Ingress, authorization, and networking. Currently in AWS, the limitation
    of routes per route tables in VPC is 50; it could be up to 100 as requested. However,
    network performance may be impacted if the routes exceed 50 according to the official
    documentation of AWS. While kops uses kubenet networking by default, which allocates
    a/24 CIDR to each node and configures the routes in route table in AWS VPC. This
    might lead to the performance hit if the cluster has more than 50 nodes. Using
    a CNI network could address this problem.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Amazon Elastic Container Service for Kubernetes (Amazon EKS)处于预览阶段，这是AWS中的托管Kubernetes服务。理想情况下，它将与Kubernetes有更好的集成，例如Ingress的**Application
    Load Balancer**（**ALB**），授权和网络。目前在AWS中，VPC中每个路由表的路由限制为50；根据AWS的官方文档，可以根据请求将其增加到100。然而，如果路由超过50，网络性能可能会受到影响。虽然kops默认使用kubenet网络，为每个节点分配一个/24
    CIDR并在AWS VPC的路由表中配置路由。如果集群中的节点超过50个，这可能会导致性能下降。使用CNI网络可以解决这个问题。
- en: Getting ready
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For following along with the examples in this recipe, you''ll need to create
    a Kubernetes cluster in AWS. The following example is using kops to provision
    a Kubernetes cluster named `k8s-cookbook.net` in AWS; as the preceding recipes
    show, set `$KOPS_STATE_STORE` as a s3 bucket to store your kops configuration
    and metadata:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟着本教程中的示例，您需要在AWS中创建一个Kubernetes集群。以下示例使用kops在AWS中创建一个名为`k8s-cookbook.net`的Kubernetes集群；正如前面的示例所示，将`$KOPS_STATE_STORE`设置为一个s3存储桶，用于存储您的kops配置和元数据：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once we run the recommended kops update cluster `<cluster_name> --yes` command,
    after a few minutes, the cluster is up and running. We can use the kops validate
    cluster to check whether the cluster components are all up:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行了推荐的kops update cluster `<cluster_name> --yes`命令，几分钟后，集群就可以运行起来了。我们可以使用kops
    validate cluster来检查集群组件是否都已经启动：
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We're good to go!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好了！
- en: How to do it...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'When running Kubernetes in AWS, there are two possible integrations we could
    use: ELB as Service with `LoadBalancer` Type and Amazon Elastic Block Store as
    `StorageClass`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS中运行Kubernetes时，我们可以使用两种可能的集成方式：将ELB作为`LoadBalancer`类型的服务，以及将Amazon Elastic
    Block Store作为`StorageClass`。
- en: Elastic load balancer as LoadBalancer service
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性负载均衡器作为LoadBalancer服务
- en: 'Let''s create a `LoadBalancer` Service with Pods underneath, which is what
    we learned in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml), *Playing
    with Containers*:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`LoadBalancer`服务，并在其下创建Pods，这是我们在[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)中学到的内容，*Playing
    with Containers*：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the preceding template, we declared one nginx Pod and associated it with
    the `LoadBalancer` service. The service will direct the packet to container port
    `80`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述模板中，我们声明了一个nginx Pod，并将其与`LoadBalancer`服务关联起来。该服务将把数据包发送到容器端口`80`：
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s describe our `nginx` Service:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下我们的`nginx`服务：
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: After the service is created, we will find out that the AWS CloudProvider will
    provision a classic load balancer with the endpoint `adb576a05401911e8b1240ef0c7f25d3-1637943008.us-east-1.elb.amazonaws.com`.
    We can check its detailed settings via the aws command-line interface ([https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 服务创建后，我们将发现AWS CloudProvider将使用端点`adb576a05401911e8b1240ef0c7f25d3-1637943008.us-east-1.elb.amazonaws.com`来提供经典负载均衡器。我们可以通过aws命令行界面（[https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)）检查其详细设置。
- en: To install aws CLI, you can use pip to install in Mac or Linux (`pip install
    awscli`); for Windows users, you'll have to download the installer from the official
    website.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装aws CLI，您可以使用pip在Mac或Linux上安装（`pip install awscli`）；对于Windows用户，您需要从官方网站下载安装程序。
- en: 'The combination of AWS CLI commands is `aws [options] <command> <subcommand>
    [<subcommand> ...] [parameters]`. For listing load balancers, we''ll use `aws
    elb describe-load-balancers` as the major command. Using the `--load-balancer-names
    parameter` will filter load balancers by name, and for the `--output` parameter,
    you can choose text, JSON, or table:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CLI命令的组合是`aws [options] <command> <subcommand> [<subcommand> ...] [parameters]`。对于列出负载均衡器，我们将使用`aws
    elb describe-load-balancers`作为主要命令。使用`--load-balancer-names`参数将按名称过滤负载均衡器，对于`--output`参数，您可以选择文本、JSON或表格：
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If we access this ELB endpoint port `80`, we''ll see the nginx welcome page:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问这个ELB端点端口`80`，我们会看到nginx欢迎页面：
- en: '![](assets/40c40acf-d984-4021-ab91-c7f7f92e54bd.png)Access ELB endpoint to
    access LoadBalancer Service'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/40c40acf-d984-4021-ab91-c7f7f92e54bd.png)访问ELB端点以访问负载均衡器服务'
- en: 'Behind the scene, AWS CloudProvider creates a AWS elastic load balancer and
    configures its ingress rules and listeners by the Service we just defined. The
    following is a diagram of how the traffic gets into the Pods:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，AWS CloudProvider创建了一个AWS弹性负载均衡器，并通过我们刚刚定义的服务配置其入口规则和监听器。以下是流量进入Pod的图示：
- en: '![](assets/63c00acb-0240-4931-9813-9ffa62912489.png)The illustration of Kubernetes
    resources and AWS resources for Service with LoadBalancer type'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/63c00acb-0240-4931-9813-9ffa62912489.png)Kubernetes资源和AWS资源的示例，用于LoadBalancer类型的服务'
- en: The external load balancer receives the requests and forwards them to EC2 instances
    using a round-robin algorithm. For Kubernetes, the traffic gets into the Service
    via NodePort and starts a Service-to-Pod communication. For more information about
    external-to-Service and Service-to-Pod communications, you can refer to [Chapter
    3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml), *Playing with Containers*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 外部负载均衡器接收请求并使用轮询算法将其转发到EC2实例。对于Kubernetes，流量通过NodePort进入服务，并开始服务与Pod之间的通信。有关外部到服务和服务到Pod通信的更多信息，您可以参考[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)，*使用容器*。
- en: Elastic Block Store as StorageClass
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性块存储作为StorageClass
- en: We've learned about Volumes in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*. We know `PersistentVolumeClaims` is used
    to abstract storage resources from users. It can dynamically provision the `PersistentVolume`
    via `StorageClass`. The default provisioner in `StorageClass` in **AWS CloudProvider
    is Elastic Block Storage Service**‎ (**aws-ebs**). Whenever you request a PVC,
    aws-ebs provisioner will create a volume in AWS EBS.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中学习了关于卷的知识，*深入了解Kubernetes概念*。我们知道`PersistentVolumeClaims`用于从用户中抽象存储资源。它可以通过`StorageClass`动态地提供`PersistentVolume`。在**AWS
    CloudProvider中，StorageClass的默认提供者是弹性块存储服务**‎（**aws-ebs**）。每当您请求PVC时，aws-ebs提供者将在AWS
    EBS中创建一个卷。
- en: 'Let''s check the storage class in our cluster:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们集群中的存储类：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After PVC is created, an associated PV will be created:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 创建PVC后，将创建关联的PV：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can take a closer look at PV here:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里更仔细地查看PV：
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can find that it's associated with the claim we just created `pvclaim01`
    and the source type is `AWSElasticBlockStore`, as expected.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以发现它与我们刚刚创建的声明`pvclaim01`相关联，源类型是`AWSElasticBlockStore`，正如预期的那样。
- en: 'We can use AWS CLI to inspect the volume we created in EBS. Using the `--filter
    Name=tag-`value we can filter the volumes in EBS:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用AWS CLI来检查我们在EBS中创建的卷。使用`--filter Name=tag-`value我们可以过滤EBS中的卷：
- en: '[PRE50]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We can see that the EBS resource has been tagged with lots of different values: by
    observing these tags, we can know which Kubernetes cluster, namespace, PVC, and
    PV are associated with this EBS volume.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到EBS资源已经被标记了许多不同的值：通过观察这些标记，我们可以知道这个EBS卷与哪个Kubernetes集群、命名空间、PVC和PV相关联。
- en: Thanks to dynamic provisioning that StorageClass and CloudProvider support,
    Volume management is no longer a huge pain. We can create and destroy PV on the
    fly.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于StorageClass和CloudProvider支持的动态配置，卷管理不再是一个巨大的痛点。我们可以随时创建和销毁PV。
- en: There's more...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: At the time of writing this book, there is no native way in Kubernetes 1.10
    to support Ingress integration in AWS CloudProvider yet (ideally with application
    load balancer). Alternatively, kops provides addons that allow you to do so. The
    first one is ingress-nginx ([https://github.com/kubernetes/kops/tree/master/addons/ingress-nginx](https://github.com/kubernetes/kops/tree/master/addons/ingress-nginx)),
    which is powered by nginx ([https://nginx.org](https://nginx.org)) and AWS Elastic
    Load Balancer. The requests will go through ELB to nginx, and nginx will dispatch
    the requests, based on the path definition in Ingress. Another alternative is
    running skipper as kubernetes-ingress-controller ([https://zalando.github.io/skipper/dataclients/kubernetes](https://zalando.github.io/skipper/dataclients/kubernetes)).
    Kops also provides add-ons to help you deploy and leverage skipper and AWS Application
    Load Balancer ([https://github.com/kubernetes/kops/tree/master/addons/kube-ingress-aws-controller](https://github.com/kubernetes/kops/tree/master/addons/kube-ingress-aws-controller)).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Kubernetes 1.10还没有原生的方式来支持AWS CloudProvider中的Ingress集成（理想情况下是应用负载均衡器）。作为替代，kops提供了允许你这样做的插件。第一个是ingress-nginx（[https://github.com/kubernetes/kops/tree/master/addons/ingress-nginx](https://github.com/kubernetes/kops/tree/master/addons/ingress-nginx)），它由nginx（[https://nginx.org](https://nginx.org)）和AWS
    Elastic Load Balancer提供支持。请求将通过ELB传递到nginx，nginx将根据Ingress中的路径定义分发请求。另一个选择是将skipper作为kubernetes-ingress-controller运行（[https://zalando.github.io/skipper/dataclients/kubernetes](https://zalando.github.io/skipper/dataclients/kubernetes)）。Kops还提供了插件来帮助你部署和利用skipper和AWS应用负载均衡器（[https://github.com/kubernetes/kops/tree/master/addons/kube-ingress-aws-controller](https://github.com/kubernetes/kops/tree/master/addons/kube-ingress-aws-controller)）。
- en: We're expecting CCM and Amazon EKS ([https://aws.amazon.com/eks/](https://aws.amazon.com/eks/)) to
    provide more native integration for Ingress via AWS Application Load Balancer,
    and there will be more to come!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期待CCM和Amazon EKS（[https://aws.amazon.com/eks/](https://aws.amazon.com/eks/)）能够通过AWS应用负载均衡器提供更多原生的Ingress集成，还有更多的功能即将推出！
- en: Managing Kubernetes cluster on AWS by kops
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过kops在AWS上管理Kubernetes集群
- en: 'In kops, both Kubernetes masters and nodes are running as auto-scaling groups
    in AWS. In kops, the concept is called **instance groups** (**ig**), which indicate
    the same type of instances in your cluster. Similar to nodes across zones, or
    masters in each availability zone, we could check it via the kops command line:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在kops中，Kubernetes的master和节点都作为AWS中的自动扩展组运行。在kops中，这个概念被称为**实例组**（**ig**），表示集群中相同类型的实例。类似于跨区域的节点，或者每个可用性区域中的master，我们可以通过kops命令行来检查它：
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: With kops, you can change the instance type, resize instance groups (masters
    and nodes), rolling-update, and upgrade cluster. Kops also supports configuration
    for specific AWS features, such as enable AWS detailed monitoring for the instances
    in the cluster.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用kops，你可以更改实例类型，调整实例组（主节点和节点），滚动更新和升级集群。Kops还支持特定AWS功能的配置，例如为集群中的实例启用AWS详细监控。
- en: Getting ready
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For performing this recipe, you''ll need a Kubernetes cluster deployed by kops
    in AWS. You will need to follow the previous recipes in this chapter to launch
    a cluster. Here, we''ll use the same cluster we created in the previous recipe:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个操作，你需要在AWS中使用kops部署的Kubernetes集群。你需要按照本章中的先前操作来启动一个集群。在这里，我们将使用在上一个操作中创建的相同的集群：
- en: '[PRE52]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the previous recipe, we've had the `KOPS_STATE_STORE` environment variable
    set as one of our S3 bucket names by the format `s3://<bucket_name>` to store
    the kops configuration and metadata.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个操作中，我们已经将`KOPS_STATE_STORE`环境变量设置为我们的S3存储桶名称之一，格式为`s3://<bucket_name>`，用于存储kops的配置和元数据。
- en: How to do it...
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The upcoming subsections cover some common operational examples that cluster
    administrators may run into.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的小节涵盖了一些集群管理员可能遇到的常见操作示例。
- en: Modifying and resizing instance groups
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改和调整实例组
- en: Modifying instance groups may be cumbersome if you deploy all instances manually.
    You'll need to update instances one by one or relaunch them. By kops, we can easily
    perform the update without pain.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手动部署所有实例，修改实例组可能会很麻烦。你需要逐个更新实例或重新启动它们。通过kops，我们可以轻松进行更新而不痛苦。
- en: Updating nodes
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新节点
- en: 'Using the kops edit command, we can modify the instance type and the node count:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用kops edit命令，我们可以修改实例类型和节点数量：
- en: '[PRE53]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In this example, we modify both minSize and maxSize from `2` to `3`. After
    the modification, we''ll need to run the kops update to see it take effect:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`minSize`和`maxSize`都从`2`修改为`3`。修改后，我们需要运行kops update来看到其生效：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Some updates will need a rolling-update cluster. In this example, kops has
    updated the configuration in the AWS auto scaling group. AWS will then launch
    a new instance to accommodate the change. The following is a screenshot from AWS
    Auto Scaling Group''s console:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更新将需要一个滚动更新集群。在这个例子中，kops已经更新了AWS自动扩展组的配置。然后AWS将启动一个新的实例来适应这个变化。以下是来自AWS自动扩展组控制台的截图：
- en: '![](assets/544524b9-bc0f-422c-b4f7-3632b3e32a07.png)nodes_in_AWS_Auto_Scaling_Groups'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/544524b9-bc0f-422c-b4f7-3632b3e32a07.png)nodes_in_AWS_Auto_Scaling_Groups'
- en: 'We can see that the configuration has been updated, and AWS is scaling a new
    instance. After few minutes, we can check cluster status via `kops validate` or
    `kubectl get nodes`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到配置已经更新，AWS正在扩展一个新的实例。几分钟后，我们可以通过`kops validate`或`kubectl get nodes`来检查集群状态：
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Everything looks good!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来很好！
- en: Updating masters
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新主节点
- en: Updating masters is the same as updating nodes. Note that masters in the same
    availability zone are in one instance group. This means that you can't add additional
    subnets into the master instance group. In the following example, we'll resize
    the master count from 1 to 2.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 更新主节点与更新节点相同。请注意，同一可用区中的主节点属于一个实例组。这意味着你不能将额外的子网添加到主节点实例组中。在下面的例子中，我们将主节点数量从1调整为2。
- en: In this recipe, we only make the master count 1\. In the real world, the recommended
    way is to deploy masters to at least two availability zones and have three masters
    per zone (one kops instance group). You can achieve that via the `--master-count`
    and `--master-zones` parameters when launching the cluster.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作中，我们只将主节点数量设置为1。在现实世界中，推荐的方式是将主节点部署到至少两个可用区，并且每个区有三个主节点（一个kops实例组）。你可以通过`--master-count`和`--master-zones`参数在启动集群时实现这一点。
- en: 'Now take a look at the following command:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看一下以下命令：
- en: '[PRE56]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Before applying the change, we can run the update cluster command without `--yes`
    in the dry run mode:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用更改之前，我们可以在干跑模式下运行更新集群命令，不带`--yes`：
- en: '[PRE57]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: After we verify the dry run message as expected, we can perform the update as
    follows. In this case, we'll have to perform a rolling update.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 验证干跑消息后，我们可以按以下方式执行更新。在这种情况下，我们将执行滚动更新。
- en: How to know whether a rolling update is needed
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如何知道是否需要进行滚动更新
- en: 'If we didn''t run a kops rolling update in the preceding example, kops will
    show a validation error when running the kops validate cluster:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在前面的示例中没有运行kops滚动更新，那么在运行kops验证集群时，kops将显示验证错误：
- en: VALIDATION ERRORS
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 验证错误
- en: KIND                NAME                          MESSAGE
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 种类 名称 消息
- en: InstanceGroup     `master-us-east-1a` InstanceGroup `master-us-east-1a` did
    not have enough nodes 1 vs 2
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: InstanceGroup `master-us-east-1a` InstanceGroup `master-us-east-1a` did not
    have enough nodes 1 vs 2
- en: Remember to replace k8s-cookbook.net with your cluster name.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 记得用你的集群名称替换k8s-cookbook.net。
- en: '[PRE58]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Just like modifying nodes, we can use both `kubectl get nodes` and `kops validate
    cluster` to check whether the new master has joined the cluster.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 就像修改节点一样，我们可以使用`kubectl get nodes`和`kops validate cluster`来检查新的主节点是否已加入集群。
- en: Upgrading a cluster
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级集群
- en: 'For demonstrating how we upgrade the Kubernetes version, we''ll first launch
    the cluster with the 1.8.7 version. For detailed instructions of parameters, refer
    to the previous recipes in this chapter. Input the following command:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示我们如何升级Kubernetes版本，我们将首先使用1.8.7版本启动集群。有关参数的详细说明，请参阅本章中的先前示例。输入以下命令：
- en: '[PRE59]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After few minutes, we can see that the master and the nodes are up with version
    1.8.7:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，我们可以看到主节点和节点已升级到1.8.7版本：
- en: '[PRE60]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the following example, we''ll walk through how to upgrade Kubernetes cluster
    from 1.8.7 to 1.9.3 using kops. Firstly, run the kops upgrade cluster command.
    Kops will show us the latest version that we could upgrade to:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将演示如何使用kops将Kubernetes集群从1.8.7升级到1.9.3。首先运行kops升级集群命令。Kops将向我们显示可以升级到的最新版本：
- en: '[PRE61]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It indicates that the configuration has been updated, and that we''ll need
    to update the cluster now. We run command with the dryrun mode to check what will
    be modified first:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明配置已经更新，我们现在需要更新集群。我们首先以干跑模式运行命令，以检查将被修改的内容：
- en: '[PRE62]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We could see all of the components moved from v1.8.7 to v1.9.3 in Auto Scaling
    Launch Configuration. After verifying that everything is good, we can run the
    same command with the `--yes` parameter:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到所有组件都从v1.8.7移动到了v1.9.3的自动扩展启动配置中。在验证一切正常后，我们可以使用`--yes`参数运行相同的命令：
- en: '[PRE63]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In this case, we need to run the rolling update for the cluster:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要为集群运行滚动更新：
- en: '[PRE64]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: All the nodes have been upgraded to 1.9.3! When performing the rolling update,
    kops drains one instance first then cordons the node. The auto-scaling group will
    bring up another node with the updated user data, which contains the Kubernetes
    component images with the updates. For avoiding downtime, you should have multiple
    masters and nodes as the basic deployment.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点都已升级到1.9.3！在执行滚动更新时，kops首先排空一个实例，然后封锁节点。自动扩展组将启动另一个包含更新的用户数据的节点，其中包含了Kubernetes组件镜像。为了避免停机时间，您应该将多个主节点和节点作为基本部署。
- en: 'After a rolling update is completed, we can check the cluster version via `kubectl
    get nodes`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 完成滚动更新后，我们可以通过`kubectl get nodes`检查集群版本：
- en: '[PRE65]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: All the nodes have been upgraded to 1.9.3!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点都已升级到1.9.3！
- en: There's more...
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In kops, there are lots of useful addons, such as autoscaling nodes ([https://github.com/kubernetes/kops/tree/master/addons/cluster-autoscaler](https://github.com/kubernetes/kops/tree/master/addons/cluster-autoscaler))
     and mapping the service to the record in Route53 ([https://github.com/kubernetes/kops/tree/master/addons/route53-mapper](https://github.com/kubernetes/kops/tree/master/addons/route53-mapper)).
    Refer to the add-ons page to find out more!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在kops中，有许多有用的插件，比如自动扩展节点（[https://github.com/kubernetes/kops/tree/master/addons/cluster-autoscaler](https://github.com/kubernetes/kops/tree/master/addons/cluster-autoscaler)）和将服务映射到Route53中的记录（[https://github.com/kubernetes/kops/tree/master/addons/route53-mapper](https://github.com/kubernetes/kops/tree/master/addons/route53-mapper)）。请参考插件页面以了解更多信息！
- en: See also
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Deployment API* in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在《深入理解Kubernetes概念》的[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中部署API*'
- en: '*Building multiple masters* in [Chapter 4](1a0d884d-59d3-4f67-adee-2d2e37030132.xhtml),
    *Building High-Availability Clusters*'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在《构建高可用性集群》的[第4章](1a0d884d-59d3-4f67-adee-2d2e37030132.xhtml)中构建多个主节点*'
- en: '*Managing Kubernetes cluster on GKE* in [Chapter 7](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml),
    *Building Kubernetes on GCP*'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在《在GCP上构建Kubernetes》的[第7章](dfc46490-f109-4f07-ba76-1a381b006d76.xhtml)中管理GKE上的Kubernetes集群*'
