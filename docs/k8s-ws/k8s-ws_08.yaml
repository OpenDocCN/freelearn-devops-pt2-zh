- en: 8\. Service Discovery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 服务发现
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will take a look at how to route traffic between the various
    kinds of objects that we have created in previous chapters and make them discoverable
    from both within and outside our cluster. This chapter also introduces the concept
    of Kubernetes Services and explains how to use them to expose the application
    deployed using controllers such as Deployments. By the end of this chapter, you
    will be able to make your application accessible to the external world. You will
    also know about the different types of Services and be able to use them to make
    different sets of pods interact with each other.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看如何在先前章节中创建的各种对象之间路由流量，并使它们能够在集群内外被发现。本章还介绍了Kubernetes服务的概念，并解释了如何使用它们来公开使用部署控制器部署的应用程序。通过本章的学习，您将能够使您的应用程序对外部世界可访问。您还将了解不同类型的服务，并能够使用它们使不同的Pod集合相互交互。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the past few chapters, we learned about Pods and Deployments, which help
    us run containerized applications. Now that we are equipped to deploy our applications,
    in this chapter, we will take a look at some API objects that help us with the
    networking setup to ensure that our users can reach our application and that the
    different components of our application, as well as different applications, can
    work together.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们学习了有关Pod和部署的知识，这有助于我们运行容器化应用程序。现在我们已经具备了部署我们的应用程序的能力，在本章中，我们将研究一些API对象，这些对象可以帮助我们进行网络设置，以确保我们的用户可以访问我们的应用程序，并且我们应用程序的不同组件以及不同的应用程序可以一起工作。
- en: As we have seen in the previous chapters, each Kubernetes Pod gets its IP address.
    However, setting up networking and connecting everything is not as simple as coding
    in Pod IP addresses. We can't rely on a single Pod to run our applications reliably.
    Due to this, we use a Deployment to ensure that, at any given moment, we will
    have a fixed number of specific kinds of Pods running in the cluster. However,
    this means that during the runtime of our application, we can tolerate the failure
    of a certain number of Pods as new pods are automatically created to replace them.
    Hence, the IP addresses of these Pods don't stay the same. For example, if we
    have a set of Pods running the frontend application that need to talk to another
    set of Pods running the backend application inside our cluster, we need to find
    a way to make the Pods discoverable.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的章节中所看到的，每个Kubernetes Pod都有其IP地址。然而，设置网络并连接所有内容并不像编写Pod IP地址那样简单。我们不能依赖单个Pod可靠地运行我们的应用程序。因此，我们使用部署来确保在任何给定时刻，我们将在集群中运行特定类型的Pod的固定数量。然而，这意味着在应用程序运行时，我们可以容忍一定数量的Pod失败，因为新的Pod会自动创建以取代它们。因此，这些Pod的IP地址不会保持不变。例如，如果我们有一组运行前端应用程序的Pod，需要与集群内运行后端应用程序的另一组Pod进行通信，我们需要找到一种方法使这些Pod可被发现。
- en: To solve this problem, we use Kubernetes Services. Services allow us to make
    a logical set of Pods (for example, all pods managed by a Deployment) discoverable
    and accessible for other Pods running inside the same cluster or to the external
    world.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们使用Kubernetes服务。服务允许我们使一组逻辑Pod（例如，所有由部署管理的Pod）可被发现，并且可以被集群内运行的其他Pod或外部世界访问。
- en: Service
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: A Service defines policies by which a logical set of Pods can be accessed. Kubernetes
    Services enable communication between various components of our application, as
    well as between different applications. Services help us connect the application
    with other applications or users. For example, let's say we have a set of Pods
    running the frontend of an application, a set of Pods running the backend, and
    another set of Pods connecting the data source. The frontend is the one that users
    need to interact with directly. The frontend then needs to connect to the backend,
    which, in turn, needs to talk to the external data source.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定义了一组逻辑Pod可以被访问的策略。Kubernetes服务使我们的应用程序的各个组件之间以及不同应用程序之间进行通信。服务帮助我们将应用程序与其他应用程序或用户连接起来。例如，假设我们有一组运行应用程序前端的Pod，一组运行后端的Pod，以及另一组连接数据源的Pod。前端是用户需要直接交互的部分。然后前端需要连接到后端，后端又需要与外部数据源进行通信。
- en: 'Consider you are making a survey app that also allows users to make visualizations
    based on their survey results. Using a bit of simplification, we can imagine three
    Deployments – one that runs the forms'' frontend to collect the data, another
    that validates and stores the data, and a third one that runs the data visualization
    application. The following diagram should help you visualize how Services would
    come into the picture for routing traffic and exposing different components:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在制作一个调查应用程序，该应用程序还允许用户根据其调查结果进行可视化。使用一点简化，我们可以想象三个部署 - 一个运行表单前端以收集数据，另一个验证和存储数据，第三个运行数据可视化应用程序。以下图表应该帮助您想象服务如何在路由流量和公开不同组件方面发挥作用：
- en: '![Figure 8.1: Using Services to route traffic into and within the cluster'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1：使用服务将流量路由到集群内部和集群内部'
- en: '](image/B14870_08_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_01.jpg)'
- en: 'Figure 8.1: Using Services to route traffic into and within the cluster'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：使用服务将流量路由到集群内部和集群内部
- en: Hence, the abstraction of Services helps in keeping the different parts of the
    application decoupled and enables communication between them. In legacy (non-Kubernetes)
    environments, you may expect different components to be linked together by the
    IP addresses of different VMs or bare-metal machines running different resources.
    When working with Kubernetes, the predominant way of linking different resources
    together is using labels and label selectors, which allows a Deployment to easily
    replace failed Pods or scale the number of Deployments as needed. Thus, you can
    think of a Service as a translation layer between the IP addresses and label selector-based
    mechanism of linking different resources. Hence, you just need to point toward
    a Service, and it will take care of routing the traffic to the appropriate application,
    regardless of how many replica Pods are associated with the application or which
    nodes these Pods are running on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，服务的抽象有助于保持应用程序的不同部分解耦，并使它们之间能够进行通信。在传统（非Kubernetes）环境中，您可能期望不同的组件通过运行不同资源的不同VM或裸金属机器的IP地址相互链接。在使用Kubernetes时，将不同资源链接在一起的主要方式是使用标签和标签选择器，这允许部署轻松替换失败的Pod或根据需要扩展部署的数量。因此，您可以将服务视为IP地址和基于标签选择器的不同资源链接机制之间的翻译层。因此，您只需指向一个服务，它将负责将流量路由到适当的应用程序，而不管与应用程序关联的副本Pod的数量或这些Pod运行在哪些节点上。
- en: Service Configuration
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务配置
- en: Similar to the configuration of Pods, ReplicaSets, and Deployments, the configuration
    for a Service also contains four high-level fields; that is, `apiVersion`, `kind`,
    `metadata`, and `spec`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与Pod、ReplicaSets和部署的配置类似，服务的配置也包含四个高级字段；即`apiVersion`、`kind`、`metadata`和`spec`。
- en: 'Here is an example manifest for a Service:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是服务的示例清单：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For a Service, `apiVersion` is `v1` and `kind` will always be `Service`. In
    the `metadata` field, we will specify the name of the Service. In addition to
    the name, we can also add `labels` and `annotations` in the `metadata` field.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个服务，`apiVersion`是`v1`，`kind`总是`Service`。在`metadata`字段中，我们将指定服务的名称。除了名称，我们还可以在`metadata`字段中添加`labels`和`annotations`。
- en: The content of the `spec` field depends on the type of Service we want to create.
    In the next section, we will go through the different types of Services and understand
    various parts of the `spec` field regarding the configuration.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec`字段的内容取决于我们想要创建的服务类型。在下一节中，我们将了解不同类型的服务并理解`spec`字段的配置的各个部分。'
- en: Types of Services
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务类型
- en: 'There are four different types of Services:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种不同类型的服务：
- en: '**NodePort**: This type of Service makes internal Pod(s) accessible on a port
    on the node on which the Pod(s) are running.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NodePort**：这种类型的服务使内部Pod在其所在的节点上的端口上可访问。'
- en: '**ClusterIP**: This type of Service exposes the Service on a certain IP inside
    the cluster. This is the default type of Service.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClusterIP**：这种类型的服务在集群内的特定IP上暴露服务。这是默认的服务类型。'
- en: '**LoadBalancer**: This type of Service exposes the application externally using
    the load balancer provided by the cloud provider.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LoadBalancer**：这种类型的服务使用云提供商提供的负载均衡器在外部暴露应用程序。'
- en: '**ExternalName**: This type of Service points to a DNS rather than a set of
    Pods. The other types of Services use label selectors to select the Pods to be
    exposed. This is a special type of Service that doesn''t use any selectors by
    default.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ExternalName**：这种类型的服务指向DNS而不是一组Pod。其他类型的服务使用标签选择器来选择要暴露的Pod。这是一种特殊类型的服务，默认情况下不使用任何选择器。'
- en: We will take a closer look at all these Services in the following sections.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中更仔细地看看所有这些服务。
- en: NodePort Service
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NodePort服务
- en: A NodePort Service exposes the application on the same port on all the nodes
    in the cluster. The Pods may be running across all or some of the nodes in the
    cluster.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: NodePort服务在集群中的所有节点上都使用相同的端口暴露应用程序。Pod可能在集群中的所有节点或部分节点上运行。
- en: 'In a simplified case where there''s only one node in the cluster, the Service
    exposes all the selected Pods on the port configured in the Service. However,
    in a more practical case, where the Pods may be running on multiple nodes, the
    Service spans across all the nodes and exposes the Pods on the specific port on
    all the nodes. This way, the application can be accessed from outside the Kubernetes
    cluster using the following IP/port combination: `<NodeIP>:<NodePort>`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个简化的情况下，集群中只有一个节点时，服务会在服务配置的端口上暴露所有选定的Pod。然而，在更实际的情况下，Pod可能在多个节点上运行，服务跨越所有节点并在所有节点上的特定端口上暴露Pod。这样，应用程序可以使用以下IP/端口组合从Kubernetes集群外部访问：`<NodeIP>:<NodePort>`。
- en: 'A `config` file for a sample Service would look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例服务的`config`文件看起来像这样：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we can see, there are three ports involved in the definition of a `NodePort`
    Service. Let''s take a look at these:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`NodePort`服务的定义中涉及了三个端口。让我们来看看这些：
- en: '`targetPort`: This field represents the port where the application running
    on the Pods is exposed. This is the port that the Service forwards the request
    to. By default, `targetPort` is set to the same value as the `port` field.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`targetPort`：这个字段代表了Pod上运行的应用程序暴露的端口。这是服务转发请求的端口。默认情况下，`targetPort`设置为与`port`字段相同的值。'
- en: '`port`: This field represents the port of the Service itself.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`：这个字段代表了服务本身的端口。'
- en: '`nodePort`: This field represents the port on the node that we can use to access
    the Service itself.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodePort`：这个字段代表了我们可以用来访问服务本身的节点上的端口。'
- en: 'Besides the ports, there''s also another field called `selector` in the Service
    `spec` section. This section is used to specify the labels that a Pod needs to
    have in order to be selected by a Service. Once this Service is created, it will
    identify all the Pods that have the `app: nginx` and `environment: production`
    labels and add endpoints for all such Pods. We will look at endpoints in more
    detail in the following exercise.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '除了端口，服务`spec`部分还有另一个字段叫做`selector`。这个部分用于指定一个Pod需要具有哪些标签，才能被服务选中。一旦这个服务被创建，它将识别所有具有`app:
    nginx`和`environment: production`标签的Pod，并为所有这样的Pod添加端点。我们将在下一个练习中更详细地了解端点。'
- en: 'Exercise 8.01: Creating a Simple NodePort Service with Nginx Containers'
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.01：使用Nginx容器创建一个简单的NodePort服务
- en: In this exercise, we will create a simple NodePort Service with Nginx containers.
    Nginx containers, by default, expose port `80` on the Pod with an HTML page saying
    `Welcome to nginx!`. We will make sure that we can access that page from a browser
    on our local machine.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个简单的NodePort服务，使用Nginx容器。默认情况下，Nginx容器在Pod上暴露端口`80`，并显示一个HTML页面，上面写着`Welcome
    to nginx!`。我们将确保我们可以从本地机器的浏览器访问该页面。
- en: 'To successfully complete this exercise, perform the following steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功完成这个练习，请执行以下步骤：
- en: 'Create a file called `nginx-deployment.yaml` with the following content:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`nginx-deployment.yaml`的文件，内容如下：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the following command to create the Deployment using the `kubectl apply`
    command:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令使用`kubectl apply`命令创建部署：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should get the following output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see, `nginx-deployment` has been created.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`nginx-deployment`已经被创建。
- en: 'Run the following command to verify that the Deployment has created three replicas:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令验证部署是否创建了三个副本：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see a response similar to the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的响应：
- en: '![Figure 8.2: Getting all Pods'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2：获取所有Pod'
- en: '](image/B14870_08_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_02.jpg)'
- en: 'Figure 8.2: Getting all Pods'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：获取所有Pod
- en: 'Create a file called `nginx-service-nodeport.yaml` with the following content:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`nginx-service-nodeport.yaml`的文件，内容如下：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the following command to create the Service:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来创建服务：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Alternatively, we can use the `kubectl expose` command to expose a Deployment
    or a Pod using a Kubernetes Service. The following command will also create a
    NodePort Service named `nginx-service-nodeport`, with `port` and `targetPort`
    set to `80`. The only difference is that this command doesn''t allow us to customize
    the `nodePort` field. `nodePort` is automatically allocated when we create the
    Service using the `kubectl expose` command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`kubectl expose`命令来暴露一个部署或一个Pod，使用Kubernetes服务。以下命令还将创建一个名为`nginx-service-nodeport`的NodePort服务，`port`和`targetPort`设置为`80`。唯一的区别是，这个命令不允许我们自定义`nodePort`字段。使用`kubectl
    expose`命令创建服务时，`nodePort`会自动分配：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we use this command to create the Service, we will be able to figure out
    what `nodePort` was automatically assigned to the Service in the following step.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用这个命令创建服务，我们将能够在下一步中找出`nodePort`自动分配给服务的是什么。
- en: 'Run the following command to verify that the Service was created:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以验证服务是否已创建：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This should give a response similar to the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会得到类似以下的响应：
- en: '![Figure 8.3: Getting the NodePort Service'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3：获取NodePort服务'
- en: '](image/B14870_08_03.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_03.jpg)'
- en: 'Figure 8.3: Getting the NodePort Service'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：获取NodePort服务
- en: You can ignore the additional Service named `kubernetes`, which already existed
    before we created our Service. This Service is used to expose the Kubernetes API
    of the cluster internally.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以忽略名为`kubernetes`的额外服务，这个服务在我们创建服务之前已经存在。这个服务用于在集群内部暴露Kubernetes API。
- en: 'Run the following command to verify that the Service was created with the correct
    configuration:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以验证Service是否以正确的配置创建：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This should give us the following output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们以下输出：
- en: '![Figure 8.4: Describing the NodePort Service'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4：描述NodePort服务'
- en: '](image/B14870_08_04.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_04.jpg)'
- en: 'Figure 8.4: Describing the NodePort Service'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：描述NodePort服务
- en: In the highlighted sections of the output, we can confirm that the Service was
    created with the correct `Port`, `TargetPort`, and `NodePort` fields.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的突出显示部分，我们可以确认Service是使用正确的`Port`，`TargetPort`和`NodePort`字段创建的。
- en: There's also another field called `Endpoints`. We can see that the value of
    this field is a list of IP addresses; that is, `172.17.0.3:80`, `172.17.0.4:80`,
    and `172.17.0.5:80`. Each of these IP addresses points to the IP addresses allocated
    to the three Pods created by `nginx-deployment`, along with the target ports exposed
    by all of those Pods. We can use the `custom-columns` output format alongside
    the `kubectl get pods` command to get the IP addresses for all three pods. We
    can create a custom column output using the `status.podIP` field, which contains
    the IP address of a running Pod.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个字段叫做`Endpoints`。我们可以看到这个字段的值是一个IP地址列表；即`172.17.0.3:80`，`172.17.0.4:80`和`172.17.0.5:80`。这些IP地址分别指向由`nginx-deployment`创建的三个Pod分配的IP地址，以及所有这些Pod公开的目标端口。我们可以使用`kubectl
    get pods`命令以及`custom-columns`输出格式来获取所有三个Pod的IP地址。我们可以使用`status.podIP`字段创建自定义列输出，该字段包含正在运行的Pod的IP地址。
- en: 'Run the following command to see the IP addresses of all three Pods:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以查看所有三个Pod的IP地址：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should see the following output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Hence, we can see that the `Endpoints` field of the Service actually points
    to the IP addresses of our three Pods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到Service的`Endpoints`字段实际上指向我们三个Pod的IP地址。
- en: As we know in the case of a NodePort Service, we can access the Pod's application
    using the IP address of the node and the port exposed by the Service on the node.
    To do this, we need to find out the IP address of the node in the Kubernetes cluster.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，在NodePort服务的情况下，我们可以使用节点的IP地址和服务在节点上公开的端口来访问Pod的应用程序。为此，我们需要找出Kubernetes集群中节点的IP地址。
- en: 'Run the following command to get the IP address of the Kubernetes cluster running
    locally:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以获取本地运行的Kubernetes集群的IP地址：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should see the following response:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the following command to send a request to the IP address we obtained from
    the previous step at port `32023` using `curl`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，使用`curl`发送请求到我们从上一步获得的IP地址的端口`32023`：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should get a response from Nginx like so:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会收到Nginx的响应：
- en: '![Figure 8.5: Sending a curl request to check the NodePort Service'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5：发送curl请求以检查NodePort服务'
- en: '](image/B14870_08_05.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_05.jpg)'
- en: 'Figure 8.5: Sending a curl request to check the NodePort Service'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：发送curl请求以检查NodePort服务
- en: 'Finally, open your browser and enter `192.168.99.100:32023` to make sure we
    can get to the following page:![Figure 8.6: Accessing the application in a browser'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开浏览器并输入`192.168.99.100:32023`，以确保我们可以进入以下页面：![图8.6：在浏览器中访问应用程序
- en: '](image/B14870_08_06.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_06.jpg)'
- en: 'Figure 8.6: Accessing the application in a browser'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：在浏览器中访问应用程序
- en: Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Ideally, you would want to create the objects for each exercise and activity
    in different namespaces to keep them separate from the rest of your objects. So,
    feel free to create a namespace and create the Deployment in that namespace. Alternatively,
    you can ensure that you clean up any objects shown in the following commands so
    that there is no interference.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您希望为每个练习和活动创建不同的命名空间中的对象，以使它们与您的其他对象分开。因此，可以随意创建一个命名空间并在该命名空间中创建部署。或者，您可以确保清理掉以下命令中显示的任何对象，以确保没有干扰。
- en: 'Delete both the Deployment and the Service to ensure you''re working on the
    clean ground for the rest of the exercises in this chapter:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除部署和服务，以确保在本章节的其余练习中你在干净的环境中工作：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see the following response:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, delete the Service using the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令删除该服务：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should see this response:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到这个响应：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this exercise, we have created a Deployment with three replicas of the Nginx
    container (this can be replaced with any real application running in the container)
    and exposed the application using the NodePort Service.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建了一个具有三个Nginx容器副本的部署（这可以替换为在容器中运行的任何真实应用程序），并使用NodePort服务暴露了该应用程序。
- en: ClusterIP Service
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ClusterIP服务
- en: As we mentioned earlier, a ClusterIP Service exposes the application running
    on the Pods on an IP address that's accessible from inside the cluster only. This
    makes the ClusterIP Service a good type of Service to use for communication between
    different types of Pods inside the same cluster.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，ClusterIP服务会在集群内部暴露运行在Pod上的应用程序的IP地址。这使得ClusterIP服务成为在同一集群内不同类型的Pod之间进行通信的良好选择。
- en: For example, let's consider our earlier example of a simple survey application.
    Let's say we have a survey application that serves the frontend to show the forms
    to the users where they can fill in the surveys. It's running on a set of Pods
    managed by the `survey-frontend` Deployment. We also have another application
    that is responsible for validating and storing the data filled by the users. It's
    running on a set of Pods managed by the `survey-backend` Deployment. This backend
    application needs to be accessed internally by the survey frontend application.
    We can use a ClusterIP Service to expose the backend application so that the frontend
    Pods can easily access the backend application using a single IP address for that
    ClusterIP Service.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑一个简单调查应用的例子。假设我们有一个调查应用，用于向用户展示表单，用户可以在其中填写调查。它运行在由`survey-frontend`部署管理的一组Pod上。我们还有另一个应用，负责验证和存储用户填写的数据。它运行在由`survey-backend`部署管理的一组Pod上。这个后端应用需要被调查前端应用内部访问。我们可以使用ClusterIP服务来暴露后端应用，以便前端Pod可以使用单个IP地址轻松访问后端应用。
- en: Service Configuration
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务配置
- en: 'Here''s an example of what the configuration for a ClusterIP Service looks
    like:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是ClusterIP服务配置的示例：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `type` of Service is set to `ClusterIP`. Only two ports are needed for
    this type of the Service: `targetPort` and `port`. These represent the port where
    the application is exposed on the Pod and the port where the Service is created
    on a given cluster IP, respectively.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的`type`设置为`ClusterIP`。这种类型的服务只需要两个端口：`targetPort`和`port`。它们分别代表了应用程序在Pod上暴露的端口和在给定集群IP上创建的服务的端口。
- en: 'Similar to the NodePort Service, the ClusterIP Service''s configuration also
    needs a `selector` section, which is used to decide which Pods to select by the
    Service. In this example, this Service will select all the Pods that have both
    `app: nginx` and `environment: production` labels. We will create a simple ClusterIP
    Service in the following exercise based on a similar example.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '与NodePort服务类似，ClusterIP服务的配置也需要一个`selector`部分，用于决定服务选择哪些Pod。在这个例子中，这个服务将选择所有具有`app:
    nginx`和`environment: production`标签的Pod。我们将根据类似的示例在下一个练习中创建一个简单的ClusterIP服务。'
- en: 'Exercise 8.02: Creating a Simple ClusterIP Service with Nginx Containers'
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.02：使用Nginx容器创建一个简单的ClusterIP服务
- en: 'In this exercise, we will create a simple ClusterIP Service with Nginx containers.
    Nginx containers, by default, expose port `80` on the Pod with an HTML page saying
    `Welcome to nginx!`. We will make sure that we can access that page from inside
    the Kubernetes cluster using the `curl` command. Let''s get started:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用Nginx容器创建一个简单的ClusterIP服务。默认情况下，Nginx容器在Pod上暴露端口`80`，显示一个HTML页面，上面写着`Welcome
    to nginx!`。我们将确保我们可以使用`curl`命令从Kubernetes集群内部访问该页面。让我们开始吧：
- en: 'Create a file called `nginx-deployment.yaml` with the following content:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`nginx-deployment.yaml`的文件，内容如下：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the following command to create the Deployment using the `kubectl apply`
    command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，使用`kubectl apply`命令创建部署：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should see the following response:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the following command to verify that the Deployment has created three replicas:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以验证部署是否已创建三个副本：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You should see output similar to the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '![Figure 8.7: Getting all the Pods'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7：获取所有Pod'
- en: '](image/B14870_08_07.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_07.jpg)'
- en: 'Figure 8.7: Getting all the Pods'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：获取所有Pod
- en: 'Create a file called `nginx-service-clusterip.yaml` with the following content:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`nginx-service-clusterip.yaml`的文件，内容如下：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the following command to create the Service:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建服务：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You should see the following response:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the following command to verify that the Service was created:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以验证服务是否已创建：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should see the following response:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 8.8: Getting the ClusterIP Service'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8：获取ClusterIP服务'
- en: '](image/B14870_08_08.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_08.jpg)'
- en: 'Figure 8.8: Getting the ClusterIP Service'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：获取ClusterIP服务
- en: 'Run the following command to verify that the Service has been created with
    the correct configuration:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以验证服务是否已使用正确的配置创建：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should see the following response:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 8.9: Describing the ClusterIP Service'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9：描述ClusterIP服务'
- en: '](image/B14870_08_09.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_09.jpg)'
- en: 'Figure 8.9: Describing the ClusterIP Service'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：描述ClusterIP服务
- en: We can see that the Service has been created with the correct `Port` and `TargetPort`
    fields. In the `Endpoints` field, we can see the IP addresses of the Pods, along
    with the target ports on those Pods.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到服务已使用正确的`Port`和`TargetPort`字段创建。在`Endpoints`字段中，我们可以看到Pod的IP地址，以及这些Pod上的目标端口。
- en: 'Run the following command to see the IP addresses of all three Pods:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以查看所有三个Pod的IP地址：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should see the following response:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Hence, we can see that the `Endpoints` field of the Service actually points
    to the IP addresses of our three Pods.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到服务的`Endpoints`字段实际上指向我们三个Pod的IP地址。
- en: 'Run the following command to get the cluster IP of the Service:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以获取服务的集群IP：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This results in the following output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![Figure 8.10: Getting the cluster IP from the Service'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10：从服务获取集群IP'
- en: '](image/B14870_08_10.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_10.jpg)'
- en: 'Figure 8.10: Getting the cluster IP from the Service'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：从服务获取集群IP
- en: As we can see, the Service has a cluster IP of `10.99.11.74`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，服务的集群IP是`10.99.11.74`。
- en: We know that, in the case of a ClusterIP Service, we can access the application
    running on its endpoints from inside the cluster. So, we need to go inside the
    cluster to be able to check whether this really works.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，在ClusterIP服务的情况下，我们可以从集群内部访问其端点上运行的应用程序。因此，我们需要进入集群以检查这是否真的有效。
- en: 'Run the following command to access the `minikube` node via SSH:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令通过SSH访问`minikube`节点：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You will see the following response:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到以下响应：
- en: '![Figure 8.11: SSHing into the minikube node'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11：SSH进入minikube节点'
- en: '](image/B14870_08_11.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_11.jpg)'
- en: 'Figure 8.11: SSHing into the minikube node'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：SSH进入minikube节点
- en: 'Now that we are inside the cluster, we can try to access the cluster IP address
    of the Service and see whether we can access the Pods running Nginx:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在集群内部，我们可以尝试访问服务的集群IP地址，看看我们是否可以访问运行Nginx的Pods：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You should see the following response from Nginx:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 应该看到来自Nginx的以下响应：
- en: '![Figure 8.12: Sending a curl request to the Service from inside the cluster'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12：从集群内部向服务发送curl请求'
- en: '](image/B14870_08_12.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_12.jpg)'
- en: 'Figure 8.12: Sending a curl request to the Service from inside the cluster'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：从集群内部向服务发送curl请求
- en: Here, we can see that `curl` returns the HTML code for the default Nginx landing
    page. Thus, we can successfully access our Nginx Pods. Next, we will delete the
    Pods and Services.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`curl`返回默认Nginx欢迎页面的HTML代码。因此，我们可以成功访问我们的Nginx Pods。接下来，我们将删除Pods和Services。
- en: 'Run the following command to exit the SSH session inside minikube:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令退出minikube内部的SSH会话：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Delete the Deployment and the Service to ensure you''re working on the clean
    ground for the following exercises in this chapter:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除部署和服务，以确保在本章的后续练习中您正在处理干净的环境：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You should see the following response:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Delete the Service using the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令删除服务：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You should see the following response:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this exercise, we were able to expose the application running on multiple
    Pods on a single IP address. This can be accessed by all the other Pods running
    inside the same cluster.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们能够在单个IP地址上公开运行在多个Pods上的应用程序。这可以被同一集群内运行的所有其他Pods访问。
- en: Choosing a Custom IP Address for the Service
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为服务选择自定义IP地址
- en: In the previous exercise, we saw that the Service was created with a random
    available IP address inside the Kubernetes cluster. We can also specify an IP
    address if we want. This may be particularly useful if we already have a DNS entry
    for a particular address and we want to reuse that for our Service.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们看到服务是使用Kubernetes集群内的随机可用IP地址创建的。如果需要，我们也可以指定IP地址。如果我们已经为特定地址有DNS条目并且想要重用它作为我们的服务，这可能特别有用。
- en: We can do this by setting the `spec.clusterIP` field with a value of the IP
    address we want the Service to use. The IP address specified in this field should
    be a valid IPv4 or IPv6 address. If an invalid IP address is used to create the
    Service, the API server will return an error.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`spec.clusterIP`字段设置为我们希望服务使用的IP地址的值来实现这一点。在该字段中指定的IP地址应为有效的IPv4或IPv6地址。如果使用无效的IP地址创建服务，API服务器将返回错误。
- en: 'Exercise 8.03: Creating a ClusterIP Service with a Custom IP'
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.03：使用自定义IP创建ClusterIP服务
- en: 'In this exercise, we will create a ClusterIP Service with a custom IP address.
    We will try a random IP address. As in the previous exercise, we will make sure
    that we can access the default Nginx page from inside the Kubernetes cluster by
    using the `curl` command to the set IP address. Let''s get started:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用自定义IP地址创建一个ClusterIP服务。我们将尝试一个随机的IP地址。与之前的练习一样，我们将确保我们可以使用`curl`命令访问Kubernetes集群内的默认Nginx页面。让我们开始吧：
- en: Create a file called `nginx-deployment.yaml` with the same content that we used
    in the previous exercises in this chapter.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`nginx-deployment.yaml`的文件，内容与本章前面练习中使用的内容相同。
- en: 'Run the following command to create the Deployment:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建部署：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You should see the following response:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a file named `nginx-service-custom-clusterip.yaml` with the following
    content:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`nginx-service-custom-clusterip.yaml`的文件，内容如下：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This uses a random ClusterIP value at the moment.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 目前使用的是一个随机的ClusterIP值。
- en: 'Run the following command to create a Service with the preceding configuration:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建具有上述配置的服务：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You should see the following response:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 8.13: Service creation failure due to incorrect IP address'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.13：由于IP地址不正确而导致服务创建失败'
- en: '](image/B14870_08_13.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_13.jpg)'
- en: 'Figure 8.13: Service creation failure due to incorrect IP address'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：由于IP地址不正确而导致服务创建失败
- en: As we can see, the command gives us an error because the IP address we used
    (`10.90.10.70`) isn't in the valid IP range. As highlighted in the preceding output,
    the valid IP range is `10.96.0.0/12`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，该命令给出了一个错误，因为我们使用的IP地址（`10.90.10.70`）不在有效的IP范围内。正如在前面的输出中所强调的，有效的IP范围是`10.96.0.0/12`。
- en: 'We can actually find this valid range of IP addresses before creating the Service
    using the `kubectl cluster-info dump` command. It provides a lot of information
    that can be used for cluster debugging and diagnosis. We can filter for the `service-cluster-ip-range`
    string in the output of the command to find out the valid ranges of IP addresses
    we can use in a cluster. The following command will output the valid IP range:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以在创建服务之前使用`kubectl cluster-info dump`命令找到这些有效的IP地址范围。它提供了大量可用于集群调试和诊断的信息。我们可以在命令的输出中过滤`service-cluster-ip-range`字符串，以找出我们可以在集群中使用的有效IP地址范围。以下命令将输出有效的IP范围：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You should see the following output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We can then use the appropriate IP address for `clusterIP` for our Service.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为我们的服务使用适当的`clusterIP` IP地址。
- en: 'Modify the `nginx-service-custom-clusterip.yaml` file by changing the value
    of `clusterIP` to `10.96.0.5` since that''s one of the valid values:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`clusterIP`的值更改为`10.96.0.5`来修改`nginx-service-custom-clusterip.yaml`文件，因为这是一个有效的值：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Run the following command to create the Service again:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行以下命令以创建服务：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You should see the following output:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can see that the Service has been created successfully.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到服务已成功创建。
- en: 'Run the following command to ensure that the Service was created with the custom
    ClusterIP we specified in the configuration:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以确保服务是使用我们在配置中指定的自定义ClusterIP创建的：
- en: '[PRE50]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You should see the following output:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 8.14: Getting the ClusterIP from the Service'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.14：从服务获取ClusterIP'
- en: '](image/B14870_08_14.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_14.jpg)'
- en: 'Figure 8.14: Getting the ClusterIP from the Service'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：从服务获取ClusterIP
- en: Here, we can confirm that the Service was indeed created with the IP address
    mentioned in the configuration; that is, `10.96.0.5`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以确认服务确实是使用配置中提到的IP地址`10.96.0.5`创建的。
- en: 'Next, let''s confirm that we can access the Service using the custom IP address
    from inside the cluster:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们确认我们可以使用集群内的自定义IP地址访问服务：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You should see the following response:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 8.15: SSHing into the minikube node'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15：SSH进入minikube节点'
- en: '](image/B14870_08_15.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_15.jpg)'
- en: 'Figure 8.15: SSHing into the minikube node'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：SSH进入minikube节点
- en: 'Now, run the following command to send a request to `10.96.0.5:80` using `curl`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行以下命令，使用`curl`向`10.96.0.5:80`发送请求：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We intentionally skipped the port number (`80`) in the `curl` request because,
    by default, curl assumes the port number to be `80`. If the Service were using
    a different port number, we would have to specify that in the curl request explicitly.
    You should see the following output:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意在`curl`请求中跳过了端口号（`80`），因为默认情况下，curl假定端口号为`80`。如果服务使用不同的端口号，我们将不得不在curl请求中明确指定。您应该看到以下输出：
- en: '![Figure 8.16: Sending a curl request to a Service from the minikube node'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.16：从minikube节点向服务发送curl请求'
- en: '](image/B14870_08_16.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_16.jpg)'
- en: 'Figure 8.16: Sending a curl request to a Service from the minikube node'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16：从minikube节点向服务发送curl请求
- en: Thus, we can see that we are able to access our Service from inside the cluster
    and that that service can be accessed at the IP address that we defined for `clusterIP`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到我们能够从集群内部访问我们的服务，并且该服务可以在我们为`clusterIP`定义的IP地址上访问。
- en: LoadBalancer Service
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LoadBalancer服务
- en: A LoadBalancer Service exposes the application externally using the load balancer
    provided by the cloud provider. This type of Service has no default local implementation
    and can only be deployed using a cloud provider. The cloud providers provision
    a load balancer when a Service of the `LoadBalancer` type is created.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: LoadBalancer服务使用云提供商提供的负载均衡器来外部公开应用程序。这种类型的服务没有默认的本地实现，只能使用云提供商部署。当创建`LoadBalancer`类型的服务时，云提供商会提供一个负载均衡器。
- en: Thus, a LoadBalancer Service is basically a superset of the NodePort Service.
    The LoadBalancer Service uses the implementation offered by the cloud provider
    and assigns an external IP address to the Service.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，LoadBalancer服务基本上是NodePort服务的超集。LoadBalancer服务使用云提供商提供的实现，并为服务分配外部IP地址。
- en: 'The configuration of a `LoadBalancer` Service depends on the cloud provider.
    Each cloud provider requires you to add a particular set of metadata in the form
    of annotations. Here''s a simplified example of the configuration for a `LoadBalancer`
    Service:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadBalancer`服务的配置取决于云提供商。每个云提供商都需要您添加一组特定的元数据，以注释的形式。以下是`LoadBalancer`服务配置的简化示例：'
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ExternalName Service
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ExternalName服务
- en: The ExternalName Service maps a Service to a DNS name. In the case of the ExternalName
    Service, there's no proxying or forwarding. Redirecting the request happens at
    the DNS level instead. When a request comes for the Service, a CNAME record is
    returned with the value of the DNS name that was set in the Service configuration.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ExternalName服务将服务映射到DNS名称。在ExternalName服务的情况下，没有代理或转发。重定向请求发生在DNS级别。当请求服务时，将返回一个CNAME记录，其值为在服务配置中设置的DNS名称。
- en: 'The configuration of the ExternalName Service doesn''t contain any selectors.
    It looks as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ExternalName服务的配置不包含任何选择器。它看起来是这样的：
- en: '[PRE54]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding Service template maps `externalname-service` to a DNS name; for
    example, `my.example.domain.com`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的服务模板将`externalname-service`映射到一个DNS名称；例如，`my.example.domain.com`。
- en: Let's say you're migrating your production applications to a new Kubernetes
    cluster. A good approach is to start with stateless parts and move them to a Kubernetes
    cluster first. During the migration process, you will need to make sure those
    stateless parts in the Kubernetes cluster can still access the other production
    Services, such as database storage or other backend Services/APIs. In such a case,
    we can simply create an ExternalName Service so that our Pods from the new cluster
    can still access resources from the old cluster, which are outside the bounds
    of the new cluster. Hence, ExternalName provides communication between Kubernetes
    applications and external Services running outside the Kubernetes cluster.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在将生产应用程序迁移到一个新的Kubernetes集群。一个很好的方法是首先从无状态的部分开始，并将它们首先移动到Kubernetes集群。在迁移过程中，您需要确保Kubernetes集群中的这些无状态部分仍然可以访问其他生产服务，例如数据库存储或其他后端服务/
    API。在这种情况下，我们可以简单地创建一个ExternalName服务，以便我们的新集群中的Pod可以仍然访问旧集群中的资源，这些资源超出了新集群的范围。因此，ExternalName提供了Kubernetes应用程序与运行在Kubernetes集群之外的外部服务之间的通信。
- en: Ingress
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入口
- en: 'Ingress is an object that defines rules that are used to manage external access
    to the Services in a Kubernetes cluster. Typically, Ingress acts like a middleman
    between the internet and the Services running inside a cluster:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Ingress是一个定义规则的对象，用于管理对Kubernetes集群中服务的外部访问。通常，Ingress充当互联网和集群内运行的服务之间的中间人：
- en: '![Figure 8.17: Ingress'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17：入口'
- en: '](image/B14870_08_17.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_17.jpg)'
- en: 'Figure 8.17: Ingress'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17：入口
- en: You will learn much more about Ingress and the major motivations for using it
    in *Chapter 12*, *Your Application and HA*. Due to this, we will not cover the
    implementation of Ingress here.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在*第12章*“您的应用程序和HA”中学到更多关于Ingress以及使用它的主要动机。因此，在这里我们不会涵盖Ingress的实现。
- en: Now that we have learned about the different types of Services in Kubernetes,
    we will implement all of them to get an idea of how they would work together in
    a real-life scenario.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Kubernetes中不同类型的服务，我们将实现所有这些服务，以了解它们在实际情况下如何一起工作。
- en: 'Activity 8.01: Creating a Service to Expose the Application Running on a Pod'
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动8.01：创建一个服务来暴露运行在Pod上的应用程序
- en: Consider a scenario where the product team you're working with has created a
    survey application that has two independent and decoupled components – a frontend
    and a backend. The frontend component of the survey application renders the survey
    forms and needs to be exposed to external users. It also needs to communicate
    with the backend component, which is responsible for validating and storing the
    survey's responses.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个情景，你正在与产品团队合作，他们创建了一个调查应用程序，该应用程序有两个独立和解耦的组件 - 前端和后端。调查应用程序的前端组件呈现调查表单，并需要向外部用户公开。它还需要与后端组件通信，后端负责验证和存储调查的响应。
- en: 'For the scope of this activity, consider the following tasks:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本活动范围内，考虑以下任务：
- en: To avoid overcomplicating this activity, you can deploy the Apache server ([https://hub.docker.com/_/httpd](https://hub.docker.com/_/httpd))
    as the frontend, and we can treat its default placeholder home page as the component
    that should be visible to the survey applicants. Expose the frontend application
    so that it's accessible on the host node at port `31000`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免使这项活动过于复杂，您可以部署Apache服务器（[https://hub.docker.com/_/httpd](https://hub.docker.com/_/httpd)）作为前端，并且我们可以将其默认的占位符主页视为应该对调查申请人可见的组件。公开前端应用程序，以便在主机节点的端口`31000`上可以访问它。
- en: For the backend application, deploy an Nginx server. We will treat the default
    home page of Nginx as the page that you should be able to see from the backend.
    Expose the backend application so that it's accessible for the frontend application
    Pods in the same cluster.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于后端应用程序，部署一个Nginx服务器。我们将把Nginx的默认主页视为您应该能够从后端看到的页面。公开后端应用程序，以便前端应用程序Pod在同一集群中可以访问它。
- en: Both Apache and Nginx are exposed at port `80` on the Pods by default.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Apache和Nginx在Pod上以端口`80`公开。
- en: Note
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We are using Apache and Nginx here to keep the activity simple. In a real-world
    scenario, these two would be replaced with the frontend survey site and the backend
    data analysis component of your survey application, along with a database component
    for storing all the survey data.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用Apache和Nginx来保持活动简单。在实际情况下，这两者将被替换为前端调查站点和调查应用程序的后端数据分析组件，以及用于存储所有调查数据的数据库组件。
- en: To make sure frontend applications are aware of the backend application Service,
    add an environment variable to the frontend application Pods that contain the
    IP and the port address of the backend Service. This will ensure that the frontend
    applications know where to send a request to backend applications.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保前端应用程序知道后端应用程序服务，向包含后端服务的IP和端口地址的前端应用程序Pod添加环境变量。这将确保前端应用程序知道将请求发送到后端应用程序的位置。
- en: 'To add environment variables to a Pod, we can add a field named `env` to the
    `spec` section of a Pod configuration that contains a list of name and value pairs
    for all the environment variables we want to add. Here''s an example of how to
    add an environment variable called `APPLICATION_TYPE` with a value of `Frontend`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要向Pod添加环境变量，可以在Pod配置的`spec`部分中添加一个名为`env`的字段，其中包含我们想要添加的所有环境变量的名称和值对的列表。以下是如何添加名为`APPLICATION_TYPE`的环境变量，其值为`Frontend`的示例：
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We used something called a `ConfigMap` to add an environment variable here.
    We will learn more about them in *Chapter 10*, *ConfigMaps and Secrets*.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了一个叫做`ConfigMap`的东西来添加环境变量。我们将在*第10章* *ConfigMaps和Secrets*中学到更多关于它们的知识。
- en: Let's assume that, based on load testing the application, you have estimated
    that you'll initially need five replicas of the frontend application and four
    replicas of the backend application.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设根据对应用程序的负载测试，您估计最初需要五个前端应用程序副本和四个后端应用程序副本。
- en: 'The following are the high-level steps you will need to perform in order to
    complete this activity:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您需要执行的高级步骤，以完成此活动：
- en: Create a namespace for this activity.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此活动创建一个命名空间。
- en: Write an appropriate Deployment configuration for the backend application and
    create the Deployment.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为后端应用程序编写适当的部署配置，并创建部署。
- en: Write an appropriate Service configuration for the backend application with
    the appropriate Service type and create the Service.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为后端应用程序编写适当的服务配置，包括适当的服务类型，并创建服务。
- en: Ensure that the backend application is accessible, as expected.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保后端应用程序可以按预期访问。
- en: Write an appropriate Deployment configuration for the frontend application.
    Make sure it has the environment variables set for the IP address and the port
    address for the backend application Service.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为前端应用程序编写适当的部署配置。确保为后端应用程序服务的IP地址和端口地址设置了环境变量。
- en: Create a deployment for the frontend application.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为前端应用程序创建一个部署。
- en: Write an appropriate Service configuration for the frontend application with
    the appropriate service type and create the Service.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为前端应用程序编写适当的服务配置，包括适当的服务类型，并创建服务。
- en: Ensure that the frontend application is accessible as expected on port `31000`
    on the host node.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保前端应用程序在主机节点的端口`31000`上按预期可访问。
- en: '**Expected Output:**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输出：**'
- en: 'At the end of the exercise, you should be able to access the frontend application
    in the browser using the host IP address at port `31000`. You should see the following
    output in your browser:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在练习结束时，您应该能够使用主机IP地址和端口`31000`在浏览器中访问前端应用程序。您应该在浏览器中看到以下输出：
- en: '![Figure 8.18: Expected output of Activity 8.01'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.18：活动8.01的预期输出'
- en: '](image/B14870_08_18.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_08_18.jpg)'
- en: 'Figure 8.18: Expected output of Activity 8.01'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18：活动8.01的预期输出
- en: Note
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下地址找到：[https://packt.live/304PEoD](https://packt.live/304PEoD)。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the different ways in which we can expose our application
    running on Pods. We have seen how we can use a ClusterIP Service to expose an
    application inside the cluster. We have also seen how we can use a NodePort Service
    to expose an application outside the cluster. We have also covered the LoadBalancer
    and ExternalName Services in brief.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了在Pod上运行的应用程序的不同暴露方式。我们已经看到了如何使用ClusterIP服务来在集群内部暴露应用程序。我们还看到了如何使用NodePort服务来在集群外部暴露应用程序。我们还简要介绍了LoadBalancer和ExternalName服务。
- en: Now that we have created a Deployment and learned how to make it accessible
    from the external world, in the next chapter, we will focus on storage aspects.
    There, we will cover reading and storing data on disk, in and across Pods.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个部署，并学会了如何使它可以从外部世界访问，在下一章中，我们将专注于存储方面。在那里，我们将涵盖在磁盘上读取和存储数据，在Pod之间和跨Pod。
