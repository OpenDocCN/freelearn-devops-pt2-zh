- en: 13\. Runtime and Network Security in Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13\. Kubernetes中的运行时和网络安全
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will look at various resources that we can use to secure
    workloads running in our cluster. We will also understand a rough threat model
    and apply it to architect a secure cluster so that we can defend our cluster and
    application against various types of threats. By the end of this chapter, you
    will be able to create Role and ClusterRole, as well as RoleBinding and ClusterRoleBinding
    to control the access of any process or user to the Kubernetes API server and
    objects. Then, you will learn how to create a NetworkPolicy to restrict communication
    between your application and the database. You will also learn how to create a
    PodSecurityPolicy to ensure that the running components of your application are
    conforming to the defined limits.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看各种资源，我们可以使用来保护在我们集群中运行的工作负载。我们还将了解一个粗略的威胁模型，并将其应用于设计一个安全的集群，以便我们可以防御我们的集群和应用程序免受各种威胁。到本章结束时，您将能够创建Role和ClusterRole，以及RoleBinding和ClusterRoleBinding来控制任何进程或用户对Kubernetes
    API服务器和对象的访问。然后，您将学习如何创建NetworkPolicy来限制应用程序与数据库之间的通信。您还将学习如何创建PodSecurityPolicy来确保应用程序的运行组件符合定义的限制。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the last couple of chapters, we had our DevOps hat on and learned how to
    set up a cluster, as well as how to roll out new application versions safely and
    without downtime in Kubernetes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们戴上了DevOps的帽子，学习了如何在Kubernetes中设置集群，以及如何安全地部署新的应用程序版本而不会中断。
- en: Now, it's time to switch gears a bit, take our DevOps hat off, and put on our
    security analyst hat. First, we will look at where someone might attack our Kubernetes
    cluster and how an unauthorized user could potentially wreak havoc in our cluster.
    After that, we're going to introduce a few of the security primitives of Kubernetes
    and how we can combat the most common forms of attack. Finally, we'll further
    modify our application and demonstrate how some of these security primitives work.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候稍微转换一下，摘下我们的DevOps帽子，戴上我们的安全分析师帽子。首先，我们将看看有人可能攻击我们的Kubernetes集群的地方，以及未经授权的用户如何可能在我们的集群中造成严重破坏。之后，我们将介绍Kubernetes的一些安全原语以及我们如何对抗最常见的攻击形式。最后，我们将进一步修改我们的应用程序，并演示一些这些安全原语是如何工作的。
- en: But before we get to any of it, let's begin by taking a brief look at the various
    areas of concern for security in a modern web application, as well as a basic
    paradigm for implementing effective security for our cluster. We'll start by examining
    what we call the "4Cs of Cloud Native Security."
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们开始任何工作之前，让我们首先简要地看一下现代Web应用程序安全的各个关注领域，以及为我们的集群实施有效安全的基本范式。我们将首先检查我们所谓的“云原生安全的4C”。
- en: Threat Modeling
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 威胁建模
- en: It is far beyond the scope of this chapter to adequately teach many of the necessary
    disciplines of security so that you have a rigorous understanding of how modern
    workload security should be implemented and orchestrated. However, we will briefly
    gain an idea of how we should be thinking about it. Threat modeling is a discipline
    where we examine the various areas where our applications could be subject to
    an attack or unauthorized usage.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的范围远远超出了充分教授许多必要的安全学科的范围，以便您对现代工作负载安全应该如何实施和编排有严格的理解。然而，我们将简要了解我们应该如何思考。威胁建模是一种学科，我们在其中检查我们的应用程序可能受到攻击或未经授权使用的各个领域。
- en: For example, consider an HTTP web server. It will typically have ports 80 and
    443 exposed for serving web traffic, but it also acts as an entry point for any
    potential attackers. It may have a web management console exposed at a certain
    port. It may have certain other management ports open and API access to allow
    other software to manage it for automation purposes. The application runtime may
    need to regularly handle sensitive data. The entire end-to-end pipeline meant
    to create and deliver the application could expose various points that are vulnerable
    to compromise. The encryption algorithms that an application relies on may be
    compromised or made obsolete due to the increased sophistication of brute-force
    attacks. All these represent the various areas where our application could be
    subject to an attack.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个HTTP Web服务器。它通常会暴露端口80和443以提供Web流量服务，但它也作为潜在攻击者的入口点。它可能在某个端口上暴露Web管理控制台。它可能打开某些其他管理端口和API访问，以允许其他软件进行自动化管理。应用程序运行时可能需要定期处理敏感数据。用于创建和交付应用程序的整个端到端流水线可能暴露出各种容易受到攻击的点。应用程序依赖的加密算法可能会因暴力攻击的增加而被破坏或过时。所有这些都代表了我们的应用程序可能受到攻击的各个领域。
- en: 'An easy way to organize some of the attack vectors of our application is to
    remember the acronym **STRIDE**. It stands for the following types of attacks:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 组织应用程序的一些攻击向量的简单方法是记住缩写**STRIDE**。它代表以下类型的攻击：
- en: '**S**poofing: A user or an application disguising themselves as someone else.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**欺骗：用户或应用程序伪装成其他人。'
- en: '**T**ampering: Changing any data without seeking consent from or providing
    information to the concerned stakeholders.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**T**篡改：未经相关利益相关者同意更改任何数据或提供信息。'
- en: '**R**epudiation: Being able to deny your involvement in your actions and/or
    the lack of ability to trace any actions to a particular user.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**R**否认：否认参与行为或无法追踪特定用户的任何行为。'
- en: '**I**nformation disclosure: Exfiltrating privileged or sensitive information
    you were not intended to have.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**信息泄露：窃取你未被授权获取的特权或敏感信息。'
- en: '**D**enial of service: Flooding a server with bogus requests to saturate its
    resources and deny it the ability to serve its intended purpose.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**拒绝服务：向服务器发送虚假请求以使其资源饱和，并拒绝其提供预期目的的能力。'
- en: '**E**levation of privilege: Getting access to a restricted resource or privilege
    by exploiting bugs.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**E**特权提升：通过利用漏洞获得对受限资源或特权的访问。'
- en: Many of the attacks that hackers carry out are designed to do one or more of
    the preceding, usually to jeopardize the confidentiality, integrity, and availability
    of our data. With this in mind, we can use a mental model of how we can think
    about where threats to our system might exist in various parts of a modern cloud
    native application stack. This mental model is called "The 4Cs of Cloud Native
    Security," and we'll be using it to organize our exploration of the security primitives
    of Kubernetes. Ideally, by leveraging all these primitives, this should give you
    a good level of confidence in your application's resistance to STRIDE-like attacks,
    specifically within the context of Kubernetes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 许多黑客发动的攻击都旨在执行上述一项或多项行动，通常是为了危害我们数据的机密性、完整性和可用性。考虑到这一点，我们可以使用一个心智模型来思考我们的系统可能存在威胁的各个部分在现代云原生应用程序堆栈中的位置。这个心智模型被称为“云原生安全的4C”，我们将使用它来组织我们对Kubernetes安全原语的探索。理想情况下，通过利用所有这些原语，这应该能够让您对应用程序在Kubernetes环境中对抗类STRIDE攻击具有较高的信心。
- en: The 4Cs of Cloud Native Security
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云原生安全的4C
- en: 'Security can and should be organized into layers. This is considered a "defense
    in depth" approach to security and it is widely regarded by the technology community
    as the best way to prevent the compromise of any single component from exposing
    the whole system. When it comes to cloud native applications, we think of security
    in four layers: securing your code, containers, cluster, and cloud. The following
    diagram shows how they are organized. This helps us visualize that if a compromise
    happens at a lower level, it will most assuredly compromise a higher level that
    depends on it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 安全可以并且应该组织成层。这被认为是安全的“深度防御”方法，并且被技术界普遍认为是防止任何单个组件暴露整个系统的最佳方式。当涉及到云原生应用程序时，我们认为安全分为四个层次：保护您的代码、容器、集群和云。以下图表显示了它们是如何组织的。这帮助我们想象，如果在较低层次发生了妥协，它几乎肯定会妥协依赖它的更高层次：
- en: '![Figure 13.1: The 4Cs of Cloud Native Security'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.1：云原生安全的4C'
- en: '](image/B14870_13_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_13_01.jpg)'
- en: 'Figure 13.1: The 4Cs of Cloud Native Security'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：云原生安全的4C
- en: Since this book is focused on Kubernetes, we'll zoom into cluster security and
    then begin to implement some of the suggestions in our example application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书侧重于Kubernetes，我们将重点关注集群安全，然后开始在我们的示例应用程序中实施一些建议。
- en: Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For suggestions on the other C''s, take a look at this link: [https://kubernetes.io/docs/concepts/security/overview/](https://kubernetes.io/docs/concepts/security/overview/).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有关其他C的建议，请查看此链接：[https://kubernetes.io/docs/concepts/security/overview/](https://kubernetes.io/docs/concepts/security/overview/)。
- en: Cluster Security
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群安全
- en: One way to think about Kubernetes is as a gigantic self-orchestrating pool of
    compute, networking, and storage. As such, in many respects, Kubernetes is *exactly
    like a cloud platform*. It is important to understand this equivalence because
    this mental abstraction allows us to reason differently as a cluster operator
    versus a cluster developer. A cluster operator would want to ensure that all the
    components *of* the cluster were secure and hardened against any workload. A cluster
    developer would concern themselves with ensuring that the workload they are defining
    for Kubernetes is running securely inside the cluster.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一种思考Kubernetes的方式是将其视为一个巨大的自我编排的计算、网络和存储池。因此，在许多方面，Kubernetes *就像一个云平台*。理解这种等价性很重要，因为这种心理抽象使我们能够以集群操作员与集群开发人员的不同方式进行推理。集群操作员希望确保集群的所有组件都安全，并且针对任何工作负载进行了加固。集群开发人员将关注确保他们为Kubernetes定义的工作负载在集群内安全运行。
- en: 'Here is where your work becomes a bit easy – most cloud provider offerings
    from Kubernetes will ensure the security of the Kubernetes control plane for you.
    If, for whatever reason, you''re not able to leverage a cloud provider offering,
    you''ll want to read more in the documentation about securing your cluster at
    this link: [https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/](https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您的工作变得有点容易 - 大多数Kubernetes的云提供商提供的服务将为您确保Kubernetes控制平面的安全。如果由于某种原因，您无法利用云提供商的服务，您将希望在此链接的文档中阅读有关在此链接上保护您的集群的更多信息：[https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/](https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/)。
- en: Even when you are using a cloud provider's offering, just because they are securing
    your control plane does not mean that your Kubernetes cluster is secure. The reason
    you cannot rely on your cloud provider's security is that your application, its
    container, or a poor policy implementation could leave your infrastructure very
    exposed to attacks. So, now, we need to talk about securing workloads within our
    cluster.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您使用的是云提供商的服务，仅仅因为他们在保护您的控制平面并不意味着您的Kubernetes集群是安全的。您不能依赖于云提供商的安全性的原因是，您的应用程序、其容器或糟糕的策略实施可能会使您的基础设施非常容易受到攻击。因此，现在，我们需要讨论如何在集群内保护工作负载。
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is active work being done in the Kubernetes community to improve security
    concepts and implementations. The relevant Kubernetes documentation should be
    revisited often to determine whether improvements have been made.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes社区正在积极开展工作，以改进安全概念和实施。相关的Kubernetes文档应经常重新审视，以确定是否已经进行了改进。
- en: 'To fortify our internal cluster security, we need to take a look at the following
    three concepts:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强我们内部集群的安全性，我们需要关注以下三个概念：
- en: '**Kubernetes RBAC**: This is the main policy engine of Kubernetes. It defines
    a system of roles and permissions, as well as how permissions are granted to those
    roles.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes RBAC**：这是Kubernetes的主要策略引擎。它定义了一套角色和权限系统，以及如何将权限授予这些角色。'
- en: '**NetworkPolicies**: These are (depending on your Container Network Interface
    plugin) policies that act as a "firewall" between Pods. Think of them as a Kubernetes-aware
    network access control list.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络策略**：这些是（取决于您的容器网络接口插件）在Pod之间充当“防火墙”的策略。将它们视为Kubernetes感知的网络访问控制列表。'
- en: '**PodSecurityPolicies**: These are defined at a particular scope (namespace,
    whole cluster) and serve as a definition of how a Pod is allowed to run in Kubernetes.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod安全策略**：这些是在特定范围（命名空间、整个集群）定义的，并且作为Pod在Kubernetes中允许运行的定义。'
- en: We will not be covering encrypting Kubernetes Secrets at rest in etcd as most
    cloud providers either handle that for you or the implementation is specific to
    that cloud provider (such as AWS KMS).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会涵盖在etcd中对Kubernetes Secrets进行加密，因为大多数云提供商要么为您处理这个问题，要么实现是特定于该云提供商的（例如AWS
    KMS）。
- en: Kubernetes RBAC
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes RBAC
- en: Before we dive into RBAC, recall from *Chapter 4*, *How to Communicate with
    Kubernetes (API Server)*, how Kubernetes authorizes requests to the API. We learned
    that there are three stages – Authentication, Authorization, and AdmissionControl.
    We will learn more about Admission Controllers in *Chapter 16*, *Kubernetes Admission
    Controllers*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究RBAC之前，请回顾一下*第4章*中关于Kubernetes如何授权对API的请求的内容，我们了解到有三个阶段-认证、授权和准入控制。我们将在*第16章*中更多地了解准入控制器。
- en: Kubernetes supports multiple different methods of authenticating with the cluster,
    and you'll want to reference your cloud provider's documentation to get more details
    on their specific implementation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes支持多种不同的集群认证方法，您需要参考您的云提供商的文档，以获取有关其特定实现的更多详细信息。
- en: Authorization logic is handled through something called **RBAC**. It stands
    for **role-based access control** and it's the foundation of how we constrain
    certain users and groups to the minimum necessary permissions to perform their
    job. This is based on a concept in software security called "the principle of
    least privilege." For example, if you are a software engineer for a credit card
    processing company, **Payment Card Industry Data Security Standard** (**PCI DSS**)
    compliance requires that you shouldn't have access to production clusters and
    customer data. Therefore, if you did have access to a cluster in production, you
    should have a role that has no privileges.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 授权逻辑是通过一种称为**RBAC**的东西处理的。它代表**基于角色的访问控制**，是我们约束某些用户和组只能执行其工作所需的最低权限的基础。这基于软件安全中的一个概念，称为“最小特权原则”。例如，如果你是一家信用卡处理公司的软件工程师，**PCI
    DSS**合规要求你不应该访问生产集群和客户数据。因此，如果你确实可以访问生产集群，你应该有一个没有特权的角色。
- en: 'RBAC is implemented by cluster administrators through four different API objects:
    **Roles**, **RoleBindings**, **ClusterRoles**, and **ClusterRoleBindings**. Let''s
    look at how they work together by examining a diagram:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC是由集群管理员通过四种不同的API对象实现的：**Roles**、**RoleBindings**、**ClusterRoles**和**ClusterRoleBindings**。让我们通过检查一个图表来看它们是如何一起工作的：
- en: '![Figure 13.2: Different objects interacting to implement RBAC'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.2：不同对象相互作用以实现RBAC'
- en: '](image/B14870_13_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_13_02.jpg)'
- en: 'Figure 13.2: Different objects interacting to implement RBAC'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：不同对象相互作用以实现RBAC
- en: In this diagram, we can see that Kubernetes `User`/`Group` and `ServiceAccount`
    objects obtain their permissions by being bound to a `Role` or `ClusterRole`.
    Let's understand these objects individually.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，我们可以看到Kubernetes的`User`/`Group`和`ServiceAccount`对象通过绑定到`Role`或`ClusterRole`来获得他们的权限。让我们分别了解这些对象。
- en: Role
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: 'Here is a sample spec for a Role:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Role的样本规范：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The various fields define the permissions that a Role should have:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 各种字段定义了Role应该具有的权限：
- en: '`namespace`: Roles are scoped to a Kubernetes namespace, which is defined in
    this field. This makes a Role different from a ClusterRole, whose permissions
    apply for any namespace in the cluster.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespace`：Roles适用于Kubernetes命名空间，这在这个字段中定义。这使得Role与ClusterRole不同，后者的权限适用于集群中的任何命名空间。'
- en: '`verbs`: These describe which Kubernetes actions we are allowing. Some examples
    of commonly used verbs include `get`, `list`, `watch`, `create`, `update`, and
    `delete`. There are more, but these are usually good enough for most use cases.
    For a refresher on this, please refer to *The Kubernetes API* section of *Chapter
    4*, *How to Communicate with Kubernetes (API Server)*.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`动词`：这些描述了我们允许的Kubernetes操作。一些常用动词的例子包括`get`、`list`、`watch`、`create`、`update`和`delete`。还有更多，但这些通常对大多数用例来说已经足够了。如果需要复习，请参考*第4章*的*Kubernetes
    API*部分，*如何与Kubernetes（API服务器）通信*。'
- en: '`apiGroups`: These describe which Kubernetes API groups the Role will have
    access to. These are specified as `<group>/<version>` (such as `apps/v1`). If
    you use CustomResourceDefinitions, these API groups can be referenced here as
    well.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiGroups`：这些描述了Role将访问的Kubernetes API组。这些被指定为`<group>/<version>`（比如`apps/v1`）。如果使用CustomResourceDefinitions，这些API组也可以在这里引用。'
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'A full list of API groups that ship with Kubernetes can be found here (as of
    version 1.18): [https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes随附的API组的完整列表可以在这里找到（截至版本1.18）：[https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/)。
- en: '`resources`: These describe which API objects we are talking about and are
    defined by the value in the `Kind` field of the object definition; for example,
    `deployment`, `secret`, `configmap`, `pod`, `node`, and others.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources`：这些描述了我们正在讨论的API对象，并由对象定义的`Kind`字段中的值定义；例如，`deployment`、`secret`、`configmap`、`pod`、`node`等。'
- en: RoleBinding
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RoleBinding
- en: 'As shown in the preceding diagram, a RoleBinding binds or associates a Role
    to ServiceAccounts, users, or groups of users. Here''s a sample spec for a RoleBinding:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，RoleBinding将角色绑定或关联到ServiceAccounts、用户或用户组。以下是RoleBinding的示例规范：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This spec defines the subjects that should be able to use a Role to perform
    an action that requires authorization in Kubernetes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此规范定义了应该能够使用角色执行需要在Kubernetes中进行授权的操作的主体：
- en: '`subjects`: This refers to an authenticated ServiceAccount, user, or group
    that should be able to use this Role.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subjects`：这指的是经过身份验证的ServiceAccount、用户或应该能够使用此角色的组。'
- en: '`roleRef`: This refers to the Role they can assume.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`roleRef`：这指的是他们可以承担的角色。'
- en: ClusterRole
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ClusterRole
- en: A ClusterRole is identical to a Role in every way except one. Instead of granting
    permissions only inside one Kubernetes namespace, it grants this set of permissions
    cluster-wide.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ClusterRole在每个方面都与Role相同，除了一个方面。它不仅在一个Kubernetes命名空间内授予权限，而且在整个集群范围内授予权限。
- en: ClusterRoleBinding
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ClusterRoleBinding
- en: This is identical to a RoleBinding except that it must be bound to a ClusterRole
    and not a Role. You cannot bind a ClusterRoleBinding to a Role, nor a RoleBinding
    to a ClusterRole.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这与RoleBinding相同，只是它必须绑定到ClusterRole而不是Role。您不能将ClusterRoleBinding绑定到Role，也不能将RoleBinding绑定到ClusterRole。
- en: Some Important Notes about RBAC Policies
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有关RBAC策略的一些重要说明
- en: RBAC policy documents are allow-only. This means that, by default, a subject
    has no access, and only via RoleBinding or ClusterRoleBinding will it have the
    specific access set forth in the corresponding Role or ClusterRole.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RBAC策略文档仅允许。这意味着，默认情况下，主体没有访问权限，只有通过RoleBinding或ClusterRoleBinding才能具有相应角色或集群角色中规定的特定访问权限。
- en: Bindings are immutable. This means that once you have bound a subject to a Role
    or ClusterRole, it cannot be changed. This is to prevent privilege escalation.
    As such, an entity can be granted permission to modify objects (which is good
    enough for many use cases) while preventing it from elevating its own privileges.
    If you need to modify a binding, simply delete and recreate it.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定是不可变的。这意味着一旦您将主体绑定到角色或集群角色，就无法更改。这是为了防止特权升级。因此，实体可以被授予修改对象的权限（对于许多用例来说已经足够好），同时防止它提升自己的特权。如果需要修改绑定，只需删除并重新创建。
- en: A ClusterRole or Role that can create other ClusterRoles and Roles will only
    be able to grant, at most, the same permissions it has. Otherwise, it would be
    a clear privilege escalation path.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以创建其他ClusterRoles和Roles的ClusterRole或Role只能授予最多与其相同的权限。否则，这将是一个明显的特权升级路径。
- en: ServiceAccount
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务账户
- en: In the previous chapters, when we learned about authentication in terms of Minikube
    and Kops, we saw that Kubernetes generated certificates that we used. In the case
    of EKS, AWS IAM roles and the AWS IAM Authenticator were used.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，当我们学习有关Minikube和Kops的身份验证时，我们看到Kubernetes生成了我们使用的证书。在EKS的情况下，使用了AWS IAM角色和AWS
    IAM Authenticator。
- en: As it turns out, Kubernetes has a special object type for allowing resources
    within the cluster to authenticate with the API server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，Kubernetes有一个特殊的对象类型，允许集群内的资源与API服务器进行身份验证。
- en: We can use the ServiceAccount resource to allow Pods to receive a Kubernetes-generated
    token that it will pass to the API server for authentication. All official Kubernetes
    client libraries support this type of authentication, so it is the preferred method
    for programmatic Kubernetes cluster access from within the cluster.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用ServiceAccount资源来允许Pods接收Kubernetes生成的令牌，它将传递给API服务器进行身份验证。所有官方的Kubernetes客户端库都支持这种类型的身份验证，因此这是从集群内部进行程序化Kubernetes集群访问的首选方法。
- en: 'When you are running as a cluster admin, you can use `kubectl` to authenticate
    using a particular ServiceAccount using the `--as` parameter. For the example
    ServiceAccount shown previously, this would look something like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当您以集群管理员身份运行时，可以使用`kubectl`使用`--as`参数对特定ServiceAccount进行身份验证。对于之前显示的示例ServiceAccount，这将看起来像这样：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We'll learn how these objects work together so that we can control access in
    the following exercise.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习这些对象如何一起工作，以便在以下练习中控制访问。
- en: 'Exercise 13.01: Creating a Kubernetes RBAC ClusterRole'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.01：创建Kubernetes RBAC ClusterRole
- en: 'In this exercise, we will create a ClusterRole and ClusterRoleBinding. Then,
    we will become the user and inherit their permissions, as defined by the ClusterRole,
    and demonstrate how Kubernetes prevents access to certain APIs based on rules.
    Let''s get started:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个ClusterRole和ClusterRoleBinding。然后，我们将成为用户并继承他们的权限，如ClusterRole所定义的，并演示Kubernetes如何基于规则阻止对某些API的访问。让我们开始吧：
- en: 'To begin with, we will recreate the EKS cluster from the Terraform file we
    used in *Exercise 12.02*, *Creating a Cluster with EKS Using Terraform*. If you
    already have the `main.tf` file, you can work with it. Otherwise, you can run
    the following command to get it:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从我们在*练习12.02*中使用的Terraform文件中重新创建EKS集群，*使用Terraform创建EKS集群*。如果您已经有`main.tf`文件，可以使用它。否则，您可以运行以下命令获取它：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, use the following two commands, one after the other, to get your cluster
    resources up and running:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，依次使用以下两个命令，将您的集群资源恢复运行：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: After performing any of these exercises, if you plan to continue working through
    the following exercises after a significant amount of time, it might be a good
    idea to deallocate your cluster resources to stop AWS billing. You can do that
    using the `terraform destroy` command. Then, you can run this step to get everything
    back online again when you are ready to perform an exercise or activity.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任何这些练习之后，如果您计划在较长时间后继续进行以下练习，最好释放集群资源以停止AWS计费。您可以使用`terraform destroy`命令来做到这一点。然后，当您准备进行练习或活动时，可以运行此步骤将所有内容恢复在线。
- en: If any exercise or activity relies on objects that were created in the previous
    exercises, you will need to recreate those objects as well.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何练习或活动依赖于在先前练习中创建的对象，您还需要重新创建这些对象。
- en: 'Now, we''re going to create three YAML files for our RBAC resources. The first
    is a ServiceAccount that lets us have identity and authentication tokens granted
    to us by the cluster. Create a file called `sa.yaml` with the following content:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为我们的RBAC资源创建三个YAML文件。第一个是一个ServiceAccount，它允许我们通过集群授予的身份和认证令牌。创建一个名为`sa.yaml`的文件，内容如下：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we are going to create a ClusterRole object and assign it some permissions.
    Create a file called `cr.yaml` with the following content:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个ClusterRole对象并分配一些权限。创建一个名为`cr.yaml`的文件，内容如下：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are defining a `ClusterRole` with the ability to list all the Pods in any
    namespace, but nothing else.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在定义一个`ClusterRole`，它具有列出任何命名空间中所有Pod的能力，但其他操作不能执行。
- en: 'Next, we are going to create a `ClusterRoleBinding` object that will bind the
    created ServiceAccount and ClusterRole. Create a file called `crb.yaml` with the
    following content:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`ClusterRoleBinding`对象，将创建的ServiceAccount和ClusterRole绑定在一起。创建一个名为`crb.yaml`的文件，内容如下：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In these files, we are defining three objects: a `ServiceAccount`, a `ClusterRole`,
    and a `ClusterRoleBinding`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些文件中，我们定义了三个对象：`ServiceAccount`、`ClusterRole`和`ClusterRoleBinding`。
- en: 'Run the following command to create this RBAC policy, as well as our ServiceAccount:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来创建此RBAC策略，以及我们的ServiceAccount：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should see the following response:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 13.3: Creating a ServiceAccount, a ClusterRole, and a ClusterRoleBinding'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.3：创建ServiceAccount、ClusterRole和ClusterRoleBinding'
- en: '](image/B14870_13_03.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_13_03.jpg)'
- en: 'Figure 13.3: Creating a ServiceAccount, a ClusterRole, and a ClusterRoleBinding'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：创建ServiceAccount、ClusterRole和ClusterRoleBinding
- en: 'In the following steps, we will demonstrate that using our service account''s
    ClusterRole will prevent us from describing Pods. But before that, let''s get
    a list of the Pods and prove that everything still works. Do this by running the
    following command:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将演示使用我们的服务账户的ClusterRole将阻止我们描述Pods。但在那之前，让我们先获取Pod的列表，并证明一切仍然正常工作。通过运行以下命令来实现：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see the following response:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 13.4: Getting the list of Pods'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.4：获取Pod列表'
- en: '](image/B14870_13_04.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_13_04.jpg)'
- en: 'Figure 13.4: Getting the list of Pods'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4：获取Pod列表
- en: 'Now, let''s describe the first Pod. The name of the first Pod here is `aws-node-fzr6m`.
    The `describe` command, in this case, would be as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们描述第一个Pod。这里第一个Pod的名称是`aws-node-fzr6m`。在这种情况下，`describe`命令将如下所示：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Please use the Pod name that you have for your cluster. You should see a response
    similar to the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用您集群中的Pod名称。您应该看到类似以下的响应：
- en: '![Figure 13.5: Describing the aws-node-fzr6m Pod'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.5：描述aws-node-fzr6m Pod'
- en: '](image/B14870_13_05.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_13_05.jpg)'
- en: 'Figure 13.5: Describing the aws-node-fzr6m Pod'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5：描述aws-node-fzr6m Pod
- en: The preceding screenshot shows the truncated version of the output of the `describe`
    command.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了“describe”命令输出的截断版本。
- en: 'Now, we will run the same commands we used previously, but this time pretending
    to be the user using the ServiceAccount that is currently bound to the ClusterRole
    and ClusterRoleBinding that we created. We''ll do this by using the `--as` parameter
    with `kubectl`. Thus, the command will look like this:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将运行与之前相同的命令，但这次假装是使用当前绑定到我们创建的ClusterRole和ClusterRoleBinding的ServiceAccount的用户。我们将使用`kubectl`的`--as`参数来实现这一点。因此，命令将如下所示：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that we can assume the ClusterRole because we are an admin in the cluster
    that we created. You should see the following response:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以假设ClusterRole，因为我们是我们创建的集群中的管理员。您应该看到以下响应：
- en: '![Figure 13.6: Getting the list of Pods while assuming the test-sa ServiceAccount'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.6：假设test-sa ServiceAccount获取Pod列表'
- en: '](image/B14870_13_06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_13_06.jpg)'
- en: 'Figure 13.6: Getting the list of Pods while assuming the test-sa ServiceAccount'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6：假设test-sa ServiceAccount获取Pod列表
- en: Sure enough, that still works. As you may recall from *step 3*, we mentioned
    the `list` as an allowed verb, which is what's used for fetching the list of all
    resources of a certain kind.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，这仍然有效。正如您可能还记得的那样，从*步骤3*中可以看到，我们提到了“list”作为一个允许的动词，这是用于获取某种类型的所有资源列表的动词。
- en: 'Now, let''s see what happens if a user with the ClusterRole we created attempts
    to describe a Pod:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果具有我们创建的ClusterRole的用户尝试描述一个Pod会发生什么：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should see the following response:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 13.7: Forbidden error'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.7：禁止错误'
- en: '](image/B14870_13_07.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_13_07.jpg)'
- en: 'Figure 13.7: Forbidden error'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7：禁止错误
- en: The kubectl `describe` command uses the `get` verb. Recall from *step 3* that
    it was not on the allowed list of verbs for our ClusterRole.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl `describe`命令使用`get`动词。回想一下*步骤3*，它不在我们的ClusterRole允许的动词列表中。
- en: 'If this were a user (or a hacker) trying to use any command not allowed for
    them, we would have successfully stopped it. There are many practical RBAC examples
    available on the Kubernetes documentation website. It is beyond the scope of this
    chapter to talk about all the design patterns for RBAC in Kubernetes. All we can
    say is this: wherever possible, you should be practicing the "principle of least
    privilege" to limit unnecessary access to the Kubernetes API server. That is,
    everyone should get the minimum level of access required to do their job; not
    everyone needs to be a cluster admin.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个用户（或黑客）试图使用任何不允许的命令，我们将成功阻止它。Kubernetes文档网站上有许多实用的RBAC示例。在本章中讨论Kubernetes中所有RBAC的设计模式超出了范围。我们只能说：在可能的情况下，您应该实践“最小特权原则”，以限制对Kubernetes
    API服务器的不必要访问。也就是说，每个人都应该获得完成工作所需的最低访问级别；并非每个人都需要成为集群管理员。
- en: 'While we cannot make specific recommendations about security at your company,
    we can say that there are a few good "rules of thumb," which can be stated as
    follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们无法就公司的安全性做出具体建议，但我们可以说有一些不错的“经验法则”，可以表述如下：
- en: Whenever possible, try to make cluster contributors/users inside of a Role instead
    of a ClusterRole. Since a Role is constrained to a namespace, this will prevent
    that user from gaining unauthorized access to another namespace.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，尝试将集群贡献者/用户放在角色中，而不是ClusterRole中。由于角色受到命名空间的限制，这将防止用户未经授权地访问另一个命名空间。
- en: Only cluster admins should have access to ClusterRoles, which should be limited
    and temporary in scope. For example, if you do on-call rotations where engineers
    are responsible for the availability of your services, then they should only have
    an admin ClusterRole for the time they are on call.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有集群管理员应该访问ClusterRoles，这应该是有限且临时的。例如，如果您进行值班轮换，工程师负责您的服务的可用性，那么他们在值班期间应该只有管理员ClusterRole。
- en: NetworkPolicies
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络策略
- en: NetworkPolicy objects in Kubernetes are essentially Network Access Control Lists
    but at the Pod and namespace level. They work by using label selection (such as
    Services) or by indicating a CIDR IP address range to allow on a particular port/protocol.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的NetworkPolicy对象本质上是Pod和命名空间级别的网络访问控制列表。它们通过使用标签选择（例如服务）或指示CIDR IP地址范围来允许特定端口/协议上的访问。
- en: 'This is immensely helpful for ensuring security, especially when you have multiple
    microservices running on a cluster. Now, imagine you have a cluster that hosts
    many applications for your company. It hosts a marketing website that runs an
    open-source library, a database server with sensitive data, and an application
    server that controls access to that data. If the marketing website doesn''t need
    to access the database, then there should be no reason for it to be allowed access
    to the database. By using a NetworkPolicy, we can prevent an exploit or a bug
    in the marketing website from allowing an attacker to expand that attack so that
    they can access your business data by preventing the marketing website Pod from
    even being able to talk to the database. Let''s take a look at a sample NetworkPolicy
    document and decipher it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于确保安全非常有帮助，特别是当您在集群上运行多个微服务时。现在，想象一下您有一个为您的公司托管许多应用程序的集群。它托管了一个运行开源库的营销网站，一个包含敏感数据的数据库服务器，以及一个控制对该数据访问的应用服务器。如果营销网站不需要访问数据库，那么它就不应该被允许访问数据库。通过使用NetworkPolicy，我们可以防止营销网站中的漏洞或错误允许攻击者扩大攻击，以便他们可以通过阻止营销网站Pod甚至无法与数据库通信来访问您的业务数据。让我们来看一个示例NetworkPolicy文档并解释它：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s examine some of the fields of this NetworkPolicy:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个NetworkPolicy的一些字段：
- en: It contains the standard `apiVersion`, `kind`, and `metadata` fields that we
    described earlier in this chapter.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含了我们在本章前面描述的标准`apiVersion`，`kind`和`metadata`字段。
- en: '`podSelector`: The labels it should look for in the namespace to apply the
    policy.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podSelector`：它应该在命名空间中查找的标签，以应用策略。'
- en: '`policyTypes`: Can be either ingress, egress, or both. This means that the
    network policy applies to either traffic coming into the Pods being selected,
    leaving the Pods being selected, or both.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`policyTypes`：可以是入口、出口或两者。这意味着网络策略适用于被选择的Pod中进入的流量、离开被选择的Pod的流量，或两者。'
- en: '`Ingress`: This takes a `from` block that defines where traffic can originate
    from in the policy. This can be a namespace, a Pod selector, or an IP address
    block and port combination.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ingress`：这需要一个`from`块，定义了策略中流量可以从哪里发起。这可以是一个命名空间、一个Pod选择器或一个IP地址块和端口组合。'
- en: '`Egress`: This takes a `to` block and defines where traffic is allowed to go
    to in the network policy. This can be a namespace, a Pod selector, or an IP address
    block and port combination.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Egress`：这需要一个`to`块，并定义了网络策略中允许流量去哪里。这可以是一个命名空间、一个Pod选择器或一个IP地址块和端口组合。'
- en: Your CNI may not have a mature implementation of NetworkPolicies, so be sure
    to consult your cloud provider's documentation for more information. In the case
    of the cluster we set up using EKS, it is using the Amazon CNI. We can use **Calico**,
    an open-source project, to augment the existing EKS CNI and make up for deficiencies
    with respect to enforcing NetworkPolicy declarations. It is worth mentioning that
    Calico can be used as a CNI as well, but we will only be using the supplementary
    functionality for NetworkPolicy enforcement in the following exercise.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您的CNI可能没有成熟的NetworkPolicies实现，因此请务必查阅您的云提供商的文档以获取更多信息。在我们使用EKS设置的集群中，它使用的是Amazon
    CNI。我们可以使用**Calico**，一个开源项目，来增强现有的EKS CNI，并弥补在执行NetworkPolicy声明方面的不足。值得一提的是，Calico也可以作为CNI使用，但我们将只在以下练习中使用其补充功能来执行NetworkPolicy。
- en: 'Exercise 13.02: Creating a NetworkPolicy'
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.02：创建NetworkPolicy
- en: 'In this exercise, we will implement Calico to augment the out-of-the-box enforcement
    of NetworkPolicy declarations available with Amazon CNI in EKS. Let''s get started:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现Calico来增强Amazon CNI在EKS中可用的NetworkPolicy声明的即插即用执行。让我们开始吧：
- en: 'Run the following command to install the Amazon CNI with Calico:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令安装带有Calico的Amazon CNI：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should see a response similar to the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似于以下的响应：
- en: '![Figure 13.8: Installing Amazon CNI with Calico'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.8：安装带有Calico的Amazon CNI'
- en: '](image/B14870_13_08.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_13_08.jpg)'
- en: 'Figure 13.8: Installing Amazon CNI with Calico'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8：安装带有Calico的Amazon CNI
- en: 'To verify that you have deployed the DaemonSet corresponding to Calico successfully,
    use the following command:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证您是否成功部署了与Calico对应的DaemonSet，请使用以下命令：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should see the `calico-node` DaemonSet, as shown here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到`calico-node` DaemonSet，如下所示：
- en: '![Figure 13.9: Checking the calico-node DaemonSet'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.9：检查calico-node DaemonSet'
- en: '](image/B14870_13_09.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_13_09.jpg)'
- en: 'Figure 13.9: Checking the calico-node DaemonSet'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9：检查calico-node DaemonSet
- en: 'Now, let''s create our NetworkPolicy object. First, create a file named `net_pol_all_deny.yaml`
    with the following content:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的NetworkPolicy对象。首先，创建一个名为`net_pol_all_deny.yaml`的文件，内容如下：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This policy is a very simple NetworkPolicy. It says that no traffic to and from
    Pods is allowed in or out of the cluster. This is the secure base on which we're
    going to continue expanding our application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个策略是一个非常简单的NetworkPolicy。它表示不允许流入或流出集群的Pod之间的流量。这是我们将继续扩展我们应用程序的安全基础。
- en: 'Let''s apply our policy using the following command:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下命令应用我们的策略：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see the following response:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, there is no traffic flowing through our cluster. We can prove this by deploying
    our application since it needs the network to communicate with itself.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的集群中没有流量流动。我们可以通过部署我们的应用程序来证明这一点，因为它需要网络来与自身通信。
- en: 'As a test application, we will use the same application we used in *Exercise
    12.04*, *Deploying an Application Version Update*. If you already have the YAML
    file for that, you can use it. Otherwise, run the following command to get the
    file in your working directory:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为一个测试应用程序，我们将使用与*Exercise 12.04*，*部署应用程序版本更新*中使用的相同应用程序。如果您已经有该YAML文件，可以使用它。否则，运行以下命令以在您的工作目录中获取该文件：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, use the following command to deploy the application:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令部署应用程序：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should see the following response:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '![Figure 13.10: Deploying our application'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.10：部署我们的应用程序'
- en: '](image/B14870_13_10.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_13_10.jpg)'
- en: 'Figure 13.10: Deploying our application'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10：部署我们的应用程序
- en: 'Now, let''s check the status of our deployment using the following command:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令检查我们部署的状态：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should see the following response:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '![Figure 13.11: Checking the status of our application'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.11：检查我们应用程序的状态'
- en: '](image/B14870_13_11.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_13_11.jpg)'
- en: 'Figure 13.11: Checking the status of our application'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11：检查我们应用程序的状态
- en: This is a truncated screenshot. As you can see, we have an issue that we are
    unable to communicate with Redis. Fixing this will be a part of *Activity 13.01*,
    *Going Beyond Primitives*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个截断的截图。正如你所看到的，我们有一个问题，即无法与Redis通信。修复这个问题将是*Activity 13.01*，*超越基本操作*的一部分。
- en: 'We are going to test network access now, so in a separate Terminal window,
    let''s start our proxy:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将测试网络访问，因此在一个单独的终端窗口中，让我们启动我们的代理：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should see this response:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到这个响应：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Another way to verify that the NetworkPolicy is preventing traffic is to use
    our `curl` command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 验证NetworkPolicy是否阻止流量的另一种方法是使用我们的`curl`命令：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You should see a response similar to this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似于这样的响应：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As we can see, we are able to prevent unauthorized communication between Pods
    in our Kubernetes cluster. By leveraging NetworkPolicies, we can prevent attackers
    from doing further damage if they are able to compromise some of the components
    of our cluster, containers, or source code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们能够防止Kubernetes集群中Pod之间的未经授权通信。通过利用NetworkPolicies，我们可以防止攻击者在能够 compromise
    集群、容器或源代码的一些组件后造成进一步的破坏。
- en: PodSecurityPolicy
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PodSecurityPolicy
- en: So far, we have learned about and tested Kubernetes RBAC to prevent unauthorized
    API server access, and also applied a NetworkPolicy to prevent unnecessary network
    communication. The next most important area of security outside the network is
    the application runtime. Attackers need access to the network to get in and out,
    but they also need a vulnerable runtime to do anything more serious. This is where
    Kubernetes PodSecurityPolicy objects help prevent that from happening.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习并测试了Kubernetes RBAC以防止未经授权的API服务器访问，并且还应用了NetworkPolicy以防止不必要的网络通信。网络之外安全性的下一个最重要领域是应用程序运行时。攻击者需要访问网络来进出，但他们还需要一个容易受攻击的运行时来做更严重的事情。这就是Kubernetes
    PodSecurityPolicy对象帮助防止这种情况发生的地方。
- en: PodSecurityPolicy objects overlap with a specific type of AdmissionController
    and allow a cluster operator to dynamically define the minimum runtime requirements
    of a Pod that's been admitted for scheduling on the cluster.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: PodSecurityPolicy对象与特定类型的AdmissionController重叠，并允许集群操作员动态定义已被允许在集群上调度的Pod的最低运行时要求。
- en: To understand exactly how PodSecurityPolicies can be useful, let's consider
    the following scenario. You are a Kubernetes cluster admin at a large financial
    institution. Your company uses ticket-based change management software in an ITIL-compliant
    fashion (ITIL is a standardized change management framework for IT services) to
    ensure that changes that are made to the environment are stable. This prevents
    developers from doing anything disastrous in production. To keep up with the change
    of pace in the market that your customers are demanding, you need a programmatic
    way to enable developers to do more change management autonomously. But you also
    need to do so in a way that is secure and compliant with certain standards. PodSecurityPolicies
    help us do this because they allow administrators to create policy definitions
    in software that are enforced when a Pod is being admitted to a cluster. This
    means that developers can move more rapidly, and cluster admins can still certify
    that their environment is fully compliant with the set standards.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确切了解PodSecurityPolicies如何有用，让我们考虑以下情景。您是一家大型金融机构的Kubernetes集群管理员。您的公司以符合ITIL的方式（ITIL是IT服务的标准变更管理框架）使用基于票据的变更管理软件，以确保对环境所做的更改是稳定的。这可以防止开发人员在生产环境中做出灾难性的事情。为了跟上客户要求的市场变化速度，您需要一种程序化的方式来使开发人员能够更自主地进行更改管理。但您还需要以安全和符合某些标准的方式来做到这一点。PodSecurityPolicies帮助我们做到这一点，因为它们允许管理员在软件中创建策略定义，并在Pod被允许进入集群时执行。这意味着开发人员可以更快地移动，而集群管理员仍然可以证明他们的环境完全符合设定的标准。
- en: Further extending this scenario, you might want to prevent users from running
    their container as the root user so that attackers can't exploit any vulnerabilities
    in Docker. By applying a PodSecurityPolicy, you can prevent your users from accidentally
    deploying unsecured containers.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步扩展这种情况，您可能希望阻止用户将其容器以root用户身份运行，以防攻击者利用Docker中的任何漏洞。通过应用PodSecurityPolicy，您可以防止用户意外部署不安全的容器。
- en: 'Now that we have seen how they can be useful, let''s consider a sample PodSecurityPolicy
    and examine it:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到它们如何有用，让我们考虑一个示例PodSecurityPolicy并对其进行检查：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s examine a few noteworthy fields here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里检查一些值得注意的字段：
- en: '`metadata.namespace`: This is going to create the PodSecurityPolicy in the
    `default` namespace and will apply to Pods in the same namespace.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata.namespace`: 这将在`default`命名空间中创建PodSecurityPolicy，并将应用于同一命名空间中的Pod。'
- en: '`privileged`: This controls whether containers are allowed to run in a privileged
    execution context on the node, which effectively grants the container root-level
    access to the host. You can find more information about privileged containers
    here: [https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities).'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`privileged`: 这控制容器是否允许在节点上以特权执行上下文中运行，这实际上授予容器对主机的根级访问权限。您可以在这里找到有关特权容器的更多信息：[https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities](https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities)。'
- en: '`seLinux`: This defines any SELinux settings. Some Kubernetes clusters run
    in SELinux environments, which implement something called "mandatory access control"
    outside of the cluster. This allows those controls to be projected into the cluster.
    By stating `RunAsAny`, we are allowing any SELinux user.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seLinux`: 这定义了任何SELinux设置。一些Kubernetes集群在SELinux环境中运行，这些环境在集群外实现了称为“强制访问控制”的东西。这允许将这些控制投影到集群中。通过声明`RunAsAny`，我们允许任何SELinux用户。'
- en: '`supplementalGroups`: This is a mandatory field of the policy. It essentially
    tells us that we are allowing any Linux user group ID (GID). In this sample spec,
    we are saying that users from any Linux user group with IDs 1 to 2500 are allowed.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`supplementalGroups`: 这是策略的一个强制字段。它基本上告诉我们，我们允许任何Linux用户组ID（GID）。在此示例规范中，我们说允许来自ID为1到2500的任何Linux用户组的用户。'
- en: '`runAsUser`: This allows us to specify specific Linux users who are permitted
    to run any process in the Pod. By stating `MustRunAsNonRoot`, we are saying that
    any process in the Pod must not run with root privileges.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runAsUser`: 这允许我们指定可以在Pod中运行任何进程的特定Linux用户。通过声明`MustRunAsNonRoot`，我们说Pod中的任何进程都不能以root权限运行。'
- en: '`fsGroup`: This is the Linux group ID the container process must be running
    as to interact with certain volumes on the cluster. Thus, even if a volume exists
    on a Pod, we can restrict certain processes in that Pod from accessing it. In
    this sample spec, we are saying that only Linux users in the `devops` group with
    a GID of 655 can access the volume. This is applied regardless of the location
    of the Pod in the cluster or where the volume is.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fsGroup`: 这是容器进程必须以其运行的Linux组ID，以便与集群上的某些卷进行交互。因此，即使Pod上存在卷，我们也可以限制该Pod中的某些进程访问它。在此示例规范中，我们说只有具有GID为655的`devops`组中的Linux用户可以访问该卷。这将适用于Pod在集群中的位置或卷的位置。'
- en: '`volumes`: This allows us to permit the different types of volume that can
    be mounted to that Pod, such as a `configmap` or a `persistentVolumeClaim`. In
    this sample spec, we have specified `*` (an asterisk), which implies that all
    kinds of volumes are allowed to be used by the processes in this Pod.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`卷`: 这使我们能够允许可以挂载到该Pod的不同类型的卷，例如`configmap`或`persistentVolumeClaim`。在此示例规范中，我们已经指定了`*`（星号），这意味着所有类型的卷都可以被该Pod中的进程使用。'
- en: Now that we have understood what the different fields in the spec mean, we'll
    create a PodSecurityPolicy in the following exercise.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了规范中不同字段的含义，我们将在以下练习中创建一个PodSecurityPolicy。
- en: 'Exercise 13.03: Creating and Testing a PodSecurityPolicy'
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.03：创建和测试PodSecurityPolicy
- en: 'In this exercise, we''re going to be creating a PodSecurityPolicy and applying
    it to our cluster to demonstrate the types of functionalities Pods must now comply
    with in our cluster after we apply it. Let''s get started:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个PodSecurityPolicy并将其应用到我们的集群，以演示我们应用后集群中Pod必须遵守的功能类型。让我们开始吧：
- en: 'Create a file named `pod_security_policy_example.yaml` with the following content:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pod_security_policy_example.yaml`的文件，内容如下：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To apply this to the cluster, run the following command:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将此应用到集群中，请运行以下命令：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should see the following response:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To check that our policy is enforced, let's try to create a Pod that doesn't
    comply with this policy. Now we have a policy called `MustRunAsNonRoot`, so we
    should try to run a container as root and see what happens.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查我们的策略是否得到执行，让我们尝试创建一个不符合这个策略的Pod。现在我们有一个名为`MustRunAsNonRoot`的策略，所以我们应该尝试以root身份运行一个容器，看看会发生什么。
- en: 'To create a Docker container that would violate this PodSecurityPolicy, first,
    create a file named `Dockerfile` with the following content:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个违反这个PodSecurityPolicy的Docker容器，首先创建一个名为`Dockerfile`的文件，内容如下：
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The second line of this `Dockerfile` switches to the root user (indicated by
    the UID of `0`), and then the `echo` command should tell us what user is running
    in this container when it starts.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Dockerfile`的第二行切换到root用户（由UID `0`表示），然后`echo`命令应该告诉我们在容器启动时运行的用户是谁。
- en: 'Build the Docker image by running the following command:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令构建Docker镜像：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should see the following response:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '![Figure 13.12: Building our Docker image'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.12：构建我们的Docker镜像'
- en: '](image/B14870_13_12.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_13_12.jpg)'
- en: 'Figure 13.12: Building our Docker image'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12：构建我们的Docker镜像
- en: 'Let''s run our Docker container:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行我们的Docker容器：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should see the following response:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As we can see, this container is going to run as root.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个容器将以root身份运行。
- en: 'Now, we need to create a Pod from this container. Create a file named `pod.yaml`
    with the following content:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要从这个容器创建一个Pod。创建一个名为`pod.yaml`的文件，内容如下：
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can push your own image to your Docker Hub repository and replace this link,
    or you can use the container that we have already provided for convenience. As
    a general rule of thumb, you should always be careful when downloading something
    that is supposed to run with root access.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将自己的镜像推送到Docker Hub存储库并替换此链接，或者您可以使用我们已经提供的容器以方便使用。作为一个一般的经验法则，当下载某些应该以root访问权限运行的东西时，您应该始终小心。
- en: 'By default, a PodSecurityPolicy does nothing until the `use` permission is
    installed on a user, group, or ServiceAccount that will be creating the Pod. To
    mimic this, we will quickly create a ServiceAccount:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，PodSecurityPolicy在用户、组或ServiceAccount上安装了`use`权限之前不会执行任何操作，这些用户、组或ServiceAccount将创建Pod。为了模仿这一点，我们将快速创建一个ServiceAccount：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You should see the following response:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let''s create a Role that will be subject to this PodSecurityPolicy:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个将受到这个PodSecurityPolicy约束的角色：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note that this is another quick way to create a Role. Here, `psp:unprivileged`
    corresponds to the name of the role, while the flags correspond to the fields
    that we studied earlier. We are using the `--resource-name` flag to apply the
    Role to our specific PodSecurityPolicy. You should get the following response:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是创建角色的另一种快速方法。在这里，`psp:unprivileged`对应于角色的名称，而标志对应于我们之前学习的字段。我们使用`--resource-name`标志将角色应用到我们特定的PodSecurityPolicy。您应该会得到以下响应：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s bind this role to our ServiceAccount using a RoleBinding:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用RoleBinding将这个角色绑定到我们的ServiceAccount：
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, we are using a command similar to the one we used in the previous step.
    You should see the following response:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了类似于上一步中使用的命令。您应该会看到以下响应：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s masquerade as this user and try to create this Pod:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们假扮成这个用户，尝试创建这个Pod：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You should see the following response:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '![Figure 13.13: Trying to create a Pod while assuming the fake-user ServiceAccount'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.13：尝试在假用户ServiceAccount的假设下创建一个Pod'
- en: '](image/B14870_13_13.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_13_13.jpg)'
- en: 'Figure 13.13: Trying to create a Pod while assuming the fake-user ServiceAccount'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13：尝试在假用户ServiceAccount的假设下创建Pod
- en: At the beginning of this chapter, we explored the 4Cs of cluster security, and
    then throughout this chapter, we have seen different ways in which Kubernetes
    allows us to harden our cluster against various areas of attack. We learned that
    RBAC policies allow us to control access to our API and objects, NetworkPolicy
    allows us to harden the networking topology, and PodSecurityPolicy helps us protect
    against compromised runtimes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们探讨了集群安全的4C，然后在本章的整个过程中，我们看到了Kubernetes允许我们以不同的方式加固集群以抵御各种攻击的方法。我们了解到RBAC策略允许我们控制对API和对象的访问，NetworkPolicy允许我们加固网络拓扑，而PodSecurityPolicy则帮助我们防止受损的运行时。
- en: Now, let's bring these concepts together in the following activity.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在以下活动中将这些概念结合起来。
- en: 'Activity 13.01: Securing Our App'
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动13.01：保护我们的应用程序
- en: 'As it stands, our application from the previous chapter is already quite secure
    for the use case. What we need to do, though, is prevent users from deploying
    Pods that are privileged (so that they can''t escalate their permissions) and
    make sure that our app can communicate with both the outside world and its datastore.
    A correct solution to this application would be to have the following functionality:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，我们在上一章中的应用程序已经相当安全了。但是，我们需要做的是防止用户部署特权Pod，并确保我们的应用程序可以与外部世界和其数据存储通信。对于这个应用程序的正确解决方案应该具有以下功能：
- en: The application should work seamlessly, as we demonstrated in the previous chapter,
    but now, it should prevent any unnecessary network traffic. Unnecessary here refers
    to the fact that the only Pod communicating with the Redis server should be the
    app, and that the app should only be communicating with other IP ranges.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该无缝工作，就像我们在上一章中演示的那样，但现在，它应该阻止任何不必要的网络流量。这里的不必要是指只有与Redis服务器通信的Pod应用程序，而且该应用程序只能与其他IP范围通信。
- en: 'In *Exercise 13.02*, *Creating a NetworkPolicy*, we saw that our application
    did not work due to the highly restrictive NetworkPolicy. However, in this case,
    you should see the application running with an output similar to the following:![Figure
    13.14: Expected output for Activity 13.01'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*Exercise 13.02*，*Creating a NetworkPolicy*中，我们看到由于高度限制性的NetworkPolicy，我们的应用程序无法工作。然而，在这种情况下，您应该看到应用程序运行并输出类似于以下内容的内容：![图13.14：活动13.01的预期输出
- en: '](image/B14870_13_14.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_13_14.jpg)'
- en: 'Figure 13.14: Expected output for Activity 13.01'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14：活动13.01的预期输出
- en: 'Here are some steps that can help you complete this activity:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可以帮助您完成此活动的步骤：
- en: Ensure that you have a cluster infrastructure and all the objects from *Exercise
    13.01, Creating a Kubernetes RBAC ClusterRole*.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您拥有集群基础架构和*Exercise 13.01, Creating a Kubernetes RBAC ClusterRole*中的所有对象。
- en: Create a file named `pod_security_policy.yaml` ( and then apply it). Keep in
    mind the functionality as described in the first bullet point above when creating
    this file. You might want to re-visit the section *PodSecurityPolicy* where we
    describe each of the fields used in such a file in detail.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`pod_security_policy.yaml`的文件（然后应用它）。在创建此文件时，请记住上面第一个要点中描述的功能。您可能需要重新访问*PodSecurityPolicy*部分，在那里我们详细描述了此类文件中使用的每个字段。
- en: Create a file named `network_policy.yaml`. Keep in mind the requirement as listed
    in the second bullet point above when creating this file. You might want to re-visit
    the section *NetworkPolicies* where we describe each of the fields used in such
    a file in detail. Make sure to apply this policy once you have created it.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`network_policy.yaml`的文件。在创建此文件时，请记住上面第二个要求中列出的内容。您可能需要重新访问*NetworkPolicies*部分，我们在其中详细描述了此类文件中使用的每个字段。确保在创建后应用此策略。
- en: If you have the application from *Exercise 14.02, Creating a NetworkPolicy*
    still deployed in your cluster, you can move on to the next step. Otherwise, rerun
    *steps 5* and *6* from that exercise.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的集群中仍在部署*Exercise 14.02, Creating a NetworkPolicy*中的应用程序，则可以继续下一步。否则，请重新运行该练习中的*步骤5*和*6*。
- en: Now, test the application.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，测试该应用程序。
- en: Note
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下地址找到：[https://packt.live/304PEoD](https://packt.live/304PEoD)。
- en: Also, consider deleting the NetworkPolicy and PodSecurityPolicy after you are
    done with this chapter to avoid any interference with later chapters.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，考虑在完成本章后删除NetworkPolicy和PodSecurityPolicy，以避免对后续章节造成干扰。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In our journey of building a production-ready Kubernetes environment, security
    is a critical aspect. With that in mind, in this chapter, we examined how threat
    modeling allows us to think in an adversarial way about our application infrastructure
    and how it informs us of how we can defend it from attack. Then, we looked at
    the 4Cs of Cloud Native Security to understand where our attack surfaces are,
    followed by how Kubernetes can help us run workloads securely in the cluster.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建生产就绪的Kubernetes环境的过程中，安全性是一个关键方面。考虑到这一点，在本章中，我们研究了威胁建模如何让我们以对抗性的方式思考我们的应用基础架构，以及它如何告诉我们如何防御攻击。然后，我们看了一下云原生安全的4C，以了解我们的攻击面在哪里，然后看了一下Kubernetes如何帮助我们在集群中安全地运行工作负载。
- en: 'Kubernetes has several security features that we can leverage to secure our
    cluster. We learned about three security measures that are important to leverage:
    RBAC, NetworkPolicies, and PodSecurityPolicies. We also learned about their various
    applications when it comes to securing access to your cluster, securing your container
    network, and securing your container runtimes.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes具有几个安全功能，我们可以利用这些功能来保护我们的集群。我们了解了三个重要的安全措施：RBAC、NetworkPolicies和PodSecurityPolicies。我们还了解了它们在保护对集群的访问、保护容器网络和保护容器运行时方面的各种应用。
- en: In the next chapter, we're going to examine how to manage storage objects in
    Kubernetes and deal with apps that are stateful.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在Kubernetes中管理存储对象，并处理具有状态的应用程序。
