- en: 1\. Introduction to Kubernetes and Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. Kubernetes和容器简介
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: The chapter begins by describing the evolution of software development and delivery,
    beginning with running software on bare-metal machines, through to the modern
    approach of containerization. We will also take a look at the underlying Linux
    technologies that enable containerization. By the end of the chapter, you will
    be able to run a basic Docker container from an image. You will also be able to
    package a custom application to make your own Docker image. Next, we will take
    a look at how we can control the resource limits and group for a container. Finally,
    the end of the chapter describes why we need to have a tool such as Kubernetes,
    along with a short introduction to its strengths.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先描述了软件开发和交付的演变，从在裸机上运行软件，到现代容器化方法。我们还将看一下支持容器化的底层Linux技术。在本章结束时，您将能够从镜像中运行基本的Docker容器。您还将能够打包自定义应用程序以制作自己的Docker镜像。接下来，我们将看一下如何控制容器的资源限制和分组。最后，本章结束时描述了为什么我们需要像Kubernetes这样的工具，以及对其优势的简短介绍。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: About a decade ago, there was a lot of discussion over software development
    paradigms such as service-oriented architecture, agile development, and software
    design patterns. In hindsight, those were all great ideas, but only a few of them
    were practically adopted a decade ago.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大约十年前，关于服务导向架构、敏捷开发和软件设计模式等软件开发范式进行了大量讨论。回顾来看，这些都是很好的想法，但只有少数被实际采纳了十年前。
- en: One of the major reasons for the lack of adoption of these paradigms is that
    the underlying infrastructure couldn't offer the resources or capabilities for
    abstracting fine-grained software components and managing an optimal software
    development life cycle. Hence, a lot of duplicated efforts were still required
    for resolving some common issues of software development such as managing software
    dependencies and consistent environments, software testing, packaging, upgrading,
    and scaling.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些范式缺乏采纳的一个主要原因是底层基础设施无法提供资源或能力来抽象细粒度的软件组件，并管理最佳的软件开发生命周期。因此，仍然需要大量重复的工作来解决软件开发的一些常见问题，如管理软件依赖关系和一致的环境、软件测试、打包、升级和扩展。
- en: In recent years, with Docker at the forefront, containerization technology has
    provided a new encapsulation mechanism that allows you to bundle your application,
    its runtime, and its dependencies, and also brings in a new angle to view the
    development of software. By using containerization technology, the underlying
    infrastructure gets abstracted away so that applications can be seamlessly moved
    among heterogeneous environments. However, along with the rising volume of containers,
    you may need orchestration tools to help you to manage their interactions with
    each other as well as to optimize the utilization of the underlying hardware.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，以Docker为首的容器技术提供了一种新的封装机制，允许您捆绑应用程序、其运行时和其依赖项，并为软件开发带来了新的视角。通过使用容器技术，底层基础设施被抽象化，以便应用程序可以在异构环境中无缝移动。然而，随着容器数量的增加，您可能需要编排工具来帮助您管理它们之间的交互，以及优化底层硬件的利用率。
- en: That's where Kubernetes comes into play. Kubernetes provides a variety of options
    to automate deployment, scaling, and the management of containerized applications.
    It has seen explosive adoption in recent years and has become the de-facto standard
    in the container orchestration field.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Kubernetes发挥作用的地方。Kubernetes提供了各种选项来自动化部署、扩展和管理容器化应用程序。它近年来得到了爆炸式的采用，并已成为容器编排领域的事实标准。
- en: As this is the first chapter of this book, we will start with a brief history
    of software development over the past few decades, and then illustrate the origins
    of containers and Kubernetes. We will focus on explaining what problems they can
    solve, and **three key reasons** why their adoption has seen a considerable rise
    in recent years.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本书的第一章，我们将从过去几十年软件开发的简要历史开始，然后阐述容器和Kubernetes的起源。我们将重点解释它们可以解决什么问题，以及它们为什么在最近几年的采用率大幅上升的**三个关键原因**。
- en: The Evolution of Software Development
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件开发的演变
- en: Along with the evolution of virtualization technology, it's common for companies
    to use **virtual machines** (**VMs**) to manage their software products, either
    in the public cloud or an on-premises environment. This brings huge benefits such
    as automatic machine provisioning, better hardware resource utilization, resource
    abstraction, and more. More critically, for the first time, it employs the separation
    of computing, network, and storage resources to unleash the power of software
    development from the tediousness of hardware management. Virtualization also brings
    in the ability to manipulate the underlying infrastructure programmatically. So,
    from a system administrator and developer's perspective, they can better streamline
    the workflow of software maintenance and development. This is a big move in the
    history of software development.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随着虚拟化技术的发展，公司通常使用**虚拟机**（**VMs**）来管理其软件产品，无论是在公共云还是本地环境中。这带来了诸如自动机器配置、更好的硬件资源利用、资源抽象等巨大好处。更为重要的是，它首次采用了计算、网络和存储资源的分离，使软件开发摆脱了硬件管理的繁琐。虚拟化还带来了以编程方式操纵底层基础设施的能力。因此，从系统管理员和开发人员的角度来看，他们可以更好地优化软件维护和开发的工作流程。这是软件开发历史上的一大进步。
- en: However, in the past decade, the scope and life cycle of software development
    have changed vastly. Earlier, it was not uncommon for software to be developed
    in big monolithic chunks with a slow-release cycle. Nowadays, to catch up with
    the rapid changes of business requirements, a piece of software may need to be
    broken down into individual fine-grained subcomponents, and each component may
    need to have its release cycle so that it can be released as often as possible
    to get feedback from the market earlier. Moreover, we may want each component
    to be scalable and cost-effective.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在过去的十年中，软件开发的范围和生命周期发生了巨大变化。以前，将软件开发成大型的单块是很常见的，发布周期很慢。如今，为了跟上业务需求的快速变化，一款软件可能需要被拆分成个别的细粒度子组件，并且每个组件可能需要有自己的发布周期，以便尽可能频繁地发布，以便更早地从市场获得反馈。此外，我们可能希望每个组件都具有可伸缩性和成本效益。
- en: So, how does this impact application development and deployment? In comparison
    to the bare-metal era, adopting VMs doesn't help much since VMs don't change the
    granularity of how different components are managed; the entire software is still
    deployed on a single machine, only it is a virtual one instead of a physical one.
    Making a number of interdependent components work together is still not an easy
    task.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这对应用程序开发和部署有什么影响呢？与裸机时代相比，采用虚拟机并没有太大帮助，因为虚拟机并没有改变不同组件管理的粒度；整个软件仍然部署在一台机器上，只不过是虚拟机而不是物理机。使一些相互依赖的组件共同工作仍然不是一件容易的事情。
- en: A straightforward idea here is to add an abstraction layer to connect the machines
    with the applications running on them. This is so that application developers
    would only need to focus on the business logic to build the applications. Some
    examples of this are **Google App Engine** (**GAE**) and Cloud Foundry.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个直接的想法是添加一个抽象层，将机器与运行在其上的应用程序连接起来。这样应用程序开发人员只需要专注于业务逻辑来构建应用程序。一些例子包括Google
    App Engine（GAE）和Cloud Foundry。
- en: The **first issue** with these solutions is the lack of consistent development
    experience among different environments. Developers develop and test applications
    on their machines with their local dependencies (both at the programming language
    and operating system level); while in a production environment, the application
    has to rely on another set of dependencies underneath. And we still haven't talked
    about the software components that need the cooperation of different developers
    in different teams.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案的第一个问题是不同环境之间缺乏一致的开发体验。开发人员在他们的机器上开发和测试应用程序，使用他们本地的依赖关系（无论是在编程语言还是操作系统级别）；而在生产环境中，应用程序必须依赖另一组底层依赖关系。而且我们还没有谈到需要不同团队中不同开发人员合作的软件组件。
- en: The **second issue** is that the hard boundary between applications and the
    underlying infrastructure would limit the applications from being highly performant,
    especially if the application is sensitive to the storage, compute, or network
    resources. For instance, you may want the application to be deployed across multiple
    availability zones (isolated geographic locations within data centers where cloud
    resources are managed), or you may want some applications to coexist, or not to
    coexist, with other particular applications. Alternatively, you may want some
    applications to adhere to particular hardware (for example, solid-state drives).
    In such cases, it becomes hard to focus on the functionality of the app without
    exposing the topological characteristics of the infrastructure to upper applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是应用程序和底层基础设施之间的硬性边界会限制应用程序的高性能，特别是如果应用程序对存储、计算或网络资源敏感。例如，您可能希望应用程序部署在多个可用区（数据中心内的隔离地理位置，云资源在其中管理），或者您可能希望一些应用程序共存，或者不与其他特定应用程序共存。或者，您可能希望一些应用程序遵循特定的硬件（例如固态驱动器）。在这种情况下，很难专注于应用程序的功能，而不向上层应用程序暴露基础设施的拓扑特征。
- en: In fact, in the life cycle of software development, there is no clear boundary
    between the infrastructure and applications. What we want to achieve is to manage
    the applications automatically, while making optimal use of the infrastructure.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在软件开发的生命周期中，基础设施和应用程序之间没有明确的界限。我们想要实现的是自动管理应用程序，同时最大限度地利用基础设施。
- en: So, how could we achieve this? Docker (which we will introduce later in this
    chapter) solves the **first issue** by leveraging Linux containerization technologies
    to encapsulate the application and its dependencies. It also introduces the concept
    of Docker images to make the software aspect of the application runtime environment
    lightweight, reproducible, and portable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何实现这一点呢？Docker（我们将在本章后面介绍）通过利用Linux容器化技术来解决第一个问题，封装应用程序及其依赖关系。它还引入了Docker镜像的概念，使应用程序运行时环境的软件方面变得轻量、可重现和可移植。
- en: The **second issue** is more complicated. That's where Kubernetes comes in.
    Kubernetes leverages a battle-tested design rationale called the Declarative API
    to abstract the infrastructure as well as each phase of application delivery such
    as deployment, upgrades, redundancy, scaling, and more. It also offers a series
    of building blocks for users to choose, orchestrate, and compose into the eventual
    application. We will gradually move on to study Kubernetes, which is the core
    of this book, toward the end of this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二个问题**更加复杂。这就是Kubernetes发挥作用的地方。Kubernetes利用一种经过考验的设计理念，称为声明式API，来抽象基础设施以及应用交付的每个阶段，如部署、升级、冗余、扩展等。它还为用户提供了一系列构建模块，供用户选择、编排并组合成最终的应用程序。我们将逐渐开始学习Kubernetes，这是本书的核心内容，在本章末尾。'
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If not specified particularly, the term "container" might be used interchangeably
    with "Linux container" throughout this book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有特别指定，本书中可能会将术语“容器”与“Linux容器”互换使用。
- en: Virtual Machines versus Containers
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟机与容器
- en: 'A **virtual machine** (**VM**), as the name implies, aims to emulate a physical
    computer system. Technically, VMs are provisioned by a hypervisor, and the hypervisor
    runs on the host OS. The following diagram illustrates this concept:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟机**（**VM**），顾名思义，旨在模拟物理计算机系统。从技术上讲，虚拟机是由虚拟化监控程序提供的，并且虚拟化监控程序运行在主机操作系统上。下图说明了这个概念：'
- en: '![Figure 1.1: Running applications on VMs'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1：在虚拟机上运行应用程序'
- en: '](image/B14870_01_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_01.jpg)'
- en: 'Figure 1.1: Running applications on VMs'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：在虚拟机上运行应用程序
- en: Here, the VMs have full OS stacks, and the OS running on the VM (called the
    `Guest OS`) must rely on the underlying hypervisor to function. The applications
    and operating system reside and run inside the VM. Their operations go through
    the guest OS's kernel and are then translated to the system calls by the hypervisor,
    which are eventually executed on the host OS.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，虚拟机具有完整的操作系统堆栈，虚拟机上运行的操作系统（称为“客户操作系统”）必须依赖底层的虚拟化监控程序才能运行。应用程序和操作系统驻留并在虚拟机内运行。它们的操作经过客户操作系统的内核，然后由虚拟化监控程序翻译成系统调用，最终在主机操作系统上执行。
- en: 'Containers, on the other hand, don''t need a hypervisor underneath. By leveraging
    some Linux containerization technologies such as namespaces and cgroups (which
    we will revisit later), each container runs independently on the host OS. The
    following diagram illustrates containerization, taking Docker containers as an
    example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，容器不需要底层的虚拟化监控程序。通过利用一些Linux容器化技术，如命名空间和cgroups（我们稍后会重新讨论），每个容器都可以独立地在主机操作系统上运行。下图说明了容器化，以Docker容器为例：
- en: '![Figure 1.2: Running applications in containers'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2：在容器中运行应用程序'
- en: '](image/B14870_01_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_02.jpg)'
- en: 'Figure 1.2: Running applications in containers'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：在容器中运行应用程序
- en: It's worth mentioning that we put Docker beside the containers instead of between
    the containers and the host OS. That's because, technically, it's not necessary
    to have Docker Engine hosting those containers. Docker Engine plays more of a
    manager role to manage the life cycle of the containers. It is also inappropriate
    to liken Docker Engine to the hypervisor because once a container is up and running,
    we don't need an extra layer to "translate" the application operations to be understandable
    by the host OS. From *Figure 1.2*, you can also tell that applications inside
    the containers are essentially running directly on the host OS.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，我们将Docker放在容器旁边，而不是在容器和主机操作系统之间。这是因为从技术上讲，没有必要让Docker引擎托管这些容器。Docker引擎更多地扮演着一个管理者的角色，来管理容器的生命周期。将Docker引擎比作虚拟化监控程序也是不恰当的，因为一旦容器启动运行，我们就不需要额外的层来“翻译”应用程序操作，使其能够被主机操作系统理解。从*图1.2*中，你也可以看出容器内的应用程序实质上是直接在主机操作系统上运行的。
- en: 'When we spin up a container, we don''t need to bring up an entire OS; instead,
    it leverages the features of the Linux kernel on the host OS. Therefore, containers
    start up faster, function with less overhead, and require much less space compared
    to VMs. The following is a table comparing VMs with containers:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动一个容器时，我们不需要启动整个操作系统；相反，它利用了主机操作系统上Linux内核的特性。因此，与虚拟机相比，容器启动更快，功能开销更小，占用的空间也要少得多。以下是一个比较虚拟机和容器的表格：
- en: '![Figure 1.3: Comparison of VMs and Containers'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3：虚拟机和容器的比较'
- en: '](image/B14870_01_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_03.jpg)'
- en: 'Figure 1.3: Comparison of VMs and Containers'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：虚拟机和容器的比较
- en: 'Looking at this comparison, it seems that containers win in all aspects except
    for isolation. The Linux container technologies that are leveraged by the containers
    are not new. The key Linux kernel features, namespace, and cgroup (which we will
    study later in this chapter) have existed for more than a decade. There were some
    older container implementations such as LXC and Cloud Foundry Warden before the
    emergence of Docker. Now, an interesting question is: given that container technology
    has so many benefits, why has it been adopted in recent years instead of a decade
    ago? We will find some answers to this question in the following sections.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个比较来看，容器在所有方面都胜过虚拟机，除了隔离性。容器所利用的Linux容器技术并不新鲜。关键的Linux内核特性，命名空间和cgroup（我们将在本章后面学习）已经存在了十多年。在Docker出现之前，还有一些旧的容器实现，如LXC和Cloud
    Foundry Warden。现在，一个有趣的问题是：鉴于容器技术有这么多好处，为什么它在最近几年才被采用，而不是十年前？我们将在接下来的章节中找到这个问题的一些答案。
- en: Docker Basics
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker基础知识
- en: Until now, we have seen the different advantages that containerization provides
    as opposed to running applications on a VM. Docker is the most commonly used containerization
    technology by a wide margin. In this section, we will start with some Docker basics
    and perform some exercises to get you first-hand experience of working with Docker.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了容器化相对于在虚拟机上运行应用程序提供的不同优势。Docker是目前最常用的容器化技术。在本节中，我们将从一些Docker基础知识开始，并进行一些练习，让您亲身体验使用Docker的工作。
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Apart from Docker, there are other container managers such as containerd and
    podman. They behave differently in terms of features and user experiences, for
    example, containerd and podman are claimed to be more lightweight than Docker,
    and better fit than Kubernetes. However, they are all **Open Container Initiatives**
    (**OCI**) compliant to guarantee the container images are compatible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Docker之外，还有其他容器管理器，如containerd和podman。它们在功能和用户体验方面表现不同，例如，containerd和podman被称为比Docker更轻量级，比Kubernetes更合适。然而，它们都符合**Open
    Container Initiatives** (**OCI**)标准，以确保容器镜像兼容。
- en: Although Docker can be installed on any OS, you should be aware that, on Windows
    and macOS, it actually creates a Linux VM (or uses equivalent virtualization technology
    such as HyperKit in macOS) and embeds Docker into the VM. In this chapter, we
    will use Ubuntu 18.04 LTS as the OS and the Docker Community Edition 18.09.7.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Docker可以安装在任何操作系统上，但你应该知道，在Windows和macOS上，它实际上创建了一个Linux虚拟机（或者在macOS中使用类似的虚拟化技术，如HyperKit），并将Docker嵌入到虚拟机中。在本章中，我们将使用Ubuntu
    18.04 LTS作为操作系统，以及Docker Community Edition 18.09.7。
- en: 'Before you proceed, please ensure that Docker is installed as per the instructions
    in the *Preface*. You can confirm whether Docker is installed by querying the
    version of Docker using the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保按照*前言*中的说明安装了Docker。您可以通过使用以下命令查询Docker的版本来确认Docker是否已安装：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should see the following output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All the commands in the following sections are executed as `root`. Enter `sudo
    -s` in the terminal, followed by the admin password when prompted, to get root
    access.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分中的所有命令都是以`root`身份执行的。在终端中输入`sudo -s`，然后在提示时输入管理员密码，以获取root访问权限。
- en: What's behind docker run?
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker run背后是什么？
- en: 'After Docker is installed, running a containerized application is quite simple.
    For demonstration purposes, we will use the Nginx web server as an example application.
    We can simply run the following command to start up the Nginx server:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Docker后，运行容器化应用程序非常简单。为了演示目的，我们将使用Nginx web服务器作为示例应用程序。我们可以简单地运行以下命令来启动Nginx服务器：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see the similar result:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似的结果：
- en: '![Figure 1.4: Starting up Nginx'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4：启动Nginx'
- en: '](image/B14870_01_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_04.jpg)'
- en: 'Figure 1.4: Starting up Nginx'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：启动Nginx
- en: 'This command involves several actions, described as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令涉及几个动作，描述如下：
- en: '`docker run` tells Docker Engine to run an application.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker run`告诉Docker引擎运行一个应用程序。'
- en: The `-d` parameter (short for `--detach`) forces the application to run in the
    background so that you won't see the output of the application in the terminal.
    Instead, you have to run `docker logs <container ID>` to implicitly get the output.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-d`参数（`--detach`的缩写）强制应用程序在后台运行，这样你就看不到应用程序在终端的输出。相反，你必须运行`docker logs <container
    ID>`来隐式获取输出。'
- en: Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The "detached" mode usually implies that the application is a long-running service.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: “分离”模式通常意味着应用程序是一个长时间运行的服务。
- en: The last parameter, `nginx`, indicates the image name on which the application
    is based. The image encapsulates the Nginx program as well as its dependencies.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个参数`nginx`表示应用程序所基于的镜像名称。该镜像封装了Nginx程序及其依赖项。
- en: 'The output logs explain a brief workflow: first, it tried to fetch the `nginx`
    image locally, which failed, so it retrieved the image from a public image repository
    (Docker Hub, which we will revisit later). Once the image is downloaded locally,
    it uses that image to start an instance, and then outputs an ID (in the preceding
    example, this is `96c374…`), identifying the running instance. As you can observe,
    this is a hexadecimal string, and you can use the beginning four or more unique
    characters in practice to refer to any instance. You should see that even the
    terminal outputs of the `docker` commands truncate the ID.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输出日志解释了一个简要的工作流程：首先，它尝试在本地获取`nginx`镜像，但失败了，所以它从公共镜像仓库（稍后我们将重新讨论的Docker Hub）中检索了镜像。一旦镜像在本地下载完成，它就使用该镜像启动一个实例，然后输出一个ID（在前面的示例中，这是`96c374…`），用于标识运行中的实例。正如你所看到的，这是一个十六进制字符串，你可以在实践中使用前四个或更多的唯一字符来引用任何实例。你应该看到，即使`docker`命令的终端输出也会截断ID。
- en: 'The running instance can be verified using the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令验证运行实例：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should see the following result:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下结果：
- en: '![Figure 1.5: Getting a list of all the running Docker containers'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.5：获取所有正在运行的Docker容器的列表'
- en: '](image/B14870_01_05.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_05.jpg)'
- en: 'Figure 1.5: Getting a list of all the running Docker containers'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：获取所有正在运行的Docker容器的列表
- en: The `docker ps` command lists all the running containers. In the preceding example,
    there is only one container running, which is `nginx`. Unlike a typical Nginx
    distribution that runs natively on a physical machine or VM, the `nginx` container
    functions in an isolated manner. The `nginx` container does not, by default, expose
    its service on host ports. Instead, it serves at the port of its container, which
    is an isolated entity. We can get to the `nginx` service by calling on port `80`
    of the container IP.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps`命令列出所有正在运行的容器。在前面的示例中，只有一个名为`nginx`的容器正在运行。与在物理机器或虚拟机上本地运行的典型Nginx发行版不同，`nginx`容器以隔离的方式运行。`nginx`容器默认不会在主机端口上公开其服务。相反，它在其容器的端口上提供服务，这是一个隔离的实体。我们可以通过调用容器IP的端口`80`来访问`nginx`服务。'
- en: 'First, let''s get the container IP by running the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过运行以下命令获取容器IP：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should see the following output (it may vary depending on your local environment):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出（具体内容可能因您的本地环境而异）：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, in this case, the `nginx` container has an IP address of `172.17.0.2`.
    Let''s check whether Nginx responds by accessing this IP on port `80`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在这种情况下，`nginx`容器的IP地址为`172.17.0.2`。让我们通过在端口`80`上访问此IP来检查Nginx是否有响应：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should see the following output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 1.6: Response of the Nginx container'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6：Nginx容器的响应'
- en: '](image/B14870_01_06.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_06.jpg)'
- en: 'Figure 1.6: Response of the Nginx container'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：Nginx容器的响应
- en: As you can see in *Figure 1.6*, we get a response, which is displayed in the
    terminal as the source HTML of the default home page.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在*图1.6*中所看到的，我们得到了一个响应，它显示在终端上作为默认主页的源HTML。
- en: 'Usually, we don''t rely on the internal IP to access the service. A more practical
    way is to expose the service on some port of the host. To map the host port `8080`
    to the container port `80`, use the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不依赖内部IP来访问服务。更实际的方法是在主机的某个端口上暴露服务。要将主机端口`8080`映射到容器端口`80`，请使用以下命令：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see a similar response:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似的响应：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `-p 8080:80` parameter tells Docker Engine to start the container and map
    the traffic on port 8080 of the host to the inside container at port `80`. Now,
    if we try to access the `localhost` on port `8080`, we will be able to access
    the containerized `nginx` service. Let''s try it out:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p 8080:80`参数告诉Docker Engine启动容器并将主机端口8080上的流量映射到容器内部的端口`80`。现在，如果我们尝试在端口`8080`上访问`localhost`，我们将能够访问容器化的`nginx`服务。让我们试一试：'
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You should see the same output as in *Figure 1.6*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到与*图1.6*中相同的输出。
- en: 'Nginx is an example of a type of workload that doesn''t have a fixed termination
    time, that is, it does not just show output and then terminates. This is also
    known as a **long-running service**. The other type of workload, which just runs
    to completion and exits, is called a **short-time service**, or simply a **job**.
    For containers running jobs, we can omit the `-d` parameter. Here is an example
    of a job:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx是一种没有固定终止时间的工作负载的示例，也就是说，它不仅仅显示输出然后终止。这也被称为**长时间运行的服务**。另一种工作负载，只是运行到完成并退出的类型，称为**短时间服务**，或简称为**作业**。对于运行作业的容器，我们可以省略`-d`参数。以下是作业的一个示例：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should see the following response:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 1.7: Running the hello-world image'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.7：运行hello-world镜像'
- en: '](image/B14870_01_07.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_07.jpg)'
- en: 'Figure 1.7: Running the hello-world image'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：运行hello-world镜像
- en: 'Now, if you run `docker ps`, which is intended to list running containers,
    it doesn''t show the `hello-world` container. This is as expected since the container
    has finished its job (that is, printing out the response text that we saw in the
    previous screenshot) and exited. To be able to find the exited container, you
    can run the same command with the `-a` flag, which will show all the containers:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您运行`docker ps`，这是用于列出运行中容器的命令，它不会显示`hello-world`容器。这是预期的，因为容器已经完成了它的工作（即，打印出我们在上一个截图中看到的响应文本）并退出了。为了能够找到已退出的容器，您可以使用相同的命令加上`-a`标志运行，这将显示所有容器：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see the following output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 1.8: Checking our exited container'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.8：检查我们的已退出容器'
- en: '](image/B14870_01_08.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_08.jpg)'
- en: 'Figure 1.8: Checking our exited container'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8：检查我们的已退出容器
- en: 'For a container that has stopped, you can delete it using `docker rm <container
    ID>`, or rerun it with `docker run <container ID>`. Alternatively, if you rerun
    the `docker run hello-world`, it will again bring up a new container with a new
    ID and exit after it finishes its job. You can try this out yourself as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于已停止的容器，您可以使用`docker rm <container ID>`删除它，或者使用`docker run <container ID>`重新运行它。或者，如果您重新运行`docker
    run hello-world`，它将再次启动一个新的容器，并在完成工作后退出。您可以按照以下步骤自行尝试：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should see the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 1.9: Checking multiple exited containers'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.9：检查多个已退出的容器'
- en: '](image/B14870_01_09.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_09.jpg)'
- en: 'Figure 1.9: Checking multiple exited containers'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9：检查多个已退出的容器
- en: Thus, you can see that running multiple containers based on the same underlying
    image is pretty straightforward.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以看到基于相同基础镜像运行多个容器是非常简单的。
- en: By now, you should have a very basic understanding of how a container is launched,
    and how to check its status.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该对容器是如何启动以及如何检查其状态有了非常基本的了解。
- en: Dockerfiles and Docker Images
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dockerfile和Docker镜像
- en: In the VM era, there was no standard or unified way to abstract and pack various
    kinds of applications. The traditional way was to use a tool, such as Ansible,
    to manage the installation and update the processes for each application. This
    is still used nowadays, but it involves lots of manual operations and is error-prone
    due to inconsistencies between different environments. From a developer's perspective,
    applications are developed on local machines, which are vastly different from
    the staging and eventual production environment.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟机时代，没有标准或统一的方式来抽象和打包各种类型的应用程序。传统的方法是使用工具，比如Ansible，来管理每个应用程序的安装和更新过程。这种方法现在仍在使用，但它涉及大量的手动操作，并且由于不同环境之间的不一致性而容易出错。从开发人员的角度来看，应用程序是在本地机器上开发的，这与分级和最终生产环境大不相同。
- en: So, how does Docker resolve these issues? The innovation it brings is called
    `Dockerfile` and Docker image. A `Dockerfile` is a text file that abstracts a
    series of instructions to build a reproducible environment including the application
    itself as well as all of its dependencies.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Docker是如何解决这些问题的呢？它带来的创新被称为`Dockerfile`和Docker镜像。`Dockerfile`是一个文本文件，它抽象了一系列指令来构建一个可重现的环境，包括应用程序本身以及所有的依赖项。
- en: 'By using the `docker build` command, Docker uses the `Dockerfile` to generate
    a standardized entity called a Docker image, which you can run on almost any OS.
    By leveraging Docker images, developers can develop and test applications in the
    same environment as the production one, because the dependencies are abstracted
    and bundled within the same image. Let''s take a step back and look at the `nginx`
    application we started earlier. Use the following command to list all the locally
    downloaded images:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`docker build`命令，Docker使用`Dockerfile`生成一个名为Docker镜像的标准化实体，您可以在几乎任何操作系统上运行它。通过利用Docker镜像，开发人员可以在与生产环境相同的环境中开发和测试应用程序，因为依赖项被抽象化并捆绑在同一个镜像中。让我们退一步，看看我们之前启动的`nginx`应用程序。使用以下命令列出所有本地下载的镜像：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should see the following list:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下列表：
- en: '![Figure 1.10: Getting a list of images'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.10：获取镜像列表'
- en: '](image/B14870_01_10.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_10.jpg)'
- en: 'Figure 1.10: Getting a list of images'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10：获取镜像列表
- en: Unlike VM images, Docker images only bundle the necessary files such as application
    binaries, dependencies, and the Linux root filesystem. Internally, a Docker image
    is separated into different layers, with each layer being stacked on top of another
    one. In this way, upgrading the application only requires an update to the relevant
    layers. This reduces both the image footprint as well as the upgrade time.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与虚拟机镜像不同，Docker镜像只捆绑必要的文件，如应用程序二进制文件、依赖项和Linux根文件系统。在内部，Docker镜像被分成不同的层，每个层都堆叠在另一个层上。这样，升级应用程序只需要更新相关的层。这既减少了镜像的占用空间，也减少了升级时间。
- en: 'The following figure shows the hierarchical layers of a hypothetical Docker
    image that is built from the base OS layer (Ubuntu), the Java web application
    runtime layer (Tomcat), and the topmost user application layer:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了一个假想的Docker镜像的分层结构，该镜像是从基本操作系统层（Ubuntu）、Java Web应用程序运行时层（Tomcat）和最顶层的用户应用程序层构建而成：
- en: '![Figure 1.11: An example of stacked layers in a container'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.11：容器中堆叠层的示例'
- en: '](image/B14870_01_11.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_11.jpg)'
- en: 'Figure 1.11: An example of stacked layers in a container'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11：容器中堆叠层的示例
- en: Note that it is common practice to use the images of a popular OS as a starting
    point for building Docker images (as you will see in the following exercise) since
    it conveniently includes the various components required to develop an application.
    In the preceding hypothetical container, the application would use Tomcat as well
    as some dependencies included in Ubuntu in order to function properly. This is
    the only reason that Ubuntu is included as the base layer. If we wanted, we could
    bundle the required dependencies without including the entire Ubuntu base image.
    So, don't confuse this with the case of a VM, where including a guest OS is necessary.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通常会使用流行操作系统的镜像作为构建Docker镜像的起点（正如您将在以下练习中看到的），因为它方便地包含了开发应用程序所需的各种组件。在上述假设的容器中，应用程序将使用Tomcat以及Ubuntu中包含的一些依赖项才能正常运行。这是将Ubuntu包含为基础层的唯一原因。如果我们愿意，我们可以在不包含整个Ubuntu基础镜像的情况下捆绑所需的依赖项。因此，不要将其与虚拟机的情况混淆，虚拟机需要包含一个客户操作系统的情况。
- en: Let's take a look at how we can build our own Docker image for an application
    in the following exercise.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在以下练习中为我们自己构建一个Docker镜像。
- en: 'Exercise 1.01: Creating a Docker Image and Uploading It to Docker Hub'
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.01：创建Docker镜像并将其上传到Docker Hub
- en: In this exercise, we will build a Docker image for a simple application written
    in Go.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将为一个用Go语言编写的简单应用程序构建一个Docker镜像。
- en: 'We''re going to use Go in this exercise so that the source code and its language
    dependencies can be compiled into a single executable binary. However, you''re
    free to use any programming language you prefer; just remember to bundle the language
    runtime dependencies if you''re going to use Java, Python, Node.js, or any other language:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用Go，这样源代码和它的语言依赖可以编译成一个可执行的二进制文件。然而，你可以自由选择任何你喜欢的编程语言；只要记得如果你要使用Java、Python、Node.js或任何其他语言，就要捆绑语言运行时依赖。
- en: 'For this exercise, we will create a file named `Dockerfile`. Note that this
    filename has no extension. You can use your preferred text editor to create this
    file with the following content:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个名为`Dockerfile`的文件。请注意，这个文件名没有扩展名。你可以使用你喜欢的文本编辑器创建这个文件，内容如下：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: From the terminal, whenever you create a file using any simple text editor such
    as vim or nano or using the `cat` command, it will be created in the current working
    directory in any Linux distro or even macOS. The default working directory when
    you open the terminal is `/home/`. If you prefer to use a different directory,
    please take that into account when following any of the exercise steps throughout
    this book.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端，无论你是使用vim或nano这样的简单文本编辑器，还是使用`cat`命令创建文件，它都会被创建在当前工作目录中，无论是在任何Linux发行版还是macOS中。当你打开终端时，默认的工作目录是`/home/`。如果你想使用不同的目录，请在遵循本书中的任何练习步骤时考虑这一点。
- en: The first line specifies which base image to use as the foundation. This example
    uses Alpine, a popular base image that takes only about 5 MB and is based on Alpine
    Linux. The second line copies a file called `k8s-for-beginners` from the directory
    where the `Dockerfile` is located to the root folder of the image. In this example,
    we will build a tiny web server and compile it to a binary with the name `k8s-for-beginners`,
    which will be placed in the same directory as the `Dockerfile`. The third line
    specifies the default startup command. In this case, we just start our sample
    web server.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行指定了要使用的基础镜像。这个示例使用了Alpine，一个流行的基础镜像，只占用大约5MB，基于Alpine Linux。第二行将一个名为`k8s-for-beginners`的文件从`Dockerfile`所在的目录复制到镜像的根目录。在这个示例中，我们将构建一个微型网络服务器，并将其编译成一个名为`k8s-for-beginners`的二进制文件，该文件将放在与`Dockerfile`相同的目录中。第三行指定了默认的启动命令。在这种情况下，我们只是启动我们的示例网络服务器。
- en: 'Next, let''s build our sample web server. Create a file named `main.go` with
    the following content:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们构建我们的示例网络服务器。创建一个名为`main.go`的文件，内容如下：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can observe from `func main()`, this application serves as a web server
    that accepts an incoming HTTP request at port 8080 on the root path and responds
    with the message `Hello Kubernetes Beginners`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以从`func main()`中观察到的那样，这个应用程序充当一个网络服务器，在8080端口的根路径接受传入的HTTP请求，并用消息`Hello
    Kubernetes Beginners`做出响应。
- en: To verify this program works, you can just run `go run main.go`, and then open
    [`http://localhost:8080`](http://localhost:8080) on the browser. You're expected
    to get the "`Hello Kubernetes Beginners!`" output.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证这个程序是否有效，你可以运行`go run main.go`，然后在浏览器上打开[`http://localhost:8080`](http://localhost:8080)。你应该会得到"`Hello
    Kubernetes Beginners!`"的输出。
- en: 'Use `go build` to compile runtime dependencies along with the source code into
    one executable binary. Run the following command in the terminal:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go build`将运行时依赖和源代码编译成一个可执行的二进制文件。在终端中运行以下命令：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike *step 3*, the arguments `GOOS=linux GOARCH=amd64` tell the Go compiler
    to compile the program on a specific platform, which turns out to be compatible
    with the Linux distro we are going to build this problem into. `CGO_ENABLED=0`
    is aimed to generate a statically linked binary so that it can work with some
    minimum-tailored image (For example, alpine).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与*步骤3*不同，参数`GOOS=linux GOARCH=amd64`告诉Go编译器在特定平台上编译程序，这与我们将要构建的Linux发行版兼容。`CGO_ENABLED=0`旨在生成一个静态链接的二进制文件，以便它可以与一些最小定制的镜像一起工作（例如alpine）。
- en: 'Now, check whether the `k8s-for-beginners` file is created:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查`k8s-for-beginners`文件是否已创建：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see the following response:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we have both the `Dockerfile` and the runnable binary. Build the Docker
    image by using the following command:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了`Dockerfile`和可运行的二进制文件。使用以下命令构建Docker镜像：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Don''t miss the dot (`.`) at the end of this command. You should see the following response:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不要错过这个命令末尾的点（`.`）。您应该会看到以下响应：
- en: '![Figure 1.12: Output of docker build command'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.12：docker build命令的输出'
- en: '](image/B14870_01_12.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_12.jpg)'
- en: 'Figure 1.12: Output of docker build command'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12：docker build命令的输出
- en: 'There are two parameters in the command that we used: `-t k8s-for-beginners:v0.0.1`
    provides a tag on the image with format `<imagename:version>`, while `.` (the
    dot at the end of the command) denotes the path to look for the `Dockerfile`.
    In this case, `.` refers to the current working directory.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的命令中有两个参数：`-t k8s-for-beginners:v0.0.1`为镜像提供了一个格式为`<imagename:version>`的标签，而`.`（命令末尾的点）表示查找`Dockerfile`的路径。在这种情况下，`.`指的是当前工作目录。
- en: Note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you clone the GitHub repository for this chapter, you will find that we have
    provided a copy of the `Dockerfile` in each directory so that you can conveniently
    run the `docker build` command by navigating to the directory.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您克隆了本章的GitHub存储库，您会发现我们在每个目录中都提供了`Dockerfile`的副本，以便您可以方便地通过转到该目录运行`docker
    build`命令。
- en: 'Now, we have the `k8s-for-beginners:v0.0.1` image available locally. You can
    confirm that by running the following command:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们本地有了`k8s-for-beginners:v0.0.1`镜像。您可以通过运行以下命令来确认：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should see the following response:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '![Figure 1.13: Verifying whether our Docker image has been created'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.13：验证我们的Docker镜像是否已创建'
- en: '](image/B14870_01_13.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_13.jpg)'
- en: 'Figure 1.13: Verifying whether our Docker image has been created'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13：验证我们的Docker镜像是否已创建
- en: An interesting thing to observe is that the image merely consumes 11.4 MB, which
    includes both the Linux system files and our application. A tip here is to only
    include necessary files in the Docker image to make it compact so that it is easy
    to distribute and manage.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的观察是，该镜像仅占用11.4 MB，其中包括Linux系统文件和我们的应用程序。这里的建议是只在Docker镜像中包含必要的文件，使其紧凑，以便易于分发和管理。
- en: Now that we have built our image, we will run it in a container in the next
    exercise. Another thing to note is that, currently, this image resides on our
    local machine, and we can build a container using it only on our machine. However,
    the advantage of packaging an application with its dependencies is that it can
    be easily run on different machines. To easily facilitate that, we can upload
    our images to online Docker image repositories such as Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了我们的镜像，接下来我们将在容器中运行它。另一个需要注意的是，目前这个镜像驻留在我们的本地机器上，我们只能在本地机器上使用它构建一个容器。然而，将应用程序与其依赖项打包的优势在于它可以轻松地在不同的机器上运行。为了方便起见，我们可以将我们的镜像上传到在线Docker镜像仓库，如Docker
    Hub（[https://hub.docker.com/](https://hub.docker.com/)）。
- en: 'Note:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: In addition to Docker Hub, there are other public image repositories such as
    [quay.io](http://quay.io), [gcr.io](http://gcr.io), and more. You can refer to
    the documentation of the respective repository to configure it properly in your
    Docker client.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Docker Hub，还有其他公共镜像仓库，如[quay.io](http://quay.io)，[gcr.io](http://gcr.io)等。您可以参考各自仓库的文档，以正确配置在您的Docker客户端中。
- en: 'Exercise 1.02: Running Your First Application in Docker'
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.02：在Docker中运行您的第一个应用程序
- en: 'In *Exercise 1.01*, *Creating a Docker Image and Uploading it to Docker Hub*,
    we packaged the web application into a Docker image. In this exercise, we will
    run it and push it to Docker Hub:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在*练习1.01*中，*创建Docker镜像并将其上传到Docker Hub*，我们将Web应用程序打包成Docker镜像。在这个练习中，我们将运行它并将其推送到Docker
    Hub：
- en: 'First, we should clean up any leftover containers from the previous exercise
    by running the following command in the terminal:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们应该通过在终端中运行以下命令清理掉上一个练习中的任何残留容器：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should see the following response:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have seen that `docker ps -a` returns the information of all the containers.
    The extra `q` in the `-aq` flag means "quiet" and the flag will only display numeric
    IDs. These IDs will be passed to `docker rm -f`, and, therefore, all the containers
    will be removed forcefully.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到`docker ps -a`返回所有容器的信息。`-aq`标志中的额外`q`表示“安静”，该标志只会显示数字ID。这些ID将被传递给`docker
    rm -f`，因此所有容器将被强制删除。
- en: 'Run the following command to start the webserver:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令启动web服务器：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should see the following response:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see in the preceding command, we are mapping the internal port `8080`
    of the container to the host machine's port `8080`. The `8080:8080` parameter
    preceded by `-p` maps port `8080` of the container to port `8080` on the host
    machine. The `-d` parameter indicates the detached mode. By default, Docker checks
    the local registry first. So, in this case, the local Docker image will be used
    for launching the container.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述命令中所示，我们将容器的内部端口`8080`映射到主机的端口`8080`。由`-p`前置的`8080:8080`参数将容器的端口`8080`映射到主机上的端口`8080`。`-d`参数表示分离模式。默认情况下，Docker首先检查本地注册表。因此，在这种情况下，将使用本地Docker镜像来启动容器。
- en: 'Now, let us check whether it works as expected by sending an HTTP request to
    `localhost` at port `8080`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过向`localhost`的端口`8080`发送HTTP请求来检查它是否按预期工作：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `curl` command checks for a response from the stated address. You should
    see the following response:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl`命令检查来自指定地址的响应。您应该看到以下响应：'
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can also observe the logs of the running container by using the following commands:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用以下命令观察运行容器的日志：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You should see the following logs:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下日志：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before running the following commands, you should register for a Docker Hub
    account and have your username and password ready.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行以下命令之前，您应该注册一个Docker Hub帐户，并准备好您的用户名和密码。
- en: 'Finally, we need to log in to Docker Hub, and then push the local image to
    the remote Docker Hub registry. Use the following command:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要登录到Docker Hub，然后将本地镜像推送到远程Docker Hub注册表。使用以下命令：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now enter the username and password to your Docker Hub account when prompted.
    You should see the following response:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在提示时输入您的Docker Hub帐户的用户名和密码。您应该看到以下响应：
- en: '![Figure 1.14: Logging in to Docker Hub'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.14：登录到Docker Hub'
- en: '](image/B14870_01_14.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_14.jpg)'
- en: 'Figure 1.14: Logging in to Docker Hub'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14：登录到Docker Hub
- en: 'Next, we will push the local image, `k8s-for-beginners:v0.0.1`, to the remote
    Docker Hub registry. Run the following command:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将把本地镜像`k8s-for-beginners:v0.0.1`推送到远程Docker Hub注册表。运行以下命令：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should see the following response:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 1.15: Failing to push the image to Docker Hub'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.15：无法将镜像推送到Docker Hub'
- en: '](image/B14870_01_15.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_15.jpg)'
- en: 'Figure 1.15: Failing to push the image to Docker Hub'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15：无法将图像推送到Docker Hub
- en: But wait, why does it say, "`requested access to the resource is denied`"? That
    is because the parameter followed by the `docker push` must comply with a `<username/imagename:version>`
    naming convention. In the previous exercise, we specified a local image tag, `k8s-for-beginners:v0.0.1`,
    without a username. In the `docker push` command, if no username is specified,
    it will try to push to the repository with the default username, `library`, which
    also hosts some well-known libraries such as Ubuntu, nginx, and more.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，等等，为什么它说“`请求访问被拒绝`”?那是因为`docker push`后面的参数必须符合`<username/imagename:version>`的命名约定。在上一个练习中，我们指定了一个本地图像标签，`k8s-for-beginners:v0.0.1`，没有用户名。在`docker
    push`命令中，如果没有指定用户名，它将尝试将其推送到默认用户名`library`的存储库，该存储库还托管一些知名库，如Ubuntu、nginx等。
- en: 'To push our local image to our own user, we need to give a compliant name for
    the local image by running `docker tag <imagename:version> <username/imagename:version>`,
    as shown in the following command:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将我们的本地图像推送到我们自己的用户，我们需要通过运行`docker tag <imagename:version> <username/imagename:version>`来为本地图像提供符合规范的名称，如下命令所示：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can verify that the image has been properly tagged using the following command:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令验证图像是否已正确标记：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should see the following output:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 1.16: Checking the tagged Docker image'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.16：检查标记的Docker图像'
- en: '](image/B14870_01_16.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_16.jpg)'
- en: 'Figure 1.16: Checking the tagged Docker image'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.16：检查标记的Docker图像
- en: After tagging it properly, you can tell that the new image actually has the
    same `IMAGE ID` as the old one, which implies they're the same image.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 标记正确后，您可以看到新图像实际上与旧图像具有相同的`IMAGE ID`，这意味着它们是相同的图像。
- en: 'Now that we have the image tagged appropriately, we''re ready to push this
    image to Docker Hub by running the following command:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经适当地标记了图像，我们准备通过运行以下命令将此图像推送到Docker Hub：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You should see a response similar to this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于此的响应：
- en: '![Figure 1.17: Image successfully pushed to Docker Hub'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.17：图像成功推送到Docker Hub'
- en: '](image/B14870_01_17.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_17.jpg)'
- en: 'Figure 1.17: Image successfully pushed to Docker Hub'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.17：图像成功推送到Docker Hub
- en: 'The image will be live after a short time on Docker Hub. You can verify it
    by replacing the `<username>` with your username in the following link: `https://hub.docker.com/repository/docker/<username>/k8s-for-beginners/tags`.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图像将在Docker Hub上短时间后上线。您可以通过在以下链接中用您的用户名替换`<username>`来验证它：`https://hub.docker.com/repository/docker/<username>/k8s-for-beginners/tags`。
- en: 'You should be able to see some information regarding your image, similar to
    the following image:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够看到有关您的图像的一些信息，类似于以下图像：
- en: '![Figure 1.18: The Docker Hub page for our image'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.18：我们图像的Docker Hub页面'
- en: '](image/B14870_01_18.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_18.jpg)'
- en: 'Figure 1.18: The Docker Hub page for our image'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.18：我们图像的Docker Hub页面
- en: Now our Docker image is publicly accessible for anyone to use, just like the
    `nginx` image we used at the beginning of this chapter.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的Docker图像对任何人都是公开可访问的，就像我们在本章开头使用的`nginx`图像一样。
- en: In this section, we learned how to build Docker images and push them to Docker
    Hub. Although it looks inconspicuous, it is the first time we have a unified mechanism
    to manage the applications, along with their dependencies, consistently across
    all environments. Docker images and their underlying layered filesystem are also
    the **primary reason** why container technology has been widely adopted in recent
    years, as opposed to a decade ago.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们学习了如何构建Docker镜像并将其推送到Docker Hub。尽管看起来不起眼，但这是我们第一次拥有一个统一的机制来一致地管理应用程序及其依赖项，跨所有环境。Docker镜像及其底层分层文件系统也是容器技术近年来被广泛采用的**主要原因**，与十年前相比。
- en: In the next section, we will dive a little deeper into Docker to see how it
    leverages Linux container technologies.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入了解Docker，看看它如何利用Linux容器技术。
- en: The Essence of Linux Container Technology
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux容器技术的本质
- en: All things look elegant and straightforward from the outside. But what's the
    magic working underneath to make a container so powerful? In this section, we
    will try to open the hood to take a look inside. Let us take a look at a few Linux
    technologies that lay the foundation for containers.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 所有事物从外表看起来都优雅而简单。但是在底层是如何运作的，让一个容器如此强大？在这一部分，我们将尝试打开引擎盖，看看里面。让我们来看看一些为容器奠定基础的Linux技术。
- en: Namespace
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: The first key technology relied upon by containers is called a **Linux namespace**.
    When a Linux system starts up, it creates a default namespace (the `root` namespace).
    Then, by default, the processes created later join the same namespace, and, hence,
    they can interact with each other boundlessly. For example, two processes are
    able to view the files in the same folder, and also interact through the `localhost`
    network. This sounds pretty straightforward, but technically it's all credited
    to the `root` namespace, which connects all the processes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 容器依赖的第一个关键技术称为Linux命名空间。当Linux系统启动时，它会创建一个默认命名空间（`root`命名空间）。然后，默认情况下，稍后创建的进程将加入相同的命名空间，因此它们可以无限制地相互交互。例如，两个进程能够查看同一文件夹中的文件，并通过`localhost`网络进行交互。这听起来很简单，但从技术上讲，这都归功于连接所有进程的`root`命名空间。
- en: 'To support advanced use cases, Linux offers the namespace API to enable different
    processes being grouped into different namespaces so that only the processes that
    belong to the same namespace can be aware of each other. In other words, different
    groups of processes are isolated. This also explains why we mentioned earlier
    that the isolation of Docker is process-level. The following is a list of the
    types of namespaces supported in the Linux kernel:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持高级用例，Linux提供了命名空间API，以便将不同的进程分组到不同的命名空间中，这样只有属于同一命名空间的进程才能相互感知。换句话说，不同组的进程被隔离。这也解释了为什么我们之前提到Docker的隔离是进程级别的。以下是Linux内核支持的命名空间类型列表：
- en: Mount namespaces
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载命名空间
- en: '**PID** (**Process ID**) namespaces'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PID（进程ID）命名空间
- en: Network namespaces
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络命名空间
- en: '**IPC** (**Inter-Process Communication**) namespaces'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPC（进程间通信）命名空间
- en: '**UTS** (**Unix Time-sharing System**) namespaces'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTS（Unix时间共享系统）命名空间
- en: User namespaces (since Linux kernel 3.8)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户命名空间（自Linux内核3.8以来）
- en: Cgroup namespaces (since Linux kernel 4.6)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cgroup命名空间（自Linux内核4.6以来）
- en: Time namespaces (to be implemented in a future version of the Linux kernel)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间命名空间（将在未来版本的Linux内核中实现）
- en: For the sake of brevity, we will choose two easy ones (UTS and PID) and use
    concrete examples to explain how they're reflected in Docker later.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们将选择两个简单的（UTS和PID）并使用具体示例来解释它们如何在Docker中体现。
- en: Note
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are running macOS, some of the following commands will need to be used
    differently, since we are exploring Linux features. Docker on macOS runs inside
    a Linux VM using HyperKit. So, you need to open another terminal session and log
    into the VM:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行 macOS，一些以下命令将需要以不同的方式使用，因为我们正在探索 Linux 的特性。Docker 在 macOS 上使用 HyperKit
    在 Linux VM 中运行。因此，你需要打开另一个终端会话并登录到 VM 中：
- en: '`screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty`'
- en: After this command, you may see an empty screen. Press *Enter*, and you should
    have root access to the VM that is running Docker. To exit the session, you can
    press *Ctrl* *+* *A* *+* *K*, and then press *Y* when asked for confirmation for
    killing the window.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '运行此命令后，你可能会看到一个空屏幕。按 *Enter*，你应该获得运行 Docker 的 VM 的 root 访问权限。要退出会话，你可以按 *Ctrl*
    *+* *A* *+* *K*，然后在要求确认关闭窗口时按 *Y*。 '
- en: We recommend that you use a different terminal window to access the Linux VM.
    We will mention which commands need to be run in this terminal session if you
    are using macOS. If you are using any Linux OS, you can ignore this and simply
    run all the commands in the same terminal session, unless mentioned otherwise
    in the instructions.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您使用另一个终端窗口访问 Linux VM。如果你使用 macOS，我们将提到需要在此终端会话中运行哪些命令。如果你使用任何 Linux 操作系统，你可以忽略这一点，并在同一个终端会话中运行所有命令，除非在说明中另有说明。
- en: 'Once a Docker container is created, Docker creates and associates a number
    of namespaces with the container. For example, let''s take a look at the sample
    container we created in the previous section. Let''s use the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Docker 容器后，Docker 会创建并关联一些命名空间到容器。例如，让我们看看在上一节中创建的示例容器。让我们使用以下命令：
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding command checks the PID of the container running on the host OS.
    You should see a response similar to the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令检查在主机操作系统上运行的容器的 PID。你应该看到类似以下的响应：
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this example, the PID is `5897`, as you can see in the preceding response.
    Now, run this command in the Linux VM:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，PID 是 `5897`，正如你在前面的响应中所看到的。现在，在 Linux VM 中运行以下命令：
- en: '[PRE36]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This should give an output similar to this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生类似于以下内容的输出：
- en: '![Figure 1.19: Checking the PID of our process'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.19：检查我们进程的PID'
- en: '](image/B14870_01_19.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_19.jpg)'
- en: 'Figure 1.19: Checking the PID of our process'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.19：检查我们进程的PID
- en: The `ps -ef` command lists all the running processes on the host OS, and `|
    grep k8s-for-beginners` then filters this list to display the processes that have
    `k8s-for-beginners` in their name. We can see that the process also has the PID
    `5897`, which is consistent with the first command. This reveals an important
    fact that a container is nothing but a particular process running directly on
    the host OS.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps -ef` 命令列出主机操作系统上所有正在运行的进程，然后 `| grep k8s-for-beginners` 过滤此列表，以显示名称中包含
    `k8s-for-beginners` 的进程。我们可以看到该进程还具有 PID `5897`，这与第一个命令一致。这揭示了一个重要的事实，即容器只是直接在主机操作系统上运行的特定进程。'
- en: 'Next, run this command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行此命令：
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For macOS, run this command in the VM terminal. You should see the following output:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS，在 VM 终端中运行此命令。你应该看到以下输出：
- en: '![Figure 1.20: Listing the different namespaces created for our container'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.20：列出为我们的容器创建的不同命名空间'
- en: '](image/B14870_01_20.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_20.jpg)'
- en: 'Figure 1.20: Listing the different namespaces created for our container'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.20：列出为我们的容器创建的不同命名空间
- en: This command checks the `/proc` folder (which is a Linux pseudo-filesystem)
    to list all the namespaces created along with the start of the container. The
    result shows some well-known namespaces (take a look at the highlighted rectangle)
    such as `uts`, `pid`, `net`, and more. Let's take a closer look at them.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令检查`/proc`文件夹（这是一个Linux伪文件系统），列出了随着容器启动创建的所有命名空间。结果显示了一些众所周知的命名空间（看一下突出显示的矩形），如`uts`、`pid`、`net`等。让我们仔细看看它们。
- en: 'The `uts` namespace is created to enable the container to have its hostname
    instead of the host''s hostname. By default, a container is assigned its container
    ID as the hostname, and it can be changed using the `-h` parameter while running
    a container, as shown here:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`uts`命名空间被创建，以使容器具有其主机名，而不是主机的主机名。默认情况下，容器被分配其容器ID作为主机名，并且可以在运行容器时使用`-h`参数进行更改，如下所示：'
- en: '[PRE38]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This should give the following response:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给出以下响应：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Using the returned container ID, we can enter the container and check its hostname
    using the following two commands one after the other:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用返回的容器ID，我们可以进入容器并使用以下两个命令依次检查其主机名：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You should see the following response:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `docker exec` command tries to enter into the container and execute the
    `sh` command to launch the shell inside the container. And once we're inside the
    container, we run the `hostname` command to check the hostname from inside the
    container. From the output, we can tell that the `-h` parameter is in effect because
    we can see `k8s-for-beginners` as the hostname.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker exec`命令尝试进入容器并执行`sh`命令，在容器内启动shell。一旦我们进入容器，我们运行`hostname`命令来检查容器内的主机名。从输出中，我们可以看出`-h`参数正在生效，因为我们可以看到`k8s-for-beginners`作为主机名。'
- en: 'In addition to the `uts` namespace, the container is also isolated in its own
    `PID` namespace, so it can only view the processes launched by itself, and the
    launching process (specified by `CMD` or `ENTRYPOINT` in the `Dockerfile` that
    we created in *Exercise 1.01*, *Creating a Docker Image and Uploading it to Docker
    Hub*) is assigned `PID` `1`. Let''s take a look at this by entering the following
    two commands one after the other:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`uts`命名空间，容器还在其自己的`PID`命名空间中进行隔离，因此它只能查看由自己启动的进程，而启动进程（由我们在*练习1.01*中创建的`Dockerfile`中的`CMD`或`ENTRYPOINT`指定）被分配为`PID`
    `1`。让我们通过依次输入以下两个命令来看一下这个：
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You should see the following response:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 1.21: The list of processes inside our container'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.21：容器内的进程列表'
- en: '](image/B14870_01_21.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_21.jpg)'
- en: 'Figure 1.21: The list of processes inside our container'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.21：容器内的进程列表
- en: Docker provides the `--pid` option for a container to join another container's
    PID namespace.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Docker为容器提供了`--pid`选项，以加入另一个容器的PID命名空间。
- en: In addition to the `uts` and `pid` namespaces, there are some other namespaces
    that Docker leverages. We will examine the network namespace ("`net`" in *Figure
    1.20*) in the next exercise.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`uts`和`pid`命名空间，Docker还利用了一些其他命名空间。我们将在下一个练习中检查网络命名空间（*图1.20*中的"`net`"）。
- en: 'Exercise 1.03: Joining a Container to the Network Namespace of Another Container'
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.03：将一个容器加入另一个容器的网络命名空间
- en: 'In this exercise, we will recreate the `k8s-for-beginners` container without
    host mapping, and then create another container to join its network namespace:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将重新创建`k8s-for-beginners`容器，而不进行主机映射，然后创建另一个容器加入其网络命名空间：
- en: 'As with the previous exercise, remove all the existing containers by running
    the following command:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前的练习一样，通过运行以下命令删除所有现有容器：
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should see an output similar to this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于这样的输出：
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, begin by running our container using the following command:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，开始使用以下命令运行我们的容器：
- en: '[PRE45]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You should see the following response:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we will get the list of running containers so that we can see the container ID:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将获取正在运行的容器列表，以便查看容器的ID：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You should see the following response:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '![Figure 1.22: Getting a list of all of the running containers'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.22：获取所有正在运行的容器列表'
- en: '](image/B14870_01_22.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_22.jpg)'
- en: 'Figure 1.22: Getting a list of all of the running containers'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.22：获取所有正在运行的容器列表
- en: 'Now, we will run an image called `netshoot` in the same network namespace as
    the container that we created in *step 1*, by using the `--net` parameter:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在与我们在*步骤1*中创建的容器相同的网络命名空间中运行一个名为`netshoot`的镜像，使用`--net`参数：
- en: '[PRE48]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Use the container ID of our previous container that we obtained in the previous
    step. You should see a response that is similar to the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在上一步中获得的先前容器的容器ID。您应该会看到类似于以下响应：
- en: '![Figure 1.23: Starting up the netshoot container'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.23：启动netshoot容器'
- en: '](image/B14870_01_23.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_23.jpg)'
- en: 'Figure 1.23: Starting up the netshoot container'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.23：启动netshoot容器
- en: '`nicolaka/netshoot` is a tiny image packaged with some commonly used network
    libraries such as `iproute2`, `curl`, and more.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`nicolaka/netshoot`是一个打包了一些常用网络库（如`iproute2`、`curl`等）的微型镜像。'
- en: 'Now, let''s run the `curl` command inside `netshoot` to check whether we are
    able to access the `k8s-for-beginners` container:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`netshoot`内部运行`curl`命令，以检查我们是否能够访问`k8s-for-beginners`容器：
- en: '[PRE49]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You should see the following response:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '[PRE50]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding example proves that the `netshoot` container was created by joining
    the network namespace of `k8s-for-beginners`; otherwise, accessing port `8080`
    on `localhost` wouldn't have got us a response.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例证明了`netshoot`容器是通过加入`k8s-for-beginners`的网络命名空间而创建的；否则，在`localhost`上访问端口`8080`就不会得到响应。
- en: This can also be verified by double-checking the network namespace IDs of the
    two containers, which we will do in the following steps.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这也可以通过在接下来的步骤中验证两个容器的网络命名空间ID来进行验证。
- en: 'To confirm our result, let us first open another terminal without exiting the
    `netshoot` container. Get the list of containers to ensure both containers are
     running:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认我们的结果，让我们首先在不退出`netshoot`容器的情况下打开另一个终端。获取容器列表以确保两个容器都在运行：
- en: '[PRE51]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You should see a response as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '![Figure 1.24: Checking whether both of the k8s-for-beginners and netshoot'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.24：检查k8s-for-beginners和netshoot是否都在线'
- en: containers are online
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 容器都在线
- en: '](image/B14870_01_24.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_24.jpg)'
- en: 'Figure 1.24: Checking whether both of the k8s-for-beginners and netshoot containers
    are online'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.24：检查k8s-for-beginners和netshoot容器是否都在线
- en: 'Next, get the PID of the `k8s-for-beginners` container:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，获取`k8s-for-beginners`容器的PID：
- en: '[PRE52]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You should see the following response:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '[PRE53]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see, the PID for this example is `7311`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此示例的PID为`7311`。
- en: 'Now get the pseudo-filesystem of the process using the preceding PID:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用前面的PID获取进程的伪文件系统：
- en: '[PRE54]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you are using macOS, run this command on the Linux VM in another terminal
    session. Use the PID you obtained in the previous step in this command. You should
    see the following response:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是macOS，请在另一个终端会话中在Linux VM上运行此命令。在此命令中使用您在上一步中获得的PID。您应该会看到以下响应：
- en: '[PRE55]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Similarly, get the PID of the `netshoot` container using the following command:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，使用以下命令获取`netshoot`容器的PID：
- en: '[PRE56]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Use the appropriate container ID from *step 6* in this command. You should
    see the following response:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令中使用*步骤6*中的适当容器ID。您应该会看到以下响应：
- en: '[PRE57]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see, the PID of the `netshoot` container is `8143`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`netshoot` 容器的 PID 是 `8143`。
- en: 'Next, we can get its pseudo-filesystem using its PID or by using this command:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过其 PID 或使用此命令获取其伪文件系统：
- en: '[PRE58]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If you are using macOS, run this command on the Linux VM in another session.
    Use the PID from the previous step in this command. You should see the following
    response:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 macOS，在另一个会话中在 Linux VM 上运行此命令。在此命令中使用上一步中的 PID。您应该会看到以下响应：
- en: '[PRE59]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can observe from the outputs of *step 8* and *step 10*, the two containers
    share the same network namespace (`4026532247`).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从 *步骤 8* 和 *步骤 10* 的输出中所观察到的，这两个容器共享相同的网络命名空间（`4026532247`）。
- en: 'As a final cleanup step, let''s remove all of the containers:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后的清理步骤，让我们删除所有的容器：
- en: '[PRE60]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You should see a response similar to the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到类似以下的响应：
- en: '[PRE61]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'What if you want to join a container to the host''s root namespace? Well, `--net
    host` is a good way of achieving that. To demonstrate this, we will start a container
    using the same image, but with the `--net host` parameter:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想要将容器加入到主机的根命名空间中怎么办？嗯，`--net host` 是实现这一目标的好方法。为了演示这一点，我们将使用相同的镜像启动一个容器，但使用
    `--net host` 参数：
- en: '[PRE62]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You should see the following response:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '[PRE63]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, list all of the running containers:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，列出所有正在运行的容器：
- en: '[PRE64]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You should see the following response:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '![Figure 1.25: Listing all the containers'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.25：列出所有容器'
- en: '](image/B14870_01_25.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_25.jpg)'
- en: 'Figure 1.25: Listing all the containers'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.25：列出所有容器
- en: 'Get the PID of the running container using the following command:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令获取正在运行的容器的 PID：
- en: '[PRE65]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Use the appropriate container ID in this command. You should see the following response:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令中使用适当的容器 ID。您应该会看到以下响应：
- en: '[PRE66]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Find the network namespace ID by looking up the PID:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查找 PID 查找网络命名空间 ID：
- en: '[PRE67]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If you are using macOS, run this command on the Linux VM. Use the appropriate
    PID in this command. You should see the following response:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 macOS，在 Linux VM 上运行此命令。在此命令中使用适当的 PID。您应该会看到以下响应：
- en: '[PRE68]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You may be confused by the `4026531993` namespace. By giving the `--net host`
    parameter, shouldn't Docker bypass the creation of a new namespace? The answer
    to this is that it's not a new namespace; in fact, it's the aforementioned Linux
    root namespace. We will confirm this in the next step.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会对 `4026531993` 命名空间感到困惑。通过给出 `--net host` 参数，Docker 不应该绕过创建新的命名空间吗？答案是这不是一个新的命名空间；事实上，它就是前面提到的
    Linux 根命名空间。我们将在下一步中确认这一点。
- en: 'Get the namespace of PID `1` of the host OS:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取主机操作系统的 PID `1` 的命名空间：
- en: '[PRE69]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If you are using macOS, run this command on the Linux VM. You should see the
    following response:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 macOS，在 Linux VM 上运行此命令。您应该会看到以下响应：
- en: '[PRE70]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: As you can see in this output, this namespace of the host is the same as that
    of the container we saw in *step 15*.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在此输出中所看到的，主机的这个命名空间与我们在 *步骤 15* 中看到的容器的命名空间是相同的。
- en: From this exercise, we can get an impression of how a container is isolated
    into different namespaces, and also which Docker parameter can be used to relate
    it with other namespaces.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，我们可以对容器如何被隔离到不同的命名空间以及哪些 Docker 参数可以用来与其他命名空间相关联有所了解。
- en: Cgroups
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cgroups
- en: By default, no matter which namespace a container joins, it can use all of the
    available resources of the host. That is, for sure, not what we want when we are
    running multiple containers on a system; otherwise, a few containers may hog the
    resources shared among all the containers.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，无论容器加入哪个命名空间，它都可以使用主机的所有可用资源。这当然不是我们在系统上运行多个容器时想要的情况；否则，一些容器可能会独占所有容器共享的资源。
- en: To address this, the **cgroups** (short for **Control Groups**) feature was
    introduced in Linux kernel version 2.6.24 onward to limit the resource usage of
    processes. Using this feature, a system administrator can control the most important
    resources, such as memory, CPU, disk space, and network bandwidth.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Linux 内核版本 2.6.24 以后引入了 **cgroups**（**Control Groups** 的缩写）功能，用于限制进程的资源使用。使用这个功能，系统管理员可以控制最重要的资源，如内存、CPU、磁盘空间和网络带宽。
- en: In Ubuntu 18.04 LTS, a series of cgroups under path `/sys/fs/cgroup/<cgroup
    type>` are created by default.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 18.04 LTS 中，默认情况下会在路径 `/sys/fs/cgroup/<cgroup type>` 下创建一系列 cgroups。
- en: Note
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can run `mount -t cgroup` in order to view all the cgroups in Ubuntu; though,
    we are leaving them out of the scope of this book since they are not very relevant
    to us.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行 `mount -t cgroup` 来查看 Ubuntu 中的所有 cgroups；尽管如此，我们不会在本书的范围内涉及它们，因为它们对我们来说并不是很相关。
- en: 'Right now, we don''t quite care about the system processes and their cgroups;
    we just want to focus on how Docker is related in the whole cgroups picture. Docker
    has its cgroups folders under the path `/sys/fs/cgroup/<resource kind>/docker`.
    Use the `find` command to retrieve the list:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们并不太关心系统进程及其 cgroups；我们只想关注 Docker 在整个 cgroups 图中的关系。Docker 在路径 `/sys/fs/cgroup/<resource
    kind>/docker` 下有其 cgroups 文件夹。使用 `find` 命令来检索列表：
- en: '[PRE71]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If you are using macOS, run this command on the Linux VM in another session.
    You should see the following results:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 macOS，在 Linux VM 的另一个会话中运行此命令。您应该会看到以下结果：
- en: '![Figure 1.26: Getting all the cgroups related to Docker'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.26：获取与 Docker 相关的所有 cgroups'
- en: '](image/B14870_01_26.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_26.jpg)'
- en: 'Figure 1.26: Getting all the cgroups related to Docker'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.26：获取与 Docker 相关的所有 cgroups
- en: Each folder is read as a control group, and the folders are hierarchical, meaning
    that each cgroup has a parent from which it inherits properties, all the way up
    to the root cgroup, which is created at the system start.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件夹都被视为一个控制组，这些文件夹是分层的，这意味着每个 cgroup 都有一个从其继承属性的父级，一直到在系统启动时创建的根 cgroup。
- en: To illustrate how a cgroup works in Docker, we will use the `memory` cgroup,
    highlighted in *Figure 1.26* as an example.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 cgroup 在 Docker 中的工作原理，我们将使用 *图 1.26* 中突出显示的 `memory` cgroup 作为示例。
- en: 'But first, let''s remove all existing containers using the following command:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们使用以下命令删除所有现有的容器：
- en: '[PRE72]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You should see a response similar to the following:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到类似以下的响应：
- en: '[PRE73]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let''s confirm that by using the following command:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下命令来确认：
- en: '[PRE74]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You should see an empty list as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到一个空列表，如下所示：
- en: '[PRE75]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Let''s see whether there is a `cgroup` memory folder:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看是否有 `cgroup` 内存文件夹：
- en: '[PRE76]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If you are using macOS, run this command on the Linux VM. You should then see
    the following response:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 macOS，在 Linux VM 上运行此命令。然后您应该会看到以下响应：
- en: '[PRE77]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'No folders show up. Now, let''s run a container:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 没有文件夹显示出来。现在，让我们运行一个容器：
- en: '[PRE78]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You should see the output similar to the following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到类似以下的输出：
- en: '[PRE79]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Check the `cgroup` folder again:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查 `cgroup` 文件夹：
- en: '[PRE80]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If you are using macOS, run this command on the Linux VM. You should see this response:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 macOS，在 Linux VM 上运行此命令。您应该会看到以下响应：
- en: '[PRE81]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'By now, you can see that once we create a container, Docker creates its cgroup
    folder under a specific resource kind (in our example, it''s memory). Now, let''s
    take a look at which files are created in this folder:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可以看到一旦我们创建一个容器，Docker 就会在特定资源类型（在我们的示例中是内存）下创建其 cgroup 文件夹。现在，让我们看看在这个文件夹中创建了哪些文件：
- en: '[PRE82]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'If you are using macOS, run this command on the Linux VM. Please use the appropriate
    path that you obtained from the previous screenshot for your instance. You should
    see the following list of files:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 macOS，在 Linux VM 上运行此命令。请使用您从上一张截图中获得的适当路径。您应该会看到以下文件列表：
- en: '![Figure 1.27: Exploring memory cgroups created by Docker'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.27：探索Docker创建的内存cgroups'
- en: '](image/B14870_01_27.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_27.jpg)'
- en: 'Figure 1.27: Exploring memory cgroups created by Docker'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.27：探索Docker创建的内存cgroups
- en: 'We won''t go through every setting here. The setting we''re interested in is
    `memory.limit_in_bytes`, as highlighted previously, which denotes how much memory
    the container can use. Let''s see what value is written in this file:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里介绍每个设置。 我们感兴趣的设置是`memory.limit_in_bytes`，如前所述，它表示容器可以使用多少内存。 让我们看看这个文件中写了什么值：
- en: '[PRE83]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'If you are using macOS, run this command on the Linux VM. You should see the
    following response:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是macOS，请在Linux VM上运行此命令。 您应该看到以下响应：
- en: '[PRE84]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The value `9223372036854771712` is the largest positive signed integer (263
    – 1) in a 64-bit system, which means unlimited memory can be used by this container.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 值`9223372036854771712`是64位系统中最大的正有符号整数（263-1），这意味着此容器可以使用无限的内存。
- en: 'To discover how Docker deals with the containers that overuse claimed memory,
    we''re going to show you another program that consumes a certain amount of RAM.
    The following is a Golang program used to consume 50 MB of RAM incrementally and
    then hold the entire program (sleep for 1 hour) so as to not exit:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解Docker如何处理过度使用声明内存的容器，我们将向您展示另一个程序，该程序消耗一定量的RAM。 以下是一个用于逐步消耗50 MB RAM然后保持整个程序（休眠1小时）以防止退出的Golang程序：
- en: '[PRE85]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You may try building an image using this code, as shown in *Exercise 1.01*,
    *Creating a Docker Image and Uploading it to Docker Hub*. This code will be used
    in place of the code provided in *step 2* of that exercise, and then you can tag
    the image with `<username>/memconsumer`. Now, we can test resource limitations.
    Let's use the Docker image and run it with the `--memory` (or `-m`) flag to instruct
    Docker that we only want to use a certain amount of RAM.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试使用此代码构建一个镜像，如*练习1.01*中所示，*创建Docker镜像并将其上传到Docker Hub*。 此代码将用于替换该练习中*步骤2*中提供的代码，然后您可以使用`<username>/memconsumer`为镜像打标签。
    现在，我们可以测试资源限制。 让我们使用Docker镜像并使用`--memory`（或`-m`）标志运行它，以指示Docker我们只想使用一定量的RAM。
- en: 'If you are using Ubuntu or any other Debian-based Linux, to continue with the
    chapter, you may need to manually enable cgroup memory and swap capabilities if
    you see the following warning message when running this command:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Ubuntu或任何其他基于Debian的Linux，在继续本章之前，如果在运行此命令时看到以下警告消息，则可能需要手动启用cgroup内存和交换功能：
- en: '[PRE86]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This is the warning message that you may see:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您可能会看到的警告消息：
- en: '[PRE87]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The steps to enable cgroup memory and swap capabilities are as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 启用cgroup内存和交换功能的步骤如下：
- en: Note
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The following three steps are not applicable if you are using macOS.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是macOS，则以下三个步骤不适用。
- en: 'Edit the `/etc/default/grub` file (you may need root privileges for this).
    Add or edit the `GRUB_CMDLINE_LINUX` line to add the following two key-value pairs:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`/etc/default/grub`文件（可能需要root权限）。 添加或编辑`GRUB_CMDLINE_LINUX`行以添加以下两个键值对：
- en: '[PRE88]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Run `update-grub` using root privileges.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用root权限运行`update-grub`。
- en: Reboot the machine.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动机器。
- en: 'Next, we should be able to limit the container memory usage to 100 MB by running
    the following command:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该能够通过运行以下命令来限制容器的内存使用量为100 MB：
- en: '[PRE89]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This command pulls the image that we have provided for this demonstration. If
    you have built your image, you can use that by using `<your_username>/<tag_name>`
    in the preceding command.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令拉取了我们为此演示提供的镜像。 如果您已构建了自己的镜像，可以在前面的命令中使用`<your_username>/<tag_name>`。
- en: 'You should see the following response:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE90]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This command disables usage on the swap memory (since we specify the same value
    on `--memory` and `--memory-swap`) so as to gauge the consumption of memory easily.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令禁用了交换内存的使用（因为我们在`--memory`和`--memory-swap`上指定了相同的值），以便轻松地衡量内存的消耗。
- en: 'Let''s check the status of our container:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们的容器的状态：
- en: '[PRE91]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'You should see the following response:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '![Figure 1.28: Getting the list of containers'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.28：获取容器列表'
- en: '](image/B14870_01_28.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_28.jpg)'
- en: 'Figure 1.28: Getting the list of containers'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.28：获取容器列表
- en: 'Now, let''s confirm the restrictions placed on the container by reading the
    `cgroup` file for the container:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过读取容器的`cgroup`文件来确认对容器施加的限制：
- en: '[PRE92]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If you are using macOS, run this command on the Linux VM. Please use the appropriate
    path in this command. You should see the following response:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是macOS，请在Linux VM上运行此命令。请在此命令中使用适当的路径。你应该看到以下响应：
- en: '[PRE93]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The container is launched with a request of 100 MB of RAM, and it runs without
    any problem since it internally only consumes 50 MB of RAM. From the cgroup setting,
    you can observe that the value has been updated to `104857600`, which is exactly
    100 MB.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 容器启动时请求了100 MB的RAM，并且它在内部只消耗了50 MB的RAM，因此可以正常运行。从cgroup设置中，您可以观察到该值已更新为`104857600`，这正好是100
    MB。
- en: But what if the container requests less than 50 MB, while the program running
    in it requires more than 50 MB? How will Docker and Linux respond to that? Let's
    take a look.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果容器请求少于50 MB，而其中运行的程序需要超过50 MB呢？Docker和Linux会如何响应？让我们来看看。
- en: 'First, let''s remove any running containers:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们删除任何正在运行的容器：
- en: '[PRE94]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'You should see the following response:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '[PRE95]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, we''re going to run the container again, but we will request only 20
    MB of memory:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将再次运行容器，但是我们只会请求20 MB的内存：
- en: '[PRE96]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You should see this response:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到这个响应：
- en: '[PRE97]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now, let''s check the status of our container:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一下我们的容器的状态：
- en: '[PRE98]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You should see an empty list like this:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个空列表，就像这样：
- en: '[PRE99]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'As you can see, we cannot see our container. Let''s list all kinds of containers:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们无法看到我们的容器。让我们列出所有类型的容器：
- en: '[PRE100]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'You should see the following output:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![Figure 1.29: Getting a list of all containers'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.29：获取所有容器的列表'
- en: '](image/B14870_01_29.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_29.jpg)'
- en: 'Figure 1.29: Getting a list of all containers'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.29：获取所有容器的列表
- en: 'We found our container. It has been forcibly killed. It can be verified by
    checking the container logs:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了我们的容器。它已被强制终止。可以通过检查容器日志来验证：
- en: '[PRE101]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'You should see the following output:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![Figure 1.30: The logs of our terminated container'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.30：我们终止的容器的日志'
- en: '](image/B14870_01_30.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_30.jpg)'
- en: 'Figure 1.30: The logs of our terminated container'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.30：我们终止的容器的日志
- en: The container tried to increase the memory consumed by 1 MB each time, and when
    it came to the memory limit (20 MB), it was killed.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 容器试图每次增加1 MB的内存消耗，当它达到内存限制（20 MB）时，它被杀死。
- en: From the preceding examples, we have seen how Docker exposes flags to end-users,
    and how those flags interact with underlying Linux cgroups to limit resource usage.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，我们已经看到Docker如何向最终用户公开标志，以及这些标志如何与底层的Linux cgroups交互以限制资源使用。
- en: 'Containerization: The Mindset Change'
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化：思维方式的改变
- en: In the previous sections, we looked at the anatomy of Linux namespaces and cgroups.
    We explained that a container is essentially a process running natively on the
    host OS. It is a special process with additional limitations such as OS-level
    isolation from other processes and the control of resource quotas.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看了Linux命名空间和cgroups的解剖。我们解释了容器本质上是在主机操作系统上本地运行的进程。它是一个特殊的进程，具有额外的限制，如与其他进程的操作系统级隔离和资源配额的控制。
- en: 'Since Docker 1.11, **containerd** has been adopted as the default container
    runtime, instead of directly using Docker Daemon (`dockerd`) to manage containers.
    Let''s take a look at this runtime. First, restart our container normally:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 自Docker 1.11以来，containerd已被采用为默认的容器运行时，而不是直接使用Docker Daemon（`dockerd`）来管理容器。让我们来看看这个运行时。首先，正常重启我们的容器：
- en: '[PRE102]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'You should see the following response:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE103]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We can use `ps -aef --forest` to list all of the running processes in a hierarchy,
    and then use `| grep containerd` to filter the output by the `containerd` keyword.
    Finally, we can use `-A 1` to output one extra line (using `-A 1`) so that at
    least one running container shows up:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ps -aef --forest`来列出层次结构中所有运行的进程，然后使用`| grep containerd`来通过`containerd`关键字过滤输出。最后，我们可以使用`-A
    1`来输出一行额外的内容（使用`-A 1`），以便至少有一个运行的容器显示出来：
- en: '[PRE104]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'If you are using macOS, run this command on the Linux VM without the `--forest`
    flag. You should see the following response:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用macOS，请在没有`--forest`标志的Linux VM上运行此命令。您应该看到以下响应：
- en: '![Figure 1.31: Getting processes related to containerd'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.31：获取与containerd相关的进程'
- en: '](image/B14870_01_31.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_01_31.jpg)'
- en: 'Figure 1.31: Getting processes related to containerd'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.31：获取与containerd相关的进程
- en: In the output, we can see that `containerd` (PID `1037`) acts as the top parent
    process, and it manages `containerd-shim` (PID `19374`), and `containerd-shim`
    manages most of the child processes of `k8s-for-beginners` (PID `19394`), which
    is the container we started.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到`containerd`（PID `1037`）充当顶级父进程，并管理`containerd-shim`（PID `19374`），而`containerd-shim`管理`k8s-for-beginners`（PID
    `19394`）的大多数子进程，这是我们启动的容器。
- en: 'Keeping the core idea of a container in mind can help you while migrating any
    VM-based applications to container-based ones. Basically, there are two patterns
    to deploy applications in containers:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记容器的核心思想可以帮助您将任何基于VM的应用程序迁移到基于容器的应用程序。基本上，有两种模式可以部署容器中的应用程序：
- en: Several Applications in One Container
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个容器中的多个应用程序
- en: 'This kind of implementation requires a supervisor application to launch and
    hold the container. And then, we can put applications into the container as child
    processes of the supervisor. The supervisor has several variants:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现需要一个监督者应用程序来启动和持有容器。然后，我们可以将应用程序放入容器作为监督者的子进程。监督者有几个变体：
- en: 'A customized wrapper script: This needs complicated scripting to control the
    failures of managed applications.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义包装脚本：这需要复杂的脚本来控制受管应用程序的故障。
- en: 'A third-party tool such as supervisord or systemd: Upon application failures,
    the supervisor is responsible for getting it restarted.'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方工具，如supervisord或systemd：在应用程序失败时，监督者负责重新启动它。
- en: One Application in One Container
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个容器中的一个应用程序
- en: This kind of implementation does not require any supervisor as in the previous
    case. In fact, the life cycle of the application is tied to the life cycle of
    the container.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现不需要像之前那样的监督者。事实上，应用程序的生命周期与容器的生命周期相关联。
- en: A Comparison of These Approaches
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这些方法的比较
- en: 'By deploying several applications in a single container, we are essentially
    treating a container as a VM. This *container as a lightweight VM* approach was
    once used as a promotion slogan of container technologies. However, as explained,
    they vary in a lot of aspects. Of course, this way can save the migration efforts
    from the VM-based development/deployment model to the containers, but it also
    introduces several drawbacks in the following aspects:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在单个容器中部署多个应用程序，我们实质上是将容器视为VM。这种*容器作为轻量级VM*的方法曾经被用作容器技术的宣传口号。然而，正如所解释的，它们在许多方面都有所不同。当然，这种方式可以节省从基于VM的开发/部署模型迁移到容器的工作，但它也在以下方面引入了一些缺点：
- en: '**Application life cycle control**: Looking from the outside, the container
    is exposed as one state, as it is essentially a single host process. The life
    cycles of the internal applications are managed by the "supervisor", and, therefore,
    cannot be observed from the outside. So, looking from the outside, you may observe
    that a container stays healthy, but some applications inside it may be restarting
    persistently. It may keep restarting due to a fatal error in one of its internal
    applications, which you may not be able to point out.'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序生命周期控制：从外部看，容器暴露为一个状态，因为它本质上是一个单一的主机进程。内部应用程序的生命周期由“监督者”管理，因此无法从外部观察。因此，从外部看，您可能会观察到容器保持健康，但其中一些应用程序可能会持续重启。它可能会因为内部应用程序的致命错误而持续重启，而您可能无法指出这一点。
- en: '**Version upgrade**: If you want to upgrade any one of the different applications
    in a container, you may have to pull down the entire container. This causes unnecessary
    downtime for the other applications in that container, which don''t need a version
    upgrade. Thus, if the applications require components that are developed by different
    teams, their release cycles have to be tightly coupled.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本升级：如果您想升级容器中的任何一个不同的应用程序，您可能需要拉下整个容器。这会导致容器中其他不需要版本升级的应用程序不必要的停机时间。因此，如果应用程序需要由不同团队开发的组件，它们的发布周期必须紧密耦合。
- en: '**Horizontal scaling**: If only one application needs to be scaled out, you
    have no option but to scale out the whole container, which will also replicate
    all the other applications. This leads to a waste of resources on the applications
    that don''t need scaling.'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平扩展：如果只有一个应用程序需要扩展，您别无选择，只能扩展整个容器，这也会复制所有其他应用程序。这会导致不需要扩展的应用程序浪费资源。
- en: '**Operational concerns**: Checking the logs of the applications becomes more
    challenging as the standard output (`stdout`) and error (`stderr`) of the container
    don''t represent the logs of the applications inside containers. You have to make
    an extra effort to manage those logs, such as installing additional monitoring
    tools to diagnose the health of each application.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时的考虑：检查应用程序的日志变得更具挑战性，因为容器的标准输出（`stdout`）和错误（`stderr`）不代表容器内应用程序的日志。您必须额外努力来管理这些日志，比如安装额外的监控工具来诊断每个应用程序的健康状况。
- en: Technically, having multiple applications in a single container works, and it
    doesn't require many mindset changes from a VM perspective. However, when we adopt
    the container technology to enjoy its benefits, we need to make a trade-off between
    migration conveniences and long-term maintainability.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，在单个容器中运行多个应用程序是可行的，并且不需要从虚拟机的角度进行太多思维转变。然而，当我们采用容器技术来享受其好处时，我们需要在迁移便利性和长期可维护性之间进行权衡。
- en: The second way (that is, having one application in one container) enables a
    container to automatically manage the life cycle of the only application present
    inside it. In this way, we can unify container management by leveraging native
    Linux capabilities, such as getting an application status by checking the container
    state and fetching application logs from the `stdout/stderr` of the container.
    This enables you to manage each application in its own release cycle.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式（即一个容器中只有一个应用程序）使容器能够自动管理其内部唯一应用程序的生命周期。通过利用原生的Linux功能，例如通过检查容器状态获取应用程序状态，并从容器的`stdout/stderr`获取应用程序日志，我们可以统一容器管理。这使您能够管理每个应用程序的发布周期。
- en: However, this is not an easy task. It requires you to rethink the relationship
    and dependencies of different components so as to break the monolithic applications
    into microservices. This may require a certain amount of refactoring of the architectural
    design to include both source code and delivery pipeline changes.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是一件容易的事情。这需要你重新思考不同组件之间的关系和依赖，以将单片应用程序拆分为微服务。这可能需要对架构设计进行一定程度的重构，包括源代码和交付流程的改变。
- en: To summarize, adopting container technology is a break-up-and-reorganize journey.
    It not only takes time for the technology to mature but also, more importantly,
    it requires changes in people's mindsets. Only with this mindset change can you
    restructure the applications as well as the underlying infrastructure to unleash
    the value of containers and enjoy their real benefits. It's the **second reason**
    that container technologies only started to rise in recent years instead of a
    decade ago.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，采用容器技术是一次分离和重组的旅程。这不仅需要技术成熟的时间，更重要的是，它需要改变人们的思维方式。只有通过这种思维方式的改变，你才能重构应用程序以及底层基础设施，释放容器的价值并享受它们的真正好处。正是这个**第二个原因**，容器技术才在最近几年开始崛起，而不是十年前。
- en: The Need for Container Orchestration
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器编排的需求
- en: 'The `k8s-for-beginners` container we built in *Exercise 1.01*, *Creating a
    Docker Image and Uploading it to Docker Hub*, is nothing but a simple demonstration.
    In the case of a serious workload deployed in a production environment, and to
    enable hundreds of thousands of containers running in a cluster, we have many
    more things to consider. We need a system to manage the following problems:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*练习1.01*中构建的`k8s-for-beginners`容器只是一个简单的演示。在生产环境中部署严重工作负载，并在集群中运行数十万个容器时，我们需要考虑更多的事情。我们需要一个系统来解决以下问题：
- en: Container Interactions
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器交互
- en: As an example, suppose that we are going to build a web app with a frontend
    container displaying information and accepting user requests, and a backend container
    serving as a datastore that interacts with the frontend container. The first challenge
    is to figure out how to specify the address of the backend container to the frontend
    container. It is not a good idea to hardcode the IP, as the container IP is not
    static. In a distributed system, it is not uncommon for containers or machines
    to fail due to unexpected issues. So, the link between any two containers must
    be discoverable and effective across all the machines. On the other hand, the
    second challenge is that we may want to limit which containers (for example, the
    backend container) can be visited by which kind of containers (for example, its
    corresponding frontend ones).
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们要构建一个 Web 应用程序，其中前端容器显示信息并接受用户请求，后端容器作为与前端容器交互的数据存储。第一个挑战是如何指定后端容器的地址给前端容器。硬编码
    IP 并不是一个好主意，因为容器 IP 不是静态的。在分布式系统中，由于意外问题，容器或机器可能会失败。因此，任何两个容器之间的链接必须是可发现的，并且在所有机器上都是有效的。另一方面，第二个挑战是我们可能希望限制哪些容器（例如后端容器）可以被哪种类型的容器（例如其对应的前端容器）访问。
- en: Network and Storage
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络和存储
- en: All the examples that we gave in the previous sections used containers running
    on the same machine. This is pretty straightforward, as the underlying Linux namespaces
    and cgroup technologies were designed to work within the same OS entity. If we
    want to run thousands of containers in a production environment, which is pretty
    common, we have to resolve the network connectivity issue to ensure that different
    containers across different machines are able to connect with each other. On the
    other hand, local or temporary on-disk storage doesn't always work for all workloads.
    Applications may need the data to be stored remotely and be available to be mounted
    at will to any machine in the cluster the container is run on, no matter if the
    container is starting up for the first time or restarting after a failure.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们给出的所有示例都是在同一台机器上运行的容器。这相当简单，因为底层的Linux命名空间和cgroup技术是设计为在同一操作系统实体内工作的。如果我们想在生产环境中运行数千个容器，这是非常常见的，我们必须解决网络连接问题，以确保不同机器上的不同容器能够相互连接。另一方面，本地或临时的磁盘存储并不总是适用于所有工作负载。应用程序可能需要将数据存储在远程位置，并且可以随时挂载到集群中任何一台机器上，无论容器是第一次启动还是在故障后重新启动。
- en: Resource Management and Scheduling
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源管理和调度
- en: We have seen that a container leverages Linux cgroups to manage its resource
    usage. To be a modern resource manager, it needs to build an easy-to-use resource
    model to abstract resources such as CPU, RAM, disk, and GPU. We need to manage
    a number of containers efficiently, and to provision and free up resources in
    time so as to achieve high cluster utilization.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，容器利用Linux cgroups来管理其资源使用情况。要成为现代资源管理器，它需要构建一个易于使用的资源模型，以抽象资源，如CPU、RAM、磁盘和GPU。我们需要有效地管理多个容器，并及时分配和释放资源，以实现高集群利用率。
- en: Scheduling involves assigning an appropriate machine in the cluster for each
    of our workloads to run on. We will take a closer look at scheduling as we proceed
    further in this book. To ensure that each container has the best machine to run,
    the scheduler (a Kubernetes component that takes care of scheduling) needs to
    have a global view of the distribution of all containers across the different
    machines in the cluster. Additionally, in large data centers, the containers would
    need to be distributed based on the physical locations of the machines or the
    availability zones of the cloud services. For example, if all containers supporting
    a service are allocated to the same physical machine, and that machine happens
    to fail, the service will experience a period of outage regardless of how many
    replicas of the containers you had deployed.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 调度涉及为集群中的每个工作负载分配适当的机器来运行。随着我们在本书中继续深入研究，我们将更仔细地研究调度。为了确保每个容器都有最佳的机器来运行，调度器（负责调度的Kubernetes组件）需要全局查看集群中不同机器上所有容器的分布情况。此外，在大型数据中心中，容器需要根据机器的物理位置或云服务的可用区进行分布。例如，如果支持某项服务的所有容器都分配给同一台物理机，而该机器发生故障，无论您部署了多少个容器的副本，该服务都将经历一段宕机期。
- en: Failover and Recovery
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障转移和恢复
- en: Application or machine errors are quite common in a distributed system. Therefore,
    we must consider container and machine failures. When containers encounter fatal
    errors and exit, they should be able to be restarted on the same or another suitable
    machine that is available. We should be able to detect machine faults or network
    partitions so as to reschedule the containers from problematic machines to healthy
    ones. Moreover, the reconciliation process should be autonomous, to make sure
    the application is always running in its desired state.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，应用程序或机器错误是相当常见的。因此，我们必须考虑容器和机器故障。当容器遇到致命错误并退出时，它们应该能够在同一台或另一台可用的机器上重新启动。我们应该能够检测机器故障或网络分区，以便将容器从有问题的机器重新调度到健康的机器上。此外，协调过程应该是自主的，以确保应用程序始终以其期望的状态运行。
- en: Scalability
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展性
- en: As demand increases, you may want to scale up an application. Take a web frontend
    application as an example. We may need to run several replicas of it and use a
    load balancer to distribute the incoming traffic evenly among the many replicas
    of containers supporting the service. To walk one step further, depending on the
    volume of incoming requests, you may want the application to be scaled dynamically,
    either horizontally (by having more or fewer replicas), or vertically (by allocating
    more or fewer resources). This takes the difficulty of system design to another
    level.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 随着需求的增加，您可能希望扩展应用程序。以Web前端应用程序为例。我们可能需要运行多个副本，并使用负载均衡器将传入的流量均匀分配到支持服务的容器的多个副本中。更进一步，根据传入请求的数量，您可能希望应用程序动态扩展，无论是水平扩展（增加或减少副本）还是垂直扩展（分配更多或更少的资源）。这使得系统设计的难度提升到了另一个层次。
- en: Service Exposure
  id: totrans-505
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务暴露
- en: 'Suppose we''ve tackled all the challenges mentioned previously; that''s to
    say, all things are working great within the cluster. Well, here comes another
    challenge: how can the applications be accessed externally? On one hand, the external
    endpoint needs to be associated with the underlying on-premises or cloud environment
    so that it can leverage the infrastructure''s API to make itself always accessible.
    On the other hand, to keep the internal network traffic always going through,
    the external endpoint needs to be associated with internal backing replicas dynamically
    – any unhealthy replicas need to be taken out and backfilled automatically to
    ensure that the application remains online. Moreover, L4 (TCP/UDP) and L7 (HTTP,
    HTTPS) traffic has different characteristics in terms of packets, and, therefore,
    needs to be treated in slightly different ways to ensure efficiency. For example,
    the HTTP header information can be used to reuse the same public IP to serve multiple
    backend applications.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经解决了之前提到的所有挑战；也就是说，在集群内一切都运行良好。好吧，又来了另一个挑战：应用程序如何可以被外部访问？一方面，外部端点需要与基础的本地或云环境相关联，以便利用基础设施的API使其始终可访问。另一方面，为了保持内部网络流量始终通过，外部端点需要动态关联内部备份副本
    - 任何不健康的副本都需要被自动取出并自动填充，以确保应用程序保持在线。此外，L4（TCP/UDP）和L7（HTTP，HTTPS）流量在数据包方面具有不同的特征，因此需要以稍微不同的方式处理以确保效率。例如，HTTP头信息可以用于重用相同的公共IP来为多个后端应用程序提供服务。
- en: Delivery Pipeline
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交付管道
- en: From a system administrator's point of view, a healthy cluster must be monitorable,
    operable, and autonomous in responding to failures. This requires the applications
    deployed on to the cluster to follow a standardized and configurable delivery
    pipeline so that it can be managed well at different phases, as well as in different environments.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 从系统管理员的角度来看，一个健康的集群必须是可监控的、可操作的，并且能够自主应对故障。这要求部署在集群上的应用程序遵循标准化和可配置的交付流程，以便在不同阶段和不同环境中进行良好的管理。
- en: An individual container is typically used only for completing a single functionality,
    which is not enough. We need to provide several building blocks to connect the
    containers all together to accomplish a complicated task.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的容器通常只用于完成单一功能，这是不够的。我们需要提供几个构建块来将所有容器连接在一起，以完成复杂的任务。
- en: 'Orchestrator: Putting All the Things Together'
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编排器：将所有事物整合在一起
- en: We don't mean to overwhelm you, but the aforementioned problems are very serious,
    and they arise as a result of the large number of containers that need to be automatically
    managed. Compared to the VM era, containers do open another door for application
    management in a large, distributed cluster. However, this also takes container
    and cluster management challenges to another level. In order to connect the containers
    to each other to accomplish the desired functionality in a scalable, high-performant,
    and self-recovering manner, we need a well-designed container orchestrator. Otherwise,
    we would not be able to migrate our applications from VMs to containers. It's
    the **third reason** why containerization technologies began to be adopted on
    a large scale in recent years, particularly upon the emergence of Kubernetes –
    which is the de facto container orchestrator nowadays.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不是要压倒你，但上述问题非常严重，这是由于需要自动管理大量容器而产生的。与虚拟机时代相比，容器在大型分布式集群中为应用程序管理打开了另一扇门。然而，这也将容器和集群管理的挑战提升到了另一个层面。为了将容器连接在一起，以以可扩展、高性能和自我恢复的方式实现所需的功能，我们需要一个设计良好的容器编排器。否则，我们将无法将我们的应用程序从虚拟机迁移到容器中。这是**第三个原因**，为什么近年来容器化技术开始大规模采用，特别是在Kubernetes出现后
    - 它现在是事实上的容器编排器。
- en: Welcome to the Kubernetes World
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欢迎来到Kubernetes世界
- en: Unlike typical software that usually evolves piece by piece, Kubernetes got
    a kick-start as it was designed based on years of experience on Google's internal
    large-scale cluster management software such as Borg and Omega. That's to say,
    Kubernetes was born equipped with lots of best practices in the container orchestration
    and management field. Since day one, the team behind it understood the real pain
    points and came up with proper designs for tackling them. Concepts such as pods,
    one IP per pod, declarative APIs, and controller patterns, among others that were
    first introduced by Kubernetes, seemed to be a bit "impracticable", and some people
    at that time might have questioned their real value. However, 5 years later, those
    design rationales remain unchanged and have proven to be the key differentiators
    from other software.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 与通常逐步发展的典型软件不同，Kubernetes是一个快速启动的项目，因为它是基于谷歌内部大规模集群管理软件（如Borg和Omega）多年经验的设计而来。也就是说，Kubernetes诞生时就装备了容器编排和管理领域的许多最佳实践。从一开始，团队就理解了真正的痛点，并提出了适当的设计来解决这些问题。像Pod、每个Pod一个IP、声明式API和控制器模式等概念，都是Kubernetes首次引入的，似乎有点“不切实际”，当时可能有人质疑它们的真正价值。然而，5年后，这些设计原理仍然保持不变，并已被证明是与其他软件的关键区别。
- en: 'Kubernetes resolves all the challenges mentioned in the previous section. Some
    of the well-known features that Kubernetes provides are:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes解决了前一节提到的所有挑战。Kubernetes提供的一些众所周知的功能包括：
- en: '**Native support for application life cycle management**'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地支持应用程序生命周期管理**'
- en: This includes built-in support for application replicating, autoscaling, rollout,
    and rollback. You can describe the desired state of your application (for example,
    how many replicas, which image version, and so on), and Kubernetes will automatically
    reconcile the real state to meet its desired state. Moreover, when it comes to
    rollout and rollback, Kubernetes ensures that the old replicas are replaced by
    new ones gradually to avoid downtime of the application.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括对应用程序复制、自动缩放、部署和回滚的内置支持。您可以描述应用程序的期望状态（例如，多少个副本，哪个镜像版本等），Kubernetes将自动协调实际状态以满足其期望状态。此外，在部署和回滚方面，Kubernetes确保旧副本逐渐被新副本替换，以避免应用程序的停机时间。
- en: '**Built-in health-checking support**'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置健康检查支持**'
- en: By implementing some "health check" hooks, you can define when the containers
    can be viewed as ready, alive, or failed. Kubernetes will only start directing
    traffic to a container when it's healthy as well as ready. It will also restart
    the unhealthy containers automatically.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现一些“健康检查”钩子，您可以定义容器何时被视为就绪、存活或失败。只有当容器健康且就绪时，Kubernetes才会开始将流量引导到容器，并且会自动重新启动不健康的容器。
- en: '**Service discovery and load balancing**'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现和负载均衡**'
- en: Kubernetes provides internal load balancing between different replicas of a
    workload. Since containers can fail occasionally, Kubernetes doesn't use an IP
    for direct access. Instead, it uses an internal DNS and exposes each service with
    a DNS record for communication within a cluster.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes在工作负载的不同副本之间提供内部负载均衡。由于容器偶尔会失败，Kubernetes不使用IP进行直接访问。相反，它使用内部DNS，并为集群内的通信为每个服务公开一个DNS记录。
- en: '**Configuration management**'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置管理**'
- en: Kubernetes uses labels to describe the machines and workloads. They're respected
    by Kubernetes' components to manage containers and dependencies in a loosely coupled
    and flexible fashion. Moreover, the simple but powerful labels can be used to
    achieve advanced scheduling features (for example, taint/toleration and affinity/anti-affinity).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用标签来描述机器和工作负载。它们受Kubernetes组件的尊重，以松散耦合和灵活的方式管理容器和依赖关系。此外，简单但强大的标签可以用于实现高级调度功能（例如，污点/容忍和亲和性/反亲和性）。
- en: In terms of security, Kubernetes provides the Secret API to allow you to store
    and manage sensitive information. This can help application developers to associate
    the credentials with your applications securely. From a system administrator's
    point of view, Kubernetes also provides varied options for managing authentication
    and authorization.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全方面，Kubernetes提供了Secret API，允许您存储和管理敏感信息。这可以帮助应用程序开发人员安全地将凭据与应用程序关联起来。从系统管理员的角度来看，Kubernetes还提供了各种选项来管理身份验证和授权。
- en: Moreover, some options such as ConfigMaps aim to provide fine-grained mechanics
    to build a flexible application delivery pipeline.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些选项，如ConfigMaps，旨在提供精细的机制来构建灵活的应用交付流水线。
- en: '**Network and storage abstraction**'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络和存储抽象**'
- en: Kubernetes initiates the standards to abstract the network and storage specifications,
    which are known as the CNI (Container Network Interface) and CSI (Container Storage
    Interface). Each network and storage provider follows the interface and provides
    its implementation. This mechanism decouples the interface between Kubernetes
    and heterogeneous providers. With that, end users can use standard Kubernetes
    APIs to orchestrate their workloads in a portable manner.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes启动了抽象网络和存储规范的标准，即CNI（容器网络接口）和CSI（容器存储接口）。每个网络和存储提供商都遵循接口并提供其实现。这种机制解耦了Kubernetes和异构提供商之间的接口。有了这个，最终用户可以使用标准的Kubernetes
    API以可移植的方式编排其工作负载。
- en: 'Under the hood, there are some key concepts supporting the previously mentioned
    features, and, more critically, Kubernetes provides different extension mechanics
    for end-users to build customized clusters or even their own platform:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在引擎盖下，有一些支持前面提到的功能的关键概念，更为关键的是，Kubernetes为最终用户提供了不同的扩展机制，以构建定制的集群甚至他们自己的平台：
- en: '**The Declarative API**'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式API**'
- en: The Declarative API is a way to describe what you want to be done. Under this
    contract, we just specify the desired final state rather than describing the steps
    to get there.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式API是描述您想要完成的方式。在这个约定下，我们只需指定期望的最终状态，而不是描述到达那里的步骤。
- en: The declarative model is widely used in Kubernetes. It not only enables Kubernetes'
    core features to function in a fault-tolerant way but also serves as a golden
    rule to build Kubernetes extension solutions.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式模型在Kubernetes中被广泛使用。它不仅使Kubernetes的核心功能能够以容错的方式运行，而且还作为构建Kubernetes扩展解决方案的黄金法则。
- en: '**Concise Kubernetes core**'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁的Kubernetes核心**'
- en: It is common for a software project to grow bigger over time, especially for
    famous open source software such as Kubernetes. More and more companies are getting
    involved in the development of Kubernetes. But fortunately, since day one, the
    forerunners of Kubernetes set some baselines to keep Kubernetes' core neat and
    concise. For example, instead of binding to a particular container runtime (for
    example, Docker or Containerd), Kubernetes defines an interface (**CRI** or the
    **container runtime interface**) to be technology-agnostic so that users can choose
    which runtime to use. Also, by defining the **CNI** (**Container Network Interface**),
    it delegates the pod and host's network routing implementation to different projects
    such as Calico and Weave Net. In this way, Kubernetes is able to keep its core
    manageable, and also encourage more vendors to join, so the end-users can have
    more choices to avoid vendor lock-ins.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 软件项目随着时间的推移往往会变得越来越庞大，尤其是像Kubernetes这样著名的开源软件。越来越多的公司参与了Kubernetes的开发。但幸运的是，自从第一天起，Kubernetes的先驱者们就设定了一些基线，以保持Kubernetes的核心简洁整洁。例如，Kubernetes并没有绑定到特定的容器运行时（例如Docker或Containerd），而是定义了一个接口（**CRI**或**容器运行时接口**）以保持技术的中立性，使用户可以选择使用哪种运行时。此外，通过定义**CNI**（**容器网络接口**），它将pod和主机的网络路由实现委托给不同的项目，如Calico和Weave
    Net。这样，Kubernetes能够保持其核心的可管理性，并鼓励更多的供应商加入，以便最终用户可以有更多的选择，避免供应商锁定。
- en: '**Configurable, pluggable, and extensible design**'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可配置、可插拔和可扩展的设计**'
- en: All Kubernetes' components provide configuration files and flags for users to
    customize the functionalities. And each core component is implemented strictly
    to adhere to the public Kubernetes API; for advanced users, you can choose to
    implement a part of or the entire component yourself to fulfill a special requirement,
    as long as it is subject to the API. Moreover, Kubernetes provides a series of
    extension points to extend Kubernetes' features, as well as building your platform.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Kubernetes组件都提供配置文件和标志，供用户自定义功能。每个核心组件都严格实现以符合公共Kubernetes API；对于高级用户，您可以选择自己实现部分或整个组件，以满足特殊需求，只要它符合API。此外，Kubernetes提供了一系列扩展点来扩展Kubernetes的功能，以及构建您的平台。
- en: In the course of this book, we will walk you through the high-level Kubernetes
    architecture, its core concepts, best practices, and examples to help you master
    the essentials of Kubernetes, so that you can build your applications on Kubernetes,
    and also extend Kubernetes to accomplish complex requirements.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的过程中，我们将带您了解高级别的Kubernetes架构、其核心概念、最佳实践和示例，以帮助您掌握Kubernetes的基本知识，这样您就可以在Kubernetes上构建您的应用程序，并扩展Kubernetes以满足复杂的需求。
- en: 'Activity 1.01: Creating a Simple Page Count Application'
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1.01：创建一个简单的页面计数应用程序
- en: In this activity, we will create a simple web application that counts the number
    of visitors. We will containerize this application, push it to a Docker image
    registry, and then run the containerized application.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将创建一个简单的网络应用程序，用于统计访问者的数量。我们将把这个应用程序放入容器中，将其推送到Docker镜像注册表，然后运行容器化的应用程序。
- en: '**A PageView Web App**'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**页面浏览网络应用**'
- en: 'We will first build a simple web application to show the pageviews of a particular
    web page:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先构建一个简单的网络应用程序，用于显示特定网页的页面浏览量：
- en: 'Use your favorite programming language to write an HTTP server to listen on
    port `8080` at the root path (`/`). Once it receives a request, it adds `1` to
    its internal variable and responds with the message `Hello, you''re visitor #i`,
    where `i` is the accumulated number. You should be able to run this application
    on your local development environment.'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用您喜欢的编程语言编写一个HTTP服务器，监听端口`8080`，在根路径(`/`)。一旦收到请求，它会将`1`添加到其内部变量，并以消息`Hello,
    you''re visitor #i`做出响应，其中`i`是累积数字。您应该能够在本地开发环境中运行此应用程序。'
- en: Note
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In case you need help with the code, we have provided a sample piece of code
    written in Go, which is also used for the solution to this activity. You can get
    this from the following link: [https://packt.live/2DcCQUH](https://packt.live/2DcCQUH).'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要代码帮助，我们提供了一个用Go编写的示例代码片段，也用于解决这个活动的问题。您可以从以下链接获取：[https://packt.live/2DcCQUH](https://packt.live/2DcCQUH)。
- en: Compose a `Dockerfile` to build the HTTP server and package it along with its
    dependencies into a Docker image. Set the startup command in the last line to
    run the HTTP server.
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`Dockerfile`来构建HTTP服务器，并将其与其依赖项打包到Docker镜像中。在最后一行设置启动命令以运行HTTP服务器。
- en: Build the `Dockerfile` and push the image to a public Docker images registry
    (for example, [https://hub.docker.com/](https://hub.docker.com/)).
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`Dockerfile`并将镜像推送到公共Docker镜像注册表（例如，[https://hub.docker.com/](https://hub.docker.com/)）。
- en: Test your Docker images by launching a Docker container. You should use either
    Docker port mapping or an internal container IP to access the HTTP server.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过启动Docker容器来测试您的Docker镜像。您应该使用Docker端口映射或内部容器IP来访问HTTP服务器。
- en: 'You can test whether your application is working by repeatedly accessing it
    using the `curl` command as follows:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过重复使用`curl`命令来访问它，以测试您的应用程序是否正常工作。
- en: '[PRE105]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '**Bonus Objective**'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '**奖励目标**'
- en: Until now, we have implemented the basics of Docker that we have learned in
    this chapter. However, we can demonstrate the need to link different containers
    by extending this activity.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了本章学到的Docker的基础知识。然而，我们可以通过扩展这个活动来演示连接不同容器的需求。
- en: For an application, usually, we need multiple containers to focus on different
    functionalities and then connect them together as a fully functional application.
    Later on, in this book, you will learn how to do this using Kubernetes; however,
    for now, let's connect the containers directly.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个应用程序，通常我们需要多个容器来专注于不同的功能，然后将它们连接在一起作为一个完全功能的应用程序。在本书的后面，您将学习如何使用Kubernetes来做到这一点；然而，现在让我们直接连接容器。
- en: We can enhance this application by attaching a backend datastore to it. This
    will allow it to persist its state even after the container is terminated, that
    is, it will retain the number of visitors. If the container is restarted, it will
    continue the count instead of resetting it. Here are some guidelines for building
    on top of the application that you have built so far.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过附加后端数据存储来增强此应用程序。这将使其能够在容器终止后保持其状态，即保留访问者数量。如果容器重新启动，它将继续计数，而不是重置计数。以下是构建到目前为止构建的应用程序的一些建议。
- en: '**A Backend Datastore**'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 一个后端数据存储
- en: 'We may lose the pageview number when the container dies, so we need to persist
    it into a backend datastore:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器终止时，我们可能会丢失页面浏览次数，因此我们需要将其持久化到后端数据存储中：
- en: 'Run one of the three well-known datastores: Redis, MySQL, or MongoDB within
    a container.'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器中运行三种知名的数据存储之一：Redis、MySQL或MongoDB。
- en: Note
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).
    We have implemented Redis for our datastore.'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在以下地址找到：[https://packt.live/304PEoD](https://packt.live/304PEoD)。我们已经为我们的数据存储实现了Redis。
- en: 'You can find more details about the usage of the Redis container at this link:
    [https://hub.docker.com/_/redis](https://hub.docker.com/_/redis).'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此链接找到有关Redis容器用法的更多详细信息：[https://hub.docker.com/_/redis](https://hub.docker.com/_/redis)。
- en: 'If you wish to use MySQL, you can find details about its usage at this link:
    [https://hub.docker.com/_/mysql](https://hub.docker.com/_/mysql).'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望使用MySQL，您可以在此链接找到有关其用法的详细信息：[https://hub.docker.com/_/mysql](https://hub.docker.com/_/mysql)。
- en: 'If you wish to use MongoDB, you can find details about its usage at this link:
    [https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo).'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望使用MongoDB，您可以在此链接找到有关其用法的详细信息：[https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)。
- en: 'You may need to run the container using the `--name db` flag to make it discoverable.
    If you are using Redis, the command should look like this:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能需要使用`--name db`标志运行容器以使其可发现。如果您使用Redis，则命令应如下所示：
- en: '[PRE106]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '**Modifying the Web App to Connect to a Backend Datastore**'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 修改Web应用程序以连接到后端数据存储
- en: 'Every time a request comes in, you should modify the logic to read the pageview
    number from the backend, then add `1` to its internal variable, and respond with
    a message of `Hello, you''re visitor #i`, where `i` is the accumulated number.
    At the same time, store the added pageview number in the datastore. You may need
    to use the datastore''s specific SDK **Software Development Kit** (**SDK**) to
    connect to the datastore. You can put the connection URL as `db:<db port>` for
    now.'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '每当有请求时，您应该修改逻辑以从后端读取页面浏览次数，然后将`1`添加到其内部变量，并响应消息`Hello, you''re visitor #i`，其中`i`是累积数字。同时，将添加的页面浏览次数存储在数据存储中。您可能需要使用数据存储的特定SDK（软件开发工具包）来连接到数据存储。您现在可以将连接URL设置为`db:<db端口>`。'
- en: Note
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may use the source code from the following link: [https://packt.live/3lBwOhJ](https://packt.live/3lBwOhJ).'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下链接的源代码：[https://packt.live/3lBwOhJ](https://packt.live/3lBwOhJ)。
- en: If you are using the code from this link, ensure that you modify it to map to
    the exposed port on your datastore.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用此链接中的代码，请确保将其修改为映射到数据存储的公开端口。
- en: Rebuild the web app with a new image version.
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的镜像版本重建网络应用程序。
- en: Run the web app container using the `--link db:db` flag.
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`--link db:db`标志运行网络应用程序容器。
- en: Verify that the pageview number is returned properly.
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证页面浏览次数是否正确返回。
- en: Kill the web app container and restart it to see whether the pageview number
    gets restored properly.
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终止网络应用程序容器并重新启动，以查看页面浏览次数是否恢复正常。
- en: 'Once you have created the application successfully, test it by accessing it
    repeatedly. You should see it working as follows:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序成功后，通过重复访问来测试它。您应该看到它的工作如下：
- en: '[PRE107]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Then, kill the container and restart it. Now, try accessing it. The state of
    the application should be persisted, that is, the count must continue from where
    it was before you restarted the container. You should see a result as follows:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，终止容器并重新启动。现在，尝试访问它。应用程序的状态应该被保留，也就是说，计数必须从您重新启动容器之前的位置继续。您应该看到以下结果：
- en: '[PRE108]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Note
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在以下地址找到：[https://packt.live/304PEoD](https://packt.live/304PEoD)。
- en: Summary
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we walked you through a brief history of software development
    and explained some of the challenges in the VM era. With the emergence of Docker,
    containerization technologies open a new gate in terms of resolving the problems
    that existed with earlier methods of software development.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了软件开发的简要历史，并解释了VM时代的一些挑战。随着Docker的出现，容器化技术在解决早期软件开发方法存在的问题方面开辟了新的大门。
- en: We walked you through the basics of Docker and detailed the underlying features
    of Linux such as namespaces and cgroups, which enable containerization. We then
    brought up the concept of container orchestration and illustrated the problems
    it aims to solve. Finally, we gave a very brief overview of some of the key features
    and methodologies of Kubernetes.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向您介绍了Docker的基础知识，并详细介绍了Linux的基本特性，如命名空间和cgroups，这些特性实现了容器化。然后，我们提出了容器编排的概念，并阐明了它旨在解决的问题。最后，我们对Kubernetes的一些关键特性和方法进行了非常简要的概述。
- en: In the next chapter, we will dive a little deeper and take a look at Kubernetes'
    architecture to understand how it works.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解Kubernetes的架构，以了解其工作原理。
