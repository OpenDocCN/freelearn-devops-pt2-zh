- en: 19\. Custom Resource Definitions in Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19. Kubernetes中的自定义资源定义
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will show how you can use **Custom Resource Definitions**
    (**CRDs**) to extend Kubernetes and add new functionality to your Kubernetes cluster.
    You will also learn how to define, configure, and implement a complete CRD. We
    will also describe various example scenarios where CRDs can be very helpful. By
    the end of this chapter, you will be able to define and configure a CRD and a
    **Custom Resource** (**CR**). You will also learn how to deploy a basic custom
    controller to implement the required functionality of the CR in your cluster.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示如何使用**自定义资源定义**（**CRDs**）来扩展Kubernetes并向您的Kubernetes集群添加新功能。您还将学习如何定义、配置和实现完整的CRD。我们还将描述各种示例场景，其中CRDs可以非常有帮助。在本章结束时，您将能够定义和配置CRD和**自定义资源**（**CR**）。您还将学习如何部署一个基本的自定义控制器来实现集群中CR所需的功能。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In previous chapters, we learned about different Kubernetes objects, such as
    Pods, Deployments, and ConfigMaps. These objects are defined and managed by the
    Kubernetes API (that is, for these objects, the API server manages their creation
    and destruction, among other operations). However, you may want to extend the
    functions provided by Kubernetes to provide a feature that is not shipped with
    standard Kubernetes, and that cannot be enabled by the built-in objects provided
    by Kubernetes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了不同的Kubernetes对象，比如Pods、Deployments和ConfigMaps。这些对象是由Kubernetes
    API定义和管理的（也就是说，对于这些对象，API服务器管理它们的创建和销毁，以及其他操作）。然而，您可能希望扩展Kubernetes提供的功能，以提供一个标准Kubernetes中没有的功能，并且不能通过Kubernetes提供的内置对象来启用。
- en: To build these functionalities on top of Kubernetes, we use **Custom Resources**
    (**CRs**). **Custom Resource Definitions** (**CRDs**) allow us to add a capability
    through which users can add custom objects to the Kubernetes server and use those
    CRs like any other native Kubernetes object. A CRD helps us to introduce our custom
    objects to the Kubernetes system. Once our CRD is created, it can be used like
    any other object in the Kubernetes server. Not only that, but we can also use
    the Kubernetes API, **Role-Based Access Control** (**RBAC**) policies, and other
    Kubernetes features for the CRs we have introduced.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Kubernetes之上构建这些功能，我们使用**自定义资源**（**CRs**）。**自定义资源定义**（**CRDs**）允许我们通过这种方式向Kubernetes服务器添加自定义对象，并像任何其他本机Kubernetes对象一样使用这些CRs。CRD帮助我们将我们的自定义对象引入Kubernetes系统。一旦我们的CRD被创建，它就可以像Kubernetes服务器中的任何其他对象一样使用。不仅如此，我们还可以使用Kubernetes
    API、**基于角色的访问控制**（**RBAC**）策略和其他Kubernetes功能来管理我们引入的CRs。
- en: When you define a CRD, it is stored in the Kubernetes configuration database
    (etcd). Think of CRDs as the definition of the structure of your custom object.
    Once a CRD is defined, Kubernetes creates objects that abide by the definition
    of the CRD. We call these objects CRs. If we were to compare this to the analogy
    of programming languages, CRD is the class and the CR is the instance of the class.
    In short, a CRD defines the schema of a custom object and a CR defines the desired
    state of an object that you would like to achieve.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义一个CRD时，它会存储在Kubernetes配置数据库（etcd）中。将CRD视为自定义对象结构的定义。一旦定义了CRD，Kubernetes就会创建符合CRD定义的对象。我们称这些对象为CRs。如果我们将其比作编程语言的类比，CRD就是类，CR就是类的实例。简而言之，CRD定义了自定义对象的模式，CR定义了您希望实现的对象的期望状态。
- en: CRs are implemented via a custom controller. We will take a closer look at custom
    controllers in the first topic of this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: CRs是通过自定义控制器实现的。我们将在本章的第一个主题中更详细地了解自定义控制器。
- en: What Is a Custom Controller?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是自定义控制器？
- en: CRDs and CRs help you define the desired state for your CRs. There is a need
    for a component that makes sure that the state of the Kubernetes system matches
    the desired state as defined by the CR. As you have seen in earlier chapters,
    the Kubernetes components that do this are called controllers. Kubernetes comes
    up with many of these controllers whose job is to make sure that the desired state
    (for example, the number of replicas of Pods defined in a Deployment) is equal
    to the value defined in the Deployment object. In summary, a controller is a component
    that watches the state of resources through the Kubernetes API server and attempts
    to match the current state with the desired state.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: CRD和CR可帮助您定义CR的期望状态。需要一个组件来确保Kubernetes系统的状态与CR定义的期望状态相匹配。正如您在前几章中所看到的，执行此操作的Kubernetes组件称为控制器。Kubernetes提供了许多这些控制器，它们的工作是确保期望状态（例如，在部署中定义的Pod副本数）等于部署对象中定义的值。总之，控制器是一个通过Kubernetes
    API服务器监视资源状态并尝试将当前状态与期望状态匹配的组件。
- en: The built-in controllers that are included in a standard setup of Kubernetes
    are meant to work with built-in objects such as Deployments. For our CRDs and
    their CRs, we need to write our own custom controllers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 标准Kubernetes设置中包含的内置控制器旨在与内置对象（如部署）一起使用。对于我们的CRD及其CR，我们需要编写自己的自定义控制器。
- en: The Relationship between a CRD, a CR, and a Controller
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRD、CR和控制器之间的关系
- en: 'The CRD provides a way to define a CR, and custom controllers provide the logic
    to act on the CR objects. The following diagram summarizes the CRD, CR, and controller:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: CRD提供了定义CR的方法，自定义控制器提供了对CR对象进行操作的逻辑。以下图表总结了CRD、CR和控制器：
- en: '![Figure 19.1: How CRD, CR, and controllers are tied together'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.1：CRD、CR和控制器如何相互关联'
- en: '](image/B14870_19_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_19_01.jpg)'
- en: 'Figure 19.1: How CRD, CR, and controllers are tied together'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.1：CRD、CR和控制器如何相互关联
- en: 'As illustrated in the preceding diagram, we have a CRD, a custom controller,
    and the CR object that defines the desired state as per the CRD. There are three
    things to note here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们有一个CRD、一个自定义控制器和根据CRD定义期望状态的CR对象。这里有三件事需要注意：
- en: The CRD is the schema that defines how the object will look. Every resource
    has a defined schema that tells the Kubernetes engine what to expect in a definition.
    Core objects such as `PodSpec` have schemas that are baked into the Kubernetes
    project.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CRD是定义对象外观的模式。每个资源都有一个定义的模式，告诉Kubernetes引擎在定义中期望什么。诸如`PodSpec`之类的核心对象具有内置到Kubernetes项目中的模式。
- en: Note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the source code for PodSpec at this link: [https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/types.go#L2627](https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/types.go#L2627
    )'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此链接找到PodSpec的源代码：[https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/types.go#L2627](https://github.com/kubernetes/kubernetes/blob/master/pkg/apis/core/types.go#L2627)
- en: The CR object, which is created based on the schema (the CRD), defines the desired
    state of the resource.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于模式（CRD）创建的CR对象定义了资源的期望状态。
- en: The custom controller is the application that provides the functionality to
    bring the current state to the desired state.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义控制器是提供功能的应用程序，将当前状态带到期望的状态。
- en: Remember, the CRD is a way through which Kubernetes allows us to define the
    schema or definition for our CRs declaratively. Once our CRD (the schema) is registered
    with the Kubernetes server, a CR (the object) is defined as per our CRD.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，CRD是Kubernetes允许我们声明性地定义CR的模式或定义的一种方式。一旦我们的CRD（模式）在Kubernetes服务器上注册，CR（对象）将根据我们的CRD进行定义。
- en: Standard Kubernetes API Resources
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准Kubernetes API资源
- en: Let's list all the resources and APIs that are available in the Kubernetes cluster.
    Recall that everything we have used is defined as an API resource, and an API
    is a gateway through which we communicate with the Kubernetes server to work with
    that resource.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出Kubernetes集群中所有可用的资源和API。请记住，我们使用的所有内容都被定义为API资源，而API是我们与Kubernetes服务器通信以处理该资源的网关。
- en: 'Get a list of all the current Kubernetes resources by using the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令获取当前Kubernetes资源的列表：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should see the following response:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 19.2: Standard Kubernetes API resources'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.2：标准Kubernetes API资源'
- en: '](image/B14870_19_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_19_02.jpg)'
- en: 'Figure 19.2: Standard Kubernetes API resources'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.2：标准Kubernetes API资源
- en: In the preceding screenshot, you can see that the resources defined in Kubernetes
    have an `APIGroup` property, which defines what internal API is responsible for
    managing this resource. The `Kind` column lists the name of the resources. As
    we have seen earlier in this topic, for standard Kubernetes objects such as Pods,
    the schema or definition of a Pod object is built into Kubernetes. When you define
    a Pod specification to run a Pod, this could be said to be analogous to a CR.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，您可以看到Kubernetes中定义的资源具有`APIGroup`属性，该属性定义了负责管理此资源的内部API。`Kind`列出了资源的名称。正如我们在本主题中之前所看到的，对于标准的Kubernetes对象，比如Pods，Pod对象的模式或定义内置在Kubernetes中。当您定义一个Pod规范来运行一个Pod时，这可以说类似于CR。
- en: 'For every resource, there is some code that can take action against the resource.
    This is defined as a group of APIs (`APIGroup`). Note that multiple API groups
    can exist; for example, a stable version and an experimental version. Issue the
    following command to see what API versions are available in your Kubernetes cluster:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个资源，都有一些可以针对该资源采取行动的代码。这被定义为一组API（`APIGroup`）。请注意，可以存在多个API组；例如，一个稳定版本和一个实验版本。发出以下命令以查看您的Kubernetes集群中有哪些API版本可用：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You should see the following response:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 19.3: Various API groups and their versions'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.3：各种API组及其版本'
- en: '](image/B14870_19_03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_19_03.jpg)'
- en: 'Figure 19.3: Various API groups and their versions'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.3：各种API组及其版本
- en: In the preceding screenshot, note that the `apps` API group has multiple versions
    available. Each of these versions may have a different set of features that is
    not available in other groups.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，请注意`apps` API组有多个可用版本。每个版本可能具有其他组中不可用的不同功能集。
- en: Why We Need Custom Resources?
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我们需要自定义资源？
- en: As stated earlier, CRs provide a way through which we can extend the Kubernetes
    platform to provide functionalities that are specific to certain use cases. Here
    are a few use cases where you will encounter the use of CRs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，CR提供了一种方式，通过这种方式我们可以扩展Kubernetes平台，以提供特定于某些用例的功能。以下是一些您将遇到CR使用的用例。
- en: Example Use Case 1
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例用例1
- en: Consider a use case in which you want to automate the provisioning of a business
    application or a database onto the Kubernetes cluster automatically. Abstracting
    away the technical details, such as configuring and deploying the application,
    allows teams to manage them without having an in-depth knowledge of Kubernetes.
    For example, you can create a CR to abstract the creation of a database. Thus,
    users can create a database Pod by just defining the name and size of the database
    in a CRD, and the controller will provision the rest.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个用例，您希望自动将业务应用程序或数据库自动部署到Kubernetes集群上。抽象掉技术细节，比如配置和部署应用程序，允许团队在不需要深入了解Kubernetes的情况下管理它们。例如，您可以创建一个CR来抽象数据库的创建。因此，用户只需在CRD中定义数据库的名称和大小，控制器就会提供其余部分来创建数据库Pod。
- en: Example Use Case 2
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例用例2
- en: Consider a scenario where you have self-serving teams. Your Kubernetes platform
    is used by multiple teams and you would like the teams to provision namespaces
    and other resources by themselves. In this case, you want teams to define the
    total CPU and memory they need for the workloads, as well as default limits for
    a Pod. You can create a CRD and teams can create a CR with the namespace name
    and other parameters. Your custom controllers would create the resources they
    need and associate the correct RBAC policies for each team. You can also add additional
    functionality, such as a team being restricted to three environments. The controller
    can also generate audit events and record all the activities.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个情景，您有自助团队。您的Kubernetes平台被多个团队使用，您希望团队自行定义工作负载所需的总CPU和内存，以及Pod的默认限制。您可以创建一个CRD，团队可以使用命名空间名称和其他参数创建CR。您的自定义控制器将创建他们需要的资源，并为每个团队关联正确的RBAC策略。您还可以添加其他功能，例如限制团队只能使用三个环境。控制器还可以生成审计事件并记录所有活动。
- en: Example Use Case 3
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例用例3
- en: Let's say you are an administrator of a development Kubernetes cluster where
    developers come and test their application. The problem you are facing is that
    the developers left the Pods running and have moved on to new projects. This may
    create a resource issue for your cluster.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您是开发Kubernetes集群的管理员，开发人员会在这里测试他们的应用程序。您面临的问题是开发人员留下了正在运行的Pod，并已转移到新项目。这可能会对您的集群造成资源问题。
- en: In this chapter, we will build a CRD and a custom controller around this scenario.
    A solution that we can implement is to delete the Pod after a certain amount of
    time has passed following their creation. Let's call this time `podLiveForThisMinutes`.
    A further requirement is to have a configurable way of defining `podLiveForThisMinutes`
    for each namespace, as different teams may have different priorities and requirements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将围绕这种情景构建一个CRD和一个自定义控制器。我们可以实现的解决方案是在创建后的一定时间后删除Pod。让我们称这个时间为`podLiveForThisMinutes`。另一个要求是以可配置的方式为每个命名空间定义`podLiveForThisMinutes`，因为不同的团队可能有不同的优先级和要求。
- en: We can define a time limit per namespace and that would provide the flexibility
    to apply controls on different namespaces. To implement the requirements defined
    in this example use case, we will define a CRD that allows two fields – a namespace
    name and the amount of time to allow the Pods to run (`podLiveForThisMinutes`).
    In the rest of this chapter, we will build a CRD and a controller that will allow
    us to achieve the functionality mentioned here.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个命名空间定义一个时间限制，这将为在不同命名空间应用控制提供灵活性。为了实现本示例用例中定义的要求，我们将定义一个CRD，允许两个字段 -
    命名空间名称和允许Pod运行的时间量（`podLiveForThisMinutes`）。在本章的其余部分，我们将构建一个CRD和一个控制器，使我们能够实现这里提到的功能。
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are other (better) ways to implement the preceding scenario. In the real
    world, a Kubernetes `Deployment` object would recreate the Pod if the Pod had
    been created using the `Deployment` resource. We have chosen this scenario to
    keep the example simple and easy to implement.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他（更好的）方法来实现前面的场景。在现实世界中，如果Pod是使用`Deployment`资源创建的，Kubernetes的`Deployment`对象将重新创建Pod。我们选择了这个场景，以使示例简单易实现。
- en: How Our Custom Resources Are Defined
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的自定义资源是如何定义的
- en: To come up with a solution for *Example Use Case 3* in the previous section,
    we have decided that our CRD will define two fields, as mentioned in the preceding
    example. To accomplish this, our CR object will look as follows.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决前一节中*示例用例3*的问题，我们决定我们的CRD将定义两个字段，如前面的示例中所述。为了实现这一点，我们的CR对象将如下所示。
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding specification defines our target object. As you can see, it looks
    just like normal Kubernetes objects, but the specifications (the `spec` section)
    are defined as per our requirements. Let's dig a bit deeper into the details.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述规范定义了我们的目标对象。正如你所看到的，它看起来就像普通的Kubernetes对象，但规范（`spec`部分）根据我们的需求进行了定义。让我们深入了解一下细节。
- en: apiVersion
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: apiVersion
- en: This is the field required by Kubernetes to group objects. Note that we put
    the version (`v1`) as part of the group key. This grouping technique helps us
    keep multiple versions of our object. Consider whether you want to add a new property
    without affecting existing users. You can just create a new group with `v2`, and
    an object definition with both versions — `v1` and `v2` — can exist at the same
    time. Because they are separated, it allows different versions of different groups
    to evolve at a different rate.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Kubernetes用来对对象进行分组的字段。请注意，我们将版本（`v1`）作为组键的一部分。这种分组技术帮助我们保持对象的多个版本。考虑是否要添加新属性而不影响现有用户。你可以只创建一个带有`v2`的新组，同时存在`v1`和`v2`两个版本的对象定义。因为它们是分开的，所以不同组的不同版本可以以不同的速度发展。
- en: This approach also helps if we want to test new features. Say we want to add
    a new field to the same object. Then, we could just change the API version and
    add the new field. Thus, we can keep the stable version separate from the new,
    experimental version.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法还有助于我们测试新功能。假设我们想要向同一对象添加一个新字段。然后，我们可以只更改API版本并添加新字段。因此，我们可以将稳定版本与新的实验版本分开。
- en: kind
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kind
- en: This field mentions a specific type of object in a group defined by `apiVersion`.
    Think of `kind` as the name of the CR object, such as `Pod`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字段提到了由`apiVersion`定义的组中的特定类型对象。把`kind`想象成CR对象的名称，比如`Pod`。
- en: Note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Do not confuse this with the name of the object that you create using this specification,
    which is defined in the `metadata` section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将其与使用此规范创建的对象的名称混淆，该对象在“metadata”部分中定义。
- en: Through this, we can have multiple objects under one API group. Imagine you
    are about to create an awesome functionality that would require multiple different
    types of objects to be created. You can have multiple objects using the `Kind`
    field under the same API group.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，我们可以在一个API组下拥有多个对象。想象一下，你要创建一个需要创建多种不同类型对象的功能。你可以在同一个API组下使用“Kind”字段创建多个对象。
- en: spec
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: spec
- en: This field defines the information needed to define the specification of the
    object. The specification contains information that defines the desired state
    of our resource. All the fields that describe the characteristics of our resource
    go inside the `spec` section. For our use case, the `spec` section contains the
    two fields that we need for our CR – `podLiveForThisMinutes` and `namespaceName`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字段定义了定义对象规范所需的信息。规范包含定义资源期望状态的信息。描述资源特性的所有字段都放在`spec`部分。对于我们的用例，`spec`部分包含我们CR所需的两个字段——`podLiveForThisMinutes`和`namespaceName`。
- en: namespaceName and podLiveForThisMinutes
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: namespaceName和podLiveForThisMinutes
- en: These are the custom fields that we want to define. `namespaceName` will contain
    the name of the target namespace, and `podLiveForThisMinutes` will contain the
    time (in minutes) that we want the Pod to be active for.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们想要定义的自定义字段。`namespaceName`将包含目标命名空间的名称，而`podLiveForThisMinutes`将包含我们希望Pod活动的时间（以分钟为单位）。
- en: The Definition of a CRD
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRD的定义
- en: In the previous section, we showed the different components of a CR. However,
    before we define our CR, we need to define a schema, which governs how the CR
    would be defined. In the following exercise, you will define the schema or the
    CRD for the resource mentioned in the *How Our Custom Resources Are Defined* section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们展示了CR的不同组件。然而，在我们定义CR之前，我们需要定义一个模式，它规定了CR的定义方式。在接下来的练习中，您将为*我们的自定义资源是如何定义的*部分中提到的资源定义模式或CRD。
- en: 'Consider this example CRD, which we will use in the following exercise. Let''s
    understand the important bits of the CRD by observing the following definition:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个示例CRD，在接下来的练习中我们将使用它。让我们通过观察以下定义来理解CRD的重要部分：
- en: pod-normaliser-crd.yaml
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: pod-normaliser-crd.yaml
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s look at various components of this CRD:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个CRD的各个组件：
- en: '`apiVersion` and `kind`: These are the API and the resource for the CRD itself
    and are provided by Kubernetes for the CRD definition.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiVersion`和`kind`：这些是CRD本身的API和资源，由Kubernetes提供给CRD定义。'
- en: '`group` and `version`: Think of an API group as a set of objects that are logically
    related to one another. These two fields define the API group and the version
    of our CR, which will then be translated into the `apiVersion` field of our CR,
    defined earlier in the previous section.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group`和`version`：将API组想象成一组逻辑相关的对象。这两个字段定义了我们CR的API组和版本，然后将被翻译成我们在前面部分中定义的CR的`apiVersion`字段。'
- en: '`kind`: This field defines the `kind` of our CR, defined earlier in the *How
    Our Custom Resources Are Defined* section.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`：这个字段定义了我们CR的`kind`，在*我们的自定义资源是如何定义的*部分中已经定义过。'
- en: '`metadata/name`: The name must match the `spec` fields, and the format is a
    combination of two fields – that is, `<plural>.<group>`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata/name`：名称必须与`spec`字段匹配，格式是两个字段的组合，即`<plural>.<group>`。'
- en: '`scope`: This field defines whether the CR will be namespace-scoped or cluster-scoped.
    By default, the CR is cluster-scoped. We have defined it as namespace-scoped here.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scope`：这个字段定义了CR是命名空间范围还是集群范围。默认情况下，CR是集群范围的。我们在这里定义它为命名空间范围。'
- en: '`plurals`: These are plural names to be used in the Kubernetes API server URL.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plurals`：这些是用于Kubernetes API服务器URL中的复数名称。'
- en: '`openAPIV3Schema`: This is the schema that is defined based on the OpenAPI
    v3 standards. It refers to the actual fields/schema of our CR. A schema is something
    that defines what fields are available in our CR, the names of the fields, and
    the data types for them. It basically defines the structure of the `spec` field
    in our CR. We have used the `namespaceName` and `podLiveForMinutes` fields in
    our CR. You can see this in *step 2* of the following exercise.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openAPIV3Schema`：这是基于OpenAPI v3标准定义的模式。它指的是我们CR的实际字段/模式。模式定义了我们CR中可用的字段、字段的名称和它们的数据类型。它基本上定义了我们CR中`spec`字段的结构。我们在CR中使用了`namespaceName`和`podLiveForMinutes`字段。你可以在以下练习的*步骤2*中看到这一点。'
- en: It is interesting to know that the component of the API server that serves the
    CRs is called `apiextensions-apiserver`. When kubectl requests reach the API server,
    it first checks whether the resource is a standard Kubernetes resource, such as
    a Pod or a Deployment. If the resource is not a standard resource, then `apiextensions-apiserver`
    is invoked.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，API服务器中服务CR的组件被称为`apiextensions-apiserver`。当kubectl请求到达API服务器时，它首先检查资源是否是标准的Kubernetes资源，比如Pod或Deployment。如果资源不是标准资源，那么就会调用`apiextensions-apiserver`。
- en: 'Exercise 19.01: Defining a CRD'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习19.01：定义CRD
- en: 'In this exercise, we will define a CRD, and in the next exercise, we will create
    a CR for the defined CRD. The definition of the CRD is stored in the Kubernetes
    etcd server. Remember that the CRD and CR are just definitions, and until you
    deploy a controller that is associated with your CRs, there is no functionality
    attached to the CRD/CR. By defining a CRD, you are registering a new type of object
    with the Kubernetes cluster. After you define the CRD, it will be accessible via
    the normal Kubernetes API and you can access it via Kubectl:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个CRD，在下一个练习中，我们将为定义的CRD创建一个CR。CRD的定义存储在Kubernetes etcd服务器中。请记住，CRD和CR只是定义，直到您部署与您的CR相关联的控制器，CRD/CR才会有功能附加。通过定义CRD，您正在向Kubernetes集群注册一个新类型的对象。在定义CRD之后，它将通过正常的Kubernetes
    API可访问，并且您可以通过Kubectl访问它：
- en: 'Create a new namespace called `crddemo`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`crddemo`的新命名空间：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This should give the following response:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该得到以下响应：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we need to define a CRD. Create a file named `pod-normaliser-crd.yaml`
    using the following content:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要定义一个CRD。使用以下内容创建一个名为`pod-normaliser-crd.yaml`的文件：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using the definition from the previous step, create the CRD using the following
    command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上一步的定义，使用以下命令创建CRD：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see the following response:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 19.4: Creating our CRD'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.4：创建我们的CRD'
- en: '](image/B14870_19_04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_19_04.jpg)'
- en: 'Figure 19.4: Creating our CRD'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.4：创建我们的CRD
- en: 'Verify that the CR is registered with Kubernetes using the following command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令验证CR是否已在Kubernetes中注册：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should see the following list of resources:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下资源列表：
- en: '![Figure 19.5: Verifying whether the CR has been registered with Kubernetes'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.5：验证CR是否已在Kubernetes中注册'
- en: '](image/B14870_19_05.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_19_05.jpg)'
- en: 'Figure 19.5: Verifying whether the CR has been registered with Kubernetes'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.5：验证CR是否已在Kubernetes中注册
- en: 'Verify that the API is available in the Kubernetes API server by using the
    following command:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令验证Kubernetes API服务器中是否可用API：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see the following response:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this exercise, we have defined a CRD, and now, Kubernetes will be able to
    know what our CR should look like.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们已经定义了一个CRD，现在，Kubernetes将能够知道我们的CR应该是什么样子的。
- en: Now, in the following exercise, let's create a resource object as per the CRD
    we defined. This exercise will be an extension of the previous exercise. However,
    we have separated them because CRD objects can exist on their own; you don't have
    to have a CR paired with a CRD. It may be the case that a CRD is provided by some
    third-party software vendor, and you are only required to create the CR. For example,
    a database controller provided by a vendor may already have a CRD and the controller.
    To use the functionality, you just need to define the CR.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在下一个练习中，让我们根据我们定义的CRD创建一个资源对象。这个练习将是上一个练习的延伸。但是，我们将它们分开，因为CRD对象可以独立存在；您不必将CR与CRD配对。可能的情况是，CRD由某些第三方软件供应商提供，并且您只需要创建CR。例如，供应商提供的数据库控制器可能已经有了CRD和控制器。要使用功能，您只需要定义CR。
- en: Let's proceed to make a CR out of our CRD in the following exercise.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在下一个练习中将我们的CRD制作成一个CR。
- en: 'Exercise 19.02: Defining a CR Using a CRD'
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习19.02：使用CRD定义CR
- en: 'In this exercise, we will create a CR as per the CRD defined in the previous
    exercise. The CR will be stored in the etcd datastore as a normal Kubernetes object,
    and it is served by the Kubernetes API server – that is, when you try to access
    it via Kubectl, it will be handled by the Kubernetes API server:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将根据上一个练习中定义的CRD创建一个CR。CR将作为一个普通的Kubernetes对象存储在etcd数据存储中，并由Kubernetes
    API服务器提供服务-也就是说，当您尝试通过Kubectl访问它时，它将由Kubernetes API服务器处理：
- en: Note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will only be able to perform this exercise after successfully completing
    the previous exercise in this chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在成功完成本章的上一个练习后，您才能执行此练习。
- en: 'First, make sure that there is no CR for the `podlifecycleconfigs` type. Use
    the following command to check:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保`podlifecycleconfigs`类型没有CR。使用以下命令进行检查：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If there is no CR, you should see the following response:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有CR，您应该会看到以下响应：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If there is a resource defined, you can delete it using the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已定义资源，可以使用以下命令删除它：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we have to create a CR. Create a file named `pod-normaliser.yaml` using
    the following content:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须创建一个CR。使用以下内容创建名为`pod-normaliser.yaml`的文件：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Issue the following command to create the resource from the file created in
    the previous step:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建来自上一步创建的文件的资源：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should see the following response:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '![Figure 19.6: Creating our CR'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.6：创建我们的CR'
- en: '](image/B14870_19_06.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_19_06.jpg)'
- en: 'Figure 19.6: Creating our CR'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.6：创建我们的CR
- en: 'Verify that it is registered by Kubernetes by using the following command:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令验证Kubernetes是否已注册它：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should see the following response:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that we are using normal kubectl commands now. This is a pretty awesome
    way to extend the Kubernetes platform.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们现在正在使用普通的kubectl命令。这是扩展Kubernetes平台的一种非常棒的方式。
- en: We have defined our own CRD and have created a CR against it. The next step
    is to add the required functionality for our CR.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了自己的CRD，并已创建了一个CR。下一步是为我们的CR添加所需的功能。
- en: Writing the Custom Controller
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自定义控制器
- en: Now that we have a CR in our cluster, we will proceed to write some code that
    *acts* upon it to achieve the purpose of the scenario we set out in the *Why We
    Need Custom Resources* section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在集群中有一个CR，我们将继续编写一些代码来*执行*它，以实现我们在*为什么需要自定义资源*部分中设定的场景的目的。
- en: Note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will not teach the actual programming for writing the Go code for our controller
    since that is beyond the scope of this book. However, we will provide you with
    the programming logic required for *Example Use Case 3*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会教授编写控制器Go代码的实际编程，因为这超出了本书的范围。但是，我们会为*示例用例3*提供所需的编程逻辑。
- en: Let's imagine that our custom controller code is running as a Pod. What would
    it need to do to respond to a CR?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的自定义控制器代码正在作为一个Pod运行。为了响应CR，它需要做些什么？
- en: First, the controller has to be aware that a new CR has been defined/removed
    in the cluster to get the desired state.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，控制器必须知道在集群中定义/删除了新的CR，以获取所需的状态。
- en: Second, the code needs a way to interact with the Kubernetes API server to request
    the current state and then ask for the desired state. In our case, our controller
    has to be aware of all the pods in a namespace and the time when the Pods have
    been created. The code can then ask Kubernetes to delete the Pods if the allowed
    time is up for them, as per the CRD. Please refer to the *Example Use Case 3*
    section to refresh your memory on what our controller would be doing.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，代码需要一种与Kubernetes API服务器交互的方式，以请求当前状态，然后请求所需的状态。在我们的情况下，我们的控制器必须知道命名空间中所有Pod的时间以及Pod的创建时间。然后，代码可以要求Kubernetes根据CRD删除Pods，如果它们的允许时间已到。请参考*示例用例3*部分，以刷新您对我们的控制器将要执行的操作的记忆。
- en: 'The logic for our code can be visualized using the following diagram:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码逻辑可以通过以下图表进行可视化：
- en: '![Figure 19.7: Flowchart describing the logic for a custom controller'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.7：描述自定义控制器逻辑的流程图'
- en: '](image/B14870_19_07.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_19_07.jpg)'
- en: 'Figure 19.7: Flowchart describing the logic for a custom controller'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.7：描述自定义控制器逻辑的流程图
- en: 'If we were to describe the logic as simple pseudocode, it would be as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要将逻辑描述为简单的伪代码，那么它将如下所示：
- en: Fetch all the new CRs that have been created for our custom CRD from the Kubernetes
    API server.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Kubernetes API服务器获取为我们的自定义CRD创建的所有新CR。
- en: Register callbacks in case CRs are added or deleted. The callbacks would be
    triggered each time a new CR is added or deleted in our Kubernetes cluster.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册回调以便在添加或删除CR时触发。每当在我们的Kubernetes集群中添加或删除新的CR时，都会触发这些回调。
- en: If the CR is added to the cluster, the callback will create a sub-routine that
    continuously fetches the list of Pods in the namespace defined by the CR. If the
    Pod has been running for more than the time specified, it will be terminated.
    Otherwise, it will sleep for a few seconds.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果将CR添加到集群中，回调将创建一个子例程，该子例程将持续获取由CR定义的命名空间中的Pod列表。如果Pod已运行时间超过指定时间，它将被终止。否则，它将休眠几秒钟。
- en: If the CR is deleted, the callback will stop the sub-routine.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果删除CR，回调将停止子例程。
- en: The Components of the Custom Controller
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义控制器的组件
- en: As mentioned earlier, explaining in detail how custom controllers are built
    is beyond the scope of this book, and we have provided a fully working custom
    controller to suit the needs of *Example Use Case 3*. Our focus is to make sure
    that you can build and execute the controller to understand its behavior and that
    you are comfortable with all the components involved.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，详细解释自定义控制器的构建方式超出了本书的范围，我们已经提供了一个完全可用的自定义控制器，以满足*示例用例3*的需求。我们的重点是确保您可以构建和执行控制器以了解其行为，并且您对所有涉及的组件都感到满意。
- en: Custom controllers are components that provide functionality against a CR. To
    provide this, a custom controller would need to understand what a CR is meant
    for and its different parameters, or the *structural schema*. To make our controller
    aware of the schema, we provide the details about our schema to the controller
    through a code file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义控制器是针对CR提供功能的组件。为了提供这一点，自定义控制器需要了解CR的用途及其不同的参数，或者*结构模式*。为了使我们的控制器了解模式，我们通过代码文件向控制器提供有关我们模式的详细信息。
- en: 'Here is an excerpt of the code for the controller that we have provided:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们提供的控制器代码的摘录：
- en: types.go
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: types.go
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can find the complete code at this link: [https://packt.live/3jXky9G](https://packt.live/3jXky9G).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此链接找到完整的代码：[https://packt.live/3jXky9G](https://packt.live/3jXky9G)。
- en: 'As you can see, we have defined the `PodLifecycleConfig` structure as per our
    example of the CR provided in the *How Our Custom Resources Are Defined* section.
    It is repeated here for easier reference:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已经根据“自定义资源的定义方式”部分提供的CR示例定义了`PodLifecycleConfig`结构。这里重复列出以便更容易参考：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that in `types.go`, we have defined objects that can hold the full definition
    of this example spec. Also, notice in `types.go` that `namespaceName` is defined
    as `string` and `podLiveForThisMinuets` is defined as `int`. This is because we
    are using strings and integers for these fields, as you can see in the CR.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`types.go`中，我们已经定义了可以保存此示例规范的完整定义的对象。还要注意在`types.go`中，`namespaceName`被定义为`string`，`podLiveForThisMinuets`被定义为`int`。这是因为我们在CR中使用字符串和整数来表示这些字段，正如您所看到的。
- en: The next important function of the controller is to listen to events from the
    Kubernetes system that are related to the CR. We are using the **Kubernetes Go**
    client library to connect to the Kubernetes API server. This library makes it
    easier to connect to the Kubernetes API server (for example, for authentication)
    and have predefined request and response types to communicate with the Kubernetes
    API server.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的下一个重要功能是监听与CR相关的来自Kubernetes系统的事件。我们使用**Kubernetes Go**客户端库连接到Kubernetes
    API服务器。该库使连接到Kubernetes API服务器（例如，用于身份验证）更容易，并具有预定义的请求和响应类型，以与Kubernetes API服务器进行通信。
- en: Note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find more details about the Kubernetes Go client library at this link:
    [https://github.com/kubernetes/client-go](https://github.com/kubernetes/client-go).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此链接找到有关Kubernetes Go客户端库的更多详细信息：[https://github.com/kubernetes/client-go](https://github.com/kubernetes/client-go)。
- en: However, you are free to use any other library or any other programming language
    to communicate with the API server over HTTPS.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以自由地使用任何其他库或任何其他编程语言通过HTTPS与API服务器通信。
- en: 'You can see how we have implemented it by checking the code at this link: [https://packt.live/3ieFtVm](https://packt.live/3ieFtVm).
    First, we need to connect to the Kubernetes cluster. This code is running inside
    a Pod in the cluster, and it will need to connect to the Kubernetes API server.
    We need to give sufficient rights to our Pod to connect to the master server,
    which will be covered in the activity later in this chapter. We will use RBAC
    policies to achieve this. Please refer to *Chapter 13*, *Runtime and Network Security
    in Kubernetes*, to get a refresher on how Kubernetes implements RBAC functionality.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看此链接上的代码来了解我们是如何实现的：[https://packt.live/3ieFtVm](https://packt.live/3ieFtVm)。首先，我们需要连接到Kubernetes集群。这段代码正在集群中的一个Pod中运行，并且需要连接到Kubernetes
    API服务器。我们需要给予我们的Pod足够的权限来连接到主服务器，这将在本章后面的活动中介绍。我们将使用RBAC策略来实现这一点。请参考*第13章*，*Kubernetes中的运行时和网络安全*，以了解Kubernetes如何实现RBAC功能的复习。
- en: Once we are connected, we use the `SharedInformerFactory` object to listen to
    Kubernetes events for the controller. Think of the event as a way for us to be
    notified by Kubernetes when a new CR is created or deleted. `SharedInformerFactory`
    is a way provided by the Kubernetes Go client library to listen to events generated
    by the Kubernetes API server. A detailed explanation of `SharedInformerFactory`
    is beyond the scope of this book.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们连接上了，我们就使用`SharedInformerFactory`对象来监听控制器的Kubernetes事件。将事件视为Kubernetes在创建或删除新CR时通知我们的一种方式。`SharedInformerFactory`是Kubernetes
    Go客户端库提供的一种方式，用于监听Kubernetes API服务器生成的事件。对`SharedInformerFactory`的详细解释超出了本书的范围。
- en: 'The following snippet is an excerpt from our Go code to create `SharedInformerFactory`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是我们的Go代码中创建`SharedInformerFactory`的摘录：
- en: main.go
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: main.go
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can find the complete code at this link: [https://packt.live/3lXe3FM](https://packt.live/3lXe3FM).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此链接找到完整的代码：[https://packt.live/3lXe3FM](https://packt.live/3lXe3FM)。
- en: 'Once we have connected to the Kubernetes API server, we need to register to
    be notified whether our CR has been created or deleted. The following code performs
    this action:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们连接到Kubernetes API服务器，我们需要注册以便在我们的CR被创建或删除时得到通知。以下代码执行了这个动作：
- en: main.go
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: main.go
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can find the complete code at this link: [https://packt.live/2ZjtQoy](https://packt.live/2ZjtQoy).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此链接找到完整的代码：[https://packt.live/2ZjtQoy](https://packt.live/2ZjtQoy)。
- en: Note that the preceding code is an extract from the full code, and the snippet
    here is modified slightly for better presentation in this book. This code is registering
    callbacks to the Kubernetes server. Notice that we have registered for `AddFunc`
    and `DeleteFunc`. These will be called once the CR has been created or deleted,
    and we can write custom logic against that. You can see that for `AddFunc`, a
    Go subroutine is being called. For every new CR, we have a separate subroutine
    to keep on watching for the Pods created in the namespace. Also, note that `AddFunc`
    will print out `A Custom Resource has been Added` to the logs. You may also have
    noticed that in `DeleteFunc`, we have closed the `signal` channel, which will
    flag the Go subroutine to stop itself.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述代码是从完整代码中提取的，这里的片段经过了轻微修改，以便在本书中更好地呈现。此代码正在向 Kubernetes 服务器注册回调。请注意，我们已经注册了
    `AddFunc` 和 `DeleteFunc`。一旦 CR 被创建或删除，这些函数将被调用，我们可以针对此编写自定义逻辑。您可以看到，对于 `AddFunc`，正在调用
    Go 子例程。对于每个新的 CR，我们都有一个单独的子例程来继续监视在命名空间中创建的 Pods。另外，请注意，`AddFunc` 将在日志中打印出 `A
    Custom Resource has been Added`。您可能还注意到，在 `DeleteFunc` 中，我们已关闭了 `signal` 通道，这将标记
    Go 子例程停止自身。
- en: 'Activity 19.01: CRD and Custom Controller in Action'
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 19.01：CRD 和自定义控制器的实际应用
- en: In this activity, we will build and deploy custom controllers, CRs, and CRDs.
    Note that the coding required for building the custom controller is beyond the
    scope of this book and a ready-made code is provided in the code repository to
    facilitate the Deployment of a working controller.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将构建和部署自定义控制器、CR 和 CRD。请注意，构建自定义控制器所需的编码超出了本书的范围，并且代码库中提供了现成的代码，以便部署工作控制器。
- en: We will create a new CRD that can take two fields – a `podLiveForThisMinutes`
    field, which defines the time (in minutes) for a Pod to be allowed to run before
    it is killed, and the `namespaceName` field, which defines which namespace these
    rules will be applied to.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的 CRD，可以接受两个字段 - `podLiveForThisMinutes` 字段，定义了 Pod 在被杀死之前允许运行的时间（以分钟为单位），以及
    `namespaceName` 字段，定义了这些规则将应用于哪个命名空间。
- en: We will create a new CR as per the CRD. Also, we will create a new Kubernetes
    role that allows this new CRD to be queried from the Kubernetes API server. We
    will then show you how to associate the newly created role with the ServiceAccount
    named `default`, which is the default ServiceAccount that a Pod will use when
    we run it in the namespace named `default`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据 CRD 创建一个新的 CR。此外，我们将创建一个新的 Kubernetes 角色，允许从 Kubernetes API 服务器查询此新的 CRD。然后，我们将向您展示如何将新创建的角色与名为
    `default` 的 ServiceAccount 关联起来，这是在命名空间 `default` 中运行 Pod 时默认使用的 ServiceAccount。
- en: Generally, we build a custom controller that provides logic against the CRD
    we created. We will just use the code packaged as a container and deploy it as
    a Pod. The controller will be deployed as a normal Pod.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们构建一个自定义控制器，提供针对我们创建的 CRD 的逻辑。我们将使用打包为容器的代码，并将其部署为 Pod。控制器将作为普通 Pod 部署。
- en: At the end of the activity, to test our controller, you will create a simple
    Pod and verify whether our custom controller can delete the Pod.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在活动结束时，为了测试我们的控制器，您将创建一个简单的 Pod，并验证我们的自定义控制器是否能够删除该 Pod。
- en: '**Activity Guidelines:**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**活动指南：**'
- en: Delete the existing `crddemo` namespace and create a new one with the same name.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除现有的 `crddemo` 命名空间，并使用相同的名称创建一个新的命名空间。
- en: 'Get the code and the `Dockerfile` for creating the controller using the following
    command:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令获取用于创建控制器的代码和 `Dockerfile`：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Create a CRD with the following fields.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有以下字段的 CRD。
- en: 'The metadata should contain the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据应包含以下内容：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `OpenAPIV3Schema` section should contain the following `properties` settings:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenAPIV3Schema` 部分应包含以下 `properties` 设置：'
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Create a CR that allows Pods to live for 1 minute in the `crddemo` namespace.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个CR，允许`crddemo`命名空间中的Pod存活1分钟。
- en: 'Create a Role that allows the following permissions for the specified API resources:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个角色，为指定的API资源允许以下权限：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using a RoleBinding object, associate this new Role with the `default` ServiceAccount
    in the `crddemo` namespace.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用RoleBinding对象，将此新角色与`crddemo`命名空间中的`default` ServiceAccount关联起来。
- en: Build and deploy the controller Pod using the `Dockerfile` provided in *step
    2*.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*步骤2*中提供的`Dockerfile`构建和部署控制器Pod。
- en: Create a Pod that runs for a long time using the `k8s.gcr.io/busybox` image
    in the `crddemo` namespace.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`crddemo`命名空间中使用`k8s.gcr.io/busybox`镜像创建一个长时间运行的Pod。
- en: 'Watch the Pod created in the previous step and observe whether it is being
    terminated by our controller. The expected result is that the Pod should be created,
    and then it should be automatically terminated after about a minute, as in the
    following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 观察上一步创建的Pod，并观察我们的控制器是否正在终止它。预期结果是Pod应该被创建，然后大约一分钟后应该自动终止，如下面的屏幕截图所示：
- en: '![Figure 19.8: The expected output of Activity 19.01'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.8：活动19.01的预期输出'
- en: '](image/B14870_19_08.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_19_08.jpg)'
- en: 'Figure 19.8: The expected output of Activity 19.01'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.8：活动19.01的预期输出
- en: Note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在以下地址找到：[https://packt.live/304PEoD](https://packt.live/304PEoD)。
- en: Adding Data to Our Custom Resource
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的自定义资源添加数据
- en: 'In the previous activity, you created a CRD and CR. We mentioned earlier that
    once we define our CR, we can query them using standard kubectl commands. For
    example, if you would like to see how many CRs of the `PodLifecycleConfig` type
    have been defined, you can use the following command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个活动中，您创建了CRD和CR。我们之前提到过，一旦定义了我们的CR，就可以使用标准kubectl命令查询它们。例如，如果您想查看已定义的`PodLifecycleConfig`类型的CR数量，可以使用以下命令：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You will see the following response
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下响应
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that it only shows the name and age of the object. However, if you issue
    a command for a native Kubernetes object, you will see a lot more columns. Let''s
    try that for Deployments:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它只显示对象的名称和年龄。但是，如果您为本机Kubernetes对象发出命令，您将看到更多列。让我们尝试部署：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should see a response similar to this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于这样的响应：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice the additional columns that Kubernetes has added, which provide way more
    information about the objects.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意Kubernetes添加的附加列，这些列提供了有关对象的更多信息。
- en: What if we want to add more columns so that the output of the preceding command
    shows more details for our CRs? You are in luck, as Kubernetes provides a way
    to add additional information columns for the CRs. This is useful for displaying
    the critical values of each type of custom object. This can be done using additional
    data defined in the CRD. Let's see how we can do that in the following exercise.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要添加更多列，以便前面的命令输出显示我们的CR的更多细节怎么办？您很幸运，因为Kubernetes提供了一种方法来为CR添加附加信息列。这对于显示每种自定义对象的关键值非常有用。这可以通过在CRD中定义的附加数据来实现。让我们看看我们如何在以下练习中做到这一点。
- en: 'Exercise 19.03: Adding Custom Information to the CR List Command'
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习19.03：向CR列表命令添加自定义信息
- en: 'In this exercise, you will learn how to add custom information to the CR list
    obtained by means of the `kubectl get` command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将学习如何通过`kubectl get`命令添加自定义信息到CR列表中：
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will only be able to perform this exercise after successfully completing
    *Activity 19.01*, *CRD and Custom Controller in Action*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在成功完成*活动19.01*，*CRD和自定义控制器实战*之后，您才能执行此练习。
- en: 'Let''s define another CRD with additional columns. Create a file named `pod-normaliser-crd-adv.yaml`
    with the following content:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义另一个带有附加列的CRD。创建一个名为`pod-normaliser-crd-adv.yaml`的文件，内容如下：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Notice how we have a new section named `additionalPrinterColumns`. As the name
    suggests, this defines additional information for your resource. The two important
    fields of the `additionalPrinterColumns` sections are as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们有一个名为`additionalPrinterColumns`的新部分。顾名思义，这定义了资源的附加信息。`additionalPrinterColumns`部分的两个重要字段如下：
- en: '– `name`: This defines the name of the column to be printed.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '- `name`：这定义了要打印的列的名称。'
- en: '– `JSONPath`: This defines the location of the field. Through this path, the
    information is fetched from the resources and is displayed in the corresponding
    column.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '- `JSONPath`：这定义了字段的位置。通过这个路径，从资源中获取信息，并在相应的列中显示。'
- en: 'Now, let''s create this new CRD using the following command:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令创建这个新的CRD：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You will see the following output:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![Figure 19.9: Creating our modified CRD'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.9：创建我们修改后的CRD'
- en: '](image/B14870_19_09.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_19_09.jpg)'
- en: 'Figure 19.9: Creating our modified CRD'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.9：创建我们修改后的CRD
- en: 'Once we have created the CRD, let''s create the object for the CRD. Create
    a file named `pod-normaliser-adv.yaml` with the following content:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了CRD后，让我们创建CRD的对象。创建一个名为`pod-normaliser-adv.yaml`的文件，内容如下：
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, the fields in the `spec` section should be visible in the list obtained
    by the `kubectl get` command, similar to native Kubernetes objects.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`spec`部分中的字段应该在`kubectl get`命令获取的列表中可见，类似于原生Kubernetes对象。
- en: 'Let''s create the CR defined in the previous step using the following command:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建前一步中定义的CR：
- en: '[PRE33]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This should give the following response:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该得到以下响应：
- en: '![Figure 19.10: Creating our CR'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.10：创建我们的CR'
- en: '](image/B14870_19_10.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_19_10.jpg)'
- en: 'Figure 19.10: Creating our CR'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.10：创建我们的CR
- en: 'Now, let''s issue the `kubectl get` command to see whether additional fields
    are displayed:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们发出`kubectl get`命令，看看是否显示了附加字段：
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should see the following information displayed for our object:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到我们的对象显示了以下信息：
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can see that the additional fields are displayed and we now have more information
    about our CRs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到附加字段已显示，现在我们对CR有了更多信息。
- en: In this exercise, you have seen that we can associate additional data for our
    CR while querying it via the Kubernetes API server. We can define the field names
    and the path for the data for the fields. This resource-specific information becomes
    important when you have many resources of the same type, and it is also useful
    for the operations team to better understand the resources defined.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您已经看到我们可以在通过Kubernetes API服务器查询CR时关联附加数据。我们可以定义字段名称和字段数据的路径。当您拥有许多相同类型的资源时，这种资源特定信息变得重要，对于运维团队来说，更好地理解定义的资源也很有用。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about custom controllers. As per the Kubernetes
    glossary, a controller implements a control loop to watch the state of the cluster
    through the API server and makes changes in an attempt to move the current state
    toward the desired state.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了自定义控制器。根据Kubernetes词汇表，控制器实现控制循环，通过API服务器监视集群的状态，并进行更改，以尝试将当前状态移向期望的状态。
- en: Controllers can not only watch and manage user-defined CRs, but they can also
    act on resources such as Deployments or services, which are typically part of
    the Kubernetes controller manager. Controllers provide a way to write your own
    code to suit your business needs.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器不仅可以监视和管理用户定义的CR，还可以对部署或服务等资源进行操作，这些资源通常是Kubernetes控制器管理器的一部分。控制器提供了一种编写自己的代码以满足业务需求的方式。
- en: CRDs are the central mechanism used in the Kubernetes system to extend its capability.
    CRDs provide a native way to implement custom logic for the Kubernetes API server
    that satisfies your business requirements.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: CRD是Kubernetes系统中用于扩展其功能的中心机制。CRD提供了一种原生方式来实现符合您业务需求的Kubernetes API服务器的自定义逻辑。
- en: You have learned about how CRDs and controllers help provide an extension mechanism
    for the Kubernetes platform. You have also seen the process through which you
    can configure and deploy custom controllers on the Kubernetes platform.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解了CRD和控制器如何帮助为Kubernetes平台提供扩展机制。您还看到了如何配置和部署自定义控制器到Kubernetes平台的过程。
- en: As we come to the end of our journey, let's reflect on what we have achieved.
    We started with the basic concepts of Kubernetes, how it is architected, and how
    to interact with it. We were introduced to Kubectl, the command-line tool to interact
    with Kubernetes, and then later, we saw how the Kubernetes API server works and
    how to communicate with it using `curl` commands.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们接近旅程的尽头时，让我们回顾一下我们取得了什么成就。我们从Kubernetes的基本概念开始，了解了其架构以及如何与其交互。我们介绍了Kubectl，这是与Kubernetes交互的命令行工具，然后，我们看到了Kubernetes
    API服务器的工作原理以及如何使用`curl`命令与其通信。
- en: The first two chapters established the fundamentals of containerization and
    Kubernetes. Thereafter, we learned the basics of kubectl – the Kubernetes command
    center. In *Chapter 04, How to Communicate with Kubernetes (API Server)*, we looked
    at how kubectl and other HTTP clients communicate with the Kubernetes API server.
    We consolidated our learning by creating a Deployment at the end of the chapter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 前两章建立了容器化和Kubernetes的基础知识。此后，我们学习了kubectl的基础知识- Kubernetes命令中心。在*第04章，如何与Kubernetes（API服务器）通信*中，我们看到了kubectl和其他HTTP客户端如何与Kubernetes
    API服务器通信。我们通过在章节末创建一个部署来巩固我们的学习。
- en: From *Chapter 5*, *Pods*, through to *Chapter 10*, *ConfigMaps and Secrets*,
    we dug into concepts that are critical to understanding the platform and to start
    designing applications to run on Kubernetes. Concepts such as Pods, Deployments,
    Services, and PersistentVolumes enable us to use the platform to write fault-tolerant
    applications.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 从*第5章*的*Pods*到*第10章*的*ConfigMaps和Secrets*，我们深入探讨了理解平台并开始设计在Kubernetes上运行应用程序所必不可少的概念。诸如Pods、Deployments、Services和PersistentVolumes等概念使我们能够利用该平台编写容错应用程序。
- en: In the next series of chapters, stretching from *Chapter 11*, *Build Your Own
    HA Cluster*, to *Chapter 15*, *Monitoring and Autoscaling in Kubernetes*, we learned
    about installing and running Kubernetes on a cloud platform. This covered the
    installation of the Kubernetes platform in high availability (HA) configuration
    and how to manage network security in the platform. In this part of the book,
    you also looked at stateful components and how applications can use these features
    of the platform. Lastly, this section talked about monitoring your cluster and
    setting up autoscaling.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的一系列章节中，从*第11章*的*构建您自己的HA集群*到*第15章*的*Kubernetes中的监控和自动缩放*，我们了解了如何在云平台上安装和运行Kubernetes。这涵盖了在高可用性（HA）配置中安装Kubernetes平台以及如何在平台中管理网络安全。在本书的这一部分，您还了解了有状态组件以及应用程序如何使用平台的这些特性。最后，本节讨论了监视您的集群并设置自动缩放。
- en: Finally, in this last part, starting from *Chapter 16*, *Kubernetes Admission
    Controllers*, we began learning about advanced concepts such as how you can apply
    custom policies using admission controllers. You have also been introduced to
    the Kubernetes scheduler, a component that decides where your application will
    be running in the cluster. You learned how to change the default behavior of the
    scheduler. You have also seen how CRDs provide a way to extend Kubernetes, which
    can be useful not only to build custom enhancements but also as a way for third-party
    providers to add functionality to Kubernetes.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这最后一部分，从*第16章*开始，*Kubernetes准入控制器*，我们开始学习一些高级概念，比如如何使用准入控制器应用自定义策略。你也已经了解了Kubernetes调度器，这是一个决定你的应用程序将在集群中的哪个位置运行的组件。你学会了如何改变调度器的默认行为。你也看到了CRD提供了一种扩展Kubernetes的方式，这不仅可以用来构建自定义增强功能，也可以作为第三方提供商为Kubernetes添加功能的一种方式。
- en: This book serves as a good launchpad to get started with Kubernetes. You are
    now equipped to design and build systems on top of Kubernetes that can bring cloud-native
    experience to your organization. Although this is the end of this book, it is
    only the beginning of your journey as a Kubernetes professional.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书可以作为一个很好的起点，帮助你开始学习Kubernetes。现在你已经具备了在Kubernetes之上设计和构建系统的能力，可以为你的组织带来云原生的体验。虽然这本书到此结束了，但这只是作为一个Kubernetes专业人员的旅程的开始。
