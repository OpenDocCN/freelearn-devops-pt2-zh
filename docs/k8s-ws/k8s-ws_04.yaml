- en: 4\. How to Communicate with Kubernetes (API Server)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 如何与Kubernetes（API服务器）通信
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will build a foundational understanding of the Kubernetes
    API server and the various ways of interacting with it. We will learn how kubectl
    and other HTTP clients communicate with the Kubernetes API server. We will use
    some practical demonstrations to trace these communications and see the details
    of HTTP requests. Then, we will also see how we can look up the API details so
    that you can write your own API request from scratch. By the end of this chapter,
    you will be able to create API objects by directly communicating with the API
    server using any HTTP client, such as curl, to make RESTful API calls to the API
    server.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将建立对Kubernetes API服务器及其各种交互方式的基础理解。我们将学习kubectl和其他HTTP客户端如何与Kubernetes
    API服务器进行通信。我们将使用一些实际演示来跟踪这些通信，并查看HTTP请求的详细信息。然后，我们还将看到如何查找API详细信息，以便您可以从头开始编写自己的API请求。通过本章的学习，您将能够使用任何HTTP客户端（如curl）直接与API服务器通信，以创建API对象并进行RESTful
    API调用。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: As you will recall from *Chapter 2*, *An Overview of Kubernetes*, the API server
    acts as the central hub that communicates with all the different components in
    Kubernetes. In the previous chapter, we took a look at how we can use kubectl
    to instruct the API server to do various things.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在*第2章*《Kubernetes概述》中所记得的，API服务器充当与Kubernetes中所有不同组件通信的中央枢纽。在上一章中，我们看到了如何使用kubectl指示API服务器执行各种操作。
- en: In this chapter, we will take a further look into the components that make up
    the API server. As the API server is at the center of our entire Kubernetes system,
    it is important to learn how to effectively communicate with the API server itself
    and how API requests are processed. We will also look at various API concepts,
    such as resources, API groups, and API versions, which will help you understand
    the HTTP requests and responses that are made to the API server. Finally, we will
    interact with the Kubernetes API using multiple REST clients to achieve many of
    the same results we did in the previous chapter using the kubectl command-line
    tool.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步了解构成API服务器的组件。由于API服务器位于整个Kubernetes系统的中心，因此学习如何有效地与API服务器本身进行通信以及如何处理API请求非常重要。我们还将了解各种API概念，如资源、API组和API版本，这将帮助您了解发送到API服务器的HTTP请求和响应。最后，我们将使用多个REST客户端与Kubernetes
    API进行交互，以实现在上一章中使用kubectl命令行工具实现的许多相同结果。
- en: The Kubernetes API Server
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes API服务器
- en: In Kubernetes, all communications and operations between the control plane components
    and external clients, such as kubectl, are translated into **RESTful API** calls
    that are handled by the API server. Effectively, the API server is a RESTful web
    application that processes RESTful API calls over HTTP to store and update API
    objects in the etcd datastore.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，控制平面组件和外部客户端（如kubectl）之间的所有通信和操作都被转换为由API服务器处理的**RESTful API**调用。实际上，API服务器是一个RESTful
    Web应用程序，它通过HTTP处理RESTful API调用以存储和更新etcd数据存储中的API对象。
- en: The API server is also a frontend component that acts as a gateway to and from
    the outside world, which is accessed by all clients, such as the kubectl command-line
    tool. Even the cluster components in the control plane interact with each other
    only through the API server. Additionally, it is the only component that interacts
    directly with the etcd datastore. Since the API server is the only way for clients
    to access the cluster, it must be properly configured to be accessible by clients.
    You will usually see the API server implemented as `kube-apiserver`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: API服务器也是一个前端组件，充当与外部世界的网关，所有客户端都可以访问，比如kubectl命令行工具。即使控制平面中的集群组件也只能通过API服务器相互交互。此外，它是唯一直接与etcd数据存储交互的组件。由于API服务器是客户端访问集群的唯一方式，必须正确配置以供客户端访问。通常会看到API服务器实现为`kube-apiserver`。
- en: Note
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will explain the RESTful API in more detail in the *The Kubernetes API* section
    later in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面的* Kubernetes API*部分更详细地解释RESTful API。
- en: 'Now, let''s recall how the API server looks in our Minikube cluster by running
    the following command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过运行以下命令来回顾一下我们的Minikube集群中的API服务器的外观：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should see the following response:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 4.1: Observing how the API server is implemented in Minikube'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1：观察Minikube中API服务器的实现方式'
- en: '](image/B14870_04_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_01.jpg)'
- en: 'Figure 4.1: Observing how the API server is implemented in Minikube'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：观察Minikube中API服务器的实现方式
- en: 'As we saw in previous chapters, in the Minikube environment, the API server
    is referred to as `kube-apiserver-minikube` in the `kube-system` namespace. As
    you can see in the preceding screenshot, we have a single instance of the API
    server: `kube-apiserver-minikube`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的章节中看到的，在Minikube环境中，API服务器被称为`kube-apiserver-minikube`，位于`kube-system`命名空间中。如前面的屏幕截图所示，我们有一个API服务器的单个实例：`kube-apiserver-minikube`。
- en: The API server is stateless (that is, its behavior will be consistent regardless
    of the state of the cluster) and is designed to scale horizontally. Usually, for
    the high availability of clusters, it is recommended to have at least three instances
    to handle the load and fault tolerance better.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: API服务器是无状态的（即，其行为将始终保持一致，无论集群的状态如何），并且设计为水平扩展。通常，为了集群的高可用性，建议至少有三个实例来更好地处理负载和容错能力。
- en: Kubernetes HTTP Request Flow
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes HTTP请求流程
- en: 'As we learned in earlier chapters, when we run any `kubectl` command, the command
    is translated into an HTTP API request in JSON format and is sent to the API server.
    Then, the API server returns a response to the client, along with any requested
    information. The following diagram shows the API request life cycle and what happens
    inside the API server when it receives a request:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的章节中学到的，当我们运行任何`kubectl`命令时，该命令会被转换为JSON格式的HTTP API请求，并发送到API服务器。然后，API服务器将响应返回给客户端，并提供任何请求的信息。以下图表显示了API请求的生命周期以及API服务器在接收请求时发生的情况：
- en: '![Figure 4.2: API server HTTP request flow'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2：API服务器HTTP请求流'
- en: '](image/B14870_04_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_02.jpg)'
- en: 'Figure 4.2: API server HTTP request flow'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：API服务器HTTP请求流
- en: As you can see in the preceding figure, the HTTP request goes through the authentication,
    authorization, and admission control stages. We will take a look at each of these
    in the following subtopics.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，HTTP请求经过身份验证、授权和准入控制阶段。我们将在以下子主题中查看每个阶段。
- en: Authentication
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证
- en: In Kubernetes, every API call needs to authenticate with the API server, regardless
    of whether it comes from outside the cluster, such as those made by kubectl, or
    a process inside the cluster, such as those made by kubelet.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，每个API调用都需要通过API服务器进行身份验证，无论是来自集群外部的调用，比如kubectl发出的调用，还是来自集群内部的进程，比如kubelet发出的调用。
- en: When an HTTP request is sent to the API server, the API server needs to authenticate
    the client sending this request. The HTTP request will contain the information
    required for authentication, such as the username, user ID, and group. The authentication
    method will be determined by either the header or the certificate of the request.
    To deal with these different methods, the API server has different authentication
    plugins, such as ServiceAccount tokens, which are used to authenticate ServiceAccounts,
    and at least one other method to authenticate users, such as X.509 client certificates.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当向API服务器发送HTTP请求时，API服务器需要对发送此请求的客户端进行身份验证。HTTP请求将包含所需的身份验证信息，例如用户名、用户ID和组。身份验证方法将由请求的标头或证书确定。为了处理这些不同的方法，API服务器有不同的身份验证插件，例如ServiceAccount令牌，用于对ServiceAccounts进行身份验证，以及至少一种其他方法来对用户进行身份验证，例如X.509客户端证书。
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The cluster administrator usually defines authentication plugins during cluster
    creation. You can learn more about the various authentication strategies and authentication
    plugins at [https://kubernetes.io/docs/reference/access-authn-authz/authentication/](https://kubernetes.io/docs/reference/access-authn-authz/authentication/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 集群管理员通常在集群创建过程中定义认证插件。您可以在[https://kubernetes.io/docs/reference/access-authn-authz/authentication/](https://kubernetes.io/docs/reference/access-authn-authz/authentication/)了解更多关于各种认证策略和认证插件的信息。
- en: We will take a look at the implementation of certificate-based authentication
    in *Chapter 11*, *Build Your Own HA Cluster*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第11章* *构建您自己的HA集群*中查看基于证书的身份验证的实现。
- en: The API server will call those plugins one by one until one of them authenticates
    the request. If all of them fail, then the authentication fails. If the authentication
    succeeds, then the authentication phase is complete and the request proceeds to
    the authorization phase.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: API服务器将依次调用这些插件，直到其中一个对请求进行身份验证。如果它们全部失败，则身份验证失败。如果身份验证成功，则身份验证阶段完成，请求继续到授权阶段。
- en: Authorization
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权
- en: After authentication is successful, the attributes from the HTTP request are
    sent to the authorization plugin to determine whether the user is permitted to
    perform the requested action. There are various levels of privileges that different
    users may have; for example, can a given user create a pod in the requested namespace?
    Can the user delete a Deployment? These kinds of decisions are made in the authorization
    phase.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证成功后，将HTTP请求中的属性发送到授权插件，以确定用户是否被允许执行请求的操作。不同用户可能具有不同级别的权限；例如，特定用户是否可以在请求的命名空间中创建一个pod？用户是否可以删除一个部署？这些决定是在授权阶段做出的。
- en: 'Consider an example where you have two users. A user called **ReadOnlyUser**
    (just a hypothetical name) should be allowed to list pods in the `default` namespace
    only, and **ClusterAdmin** (another hypothetical name) should be able to perform
    all tasks across all namespaces:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子，假设您有两个用户。一个名为**ReadOnlyUser**（只是一个假设的名称）应该被允许仅列出`default`命名空间中的pod，而**ClusterAdmin**（另一个假设的名称）应该能够在所有命名空间中执行所有任务：
- en: '![Figure 4.3: Privileges for our two users'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3：我们两个用户的权限'
- en: '](image/B14870_04_03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_03.jpg)'
- en: 'Figure 4.3: Privileges for our two users'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：我们两个用户的权限
- en: 'To understand this better, take a look at the following demonstration:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，请看以下演示：
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will not dive into too much detail about how to create users as this will
    be discussed in *Chapter 13*, *Runtime and Network Security in Kubernetes*. For
    this demonstration, the users, along with their permissions, are already set up,
    and the limitation of their privileges is demonstrated by switching contexts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入讨论如何创建用户，因为这将在《第13章》《Kubernetes中的运行时和网络安全》中讨论。对于这个演示，用户以及他们的权限已经设置好，并且通过切换上下文来演示他们的权限限制。
- en: '![Figure 4.4: Demonstrating different user privileges'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4：演示不同用户权限'
- en: '](image/B14870_04_04.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_04.jpg)'
- en: 'Figure 4.4: Demonstrating different user privileges'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：演示不同用户权限
- en: Notice, from the preceding screenshot, that the `ReadOnlyUser` can only **list**
    pods in the default namespace, but when trying to perform other tasks, such as
    deleting a pod in the `default` namespace or listing pods in other namespaces,
    the user will get a `Forbidden` error. This `Forbidden` error is returned by the
    authorization plugin.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从前面的截图中可以看出，`ReadOnlyUser`只能在默认命名空间中**列出**pod，但是当尝试执行其他任务时，比如在`default`命名空间中删除pod或者列出其他命名空间中的pod时，用户将会收到`Forbidden`错误。这个`Forbidden`错误是由授权插件返回的。
- en: kubectl provides a tool that you can call by using `kubectl auth can-i` to check
    whether an action is allowed for the current user.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl提供了一个工具，您可以使用`kubectl auth can-i`来检查当前用户是否允许执行某项操作。
- en: 'Let''s consider the following examples in the context of the previous demonstration.
    Let''s say that the `ReadOnlyUser` runs the following commands:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在前面演示的情境下考虑以下例子。假设`ReadOnlyUser`运行以下命令：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The user should see the following responses:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应该看到以下响应：
- en: '![Figure 4.5: Checking privileges for ReadOnlyUser'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5：检查ReadOnlyUser的权限'
- en: '](image/B14870_04_05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_05.jpg)'
- en: 'Figure 4.5: Checking privileges for ReadOnlyUser'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：检查ReadOnlyUser的权限
- en: 'Now, after switching context, let''s say that the `ClusterAdmin` user runs
    the following commands:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在切换上下文之后，假设`ClusterAdmin`用户运行以下命令：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The user should see the following response:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应该看到以下响应：
- en: '![Figure 4.6: Checking privileges for ClusterAdmin'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6：检查ClusterAdmin的权限'
- en: '](image/B14870_04_06.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_06.jpg)'
- en: 'Figure 4.6: Checking privileges for ClusterAdmin'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：检查ClusterAdmin的权限
- en: Unlike authentication phase modules, authorization modules are checked in sequence.
    If multiple authorization modules are configured, and if any authorizer approves
    or denies a request, that decision is immediately returned, and no other authorizer
    will be contacted.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与认证阶段模块不同，授权模块是按顺序检查的。如果配置了多个授权模块，并且如果任何授权者批准或拒绝请求，该决定将立即返回，不会联系其他授权者。
- en: Admission Control
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准入控制
- en: After the request is authenticated and authorized, it goes to the admission
    control modules. These modules can modify or reject requests. If the request is
    only trying to perform a READ operation, it bypasses this stage; but if it is
    trying to create, modify, or delete, it will be sent to the admission controller
    plugins. Kubernetes comes with a set of predefined admission controllers, although
    you can define custom admission controllers as well.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求经过认证和授权之后，它会经过准入控制模块。这些模块可以修改或拒绝请求。如果请求只是尝试执行读取操作，它将绕过这个阶段；但是如果它尝试创建、修改或删除，它将被发送到准入控制器插件。Kubernetes带有一组预定义的准入控制器，尽管您也可以定义自定义的准入控制器。
- en: These plugins may modify the incoming object, in some cases to apply system-configured
    defaults or even to deny the request. Like authorization modules, if any admission
    controller module rejects the request, then the request is dropped and it will
    not process further.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些插件可能会修改传入的对象，在某些情况下会应用系统配置的默认值，甚至会拒绝请求。与授权模块一样，如果任何准入控制器模块拒绝请求，那么请求将被丢弃，不会进一步处理。
- en: 'Some examples are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一些例子如下：
- en: If we configure a custom rule that every object should have a label (which you
    will learn how to do in *Chapter 16*, *Kubernetes Admission Controllers*), then
    any request to create an object without a label will be rejected by the admission
    controllers.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们配置一个自定义规则，要求每个对象都必须有一个标签（您将在第16章“Kubernetes准入控制器”中学习如何做到这一点），那么任何尝试创建没有标签的对象的请求都将被准入控制器拒绝。
- en: When you delete a namespace, it goes to the **Terminating** state, where Kubernetes
    will try to evict all the resources in it before deleting it. So, we cannot create
    any new objects in this namespace. `NamespaceLifecycle` is what prevents that.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您删除一个命名空间时，它会进入“Terminating”状态，在这种状态下，Kubernetes会尝试在删除之前清除其中的所有资源。因此，我们无法在此命名空间中创建任何新对象。“NamespaceLifecycle”就是阻止这种情况发生的。
- en: When a client tries to create a resource in a namespace that does not exist,
    the `NamespaceExists` admission controller rejects the request.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客户端尝试在不存在的命名空间中创建资源时，“NamespaceExists”准入控制器会拒绝该请求。
- en: Out of the different modules included in Kubernetes, not all of the admission
    control modules are enabled by default, and the default modules usually change
    based on the Kubernetes version. Providers of cloud-based Kubernetes solutions,
    such as **Amazon Web Services** (**AWS**), Google, and Azure, control which plugins
    can be enabled by default. Cluster administrators can also decide which modules
    to enable or disable when initializing the API server. By using the `--enable-admission-plugins`
    flag, administrators can control which modules should be enabled other than the
    default ones. On the other hand, the `--disable-admission-plugins` flag controls
    which modules from the default modules should be disabled.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中包含的不同模块中，并非所有准入控制模块都是默认启用的，默认模块通常会根据Kubernetes版本而变化。云基Kubernetes解决方案的提供商，如亚马逊网络服务（AWS）、谷歌和Azure，控制着默认可以启用哪些插件。集群管理员还可以在初始化API服务器时决定启用或禁用哪些模块。通过使用“--enable-admission-plugins”标志，管理员可以控制除默认模块之外应启用哪些模块。另一方面，“--disable-admission-plugins”标志控制默认模块中应禁用哪些模块。
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will learn more about admission controllers, including creating custom ones,
    in *Chapter 16*, *Kubernetes Admission Controllers*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在第16章“Kubernetes准入控制器”中学习更多关于准入控制器的知识，包括创建自定义准入控制器。
- en: As you will recall from *Chapter 2*, *An Overview of Kubernetes*, when we created
    a cluster using the `minikube start` command, Minikube enabled several modules
    for us by default. Let's take a closer look at that in the next exercise in which
    we will not only view the different API modules enabled for us by default but
    also start Minikube with a custom set of modules.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在第2章“Kubernetes概述”中所记得的，当我们使用“minikube start”命令创建集群时，Minikube默认为我们启用了几个模块。让我们在下一个练习中更仔细地看一下这一点，我们不仅会查看默认情况下为我们启用的不同API模块，还会使用自定义的模块启动Minikube。
- en: 'Exercise 4.01: Starting Minikube with a Custom Set of Modules'
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.01：使用自定义模块启动Minikube
- en: 'In this exercise, we will take a look at how to view the different API modules
    enabled for our instance of Minikube, and then restart Minikube using a custom
    set of API modules:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看一下如何查看我们的Minikube实例启用的不同API模块，然后使用自定义的API模块重新启动Minikube：
- en: 'If Minikube is not already running on your machine, start it up by using the
    following command:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Minikube尚未在您的计算机上运行，请使用以下命令启动它：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should see the following response:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 4.7: Starting up Minikube'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7：启动Minikube'
- en: '](image/B14870_04_07.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_07.jpg)'
- en: 'Figure 4.7: Starting up Minikube'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：启动Minikube
- en: 'Now, let''s see which modules are enabled by default. Use the following command:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看默认情况下启用了哪些模块。使用以下命令：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should see the following response:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 4.8: Default modules enabled in Minikube'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8：Minikube中默认启用的模块'
- en: '](image/B14870_04_08.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_08.jpg)'
- en: 'Figure 4.8: Default modules enabled in Minikube'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：Minikube中默认启用的模块
- en: 'As you can observe from the preceding output, Minikube has enabled the following
    modules for us: `NamespaceLifecycle`, `LimitRanger`, `ServiceAccount`, `DefaultStorageClass`,
    `DefaultTolerationSeconds`, `NodeRestriction`, `MutatingAdmissionWebhook`, `ValidatingAdmissionWebhook`,
    and `ResourceQuota`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以从前面的输出中观察到的，Minikube已为我们启用了以下模块：`NamespaceLifecycle`、`LimitRanger`、`ServiceAccount`、`DefaultStorageClass`、`DefaultTolerationSeconds`、`NodeRestriction`、`MutatingAdmissionWebhook`、`ValidatingAdmissionWebhook`和`ResourceQuota`。
- en: Note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To know more about modules, please refer the following link: [https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/
    )'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于模块的信息，请参考以下链接：[https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/
    )
- en: 'Another way to check the modules is to view the API server manifest by running
    the following command:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种检查模块的方法是查看API服务器清单，方法是运行以下命令：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We used `grep -vi deprecated` because there is another flag, `--admission-control`,
    that we are discarding from the output, as this flag will be deprecated in future
    versions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`grep -vi deprecated`，因为还有另一个标志`--admission-control`，我们正在从输出中丢弃，因为该标志将在将来的版本中被弃用。
- en: 'kubectl has the `exec` command, which allows us to execute a command to our
    running pods. This command will execute `kube-apiserver -h` inside our `kube-apiserver-minikube`
    pod and return the output to our shell:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl有`exec`命令，允许我们对正在运行的pod执行命令。该命令将在`kube-apiserver-minikube` pod内执行`kube-apiserver
    -h`命令，并将输出返回到我们的shell：
- en: '![Figure 4.9: Checking the modules enabled by default in Minikube'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9：检查Minikube中默认启用的模块'
- en: '](image/B14870_04_09.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_09.jpg)'
- en: 'Figure 4.9: Checking the modules enabled by default in Minikube'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：检查Minikube中默认启用的模块
- en: 'Now, we will start Minikube with our desired configuration. Use the following
    command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用我们期望的配置启动Minikube。使用以下命令：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see here, the `minikube start` command has the `--extra-config`
    configurator flag, which allows us to pass additional configurations to our cluster
    installation. In our case, we can use the `--extra-config` flag, along with `--enable-admission-plugins`,
    and specify the plugins we need to enable. Our command should produce this output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此处所见，`minikube start`命令具有`--extra-config`配置器标志，允许我们向集群安装传递附加配置。在我们的情况下，我们可以使用`--extra-config`标志，以及`--enable-admission-plugins`，并指定我们需要启用的插件。我们的命令应该产生这样的输出：
- en: '![Figure 4.10: Restarting Minikube with a custom set of modules'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.10：使用自定义模块重新启动Minikube'
- en: '](image/B14870_04_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_10.jpg)'
- en: 'Figure 4.10: Restarting Minikube with a custom set of modules'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10：使用自定义模块重新启动Minikube
- en: 'Now, let''s compare this instance of Minikube with our earlier one. Use the
    following command:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将此Minikube实例与我们之前的实例进行比较。使用以下命令：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see the following response:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 4.11: Checking a custom set of modules for Minikube'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.11：检查Minikube的自定义模块集'
- en: '](image/B14870_04_11.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_11.jpg)'
- en: 'Figure 4.11: Checking a custom set of modules for Minikube'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：检查Minikube的自定义模块集
- en: If you compare the set of modules seen here to the ones in *Figure 4.7*, you
    will notice that only the specified plugins were enabled; while the `DefaultTolerationSeconds`,
    `NodeRestriction`, and `ValidatingAdmissionWebhook` modules are no longer enabled.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将此处看到的模块集与*图4.7*中的模块集进行比较，您会注意到只启用了指定的插件；而`DefaultTolerationSeconds`、`NodeRestriction`和`ValidatingAdmissionWebhook`模块不再启用。
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can revert to the default configurations in Minikube by running `minikube
    start` again.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过再次运行`minikube start`来恢复Minikube中的默认配置。
- en: Validation
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证
- en: After letting the request pass through all three stages, the API server then
    validates the object—that is, it checks whether the object specification, which
    is carried in JSON format in the response body, meets the required format and
    standard.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在让请求通过所有三个阶段之后，API服务器然后验证对象——也就是说，它检查响应主体中以JSON格式携带的对象规范是否符合所需的格式和标准。
- en: After successful validation, the API server stores the object in the etcd datastore
    and returns a response to the client. After that, as you learned in *Chapter 2*,
    *An Overview of Kubernetes*, other components, such as the scheduler and the controller
    manager, take over to find a suitable node and actually implement the object on
    your cluster.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 成功验证后，API服务器将对象存储在etcd数据存储中，并向客户端返回响应。之后，正如您在*第2章*中学到的* Kubernetes概述*中所了解的那样，其他组件，如调度程序和控制器管理器，接管了寻找合适的节点并实际在集群上实现对象。
- en: The Kubernetes API
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes API
- en: The Kubernetes API uses JSON over HTTP for its requests and responses. It follows
    the REST architectural style. You can use the Kubernetes API to read and write
    Kubernetes resource objects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API使用JSON over HTTP进行请求和响应。它遵循REST架构风格。您可以使用Kubernetes API来读取和编写Kubernetes资源对象。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more details about the RESTful API, please refer to [https://restfulapi.net/](https://restfulapi.net/).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有关RESTful API的更多详细信息，请参阅[https://restfulapi.net/](https://restfulapi.net/)。
- en: 'Kubernetes API allows clients to create, update, delete, or read a description
    of an object via standard HTTP methods (or HTTP verbs), such as the examples in
    the following table:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API允许客户端通过标准HTTP方法（或HTTP动词）创建、更新、删除或读取对象的描述，例如以下表中的示例：
- en: '![Figure 4.12: HTTP verbs and their usage'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.12：HTTP动词及其用法'
- en: '](image/B14870_04_12.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_12.jpg)'
- en: 'Figure 4.12: HTTP verbs and their usage'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：HTTP动词及其用法
- en: 'In the context of Kubernetes API calls, it is helpful to understand how these
    HTTP methods map to API request verbs. So, let''s take a look at which verbs are
    sent through which methods:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes API调用的上下文中，了解这些HTTP方法如何映射到API请求动词是有帮助的。因此，让我们看看哪些动词通过哪些方法发送：
- en: '`GET`: `get`, `list`, and `watch`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：`get`、`list`和`watch`'
- en: Some example kubectl commands are `kubectl get pod`, `kubectl describe pod <pod-name>`,
    and `kubectl get pod -w`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例kubectl命令是`kubectl get pod`、`kubectl describe pod <pod-name>`和`kubectl get
    pod -w`。
- en: '`POST`: `create`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：`create`'
- en: An example kubectl command is `kubectl create -f <filename.yaml>`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例kubectl命令是`kubectl create -f <filename.yaml>`。
- en: '`PATCH`: `patch`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：`patch`'
- en: An example kubectl command is `kubectl set image deployment/kubeserve nginx=nginx:1.9.1`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例kubectl命令是`kubectl set image deployment/kubeserve nginx=nginx:1.9.1`。
- en: '`DELETE`: `delete`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：`delete`'
- en: An example kubectl command is `kubectl delete pod <pod-name>`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例kubectl命令是`kubectl delete pod <pod-name>`。
- en: '`PUT`: `update`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：`update`'
- en: An example kubectl command is `kubectl apply -f <filename.yaml>`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例kubectl命令是`kubectl apply -f <filename.yaml>`。
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you have not encountered these commands yet, you will in the upcoming chapters.
    Feel free to refer back to this chapter or the following Kubernetes documentation
    to find out how each API request works for any command: [https://kubernetes.io/docs/reference/kubernetes-api/](https://kubernetes.io/docs/reference/kubernetes-api/).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有遇到这些命令，您将在接下来的章节中遇到。随时参考本章节或以下 Kubernetes 文档，了解每个命令的 API 请求如何工作：[https://kubernetes.io/docs/reference/kubernetes-api/](https://kubernetes.io/docs/reference/kubernetes-api/)。
- en: As mentioned earlier, these API calls carry JSON data, and all of them have
    a JSON schema identified by the `Kind` and `apiVersion` fields. `Kind` is a string
    that identifies the type of JSON schema that an object should have, and `apiVersion`
    is a string that identifies the version of the JSON schema the object should have.
    The next exercise should give you a better idea about this.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些 API 调用携带 JSON 数据，所有这些数据都有一个由 `Kind` 和 `apiVersion` 字段标识的 JSON 模式。`Kind`
    是一个字符串，用于标识对象应该具有的 JSON 模式类型，而 `apiVersion` 是一个字符串，用于标识对象应该具有的 JSON 模式版本。下一个练习应该让您更好地了解这一点。
- en: You can refer to the Kubernetes API reference documentation to see the different
    HTTP methods in action, at [https://kubernetes.io/docs/reference/kubernetes-api/](https://kubernetes.io/docs/reference/kubernetes-api/).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考 Kubernetes API 参考文档，查看不同的 HTTP 方法的实际操作，网址为 [https://kubernetes.io/docs/reference/kubernetes-api/](https://kubernetes.io/docs/reference/kubernetes-api/)。
- en: 'For example, if you need to create a Deployment in a specific namespace, under
    `WORKLOADS APIS`, you can navigate to `Deployment v1 apps` > `Write Operations`
    > `Create`. You will see the HTTP request and different examples using `kubectl`
    or `curl`. The following page from the API reference docs should give you an idea
    of how to use this reference:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您需要在特定命名空间下创建一个 Deployment，在 `WORKLOADS APIS` 下，您可以转到 `Deployment v1 apps`
    > `Write Operations` > `Create`。您将看到使用 `kubectl` 或 `curl` 的 HTTP 请求和不同的示例。API
    参考文档的以下页面应该让您了解如何使用此参考文档：
- en: '![Figure 4.13: HTTP request for the kubectl create command'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.13：kubectl create 命令的 HTTP 请求'
- en: '](image/B14870_04_13.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_13.jpg)'
- en: 'Figure 4.13: HTTP request for the kubectl create command'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13：kubectl create 命令的 HTTP 请求
- en: You will need to keep the version of your API server in mind when you refer
    to the previously mentioned documentation. You can find your Kubernetes API server
    version by running `kubectl version --short` command and looking for `Server Version`.
    For example, if your Kubernetes API server version is running version 1.14, you
    should navigate to the Kubernetes version 1.14 reference documentation ([https://v1-14.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/](https://v1-14.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/))
    to look up the relevant API information.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当您参考前面提到的文档时，需要牢记您的 API 服务器版本。您可以通过运行 `kubectl version --short` 命令并查找 `Server
    Version` 来找到您的 Kubernetes API 服务器版本。例如，如果您的 Kubernetes API 服务器版本运行的是 1.14 版本，您应该转到
    Kubernetes 版本 1.14 参考文档 ([https://v1-14.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/](https://v1-14.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/))
    查找相关的 API 信息。
- en: The best way to understand this is by tracing a `kubectl` command. Let's do
    exactly that in the following section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点的最佳方法是跟踪 `kubectl` 命令。让我们在接下来的部分中做到这一点。
- en: Tracing kubectl HTTP Requests
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪 kubectl 的 HTTP 请求
- en: 'Let''s try tracing the HTTP requests that kubectl sends to the API server to
    better understand them. Before we begin, let''s get all the pods in the `kube-system`
    namespace by using the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试跟踪 kubectl 发送到 API 服务器的 HTTP 请求，以更好地理解它们。在开始之前，让我们使用以下命令获取 `kube-system`
    命名空间中的所有 pod：
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This command should display the output in a table view, as you can see in the
    following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应该以表格视图显示输出，如下面的屏幕截图所示：
- en: '![Figure 4.14: Getting the list of pods in the kube-system namespace'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.14：获取kube-system命名空间中pod的列表'
- en: '](image/B14870_04_14.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_14.jpg)'
- en: 'Figure 4.14: Getting the list of pods in the kube-system namespace'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：获取kube-system命名空间中pod的列表
- en: Behind the scenes, since kubectl is a REST client, it invokes an HTTP `GET`
    request to the API server endpoint and requests information from `/api/v1/namespaces/kube-system/pods`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，由于kubectl是一个REST客户端，它会调用HTTP `GET`请求到API服务器端点，并从`/api/v1/namespaces/kube-system/pods`请求信息。
- en: 'We can enable verbose output by adding `--v=8` to our `kubectl` command. `v`
    indicates the verbosity of the command. The higher the number, the more details
    we get in the response. This number can range from `0` to `10`. Let''s see the
    output with verbosity of `8`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`kubectl`命令中添加`--v=8`来启用详细输出。`v`表示命令的详细程度。数字越高，响应中的细节就越多。这个数字可以从`0`到`10`。让我们看看详细程度为`8`的输出：
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This should give output as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给出以下输出：
- en: '![Figure 4.15: Output of a get pods command with a verbosity of 8'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.15：详细程度为8的get pods命令的输出'
- en: '](image/B14870_04_15.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_15.jpg)'
- en: 'Figure 4.15: Output of a get pods command with a verbosity of 8'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15：详细程度为8的get pods命令的输出
- en: 'Let''s examine the preceding output bit by bit to get a better understanding
    of it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个检查前面的输出，以更好地理解它：
- en: 'The first part of the output is as follows:![Figure 4.16: Part of the output
    indicating the loading of the config file'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出的第一部分如下：![图4.16：输出的一部分指示配置文件的加载
- en: '](image/B14870_04_16.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_16.jpg)'
- en: 'Figure 4.16: Part of the output indicating the loading of the config file'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16：输出的一部分指示配置文件的加载
- en: From this, we can see that kubectl loaded the configuration from our kubeconfig
    file, which has the API server endpoint, port, and credentials, such as the certificate
    or the authentication token.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以看到，kubectl从我们的kubeconfig文件中加载了配置，其中包括API服务器端点、端口和凭据，如证书或身份验证令牌。
- en: 'This is the next part of the output:![Figure 4.17: Part of the output indicating
    the HTTP GET request'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是输出的下一部分：![图4.17：输出的一部分指示HTTP GET请求
- en: '](image/B14870_04_17.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_17.jpg)'
- en: 'Figure 4.17: Part of the output indicating the HTTP GET request'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17：输出的一部分指示HTTP GET请求
- en: In this, you can see the `HTTP GET` request mentioned as `GET https://192.168.99.100:8443/api/v1/namespaces/kube-system/pods?limit=500`.
    This line contains the operation that we need to perform against the API server,
    and `/api/v1/namespaces/kube-system/pods` is the API path. You can also see `limit=500`
    at the end of the URL path, which is the chunk size; kubectl fetches a large number
    of resources in chunks to improve latency. We will see some examples relating
    to retrieving large results sets in chunks later in this chapter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到将`HTTP GET`请求提及为`GET https://192.168.99.100:8443/api/v1/namespaces/kube-system/pods?limit=500`。这一行包含了我们需要针对API服务器执行的操作，`/api/v1/namespaces/kube-system/pods`是API路径。您还可以在URL路径的末尾看到`limit=500`，这是块大小；kubectl以块的形式获取大量资源，以提高延迟。我们将在本章后面看到一些关于以块检索大型结果集的示例。
- en: 'The next part of the output is as follows:![Figure 4.18: Part of the output
    indicating request headers'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出的下一部分如下：![图4.18：输出的一部分指示请求头
- en: '](image/B14870_04_18.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_18.jpg)'
- en: 'Figure 4.18: Part of the output indicating request headers'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18：输出的一部分指示请求头
- en: 'As you can see in this part of the output, `Request Headers` describes the
    resource to be fetched or the client requesting the resource. In our example,
    the output has two parts for content negotiation:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出的这部分可以看出，`请求头`描述了要获取的资源或请求资源的客户端。在我们的示例中，输出有两部分内容协商：
- en: 'a) `Accept`: This is used by HTTP clients to tell the server what content types
    they''ll accept. In our example, we can see that kubectl informed the API server
    about the `application/json` content type. If this does not exist in the request
    header, the server will return the default preconfigured representation type,
    which is the same as `application/json` for the Kubernetes API as it uses the
    JSON schema. We can also see that it is requesting the output as a table view,
    which is indicated by `as=Table` in this line.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: a) `Accept`：这是由HTTP客户端使用的，告诉服务器它们将接受什么内容类型。在我们的示例中，我们可以看到kubectl通知API服务器有关“application/json”内容类型。如果请求标头中不存在这个内容类型，服务器将返回默认的预配置表示类型，这与Kubernetes
    API的JSON模式相同，即“application/json”。我们还可以看到它正在请求以表格视图输出，这在这一行中由“as=Table”表示。
- en: 'b) `User-Agent`: This header contains information about the client that is
    requesting this information. In this case, we can see that kubectl is providing
    information about itself.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: b) `User-Agent`：此标头包含有关请求此信息的客户端的信息。在这种情况下，我们可以看到kubectl正在提供有关自身的信息。
- en: 'Let''s examine the next part:![Figure 4.19: Part of the output indicating the
    response status'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们来检查下一部分：![图4.19：显示响应状态的部分输出
- en: '](image/B14870_04_19.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_19.jpg)'
- en: 'Figure 4.19: Part of the output indicating the response status'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19：显示响应状态的部分输出
- en: Here, we can see that the API server returns the `200 OK` HTTP status code,
    which indicates that the request has been processed successfully on the API server.
    We can also see the time taken to process this request, which is 10 milliseconds.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到API服务器返回了“200 OK”HTTP状态代码，这表明请求已在API服务器上成功处理。我们还可以看到处理此请求所花费的时间，为10毫秒。
- en: 'Let''s look at the next part:![Figure 4.20: Part of the output indicating the
    response headers'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们来看下一部分：![图4.20：显示响应头的部分输出
- en: '](image/B14870_04_20.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_20.jpg)'
- en: 'Figure 4.20: Part of the output indicating the response headers'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20：显示响应头的部分输出
- en: As you can see, this part shows the `Response Headers`, which include details
    such as the date and time of the request, in our example.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这部分显示了“响应头”，其中包括请求的日期和时间等详细信息，在我们的示例中。
- en: 'Now, let''s come to the main response sent by the API server:![Figure 4.21:
    Part of the output indicating the response body'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下API服务器发送的主要响应：![图4.21：显示响应主体的部分输出
- en: '](image/B14870_04_21.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_21.jpg)'
- en: 'Figure 4.21: Part of the output indicating the response body'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21：显示响应主体的部分输出
- en: The `Response Body` contains the resource data that was requested by the client.
    In our case, this is information about the pods in the `kube-system` namespace.
    Here, this information is in raw JSON format before kubectl can present it as
    a neat table. However, the highlighted section at the end of the previous screenshot
    shows that the response body does not have all the JSON output that we requested;
    part of the `Response Body` is truncated. This is because `--v=8` displays the
    HTTP request content with truncation of the response content.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: “响应主体”包含客户端请求的资源数据。在我们的案例中，这是有关“kube-system”命名空间中的pod的信息。在这里，这些信息以原始JSON格式呈现，然后kubectl可以将其呈现为整齐的表格。然而，前一个屏幕截图的突出显示部分显示，响应主体并没有我们请求的所有JSON输出；部分“响应主体”被截断了。这是因为“--v=8”显示了带有截断响应内容的HTTP请求内容。
- en: 'To see the full response body, you can run the same command with `--v=10`,
    which does not truncate the output at all. The command would look like as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的响应主体，您可以使用`--v=10`运行相同的命令，这样就不会截断输出。命令将如下所示：
- en: '[PRE10]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will not examine the command with `--v=10` verbosity for the sake of brevity.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 出于简洁起见，我们将不会检查使用`--v=10`详细程度的命令。
- en: 'Now, we come to the final part of the output that we are examining:![Figure
    4.22: Part of the output indicating the final result'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们来到了我们正在检查的输出的最后部分：![图4.22：输出的一部分，显示最终结果
- en: '](image/B14870_04_22.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_22.jpg)'
- en: 'Figure 4.22: Part of the output indicating the final result'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22：输出的一部分，显示最终结果
- en: This is the final output as a table, which is what was requested. kubectl has
    taken the raw JSON data and formatted it as a neat table for us.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个表格形式的最终输出，这也是请求的内容。kubectl已经将原始的JSON数据格式化为一个整洁的表格。
- en: Note
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about kubectl verbosity and debugging flags at [https://kubernetes.io/docs/reference/kubectl/cheatsheet/#kubectl-output-verbosity-and-debugging](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#kubectl-output-verbosity-and-debugging).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://kubernetes.io/docs/reference/kubectl/cheatsheet/#kubectl-output-verbosity-and-debugging](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#kubectl-output-verbosity-and-debugging)了解更多关于kubectl冗长度和调试标志的信息。
- en: API Resource Type
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API资源类型
- en: 'In the previous section, we saw that the HTTP URL was made up of an API resource,
    API group, and API version. Now, let''s learn about the resource type defined
    in the URL, such as pods, namespaces, and services. In JSON form, this is called
    `Kind`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到HTTP URL由API资源、API组和API版本组成。现在，让我们了解URL中定义的资源类型，比如pods、namespaces和services。在JSON格式中，这被称为`Kind`：
- en: '**Collection of resource**: This represents a collection of instances for a
    resource type, such as all pods in all namespaces. In a URL, this would be as
    follows:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源的集合**：这代表了资源类型的所有实例的集合，比如所有命名空间中的所有pods。在URL中，这将如下所示：'
- en: '[PRE11]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Single resource**: This represents a single instance of a resource type,
    such as retrieving details of a specific pod in a given namespace. The URL for
    this case would be as follows:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单个资源**：这代表了资源类型的单个实例，比如在给定命名空间中检索特定pod的详细信息。这种情况下的URL将如下所示：'
- en: '[PRE12]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have learned about various aspects of a request made to the API
    server, let's learn about the scope of API resources in the next section.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了向API服务器发出请求的各个方面，让我们在下一节了解API资源的范围。
- en: Scope of API Resources
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API资源的范围
- en: All resource types can either be cluster-scoped resources or namespace-scoped
    resources. The scope of a resource affects the access of that resource and how
    that resource is managed. Let's look at the differences between namespace and
    cluster scope.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 所有资源类型可以是集群范围的资源或命名空间范围的资源。资源的范围会影响对该资源的访问以及该资源的管理方式。让我们来看看命名空间和集群范围之间的区别。
- en: Namespace-Scoped Resources
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间范围的资源
- en: As we saw in *Chapter 2*, *An Overview of Kubernetes*, Kubernetes makes use
    of Linux namespaces to organize most Kubernetes resources. Resources in the same
    namespace share the same control access policies and authorization checks. When
    a namespace is deleted, all resources in that namespace are also deleted.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第2章*中看到的，*Kubernetes概述*，Kubernetes利用Linux命名空间来组织大多数Kubernetes资源。同一命名空间中的资源共享相同的控制访问策略和授权检查。当一个命名空间被删除时，该命名空间中的所有资源也会被删除。
- en: 'Let''s see what forms the request paths for interacting with namespace-scoped
    resources take:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看与命名空间范围的资源交互的请求路径是什么样的：
- en: 'Return the information about a specific pod in a namespace:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回命名空间中特定pod的信息：
- en: '[PRE13]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Return the information about a collection of all Deployments in a namespace:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回命名空间中所有Deployments的集合的信息：
- en: '[PRE14]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Return the information about all instances of the resource type (in this case,
    services) across all namespaces:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回关于资源类型的所有实例的信息（在本例中为services），跨所有命名空间：
- en: '[PRE15]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that when we are looking for information against all namespaces, it will
    not have `namespace` in the URL.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们在所有命名空间中查找信息时，URL中将不会有`namespace`。
- en: 'You can get a full list of namespace-scoped API resources by using the following
    command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令获取命名空间范围API资源的完整列表：
- en: '[PRE16]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should see a response similar to this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于这样的响应：
- en: '![Figure 4.23: Listing out all the namespace-scoped resources'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.23：列出所有命名空间范围资源'
- en: '](image/B14870_04_23.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_23.jpg)'
- en: 'Figure 4.23: Listing out all the namespace-scoped resources'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23：列出所有命名空间范围资源
- en: Cluster-Scoped Resources
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集群范围资源
- en: Most Kubernetes resources are namespace-scoped, but the namespace resource itself
    is not namespace-scoped. Resources that are not scoped within namespaces are cluster-scoped.
    Other examples of cluster-scoped resources are nodes. Since a node is cluster-scoped,
    you can deploy a pod on the desired node regardless of what namespace you want
    the pod to be in, and a node can host different pods from different namespaces.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Kubernetes资源是命名空间范围的，但命名空间资源本身不是命名空间范围的。不在命名空间范围内的资源是集群范围的。集群范围资源的其他示例是节点。由于节点是集群范围的，您可以在所需的节点上部署一个pod，而不管您希望pod在哪个命名空间，一个节点可以托管来自不同命名空间的不同pod。
- en: 'Let''s see how the request paths for interacting with cluster-scoped resources
    look:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看与集群范围资源交互的请求路径是什么样的：
- en: 'Return the information about a specific node in the cluster:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回集群中特定节点的信息：
- en: '[PRE17]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Return the information of all instances of the resource type (in this case,
    nodes) in the cluster:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回集群中资源类型的所有实例的信息（在本例中是节点）：
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can get a full list of cluster-scoped API resources by using the following
    command:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令获取集群范围API资源的完整列表：
- en: '[PRE19]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should see an output similar to this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于这样的输出：
- en: '![Figure 4.24: Listing out all cluster-scoped resources'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.24：列出所有集群范围资源'
- en: '](image/B14870_04_24.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_24.jpg)'
- en: 'Figure 4.24: Listing out all cluster-scoped resources'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24：列出所有集群范围资源
- en: API Groups
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API组
- en: 'An API group is a collection of resources that are logically related to each
    other. For example, Deployments, ReplicaSets, and DaemonSets all belong to the
    apps API group: `apps/v1`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: API组是逻辑相关的资源的集合。例如，部署、副本集和守护进程集都属于apps API组：`apps/v1`。
- en: Note
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will learn about Deployments, ReplicaSets, and DaemonSets in detail in *Chapter
    7*, *Kubernetes Controllers*. In fact, this chapter will talk about many API resources
    that you will encounter in later chapters.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在*第7章*，*Kubernetes Controllers*中详细了解部署、副本集和守护进程集。事实上，本章将讨论您将在后续章节中遇到的许多API资源。
- en: The `--api-group` flag can be used to scope the output to a specific API group,
    as we will see in the following sections. Let's take a closer look at the various
    API groups in the following sections.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`--api-group`标志可用于将输出范围限定到特定的API组，我们将在接下来的章节中看到。让我们在接下来的章节中更仔细地看看各种API组。'
- en: Core Group
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心组
- en: 'This is also called the legacy group. It contains objects such as pods, services,
    nodes, and namespaces. The URL path for these is `/api/v1`, and nothing other
    than the version is specified in the `apiVersion` field. For example, consider
    the following screenshot where we are getting information about a pod:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这也被称为传统组。它包含诸如pod、服务、节点和命名空间等对象。这些的URL路径是`/api/v1`，`apiVersion`字段中只指定版本。例如，考虑以下截图，我们正在获取有关一个pod的信息：
- en: '![Figure 4.25: API group of a pod'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.25：一个pod的API组'
- en: '](image/B14870_04_25.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_25.jpg)'
- en: 'Figure 4.25: API group of a pod'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.25：一个pod的API组
- en: 'As you can see here, the `apiVersion: v1` field indicates that this resource
    belongs to the core group.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '正如您在这里看到的，`apiVersion: v1`字段表示此资源属于核心组。'
- en: 'Resources showing a blank entry in the `kubectl api-resources` command output
    are part of the core group. You can also specify an empty argument flag (`--api-group=''''`)
    to only display the core group resources, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在`kubectl api-resources`命令输出中显示空条目的资源属于核心组。您还可以指定一个空参数标志（`--api-group=''`）来仅显示核心组资源，如下所示：
- en: '[PRE20]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should see an output as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 4.26: Listing out the resources in the core API group'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.26：列出核心API组中的资源'
- en: '](image/B14870_04_26.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_26.jpg)'
- en: 'Figure 4.26: Listing out the resources in the core API group'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.26：列出核心API组中的资源
- en: Named Group
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名组
- en: 'This group includes objects for whom the request URL is in the `/apis/$NAME/$VERSION`
    format. Unlike the core group, named groups contain the group name in the URL.
    For example, let''s consider the following screenshot where we have information
    about a Deployment:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 该组包括请求URL格式为`/apis/$NAME/$VERSION`的对象。与核心组不同，命名组在URL中包含组名。例如，让我们考虑以下屏幕截图，其中我们有有关部署的信息：
- en: '![Figure 4.27: The API group of a Deployment'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.27：部署的API组'
- en: '](image/B14870_04_27.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_27.jpg)'
- en: 'Figure 4.27: The API group of a Deployment'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.27：部署的API组
- en: 'As you can see, the highlighted field showing `apiVersion: apps/v1` indicates
    that this resource belongs to the `apps` API group.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '正如您所看到的，突出显示的字段显示`apiVersion: apps/v1`，表明此资源属于`apps`API组。'
- en: 'You can also specify the `--api-group=''<NamedGroup Name>''` flag to display
    the resources in that specified named group. For example, let''s list out the
    resources under the `apps` API group by using the following command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定`--api-group='<NamedGroup Name>'`标志来显示指定命名组中的资源。例如，让我们使用以下命令列出`apps`API组中的资源：
- en: '[PRE21]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This should give the following response:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生以下响应：
- en: '![Figure 4.28: Listing out the resources in the apps API group'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.28：列出apps API组中的资源'
- en: '](image/B14870_04_28.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_28.jpg)'
- en: 'Figure 4.28: Listing out the resources in the apps API group'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.28：列出apps API组中的资源
- en: All of these resources in the preceding screenshot are clubbed together because
    they are part of the `apps` named group, which we specified in our query command.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述屏幕截图中，所有这些资源都被合并在一起，因为它们都属于我们在查询命令中指定的`apps`命名组。
- en: 'As another example, let''s look at the `rbac.authorization.k8s.io API group`,
    which has resources to determine authorization policies. We can look at the resources
    in that group by using the following command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，让我们看一下`rbac.authorization.k8s.io API组`，该组具有确定授权策略的资源。我们可以使用以下命令查看该组中的资源：
- en: '[PRE22]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should see the following response:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 4.29: Listing out the resources in the rbac.authorization.k8s.io API
    group'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.29：列出rbac.authorization.k8s.io API组中的资源'
- en: '](image/B14870_04_29.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_29.jpg)'
- en: 'Figure 4.29: Listing out the resources in the rbac.authorization.k8s.io API
    group'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.29：列出rbac.authorization.k8s.io API组中的资源
- en: System-Wide
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统范围
- en: 'This group consists of system-wide API endpoints, such as `/version`, `/healthz`,
    `/logs`, and `/metrics`. For example, let''s consider the output of the following
    command:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 该组包括系统范围的API端点，例如`/version`、`/healthz`、`/logs`和`/metrics`。例如，让我们考虑以下命令的输出：
- en: '[PRE23]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This should give an output similar to this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生类似于以下内容的输出：
- en: '![Figure 4.30: Request URL for the kubectl version command'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.30：kubectl版本命令的请求URL'
- en: '](image/B14870_04_30.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_30.jpg)'
- en: 'Figure 4.30: Request URL for the kubectl version command'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.30：kubectl版本命令的请求URL
- en: As you can see in this screenshot, when you run `kubectl --version`, this goes
    to the `/version special entity`, as seen in the `GET` request URL.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在此屏幕截图中所看到的，当您运行`kubectl --version`时，这将转到`/version特殊实体`，如`GET`请求URL中所示。
- en: API Versions
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API版本
- en: In the Kubernetes API, there is the concept of API versioning; that is, the
    Kubernetes API supports multiple versions of a type of resource. These different
    versions may act differently. Each one has a different API path, such as `/api/v1`
    or `/apis/extensions/v1beta1`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes API中，存在API版本控制的概念；也就是说，Kubernetes API支持一种资源类型的多个版本。这些不同版本可能会有不同的行为。每个版本都有不同的API路径，例如`/api/v1`或`/apis/extensions/v1beta1`。
- en: 'The different API versions differ in terms of stability and support:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的API版本在稳定性和支持方面有所不同：
- en: '**Alpha**: This version is indicated by `alpha` in the `apiVersion` field—for
    example, `/apis/batch/v1alpha1`. The alpha version of resources is disabled by
    default as it is not intended for production clusters but can be used by early
    adopters and developers who are willing to provide feedback and suggestions and
    report bugs. Also, support for alpha resources may be dropped without notice by
    the time the final stable version of Kubernetes is finalized.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Alpha**：此版本在`apiVersion`字段中以`alpha`表示，例如`/apis/batch/v1alpha1`。默认情况下禁用资源的alpha版本，因为它不适用于生产集群，但可以供早期采用者和愿意提供反馈和建议并报告错误的开发人员使用。此外，alpha资源的支持可能会在Kubernetes的最终稳定版本确定时被取消，而无需事先通知。'
- en: '**Beta**: This version is indicated by `beta` in the `apiVersion` field—for
    example, `/apis/certificates.k8s.io/v1beta1`. The beta version of resources is
    enabled by default, and the code behind it is well tested. However, using it is
    recommended for scenarios that are not business-critical because it is possible
    that changes in subsequent releases may reduce incompatibilities; that is, some
    features may not be supported for a long time.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Beta**：此版本在`apiVersion`字段中以`beta`表示，例如`/apis/certificates.k8s.io/v1beta1`。默认情况下启用资源的beta版本，并且其背后的代码经过了充分测试。然而，建议仅在非业务关键场景下使用，因为可能会在后续版本中进行更改，导致不兼容性；也就是说，某些功能可能不会长时间得到支持。'
- en: '**Stable**: For these versions, the `apiVersion` field just contains the version
    number without any mention of `alpha` or `beta`—for example, `/apis/networking.k8s.io/v1`.
    The Stable version of resources is supported for many subsequent versions releases
    of Kubernetes. So, this version of API resources is recommended for any critical
    use cases.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳定**：对于这些版本，`apiVersion`字段只包含版本号，没有提及`alpha`或`beta`，例如`/apis/networking.k8s.io/v1`。稳定版本的资源在Kubernetes的许多后续版本中得到支持。因此，建议在任何关键用例中使用此版本的API资源。'
- en: 'You can get a complete list of the API versions enabled in your cluster by
    using the following command:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令获取集群中启用的API版本的完整列表：
- en: '[PRE24]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You should see a response similar to this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于以下内容的响应：
- en: '![Figure 4.31: List of enabled versions of API resources'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.31：已启用的API资源版本列表'
- en: '](image/B14870_04_31.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: （图像/B14870_04_31.jpg）
- en: 'Figure 4.31: List of enabled versions of API resources'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.31：已启用的API资源版本列表
- en: An interesting thing that you may observe in this screenshot is that some API
    resources, such as `autoscaling`, have multiple versions; for example, for `autoscaling`,
    there is `v1beta1`, `v1beta2`, and `v1`. So, what is the difference between them
    and which one should you use?
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在此截图中，您可能会注意到一件有趣的事情，即某些API资源（例如`autoscaling`）具有多个版本；例如，对于`autoscaling`，有`v1beta1`、`v1beta2`和`v1`。那么，它们之间有什么区别，应该使用哪个版本呢？
- en: Let's again consider the example of `autoscaling`. This feature allows you to
    scale the number of pods in a replication controller, such as Deployments, ReplicaSets,
    or StatefulSets, based on specific metrics. For example, you can autoscale the
    number of pods from 3 to 10 if the average CPU load exceeds 50%.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次考虑`autoscaling`的例子。此功能允许您根据特定指标扩展副本控制器（例如Deployments、ReplicaSets或StatefulSets）中的Pod数量。例如，如果平均CPU负载超过50％，则可以将Pod的数量从3个扩展到10个。
- en: In this case, the difference in the versions is that of feature support. The
    Stable release for autoscaling is `autoscaling/v1`, which only supports scaling
    the number of pods based on the average CPU metric. The beta release for autoscaling,
    which is `autoscaling/v2beta1`, supports scaling based on CPU and memory utilization.
    The newer version in the beta release, which is `autoscaling/v2beta2`, supports
    scaling the number of pods based on custom metrics in addition to CPU and memory.
    However, since the beta release is still not meant to be used for business-critical
    scenarios when you create an autoscaling resource, it will use the `autoscaling/v1`
    version. However, you can still use other versions to use additional features
    by specifying the beta version in the YAML file until the required features are
    added to the stable release.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，版本之间的差异是功能支持。自动缩放的稳定版本是`autoscaling/v1`，它仅支持根据平均CPU指标缩放pod的数量。自动缩放的beta版本是`autoscaling/v2beta1`，支持根据CPU和内存利用率进行缩放。beta版本中的新版本是`autoscaling/v2beta2`，支持根据自定义指标以及CPU和内存进行缩放pod的数量。然而，由于beta版本仍不适用于业务关键场景，当您创建自动缩放资源时，它将使用`autoscaling/v1`版本。但是，您仍然可以通过在YAML文件中指定beta版本来使用其他版本以使用附加功能，直到所需功能添加到稳定版本为止。
- en: All of this information can seem overwhelming. However, Kubernetes provides
    ways to access all the information you need to navigate your way around the API
    resources. You can use kubectl to access the Kubernetes docs and get the necessary
    information about the various API resources. Let's see how that works in the following
    exercise.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息可能看起来令人不知所措。然而，Kubernetes提供了访问所有您需要导航API资源的信息的方法。您可以使用kubectl访问Kubernetes文档，并获取有关各种API资源的必要信息。让我们看看在以下练习中如何运作。
- en: 'Exercise 4.02: Getting Information about API Resources'
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.02：获取有关API资源的信息
- en: Let's say that we want to create an ingress object. For the purposes of this
    exercise, you don't need to know much about ingress; we will learn about it in
    the upcoming chapters.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个ingress对象。在这个练习中，您不需要太多了解ingress；我们将在接下来的章节中学习它。
- en: 'We will use kubectl to get more information about the Ingress API resource,
    determine which API versions are available, and find out which groups it belongs
    to. If you recall from previous sections, we need this information for the `apiVersion`
    field of our YAML manifest. Then, we also get the information required for the
    other fields of our manifest file:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用kubectl获取有关Ingress API资源的更多信息，确定可用的API版本，并找出它属于哪些组。如果您还记得之前的部分，我们需要这些信息来填写YAML清单的`apiVersion`字段。然后，我们还需要获取清单文件的其他字段所需的信息：
- en: 'Let''s first ask our cluster for all the available API resources that match
    the `ingresses` keyword:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们询问我们的集群是否有与`ingresses`关键字匹配的所有可用API资源：
- en: '[PRE25]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This command will filter the list of all the API resources by the `ingresses`
    keyword. You should get the following output:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将通过`ingresses`关键字过滤所有API资源的列表。您应该得到以下输出：
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can see that we have ingress resources on two different API groups—`extensions`
    and `networking.k8s.io`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们在两个不同的API组上有ingress资源——`extensions`和`networking.k8s.io`。
- en: 'We have also seen how we can get API resources belonging to specific groups.
    Let''s check the API groups that we saw in the previous step:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还看到了如何获取属于特定组的API资源。让我们检查一下我们在上一步中看到的API组：
- en: '[PRE27]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You should get the following output:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '[PRE28]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s check the other group:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查另一个组：
- en: '[PRE29]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should see the following output:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 4.32: Listing out the resources in the networking.k8s.io API group'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.32：列出networking.k8s.io API组中的资源'
- en: '](image/B14870_04_32.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_32.jpg)'
- en: 'Figure 4.32: Listing out the resources in the networking.k8s.io API group'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.32：列出networking.k8s.io API组中的资源
- en: However, if we were to use an ingress resource, we still don't know whether
    we should use the one from the `extensions` group or the `networking.k8s.io` group.
    In the next step, we will get some more information that will help us decide that.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们要使用Ingress资源，我们仍然不知道我们应该使用来自`extensions`组还是`networking.k8s.io`组的资源。在下一步中，我们将获得一些更多信息，这将帮助我们决定。
- en: 'Use the following command to get more information:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令获取更多信息：
- en: '[PRE30]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should get this response:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到这个响应：
- en: '![Figure 4.33: Getting details of the ingress resource from the extensions
    API group'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.33：从扩展API组获取Ingress资源的详细信息'
- en: '](image/B14870_04_33.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_33.jpg)'
- en: 'Figure 4.33: Getting details of the ingress resource from the extensions API
    group'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.33：从扩展API组获取Ingress资源的详细信息
- en: As you can see, the `kubectl explain` command describes the API resource, as
    well as the details about the fields associated with it. We can also see that
    ingress uses the `extensions/v1beta1` API version, but if we read the `DESCRIPTION`,
    it mentions that this group version of ingress is deprecated by `networking.k8s.io/v1beta1`.
    Deprecated means that the standard is in the process of being phased out, and
    even though it is currently supported, it is not recommended for use.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`kubectl explain`命令描述了API资源，以及与其相关的字段的详细信息。我们还可以看到Ingress使用`extensions/v1beta1`
    API版本，但如果我们阅读`DESCRIPTION`，它提到此Ingress组版本已被`networking.k8s.io/v1beta1`弃用。弃用意味着标准正在逐步淘汰，尽管目前仍受支持，但不建议使用。
- en: Note
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you compare this to the different versions of `autoscaling` that we saw just
    before this exercise, you may think that the logical upgrade path from `v1beta`
    would be `v2beta`, and that would totally make sense. However, the ingress resource
    was moved from the `extensions` group to the `networking.k8s.io` group, and so
    this bucks the naming trend.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将此与我们在此练习之前看到的`autoscaling`的不同版本进行比较，您可能会认为从`v1beta`的逻辑升级路径将是`v2beta`，这完全是有道理的。然而，Ingress资源已从`extensions`组移动到`networking.k8s.io`组，因此这违反了命名趋势。
- en: 'It is not a good idea to use a deprecated version, so let''s say that you want
    to use the `networking.k8s.io/v1beta1` version instead. However, we need to get
    more information about it first. We can add a flag to the `kubectl explain` command
    to get information about a specific version of an API resource, as follows:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用弃用版本不是一个好主意，所以假设您想要使用`networking.k8s.io/v1beta1`版本。但是，我们首先需要获取更多关于它的信息。我们可以向`kubectl
    explain`命令添加一个标志来获取关于API资源特定版本的信息，如下所示：
- en: '[PRE31]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should see this response:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到这个响应：
- en: '![Figure 4.34: Getting details of the ingress resource from the networking.k8s.io
    API group'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.34：从networking.k8s.io API组获取Ingress资源的详细信息'
- en: '](image/B14870_04_34.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_34.jpg)'
- en: 'Figure 4.34: Getting details of the ingress resource from the networking.k8s.io
    API group'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.34：从networking.k8s.io API组获取Ingress资源的详细信息
- en: 'We can also filter the output of the `kubectl explain` command by using the
    `JSONPath` identifier. This allows us to get information about the various fields
    that we need to specify while defining the YAML manifest. So, for example, if
    we would like to see the `spec` fields for Ingress, the command will be as follows:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以通过使用`JSONPath`标识符来过滤`kubectl explain`命令的输出。这使我们能够获取关于定义YAML清单时需要指定的各个字段的信息。因此，例如，如果我们想要查看Ingress的`spec`字段，命令将如下所示：
- en: '[PRE32]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This should give a response as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给出以下响应：
- en: '![Figure 4.35: Filtering the output of the kubectl explain command'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.35：过滤kubectl explain命令的输出'
- en: to get the spec fields of ingress
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取Ingress的spec字段
- en: '](image/B14870_04_35.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_35.jpg)'
- en: 'Figure 4.35: Filtering the output of the kubectl explain command to get the
    spec fields of ingress'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.35：过滤kubectl explain命令的输出以获取ingress的spec字段
- en: 'We can dive deeper to get more details about the nested fields. For example,
    if you wanted to get more details about the `backend` field of ingress, we can
    specify `ingress.spec.backend` to get the required information:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以深入了解嵌套字段的更多细节。例如，如果您想要获取有关ingress的`backend`字段的更多详细信息，我们可以指定`ingress.spec.backend`以获取所需的信息：
- en: '[PRE33]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will give the following output:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![Figure 4.36: Filtering the output of the kubectl explain command'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.36：过滤kubectl explain命令的输出'
- en: to get the spec.backend field of ingress
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以获取ingress的spec.backend字段
- en: '](image/B14870_04_36.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_36.jpg)'
- en: 'Figure 4.36: Filtering the output of the kubectl explain command to get the
    spec.backend field of ingress'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.36：过滤kubectl explain命令的输出以获取ingress的spec.backend字段
- en: Similarly, we can repeat this for any field that you need information about,
    which is handy for building or modifying a YAML manifest. So, we have seen that
    the `kubectl explain` command is very useful when you are looking for more details
    and documentation about an API resource. It is also very useful when creating
    or modifying objects using YAML manifest files.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以重复这个过程以获取您需要的任何字段的信息，这对于构建或修改YAML清单非常方便。因此，我们已经看到`kubectl explain`命令在寻找有关API资源的更多详细信息和文档时非常有用。在使用YAML清单文件创建或修改对象时，它也非常有用。
- en: How to Enable/Disable API Resources, Groups, or Versions
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何启用/禁用API资源、组或版本
- en: In a typical cluster, not all API groups are enabled by default. It depends
    on the cluster use case as determined by the administrators. For example, some
    Kubernetes cloud providers disable resources that use the alpha level for stability
    and security reasons. However, those can still be enabled on the API server by
    using the `--runtime-config` flag, which accepts comma-separated lists.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的集群中，并非所有API组都是默认启用的。这取决于管理员确定的集群用例。例如，一些Kubernetes云提供商出于稳定性和安全性原因禁用使用alpha级别的资源。但是，仍然可以通过使用`--runtime-config`标志在API服务器上启用这些资源，该标志接受逗号分隔的列表。
- en: 'To be able to create any resource, the group and version should be enabled
    in the cluster. For example, when you try to create a `CronJob` that uses `apiVersion:
    batch/v2alpha1` in its manifest file, if the group/version is not enabled, you
    will get an error similar to the following:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '要能够创建任何资源，集群中应启用组和版本。例如，当您尝试在清单文件中使用`apiVersion: batch/v2alpha1`创建一个`CronJob`时，如果组/版本未启用，您将收到类似以下错误的消息：'
- en: '[PRE34]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To enable `batch/v2alpha1`, you will need to set `--runtime-config=batch/v2alpha1`
    on the API server. This can be done either during the creation of the cluster
    or by updating the `/etc/kubernetes/manifests/kube-apiserver.yaml` manifest file.
    The flag also supports disabling an API group or version by setting a `false`
    value to the specific version—for example, `--runtime-config=batch/v1=false`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用`batch/v2alpha1`，您需要在API服务器上设置`--runtime-config=batch/v2alpha1`。这可以在创建集群期间或通过更新`/etc/kubernetes/manifests/kube-apiserver.yaml`清单文件来完成。该标志还支持通过为特定版本设置`false`值来禁用API组或版本，例如，`--runtime-config=batch/v1=false`。
- en: '`--runtime-config` also supports the `api/all` special key, which is used to
    control all API versions. For example, to turn off all API versions except `v1`,
    you can pass the `--runtime-config=api/all=false,api/v1=true` flag. Let''s try
    our own hands-on example of creating and disabling API groups and versions in
    the following exercise.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`--runtime-config`还支持`api/all`特殊键，用于控制所有API版本。例如，要关闭除`v1`之外的所有API版本，您可以传递`--runtime-config=api/all=false,api/v1=true`标志。让我们尝试自己动手创建和禁用API组和版本的示例练习。'
- en: 'Exercise 4.03: Enabling and Disabling API Groups and Versions on a Minikube
    Cluster'
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.03：在Minikube集群上启用和禁用API组和版本
- en: 'In this exercise, we will create specific API versions while starting up Minikube,
    disable certain API versions in our running cluster, and then enable/disable resources
    in an entire API group:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在启动Minikube时创建特定的API版本，禁用运行中集群中的某些API版本，然后在整个API组中启用/禁用资源：
- en: 'Start Minikube with the flag shown in the following command:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动Minikube：
- en: '[PRE35]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You should see the following response:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 4.37: Starting up Minikube with an additional API resource group'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.37：使用额外的API资源组启动Minikube'
- en: '](image/B14870_04_37.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_37.jpg)'
- en: 'Figure 4.37: Starting up Minikube with an additional API resource group'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.37：使用额外的API资源组启动Minikube
- en: Note
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can refer to the `minikube start` documentation for further details about
    the `--extra-config` flag, at [https://minikube.sigs.k8s.io/docs/handbook/config/](https://minikube.sigs.k8s.io/docs/handbook/config/).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考`minikube start`文档，了解有关`--extra-config`标志的更多详细信息，网址为[https://minikube.sigs.k8s.io/docs/handbook/config/](https://minikube.sigs.k8s.io/docs/handbook/config/)。
- en: 'You can confirm it is enabled by checking the details about the `kube-apiserver-minikube`
    pod. Use the `describe pod` command and filter the results by the `runtime` keyword:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过使用`describe pod`命令并通过`runtime`关键字过滤结果来确认它是否已启用：
- en: '[PRE36]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You should see the following response:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE37]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Another way to confirm this is by looking at the enabled API versions by using
    the following command:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种确认的方法是使用以下命令查看已启用的API版本：
- en: '[PRE38]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You should see the following response:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE39]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, let''s create a resource called a `CronJob`, which uses `batch/v2alpha1`
    to confirm that our API server accepts the API. Create a file named `sample-cronjob.yaml`
    with the following contents:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`CronJob`的资源，它使用`batch/v2alpha1`来确认我们的API服务器是否接受API。创建一个名为`sample-cronjob.yaml`的文件，内容如下：
- en: '[PRE40]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, create a `CronJob` by using this YAML file:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用此YAML文件创建一个`CronJob`：
- en: '[PRE41]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You should see the following output:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE42]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, the API server accepted our YAML file and the `CronJob` is created
    successfully.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，API服务器接受了我们的YAML文件，并成功创建了`CronJob`。
- en: 'Now, let''s disable `batch/v2alpha1` on our cluster. To do that, we need to
    access the Minikube virtual machine (VM) using SSH, as demonstrated in previous
    chapters:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在集群上禁用`batch/v2alpha1`。为此，我们需要访问Minikube虚拟机（VM），如前几章所示：
- en: '[PRE43]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should see this response:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到这个响应：
- en: '![Figure 4.38: Accessing the Minikube VM via SSH'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.38：通过SSH访问Minikube VM'
- en: '](image/B14870_04_38.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_38.jpg)'
- en: 'Figure 4.38: Accessing the Minikube VM via SSH'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.38：通过SSH访问Minikube VM
- en: 'Open the API server manifest file. This is the template Kubernetes uses for
    the API server pods. We will use vi to modify this file, although you can use
    any text editor of your preference:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开API服务器清单文件。这是Kubernetes用于API服务器pod的模板。我们将使用vi来修改此文件，尽管您可以使用任何您喜欢的文本编辑器：
- en: '[PRE44]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You should see a response like the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的响应：
- en: '![Figure 4.39: The API server spec file'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.39：API服务器规范文件'
- en: '](image/B14870_04_39.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_39.jpg)'
- en: 'Figure 4.39: The API server spec file'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.39：API服务器规范文件
- en: Look for the line that contains `--runtime-config=batch/v2alpha1` and change
    it to `--runtime-config=batch/v2alpha1=false`. Then, save the modified file.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 查找包含“--runtime-config=batch/v2alpha1”的行，并将其更改为“--runtime-config=batch/v2alpha1=false”。然后保存修改后的文件。
- en: 'End the SSH session by using the following command:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令结束SSH会话：
- en: '[PRE45]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For the changes in the API server manifest to take effect, we need to restart
    the API server and the controller manager. Since these are deployed as stateless
    pods, we can simply delete them and they will automatically get deployed again.
    First, let''s delete the API server by running this command:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使API服务器清单中的更改生效，我们需要重新启动API服务器和控制器管理器。由于它们是部署为无状态的pod，我们可以简单地删除它们，它们将自动重新部署。首先，让我们通过运行这个命令来删除API服务器：
- en: '[PRE46]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You should see this output:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到这个输出：
- en: '[PRE47]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let''s delete the controller manager:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们删除控制器管理器：
- en: '[PRE48]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You should see this output:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到这个输出：
- en: '[PRE49]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that for both of these commands, we did not delete the pods by their names.
    The `-l` flag looks for labels. These commands deleted all the pods in the `kube-system`
    namespace that had labels that match the ones specified after the `-l` flag.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于这两个命令，我们没有按名称删除pod。`-l`标志寻找标签。这些命令删除了`kube-system`命名空间中所有具有与`-l`标志后指定的标签匹配的pod。
- en: 'We can confirm that `batch/v2alpha1` is no longer shown in API versions by
    using the following command:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令确认`batch/v2alpha1`不再显示在API版本中：
- en: '[PRE50]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This command will not give you any response, indicating that we have disabled
    `batch/v2alpha1`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令不会给你任何响应，表明我们已经禁用了`batch/v2alpha1`。
- en: So, we have seen how we can enable or disable a specific group or version of
    API resources. But this is still a broad approach. What if you wanted to disable
    a specific API resource?
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了如何启用或禁用特定组或版本的API资源。但这仍然是一个广泛的方法。如果你想要禁用特定的API资源怎么办？
- en: For our example, let's say that you want to disable ingress. We saw in the previous
    exercise that we have ingresses in the `extensions` as well as `networking.k8s.io`
    API groups. If you are targeting a specific API resource, you need to specify
    its group and version. Let's say that you want to disable ingress from the `extensions`
    group because it is deprecated. In this group, we have just one version of ingresses,
    which is `v1beta`, as you can observe from *Figure 4.33*.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你想要禁用ingress。我们在前面的练习中看到，我们在`extensions`和`networking.k8s.io` API组中都有ingresses。如果你要针对特定的API资源，你需要指定它的组和版本。假设你想要禁用`extensions`组中的ingress，因为它已经被弃用。在这个组中，我们只有一个版本的ingresses，即`v1beta`，你可以从*图4.33*中观察到。
- en: 'To achieve this, all we have to do is modify the `--runtime-config` flag to
    specify the resource that we want. So, if we wanted to disable ingress from the
    `extensions` group, the flag would be as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们只需要修改`--runtime-config`标志来指定我们想要的资源。所以，如果我们想要禁用`extensions`组中的ingress，标志将如下所示：
- en: '[PRE51]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To disable the resource, we can use this flag when starting up Minikube, as
    shown in *step 1* of this exercise, or we can add this line to the API server's
    manifest file, as shown in *step 7* of this exercise. Recall from this exercise
    that if we instead want to enable the resource, we just need to remove the `=false`
    part from the end of this flag.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用资源，我们可以在启动Minikube时使用这个标志，就像本练习的*步骤1*中所示，或者我们可以将这行添加到API服务器的清单文件中，就像本练习的*步骤7*中所示。回想一下，如果我们想要启用资源，我们只需要从这个标志的末尾删除`=false`部分。
- en: Interacting with Clusters Using the Kubernetes API
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes API与集群交互
- en: Up until now, we've been using the Kubernetes kubectl command-line tool, which
    made interacting with our cluster quite convenient. It does that by extracting
    the API server address and authentication information from the client kubeconfig
    file, which is located in `~/.kube/config` by default, as we saw in the previous
    chapter. In this section, we will look at the different ways to directly access
    the API server with HTTP clients such as curl.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用Kubernetes kubectl命令行工具，这使得与我们的集群交互非常方便。它通过从客户端kubeconfig文件中提取API服务器地址和身份验证信息来实现这一点，默认情况下位于`~/.kube/config`中，正如我们在上一章中看到的那样。在本节中，我们将看看使用curl等HTTP客户端直接访问API服务器的不同方法。
- en: There are two possible ways to directly access the API server via the REST API—by
    using kubectl in proxy mode or by providing the location and authentication credentials
    directly to the HTTP client. We will explore both methods to understand the pros
    and cons of each one.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种直接通过REST API访问API服务器的可能方式——通过使用kubectl代理模式或直接向HTTP客户端提供位置和身份验证凭据。我们将探讨这两种方法，以了解各自的优缺点。
- en: Accessing the Kubernetes API Server Using kubectl as a Proxy
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用kubectl作为代理访问Kubernetes API服务器
- en: kubectl has a great feature called **kubectl proxy**, which is the recommended
    approach for interacting with the API server. This is recommended because it is
    easier to use and provides a more secure way of doing so because it verifies the
    identity of the API server by using a self-signed certificate, which prevents
    **man-in-the-middle** (**MITM**) attacks.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl有一个很棒的功能叫做**kubectl proxy**，这是与API服务器交互的推荐方法。这是推荐的，因为它更容易使用，并提供了更安全的方式，因为它通过使用自签名证书验证API服务器的身份，防止了**中间人**（**MITM**）攻击。
- en: kubectl proxy routes the requests from our HTTP client to the API server while
    taking care of authentication by itself. Authentication is also handled by using
    the current configuration in our kubeconfig file.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl代理将HTTP客户端的请求路由到API服务器，同时自行处理身份验证。身份验证也是通过使用我们kubeconfig文件中的当前配置来处理的。
- en: 'In order to demonstrate how to use kubectl proxy, let''s first create an NGINX
    Deployment with two replicas in the default namespace and view it using `kubectl
    get pods`:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用kubectl代理，让我们首先在默认命名空间中创建一个具有两个副本的NGINX部署，并使用`kubectl get pods`查看它：
- en: '[PRE52]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This should give an output like the following:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会得到类似以下的输出：
- en: '[PRE53]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we can scale our Deployment to two replicas with the following command:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令将我们的部署扩展到两个副本：
- en: '[PRE54]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You should see an output similar to this:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似于这样的输出：
- en: '[PRE55]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s now check whether the pods are up and running:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查一下pod是否正在运行：
- en: '[PRE56]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This gives an output similar to the following:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生类似以下的输出：
- en: '[PRE57]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To start a proxy to the API server, run the `kubectl proxy` command:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动到API服务器的代理，请运行`kubectl proxy`命令：
- en: '[PRE58]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This should give output as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出：
- en: '[PRE59]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Note from the preceding screenshot that the local proxy connection is running
    on `127.0.0.1:8001`, which is the default. We can also specify a custom port by
    adding the `--port=<YourCustomPort>` flag, while adding an `&` (ampersand) sign
    at the end of our command to allow the proxy to run in the terminal background
    so that we can continue working in the same terminal window. So, the command would
    look like this:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面截图中本地代理连接正在`127.0.0.1:8001`上运行，默认情况下。我们还可以通过添加`--port=<YourCustomPort>`标志来指定自定义端口，同时在命令的末尾添加`&`（和号）符号，以允许代理在终端后台运行，这样我们可以在同一个终端窗口中继续工作。因此，命令看起来像这样：
- en: '[PRE60]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This should give the following response:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会得到以下响应：
- en: '[PRE61]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The proxy is run as a background job, and in the preceding screenshot, `[1]`
    indicates the job number and `48285` indicates its process ID. To exit a proxy
    running in the background, you can run `fg` to bring the job back to the foreground:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 代理作为后台作业运行，在前面的截图中，`[1]`表示作业编号，`48285`表示其进程ID。要退出在后台运行的代理，可以运行`fg`将作业带回前台：
- en: '[PRE62]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This will show the following response:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下响应：
- en: '[PRE63]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: After getting the proxy to the foreground, we can simply use *Ctrl* + *C* to
    exit it (if there's no other job running).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 将代理切换到前台后，我们可以简单地使用*Ctrl* + *C*退出它（如果没有其他作业在运行）。
- en: Note
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are not familiar with job control, you can learn about it at [https://www.gnu.org/software/bash/manual/html_node/Job-Control-Basics.html](https://www.gnu.org/software/bash/manual/html_node/Job-Control-Basics.html).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对作业控制不熟悉，可以在[https://www.gnu.org/software/bash/manual/html_node/Job-Control-Basics.html](https://www.gnu.org/software/bash/manual/html_node/Job-Control-Basics.html)了解相关信息。
- en: 'We can now start exploring the API using curl:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始使用curl来探索API：
- en: '[PRE64]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Recall that even though we are mostly using YAML for convenience, the data
    is stored in etcd in JSON format. You will see a long response that begins something
    like this:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管我们主要使用YAML来方便，但数据以JSON格式存储在etcd中。您将看到一个长的响应，类似于以下内容：
- en: '![Figure 4.40: The response from the API server'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.40：来自API服务器的响应'
- en: '](image/B14870_04_40.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_40.jpg)'
- en: 'Figure 4.40: The response from the API server'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.40：来自API服务器的响应
- en: But how do we find the exact path to query the Deployment we created earlier?
    Also, how do we query the pods created by that Deployment?
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们如何找到查询我们之前创建的部署的确切路径？另外，我们如何查询该部署创建的pod？
- en: 'You can start by asking yourself a few questions:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以先问自己几个问题：
- en: What are the API version and API group used by Deployments?
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署使用的API版本和API组是什么？
- en: 'In *Figure 4.27*, we saw that the Deployments are in `apps/v1`, so we can start
    by adding that to the path:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图4.27*中，我们看到部署在`apps/v1`中，因此我们可以从那里开始添加路径：
- en: '[PRE65]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Is it a namespace-scoped resource or a cluster-scoped resource? If it is a namespace-scoped
    resource, what is the name of the namespace?
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是命名空间范围的资源还是集群范围的资源？如果它是命名空间范围的资源，命名空间的名称是什么？
- en: 'We also saw in the scope of the API resources section that Deployments are
    namespace-scoped resources. When we created the Deployment, since we did not specify
    a different namespace, it went to the `default` namespace. So, in addition to
    the `apiVersion` field, we would need to add `namespaces/default/deployments`
    to our path:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在API资源范围部分看到，部署是命名空间范围的资源。当我们创建部署时，由于我们没有指定不同的命名空间，它进入了`default`命名空间。因此，除了`apiVersion`字段外，我们还需要将`namespaces/default/deployments`添加到我们的路径中：
- en: '[PRE66]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This will return a large output with the JSON data that is stored on this path.
    This is the part of the response that gives us the information that we need:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个包含存储在此路径上的JSON数据的大型输出。这是响应的一部分，给了我们需要的信息：
- en: '![Figure 4.41: Getting information about all the Deployments using curl'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.41：使用curl获取有关所有部署的信息'
- en: '](image/B14870_04_41.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_41.jpg)'
- en: 'Figure 4.41: Getting information about all the Deployments using curl'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.41：使用curl获取有关所有部署的信息
- en: 'As you can see in this output, this lists all the Deployments in the `default`
    namespace. You can infer that from `"kind": "DeploymentList"`. Also, note that
    the response is in JSON format and is not neatly presented as a table.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '正如您在此输出中所看到的，这列出了`default`命名空间中的所有部署。您可以从`"kind": "DeploymentList"`推断出这一点。另外，请注意，响应是以JSON格式呈现的，而不是整齐地呈现为表格。'
- en: 'Now, we can specify a specific Deployment by adding it to our path:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过将特定部署添加到路径来指定特定的部署：
- en: '[PRE67]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You should see this response:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到这个响应：
- en: '![Figure 4.42: Getting information about our NGINX Deployment using curl'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.42：使用curl获取有关我们的NGINX部署的信息'
- en: '](image/B14870_04_42.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_42.jpg)'
- en: 'Figure 4.42: Getting information about our NGINX Deployment using curl'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.42：使用curl获取有关我们的NGINX部署的信息
- en: You can use this method with any other resource as well.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以将此方法用于任何其他资源。
- en: Creating Objects Using curl
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用curl创建对象
- en: 'When you use any HTTP client, such as curl, to send requests to the API server
    to create objects, you need to change three things:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用任何HTTP客户端（如curl）向API服务器发送请求以创建对象时，您需要更改三件事：
- en: Change the `HTTP` request method to `POST`. By default, curl will use the `GET`
    method. To create objects, we need to use the `POST` method, as we learned in
    *The Kubernetes API* section. You can change this using the `-X` flag.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`HTTP`请求方法更改为`POST`。默认情况下，curl将使用`GET`方法。要创建对象，我们需要使用`POST`方法，正如我们在* Kubernetes
    API *部分学到的那样。您可以使用`-X`标志更改这一点。
- en: 'Change the HTTP request header. We need to modify the header to inform the
    API server what the intention of the request is. We can modify the header using
    the `-H` flag. In this case, we need to set the header to `''Content-Type: application/yaml''`.'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '更改HTTP请求头。我们需要修改标头以通知API服务器请求的意图是什么。我们可以使用`-H`标志修改标头。在这种情况下，我们需要将标头设置为`''Content-Type:
    application/yaml''`。'
- en: Include the spec of the object to be created. As you learned in the previous
    two chapters, each API resource is persisted in the etcd as an API object, which
    is defined by a YAML spec/manifest file. To create an object, you need to use
    the `--data` flag to pass the YAML manifest to the API server so that it can persist
    it in etcd as an object.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括要创建的对象的规范。正如您在前两章中学到的，每个API资源都作为API对象持久存在于etcd中，由YAML规范/清单文件定义。要创建对象，您需要使用`--data`标志将YAML清单传递给API服务器，以便它可以将其持久保存在etcd中作为对象。
- en: 'So, the curl command, which we will implement in the following exercise, will
    look something like this:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，curl命令将如下所示：
- en: '[PRE68]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: At times, you will have the manifest files handy. However, that may not always
    be the case. Also, we have not yet seen what manifests for namespaces look like.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您会随时掌握清单文件。但情况并非总是如此。此外，我们还没有看到命名空间的清单是什么样子。
- en: 'Let''s consider a case where we want to create a namespace. Usually, you would
    create a namespace as follows:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个情况，我们想要创建一个命名空间。通常，您会按以下方式创建命名空间：
- en: '[PRE69]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This will give the following response:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下响应：
- en: '[PRE70]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here, you can see that we created a namespace called `my-namespace`. However,
    for passing the request without using kubectl, we need the spec used to define
    a namespace. We can get that by using the `--dry-run=client` and `-o` flags:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们创建了一个名为`my-namespace`的命名空间。但是，为了在不使用kubectl的情况下传递请求，我们需要用于定义命名空间的规范。我们可以通过使用`--dry-run=client`和`-o`标志来获取：
- en: '[PRE71]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This will give the following response:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下响应：
- en: '![Figure 4.43: Getting the spec for a namespace using dry-run'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.43：使用dry-run获取命名空间的规范'
- en: '](image/B14870_04_43.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_43.jpg)'
- en: 'Figure 4.43: Getting the spec for a namespace using dry-run'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.43：使用dry-run获取命名空间的规范
- en: When you run a `kubectl` command with the `--dry-run=client` flag, the API server
    takes it through all the stages of a normal command, except that it does not persist
    the changes into etcd. So, the command is authenticated, authorized, and validated,
    but changes are not permanent. This is a great way to test whether a certain command
    works, and also to get the manifest that the API server would have created for
    this command, as you can see in the previous screenshot. Let's see how to put
    this in practice and use curl to create a Deployment.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`kubectl`命令带有`--dry-run=client`标志时，API服务器会将其通过正常命令的所有阶段，只是不会将更改持久化到etcd中。因此，命令经过了身份验证、授权和验证，但更改不是永久性的。这是一个很好的测试某个命令是否有效的方法，也可以获取API服务器为该命令创建的清单，就像您在之前的截图中看到的那样。让我们看看如何将其付诸实践，并使用curl创建一个部署。
- en: 'Exercise 4.04: Creating and Verifying a Deployment Using kubectl proxy and
    curl'
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.04：使用kubectl代理和curl创建和验证部署
- en: 'For this exercise, we will create an NGINX Deployment called `nginx-example`
    with three replicas in a namespace called `example`. We will do this by sending
    our requests to the API server with curl via kubectl proxy:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在名为`example`的命名空间中创建一个名为`nginx-example`的NGINX部署，其中包含三个副本。我们将通过使用kubectl代理通过curl将我们的请求发送到API服务器来完成这个操作：
- en: 'First, let''s start our proxy:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们启动我们的代理：
- en: '[PRE72]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This should give the following response:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会得到以下响应：
- en: '[PRE73]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The proxy started as a background job and is listening on the localhost at port
    `8001`.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 代理作为后台作业启动，并在本地主机的端口`8001`上进行侦听。
- en: 'Since the `example` namespace does not exist, we should create that namespace
    before creating the Deployment. As we learned in the previous section, we need
    to get the spec that should be used to create the namespace. Let''s use the following
    command:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`example`命名空间不存在，我们应该在创建部署之前创建该命名空间。正如我们在上一节中学到的，我们需要获取应该用于创建命名空间的规范。让我们使用以下命令：
- en: '[PRE74]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For Kubernetes versions 1.18+, please use `--dry-run=client`.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Kubernetes版本1.18+，请使用`--dry-run=client`。
- en: 'This will give the following output:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![Figure 4.44: Getting the spec required for our namespace'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.44：获取我们命名空间所需的规范'
- en: '](image/B14870_04_44.jpg)'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_44.jpg)'
- en: 'Figure 4.44: Getting the spec required for our namespace'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.44：获取我们命名空间所需的规范
- en: Now, we have the spec required for creating the namespace.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经获得了创建命名空间所需的规范。
- en: 'Now, we need to send a request to the API server using curl. Namespaces belong
    to the core group and hence the path will be `/api/v1/namespaces`. The final `curl`
    command to create the namespace after adding all required parameters should look
    like the following:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要使用curl向API服务器发送请求。命名空间属于核心组，因此路径将是`/api/v1/namespaces`。在添加所有必需的参数后，用于创建命名空间的最终`curl`命令应该如下所示：
- en: '[PRE75]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can discover the required path for any resource, as shown in the previous
    exercise. In this command, the double-quotes (`"`) after `--data` allow you to
    enter multi-line input in Bash, which is delimited by another double-quote at
    the end. So, you can copy the output from the previous step here before the delimiter.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像前面的练习中所示的那样发现任何资源所需的路径。在这个命令中，`--data`后面的双引号(`"`)允许您在Bash中输入多行输入，这些输入由末尾的另一个双引号限定。因此，您可以在此之前复制上一步的输出。
- en: 'Now, if everything was correct in our command, you should get a response like
    the following:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们的命令一切正确，你应该会得到以下类似的响应：
- en: '![Figure 4.45: Using curl to send a request to create a namespace'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.45：使用curl发送请求创建命名空间'
- en: '](image/B14870_04_45.jpg)'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_45.jpg)'
- en: 'Figure 4.45: Using curl to send a request to create a namespace'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.45：使用curl发送请求创建命名空间
- en: 'The same procedure applies to Deployment. So, first, let''s use the `kubectl
    create` command with `--dry-run=client` to get an idea of how our YAML data looks:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相同的过程适用于部署。因此，首先让我们使用`kubectl create`命令和`--dry-run=client`来了解我们的YAML数据的外观：
- en: '[PRE76]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For Kubernetes versions 1.18+, please use `--dry-run=client`.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Kubernetes版本1.18+，请使用`--dry-run=client`。
- en: 'You should get the following response:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到以下响应：
- en: '![Figure 4.46: Using curl to send a request to create a Deployment'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.46：使用curl发送请求创建部署'
- en: '](image/B14870_04_46.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_46.jpg)'
- en: 'Figure 4.46: Using curl to send a request to create a Deployment'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.46：使用curl发送请求创建部署
- en: Note
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that the namespace will not show if you are using the `--dry-run=client`
    flag because we need to specify it in our API path.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您使用`--dry-run=client`标志，则命名空间将不会显示，因为我们需要在API路径中指定它。
- en: 'Now, the command for creating the Deployment will be constructed similarly
    to the command for creating the namespace. Note that the namespace is specified
    in the API path:'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建部署的命令将与创建命名空间的命令类似。请注意，命名空间在API路径中指定：
- en: '[PRE77]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If everything is correct, you should get a response like the following from
    the API server:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正确，您应该从API服务器获得以下响应：
- en: '![Figure 4.47: Response from API server after creating a Deployment'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.47：创建部署后API服务器的响应'
- en: '](image/B14870_04_47.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_47.jpg)'
- en: 'Figure 4.47: Response from API server after creating a Deployment'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.47：创建部署后API服务器的响应
- en: Note that the kubectl proxy process is still running in the background. If you
    are done with interacting with the API server using kubectl proxy, then you may
    want to stop the proxy from running in the background. To do that, run the `fg`
    command to bring the kubectl proxy process to the foreground and then press *Ctrl*
    + *C*.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，kubectl代理进程仍在后台运行。如果您已经完成了使用kubectl代理与API服务器的交互，则可能希望停止后台运行的代理。要做到这一点，请运行`fg`命令将kubectl代理进程带到前台，然后按下*Ctrl*
    + *C*。
- en: So, we have seen how we can interact with the API server using kubectl proxy,
    and by using curl, we have been able to create an NGINX Deployment in a new namespace.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了如何使用kubectl代理与API服务器进行交互，并且通过使用curl，我们已经能够在新的命名空间中创建了一个NGINX部署。
- en: Direct Access to the Kubernetes API Using Authentication Credentials
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用认证凭据直接访问Kubernetes API
- en: Instead of using kubectl in proxy mode, we can provide the location and credentials
    directly to the HTTP client. This approach can be used if you are using a client
    that may get confused by proxies, but it is less secure than using the kubectl
    proxy due to the risk of MITM attacks. To mitigate this risk, it is recommended
    that you import the root certificate and verify the identity of the API server
    when using this method.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接向HTTP客户端提供位置和凭据，而不是使用kubectl代理模式。如果您使用的客户端可能会被代理搞混，可以使用这种方法，但由于中间人攻击的风险，这种方法比使用kubectl代理不够安全。为了减轻这种风险，在使用这种方法时建议导入根证书并验证API服务器的身份。
- en: 'When thinking about accessing the cluster using credentials, we need to understand
    how authentication is configured and what authentication plugins are enabled in
    our cluster. Several authentication plugins can be used, which allow different
    ways of authenticating with the server:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑使用凭据访问集群时，我们需要了解认证是如何配置的，以及我们的集群中启用了哪些认证插件。可以使用多种认证插件，允许以不同的方式与服务器进行认证：
- en: Client certificates
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端证书
- en: ServiceAccount bearer tokens
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ServiceAccount bearer tokens
- en: Authenticating proxy
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证代理
- en: HTTP basic auth
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP基本认证
- en: Note
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the preceding list includes only some of the authentication plugins.
    You can learn more about authentication at [https://kubernetes.io/docs/reference/access-authn-authz/authentication/](https://kubernetes.io/docs/reference/access-authn-authz/authentication/).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述列表仅包括一些身份验证插件。您可以在[https://kubernetes.io/docs/reference/access-authn-authz/authentication/](https://kubernetes.io/docs/reference/access-authn-authz/authentication/)了解更多关于身份验证的信息。
- en: 'Let''s check what authentication plugins are enabled in our cluster by looking
    at the API server running process using the following command and looking at the
    flags passed to the API server:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下命令查看我们集群中启用了哪些身份验证插件，查看运行中的API服务器进程并查看传递给API服务器的标志：
- en: '[PRE78]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This command will first install/update `procps` (a tool used to inspect processes)
    within the API server, which is running as a pod on our Minikube server. Then,
    it will get the list of processes and filter it by using the `kube-apiserver`
    keyword. You will get a long output, but here is the part that we are interested
    in:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将首先在我们的Minikube服务器上安装/更新`procps`（用于检查进程的工具）在API服务器中作为一个pod运行。然后，它将获取进程列表，并使用`kube-apiserver`关键字进行过滤。您将获得一个很长的输出，但这是我们感兴趣的部分：
- en: '![Figure 4.48: Getting the details flags passed to the API server'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.48：获取传递给API服务器的详细标志'
- en: '](image/B14870_04_48.jpg)'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_48.jpg)'
- en: 'Figure 4.48: Getting the details flags passed to the API server'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.48：获取传递给API服务器的详细标志
- en: 'The following two flags from this screenshot tell us some important information:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 此截图中的两个标志告诉我们一些重要信息：
- en: '`--client-ca-file=/var/lib/minikube/certs/ca.crt`'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--client-ca-file=/var/lib/minikube/certs/ca.crt`'
- en: '`--service-account-key-file=/var/lib/minikube/certs/sa.pub`'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--service-account-key-file=/var/lib/minikube/certs/sa.pub`'
- en: These flags tell us that we have two different authentication plugins configured—X.509
    client certificates (based on the first flag) and ServiceAccount tokens (based
    on the second flag). We will now learn how to use both of these authentication
    methods for communicating with the API server.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志告诉我们，我们配置了两种不同的身份验证插件——基于X.509客户端证书（基于第一个标志）和ServiceAccount令牌（基于第二个标志）。现在我们将学习如何使用这两种身份验证方法与API服务器进行通信。
- en: 'Method 1: Using Client Certificate Authentication'
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法1：使用客户端证书身份验证
- en: 'X.509 certificates are used for authenticating external requests, which is
    the current configuration in our kubeconfig file. The `--client-ca-file=/var/lib/minikube/certs/ca.crt`
    flag indicates the certificate authority that is used to validate client certificates,
    which will authenticate with the API server. An X.509 certificate defines a subject,
    which is what identifies a user in Kubernetes. For example, the X.509 certificate
    used for SSL by [https://www.google.com/](https://www.google.com/) has a subject
    containing the following information:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: X.509证书用于验证外部请求，这是我们kubeconfig文件中的当前配置。`--client-ca-file=/var/lib/minikube/certs/ca.crt`标志表示用于验证客户端证书的证书颁发机构，这将用于与API服务器进行身份验证。X.509证书定义了一个主题，这是在Kubernetes中标识用户的内容。例如，[https://www.google.com/](https://www.google.com/)使用的SSL的X.509证书包含以下信息：
- en: '[PRE79]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: When an X.509 certificate is used for authenticating a Kubernetes user, the
    `Common Name` of the subject is used as the username for the user, and the `Organization`
    field is used as the group membership of that user.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用X.509证书对Kubernetes用户进行身份验证时，主题的“通用名称”用作用户的用户名，“组织”字段用作用户的组成员身份。
- en: 'Kubernetes uses a TLS protocol for all of its API calls as a security measure.
    The HTTP client that we have been using so far, curl, can work with TLS. Earlier,
    kubectl proxy took care of communicating over TLS for us, but if we want to do
    it directly using curl, we need to add three more details to all of our API calls:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes对其所有API调用使用TLS协议作为安全措施。到目前为止，我们一直在使用的HTTP客户端curl可以与TLS一起工作。之前，kubectl代理为我们处理了TLS通信，但是如果我们想直接使用curl进行通信，我们需要向所有API调用添加三个更多的细节：
- en: '`--cert`: The client certificate path'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --cert：客户端证书路径
- en: '`--key`: The private key path'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --key：私钥路径
- en: '`--cacert`: The certificate authority path'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --cacert：证书颁发机构路径
- en: 'So, if we combine them, the command syntax should look as follows:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们将它们组合起来，命令语法应该如下所示：
- en: '[PRE80]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In this section, we will not create these certificates, but instead, we will
    be using the certificates that were created when we bootstrapped our cluster using
    Minikube. All the relevant information can be taken from our kubeconfig file,
    which was prepared by Minikube when we initialized the cluster. Let''s see that
    file:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不会创建这些证书，而是将使用在使用Minikube引导集群时创建的证书。所有相关信息都可以从我们的kubeconfig文件中获取，该文件是在初始化集群时由Minikube准备的。让我们看看那个文件：
- en: '[PRE81]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You should get the following response:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该收到以下响应：
- en: '![Figure 4.49: The API server IP and authentication certificates in kubeconfig'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.49：kubeconfig中的API服务器IP和身份验证证书'
- en: '](image/B14870_04_49.jpg)'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_49.jpg)'
- en: 'Figure 4.49: The API server IP and authentication certificates in kubeconfig'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.49：kubeconfig中的API服务器IP和身份验证证书
- en: 'The final command should look like the following: you can see that we can explore
    the API:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的命令应该如下所示：您可以看到我们可以探索API：
- en: '[PRE82]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You should get the following response:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该收到以下响应：
- en: '![Figure 4.50: Response from API server'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.50：来自API服务器的响应'
- en: '](image/B14870_04_50.jpg)'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_50.jpg)'
- en: 'Figure 4.50: Response from API server'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.50：来自API服务器的响应
- en: So, we can see that the API server is responding to our calls. You can use this
    method to achieve everything that we have done in the previous section using kubectl
    proxy.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到API服务器正在响应我们的调用。您可以使用此方法来实现我们在上一节中使用kubectl代理所做的一切。
- en: 'Method 2: Using a ServiceAccount Bearer Token'
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法2：使用ServiceAccount Bearer Token
- en: Service accounts are meant to authenticate processes running within the cluster,
    such as pods, to allow internal communication with the API server. They use signed
    bearer **JSON Web Tokens** (**JWTs**) to authenticate with the API server. These
    tokens are stored in Kubernetes objects called **Secrets**, which are a type of
    entities used to store sensitive information, such as the aforementioned authentication
    tokens. The information stored inside a Secret is Base64-encoded.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceAccount用于对集群内运行的进程进行身份验证，例如pod，以允许与API服务器进行内部通信。它们使用签名的承载**JSON Web Tokens**（**JWTs**）与API服务器进行身份验证。这些令牌存储在称为**Secrets**的Kubernetes对象中，这是一种用于存储敏感信息的实体类型，例如前述的身份验证令牌。Secret中存储的信息是Base64编码的。
- en: 'So, each ServiceAccount has a corresponding secret associated with it. When
    a pod uses a ServiceAccount to authenticate with the API server, the secret is
    mounted on the pod and the bearer token is decoded and then mounted at the following
    location inside a pod: `/run/secrets/kubernetes.io/serviceaccount`. This can then
    be used by any process in the pod to authenticate with the API server. Authentication
    by use of ServiceAccounts is enabled by a built-in module known as an admission
    controller, which is enabled by default.'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个ServiceAccount都有一个与之相关的secret。当pod使用ServiceAccount与API服务器进行身份验证时，该secret将被挂载到pod上，并且bearer
    token将被解码，然后挂载到pod内的以下位置：`/run/secrets/kubernetes.io/serviceaccount`。然后，pod中的任何进程都可以使用它来与API服务器进行身份验证。通过ServiceAccounts进行身份验证是通过内置模块实现的，该模块称为准入控制器，默认情况下已启用。
- en: However, ServiceAccounts alone are not sufficient; once authenticated, Kubernetes
    also needs to permit any actions for that ServiceAccount (which is the authorization
    phase). This is managed by **Role-Based Access Control** (**RBAC**) policies.
    In Kubernetes, you can define certain **Roles**, and then use **RoleBinding**
    to *bind* those Roles to certain users or ServiceAccounts.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅ServiceAccounts是不够的；一旦经过身份验证，Kubernetes还需要允许该ServiceAccount的任何操作（这是授权阶段）。这由**基于角色的访问控制**（**RBAC**）策略来管理。在Kubernetes中，您可以定义某些**Roles**，然后使用**RoleBinding**将这些Roles*绑定*到特定的用户或ServiceAccounts。
- en: A Role defines what actions (API verbs) are allowed and which API groups and
    resources can be accessed. A RoleBinding defines which user or ServiceAccount
    can assume that Role. A ClusterRole is similar to a Role, except that a Role is
    namespace-scoped, while a ClusterRole is a cluster-scoped policy. The same distinction
    is true for RoleBinding and ClusterRoleBinding.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: Role定义了允许的操作（API动词）以及可以访问的API组和资源。RoleBinding定义了哪个用户或ServiceAccount可以承担该角色。ClusterRole类似于Role，不同之处在于Role是命名空间范围的，而ClusterRole是集群范围的策略。RoleBinding和ClusterRoleBinding也是同样的区别。
- en: Note
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will learn more about secrets in *Chapter 10*, *ConfigMaps and Secrets*;
    more on RBAC in *Chapter 13*, *Runtime and Network Security in Kubernetes*; and
    admission controllers in *Chapter 16*, *Kubernetes Admission Controllers*.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在*第10章*“ConfigMaps和Secrets”中了解更多关于secrets的内容；在*第13章*“Kubernetes中的运行时和网络安全”中了解更多关于RBAC的内容；以及在*第16章*“Kubernetes
    Admission Controllers”中了解有关准入控制器的更多信息。
- en: 'Every namespace contains a ServiceAccount called `default`. We can see that
    by using the following command:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命名空间都包含一个名为`default`的ServiceAccount。我们可以使用以下命令来查看：
- en: '[PRE83]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'You should see the following response:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 4.51: Examining default ServiceAccounts for each namespace'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.51：检查每个命名空间的默认ServiceAccounts'
- en: '](image/B14870_04_51.jpg)'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_51.jpg)'
- en: 'Figure 4.51: Examining default ServiceAccounts for each namespace'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.51：检查每个命名空间的默认ServiceAccounts
- en: 'As mentioned earlier, a ServiceAccount is associated with a secret that contains
    the CA certificate of the API server and a bearer token. We can view the ServiceAccount-associated
    secret in the `default` namespace, as follows:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，ServiceAccount与包含API服务器的CA证书和bearer token的secret相关联。我们可以通过以下方式查看`default`命名空间中与ServiceAccount相关联的secret：
- en: '[PRE84]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'You should get the following response:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下响应：
- en: '[PRE85]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We can see that we have a secret named `default-token-wtkk5` (where `wtkk5`
    is a random string) in our default namespace. We can view the content of the Secret
    resource by using the following command:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的默认命名空间中有一个名为`default-token-wtkk5`的secret（其中`wtkk5`是一个随机字符串）。我们可以使用以下命令查看Secret资源的内容：
- en: '[PRE86]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This command will get the object definition as it is stored in etcd and display
    it in YAML format so that it is easy to read. This will produce an output as follows:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将获取对象定义，如存储在etcd中，并以YAML格式显示，以便易于阅读。这将产生以下输出：
- en: '![Figure 4.52: Displaying the information stored in a secret'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.52：显示存储在密钥中的信息'
- en: '](image/B14870_04_52.jpg)'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_52.jpg)'
- en: 'Figure 4.52: Displaying the information stored in a secret'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.52：显示存储在密钥中的信息
- en: 'Note from the preceding secret that `namespace`, `token`, and the CA certificate
    of the API server (ca.crt) are Base64-encoded. You can decode it using `base64
    --decode` in your Linux terminal, as follows:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面的密钥中的`namespace`、`token`和API服务器的CA证书（ca.crt）都是Base64编码的。您可以在Linux终端中使用`base64
    --decode`进行解码，如下所示：
- en: '[PRE87]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Copy and paste the value from `ca.crt` or `token` in the preceding command.
    This will output the decoded value, which you can then write to a file or a variable
    for later use. However, in this demonstration, we will show another method to
    get the values.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的命令中复制并粘贴`ca.crt`或`token`的值。这将输出解码后的值，然后您可以将其写入文件或变量以供以后使用。但是，在此演示中，我们将展示另一种获取值的方法。
- en: 'Let''s take a peek into one of our pods:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们窥探一下我们的一个pod：
- en: '[PRE88]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This command enters the pod and then runs a Bash shell on it. Then, once we
    have the shell running inside a pod, we can explore the various mount points available
    in the pod:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令进入pod，然后在其上运行Bash shell。然后，一旦我们在pod内部运行shell，我们可以探索pod中可用的各种挂载点：
- en: '[PRE89]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This will give an output similar to the following:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似以下的输出：
- en: '![Figure 4.53: The mount point for the bearer token'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.53：承载令牌的挂载点'
- en: '](image/B14870_04_53.jpg)'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_53.jpg)'
- en: 'Figure 4.53: The mount point for the bearer token'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.53：承载令牌的挂载点
- en: 'The mount point can be explored further:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 可以进一步探索挂载点：
- en: '[PRE90]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'You should see an output similar to the following:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '[PRE91]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: As you can see here, the mount point contains the API server CA certificate,
    the namespace this secret belongs to, and the JWT bearer token. If you are trying
    these commands on your terminal, you can exit the pod's shell by entering an `exit`.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此处所见，挂载点包含API服务器CA证书、此密钥所属的命名空间和JWT承载令牌。如果您在终端上尝试这些命令，可以通过输入“exit”退出pod的shell。
- en: If we try to access the API server using curl from inside the pod, we would
    need to provide the CA path and the token. Let's try to list all the pods in the
    pod's namespace by accessing the API server from inside a pod.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试从pod内部使用curl访问API服务器，我们需要提供CA路径和令牌。让我们尝试通过从pod内部访问API服务器来列出pod的所有内容。
- en: 'We can create a new Deployment and start a Bash terminal with the following
    procedure:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个新的Deployment，并使用以下过程启动Bash终端：
- en: '[PRE92]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This may take a few seconds to start up, and then you will get a response similar
    to this:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要几秒钟来启动，然后您将得到类似这样的响应：
- en: '[PRE93]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This will start up a Deployment running Ubuntu and immediately take us inside
    the pod and open up the Bash shell. The `--rm` flag in this command will delete
    the pod after all the processes inside the pod are terminated—that is, after we
    leave the pod using the `exit` command. But for now, let''s install curl:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个运行Ubuntu的Deployment，并立即将我们带入pod并打开Bash shell。此命令中的`--rm`标志将在pod内部的所有进程终止后删除pod，也就是在我们使用`exit`命令离开pod后。但现在，让我们安装curl：
- en: '[PRE94]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This should produce a response similar to this:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生类似这样的响应：
- en: '![Figure 4.54: Installing curl'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.54：安装curl'
- en: '](image/B14870_04_54.jpg)'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_54.jpg)'
- en: 'Figure 4.54: Installing curl'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.54：安装curl
- en: 'Now that we have installed curl, let''s try to list the pods using curl by
    accessing the API path:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了curl，让我们尝试使用curl列出pod，通过访问API路径：
- en: '[PRE95]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'You should see the following response:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 4.55: Trying to access the API without TLS'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.55：尝试在没有TLS的情况下访问API'
- en: '](image/B14870_04_55.jpg)'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_55.jpg)'
- en: 'Figure 4.55: Trying to access the API without TLS'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.55：尝试在没有TLS的情况下访问API
- en: 'Notice that the command has failed. This happened since Kubernetes forces all
    communication to use TLS, which usually rejects insecure connections (without
    any authentication tokens). Let''s add the `--insecure` flag, which will allow
    an insecure connection with curl, and observe the results:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，命令失败了。这是因为Kubernetes强制所有通信使用TLS，通常拒绝不带任何身份验证令牌的不安全连接。让我们添加`--insecure`标志，这将允许使用curl进行不安全连接，并观察结果：
- en: '[PRE96]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You should get a response as follows:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下响应：
- en: '![Figure 4.56: Anonymous request to the API server'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.56：匿名请求API服务器'
- en: '](image/B14870_04_56.jpg)'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_56.jpg)'
- en: 'Figure 4.56: Anonymous request to the API server'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.56：匿名请求API服务器
- en: We can see that we were able to reach the server using an insecure connection.
    However, the API server treated our request as anonymous since there was no identity
    provided to our command.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们能够使用不安全连接到达服务器。然而，API服务器将我们的请求视为匿名，因为我们的命令没有提供身份。
- en: 'Now, to make commands easier, we can add the namespace, CA certificate (`ca.crt`),
    and the token to variables so that the API server knows the identity of the service
    account generating the API request:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使命令更容易，我们可以将命名空间、CA证书（`ca.crt`）和令牌添加到变量中，以便API服务器知道生成API请求的ServiceAccount的身份：
- en: '[PRE97]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Note that here we can use the values directly as they are in plaintext (not
    encoded) when looking from inside a pod, compared to having to decode them from
    a Secret. Now, we have all the parameters ready. When using bearer token authentication,
    the client should send this token in the header of the request, which is the authorization
    header. This should look like this: `Authorization: Bearer <token>`. Since we
    have added the token into a variable, we can simply use that. Let''s run the `curl`
    command to see whether we can list the pods using the identity of the ServiceAccount:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，当从Pod内部查看时，我们可以直接使用这些值，因为它们是明文（未编码的），而不是从Secret中解码。现在，我们已经准备好了所有参数。在使用持有者令牌身份验证时，客户端应该在请求的标头中发送这个令牌，即授权标头。这应该看起来像这样：`Authorization:
    Bearer <token>`。由于我们已经将令牌添加到一个变量中，我们可以简单地使用它。让我们运行`curl`命令，看看我们是否可以使用ServiceAccount的身份列出Pods：'
- en: '[PRE98]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You should get the following response:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下响应：
- en: '![Figure 4.57: Request to the API server using the default ServiceAccount'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.57：使用默认ServiceAccount向API服务器发出的请求
- en: '](image/B14870_04_57.jpg)'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_57.jpg)'
- en: 'Figure 4.57: Request to the API server using the default ServiceAccount'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.57：使用默认ServiceAccount向API服务器发出的请求
- en: 'Notice that we were able to reach the API server, and the API server verified
    the `"system:serviceaccount:default:default"` identity, which is represented in
    this format: `system:<resource_type>:<namespace>:<resource_name>` However, we
    still got a `Forbidden` error because ServiceAccounts do not have any permissions
    by default. We need to manually assign permissions to our default ServiceAccount
    in order to be able to list pods. This can be done by creating a RoleBinding and
    linking it to the `view` ClusterRole.'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们能够到达API服务器，并且API服务器验证了`"system:serviceaccount:default:default"`的身份，它的表示形式是：`system:<resource_type>:<namespace>:<resource_name>`。然而，我们仍然得到了`Forbidden`错误，因为默认情况下ServiceAccounts没有任何权限。我们需要手动为我们的默认ServiceAccount分配权限，以便能够列出Pods。这可以通过创建一个RoleBinding并将其链接到`view`
    ClusterRole来完成。
- en: 'Open another terminal window, ensuring that you don''t close the terminal session
    running the `my-bash` pod (because the pod will be deleted and you will lose your
    progress if you close it). Now, in the second terminal session, you can run the
    following command to create a `rolebinding defaultSA`-view to attach the `view`
    ClusterRole to the ServiceAccount:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 打开另一个终端窗口，确保不要关闭运行`my-bash` pod的终端会话（因为如果关闭它，pod将被删除，您将丢失进度）。现在，在第二个终端会话中，您可以运行以下命令来创建一个`rolebinding
    defaultSA`-view，将`view` ClusterRole附加到ServiceAccount：
- en: '[PRE99]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Note
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The view ClusterRole should already exist for your Kubernetes cluster, as it
    is one of the default ClusterRoles available for use.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 查看ClusterRole应该已经存在于您的Kubernetes集群中，因为它是可供使用的默认ClusterRoles之一。
- en: 'As you might recall from the previous chapter, this is an imperative approach
    to creating resources; you will learn how to create manifests for RBAC policies
    in *Chapter 13*, *Runtime and Network Security in Kubernetes*. Note that we have
    to specify the ServiceAccount as `<namespace>:<ServiceAccountName>`, and we have
    a `--namespace` flag since a RoleBinding can only apply to the ServiceAccounts
    within that namespace. You should get the following response:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能还记得上一章所述，这是一种创建资源的命令性方法；您将学习如何在《第13章 Kubernetes中的运行时和网络安全》中为RBAC策略创建清单。请注意，我们必须将ServiceAccount指定为`<namespace>:<ServiceAccountName>`，并且我们有一个`--namespace`标志，因为RoleBinding只能应用于该命名空间内的ServiceAccounts。您应该会得到以下响应：
- en: '[PRE100]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now, go back to the terminal window where we accessed the `my-bash` pod. With
    the necessary permissions set, let''s try our curl command again:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们访问`my-bash` pod的终端窗口。权限设置完成后，让我们再次尝试curl命令：
- en: '[PRE101]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'You should get the following response:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到以下响应：
- en: '![Figure 4.58: Successful response from the API server'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.58：API服务器的成功响应'
- en: '](image/B14870_04_58.jpg)'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_58.jpg)'
- en: 'Figure 4.58: Successful response from the API server'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.58：API服务器的成功响应
- en: Our ServiceAccount can now authenticate with the API server, and it is authorized
    to list pods in the default namespace.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的ServiceAccount现在可以与API服务器进行身份验证，并且被授权列出默认命名空间中的pod。
- en: It is also valid to use ServiceAccount bearer tokens outside the cluster. You
    may want to use tokens instead of certificates as an identity for long-standing
    jobs since the token does not expire as long as the ServiceAccount exists, whereas
    a certificate has an expiry date set by the certificate-issuing authority. An
    example of this is CI/CD pipelines, where external services commonly use ServiceAccount
    bearer tokens for authentication.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群外部使用ServiceAccount令牌也是有效的。您可能希望在长期运行的作业中使用令牌而不是证书作为身份标识，因为只要ServiceAccount存在，令牌就不会过期，而证书的到期日期由颁发证书的机构设置。一个例子是CI/CD流水线，外部服务通常使用ServiceAccount令牌进行身份验证。
- en: 'Activity 4.01: Creating a Deployment Using a ServiceAccount Identity'
  id: totrans-650
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动4.01：使用ServiceAccount身份创建部署
- en: In this activity, we will bring together all that we have learned in this chapter.
    We will be using various operations on our cluster and using different methods
    to access the API server.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将汇集本章学到的所有知识。我们将在集群上使用各种操作，并使用不同的方法访问API服务器。
- en: 'Perform the following operations using kubectl:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 使用kubectl执行以下操作：
- en: Create a new namespace called `activity-example`.
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`activity-example`的新命名空间。
- en: Create a new ServiceAccount called `activity-sa`.
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`activity-sa`的新ServiceAccount。
- en: Create a new RoleBinding called `activity-sa-clusteradmin` to attach the `activity-sa`
    ServiceAccount to the `cluster-admin` ClusterRole (which exists by default). This
    step is to ensure that our ServiceAccount has the necessary permissions to interact
    with the API server as a cluster admin.
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`activity-sa-clusteradmin`的新RoleBinding，将`activity-sa` ServiceAccount附加到`cluster-admin`
    ClusterRole（默认情况下存在）。这一步是为了确保我们的ServiceAccount具有与集群管理员交互所需的权限。
- en: 'Perform the following operations using curl with bearer tokens for authentication:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 使用curl和持有者令牌进行以下操作进行身份验证：
- en: Create a new NGINX Deployment with the identity of the `activity-sa` ServiceAccount.
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`activity-sa` ServiceAccount的身份创建一个新的NGINX部署。
- en: 'List the pods in your Deployment. Once you use curl to check the Deployment,
    if you have successfully gone through the previous steps, you should get a response
    that looks something like this:![Figure 4.59: Expected response when checking
    the Deployment'
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出部署中的pod。一旦您使用curl检查部署，如果您已经成功完成了前面的步骤，您应该会得到一个类似于以下内容的响应：![图4.59：检查部署时的预期响应
- en: '](image/B14870_04_59.jpg)'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_04_59.jpg)'
- en: 'Figure 4.59: Expected response when checking the Deployment'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.59：检查部署时的预期响应
- en: 'Finally, delete the namespace with all associated resources. When using curl
    to delete a namespace, you should see a response with `phase` set to `terminating`
    for the `status` field of the namespace resource, as in the following screenshot:'
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，删除所有相关资源的命名空间。当使用curl删除命名空间时，您应该看到一个响应，其中`status`字段的`phase`设置为`terminating`，如下面的屏幕截图所示：
- en: '[PRE102]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Note
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在以下地址找到：[https://packt.live/304PEoD](https://packt.live/304PEoD)。
- en: Summary
  id: totrans-665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a closer look at the Kubernetes API server, the way
    that Kubernetes uses the RESTful API, and how API resources are defined. We learned
    that all commands from the kubectl command-line utility are translated into RESTful
    HTTP API calls and are sent to the API server. We learned that API calls go through
    multiple stages, including authentication, authorization, and admission control.
    We also had a closer look at each stage and some of the modules involved.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更仔细地研究了Kubernetes API服务器，Kubernetes如何使用RESTful API以及API资源的定义方式。我们了解到kubectl命令行实用程序中的所有命令都被转换为RESTful
    HTTP API调用，并发送到API服务器。我们了解到API调用经过多个阶段，包括身份验证、授权和准入控制。我们还更仔细地研究了每个阶段和一些涉及的模块。
- en: Then, we learned about some API resources, how they are categorized as namespace-scoped
    or cluster-scoped resources, and their API group and API version. We then learned
    how we can use this information to build an API path for interacting with the
    Kubernetes API.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们了解了一些API资源，它们是如何分类为命名空间范围或集群范围的资源，以及它们的API组和API版本。然后，我们学习了如何使用这些信息来构建与Kubernetes
    API交互的API路径。
- en: We also applied what we learned by making an API call directly to the API server,
    using the curl HTTP client to interact with objects by using different authentication
    methods, such as ServiceAccounts and an X.509 certificate.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过直接向API服务器发出API调用，使用curl HTTP客户端以不同的身份验证方法与对象进行交互，例如ServiceAccounts和X.509证书。
- en: In the next few chapters, we will inspect most of the commonly used API objects
    more closely, mainly focusing on the different functionalities offered by these
    objects to enable us to deploy and maintain our application in a Kubernetes cluster.
    We will begin this series of chapters by taking a look at the basic unit of deployment
    in Kubernetes (pods) in the next chapter.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将更仔细地检查大多数常用的API对象，主要关注这些对象提供的不同功能，以使我们能够在Kubernetes集群中部署和维护我们的应用程序。我们将从下一章开始，通过查看Kubernetes中部署的基本单元（pod）来开始这一系列章节。
