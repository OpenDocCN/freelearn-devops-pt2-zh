- en: 16\. Kubernetes Admission Controllers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16. Kubernetes准入控制器
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will learn about Kubernetes admission controllers and use
    them to modify or validate incoming API requests. This chapter describes the utility
    of Kubernetes admission controllers and how they offer to extend the capabilities
    of your Kubernetes cluster. You will learn about several built-in admission controllers
    and the difference between mutating and validating controllers. By the end of
    this chapter, you will be able to create your own custom admission controllers
    and apply this knowledge to build a controller for your required scenario.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Kubernetes准入控制器，并使用它们来修改或验证传入的API请求。本章描述了Kubernetes准入控制器的实用性，以及它们如何扩展您的Kubernetes集群的功能。您将了解几个内置的准入控制器，以及变异和验证控制器之间的区别。在本章结束时，您将能够创建自己的自定义准入控制器，并将这些知识应用于构建适合您所需场景的控制器。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In *Chapter 4*, *How to Communicate with Kubernetes (API Server)*, we learned
    how Kubernetes exposes its **Application Programming Interface** (**API**) to
    interact with the Kubernetes platform. You also studied how to use kubectl to
    create and manage various Kubernetes objects. The kubectl tool is simply a client
    to the Kubernetes API server. Kubernetes master nodes host the API server through
    which anyone can communicate with the cluster. The API server provides a way to
    communicate with Kubernetes for not only external actors but also all internal
    components, such as the kubelet running on a worker node.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4章*中，*如何与Kubernetes（API服务器）通信*，我们学习了Kubernetes如何将其**应用程序编程接口**（**API**）暴露出来，以便与Kubernetes平台进行交互。您还学习了如何使用kubectl来创建和管理各种Kubernetes对象。
    kubectl工具只是Kubernetes API服务器的客户端。 Kubernetes主节点托管API服务器，通过它任何人都可以与集群通信。 API服务器不仅为外部参与者提供了与Kubernetes通信的方式，还为所有内部组件（例如运行在工作节点上的kubelet）提供了通信的方式。
- en: The API server is the central access point to our cluster. If we want to make
    sure that our organization's default set of best practices and policies are enforced,
    there is no better place to check for and apply them than at the API server. Kubernetes
    provides this exact capability via **admission controllers**.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: API服务器是我们集群的中央访问点。如果我们想确保我们组织的默认最佳实践和策略得到执行，那么检查和应用它们的最佳地方就是在API服务器上。 Kubernetes通过**准入控制器**提供了这种能力。
- en: Let's take a moment to understand why admission controllers are useful. Consider,
    for example, that we have a policy of a standard set of labels in all the objects
    to assist in the reporting of groups of objects per business unit. This might
    be important for getting specific data, such as how many Pods are being executed
    by the integration team. If we are managing and monitoring objects based on their
    labels, then any objects without the required labels can hamper our management
    and monitoring practices. Therefore, we would want to implement a policy that
    will prevent an object from being created if these labels are not defined in the
    object specification. This requirement can be easily implemented using admission controllers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间来了解为什么准入控制器很有用。例如，假设我们有一个标准的标签集策略，用于在所有对象中协助报告每个业务单元的对象组。这对于获取特定数据可能很重要，例如集成团队正在执行多少个Pod。如果我们根据它们的标签来管理和监控对象，那么没有所需标签的对象可能会妨碍我们的管理和监控实践。因此，我们希望实施一个策略，如果对象规范中未定义这些标签，则将阻止创建对象。这个要求可以很容易地通过准入控制器来实现。
- en: Note
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Open Policy Agent is a good example of how webhooks can be used to build an
    extensible platform to apply standards on the Kubernetes objects. You can find
    more details about it at this link: [https://www.openpolicyagent.org/docs/latest/kubernetes-admission-control](https://www.openpolicyagent.org/docs/latest/kubernetes-admission-control).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Open Policy Agent是一个很好的例子，展示了如何使用webhooks来构建一个可扩展的平台，以在Kubernetes对象上应用标准。您可以在此链接找到更多详细信息：[https://www.openpolicyagent.org/docs/latest/kubernetes-admission-control](https://www.openpolicyagent.org/docs/latest/kubernetes-admission-control)。
- en: Admission controllers are a set of components that intercept all calls to the
    Kubernetes API server and provide a way to make sure that any requests are meeting
    the desired criteria. It is important to note that the controllers are invoked
    after the API call is authenticated and authorized and before the objects are
    actioned and stored in etcd. This provides a perfect opportunity to implement
    control and governance, apply standards, and accept or reject the API requests
    to keep the cluster in the desired shape. Let's take a look at how admission controllers
    work in the Kubernetes cluster.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 准入控制器是一组组件，拦截所有对Kubernetes API服务器的调用，并提供一种确保任何请求都符合所需标准的方法。重要的是要注意，这些控制器在API调用经过身份验证和授权后被调用，而在对象被操作和存储在etcd之前被调用。这提供了一个完美的机会来实施控制和治理，应用标准，并接受或拒绝API请求，以保持集群的期望状态。让我们来看看准入控制器在Kubernetes集群中是如何工作的。
- en: How Admission Controllers Work
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准入控制器的工作原理
- en: 'Kubernetes provides a set of more than 25 admission controllers. A set of admission
    controllers is enabled by default and the cluster administrator can pass flags
    to the API server to control enabling/disabling the additional controllers (configuring
    the API server in a production-grade cluster is outside the scope of this book).
    These can be broadly divided into two types:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了一组超过25个准入控制器。一组准入控制器默认启用，集群管理员可以向API服务器传递标志来控制启用/禁用其他控制器（配置生产级集群中的API服务器超出了本书的范围）。这些可以大致分为两种类型：
- en: '**Mutating admission controllers** allow you to modify the request before it
    gets applied to the Kubernetes platform. `LimitRanger` is one such example, which
    applies the `defaultRequests` to the Pod if it is undefined by the Pod itself.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变异准入控制器**允许您在应用到Kubernetes平台之前修改请求。`LimitRanger`就是一个例子，如果Pod本身未定义，则将`defaultRequests`应用于Pod。'
- en: '**Validating admission controllers** validate the request and cannot change
    the request object. If this controller rejects the request, it will not be actioned
    by the Kubernetes platform. An example of this would be the `NamespaceExists`
    controller, which rejects the request if the namespace referenced in the request
    is not available.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证准入控制器**验证请求，不能更改请求对象。如果此控制器拒绝请求，Kubernetes平台将不会执行该请求。一个例子是`NamespaceExists`控制器，如果请求中引用的命名空间不可用，则会拒绝该请求。'
- en: Essentially, admission controllers are executed in two phases. In the first
    phase, mutating admission controllers are executed, and, in the second phase,
    validating admission controllers are executed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，准入控制器分为两个阶段执行。在第一阶段，执行变异准入控制器，在第二阶段，执行验证准入控制器。
- en: Note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on the situation, it might be a good idea to avoid using mutating
    controllers because they change the state of the request, and the caller may not
    be aware of the changes. Instead, you can use a validating controller to reject
    an invalid request and let the caller fix the request.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 根据情况，最好避免使用变异控制器，因为它们会改变请求的状态，调用者可能不知道这些变化。相反，您可以使用验证控制器来拒绝无效的请求，并让调用者修复请求。
- en: 'A high-level overview of admission controllers is illustrated in the following
    figure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 准入控制器的高级概述如下图所示：
- en: '![Figure 16.1: Stages of an API request for creating an object'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.1：创建对象的API请求的阶段'
- en: '](image/B14870_16_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_01.jpg)'
- en: 'Figure 16.1: Stages of an API request for creating an object'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1：创建对象的API请求的阶段
- en: 'When the Kubernetes API server receives an API call (which can be made via
    kubectl or the kubelet running on other nodes), it passes the call through the
    following phases:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当Kubernetes API服务器接收到API调用（可以通过kubectl或在其他节点上运行的kubelet进行调用），它会将调用通过以下阶段：
- en: Perform authentication and authorization of the call to make sure that the caller
    is authenticated and RBAC policies are applied.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行调用的身份验证和授权，以确保调用者已经过身份验证并应用了RBAC策略。
- en: Run the payload through all of the existing mutating controllers. Mutating controllers
    are those that can change the object sent by the client.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将有效负载通过所有现有的变异控制器。变异控制器是可以更改客户端发送的对象的控制器。
- en: Check whether the object abides by the defined schema and whether all of the
    fields are valid.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查对象是否符合定义的模式，以及所有字段是否有效。
- en: Run the payload through all of the existing validating controllers. These controllers
    validate the final objects.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将有效负载通过所有现有的验证控制器。这些控制器验证最终对象。
- en: Store the objects in the etcd datastore.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象存储在etcd数据存储中。
- en: You can see from *Figure 16.1* that some admission controllers have something
    called **webhooks** attached to them. This might not be true for all admission
    controllers. We will learn more about webhooks in the later sections of this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图16.1*可以看出，一些准入控制器附有称为**webhooks**的东西。这可能并非所有准入控制器都是如此。我们将在本章的后面部分了解更多关于webhooks的内容。
- en: Note that some of the controllers provide functionality both as mutating and
    validating controllers. In fact, a few Kubernetes functions are implemented as
    admission controllers. For example, when a Kubernetes namespace enters the terminating
    state, the `NamespaceLifecycle` admission controller prevents new objects from
    being created in the terminating namespace.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一些控制器既提供变异功能，也提供验证功能。实际上，一些Kubernetes功能是作为准入控制器实现的。例如，当Kubernetes命名空间进入终止状态时，“NamespaceLifecycle”准入控制器会阻止在终止命名空间中创建新对象。
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'We will only cover a few admission controllers in this chapter for brevity.
    Please refer to this link for a complete list of the controllers that are available:
    [https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 出于简洁起见，本章只涵盖了一些准入控制器。请参考此链接，了解可用的控制器的完整列表：[https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do)。
- en: 'Let''s confirm that our Minikube setup is configured to run admission controllers.
    Run the following command to start Minikube with all of the required plugins enabled:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确认我们的Minikube设置已配置为运行准入控制器。运行以下命令以启动Minikube，并启用所有必需的插件：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should see a response like the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下截图的响应：
- en: '![Figure 16.2: Starting up Minikube with all of the required plugins'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.2：启动Minikube并启用所有必需的插件'
- en: to run admission controllers
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 运行准入控制器
- en: '](image/B14870_16_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_02.jpg)'
- en: 'Figure 16.2: Starting up Minikube with all of the required plugins to run admission
    controllers'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2：启动Minikube并启用所有必需的插件以运行准入控制器
- en: Now that we have had an overview of the built-in admission controllers, let's
    take a look at how we can make an admission controller using our own custom logic.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概述了内置准入控制器，让我们看看如何使用我们自己的自定义逻辑创建一个准入控制器。
- en: Creating Controllers with Custom Logic
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有自定义逻辑的控制器
- en: As mentioned earlier, Kubernetes provides a list of controllers with predefined
    functionality. These controllers are baked into the Kubernetes server binary.
    However, what happens if you need to have your own policy or standard to check
    against, and none of the admission controllers fit your requirements?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Kubernetes提供了一系列具有预定义功能的控制器。这些控制器已经内置到Kubernetes服务器二进制文件中。但是，如果您需要拥有自己的策略或标准来进行检查，并且没有一个准入控制器符合您的要求，会发生什么呢？
- en: To address such a requirement, Kubernetes provides something called **admission
    webhooks**. There are two types of admission webhooks, which we will study in
    the following sections.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这样的需求，Kubernetes提供了称为**准入Webhook**的东西。准入Webhook有两种类型，我们将在以下部分进行学习。
- en: The Mutating Admission Webhook
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变更准入Webhook
- en: The **mutating admission webhook** is a type of mutating admission controller
    that doesn't have any logic of its own. Instead, it allows you to define a URL
    that will be called by the Kubernetes API server. This URL is the address to our
    webhook. Functionally, a webhook is an HTTPS server that accepts requests, processes
    them, and then responds back.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**变更准入Webhook**是一种变更准入控制器，它本身没有任何逻辑。相反，它允许您定义一个URL，Kubernetes API服务器将调用该URL。这个URL就是我们Webhook的地址。从功能上讲，Webhook是一个接受请求、处理请求，然后做出响应的HTTPS服务器。'
- en: If multiple URLs are defined, they are processed in a chain, that is, the output
    of the first webhook becomes the input for the second webhook.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了多个URL，则它们将按链式处理，即第一个Webhook的输出将成为第二个Webhook的输入。
- en: The Kubernetes API server sends a payload (the AdmissionReview object) to the
    webhook URL with the request being processed. You can modify the request as per
    your requirement (for example, by adding a custom annotation) and send back a
    modified request. The Kubernetes API server will use the modified object in the
    next stages of creating the resource.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API服务器将一个负载（AdmissionReview对象）发送到Webhook URL，请求正在处理中。您可以根据需要修改请求（例如，添加自定义注释）并发送回修改后的请求。Kubernetes
    API服务器将在创建资源的下一个阶段使用修改后的对象。
- en: 'The execution flow will be as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 执行流程将如下：
- en: 'The Kubernetes API receives a request for creating an object. For example,
    let''s say you want to create a Pod that is defined as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes API接收到创建对象的请求。例如，假设您想创建一个如下所定义的Pod：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Kubernetes calls a webhook, defined as `MutatingAdmissionWebHook`, and passes
    the object definition to it. In this case, it's the Pod specification.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes调用一个名为`MutatingAdmissionWebHook`的Webhook，并将对象定义传递给它。在这种情况下，它是Pod规范。
- en: 'The webhook (which is the custom code written by you) receives the object and
    modifies it as per the custom rules. Let''s say, for example, it adds the custom
    annotation, `podModified="true"`. After modification, the object will look like this:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Webhook（由您编写的自定义代码）接收对象并根据自定义规则进行修改。例如，它添加自定义注释`podModified="true"`。修改后，对象将如下所示：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The webhook returns the modified object.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Webhook返回修改后的对象。
- en: Kubernetes will treat the modified object as if it was the original request
    and move on.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes将修改后的对象视为原始请求并继续进行。
- en: 'The flow mentioned earlier can be visualized as follows. Note that the flow
    is simplified so that you can understand the major stages:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的流程可以可视化如下。请注意，该流程经过简化，以便您理解主要阶段：
- en: '![Figure 16.3: Process flow for the mutating admission webhook'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.3：变更准入Webhook的流程'
- en: '](image/B14870_16_03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_03.jpg)'
- en: 'Figure 16.3: Process flow for the mutating admission webhook'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3：变异入场Webhook的流程
- en: The Validating Admission Webhook
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证入场Webhook
- en: The second type of webhook is the validating admission webhook. This hook, similar
    to a mutating admission webhook, doesn't have any logic of its own. Following
    the same pattern, it allows us to define a URL, which ultimately provides the
    logic that decides to accept or reject this call.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型的Webhook是验证入场Webhook。这个钩子与变异入场Webhook类似，没有自己的逻辑。按照相同的模式，它允许我们定义一个URL，最终提供决定接受或拒绝此调用的逻辑。
- en: The main difference is that a validating webhook cannot modify the request and
    can only allow or reject a request. If this webhook rejects the request, Kubernetes
    will send an error back to the caller; otherwise, it will proceed to execute the
    request further.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于验证Webhook不能修改请求，只能允许或拒绝请求。如果此Webhook拒绝请求，Kubernetes将向调用者发送错误；否则，它将继续执行请求。
- en: How a Webhook Works
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webhook的工作原理
- en: Webhooks are deployed as Pods in the Kubernetes cluster, and the Kubernetes
    API server calls them over SSL using the **AdmissionReview** object. This object
    defines the **AdmissionRequest** and **AdmissionResponse** objects. The webhook
    reads the request payload from the AdmissionRequest object and provides the success
    flag and optional changes in the AdmissionResponse object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Webhook部署为Kubernetes集群中的Pod，并且Kubernetes API服务器使用AdmissionReview对象通过SSL调用它们。该对象定义AdmissionRequest和AdmissionResponse对象。Webhook从AdmissionRequest对象中读取请求有效负载，并在AdmissionResponse对象中提供成功标志和可选更改。
- en: 'The following is a top-level definition of the AdmissionReview object. Note
    that AdmissionRequest and AdmissionResponse are both part of the AdmissionReview
    object. The following is an excerpt from the definition of the AdmissionReview
    object in the Kubernetes source code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是AdmissionReview对象的顶级定义。请注意，AdmissionRequest和AdmissionResponse都是AdmissionReview对象的一部分。以下是Kubernetes源代码中AdmissionReview对象定义的摘录：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This snippet is an extract from the Kubernetes source code. You can view more
    details of the AdmissionReview objects at this link: [https://github.com/kubernetes/api/blob/release-1.16/admission/v1beta1/types.go](https://github.com/kubernetes/api/blob/release-1.16/admission/v1beta1/types.go).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此片段是从Kubernetes源代码中提取的。您可以在此链接查看AdmissionReview对象的更多详细信息：[https://github.com/kubernetes/api/blob/release-1.16/admission/v1beta1/types.go](https://github.com/kubernetes/api/blob/release-1.16/admission/v1beta1/types.go)。
- en: The same AdmissionReview object is used for both mutating and validating admission
    webhooks. A mutating webhook calculates the changes required to meet the custom
    requirements that you have coded in the webhook. These changes (defined as a patch)
    are passed in the `patch` field, along with a `patchType` field in the AdmissionResponse
    object. The API server then applies that patch to the original object and the
    resultant object is persisted in the API server. To validate the webhook, these
    two fields are kept empty.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的AdmissionReview对象用于变异和验证入场Webhook。变异Webhook计算满足Webhook中编码的自定义要求所需的更改。这些更改（定义为补丁）与AdmissionResponse对象中的`patchType`字段一起传递到`patch`字段中。然后API服务器将该补丁应用于原始对象，并将结果对象持久化在API服务器中。要验证Webhook，这两个字段保持为空。
- en: A validating admission webhook would simply set a flag to accept or reject a
    request, while a mutating admission webhook would set a flag whether or not the
    request was successfully modified as per the request.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 验证入场Webhook只需设置一个标志以接受或拒绝请求，而变异入场Webhook将设置一个标志，指示请求是否已根据请求成功修改。
- en: First, let's take a closer look at how we can manually patch an object, which
    will help you to build a webhook that can patch an object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更仔细地看一下如何手动修补一个对象，这将帮助您构建一个可以修补对象的Webhook。
- en: 'You can manually patch an object using the `kubectl patch` command. As an example,
    let''s say that you want to add a field to the `.metadata.annotation` section
    in an object. To do that, the command would look like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`kubectl patch`命令手动打补丁一个对象。例如，假设您想在对象的`.metadata.annotation`部分添加一个字段。命令将如下所示：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note the double space before and after the field that we want to add (shown
    in the preceding command as `{"new":"annotation"}`). Let's implement this in an
    exercise where we will also learn how this command can be used with a JSON payload.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们要添加的字段之前和之后的双空格（在前面的命令中显示为`{"new":"annotation"}`）。让我们在一个练习中实现这个，并学习如何使用JSON负载来使用这个命令。
- en: 'Exercise 16.01: Modifying a ConfigMap Object through a Patch'
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16.01：通过补丁修改ConfigMap对象
- en: 'In this exercise, we will patch a ConfigMap using kubectl. We will add an annotation
    to the ConfigMap object. This annotation can later be used to group objects, similar
    to the use case that we mentioned in the *Introduction* section. Therefore, if
    multiple teams are using a cluster, we would want to track which teams are using
    which resources. Let''s begin the exercise:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用kubectl打补丁一个ConfigMap。我们将向ConfigMap对象添加一个注释。这个注释以后可以用来对对象进行分组，类似于我们在*介绍*部分提到的用例。因此，如果多个团队在使用一个集群，我们希望跟踪哪些团队在使用哪些资源。让我们开始练习：
- en: 'Create a namespace with the name `webhooks`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`webhooks`的命名空间：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see the following response:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, create a ConfigMap using the following command:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令创建一个ConfigMap：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will see the following response:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下响应：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Check the contents of the ConfigMap using the following command:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查ConfigMap的内容：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see the following response:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 16.4: Getting the contents of the ConfigMap in YAML format'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.4：以YAML格式获取ConfigMap的内容'
- en: '](image/B14870_16_04.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_04.jpg)'
- en: 'Figure 16.4: Getting the contents of the ConfigMap in YAML format'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4：以YAML格式获取ConfigMap的内容
- en: 'Now, let''s patch the ConfigMap with an annotation. The annotation we want
    to add is `teamname` with the value of `kubeteam`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用一个注释来打补丁ConfigMap。我们要添加的注释是`teamname`，值为`kubeteam`：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You will get the following response:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下响应：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In *Chapter 6*, *Labels and Annotations*, we learned that annotations are stored
    as key-value pairs. Therefore, a key can have only a value, and if a value already
    exists for the key (in this case, `teamname`), then the value will be overwritten
    by the new value. Therefore, ensure your webhook logic excludes the objects that
    already have the desired configuration.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第6章*，*标签和注释*中，我们学到注释被存储为键值对。因此，一个键只能有一个值，如果一个键已经存在值（在这种情况下是`teamname`），那么新值将覆盖旧值。因此，请确保您的webhook逻辑排除已经具有所需配置的对象。
- en: 'Now, let''s apply another patch using detailed patch instructions using JSON
    format to provide the required field:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用详细的补丁说明来应用另一个补丁，使用JSON格式提供所需的字段：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that there are three components of the patch: `op` (for operations such
    as `add`), `path` (for the location of the fields to patch), and `value` (which
    is the new value). You should see the following response:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意补丁的三个组成部分：`op`（用于操作，如`add`），`path`（用于要打补丁的字段的位置），和`value`（这是新值）。您应该看到以下响应：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is another way to apply the patch. You can see the preceding command, which
    is instructing Kubernetes to add a new annotation with the key as `custompatched`
    and the value as `true`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种应用补丁的方式。您可以看到前面的命令，它指示Kubernetes添加一个新的注释，键为`custompatched`，值为`true`。
- en: 'Now, let''s see whether the patch has been applied. Use the following command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看补丁是否已经应用。使用以下命令：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should see the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 16.5: Checking the modified annotations on our ConfigMap'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 16.5：检查我们的 ConfigMap 上修改的注释'
- en: '](image/B14870_16_05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_05.jpg)'
- en: 'Figure 16.5: Checking the modified annotations on our ConfigMap'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.5：检查我们的 ConfigMap 上修改的注释
- en: As you can see from the `annotations` field under `metadata`, both annotations
    have been applied to our ConfigMap. The platform team now knows who owns this
    ConfigMap object.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从 `metadata` 下的 `annotations` 字段中所看到的，这两个注释都已应用到我们的 ConfigMap 上。平台团队现在知道谁拥有这个
    ConfigMap 对象。
- en: Guidelines for Building a Mutating Admission WebHook
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建变更 Admission WebHook 的指南
- en: We now know all the parts of a working mutating admission webhook. Remember
    that the webhook is just a simple HTTPS server, and you can write it in your language
    of choice. Webhooks are deployed in the cluster as Pods. The Kubernetes API server
    will call these Pods over SSL on port 443 to mutate or validate the objects.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了工作中变更 Admission WebHook 的所有部分。请记住，Webhook 只是一个简单的 HTTPS 服务器，您可以使用自己选择的语言编写它。Webhook
    被部署为 Pod 在集群中。Kubernetes API 服务器将通过 SSL 在端口 443 上调用这些 Pod 来变更或验证对象。
- en: 'The pseudocode for building a webhook Pod will look like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 Webhook Pod 的伪代码将如下所示：
- en: A simple HTTPS server (the webhook) is set up in a Pod to accept POST calls.
    Note that the call must be over SSL.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Pod 中设置一个简单的 HTTPS 服务器（Webhook）来接受 POST 调用。请注意，调用必须通过 SSL 进行。
- en: Kubernetes will send the AdmissionReview object to the webhook through an HTTPS
    POST call.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 将通过 HTTPS POST 调用将 AdmissionReview 对象发送到 Webhook。
- en: The webhook code will process the AdmissionRequest object to get the details
    of the object in the request.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Webhook 代码将处理 AdmissionRequest 对象，以获取请求中对象的详细信息。
- en: The webhook code will optionally patch the object and set the response flag
    to indicate success or failure.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Webhook 代码将可选择地修补对象并将响应标志设置为指示成功或失败。
- en: The webhook code will populate the AdmissionResponse section in the AdmissionReview
    object with the updated request.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Webhook 代码将使用更新后的请求填充 AdmissionReview 对象中的 AdmissionResponse 部分。
- en: The webhook will respond to the POST call (received in *step 2*) with the AdmissionReview
    object.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Webhook 将使用 AdmissionReview 对象回应 POST 调用（在 *步骤 2* 中收到）。
- en: The Kubernetes API server will assess the response and, based on the flag, accept
    or reject the client request.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes API 服务器将评估响应，并根据标志接受或拒绝客户端请求。
- en: 'In the code for the webhook, we will specify the path and required modifications
    using JSON. Keep in mind from the previous exercise that, while patching, our
    patch object definition will contain the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Webhook 的代码中，我们将使用 JSON 指定路径和所需的修改。请记住，从之前的练习中，我们的修补对象定义将包含以下内容：
- en: '`op` specifies operations such as `add` and `replace`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`op` 指定操作，比如 `add` 和 `replace`。'
- en: '`path` specifies the location of the field we are trying to modify. Refer to
    the output of the command in *Figure 16.5* and note that different fields are
    located in different places. For example, the name is inside the metadata field,
    so the path for this will be `/metadata/name`.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path` 指定我们要修改的字段的位置。参考 *图 16.5* 中命令的输出，并注意不同的字段位于不同的位置。例如，名称位于 metadata 字段内，因此其路径将是
    `/metadata/name`。'
- en: '`value` specifies the value of the field.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value` 指定字段的值。'
- en: 'A simple mutating webhook written in Go should look like the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 用 Go 编写的简单变更 Webhook 应该如下所示：
- en: mutatingcontroller.go
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: mutatingcontroller.go
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The complete code for this example can be found at [https://packt.live/2GFRCot](https://packt.live/2GFRCot).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整代码可以在 [https://packt.live/2GFRCot](https://packt.live/2GFRCot) 找到。
- en: As you can see in the preceding code, the three main parts are the **AdmissionRequest**
    object, the **patch**, and the **AdmissionResponse** object with the patched information.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，三个主要部分是 **AdmissionRequest** 对象，**patch**，以及带有修补信息的 **AdmissionResponse**
    对象。
- en: So far, in this chapter, we have learned what the admission webhook is and how
    it interacts with the Kubernetes API server. We have also demonstrated that one
    way to change the requested objects is by using a patch. Now, let's apply what
    we have learned until now and deploy a webhook in our Kubernetes cluster.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经学习了什么是准入webhook，以及它如何与Kubernetes API服务器交互。我们还演示了通过使用补丁来更改请求的对象的一种方法。现在，让我们应用我们到目前为止学到的知识，在我们的Kubernetes集群中部署一个webhook。
- en: Remember that all communications between the API server and the webhook are
    over SSL. SSL is a protocol that is used for secure communication over a network.
    To do this, we need to create public and private keys, as you will see in the
    following exercise.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，API服务器和webhook之间的所有通信都是通过SSL进行的。SSL是一种用于网络安全通信的协议。为了做到这一点，我们需要创建公钥和私钥，正如你将在接下来的练习中看到的。
- en: Note that we have not yet built the code that goes into the webhook. First,
    let's demonstrate how to deploy the Pods (using Deployment) for a webhook using
    a pre-built container, and then we will go on to build the code that goes into
    the Pod to get the webhook up and running.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还没有构建进入webhook的代码。首先，让我们演示如何部署用于webhook的Pods（使用Deployment）使用预构建的容器，然后我们将继续构建进入Pod的代码，使webhook运行起来。
- en: 'Exercise 16.02: Deploying a Webhook'
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16.02：部署Webhook
- en: 'In this exercise, we''ll deploy a simple pre-built webhook server to Kubernetes.
    Remember that a webhook is just an HTTPS server, and that is exactly what we are
    going to create. When Kubernetes has to call the webhook endpoint over SSL, we
    will need to create a certificate for our call. Once we create our certificates
    for SSL communication, we will use the Kubernetes Deployment object to deploy
    our webhook:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在Kubernetes中部署一个简单的预构建webhook服务器。请记住，webhook只是一个HTTPS服务器，这正是我们要创建的。当Kubernetes需要通过SSL调用webhook端点时，我们需要为我们的调用创建一个证书。一旦我们为SSL通信创建了证书，我们将使用Kubernetes
    Deployment对象来部署我们的webhook：
- en: 'Create a **Certificate Authority** (**CA**) for a self-signed certificate.
    This CA will be later used to create trust between the Kubernetes and our webhook
    server for the HTTPS call:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自签名证书的**证书颁发机构**（**CA**）。这个CA将稍后用于在Kubernetes和我们的webhook服务器之间创建HTTPS调用的信任：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This should give you the following response:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给你以下的回应：
- en: '![Figure 16.6: Generating a self-signed certificate'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.6：生成自签名证书'
- en: '](image/B14870_16_06.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_06.jpg)'
- en: 'Figure 16.6: Generating a self-signed certificate'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：生成自签名证书
- en: Note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more about self-signed certificates at this link: [https://aboutssl.org/what-is-self-sign-certificate/](https://aboutssl.org/what-is-self-sign-certificate/).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此链接了解更多关于自签名证书的信息：[https://aboutssl.org/what-is-self-sign-certificate/](https://aboutssl.org/what-is-self-sign-certificate/)。
- en: 'Create the private key for the SSL call:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为SSL调用创建私钥：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see the following response:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下的回应：
- en: '![Figure 16.7: Creating the private key for the SSL call'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.7：为SSL调用创建私钥'
- en: '](image/B14870_16_07.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_07.jpg)'
- en: 'Figure 16.7: Creating the private key for the SSL call'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7：为SSL调用创建私钥
- en: 'Now sign the server certificate with the CA:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在用CA签署服务器证书：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that the name of the service in this command is the service that is going
    to expose our webhook within the cluster so that the API server can access it.
    We will revisit this name in *step 7*. You should see the following response:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此命令中服务的名称是将在集群中公开我们的webhook的服务，以便API服务器可以访问它。我们将在*步骤7*中重新访问这个名称。你应该会看到以下的回应：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we have created a certificate that our server can use. Next, we will just
    create a Kubernetes Secret to load the private key and certificate to our webhook server:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个我们的服务器可以使用的证书。接下来，我们将创建一个Kubernetes Secret，将私钥和证书加载到我们的webhook服务器中：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should see the following response:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our webhook will run as a Pod, which we will create using a Deployment. To
    do that, first, create a file named `mutating-server.yaml` with the following content:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的webhook将作为一个Pod运行，我们将使用部署来创建它。为此，首先创建一个名为`mutating-server.yaml`的文件，其中包含以下内容：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that we are linking to the premade image for the server that we have provided.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在链接到我们提供的服务器的预制图像。
- en: 'Create a Deployment using the YAML file that we created in the previous step:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们在上一步中创建的YAML文件创建部署：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should see the following response:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once the server is created, we need to create a Kubernetes Service. Note that
    the Service is accessible through `webhook-server.webhooks.svc`. This string,
    which we used in *step 3* while creating the certificate, is based on the fields
    defined in the following specification, in the format of `<SERVICENAME>.<NAMESPACENAME>.svc`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建服务器后，我们需要创建一个Kubernetes服务。请注意，服务可以通过`webhook-server.webhooks.svc`访问。这个字符串是我们在*步骤3*中创建证书时使用的，它基于以下规范中定义的字段，格式为`<SERVICENAME>.<NAMESPACENAME>.svc`。
- en: 'Create a file, named `mutating-serversvc.yaml`, to define a Service with the
    following specification:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`mutating-serversvc.yaml`的文件，以定义具有以下规范的服务：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using the definition from the previous step, create the Service using the following
    command:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上一步的定义，使用以下命令创建服务：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should see the following response:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this exercise, we have deployed a pre-built webhook and configured certificates
    such that our webhook is ready to accept calls from the Kubernetes API server.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们部署了一个预构建的webhook，并配置了证书，使得我们的webhook准备好接受来自Kubernetes API服务器的调用。
- en: Configuring the Webhook to Work with Kubernetes
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Webhook以与Kubernetes一起工作
- en: At this stage, we have created and deployed the webhook using a Deployment.
    Now, we need to register the webhook with Kubernetes so that Kubernetes knows
    about it. The way to do this is by creating a `MutatingWebHookConfiguration` object.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经使用部署创建并部署了webhook。现在，我们需要向Kubernetes注册webhook，以便Kubernetes知道它。这样做的方法是创建一个`MutatingWebHookConfiguration`对象。
- en: Note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more details about MutatingConfigurationWebhook at [https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/)找到有关MutatingConfigurationWebhook的更多详细信息。
- en: 'The following snippet shows an example of what the configuration object for
    `MutatingWebhookConfiguration` would look like:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段显示了`MutatingWebhookConfiguration`的配置对象的示例：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here are a few notable definitions from the preceding object:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述对象中的一些值得注意的定义：
- en: The `clientConfig.service` section defines the location of the mutating webhook
    (which we deployed in *Exercise 16.02*, *Deploying a Webhook*).
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`clientConfig.service`部分定义了变异webhook的位置（我们在*练习16.02*中部署的*部署webhook*）。'
- en: The `caBundle` section contains the certificate through which SSL trust will
    be established. This is the certificate, encoded in Base64 format. We will explain
    how to encode it in the next section.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`caBundle`部分包含SSL信任将建立的证书。这是以Base64格式编码的证书。我们将在下一节中解释如何对其进行编码。'
- en: The `rules` section defines what operations need to be intercepted. Here, we
    are instructing Kubernetes to intercept any calls to create a new Pod.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rules`部分定义了需要拦截的操作。在这里，我们指示Kubernetes拦截任何创建新Pod的调用。'
- en: How to Encode a Certificate in Base64 Format
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何以Base64格式编码证书
- en: As pointed out earlier, when the Kubernetes API server calls the webhook, the
    call is encrypted over SSL, and we need to provide the SSL trust certificate in
    the webhook definition. This can be seen in the `caBundle` field in the definition
    of `MutatingWebhookConfiguration` shown in the previous section. The data in this
    field is Base64-encoded, as you learned in *Chapter 10*, *ConfigMaps and Secrets*.
    The following commands can be used to encode a certificate in Base64 format.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当Kubernetes API服务器调用webhook时，调用是通过SSL加密的，我们需要在webhook定义中提供SSL信任证书。这可以在前一节中显示的`MutatingWebhookConfiguration`定义中的`caBundle`字段中看到。该字段中的数据是Base64编码的，正如您在*第10章*，*ConfigMaps和Secrets*中学到的。以下命令可用于将证书编码为Base64格式。
- en: 'First, convert the generated file into Base64 format using the following command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用以下命令将生成的文件转换为Base64格式：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since we need to convert the generated CA bundle into the Base64 format and
    put it in the YAML file (as mentioned earlier), we need to remove the newline
    (`\n`) characters. The following commands could be used to do this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要将生成的CA捆绑包转换为Base64格式并放入YAML文件中（如前所述），我们需要删除换行符（`\n`）字符。可以使用以下命令来执行此操作：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Both of these commands do not show any response in the terminal upon successful
    execution. At this stage, you will have the CA bundle inside the `onelinecert.pem`
    file, which you can copy to create your YAML definitions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令在成功执行后不会在终端上显示任何响应。在这个阶段，您将在`onelinecert.pem`文件中拥有CA捆绑包，您可以复制它来创建您的YAML定义。
- en: 'Activity 16.01: Creating a Mutating Webhook That Adds an Annotation to a Pod'
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Activity 16.01：创建一个可变的Webhook，向Pod添加注释
- en: In this activity, we are using the knowledge we have acquired in this and earlier
    chapters to create a mutating webhook that adds a custom annotation to a Pod.
    There can be many use cases for such a webhook. For example, you might want to
    record whether the container image is coming from the previously approved repository
    or not, for future reporting. Extending this further, you can also schedule Pods
    from different repositories on different nodes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将利用我们在本章和之前章节中所学到的知识来创建一个可变的webhook，它会向Pod添加一个自定义注释。这样的webhook可能有许多用例。例如，您可能希望记录容器镜像是否来自先前批准的存储库，以供将来报告。进一步扩展，您还可以在不同的节点上从不同的存储库调度Pods。
- en: 'The high-level steps for completing this activity are as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动的高级步骤如下：
- en: Create a new namespace named `webhooks`. If it exists already, delete the existing
    namespace and then create it again.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`webhooks`的新命名空间。如果已经存在，则删除现有的命名空间，然后再次创建它。
- en: Generate the self-signed CA certificate.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成自签名的CA证书。
- en: Generate a private/public key pair for SSL and sign it with the CA certificate.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为SSL生成私钥/公钥对并使用CA证书进行签名。
- en: Create a secret that holds the private/public key pair generated in the previous step.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个保存在先前步骤中生成的私钥/公钥对的密钥。
- en: Write the webhook code to add a custom annotation in the Pod.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写webhook代码以在Pod中添加自定义注释。
- en: Package the webhook server code as a Docker container.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将webhook服务器代码打包为Docker容器。
- en: Push the Docker container to a public repository of your choice.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Docker容器推送到您选择的公共存储库。
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you have any difficulty building your own webhook, you can use the code
    available at this link as a reference: [https://packt.live/2R1vJlk](https://packt.live/2R1vJlk).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在构建自己的webhook时遇到任何困难，可以使用此链接中提供的代码作为参考：[https://packt.live/2R1vJlk](https://packt.live/2R1vJlk)。
- en: 'If you want to avoid building and packaging a webhook, we have provided a pre-built
    container so that you can use it directly in your Deployment. You can use this
    image from Docker Hub: `packtworkshops/the-kubernetes-workshop:webhook`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想避免构建和打包webhook，我们提供了一个预构建的容器，这样你就可以直接在你的部署中使用它。你可以从Docker Hub使用这个图像：`packtworkshops/the-kubernetes-workshop:webhook`。
- en: Using this image allows you to skip *steps 5* to *7*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此图像可以跳过*步骤5*至*7*。
- en: Create a Deployment that deploys the webhook server.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个部署，部署webhook服务器。
- en: Expose the webhooks Deployment as a Kubernetes Service.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将webhooks部署公开为Kubernetes服务。
- en: Create a Base64-encoded version of the CA certificate.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建CA证书的Base64编码版本。
- en: Create a `MutatingWebHookConfiguration` object so that Kubernetes can intercept
    the API call and call our webhook.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MutatingWebHookConfiguration`对象，以便Kubernetes可以拦截API调用并调用我们的webhook。
- en: At this stage, our webhook has been created. Now, to test whether our webhook
    is working, create a simple Pod with no annotations.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的webhook已经创建。现在，为了测试我们的webhook是否工作，创建一个没有注释的简单Pod。
- en: 'Once the Pod is created, make sure that the annotation is added to the Pod
    by describing it. Here is a truncated version of the expected output. Note that
    the annotation here is supposed to be added by our webhook:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Pod被创建，确保通过描述它来添加注释到Pod。这里是预期输出的截断版本。请注意，这里的注释应该是由我们的webhook添加的：
- en: '![Figure 16.8: Expected output of Activity 16.01'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.8：活动16.01的预期输出'
- en: '](image/B14870_16_08.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_08.jpg)'
- en: 'Figure 16.8: Expected output of Activity 16.01'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8：活动16.01的预期输出
- en: Note
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 799.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第799页找到。
- en: Validating a Webhook
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证Webhook
- en: We have learned that the mutating webhook essentially allows the modification
    of Kubernetes objects. The other kind of webhook is called a validating webhook.
    As the name suggests, this webhook does not allow any change in the Kubernetes
    objects; instead, it works as a gatekeeper to our cluster. It allows us to write
    code that can validate any Kubernetes object being requested and allow or reject
    the request based on the conditions that we specify.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，变异webhook基本上允许修改Kubernetes对象。另一种webhook称为验证webhook。顾名思义，这个webhook不允许对Kubernetes对象进行任何更改；相反，它作为我们集群的守门人。它允许我们编写代码，可以验证任何被请求的Kubernetes对象，并根据我们指定的条件允许或拒绝请求。
- en: Let's understand how this can be helpful using an example. Let's assume that
    our Kubernetes cluster is used by many teams, and we want to know which Pods are
    associated with which teams. One solution is to ask all the teams to add a label
    on their Pod (for example, a label with the key as `teamName` and the name of
    the team as the value). As you can guess, it is not a standard Kubernetes feature
    to enforce a set of labels. In this case, we would need to create our own logic
    to disallow Pods that do not have these labels.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解这如何有帮助。假设我们的Kubernetes集群被许多团队使用，我们想知道哪些Pod与哪些团队相关联。一个解决方案是要求所有团队在其Pod上添加一个标签（例如，键为`teamName`，值为团队名称）。正如你所猜测的那样，强制执行一组标签不是标准的Kubernetes功能。在这种情况下，我们需要创建自己的逻辑来禁止没有这些标签的Pod。
- en: One way to achieve this is to write a validating webhook that looks for this
    label in any requests for Pods and reject the creation of the requested Pods if
    this label does not exist. You are going to do exactly this in *Activity 16.02*,
    *Creating a Validating Webhook that Checks for a Label in a Pod* later in the
    chapter. For now, let's take a look at what the code for a validating webhook
    will look like.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的一种方法是编写一个验证webhook，查找任何Pod请求中的此标签，并拒绝创建请求的Pod，如果此标签不存在。您将在本章后面的*活动16.02*中做到这一点，*创建一个验证webhook，检查Pod中是否存在标签*。现在，让我们看一下验证webhook的代码将是什么样子。
- en: Coding a Simple Validating WebHook
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个简单的验证WebHook
- en: 'Let''s take a look at an excerpt from the code for a simple validating webhook:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一段简单验证webhook代码的摘录：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The three main parts that you can observe in this snippet are the AdmissionRequest
    object, the logic to check whether the label exists, and creating the AdmissionResponse
    object with the Allowed flag.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此片段中观察到的三个主要部分是AdmissionRequest对象，检查标签是否存在的逻辑，以及使用Allowed标志创建AdmissionResponse对象。
- en: Now that we understand all the different components required for a validating
    webhook, let's build one in the following activity.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了验证webhook所需的所有不同组件，让我们在下一个活动中构建一个。
- en: 'Activity 16.02: Creating a Validating Webhook That Checks for a Label in a
    Pod'
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动16.02：创建一个验证webhook，检查Pod中是否存在标签
- en: In this activity, we will use the knowledge that we have acquired in this and
    earlier chapters to write a validating webhook that verifies whether a label is
    present in the requested Pod.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将利用我们在本章和之前章节中所学到的知识，编写一个验证webhook，验证请求的Pod中是否存在标签。
- en: 'The required steps are as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的步骤如下：
- en: Create a new namespace named `webhooks`. If it exists already, delete the existing
    namespace and then create it again.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`webhooks`的新命名空间。如果已经存在，请删除现有的命名空间，然后再次创建它。
- en: Generate the self-signed CA certificate.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成自签名的CA证书。
- en: Generate a private/public key pair for SSL and sign it with the CA certificate.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成SSL的私钥/公钥对，并使用CA证书进行签名。
- en: Create a secret that holds the private/public key pair generated in the previous step.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个保存在上一步生成的私钥/公钥对的秘密。
- en: Note
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Even if you have the certificates and secrets from the previous activity, we
    recommend that you discard them and start afresh to avoid any conflicts.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您拥有上一个活动的证书和密钥，我们建议您丢弃它们，重新开始，以避免任何冲突。
- en: Write the webhook code to check whether a label with the key `teamName` is present.
    If it is not present, reject the request.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写webhook代码以检查是否存在具有键`teamName`的标签。如果不存在，则拒绝请求。
- en: Package the webhook code as a Docker container.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将webhook代码打包为Docker容器。
- en: Push the Docker container to a public repository of your choice (quay.io allows
    you to create a free public repository).
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Docker容器推送到您选择的公共存储库（quay.io允许您创建一个免费的公共存储库）。
- en: Note
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you have any difficulty in building your own webhook, you can use the code
    available at this link as a reference: [https://packt.live/2FbL7Jv](https://packt.live/2FbL7Jv).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在构建自己的webhook时遇到任何困难，您可以使用此链接提供的代码作为参考：[https://packt.live/2FbL7Jv](https://packt.live/2FbL7Jv)。
- en: 'If you want to avoid building and packaging a webhook, we have provided a pre-built
    container so that you can use it directly in your Deployment. You can use this
    image from Docker Hub: `packtworkshops/the-kubernetes-workshop:webhook`.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想避免构建和打包webhook，我们提供了一个预构建的容器，以便您可以直接在部署中使用它。您可以从Docker Hub使用此镜像：`packtworkshops/the-kubernetes-workshop:webhook`。
- en: Using this image allows you to skip *steps 5* to *7*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此镜像可以跳过*步骤5*至*7*。
- en: Create a Deployment that deploys the webhook server.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建部署以部署webhook服务器。
- en: Expose the webhooks Deployment as a Kubernetes service.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将webhooks Deployment公开为Kubernetes服务。
- en: Create a Base64-encoded version of the CA certificate.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建CA证书的Base64编码版本。
- en: Create `ValidtingWebhookConfiguration` so that Kubernetes can intercept the
    API call and call our webhook.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ValidtingWebhookConfiguration`，以便Kubernetes可以拦截API调用并调用我们的webhook。
- en: Create a simple Pod with no labels and verify that it is being rejected.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个没有标签的简单Pod，并验证它是否被拒绝。
- en: Create a simple Pod with the desired labels and verify that it is being created.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有所需标签的简单Pod，并验证它是否已创建。
- en: Once the Pod is created, make sure that the label is part of the Pod specifications.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了Pod，请确保标签是Pod规范的一部分。
- en: 'You can test your validating webhook by trying to create a Pod without the
    `teamName` label. It should get rejected with the following message:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过尝试创建一个没有`teamName`标签的Pod来测试您的验证webhook。它应该被拒绝，并显示以下消息：
- en: '![Figure 16.9: Expected output of the Activity 16.02'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.9：活动16.02的预期输出'
- en: '](image/B14870_16_09.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_09.jpg)'
- en: 'Figure 16.9: Expected output of the Activity 16.02'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9：活动16.02的预期输出
- en: Note
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在以下地址找到：[https://packt.live/304PEoD](https://packt.live/304PEoD)。
- en: Controlling the Effect of a Webhook on Selected Namespaces
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制Webhook对选定命名空间的影响
- en: When you define any webhook (mutating or validating), you can control which
    namespaces will be affected by the webhook by defining the `namespaceSelector`
    parameter. Note that this is only applicable to objects that are namespace-scoped.
    For cluster-scoped objects, such as persistent volumes, this parameter will make
    no difference, and the webhook will be applied.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义任何webhook（变异或验证）时，您可以通过定义`namespaceSelector`参数来控制webhook将影响哪些命名空间。请注意，这仅适用于命名空间范围的对象。对于集群范围的对象，例如持久卷，此参数不会产生任何影响，并且将应用webhook。
- en: Note
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Not all admission controllers (mutating or validating) can be restricted to
    a namespace.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有准入控制器（变异或验证）都可以限制到一个命名空间。
- en: Just like many Kubernetes objects, namespaces can also have labels. We will
    use this property of namespaces to apply a webhook on specific namespaces, as
    you will see in the following exercise.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多Kubernetes对象一样，命名空间也可以有标签。我们将利用命名空间的这个属性，将webhook应用于特定的命名空间，正如您将在以下练习中看到的那样。
- en: 'Exercise 16.03: Creating a Validating Webhook with the Namespace Selector Defined'
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16.03：使用命名空间选择器定义一个验证Webhook
- en: In this exercise, we will define a validating webhook that enforces a custom
    rule to be applied to Pods created in a `webhooks` namespace. The rule is that
    the Pod must define a label called `teamName`. Since the rule is applicable to
    Pods created in the `webhooks-demo` namespace, all other namespaces can create
    Pods without the label defined.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个验证webhook，强制执行一个自定义规则，应用于在`webhooks`命名空间中创建的Pod。规则是Pod必须定义一个名为`teamName`的标签。由于该规则适用于在`webhooks-demo`命名空间中创建的Pod，因此所有其他命名空间都可以创建没有定义标签的Pod。
- en: Note
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before running this exercise, make sure that you have completed *Activity 16.02*,
    *Creating a Validating Webhook that Checks for a Label in a Pod* as we are reusing
    the objects created there. You can refer to the solution in the *Appendix* if
    you are facing any issues with the activity.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此练习之前，请确保您已完成*活动16.02*，*创建一个检查Pod标签的验证Webhook*，因为我们正在重用那里创建的对象。如果您在活动中遇到任何问题，可以在*附录*中查看解决方案。
- en: 'Verify that the validating webhook we created in *Activity 16.02*, *Creating
    a Validating Webhook that Checks for a Label in a Pod*, still exists:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证我们在*活动16.02*中创建的验证webhook是否仍然存在：
- en: '[PRE32]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You will see the following response:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下响应：
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, delete the preexisting validating webhook defined in *Activity 16.02*,
    *Creating a Validating Webhook that Checks for a Label in a Pod*:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，删除在*活动16.02*中定义的现有验证webhook，*创建一个检查Pod标签的验证webhook*：
- en: '[PRE34]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `ValidatingWebHookConfiguration` is a cluster scoped object, and specifying
    the `-n` flag is optional for this command.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidatingWebHookConfiguration`是一个集群范围的对象，对于这个命令，指定`-n`标志是可选的。'
- en: 'You will get the following response:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您将会得到以下的响应：
- en: '![Figure 16.10: Deleting the existing validating webhook'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.10：删除现有的验证webhook'
- en: '](image/B14870_16_10.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_10.jpg)'
- en: 'Figure 16.10: Deleting the existing validating webhook'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10：删除现有的验证webhook
- en: 'Delete the `webhooks` namespace:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`webhooks`命名空间：
- en: '[PRE35]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You will get the following response:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您将会得到以下的响应：
- en: '[PRE36]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create the `webhooks` namespace:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`webhooks`命名空间：
- en: '[PRE37]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You will get the following response:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您将会得到以下的响应：
- en: '[PRE38]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now we should have a clean slate to continue with this exercise.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该有一个干净的板块来继续进行这个练习。
- en: 'Create a new CA bundle and a private/public key pair to be used in this webhook.
    Generate a self-signed certificate using this command:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的CA捆绑和一个私钥/公钥对，用于这个webhook。使用以下命令生成一个自签名证书：
- en: '[PRE39]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You will get an output similar to the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您将会得到类似以下的输出：
- en: '![Figure 16.11: Generating a self-signed certificate'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.11：生成一个自签名证书'
- en: '](image/B14870_16_11.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_11.jpg)'
- en: 'Figure 16.11: Generating a self-signed certificate'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11：生成一个自签名证书
- en: Note
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Even if you have created the CA and keys in the previous activity, you will
    need to recreate them for this exercise to work properly.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您在之前的活动中已经创建了CA和密钥，您仍需要重新创建它们以使本练习正常工作。
- en: 'Generate a private/public key pair and sign it with the CA certificate using
    the following two commands, one after the other:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个私钥/公钥对，并使用以下两个命令依次对其进行CA证书签名：
- en: '[PRE40]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You will get an output that is similar to the following response:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您将会得到类似以下响应的输出：
- en: '![Figure 16.12: Signing a private/public key pair with our certificate'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.12：用我们的证书签署私钥/公钥对'
- en: '](image/B14870_16_12.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_12.jpg)'
- en: 'Figure 16.12: Signing a private/public key pair with our certificate'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.12：用我们的证书签署私钥/公钥对
- en: 'Create a secret that holds the private/public key pair:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个保存私钥/公钥对的secret：
- en: '[PRE41]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You should get the following response:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到以下的响应：
- en: '[PRE42]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we need to deploy the webhook in the `webhooks` namespace. Create a file
    named `validating-server.yaml` with the following content:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`webhooks`命名空间部署webhook。创建一个名为`validating-server.yaml`的文件，内容如下：
- en: '[PRE43]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can use the same webhook image created in *Activity 16.02*, *Creating a
    Validating Webhook That Checks for a Label in a Pod*. In this reference YAML,
    we are using the image that we have provided in our repository.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用在*活动16.02*中创建的相同的webhook镜像，*创建一个检查Pod标签的验证webhook*。在这个参考YAML中，我们使用了我们在仓库中提供的镜像。
- en: 'Deploy the webhook server by using the definition from the previous step:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用上一步的定义部署webhook服务器：
- en: '[PRE44]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You should see the following response:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下的响应：
- en: '[PRE45]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You might need to wait a bit and check whether the webhook Pods have been created.
    Keep checking the status of the Pods:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能需要等一会儿，检查webhook Pods是否已经创建。不断检查Pods的状态：
- en: '[PRE46]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You should see the following response:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下的响应：
- en: '![Figure 16.13: Checking whether our webhook is online'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.13：检查我们的webhook是否在线'
- en: '](image/B14870_16_13.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_13.jpg)'
- en: 'Figure 16.13: Checking whether our webhook is online'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.13：检查我们的webhook是否在线
- en: Note that the `-w` flag continuously watches the Pods. You can end the watch
    when all of the Pods are ready.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`-w`标志会持续监视Pods。当所有的Pods都准备就绪时，您可以结束监视。
- en: 'Now, we have to expose the deployed webhook server via the Kubernetes service.
    Create a file named `validating-serversvc.yaml` with the following content:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要通过Kubernetes服务公开部署的webhook服务器。创建一个名为`validating-serversvc.yaml`的文件，内容如下：
- en: '[PRE47]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that the webhook service has to be running on port `443`, as this is the
    standard for TLS communication.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，webhook服务必须在端口`443`上运行，因为这是TLS通信的标准端口。
- en: 'Use the definition from the previous step to create the service using the following
    command:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上一步的定义来使用以下命令创建服务：
- en: '[PRE48]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You will see the following output:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE49]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a Base64-encoded version of the CA certificate. Use the following commands,
    one after the other:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建CA证书的Base64编码版本。依次使用以下命令：
- en: '[PRE50]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The first command is to convert the certificate into a PEM format. And the
    second one is to convert the PEM certificate into Base64\. These commands show
    no response. You can inspect the file using the following command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令是将证书转换为PEM格式。第二个命令是将PEM证书转换为Base64。这些命令不会有任何响应。您可以使用以下命令检查文件：
- en: '[PRE51]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The file contents should be something like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 文件内容应该是这样的：
- en: '![Figure 16.14: Contents of the Base64-encoded CA certificate'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.14：Base64编码的CA证书内容'
- en: '](image/B14870_16_14.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_14.jpg)'
- en: 'Figure 16.14: Contents of the Base64-encoded CA certificate'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.14：Base64编码的CA证书内容
- en: Please note that the TLS certificates you generate will not look exactly like
    what is shown here.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您生成的TLS证书不会完全与此处显示的内容相同。
- en: 'Use the following two commands to clean up the blank lines from our CA certificate
    and add the contents to a new file:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下两个命令清除我们的CA证书中的空行，并将内容添加到一个新文件中：
- en: '[PRE52]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The first command shows no response, and the second one prints out the contents
    of `onlinecert.pem`. You should see the following response:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令不会有任何响应，第二个命令会打印出`onlinecert.pem`的内容。您应该会看到以下响应：
- en: '![Figure 16.15: Base64-encoded CA certificate with the line breaks removed'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.15：去除换行符的Base64编码CA证书'
- en: '](image/B14870_16_15.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_15.jpg)'
- en: 'Figure 16.15: Base64-encoded CA certificate with the line breaks removed'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.15：去除换行符的Base64编码CA证书
- en: Now we have the Base64-encoded certificate with no blank lines. For the next
    step, we will copy the value that you get in this output, being careful not to
    copy the `$` (which would be `%`, in the case of Zsh) at the end of the value.
    Paste this value in place of `CA_BASE64_PEM` (a placeholder for `caBundle`) in
    `validation-config-namespace-scoped.yaml`, which will be created in the next step.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了去除空行的Base64编码证书。在下一步中，我们将复制此输出中的值，注意不要复制结尾的`$`（在Zsh的情况下将是`%`）。将此值粘贴到`validation-config-namespace-scoped.yaml`中的`CA_BASE64_PEM`（`caBundle`的占位符）的位置，该文件将在下一步中创建。
- en: 'Create a file, named `validation-config-namespace-scoped.yaml`, using the following
    `ValidatingWebHookConfiguration` specification to configure the Kubernetes API
    server to call our webhook:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`validation-config-namespace-scoped.yaml`的文件，使用以下`ValidatingWebHookConfiguration`规范来配置Kubernetes
    API服务器调用我们的webhook：
- en: '[PRE53]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `CA_BASE64_PEM` placeholder will be replaced with the contents of `onelinecert.pem`
    from the previous step. Be careful not to copy any line breaks.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`CA_BASE64_PEM`占位符将被替换为上一步中`onelinecert.pem`的内容。请注意不要复制任何换行符。'
- en: 'Create the webhook, as defined in the previous step. Make sure that you replace
    the `caBundle` field with the certificates created in the earlier steps:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据上一步中定义的webhook创建webhook。确保用之前步骤中创建的证书替换`caBundle`字段：
- en: '[PRE54]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You should see the following response:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下响应：
- en: '![Figure 16.16: Creating the ValidatingWebhookConfiguration'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.16：创建ValidatingWebhookConfiguration'
- en: '](image/B14870_16_16.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_16.jpg)'
- en: 'Figure 16.16: Creating the ValidatingWebhookConfiguration'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.16：创建ValidatingWebhookConfiguration
- en: 'Create a new namespace, called `webhooks-demo`, as follows:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式创建一个名为`webhooks-demo`的新命名空间：
- en: '[PRE55]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You should see the following response:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE56]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Apply the `applyValidation=true` label to the `webhooks` namespace, as shown
    here:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`applyValidation=true`标签应用到`webhooks`命名空间，如下所示：
- en: '[PRE57]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You should see the following response:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE58]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This label will match the selector defined in *step 14* and make sure our validation
    criteria (enforced by the webhook) applies to this namespace. Note that we don't
    label the `webhooks-demo` namespace, so the validation will *not* apply to this namespace.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 此标签将与*步骤14*中定义的选择器匹配，并确保我们的验证标准（由webhook强制执行）适用于此命名空间。请注意，我们没有给`webhooks-demo`命名空间贴上标签，因此验证将*不*适用于此命名空间。
- en: 'Now define a Pod without the `teamName` label. Create a file named `target-validating-pod.yaml`
    with the following content:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在定义一个没有`teamName`标签的Pod。创建一个名为`target-validating-pod.yaml`的文件，内容如下：
- en: '[PRE59]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Based on the definition from the previous step, create the Pod in the `webhooks`
    namespace:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据上一步的定义，在`webhooks`命名空间中创建Pod：
- en: '[PRE60]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The creation of the Pod should get rejected as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Pod的创建应该被拒绝，如下所示：
- en: '![Figure 16.17: Pod rejected due to the absence of the required label'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.17：由于缺少必需标签而被拒绝的Pod'
- en: '](image/B14870_16_17.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_17.jpg)'
- en: 'Figure 16.17: Pod rejected due to the absence of the required label'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.17：由于缺少必需标签而被拒绝的Pod
- en: Keep in mind that our webhook just checks the `teamName` label in the Pod. The
    Pod creation is rejected as per our namespace selector in the definition from
    *step 14*.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的webhook只检查Pod中的`teamName`标签。根据*步骤14*中定义的命名空间选择器，Pod创建将被拒绝。
- en: 'Now, try creating the same Pod in the `webhooks-demo` namespace to see whether
    things go differently:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试在`webhooks-demo`命名空间中创建相同的Pod，看看情况是否不同：
- en: '[PRE61]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You should get this response:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到这样的响应：
- en: '[PRE62]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We were able to successfully create the Pod in the `webhooks-demo` namespace,
    but we were not able to do so in the `webhooks` namespace.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功在`webhooks-demo`命名空间中创建了Pod，但在`webhooks`命名空间中无法创建。
- en: 'Let''s describe the Pod to get more details:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们描述一下Pod以获取更多细节：
- en: '[PRE63]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You should see a response similar to this:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于这样的响应：
- en: '![Figure 16.18: Checking the specification of our Pod'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.18：检查我们的Pod的规范'
- en: '](image/B14870_16_18.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_16_18.jpg)'
- en: 'Figure 16.18: Checking the specification of our Pod'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.18：检查我们的Pod的规范
- en: As you can see, this Pod does not have any labels, and yet we were able to create
    it. This is because our validating webhook is not watching the `webhooks-demo` namespace.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个Pod没有任何标签，但我们仍然能够创建它。这是因为我们的验证webhook没有监视`webhooks-demo`命名空间。
- en: In this exercise, you have learned how a webhook can be configured to make changes
    at the namespace level. This could be useful to test functionality and provide
    different functionality to different teams that might own different namespaces.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您已经学会了如何配置webhook以在命名空间级别进行更改。这对于测试功能并为可能拥有不同命名空间的不同团队提供不同功能可能很有用。
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned that admission controllers provide a way to enforce
    the mutation and validation of objects during create, update, and delete operations.
    It is an easy way to extend the Kubernetes platform to adhere to the standards
    of your organization. They can be used to apply the best practices and policies
    onto the Kubernetes cluster.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到准入控制器提供了一种在创建、更新和删除操作期间强制执行对象的变异和验证的方式。这是扩展Kubernetes平台以符合您组织标准的简单方法。它们可以用于将最佳实践和策略应用到Kubernetes集群上。
- en: Next, we learned what mutating and validating webhooks are, how to configure
    them, and how to deploy them on the Kubernetes platform. Webhooks provide a simple
    way to extend Kubernetes and help you to adapt to the requirements of a particular enterprise.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了什么是变异和验证webhook，如何配置它们，以及如何在Kubernetes平台上部署它们。Webhook提供了一种简单的方式来扩展Kubernetes，并帮助您适应特定企业的需求。
- en: In the previous series of chapters, starting from *Chapter 11*, *Build Your
    Own HA Cluster*, to *Chapter 15*, *Monitoring and Autoscaling in Kubernetes*,
    you learned how to set up your highly-available cluster on AWS and run stateless,
    as well as stateful, applications. In the next few chapters, you will learn many
    advanced skills that will help you go beyond just running applications, and enable
    you to leverage many of the powerful administration features offered by Kubernetes
    and maintain the health of your cluster.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的一系列章节中，从*第11章*，*构建您自己的HA集群*，到*第15章*，*Kubernetes中的监控和自动扩展*，您学会了如何在AWS上设置高可用性集群，并运行无状态和有状态的应用程序。在接下来的几章中，您将学习许多高级技能，这些技能将帮助您不仅仅是运行应用程序，还能够利用Kubernetes提供的许多强大的管理功能，并保持集群的健康。
- en: Specifically, in the next chapter, you will learn about the Kubernetes scheduler.
    This is a component that decides the nodes on which a Pod will be scheduled. You
    will also learn how to configure the scheduler to adhere to your needs and how
    you can control Pod placement on a node.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在下一章中，您将了解Kubernetes调度器。这是一个决定Pod将被调度到哪些节点的组件。您还将学习如何配置调度器以符合您的需求，以及如何控制Pod在节点上的放置。
