- en: 7\. Kubernetes Controllers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. Kubernetes控制器
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces the concept of Kubernetes controllers and explains how
    to use them to create replicated Deployments. We will describe the use of different
    types of controllers, such as ReplicaSets, Deployments, DaemonSets, StatefulSets,
    and Jobs. You will learn how to choose a suitable controller for specific use
    cases. Using hands-on exercises, we will guide you through how to use these controllers
    with the desired configuration to deploy several replicas of Pods for your application.
    You will also learn how to manage them using various commands.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Kubernetes控制器的概念，并解释了如何使用它们来创建复制的部署。我们将描述不同类型的控制器的使用，如ReplicaSets、部署、DaemonSets、StatefulSets和Jobs。您将学习如何为特定用例选择合适的控制器。通过实际操作练习，我们将指导您如何使用所需的配置来部署应用程序的多个Pod副本。您还将学习如何使用各种命令来管理它们。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In previous chapters, we created different Pods, managed their life cycle manually,
    and added metadata (labels or annotations) to them to help organize and identify
    various Pods. In this chapter, we will take a look at a few Kubernetes objects
    that help you manage several replica Pods declaratively.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们创建了不同的Pod，手动管理它们的生命周期，并为它们添加了元数据（标签或注释）来帮助组织和识别各种Pod。在本章中，我们将看看一些Kubernetes对象，帮助您以声明方式管理多个副本Pod。
- en: When deploying your application in production, there are several reasons why
    you would want to have more than one replica of your Pods. Having more than one
    replica ensures that your application continues to work in cases where one or
    more Pods fail. In addition to handling failures, replication also allows you
    to balance the load across the different replicas so that one Pod is not overloaded
    with a lot of requests, thereby allowing you to easily serve higher traffic than
    what a single Pod can serve.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中部署应用程序时，有几个原因会让您希望拥有多个Pod的副本。拥有多个副本可以确保在一个或多个Pod失败的情况下，您的应用程序仍然可以正常工作。除了处理故障之外，复制还允许您在不同的副本之间平衡负载，以便一个Pod不会因为大量请求而过载，从而使您能够轻松地处理比单个Pod能够处理的更高流量。
- en: Kubernetes supports different controllers that you can use for replication,
    such as ReplicaSets, Deployments, DaemonSets, StatefulSets, and Jobs. A controller
    is an object that ensures that your application runs in the desired state for
    its entire runtime. Each of these controllers is useful for specific use cases.
    In this chapter, we will explore some of the most commonly used controllers one
    by one and understand how and when to use them in real-life scenarios.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes支持不同的控制器，您可以用于复制，如ReplicaSets、部署、DaemonSets、StatefulSets和Jobs。控制器是一个对象，确保您的应用程序在其整个运行时处于所需状态。每个控制器都对特定的用例有用。在本章中，我们将逐个探索一些最常用的控制器，并了解如何以及何时在实际场景中使用它们。
- en: ReplicaSets
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReplicaSets
- en: As discussed earlier, having multiple replicas of our application ensures that
    it is still available even if a few replicas fail. This also makes it easy for
    us to scale our application to balance the load to serve more traffic. For example,
    if we are building a web application that's exposed to users, we'd want to have
    at least two replicas of the application in case one of them fails or dies unexpectedly.
    We would also want the failed replica to recover on its own. In addition to that,
    if our traffic starts growing, we would want to increase the number of Pods (replicas)
    running our application. A ReplicaSet is a Kubernetes controller that keeps a
    certain number of Pods running at any given time.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，拥有应用程序的多个副本可以确保即使一些副本失败，应用程序仍然可用。这也使我们能够轻松地扩展我们的应用程序以平衡负载以提供更多的流量。例如，如果我们正在构建一个向用户公开的Web应用程序，我们希望至少有两个应用程序副本，以防其中一个失败或意外死机。我们还希望失败的副本能够自行恢复。除此之外，如果我们的流量开始增长，我们希望增加运行我们的应用程序的Pod（副本）的数量。ReplicaSet是一个Kubernetes控制器，它在任何给定时间保持一定数量的Pod运行。
- en: ReplicaSet acts as a supervisor for multiple Pods across the different nodes
    in a Kubernetes cluster. A ReplicaSet will terminate or start new Pods to match
    the configuration specified in the ReplicaSet template. For this reason, it is
    a good idea to use them even if your application only needs one Pod. Even if someone
    deletes the only running Pod, the ReplicaSet will ensure that a new Pod is created
    to replace it, thereby ensuring that one Pod is always running.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet充当Kubernetes集群中不同节点上多个Pod的监督者。ReplicaSet将终止或启动新的Pod以匹配ReplicaSet模板中指定的配置。因此，即使您的应用程序只需要一个Pod，使用ReplicaSet也是一个好主意。即使有人删除了唯一运行的Pod，ReplicaSet也会确保创建一个新的Pod来替代它，从而确保始终有一个Pod在运行。
- en: A ReplicaSet can be used to reliably run a single Pod indefinitely or to run
    multiple instances of the same Pod.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet可以用来可靠地运行单个Pod，也可以用来运行多个相同Pod的实例。
- en: ReplicaSet Configuration
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReplicaSet配置
- en: 'Let''s first look at an example of the configuration of a ReplicaSet, and then
    we will cover what the different fields mean:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一个ReplicaSet配置的示例，然后我们将介绍不同字段的含义：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As with Pod configuration, a ReplicaSet also needs fields such as `apiVersion`,
    `kind`, and `metadata`. For a ReplicaSet, the API version, `apps/v1`, is the current
    version and the `kind` field will always be `ReplicaSet`. One field that is different
    from what we have seen in Pod configuration so far is the `spec`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与Pod配置一样，ReplicaSet还需要字段，如`apiVersion`，`kind`和`metadata`。对于ReplicaSet，API版本`apps/v1`是当前版本，`kind`字段将始终为`ReplicaSet`。到目前为止，在Pod配置中看到的一个不同的字段是`spec`。
- en: Now, we will see what information we need to specify in the `spec` field.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到在`spec`字段中需要指定哪些信息。
- en: Replicas
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 副本
- en: 'The `replicas` field under `spec` specifies how many Pods the ReplicaSet should
    keep running concurrently. You can see the following value in the preceding example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在`spec`下的`replicas`字段指定ReplicaSet应保持同时运行多少个Pod。您可以在前面的示例中看到以下值：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The ReplicaSet will create or delete Pods in order to match this number. The
    default value for this field, if not specified, is `1`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet将创建或删除Pod以匹配这个数字。如果未指定，默认值为`1`。
- en: Pod Template
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pod模板
- en: 'In the `template` field, we will specify the template of the Pod that we want
    to run using this ReplicaSet. This Pod template will be exactly the same as the
    Pod templates we used in the previous two chapters. As usual, we can add metadata
    in the form of labels and annotations to the Pods. The ReplicaSet will use this
    Pod template to create new Pods whenever there is a need for them. The following
    section from the previous example comprises the template:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`template`字段中，我们将指定我们想要使用这个ReplicaSet运行的Pod的模板。这个Pod模板将与我们在前两章中使用的Pod模板完全相同。通常情况下，我们可以向Pod添加标签和注释的元数据。当有需要时，ReplicaSet将使用这个Pod模板来创建新的Pod。前面示例中的以下部分包括模板：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Pod Selector
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pod选择器
- en: 'This is a really important section. In the `selector` field under `spec`, we
    can specify the label selectors that will be used by the ReplicaSet to identify
    which Pods to manage:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的部分。在`spec`下的`selector`字段中，我们可以指定标签选择器，ReplicaSet将使用这些选择器来识别要管理的Pod：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding example ensures that our controller will only manage Pods with
    an `environment: production` label.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '前面的示例确保我们的控制器只管理具有`environment: production`标签的Pod。'
- en: Let's now proceed to create our first ReplicaSet.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续创建我们的第一个ReplicaSet。
- en: 'Exercise 7.01: Creating a Simple ReplicaSet with nginx Containers'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.01：使用nginx容器创建一个简单的ReplicaSet
- en: 'In this exercise, we will create a simple ReplicaSet and examine the Pods created
    by it. To successfully complete this exercise, perform the following steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个简单的ReplicaSet，并检查由它创建的Pod。要成功完成这个练习，请执行以下步骤：
- en: 'Create a file called `replicaset-nginx.yaml` with the following content:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`replicaset-nginx.yaml`的文件，内容如下：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see in the highlighted part of the configuration, we have three
    fields: `replicas`, `selector`, and `template`. We have set the number of replicas
    to `2`. The Pod selector has been set in such a way that this ReplicaSet will
    manage the Pods with the `environment: production` label. The Pod template has
    the simple Pod configuration that we used in previous chapters. We have ensured
    that the Pod label selector matches the Pod''s labels in the template exactly.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '如您在配置的突出显示部分所见，我们有三个字段：`replicas`、`selector`和`template`。我们将副本的数量设置为`2`。Pod选择器已经设置，这样ReplicaSet将管理具有`environment:
    production`标签的Pod。Pod模板具有我们在前几章中使用的简单Pod配置。我们已确保Pod标签选择器与模板中的Pod标签完全匹配。'
- en: 'Run the following command to create the ReplicaSet using the preceding configuration:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，使用前面的配置创建ReplicaSet：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see the following response:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Verify that the ReplicaSet was created by using the `kubectl get` command:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl get`命令验证ReplicaSet是否已创建：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that `rs` is a short form of `replicaset` in all kubectl commands.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在所有kubectl命令中，`rs`是`replicaset`的缩写形式。
- en: 'You should see the following response:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, we have a ReplicaSet with two desired replicas, as we defined
    in `replicaset-nginx.yaml` in *step 1*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个具有两个期望副本的ReplicaSet，就像我们在*步骤1*中在`replicaset-nginx.yaml`中定义的那样。
- en: 'Verify that the Pods were actually created by using the following command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令验证Pod是否实际创建：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should get the following response:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下响应：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see that the names of the Pods created by the ReplicaSet take the name
    of the ReplicaSet as a prefix.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，由ReplicaSet创建的Pod的名称以ReplicaSet的名称作为前缀。
- en: 'Now that we have created our first ReplicaSet, let''s look at it in more detail
    to understand what actually happened during its creation. To do that, we can describe
    the ReplicaSet we just created by using the following command in the terminal:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的第一个ReplicaSet，让我们更详细地查看它，以了解在创建过程中实际发生了什么。为了做到这一点，我们可以在终端中使用以下命令描述我们刚刚创建的ReplicaSet：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see output similar to the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '![Figure 7.1: Describing nginx-replicaset'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1：描述nginx-replicaset'
- en: '](image/B14870_07_01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_07_01.jpg)'
- en: 'Figure 7.1: Describing nginx-replicaset'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：描述nginx-replicaset
- en: 'Next, we will inspect the Pods created by this ReplicaSet and verify that they
    have been created with the correct configuration. Run the following command to
    get a list of the Pods that are running:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将检查由此副本集创建的Pod，并验证它们是否已按正确的配置创建。运行以下命令以获取正在运行的Pod的列表：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should see a response as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the following command to describe one of the Pods by copying its name:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来描述其中一个Pod，复制其名称：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should see output similar to the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '![Figure 7.2: Listing Pods'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2：列出Pods'
- en: '](image/B14870_07_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_07_02.jpg)'
- en: 'Figure 7.2: Listing Pods'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：列出Pods
- en: In the highlighted sections of the preceding output, we can clearly see that
    the pod has the `environment=production` label and is controlled by `ReplicaSet/nginx-replicaset`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出的突出部分中，我们可以清楚地看到该Pod具有`environment=production`标签，并由`ReplicaSet/nginx-replicaset`控制。
- en: So, we have created a simple ReplicaSet in this exercise. In the following subtopics,
    we will go through the highlighted sections of the preceding output to understand
    the ReplicaSet that's running.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本练习中我们创建了一个简单的副本集。在接下来的子主题中，我们将逐步了解正在运行的副本集的突出部分。
- en: Labels on the ReplicaSet
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 副本集上的标签
- en: 'Consider the following line from the output shown in *Figure 7.1*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑来自*图7.1*中显示的输出的以下行：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It shows that, as desired, the ReplicaSet was created with a label key called
    `app` with a value of `nginx`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示了所期望的，副本集是通过一个名为`app`的标签键和值为`nginx`来创建的。
- en: Selectors for the ReplicaSet
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 副本集的选择器
- en: 'Now, consider the following line from the output shown in *Figure 7.1*:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑来自*图7.1*中显示的输出的以下行：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This shows that the ReplicaSet is configured with an `environment=production`
    Pod selector. This means that this ReplicaSet will try to acquire Pods that have
    this label.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明副本集配置了一个`environment=production`的Pod选择器。这意味着这个副本集将尝试获取具有这个标签的Pod。
- en: Replicas
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 副本
- en: 'Consider the following line from the output shown in *Figure 7.1*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑来自*图7.1*中显示的输出的以下行：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can see that the ReplicaSet has the desired count of `2` for the Pods, and
    it also shows that there are currently two replicas present.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到副本集对于Pod的期望数量为`2`，并且还显示当前有两个副本存在。
- en: Pods Status
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pod的状态
- en: 'While the `Replicas` field only shows the number of Pods currently present,
    `Pods Status` shows the actual status of those Pods:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`副本`字段只显示当前存在的Pod数量，`Pod的状态`显示了这些Pod的实际状态：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can see that there are currently two Pods running under this ReplicaSet.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到当前有两个Pod在此副本集下运行。
- en: Pods Template
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pod模板
- en: Now, let's consider the `Pod Template` section of the output shown in *Figure
    7.1*. We can see that the Pod template is the same as was described in the configuration.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑*图7.1*中显示的输出的`Pod模板`部分。我们可以看到Pod模板与配置中描述的相同。
- en: Events
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: In the last section of the output shown in *Figure 7.1*, we can see that there
    are two events, which denotes that two pods were created to get to the desired
    count of two Pods for the ReplicaSet.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图7.1*中显示的输出的最后一部分中，我们可以看到有两个事件，这表示创建了两个Pod以达到副本集中两个Pod的期望数量。
- en: In the last exercise, we created a ReplicaSet to maintain a number of running
    replicas. Now, let's consider a scenario where some nodes or Pods fail for some
    reason. We will see how the ReplicaSet will behave in this situation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们创建了一个副本集来维护一定数量的运行副本。现在，让我们考虑一种情况，即某些节点或Pod由于某种原因失败。我们将看到副本集在这种情况下的行为。
- en: 'Exercise 7.02: Deleting Pods Managed by a ReplicaSet'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.02：删除ReplicaSet管理的Pod
- en: 'In this exercise, we will delete one of the Pods managed by a ReplicaSet to
    see how it responds. This way, we will be simulating a single or multiple Pods
    failing during the runtime of a ReplicaSet:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将删除ReplicaSet管理的一个Pod，以查看它的响应。这样，我们将模拟在ReplicaSet运行时单个或多个Pod失败的情况：
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this exercise, we will assume that you have successfully completed the previous
    exercise as we will be reusing the ReplicaSet created in that exercise.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将假设您已经成功完成了上一个练习，因为我们将重用在那个练习中创建的ReplicaSet。
- en: 'Verify that the Pods created by the ReplicaSet are still running:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证ReplicaSet创建的Pod是否仍在运行：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should see something similar to the following response:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于以下响应：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Delete the first Pod to replicate Pod failure during runtime by using the following command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令删除第一个Pod，以模拟运行时的Pod故障：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should see a response similar to the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于以下的响应：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Describe the ReplicaSet and check the events:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述ReplicaSet并检查事件：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should see output similar to the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于以下的输出：
- en: '![Figure 7.3: Describing the ReplicaSet'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3：描述ReplicaSet'
- en: '](image/B14870_07_03.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_07_03.jpg)'
- en: 'Figure 7.3: Describing the ReplicaSet'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：描述ReplicaSet
- en: As highlighted in the preceding output, we can see that after a Pod is deleted,
    the ReplicaSet creates a new Pod using the Pod configuration in the `Template`
    section of the ReplicaSet configuration. Even if we delete all the Pods managed
    by the ReplicaSet, they will be recreated. So, to delete all the Pods permanently
    and to avoid the recreation of the Pods, we need to delete the ReplicaSet itself.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到在删除一个Pod之后，ReplicaSet会使用ReplicaSet配置中“模板”部分的Pod配置创建一个新的Pod。即使我们删除了ReplicaSet管理的所有Pod，它们也会被重新创建。因此，要永久删除所有Pod并避免Pod的重新创建，我们需要删除ReplicaSet本身。
- en: 'Run the following command to delete the ReplicaSet:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令删除ReplicaSet：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You should see the following response:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As shown in the preceding output, the `nginx-replicaset` ReplicaSet was deleted.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出所示，“nginx-replicaset” ReplicaSet已被删除。
- en: 'Run the following command to verify that the Pods managed by the ReplicaSet
    were also deleted:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令验证ReplicaSet管理的Pod也已被删除：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should get the following response:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下响应：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see from this output, we can verify that the Pods were deleted.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中可以看出，我们可以验证Pod已被删除。
- en: Consider a scenario where you have already deployed a single Pod for testing.
    Now, it is ready to go live. You apply the required label changes from development
    to production, and now you want to control this using a ReplicaSet. We will see
    how to do this in the following exercise.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经部署了一个用于测试的单个Pod。现在，它已经准备好上线。您将从开发到生产应用所需的标签更改，并且现在您希望使用ReplicaSet来控制这一切。我们将在下面的练习中看到如何做到这一点。
- en: 'Exercise 7.03: Creating a ReplicaSet Given That a Matching Pod Already Exists'
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.03：创建一个已存在匹配Pod的ReplicaSet
- en: In this exercise, we will create a Pod that matches the Pod template in the
    ReplicaSet and then create the ReplicaSet. Our aim is to prove that the newly
    created ReplicaSet will acquire the existing Pod and start managing it as if it
    created that Pod itself.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个与ReplicaSet中Pod模板匹配的Pod，然后创建ReplicaSet。我们的目标是证明新创建的ReplicaSet将获取现有的Pod，并开始管理它，就好像它自己创建了该Pod一样。
- en: 'In order to successfully complete this exercise, perform the following steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功完成这个练习，请执行以下步骤：
- en: 'Create a file called `pod-matching-replicaset.yaml` with the following content:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pod-matching-replicaset.yaml`的文件，内容如下：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the following command to create the Pod using the preceding configuration:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令使用上述配置来创建 Pod：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You should see the following response:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a file called `replicaset-nginx.yaml` with the following content:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `replicaset-nginx.yaml` 的文件，内容如下：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the following command to create the ReplicaSet using the preceding configuration:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令使用上述配置来创建 ReplicaSet：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should see a response similar to the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下的响应：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This output indicates that the Pod has been created.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出表明 Pod 已经被创建。
- en: 'Run the following command to check the status of the ReplicaSet:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来检查 ReplicaSet 的状态：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should get the following response:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下响应：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can see that there are currently two Pods managed by the ReplicaSet, as desired.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到目前有两个由 ReplicaSet 管理的 Pod，符合预期。
- en: 'Next, let''s check what Pods are running by using the following command:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用以下命令来检查正在运行的 Pod：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You should see output similar to the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下的输出：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this output, we can see that the manually created Pod named `pod-matching-replicaset`
    is still running and that there was only one new Pod created by the `nginx-replicaset`
    ReplicaSet.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，我们可以看到手动创建的名为 `pod-matching-replicaset` 的 Pod 仍在运行，并且 `nginx-replicaset`
    ReplicaSet 只创建了一个新的 Pod。
- en: 'Next, we will use the `kubectl describe` command to check whether the Pod named
    `pod-matching-replicaset` is being managed by the ReplicaSet:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `kubectl describe` 命令来检查名为 `pod-matching-replicaset` 的 Pod 是否被 ReplicaSet
    管理：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You should see output similar to the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下的输出：
- en: '![Figure 7.4: Describing the Pod'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4：描述 Pod'
- en: '](image/B14870_07_04.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_07_04.jpg)'
- en: 'Figure 7.4: Describing the Pod'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：描述 Pod
- en: In the highlighted section of the truncated output, we can see that even though
    this Pod was created manually before the ReplicaSet event existed, this Pod is
    now managed by the ReplicaSet itself.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在截断输出的突出部分中，我们可以看到即使这个 Pod 在 ReplicaSet 事件存在之前是手动创建的，现在这个 Pod 也是由 ReplicaSet
    自己管理的。
- en: 'Next, we will describe the ReplicaSet to see how many Pod creations were triggered
    by it:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将描述 ReplicaSet，以查看它触发了多少个 Pod 的创建：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You should see output similar to the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下的输出：
- en: '![Figure 7.5: Describing the ReplicaSet'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5：描述 ReplicaSet'
- en: '](image/B14870_07_05.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_07_05.jpg)'
- en: 'Figure 7.5: Describing the ReplicaSet'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：描述 ReplicaSet
- en: 'Run the following command to delete the ReplicaSet for cleanup:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来删除 ReplicaSet 进行清理：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You should see the following response:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So, we can see that a ReplicaSet is capable of acquiring existing Pods as long
    as they match the label selector criteria. In cases where there are more matching
    Pods than the desired count, the ReplicaSet will terminate some of the Pods in
    order to maintain the total count of running Pods.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到 ReplicaSet 能够获取现有的 Pod，只要它们符合标签选择器的条件。在存在更多匹配的 Pod 的情况下，ReplicaSet
    将终止一些 Pod 以维持正在运行的 Pod 的总数。
- en: Another common operation is horizontally scaling a ReplicaSet that you previously
    created. Let's say that you create a ReplicaSet with a certain number of replicas
    and later you need to have more or fewer replicas to manage increased or decreased
    demand. Let's see how you can scale the number of replicas in the next exercise.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的操作是在之前创建的 ReplicaSet 上进行水平扩展。假设你创建了一个具有一定数量副本的 ReplicaSet，后来你需要有更多或更少的副本来管理增加或减少的需求。让我们看看如何在下一个练习中扩展副本的数量。
- en: 'Exercise 7.04: Scaling a ReplicaSet after It Is Created'
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.04：在创建后扩展 ReplicaSet
- en: In this exercise, we will create a ReplicaSet with two replicas and then modify
    it to increase the number of replicas. Then, we will reduce the number of replicas.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个具有两个副本的ReplicaSet，然后修改它以增加副本的数量。然后，我们将减少副本的数量。
- en: 'In order to successfully complete this exercise, perform the following steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功完成这个练习，请执行以下步骤：
- en: 'Create a file called `replicaset-nginx.yaml` with the following content:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`replicaset-nginx.yaml`的文件，内容如下：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Run the following command to create the ReplicaSet using the `kubectl apply`
    command, as described in the preceding code:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来使用`kubectl apply`命令创建ReplicaSet，如前面的代码所述：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should get the following response:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会得到以下响应：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the following command to check all the existing Pods:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来检查所有现有的Pod：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You should get a response similar to the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会得到类似以下的响应：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We can see that there are two Pods created by the replica set.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到有两个由副本集创建的Pod。
- en: 'Run the following command to scale up the number of replicas for the ReplicaSet to
    `4`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来扩展ReplicaSet的副本数量到`4`：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You should see the following response:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下响应：
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Run the following command to check all the Pods that are running:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来检查所有正在运行的Pod：
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You should see output similar to the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似以下的输出：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We can see that now there are a total of four Pods. The ReplicaSet created two
    new Pods after we applied the new configuration.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到现在总共有四个Pod。在我们应用新配置后，ReplicaSet创建了两个新的Pod。
- en: 'Next, let''s run the following command to scale down the number of replicas
    to `1`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们运行以下命令来将副本的数量缩减到`1`：
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You should see the following response:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下响应：
- en: '[PRE52]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Run the following command to check all the Pods that are running:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来检查所有正在运行的Pod：
- en: '[PRE53]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You should see a response similar to the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似以下的响应：
- en: '[PRE54]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We can see that this time, the ReplicaSet deleted all the Pods exceeding the
    count from the desired count of `1` and kept only one replica running.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这一次，ReplicaSet删除了所有超出期望数量`1`的Pod，并只保留了一个副本在运行。
- en: 'Run the following command to delete the ReplicaSet for cleanup:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来删除ReplicaSet以进行清理：
- en: '[PRE55]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You should see the following response:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下响应：
- en: '[PRE56]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this exercise, we have managed to scale the number of replicas up and down.
    This could be particularly useful if the traffic to your application grows or
    decreases for any reason.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们已经成功地扩展和缩减了副本的数量。如果您的应用程序的流量增加或减少，这可能特别有用。
- en: Deployment
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: A Deployment is a Kubernetes object that acts as a wrapper around a ReplicaSet
    and makes it easier to use. In general, in order to manage replicated services,
    it's recommended that you use Deployments that, in turn, manage the ReplicaSet
    and the Pods created by the ReplicaSet.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 部署是一个Kubernetes对象，它充当了ReplicaSet的包装器，并使其更容易使用。一般来说，为了管理复制的服务，建议您使用部署，而部署又管理ReplicaSet和ReplicaSet创建的Pod。
- en: 'The major motivation for using a Deployment is that it maintains a history
    of revisions. Every time a change is made to the ReplicaSet or the underlying
    Pods, a new revision of the ReplicaSet is recorded by the Deployment. This way,
    using a Deployment makes it easy to roll back to a previous state or version.
    Keep in mind that every rollback will also create a new revision for the Deployment.
    The following diagram provides an overview of the hierarchy of the different objects
    managing your containerized application:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Deployment的主要动机是它保留了修订版本的历史记录。每当对ReplicaSet或底层Pod进行更改时，Deployment都会记录ReplicaSet的新修订版本。这样，使用Deployment可以轻松回滚到先前的状态或版本。请记住，每次回滚也会为Deployment创建一个新的修订版本。以下图表概述了管理容器化应用程序的不同对象的层次结构：
- en: '![Figure 7.6: Hierarchy of Deployment, ReplicaSet, Pods, and containers'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6：Deployment、ReplicaSet、Pod和容器的层次结构'
- en: '](image/B14870_07_06.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_07_06.jpg)'
- en: 'Figure 7.6: Hierarchy of Deployment, ReplicaSet, Pods, and containers'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：Deployment、ReplicaSet、Pod和容器的层次结构
- en: Deployment Configuration
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Deployment配置
- en: 'The configuration of a Deployment is actually very similar to that of a ReplicaSet.
    Here''s an example of a Deployment configuration:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment的配置实际上与ReplicaSet的配置非常相似。以下是一个Deployment配置的示例：
- en: '[PRE57]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The value for the `kind` field is `Deployment`. The rest of the configuration
    remains the same as that for ReplicaSets. Deployments also have the `replicas`,
    `selector`, and Pod `template` fields used in the same way as ReplicaSets.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind`字段的值为`Deployment`。其余配置与ReplicaSets的配置相同。Deployments还具有与ReplicaSets相同方式使用的`replicas`、`selector`和Pod
    `template`字段。'
- en: Strategy
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略
- en: In the `strategy` field under `spec`, we can specify which strategy the Deployment
    should use when it replaces old pods with new ones. This can either be `RollingUpdate`
    or `Recreate`. The default value is `RollingUpdate`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在`spec`下的`strategy`字段中，我们可以指定Deployment在用新的Pod替换旧的Pod时应使用的策略。这可以是`RollingUpdate`或`Recreate`。默认值为`RollingUpdate`。
- en: '**RollingUpdate**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**RollingUpdate**'
- en: This is a strategy used to update a Deployment without having any downtime.
    With the `RollingUpdate` strategy, the controller updates the Pods one by one.
    Hence, at any given time, there will always be some Pods running. This strategy
    is particularly helpful when you want to update the Pod template without incurring
    any downtime for your application. However, be aware that having a rolling update
    means that there may be two different versions of Pods (old and new) running at
    the same time.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种用于更新Deployment而不会有任何停机时间的策略。使用`RollingUpdate`策略，控制器逐个更新Pods。因此，在任何给定时间，总会有一些Pod在运行。当您想要更新Pod模板而不为应用程序带来任何停机时间时，这种策略特别有帮助。但是，请注意，进行滚动更新意味着可能会同时运行两个不同版本的Pod（旧版本和新版本）。
- en: If applications serve static information, this is usually fine because there's
    usually no harm in serving traffic using two different versions of an application,
    so long as the information that is served is the same. So, `RollingUpdate` is
    usually a good strategy for these applications. In general, we can use `RollingUpdate`
    for applications for which the data stored by a new version can be read and handled
    by the old version of the application.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序提供静态信息，通常情况下这是可以接受的，因为使用两个不同版本的应用程序提供流量通常不会造成任何伤害，只要提供的信息是相同的。因此，对于这些应用程序，`RollingUpdate`通常是一个很好的策略。一般来说，我们可以将`RollingUpdate`用于新版本存储的数据可以被旧版本的应用程序读取和处理的应用程序。
- en: 'Here''s an example configuration for setting the strategy to `RollingUpdate`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将策略设置为“RollingUpdate”的示例配置：
- en: '[PRE58]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`maxUnavailable` is the maximum number of Pods that can be unavailable during
    the update. This field can be specified as either an integer representing the
    maximum number of unavailable Pods or a string representing the percentage of
    total replicas that can be unavailable. For the preceding example configuration,
    Kubernetes will ensure that no more than one replica becomes unavailable while
    applying an update. The default value for `maxUnavailable` is `25%`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxUnavailable`是在更新期间可以不可用的Pod的最大数量。此字段可以指定为表示不可用Pod的最大数量的整数，也可以指定为表示可以不可用的总副本的百分比的字符串。对于前面的示例配置，Kubernetes将确保在应用更新时不会有超过一个副本不可用。`maxUnavailable`的默认值为`25%`。'
- en: '`maxSurge` is the maximum number of Pods that can be scheduled/created above
    the desired number of Pods (as specified in the `replicas` field). This field
    can also be specified as either an integer or a percentage string, as with `maxUnavailable`.
    The default value for `maxSurge` is also `25%`.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxSurge`是可以在所需的Pod数量（在`replicas`字段中指定）之上调度/创建的最大Pod数量。这个字段也可以指定为整数或百分比字符串，就像`maxUnavailable`一样。`maxSurge`的默认值也是`25%`。'
- en: Hence, in the preceding example, we are telling the Kubernetes controller to
    update the Pods one at a time, in such a way that no more than one Pod is ever
    unavailable and that no more than four Pods are ever scheduled.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面的示例中，我们告诉Kubernetes控制器以一次一个Pod的方式更新Pod，以便永远不会有超过一个Pod不可用，并且永远不会有超过四个Pod被调度。
- en: 'The two parameters—`maxUnavailable` and `maxSurge`—can be tuned for availability
    and the speed of scaling up or down the Deployment. For example, `maxUnavailable:
    0` and `maxSurge: "30%"` ensure a rapid scale-up while maintaining the desired
    capacity at all times. `maxUnavailable: "15%"` and `maxSurge: 0` ensure that the
    deployment can be performed without using any extra capacity at the cost of having,
    at worst, 15% fewer Pods running.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxUnavailable`和`maxSurge`这两个参数可以用于调整部署的可用性和扩展部署的速度。例如，`maxUnavailable: 0`和`maxSurge:
    "30%"`可以确保快速扩展，同时始终保持所需的容量。`maxUnavailable: "15%"`和`maxSurge: 0`可以确保在不使用任何额外容量的情况下执行部署，但最多可能会有15%的Pod不运行。'
- en: '**Recreate**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 重新创建
- en: 'In this strategy, all the existing pods are killed before creating the new
    Pods with an updated configuration. This means there will be some downtime during
    the update. This, however, ensures that all the Pods running in the Deployment
    will be on the same version (old or new). This strategy is particularly useful
    when working with application Pods that need to have a shared state and so we
    can''t have two different versions of Pods running at the same time. This strategy
    can be specified as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种策略中，所有现有的Pod都被杀死，然后使用更新的配置创建新的Pod。这意味着在更新期间会有一些停机时间。然而，这确保了部署中运行的所有Pod将是相同的版本（旧的或新的）。当与需要具有共享状态的应用程序Pod一起工作时，这种策略特别有用，因此我们不能同时运行两个不同版本的Pod。可以指定此策略如下：
- en: '[PRE59]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: A good use case for using the `Recreate` update strategy is if we need to run
    some data migration or data processing before the new code can be used. In this
    case, we will need to use the `Recreate` strategy because we can't afford to have
    any new code running along with the old one without running the migration or processing
    first for all the Pods.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“重新创建”更新策略的一个很好的用例是，如果我们需要在新代码可以使用之前运行一些数据迁移或数据处理。在这种情况下，我们需要使用“重新创建”策略，因为我们不能承受任何新代码与旧代码一起运行而没有先运行迁移或处理所有Pod的情况。
- en: Now that we have studied the different fields in the configuration of a Deployment,
    let's implement them in the following exercise.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经研究了部署配置中的不同字段，让我们在以下练习中实现它们。
- en: 'Exercise 7.05: Creating a Simple Deployment with Nginx Containers'
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.05：创建一个带有Nginx容器的简单部署
- en: In this exercise, we will create our first Deployment Pod using the configuration
    described in the previous section.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用前一节中描述的配置创建我们的第一个部署Pod。
- en: 'To successfully complete this exercise, perform the following steps:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功完成这个练习，请执行以下步骤：
- en: 'Create a file called `nginx-deployment.yaml` with the following content:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`nginx-deployment.yaml`的文件，内容如下：
- en: '[PRE60]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In this configuration, we can see that the Deployment will have three replicas
    of Pods running with the `app: nginx` and `environment: production` labels.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个配置中，我们可以看到部署将有三个带有`app: nginx`和`environment: production`标签的Pod的副本运行。'
- en: 'Run the following command to create the Deployment defined in the previous step:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以创建前面步骤中定义的部署：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You should see the following response:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下响应：
- en: '[PRE62]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Run the following command to check the status of the Deployment:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以检查部署的状态：
- en: '[PRE63]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You should see a response similar to the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下的响应：
- en: '[PRE64]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Run the following command to check all the Pods that are running:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以检查所有正在运行的Pod：
- en: '[PRE65]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You should see a response similar to the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下的响应：
- en: '![Figure 7.7: A list of Pods created by the Deployment'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7：由部署创建的Pod列表'
- en: '](image/B14870_07_07.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_07_07.jpg)'
- en: 'Figure 7.7: A list of Pods created by the Deployment'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：由部署创建的Pod列表
- en: We can see that the Deployment has created three Pods, as desired.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到部署已经创建了三个Pod，就像我们期望的那样。
- en: Let's try to understand the names given to the Pods automatically. `nginx-deployment`
    creates a ReplicaSet named `nginx-deployment-588765684f`. The ReplicaSet then
    creates three replicas of Pods, each of which has a name that is prefixed with
    the name of the ReplicaSet followed by a unique identifier.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着理解自动分配给Pod的名称。`nginx-deployment`创建了一个名为`nginx-deployment-588765684f`的ReplicaSet。然后，ReplicaSet创建了三个Pod的副本，每个Pod的名称都以ReplicaSet的名称为前缀，后跟一个唯一的标识符。
- en: 'Now that we have created our first Deployment, let''s look at it in more detail
    to understand what actually happened during its creation. To do that, we can describe
    the Deployment we just created using the following command in the terminal:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的第一个部署，让我们更详细地了解一下，以了解在创建过程中实际发生了什么。为了做到这一点，我们可以使用以下命令在终端中描述我们刚刚创建的部署：
- en: '[PRE66]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You should see output similar to this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似这样的输出：
- en: '![Figure 7.8: Describing nginx-deployment'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8：描述nginx-deployment'
- en: '](image/B14870_07_08.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_07_08.jpg)'
- en: 'Figure 7.8: Describing nginx-deployment'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：描述nginx-deployment
- en: This output shows various details about the Deployment we just created. In the
    following subtopics, we will go through the highlighted sections of the preceding
    output to understand the Deployment that's running.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示了我们刚刚创建的部署的各种细节。在接下来的子主题中，我们将逐步介绍前面输出的突出部分，以了解正在运行的部署。
- en: Labels and Annotations on the Deployment
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署上的标签和注释
- en: 'Similar to ReplicaSets, we can see the following line highlighted in the output
    shown in *Figure 7.8*:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 与ReplicaSets类似，我们可以在*图7.8*中显示的输出中看到以下行：
- en: '[PRE67]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This indicates that the Deployment was created with an `app=nginx` label. Now,
    let''s consider the next field in the output:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明部署是使用`app=nginx`标签创建的。现在，让我们考虑输出中的下一个字段：
- en: '[PRE68]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: There are two annotations added to the Deployment automatically.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 部署自动添加了两个注释。
- en: '**The Revision annotation**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**修订注释**'
- en: The Kubernetes controller adds an annotation with the `deployment.kubernetes.io/revision`
    key, which contains information about how many revisions have been there for a
    particular Deployment.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes控制器添加了一个带有`deployment.kubernetes.io/revision`键的注释，其中包含了特定部署的修订次数的信息。
- en: '**The last-applied-configuration annotation**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**最后应用的配置注释**'
- en: Another annotation added by the controller has the `kubectl.kubernetes.io/last-applied-configuration`
    key, which contains the last configuration (in JSON format) that was applied to
    the Deployment. This annotation is particularly helpful in rolling back a Deployment
    to a previous revision if a new revision doesn't work well.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器添加的另一个注释具有`kubectl.kubernetes.io/last-applied-configuration`键，其中包含应用于部署的最后配置（以JSON格式）。如果新的修订版本不起作用，此注释特别有助于将部署回滚到先前的修订版本。
- en: Selectors for the Deployment
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署的选择器
- en: 'Now, consider the following line from the output shown in *Figure 7.8*:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑输出中*图7.8*中显示的以下行：
- en: '[PRE69]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This shows which Pod selectors the Deployment is configured with. So, this Deployment
    will try to acquire the Pods that have both of these labels.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了部署配置的Pod选择器。因此，此部署将尝试获取具有这两个标签的Pod。
- en: Replicas
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 副本
- en: 'Consider the following line from the output shown in *Figure 7.8*:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑输出中*图7.8*中显示的以下行：
- en: '[PRE70]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We can see that the Deployment has the desired count of `3` for the Pods, and
    it also shows that there are currently `3` replicas present.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，部署对于Pod的期望计数为`3`，并且还显示当前存在`3`个副本。
- en: Rolling Back a Deployment
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回滚部署
- en: In a real-life scenario, you may make a mistake when making a change in the
    Deployment configuration. You can easily undo a change and roll back to a previous
    stable revision of the Deployment.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际场景中，当更改部署配置时可能会出错。您可以轻松撤消更改并回滚到先前稳定的部署修订版本。
- en: 'We can use the `kubectl rollout` command to check the revision history and
    rollback. But to make this work, we also need to use the `--record` flag when
    we use any `apply` or `set` commands to modify the Deployment. This flag records
    the rollout history. Then, you can view the rollout history using the following
    command:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`kubectl rollout`命令来检查修订历史和回滚。但是，为了使其工作，当我们使用任何`apply`或`set`命令修改部署时，我们还需要使用`--record`标志。此标志记录发布历史。然后，您可以使用以下命令查看发布历史：
- en: '[PRE71]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then, we can undo any updates by using the following command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令撤消任何更新：
- en: '[PRE72]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s take a closer look at how this works in the following exercise:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下练习中更仔细地看看这是如何工作的：
- en: 'Exercise 7.06: Rolling Back a Deployment'
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.06：回滚部署
- en: 'In this exercise, we will update the Deployment twice. We will make an intentional
    mistake in the second update and try to roll back to a previous revision:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将更新部署两次。我们将在第二次更新中故意出错，并尝试回滚到先前的修订版本：
- en: 'Create a file called `app-deployment.yaml` with the following content:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`app-deployment.yaml`的文件，内容如下：
- en: '[PRE73]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Run the following command to create the Deployment:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来创建部署：
- en: '[PRE74]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You should see the following response:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '[PRE75]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Run the following command to check the rollout history of the newly created Deployment:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来检查新创建的部署的发布历史：
- en: '[PRE76]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You should see the following response:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下响应：
- en: '[PRE77]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This output shows that the Deployment has no rollout history as of now.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示，截至目前，部署没有发布历史记录。
- en: 'For the first update, let''s change the name of the container to `nginx` instead
    of `nginx-container`. Update the content of the `app-deployment.yaml` file with
    the following:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第一次更新，让我们将容器的名称更改为`nginx`而不是`nginx-container`。使用以下内容更新`app-deployment.yaml`文件：
- en: '[PRE78]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As you can see, the only thing that has changed in this template is the container name.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，此模板中唯一更改的是容器的名称。
- en: 'Apply the changed configuration using the `kubectl apply` command with the
    `--record` flag. The `--record` flag ensures that the update to the Deployment
    is recorded in the rollout history of the Deployment:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl apply`命令应用更改的配置，并使用`--record`标志。`--record`标志确保将部署的更新记录在部署的发布历史中：
- en: '[PRE79]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'You should see the following response:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE80]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Note that the rollout history maintained by the `--record` flag is different
    from the past configs stored in the annotations, which we saw in the *Labels and
    Annotations on the Deployment* subsection.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由 `--record` 标志维护的滚动历史与注释中存储的过去配置不同，我们在“部署的标签和注释”子部分中看到了这一点。
- en: 'Wait for a few seconds to allow the Deployment to recreate the Pods with the
    updated Pod configuration, and then run the following command to check the rollout
    history of the Deployment:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几秒钟，让部署重新创建具有更新的 Pod 配置的 Pods，然后运行以下命令来检查部署的滚动历史：
- en: '[PRE81]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You should see the following response:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 7.9: Checking the deployment history'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.9：检查部署历史'
- en: '](image/B14870_07_09.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_07_09.jpg)'
- en: 'Figure 7.9: Checking the deployment history'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9：检查部署历史
- en: In the output, we can see that the second revision of the Deployment was created.
    It also keeps track of what command was used to update the Deployment.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到部署的第二个修订版本已经创建。它还跟踪了用于更新部署的命令。
- en: 'Next, let''s update the Deployment and assume that we made a mistake while
    doing so. In this example, we will update the container image to `ngnx` (note
    the intentional spelling error) instead of `nginx` using the `set image` command:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们更新部署，并假设我们在这样做时犯了一个错误。在这个例子中，我们将使用 `set image` 命令将容器镜像更新为 `ngnx`（注意有意的拼写错误），而不是
    `nginx`：
- en: '[PRE82]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You should see the following response:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE83]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Wait for a few seconds for Kubernetes to recreate the new containers, and then
    check the status of the Deployment rollout using the `kubectl rollout status`
    command:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几秒钟，让 Kubernetes 重新创建新的容器，然后使用 `kubectl rollout status` 命令检查部署的滚动状态：
- en: '[PRE84]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'You should see the following response:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE85]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In this output, we can see that none of the new replicas are ready yet. Press
    *Ctrl* + *C* to exit and proceed.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，我们可以看到新的副本都还没有准备好。按 *Ctrl* + *C* 退出并继续。
- en: 'Run the following command to check the state of the Pods:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令检查 Pods 的状态：
- en: '[PRE86]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You should see the following output:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 7.10: Checking the status of Pods'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.10：检查 Pods 的状态'
- en: '](image/B14870_07_10.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_07_10.jpg)'
- en: 'Figure 7.10: Checking the status of Pods'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10：检查 Pods 的状态
- en: We can see in the output that the newly created Pod has failed with an `ImagePullBackOff`
    error, which means that the Pods aren't able to pull the image. This is expected
    because we have a typo in the name of the image.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在输出中看到，新创建的 Pod 出现了“ImagePullBackOff”错误，这意味着 Pods 无法拉取镜像。这是预期的，因为我们在镜像名称中有一个拼写错误。
- en: 'Next, check the revision history of the Deployment again by using the following command:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，再次使用以下命令检查部署的修订历史：
- en: '[PRE87]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You should see the following response:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '![Figure 7.11: Checking the rollout history of the Deployment'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.11：检查部署的滚动历史'
- en: '](image/B14870_07_11.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_07_11.jpg)'
- en: 'Figure 7.11: Checking the rollout history of the Deployment'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11：检查部署的滚动历史
- en: We can see that a third revision of the Deployment was created using the `set
    image` command containing the typo. Now that we have pretended to have made a
    mistake in updating the Deployment, we will see how to undo this and roll back
    to the last stable revision of the Deployment.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到使用包含拼写错误的 `set image` 命令创建了部署的第三个修订版本。现在，我们假装在更新部署时犯了一个错误，我们将看到如何撤消这个错误并回滚到部署的最后一个稳定修订版本。
- en: 'Run the following command to roll back to the previous revision:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令回滚到上一个修订版本：
- en: '[PRE88]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You should see the following response:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE89]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'As we can see in this output, the Deployment has not been rolled back to the
    previous revision. To practice, we may want to roll back to a revision different
    from the previous revision. We can use the `--to-revision` flag to specify the
    revision number to which we want to roll back. For example, in the preceding case,
    we could have used the following command and the result would have been exactly
    the same:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这个输出中所看到的，Deployment 没有回滚到以前的修订版本。为了练习，我们可能希望回滚到与以前的修订版本不同的修订版本。我们可以使用
    `--to-revision` 标志来指定我们想要回滚到的修订版本号。例如，在前面的情况下，我们可以使用以下命令，结果将完全相同：
- en: '[PRE90]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Run the following command to check the rollout history of the Deployment again:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行以下命令以检查 Deployment 的升级历史：
- en: '[PRE91]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'You should see the following output:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![Figure 7.12: The rollout history for the Deployment after rollback'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.12：回滚后 Deployment 的升级历史'
- en: '](image/B14870_07_12.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_07_12.jpg)'
- en: 'Figure 7.12: The rollout history for the Deployment after rollback'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12：回滚后 Deployment 的升级历史
- en: We can see in this output that a new revision was created, which applied the
    revision that was previously revision 2\. We can see that revision 2 is no longer
    present in the list of revisions. This is because rollouts are always done in
    a rolling-forward manner. This means that any time we update a revision, a new
    revision of a higher number is created. Similarly, in the case of a rollback to
    revision 2, revision 2 became revision 4.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这个输出中看到一个新的修订版本被创建，应用了之前的修订版本 2。我们可以看到修订版本 2 不再出现在修订版本列表中。这是因为升级总是以滚动向前的方式进行的。这意味着每当我们更新一个修订版本时，都会创建一个更高编号的新修订版本。同样，在回滚到修订版本
    2 的情况下，修订版本 2 变成了修订版本 4。
- en: In this exercise, we explored a lot of different possible operations relating
    to updating a Deployment, rolling it forward with some changes, tracking the history
    of a Deployment, undoing some changes, and rolling back to a previous revision.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们探索了许多与更新 Deployment、进行一些更改的滚动向前、跟踪 Deployment 历史、撤消一些更改以及回滚到以前修订版本相关的可能操作。
- en: StatefulSets
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StatefulSets
- en: StatefulSets are used to manage stateful replicas. Similar to a Deployment,
    a StatefulSet creates and manages the specified number of Pod replicas from an
    identical Pod template. However, where StatefulSets differ from Deployments is
    that they maintain a unique identity for each of their Pods. So, even if all the
    Pods are of identical specs, they are not interchangeable. Each of the Pods has
    a sticky identity that can be used by the application code to manage the state
    of the application on a particular Pod. For a StatefulSet with *n* replicas, each
    Pod is assigned a unique integer ordinal between *0* and *n – 1*. The names of
    the Pods reflect the integer identity assigned to them. When a StatefulSet is
    created, all the Pods are created in the order of their integer ordinal.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSets 用于管理有状态的副本。与 Deployment 类似，StatefulSet 从相同的 Pod 模板创建和管理指定数量的 Pod
    副本。然而，StatefulSets 与 Deployments 的不同之处在于它们为每个 Pod 保持唯一的标识。因此，即使所有的 Pods 规格相同，它们也不是可互换的。每个
    Pod 都有一个固定的标识，应用代码可以使用它来管理特定 Pod 上的应用状态。对于具有 *n* 个副本的 StatefulSet，每个 Pod 被分配一个介于
    *0* 和 *n – 1* 之间的唯一整数序数。Pod 的名称反映了分配给它们的整数标识。创建 StatefulSet 时，所有的 Pods 都按照它们的整数序数顺序创建。
- en: Each of the Pods managed by a StatefulSet will persist their sticky identity
    (integer ordinal) even if the Pod restarts. For example, if a particular Pod crashes
    or is deleted, a new Pod will be created and assigned the same sticky identity
    as that of the old Pod.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSet 管理的每个 Pod 都将保持它们的固定标识（整数序数），即使 Pod 重新启动。例如，如果特定的 Pod 崩溃或被删除，将创建一个新的
    Pod，并分配与旧 Pod 相同的固定标识。
- en: StatefulSet Configuration
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StatefulSet 配置
- en: 'The configuration of a StatefulSet is also very similar to that of a ReplicaSet.
    Here''s an example of StatefulSet configuration:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSet的配置也与ReplicaSet非常相似。以下是一个StatefulSet配置的示例：
- en: '[PRE92]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: As we can see in the preceding configuration, `apiVersion` for a StatefulSet
    is `apps/v1` and `kind` is `StatefulSet`. The rest of the fields are used in the
    same way as for ReplicaSets.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的配置中所看到的，StatefulSet的`apiVersion`是`apps/v1`，`kind`是`StatefulSet`。其余字段的使用方式与ReplicaSets相同。
- en: Note
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will learn how to implement StatefulSets on a multi-node cluster in *Chapter
    14*, *Running Stateful Components in Kubernetes*.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第14章*《在Kubernetes中运行有状态的组件》中，您将学习如何在多节点集群上实现StatefulSets。
- en: Use Cases for StatefulSets
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: StatefulSets的用例
- en: StatefulSets are useful if you need persistent storage. Using a StatefulSet,
    you can partition the data and store it in different Pods. In this case, it would
    also be possible for a Pod to go down and a new Pod come up with the same identity
    and have the same partition of data previously stored by the old Pod.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要持久存储，StatefulSets非常有用。使用StatefulSet，您可以将数据分区并存储在不同的Pods中。在这种情况下，一个Pod可能会关闭，一个新的Pod以相同的标识启动，并且具有之前由旧Pod存储的相同数据分区。
- en: A StatefulSet can also be used if you require ordered updates or scaling. For
    example, if you want to create or update your Pods in the order of the identities
    assigned to them, using a StatefulSet is a good idea.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要有序的更新或扩展，也可以使用StatefulSet。例如，如果您希望按照为它们分配的标识的顺序创建或更新Pods，使用StatefulSet是一个好主意。
- en: DaemonSets
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DaemonSets
- en: DaemonSets are used to manage the creation of a particular Pod on all or a selected
    set of nodes in a cluster. If we configure a DaemonSet to create Pods on all nodes,
    then if new nodes are added to the cluster, new pods will be created to run on
    these new nodes. Similarly, if some nodes are removed from the cluster, the Pods
    running on these nodes will be destroyed.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: DaemonSets用于管理集群中所有或选定节点上特定Pod的创建。如果我们配置一个DaemonSet在所有节点上创建Pods，那么如果向集群添加新节点，将会创建新的Pods在这些新节点上运行。同样，如果一些节点从集群中移除，运行在这些节点上的Pods将被销毁。
- en: Use Cases for DaemonSets
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DaemonSets的用例
- en: 'Logging: One of the most common use cases for a DaemonSet is to manage running
    a log collection Pod on all nodes. These Pods can be used to collect logs from
    all the nodes and then process them in a log processing pipeline.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录：DaemonSet最常见的用例之一是在所有节点上管理运行日志收集Pod。这些Pods可用于从所有节点收集日志，然后在日志处理管道中处理它们。
- en: 'Local data caching: A DaemonSet can also be used to manage caching Pods on
    all the nodes. These Pods can be used by other application Pods to store the cached
    data temporarily.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地数据缓存：DaemonSet也可以用于在所有节点上管理缓存Pod。其他应用Pods可以使用这些Pods来临时存储缓存数据。
- en: 'Monitoring: Another use case for a DaemonSet is to manage running monitoring
    Pods on all the nodes. This can be used to collect system- or application-level
    metrics for Pods running on a particular node.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控：DaemonSet的另一个用例是在所有节点上管理运行监控Pod。这可用于收集特定节点上运行的Pod的系统或应用级别指标。
- en: DaemonSet Configuration
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DaemonSet配置
- en: 'The configuration of a DaemonSet is also very similar to that of a ReplicaSet
    or a Deployment. Here''s an example of DaemonSet configuration:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: DaemonSet的配置也与ReplicaSet或Deployment非常相似。以下是一个DaemonSet配置的示例：
- en: '[PRE93]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: As we can see in the preceding configuration, `apiVersion` for a DaemonSet is
    set to `apps/v1` and `kind` is set to `DaemonSet`. The rest of the fields are
    used in the same way as for ReplicaSets.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的配置中所看到的，DaemonSet的`apiVersion`设置为`apps/v1`，`kind`设置为`DaemonSet`。其余字段的使用方式与ReplicaSets相同。
- en: To limit the scope of this book, we will not cover the details for implementing DaemonSets.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制本书的范围，我们不会涵盖实现DaemonSets的详细信息。
- en: Up until now in this chapter, you have learned about ReplicaSets, which help
    us manage several replicas of Pods running an application, and how a Deployment
    acts as a wrapper on a ReplicaSet to add some features to control rolling out
    updates and maintaining the update history, with the option of rolling back if
    needed. Then, we learned about StatefulSets, which are handy if we need to treat
    each replica as a unique entity. We also learned how DaemonSets allow us to schedule
    a Pod on each of our nodes.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了ReplicaSets，它帮助我们管理运行应用程序的多个Pod副本，以及Deployment如何作为ReplicaSet的包装器添加一些功能来控制更新的发布和维护更新历史记录，并在需要时回滚。然后，我们了解了StatefulSets，如果我们需要将每个副本视为唯一实体，则非常有用。我们还了解了DaemonSets如何允许我们在每个节点上调度一个Pod。
- en: All of these controllers have one common characteristic—they are useful for
    applications or workloads that are to be run continually. However, some workloads
    have a graceful conclusion, and there is no need to keep the Pods running after
    the task is done. For this, Kubernetes has a controller called a Job. Let's take
    a look at this in the following section.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些控制器都有一个共同的特点——它们对于需要持续运行的应用程序或工作负载非常有用。然而，一些工作负载具有优雅的结论，任务完成后无需保持Pod运行。为此，Kubernetes有一个称为Job的控制器。让我们在下一节中看看这个。
- en: Jobs
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jobs
- en: A Job is a supervisor in Kubernetes that can be used to manage Pods that are
    supposed to run a determined task and then terminate gracefully. A Job creates
    the specified number of Pods and ensures that they successfully complete their
    workloads or tasks. When a Job is created, it creates and tracks the Pods that
    were specified in its configuration. When a specified number of Pods complete
    successfully, the Job is considered complete. If a Pod fails because of underlying
    node failures, the Job will create a new Pod to replace it. This also means that
    the application or code running on the Pod should be capable of gracefully handling
    a case where a new Pod comes up during the runtime of the process.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Job是Kubernetes中的一个监督者，可以用来管理应该运行确定任务然后优雅终止的Pod。Job创建指定数量的Pod，并确保它们成功完成其工作负载或任务。当创建Job时，它会创建并跟踪其配置中指定的Pod。当指定数量的Pod成功完成时，Job被视为完成。如果Pod因底层节点故障而失败，Job将创建一个新的Pod来替换它。这也意味着在Pod上运行的应用程序或代码应该能够优雅地处理在进程运行时出现新的Pod的情况。
- en: The Pods created by a Job aren't deleted following completion of the job. The
    Pods run to completion and stay in the cluster with a `Completed` status.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: Job创建的Pod在作业完成后不会被删除。Pod会运行到完成并以“已完成”状态留在集群中。
- en: 'A Job can be used in several different ways:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Job可以以几种不同的方式使用：
- en: The simplest use case is to create a Job that runs only one Pod to completion.
    The Job will only create additional new Pods if the running pod fails. For example,
    a Job can be used for one-off or recurring data analysis work or for the training
    of a machine learning model.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最简单的用例是创建一个只运行一个Pod直到完成的Job。如果正在运行的Pod失败，Job将只创建额外的新Pod。例如，Job可用于一次性或定期数据分析工作或用于机器学习模型的训练。
- en: Jobs can also be used for parallel processing. We can specify more than one
    successful Pod completion to ensure that the Job will complete only when a certain
    number of Pods have terminated successfully.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Job也可以用于并行处理。我们可以指定多个成功的Pod完成，以确保Job仅在一定数量的Pod成功终止时才完成。
- en: Job Configuration
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Job配置
- en: 'The configuration of a Job follows a similar pattern to that of a ReplicaSet
    or a Deployment. Here''s an example of Job configuration:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Job的配置遵循与ReplicaSet或Deployment类似的模式。以下是Job配置的示例：
- en: '[PRE94]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The `apiVersion` field for a Job object is set to `batch/v1`. The `batch` API
    group contains objects relating to batch processing jobs. The `kind` field is
    set to `Job`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 作业对象的`apiVersion`字段设置为`batch/v1`。`batch` API组包含与批处理作业相关的对象。`kind`字段设置为`Job`。
- en: A Use Case for Jobs in Machine Learning
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 机器学习中作业的用例
- en: Jobs are perfect for batch processes—processes that run for a certain amount
    of time before exiting. This makes Jobs ideal for many types of production machine
    learning tasks, such as feature engineering, cross-validation, model training,
    and batch inference. For instance, you can create a Kubernetes Job that trains
    a machine learning model and persists the model and training metadata to external
    storage. Then, you can create another Job to perform batch inference. This Job
    would create a Pod that fetches the pre-trained model from storage, loads both
    the model and data into memory, performs inference, and stores the predictions.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 作业非常适合批处理过程 - 在退出之前运行一定时间的过程。这使得作业非常适合许多类型的生产机器学习任务，如特征工程、交叉验证、模型训练和批量推断。例如，您可以创建一个Kubernetes作业来训练一个机器学习模型，并将模型和训练元数据持久化到外部存储。然后，您可以创建另一个作业来执行批量推断。这个作业将创建一个Pod，从存储中获取预训练模型，将模型和数据加载到内存中，执行推断，并存储预测结果。
- en: 'Exercise 7.07: Creating a Simple Job That Finishes in Finite Time'
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.07：创建一个在有限时间内完成的简单作业
- en: In this exercise, we will create our first Job, which will run a container that
    simply waits for 10 seconds and then finishes.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建我们的第一个作业，该作业将运行一个简单等待10秒然后完成的容器。
- en: 'To successfully complete this exercise, perform the following steps:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功完成此练习，请执行以下步骤：
- en: 'Create a file called `one-time-job.yaml` with the following content:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`one-time-job.yaml`的文件，内容如下：
- en: '[PRE95]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Run the following command to create the Deployment using the `kubectl apply`
    command:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，使用`kubectl apply`命令创建部署：
- en: '[PRE96]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You should see the following response:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE97]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Run the following command to check the status of the Job:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以检查作业的状态：
- en: '[PRE98]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You should see a response similar to this:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于这样的响应：
- en: '[PRE99]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: We can see that the Job requires one completion and is not yet completed.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到作业需要一个完成，并且尚未完成。
- en: 'Run the following command to check the Pod running the Job:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来检查运行作业的Pod的状态：
- en: '[PRE100]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Note that you should run this before the Job is complete to see the response
    shown here:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您应该在作业完成之前运行此命令以查看此处显示的响应：
- en: '[PRE101]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We can see that the Job has created a Pod named `one-time-job-bzz8l` to run
    the task specified in the Job template.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到作业已经创建了一个名为`one-time-job-bzz8l`的Pod来运行作业模板中指定的任务。
- en: 'Next, run the following command to check the logs for the Pod created by the Job:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令来检查由作业创建的Pod的日志：
- en: '[PRE102]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'You should see logs similar to the following:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的日志：
- en: '[PRE103]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We can see that the Pod printed the date, waited for 20 seconds, and then printed
    `Bye` in the terminal.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Pod打印了日期，等待了20秒，然后在终端打印了`Bye`。
- en: 'Let''s check the status of the Job again by using the following command:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下命令再次检查作业的状态：
- en: '[PRE104]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'You should see a response similar to this:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于这样的响应：
- en: '[PRE105]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: We can see that the Job has now been completed.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到作业现在已经完成。
- en: 'Run the following command to verify that the Pod has run to completion:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以验证Pod是否已完成运行：
- en: '[PRE106]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'You should see a response similar to this:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于这样的响应：
- en: '[PRE107]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: We can see that the Pod has a `Completed` status.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Pod的状态为`Completed`。
- en: 'Run the following command to delete the job (as well as the Pod it created)
    for cleanup:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以删除作业（以及它创建的Pod）进行清理：
- en: '[PRE108]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'You should see the following response:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下响应：
- en: '[PRE109]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: In this exercise, we created a one-time Job and verified that the Pod created
    by the Job runs to completion. Implementing Jobs for parallel tasks is a bit more
    complicated, and we will leave that out of this workshop for brevity.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建了一个一次性作业，并验证了作业创建的Pod是否运行完成。为了简洁起见，我们将不在本次研讨会中实施并行任务的作业。
- en: Next, let's wrap this chapter up with an activity where we will create a Deployment
    and bring together several ideas learned in this chapter.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过一个活动来总结本章，我们将在其中创建一个部署，并汇集本章学到的几个想法。
- en: 'Activity 7.01: Creating a Deployment Running an Application'
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动7.01：创建运行应用程序的部署
- en: 'Consider a scenario where the product/application team you''re working with
    is now ready to put their application in production and they need your help to
    deploy it in a replicated and reliable manner. For the scope of this exercise,
    consider the following requirements for the application:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个情景，你正在与产品/应用团队合作，他们现在准备将他们的应用投入生产，并需要你的帮助以可复制和可靠的方式部署它。在本练习范围内，考虑应用的以下要求：
- en: The default number of replicas should be 6.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认副本数量应为6。
- en: For simplicity, you can use the `nginx` image for the container running in the Pod.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为简单起见，您可以使用`nginx`镜像来运行Pod中的容器。
- en: 'Make sure all the Pods have the following two labels with corresponding values:'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所有Pod都具有以下两个标签及其对应的值：
- en: '[PRE110]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The update strategy for the Deployment should be `RollingUpdate`. At worst,
    no more than half of the Pods can be down, and similarly, at no point should there
    be more than 150% of the desired count of Pods.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署的更新策略应为`RollingUpdate`。最坏的情况下，Pod的数量不应该超过一半，同样，在任何时候都不应该超过期望Pod数量的150%。
- en: 'You should be able to perform the following tasks once the Deployment has been created:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署创建完成，您应该能够执行以下任务：
- en: Scale up the number of replicas to 10.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将副本数量扩展到10。
- en: Scale down the number of replicas to 5.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将副本数量缩减到5。
- en: Note
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Ideally, you would want to create this Deployment to be in a different namespace
    to keep it separate from the rest of the stuff that you created during the previous
    exercises. So, feel free to create a namespace and create the Deployment in that
    namespace.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您希望将此部署创建在不同的命名空间中，以使其与您在先前练习中创建的其他内容分开。因此，可以随意创建一个命名空间，并在该命名空间中创建部署。
- en: 'The following are the high-level steps to perform this activity:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是执行此活动的高级步骤：
- en: Create a namespace for this activity.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此活动创建一个命名空间。
- en: Write the Deployment configuration. Ensure that it meets all the requirements
    that are specified.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写部署配置。确保它满足所有指定的要求。
- en: Create the Deployment using the configuration from the previous step.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上一步的配置创建部署。
- en: Verify that six Pods were created by the Deployment.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证部署创建了六个Pod。
- en: Perform both of the tasks mentioned previously and verify the number of Pods
    after performing each step.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行前面提到的两个任务，并在每个步骤执行后验证Pod的数量。
- en: 'You should be able to get the list of Pods to check whether you can scale up
    the number of Pods, as shown in the following image:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够获取Pod的列表，以检查是否可以扩展Pod的数量，如下图所示：
- en: '![Figure 7.13: Checking whether the number of Pods is scaled up'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13：检查Pod的数量是否扩展
- en: '](image/B14870_07_13.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_07_13.jpg)'
- en: 'Figure 7.13: Checking whether the number of Pods is scaled up'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13：检查Pod的数量是否扩展
- en: 'Similarly, you should also be able to scale down and check the number of Pods,
    as shown here:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您还应该能够缩减并检查Pod的数量，如下所示：
- en: '![Figure 7.14: Checking whether the number of Pods is scaled down'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.14：检查Pod的数量是否缩减](image/B14870_07_14.jpg)'
- en: '](image/B14870_07_14.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_07_14.jpg)'
- en: 'Figure 7.14: Checking whether the number of Pods is scaled down'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14：检查Pod数量是否缩减
- en: Note
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下地址找到：[https://packt.live/304PEoD](https://packt.live/304PEoD)。
- en: Summary
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Kubernetes treats Pods as ephemeral entities, and ideally you would not deploy
    any application or a microservice in an individual Pod. Kubernetes offers various
    controllers to leverage various benefits, including automatic replication, health
    monitoring, and automatic scaling.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes将Pod视为短暂的实体，理想情况下，您不应该在单个Pod中部署任何应用程序或微服务。Kubernetes提供了各种控制器来利用各种好处，包括自动复制、健康监控和自动扩展。
- en: In this chapter, we covered different kinds of controllers and understood when
    to use each of them. We created ReplicaSets and observed how they manage Pods.
    We learned when to use DaemonSets and StatefulSets. We also created a Deployment
    and learned how we can scale up and down the number of replicas and roll back
    to an earlier version of the Deployment. Finally, we learned how to create Jobs
    for one-time tasks. All of these controllers come into play when you want to deploy
    a production-ready application or workload, as you will see in the upcoming chapters.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了不同类型的控制器，并了解了何时使用每种控制器。我们创建了ReplicaSets，并观察了它们如何管理Pods。我们学会了何时使用DaemonSets和StatefulSets。我们还创建了一个Deployment，并学会了如何扩展和缩减副本的数量，以及如何回滚到Deployment的早期版本。最后，我们学会了如何为一次性任务创建Jobs。当您在即将到来的章节中看到时，所有这些控制器都将在您想要部署生产就绪的应用程序或工作负载时发挥作用。
- en: In the next chapter, we will see how we can discover and access the Pods or
    replicas managed by a Deployment or a ReplicaSet.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何发现和访问由Deployment或ReplicaSet管理的Pods或副本。
