- en: 3\. kubectl – Kubernetes Command Center
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. kubectl - Kubernetes命令中心
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will demystify some common kubectl commands and see how
    we can use kubectl to control our Kubernetes cluster. We will begin this chapter
    by taking a brief look at what the end-to-end process looks like when using kubectl
    commands to communicate with a Kubernetes cluster. Then, we will set up a few
    shortcuts and autocompletion for the Bash terminal. We will begin with the basics
    of using kubectl by learning how to create, delete, and manage Kubernetes objects.
    We will learn about the two approaches to managing resources in Kubernetes - declarative
    and imperative - with exercises. By the end of this chapter, you will also have
    learned how to update a live application running on your Kubernetes cluster in
    real-time using kubectl.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将揭开一些常见的kubectl命令，并看看如何使用kubectl来控制我们的Kubernetes集群。我们将从简要了解使用kubectl命令与Kubernetes集群通信的端到端过程开始。然后，我们将为Bash终端设置一些快捷方式和自动补全。我们将从学习如何创建、删除和管理Kubernetes对象的基础知识开始使用kubectl。我们将通过练习了解在Kubernetes中管理资源的两种方法
    - 声明式和命令式。到本章结束时，您还将学会如何使用kubectl实时更新运行在您的Kubernetes集群上的应用程序。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In *Chapter 1*, *Introduction to Kubernetes and Containers*, we saw that Kubernetes
    is a portable and highly extensible open-source container orchestration tool.
    It provides very powerful capabilities that can be used to manage containerized
    workloads at scale. In the previous chapter, you got the big picture of how the
    different components of Kubernetes work together to achieve the desired goals.
    We also demonstrated some basic usage of kubectl in *Chapter 2, An Overview of
    Kubernetes*. In this chapter, we will take a closer look at this utility and look
    at how we can make use of its potential.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在《第1章 Kubernetes和容器简介》中，我们看到Kubernetes是一个便携且高度可扩展的开源容器编排工具。它提供了非常强大的功能，可用于规模化管理容器化工作负载。在上一章中，您了解了Kubernetes的不同组件如何共同工作以实现期望的目标。我们还在《第2章
    Kubernetes概述》中演示了kubectl的一些基本用法。在本章中，我们将更仔细地研究这个实用程序，并看看如何利用其潜力。
- en: To reiterate, kubectl is a command-line utility for interacting with Kubernetes
    clusters and performing various operations. There are two ways to use kubectl
    while managing your cluster - imperative management, which focuses on commands
    rather than the YAML manifests to achieve the desired state, and declarative management,
    which focuses on creating and updating YAML manifest files. kubectl can support
    both these management techniques to manage Kubernetes API objects (also called
    Kubernetes API primitives). In the previous chapter, we saw how the various components
    constantly try to change the state of the cluster from the actual state to the
    desired state. This can be achieved by using kubectl commands or YAML manifests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一下，kubectl是一个用于与Kubernetes集群交互和执行各种操作的命令行实用程序。在管理集群时，有两种使用kubectl的方式 - 命令式管理，重点是使用命令而不是YAML清单来实现所需的状态，以及声明式管理，重点是创建和更新YAML清单文件。kubectl可以支持这两种管理技术来管理Kubernetes
    API对象（也称为Kubernetes API原语）。在上一章中，我们看到各种组件不断尝试将集群的状态从实际状态更改为所需状态。这可以通过使用kubectl命令或YAML清单来实现。
- en: kubectl allows you to send commands to Kubernetes clusters. The `kubectl` command
    can be used to deploy applications, inspect, and manage Kubernetes objects, or
    troubleshoot and view logs. Interestingly, even though kubectl is the standard
    tool for controlling and communicating with a Kubernetes cluster, it doesn't come
    with Kubernetes. So, even if you are running kubectl on any of the nodes of your
    cluster, you need to install the kubectl binary separately, which we did in *Exercise
    2.01*, *Getting Started with Minikube and Kubernetes Clusters*, in the previous
    chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl允许您向Kubernetes集群发送命令。`kubectl`命令可用于部署应用程序、检查和管理Kubernetes对象，或者进行故障排除和查看日志。有趣的是，尽管kubectl是控制和与Kubernetes集群通信的标准工具，但它并不随Kubernetes一起提供。因此，即使您在集群的任何节点上运行kubectl，您仍需要单独安装kubectl二进制文件，这是我们在上一章的*练习2.01*中所做的，*使用Minikube和Kubernetes集群入门*。
- en: This chapter will walk you through the behind-the-scenes functionality of kubectl
    and provide more insights into how to use kubectl commands to interact with some
    commonly used Kubernetes objects. We will learn how to set up some shortcuts for
    kubectl. We will walk you through not only creating new objects with kubectl but
    also making changes to a live Deployment in Kubernetes. But before that, let's
    take a peek behind the curtains and get an idea of exactly how kubectl communicates
    with Kubernetes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带您深入了解kubectl的幕后功能，并提供更多关于如何使用kubectl命令与一些常用的Kubernetes对象进行交互的见解。我们将学习如何为kubectl设置一些快捷方式。我们将带您不仅使用kubectl创建新对象，还对Kubernetes中的实时部署进行更改。但在此之前，让我们偷偷看看幕后，了解kubectl如何与Kubernetes通信的确切方式。
- en: How kubectl Communicates with Kubernetes
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kubectl如何与Kubernetes通信
- en: As we saw in the previous chapter, the API server manages communications between
    the end-user and Kubernetes, and it also acts as an API gateway to the cluster.
    To achieve this, it implements the RESTful API over the HTTP and HTTPS protocols
    to perform CRUD operations to populate and modify Kubernetes API objects such
    as pods, services, and more based upon the instructions sent by a user via kubectl.
    These instructions can be in various forms. For example, to retrieve information
    for pods running in the cluster, we would use the `kubectl get pods` command,
    while to create a new pod, we would use the `kubectl run` command.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，API服务器管理终端用户与Kubernetes之间的通信，并且还充当集群的API网关。为了实现这一点，它实现了基于HTTP和HTTPS协议的RESTful
    API，以执行CRUD操作，以填充和修改Kubernetes API对象，例如pod、service等，根据用户通过kubectl发送的指令。这些指令可以采用各种形式。例如，要检索集群中运行的pod的信息，我们将使用`kubectl
    get pods`命令，而要创建一个新的pod，我们将使用`kubectl run`命令。
- en: 'First, let''s take a look at what happens behind the scenes when you run a
    `kubectl` command. Take a look at the following illustration, which provides an
    overview of the process, and then we will take a closer look at the different
    details of the process:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看运行`kubectl`命令时幕后发生了什么。看一下下面的插图，它提供了该过程的概述，然后我们将更仔细地查看该过程的不同细节：
- en: '![Figure 3.1: A representative flowchart for the kubectl utility'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1：kubectl实用程序的代表性流程图'
- en: '](image/B14870_03_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_03_01.jpg)'
- en: 'Figure 3.1: A representative flowchart for the kubectl utility'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：kubectl实用程序的代表性流程图
- en: A kubectl command is translated into an API call, which is then sent to the
    API server. The API server then authenticates and validates the requests. Once
    the authentication and validation stages have been successful, the API server
    retrieves and updates data in `etcd` and responds with the requested information.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl命令被转换为API调用，然后发送到API服务器。API服务器然后对请求进行身份验证和验证。一旦身份验证和验证阶段成功，API服务器将从`etcd`中检索和更新数据，并以请求的信息做出响应。
- en: Setting up Environments with Autocompletion and Shortcuts
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置自动补全和快捷方式的环境
- en: In most Linux environments, you can set up autocompletion for kubectl commands
    before you start working with the instructions mentioned in this chapter. Learning
    how autocompletion and shortcuts work in Linux environments will be significantly
    helpful for those who are interested in getting certifications such as **Certified
    Kubernetes Administrator** (**CKA**) and **Certified Kubernetes Application Developer**
    (**CKAD**), which are conferred by the Linux Foundation. We'll learn how to set
    up autocompletion in the following exercise.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数Linux环境中，您可以在开始使用本章提到的指令之前为kubectl命令设置自动补全。了解自动补全和快捷方式在Linux环境中的工作原理对于那些有兴趣获得由Linux基金会颁发的**认证Kubernetes管理员**（**CKA**）和**认证Kubernetes应用开发者**（**CKAD**）等证书的人来说将会非常有帮助。我们将在下面的练习中学习如何设置自动补全。
- en: 'Exercise 3.01: Setting up Autocompletion'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.01：设置自动补全
- en: 'In this exercise, we will show you how to set up autocompletion and an alias
    for kubectl commands in Bash. This is a useful feature that will help you save
    time and avoid typos. Perform the following steps to complete this exercise:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将向您展示如何在Bash中为kubectl命令设置自动补全和别名。这是一个有用的功能，将帮助您节省时间并避免打字错误。执行以下步骤完成本练习：
- en: 'We will need the `bash-completion` package, so install it if it is not already
    installed. You can go to the GitHub repository to get installation instructions
    for various platforms, at [https://github.com/scop/bash-completion](https://github.com/scop/bash-completion).
    If you are running Ubuntu 20.04, you can install it via the APT package manager
    using the following command:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要`bash-completion`包，如果尚未安装，请安装它。您可以前往GitHub存储库获取各种平台的安装说明，网址为[https://github.com/scop/bash-completion](https://github.com/scop/bash-completion)。如果您正在运行Ubuntu
    20.04，您可以使用以下命令通过APT软件包管理器安装它：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can use the following command to set up autocomplete in Bash:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令在Bash中设置自动补全：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This command, as well as the subsequent commands in this exercise, will not
    show any responses in the terminal upon successful execution.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令以及本练习中的后续命令在成功执行后不会在终端上显示任何响应。
- en: 'If you want to make autocomplete persistent in your Bash shell, you can use
    the following command, which will write `kubectl` autocomplete to the `.bashrc`
    file in your current user directory:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想在Bash shell中使自动补全持久化，可以使用以下命令，它将把`kubectl`自动补全写入到您当前用户目录下的`.bashrc`文件中：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also set up an alias for your `kubectl` commands by using the `alias`
    keyword, as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您也可以使用`alias`关键字为您的`kubectl`命令设置别名，方法如下：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Similarly, if you want to set up an alias for some specific commands, you can
    use commands similar to the following:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，如果您想为某些特定命令设置别名，可以使用类似以下的命令：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, you can use the following command to set up the completion of `kubectl`
    commands when you press *Tab*:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以使用以下命令在按下*Tab*时设置`kubectl`命令的自动补全：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can also to set up autocomplete in `zsh` (an alternative to the Bash shell)
    by using the following commands:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用以下命令在`zsh`（Bash shell的替代品）中设置自动补全：
- en: '`source <(kubectl completion zsh)`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`source <(kubectl completion zsh)`'
- en: '`echo "if [ $commands[kubectl] ]; then source <(kubectl completion zsh); fi"
    >> ~/.zshrc`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo "if [ $commands[kubectl] ]; then source <(kubectl completion zsh); fi"
    >> ~/.zshrc`'
- en: By the end of this exercise, you will have an autocomplete set up for your Bash
    shell. You can also use aliases such as `k` instead of `kubectl` in your commands.
    However, to avoid confusion and maintain a standardized structure, we will use
    the full commands throughout this book.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个练习之后，你将为你的Bash shell设置好自动补全。你也可以在命令中使用别名，比如使用`k`代替`kubectl`。然而，为了避免混淆并保持标准化的结构，我们在本书中将使用完整的命令。
- en: Setting up the kubeconfig Configuration File
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置kubeconfig配置文件
- en: In most enterprise environments, there is generally more than one Kubernetes
    cluster, depending on the strategy of the organization. An administrator, developer,
    or any other role dealing with Kubernetes clusters would need to interact with
    several of those clusters and switch between them to perform different operations
    on different clusters.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数企业环境中，通常会有不止一个Kubernetes集群，这取决于组织的策略。管理员、开发人员或者其他与Kubernetes集群打交道的角色需要与多个集群进行交互，并在不同的集群上执行不同的操作。
- en: A configuration file makes things a lot easier. You can use this file to store
    information about different clusters, users, namespaces, and authentication mechanisms.
    Such configuration files are referred to as **kubeconfig** files. Note that kubeconfig
    is a generic way to refer to kubectl configuration files and that it is not the
    name of the `config` file. kubectl uses such files to store the information needed
    for us to choose a cluster and communicate with its API server.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件会让事情变得更加简单。你可以使用这个文件来存储关于不同集群、用户、命名空间和认证机制的信息。这样的配置文件被称为**kubeconfig**文件。请注意，kubeconfig是指kubectl配置文件的通用方式，而不是`config`文件的名称。kubectl使用这样的文件来存储我们选择集群并与其API服务器通信所需的信息。
- en: By default, kubectl looks for the file in the `$HOME/.kube` directory. In most
    scenarios, you can specify a `KUBECONFIG` environment variable or use the `--kubeconfig`
    flag to specify the kubeconfig files. Those files are usually saved in `$HOME/.kube/config`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，kubectl会在`$HOME/.kube`目录中查找该文件。在大多数情况下，你可以指定一个`KUBECONFIG`环境变量或使用`--kubeconfig`标志来指定kubeconfig文件。这些文件通常保存在`$HOME/.kube/config`中。
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find out more about how to configure access to multiple clusters by
    setting up the `KUBECONFIG` environment variable and the `--kubeconfig` flag at
    [https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable](https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过设置`KUBECONFIG`环境变量和`--kubeconfig`标志来了解如何配置访问多个集群的更多信息，网址为[https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable](https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable)。
- en: Security contexts are used to define the privilege and access control settings
    for the pods. We will revisit the idea of access control and security in *Chapter
    13*, *Runtime and Network Security in Kubernetes*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 安全上下文用于定义pod的特权和访问控制设置。我们将在*第13章*，*Kubernetes中的运行时和网络安全*中重新讨论访问控制和安全性。
- en: 'Let''s take a look at the kubeconfig file to understand how this works. You
    can view the kubeconfig file using the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下kubeconfig文件，以了解它是如何工作的。你可以使用以下命令查看kubeconfig文件：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, you can also use the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用以下命令：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should get an output similar to the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会得到类似以下的输出：
- en: '![Figure 3.2: The output of kubectl config view command'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2：kubectl config view命令的输出'
- en: '](image/B14870_03_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_03_02.jpg)'
- en: 'Figure 3.2: The output of kubectl config view command'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：kubectl config view命令的输出
- en: 'A `context` is a set of information that you need to access a cluster. It contains
    the name of the cluster, the user, and the namespace. The `current-context` field
    in *Figure 3.2* shows the current context that you are working with. If you want
    to switch the current context, you can use the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`context`是访问集群所需的一组信息。 它包含集群的名称、用户和命名空间。 *图3.2*中的`current-context`字段显示您正在使用的当前上下文。
    如果要切换当前上下文，可以使用以下命令：'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For example, if we wanted to switch to a context named `minikube`, we would
    use the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要切换到名为`minikube`的上下文，我们将使用以下命令：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This would give an output similar to the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似以下的输出：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Common kubectl Commands
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常用的kubectl命令
- en: As previously described, kubectl is a CLI tool that is used to communicate with
    the Kubernetes API server. kubectl has a lot of useful commands for working with
    Kubernetes. In this section, we're going to walk you through some commonly used
    kubectl commands and shortcuts that are used to manage Kubernetes objects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，kubectl是一个用于与Kubernetes API服务器通信的CLI工具。 kubectl具有许多有用的命令，用于处理Kubernetes。
    在本节中，我们将为您介绍一些常用的kubectl命令和快捷方式，用于管理Kubernetes对象。
- en: Frequently Used kubectl Commands to Create, Manage, and Delete Kubernetes Objects
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常用的kubectl命令来创建、管理和删除Kubernetes对象
- en: 'There are several simple kubectl commands that you will use almost all the
    time. In this section, we will take a look at some of the basic kubectl commands:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个简单的kubectl命令，您几乎每次都会使用。 在本节中，我们将看一些基本的kubectl命令：
- en: '`get <object>`: You can use this command to get the list of the desired types
    of objects. Using `all` instead of specifying an object type will get the list
    of all kinds of objects. By default, this will get the list of specified object
    types in the default namespace. You can use the `-n` flag to get objects from
    a specific namespace; for example, `kubectl get pod -n mynamespace`.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get <object>`：您可以使用此命令获取所需类型对象的列表。 使用`all`而不是指定对象类型将获取所有类型对象的列表。 默认情况下，这将获取默认命名空间中指定对象类型的列表。
    您可以使用`-n`标志从特定命名空间获取对象；例如，`kubectl get pod -n mynamespace`。'
- en: '`describe <object-type> <object-name>`: You can use this command to check all
    the relevant information of a specific object; for example, `kubectl describe
    pod mypod`.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe <object-type> <object-name>`：您可以使用此命令检查特定对象的所有相关信息；例如，`kubectl describe
    pod mypod`。'
- en: '`logs <object-name>`: You can use this command to check all the relevant logs
    of a specific object to find out what happened when that object was created; for
    example, `kubectl logs mypod`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logs <object-name>`：您可以使用此命令检查特定对象的所有相关日志，以找出创建该对象时发生了什么；例如，`kubectl logs
    mypod`。'
- en: '`edit <object-type> <object-name>`: You can use this command to edit a specific
    object; for example, `kubectl edit pod mypod`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edit <object-type> <object-name>`：您可以使用此命令编辑特定对象；例如，`kubectl edit pod mypod`。'
- en: '`delete <object-type> <object-name>`: You can use this command to delete a
    specific object; for example, `kubectl delete pod mypod`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete <object-type> <object-name>`：您可以使用此命令删除特定对象；例如，`kubectl delete pod
    mypod`。'
- en: '`create <filename.yaml>`: You can use this command to create a bunch of Kubernetes
    objects that have been defined in the YAML manifest file; for example, `kubectl
    create -f your_spec.yaml`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create <filename.yaml>`：您可以使用此命令创建在YAML清单文件中定义的一堆Kubernetes对象；例如，`kubectl
    create -f your_spec.yaml`。'
- en: '`apply <filename.yaml>`: You can use this command to create or update a bunch
    of Kubernetes objects that have been defined in the YAML manifest file; for example,
    `kubectl apply -f your_spec.yaml`.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply <filename.yaml>`：您可以使用此命令创建或更新在YAML清单文件中定义的一堆Kubernetes对象；例如，`kubectl
    apply -f your_spec.yaml`。'
- en: Walkthrough of Some Simple kubectl Commands
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些简单kubectl命令的演示
- en: 'In this section, we''re going to walk you through some of the commonly used
    kubectl commands. This section is mostly for demonstration purposes, so you may
    not see the exact output that you see in these images. However, this section will
    help you understand how these commands are used. You will use most of them extensively
    in later exercises, as well as throughout this book. Let''s take a look:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为您介绍一些常用的kubectl命令。本节主要用于演示目的，因此您可能看不到与这些图像中相同的确切输出。但是，本节将帮助您了解这些命令的使用方式。您将在后面的练习中广泛使用它们，以及在整本书中。让我们来看一下：
- en: 'If you want to display nodes, use the following command:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想显示节点，请使用以下命令：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You will see an output similar to the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似以下的输出：
- en: '![Figure 3.3: The output of kubectl get nodes command'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3：kubectl get nodes命令的输出'
- en: '](image/B14870_03_03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_03_03.jpg)'
- en: 'Figure 3.3: The output of kubectl get nodes command'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：kubectl get nodes命令的输出
- en: 'Since we set up aliases in *Exercise 3.01*, *Setting up Autocompletion*, you
    can also get the same result using the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在*练习3.01*，*设置自动补全*中设置了别名，您也可以使用以下命令获得相同的结果：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you want to display all current namespaces, you can use the following command:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想显示所有当前命名空间，可以使用以下命令：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should see an output similar to the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also get the same result using the following shortened command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用以下缩短命令获得相同的结果：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you want to check the version of `kubectl`, you can use the following command:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想检查`kubectl`的版本，可以使用以下命令：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You will see an output similar to the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似以下的输出：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you want to see some information regarding your current Kubernetes cluster,
    you can use the following command:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想查看有关当前Kubernetes集群的一些信息，可以使用以下命令：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should see an output similar to the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '![Figure 3.4: The output of kubectl cluster-info command'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4：kubectl cluster-info命令的输出'
- en: '](image/B14870_03_04.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_03_04.jpg)'
- en: 'Figure 3.4: The output of kubectl cluster-info command'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：kubectl cluster-info命令的输出
- en: 'Before we move on further with the demonstrations, we will mention a few commands
    that you can use to create a sample application, which we have already provided
    in the GitHub repository for this chapter. Use the following command to fetch
    the YAML specification for all the objects required to run the application:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行演示之前，我们将提到一些命令，您可以使用这些命令创建一个示例应用程序，我们已经在本章的GitHub存储库中提供了。使用以下命令获取运行应用程序所需的所有对象的YAML规范：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, you can deploy the `sample-application.yaml` file using the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用以下命令部署`sample-application.yaml`文件：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you can see the following output, this means that the sample application
    has been successfully created in your Kubernetes cluster:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能看到以下输出，这意味着示例应用程序已成功创建在您的Kubernetes集群中：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that you have deployed the provided application, if you try any of the
    commands shown later in this section, you will see the various objects, events,
    and so on related to this application. Note that your output may not exactly match
    the images shown here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已部署了提供的应用程序，如果您尝试本节后面显示的任何命令，您将看到与该应用程序相关的各种对象、事件等。请注意，您的输出可能与此处显示的图像不完全匹配：
- en: 'You can use the following command to get everything in your cluster under the
    `default` namespace:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令获取`default`命名空间下的集群中的所有内容：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will give an output similar to the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出类似以下的输出：
- en: '![Figure 3.5: The output of kubectl get all command'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5：kubectl get all命令的输出'
- en: '](image/B14870_03_05.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_03_05.jpg)'
- en: 'Figure 3.5: The output of kubectl get all command'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：kubectl get all命令的输出
- en: 'Events describe what has happened so far in the Kubernetes cluster, and you
    can use events to get a better insight into your cluster and aid in any troubleshooting
    efforts. To list all the events in the default namespace, use the following command:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件描述了Kubernetes集群中到目前为止发生的事情，您可以使用事件更好地了解您的集群，并帮助解决任何故障排除工作。要列出默认命名空间中的所有事件，请使用以下命令：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will give an output similar to the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似以下的输出：
- en: '![Figure 3.6: The output of kubectl get events command'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6：kubectl get events命令的输出'
- en: '](image/B14870_03_06.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_03_06.jpg)'
- en: 'Figure 3.6: The output of kubectl get events command'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：kubectl get events命令的输出
- en: 'A service is an abstraction that''s used to expose an application to the end-user.
    You will learn more about services in *Chapter 8*, *Service Discovery*. You can
    use the following command to list all services:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务是用来向最终用户公开应用程序的抽象。您将在*第8章* *Service Discovery*中了解更多关于服务的内容。您可以使用以下命令列出所有服务：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will give an output similar to the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似以下的输出：
- en: '![Figure 3.7: The output of kubectl get services command'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7：kubectl get services命令的输出'
- en: '](image/B14870_03_07.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_03_07.jpg)'
- en: 'Figure 3.7: The output of kubectl get services command'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：kubectl get services命令的输出
- en: 'You can get the same result using the following shortened command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用以下缩写命令获得相同的结果：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A Deployment is an API object that allows us to easily manage and update pods.
    You will learn more about Deployments in *Chapter 7*, *Kubernetes Controllers*.
    You can get the list of Deployments using the following command:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署是一个允许我们轻松管理和更新pod的API对象。您将在*第7章* *Kubernetes Controllers*中了解更多关于部署的内容。您可以使用以下命令获取部署列表：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This should give a response similar to the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生类似以下的响应：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can also get the same result using the following shortened version of the command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用以下缩写版本的命令获得相同的结果：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Some Useful Flags for the get Command
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`get`命令的一些有用标志'
- en: 'As you have seen, the `get` command is a pretty standard command that is used
    when we need to get the list of objects in our cluster. It also has several useful
    flags. Let''s take a look at a few of them here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，`get`命令是一个非常标准的命令，用于在我们需要获取集群中对象列表时使用。它还有一些有用的标志。让我们在这里看一些：
- en: 'If you want to list a particular type of resource from all your namespaces,
    you can add the `--all-namespaces` flag in the command. For example, if we want
    to list all Deployments from all namespaces, we can use the following command:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想要列出所有命名空间中特定类型的资源，您可以在命令中添加`--all-namespaces`标志。例如，如果我们想要列出所有命名空间中的所有部署，我们可以使用以下命令：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will give an output similar to this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似这样的输出：
- en: '![Figure 3.8: The output of kubectl get deployments under all namespaces'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8：在所有命名空间下kubectl get deployments的输出'
- en: '](image/B14870_03_08.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_03_08.jpg)'
- en: 'Figure 3.8: The output of kubectl get deployments under all namespaces'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：在所有命名空间下kubectl get deployments的输出
- en: You can also see that there is an additional column on the left-hand side that
    specifies the namespaces of the respective Deployments.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到左侧有一个额外的列，指定了相应部署的命名空间。
- en: 'If you want to list a specific type of resource from a specific namespace,
    you can use the `-n` flag. Here, the `-n` flag stands for `namespace`. For example,
    if you want to list all Deployments in a namespace called `keda`, the following
    command would be used:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想要列出特定命名空间中特定类型的资源，您可以使用`-n`标志。在这里，`-n`标志代表`命名空间`。例如，如果您想要列出名为`keda`的命名空间中的所有部署，将使用以下命令：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This command would show an output similar to the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会显示类似以下的输出：
- en: '![Figure 3.9: The output of kubectl get deployments under the keda namespace'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9：在keda命名空间下kubectl get deployments的输出'
- en: '](image/B14870_03_09.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_03_09.jpg)'
- en: 'Figure 3.9: The output of kubectl get deployments under the keda namespace'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：在keda命名空间下使用kubectl get deployments的输出
- en: 'You can add the `--show-labels` flag to display the labels of the objects in
    the list. For example, if you wanted to get the list of all the pods in the `default`
    namespace, along with their labels, you would use the following command:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以添加`--show-labels`标志来显示列表中对象的标签。例如，如果您想要获取`default`命名空间中所有Pod的列表，以及它们的标签，您可以使用以下命令：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This command should give an output similar to the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应该会产生类似以下的输出：
- en: '![Figure 3.10: The output of kubectl get pods with all labels'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10：使用所有标签获取kubectl get pods的输出'
- en: '](image/B14870_03_10.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_03_10.jpg)'
- en: 'Figure 3.10: The output of kubectl get pods with all labels'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10：使用所有标签获取kubectl get pods的输出
- en: There is an additional column on the right-hand side that specifies the labels
    of the pods.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧有一个额外的列，指定了Pod的标签。
- en: 'You can use the `-o wide` flag to display more information about objects. Here,
    the `-o` flag stands for `output`. Let''s look at a simple example of how to use
    this flag:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`-o wide`标志来显示有关对象的更多信息。这里，`-o`标志代表`输出`。让我们看一个如何使用这个标志的简单例子：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will give an output similar to the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似以下的输出：
- en: '![Figure 3.11: The output of kubectl get pods with additional information'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11：使用附加信息获取kubectl get pods的输出'
- en: '](image/B14870_03_11.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_03_11.jpg)'
- en: 'Figure 3.11: The output of kubectl get pods with additional information'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：使用附加信息获取kubectl get pods的输出
- en: You can also see there are additional columns on the right-hand side that specify
    which nodes the pods are running on, as well as the internal IP addresses of the
    node. You can find more ways to use the `-o` flag at [https://kubernetes.io/docs/reference/kubectl/overview/#output-options](https://kubernetes.io/docs/reference/kubectl/overview/#output-options).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到右侧有额外的列，指定了Pod所在的节点，以及节点的内部IP地址。您可以在[https://kubernetes.io/docs/reference/kubectl/overview/#output-options](https://kubernetes.io/docs/reference/kubectl/overview/#output-options)找到更多使用`-o`标志的方法。
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will limit this section to commands that are commonly used to limit the scope
    of this chapter. You can find a lot more kubectl commands at [https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将限制本节中常用的命令，以限制本章的范围。您可以在[https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands)找到更多kubectl命令。
- en: Populating Deployments in Kubernetes
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes中填充部署
- en: As we mentioned earlier, Deployment is a convenient way to manage and update
    pods. Defining a Deployment in Kubernetes is an effective and efficient way to
    provide declarative updates for the application running in your cluster.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，部署是管理和更新Pod的便捷方式。在Kubernetes中定义部署是为集群中运行的应用程序提供声明性更新的有效和高效方式。
- en: You can create a Deployment by using kubectl imperative commands or by using
    declarative YAML manifest files. In the following exercise, we're going to deploy
    an application (we will go with Nginx for this exercise) in Kubernetes and learn
    how to interact with Deployments using kubectl commands, as well as how to modify
    the YAML manifest file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用kubectl命令来创建部署，也可以使用声明性的YAML清单文件。在接下来的练习中，我们将在Kubernetes中部署一个应用程序（本练习将使用Nginx），并学习如何使用kubectl命令与部署进行交互，以及如何修改YAML清单文件。
- en: 'Exercise 3.02: Creating a Deployment'
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.02：创建部署
- en: 'There are two ways to create a Deployment in Kubernetes – using the `kubectl
    create`/`run` command and creating a manifest file in YAML format and then using
    the `kubectl apply` command. We can achieve the same goal with those two options.
    Let''s try both and then compare them:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中创建部署有两种方式 - 使用`kubectl create`/`run`命令和创建一个YAML格式的清单文件，然后使用`kubectl
    apply`命令。我们可以用这两种选项实现相同的目标。让我们尝试一下，然后进行比较：
- en: 'Create a Deployment using the following command directly:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接使用以下命令创建一个部署：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can expect an output similar to the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以期待类似以下的输出：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can also create a Deployment using the `kubectl run` command. To achieve
    the same results here, you could use the following commands:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用`kubectl run`命令创建一个部署。为了在这里实现相同的结果，您可以使用以下命令：
- en: '`kubectl run nginx --image=nginx:1.7.8`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl run nginx --image=nginx:1.7.8`'
- en: '`kubectl run nginx --image=nginx:1.7.8 --replicas=3`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl run nginx --image=nginx:1.7.8 --replicas=3`'
- en: 'You can also create a Deployment by defining the YAML manifest file for your
    Deployment. Use your preferred text editor to create a file named `sample-deployment.yaml`
    with the following content:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以通过定义部署的YAML清单文件来创建一个部署。使用您喜欢的文本编辑器创建一个名为`sample-deployment.yaml`的文件，内容如下：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this YAML definition, the `replicas` field defines the number of replica
    pods in this Deployment.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个YAML定义中，`replicas`字段定义了部署中副本pod的数量。
- en: 'Use the following command to apply the configuration you''ve defined in the
    YAML manifest file:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令应用您在YAML清单文件中定义的配置：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The sample output will look as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 示例输出将如下所示：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Use the following command to check the Deployments that currently exist in
    the `default` namespace:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查当前存在于`default`命名空间中的部署：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output will look as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this exercise, we have seen the differences in using the different approaches
    to create a Deployment. The `kubectl create` command is widely used for testing.
    For most enterprise solutions where modern DevOps approaches are implemented,
    it makes more sense to use YAML definitions to conveniently define configurations,
    and then track them with source control tools such as Git. When your organization
    integrates YAML definitions with DevOps tools, it makes the solution more manageable
    and traceable.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们已经看到了使用不同方法创建部署的差异。`kubectl create`命令被广泛用于测试。对于大多数实施现代DevOps方法的企业解决方案，使用YAML定义来方便地定义配置，并使用Git等源代码控制工具进行跟踪，更有意义。当您的组织将YAML定义与DevOps工具集成时，可以使解决方案更易管理和可追踪。
- en: Now that we have seen how to create a Deployment, in the next exercise, we will
    learn how to modify or update a Deployment that is already running. This is something
    that you will need to do quite often as the software is updated to new versions,
    bugs are identified and fixed, the demands on your application change, or your
    organization moves on to completely new solutions. We will also learn how to roll
    back a Deployment to an earlier version, which is something that you will want
    to do if an update does not lead to the expected outcome.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何创建一个部署，在下一个练习中，我们将学习如何修改或更新已经运行的部署。这是您经常需要做的事情，因为软件被更新到新版本，bug被识别和修复，您的应用程序的需求发生变化，或者您的组织转移到完全新的解决方案。我们还将学习如何将部署回滚到较早的版本，如果更新没有达到预期的结果，这是您想要做的事情。
- en: 'Exercise 3.03: Updating a Deployment'
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.03：更新部署
- en: In this exercise, we will update the application that we deployed in the previous
    exercise to a more recent version and demonstrate how we can roll back the Deployment
    to a previous version if necessary.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将更新在上一个练习中部署的应用程序到一个更近期的版本，并演示如果有必要，我们如何回滚部署到先前的版本。
- en: 'Similar to the two approaches that we saw for creating a Deployment, there
    are two ways to update an application as well – using the `kubectl set image`
    command and updating the YAML manifest file and then using the `kubectl apply`
    command. These steps will guide you through both approaches:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在创建部署时看到的两种方法类似，更新应用程序也有两种方式——使用`kubectl set image`命令和更新YAML清单文件，然后使用`kubectl
    apply`命令。以下步骤将指导您完成这两种方法：
- en: 'First, let''s get the details of the current Deployment using the following command:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下命令获取当前部署的详细信息：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You''ll get an output similar to the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似以下的输出：
- en: '![Figure 3.12: Describing the kubeserve Deployment'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12：描述kubeserve部署'
- en: '](image/B14870_03_12.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_03_12.jpg)'
- en: 'Figure 3.12: Describing the kubeserve Deployment'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12：描述kubeserve部署
- en: 'You can update the image using the following command:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用以下命令更新图像：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `image` subcommand indicates that we want to update the `image` field of
    the object, as defined in the YAML manifest that we saw in *Step 2* of the previous exercise.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`image`子命令表示我们要更新对象的`image`字段，如我们在上一个练习的*步骤2*中所见的YAML清单中定义的那样。'
- en: Then, we specify the object in the `<object-type>/<object name>` format.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们以`<object-type>/<object name>`格式指定对象。
- en: The next part, `nginx=nginx:1.9.1`, tells Kubernetes to look for the specific
    image tagged as `1.9.1` in the Docker Hub repository of NGINX. You can check out
    the available tags at [https://hub.docker.com/_/nginx?tab=tags](https://hub.docker.com/_/nginx?tab=tags).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分，`nginx=nginx:1.9.1`，告诉Kubernetes在NGINX的Docker Hub存储库中查找特定标记为`1.9.1`的图像。您可以在[https://hub.docker.com/_/nginx?tab=tags](https://hub.docker.com/_/nginx?tab=tags)上查看可用的标记。
- en: The `--record` flag is very helpful when you want to save the updates that have
    been made by your `kubectl` commands to the current resource.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`--record`标志在您想要保存`kubectl`命令对当前资源所做的更新时非常有用。'
- en: 'By applying this, you''ll get an output similar to the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用此命令，您将看到类似以下的输出：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let''s get the details of the Deployment using the following command:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令获取部署的详细信息：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should see the following output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 3.13: Using the kubectl describe command to check the'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13：使用kubectl describe命令检查'
- en: image version in the container
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 容器中的图像版本
- en: '](image/B14870_03_13.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_03_13.jpg)'
- en: 'Figure 3.13: Using the kubectl describe command to check the image version
    in the container'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13：使用kubectl describe命令检查容器中的图像版本
- en: In the preceding screenshot, you can see that the image has been successfully
    updated to version `1.9.1`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，您可以看到图像已成功更新为版本`1.9.1`。
- en: 'Another way to achieve the same result is to modify the YAML file and then
    use the `kubectl apply` command. We will use the same YAML file that we created
    in the previous exercise. If you do not have the YAML file for an object, you
    can export the YAML manifest using the following command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相同结果的另一种方法是修改YAML文件，然后使用`kubectl apply`命令。我们将使用在上一个练习中创建的相同YAML文件。如果您没有对象的YAML文件，可以使用以下命令导出YAML清单：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This command will output a file named `kubeserve-spec.yaml` with the manifest
    that is in effect in the cluster. Then, you can use vim, nano, or any other text
    editor to edit it and then apply the edited `kubeserve-spec.yaml` manifest using
    the `kubectl apply` command, as shown in the previous exercise, with the addition
    of the `--record` flag.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将输出一个名为`kubeserve-spec.yaml`的文件，其中包含在集群中生效的清单。然后，您可以使用vim、nano或任何其他文本编辑器对其进行编辑，然后使用`kubectl
    apply`命令应用编辑后的`kubeserve-spec.yaml`清单，如前一个练习中所示，还需添加`--record`标志。
- en: 'If you want to perform a rollback, you can use the following command:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要执行回滚操作，可以使用以下命令：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You''ll see an output similar to the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似以下的输出：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can use the `kubectl rollout history` command to check all the revisions
    for a specific Deployment, as shown here:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`kubectl rollout history`命令来检查特定部署的所有修订版本，如下所示：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You''ll see an output similar to the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似以下的输出：
- en: '![Figure 3.14: The output of the kubectl rollout history command'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.14：kubectl rollout history命令的输出'
- en: '](image/B14870_03_14.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_03_14.jpg)'
- en: 'Figure 3.14: The output of the kubectl rollout history command'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14：kubectl rollout history命令的输出
- en: 'You can also use the following command to check the details of a specific revision:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以使用以下命令来检查特定修订的详细信息：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output for this command will be as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出将如下所示：
- en: '![Figure 3.15: Checking the details of revision 3'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.15：检查修订版本3的详细信息'
- en: '](image/B14870_03_15.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_03_15.jpg)'
- en: 'Figure 3.15: Checking the details of revision 3'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15：检查修订版本3的详细信息
- en: 'You can roll back a Deployment to a specific revision by specifying the `--to-revision`
    flag:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过指定`--to-revision`标志将部署回滚到特定修订版本：
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You''ll see an output similar to the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似以下的输出：
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this exercise, we have learned how to update an already existing Deployment,
    as well as how to roll back a Deployment to its earlier specs.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何更新已经存在的部署，以及如何将部署回滚到先前的规范。
- en: Deployments allow us to define a desired state for the replica pod in a declarative
    way. We will revisit how Deployment works and discover more about it in *Chapter
    7*, *Kubernetes Controllers*. If you delete the individual pod replica intentionally
    or if the pod fails for any reason, since we define a Deployment with a set number
    of replicas, the Deployment will keep recreating the pod as many times as you
    delete it. This is what we call *auto-healing*. Therefore, you need to delete
    the Deployment itself, which will also delete all the pods managed by it. We will
    learn how to do that in the following exercise.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 部署允许我们以声明性的方式定义副本Pod的期望状态。我们将重新访问部署的工作原理，并在*第7章*，*Kubernetes Controllers*中发现更多关于它的信息。如果您有意删除单个Pod副本，或者如果Pod由于任何原因失败，由于我们定义了具有一定数量副本的部署，部署将会不断重新创建Pod，直到您删除它为止。这就是我们所说的*自动修复*。因此，您需要删除部署本身，这也将删除由其管理的所有Pod。我们将在接下来的练习中学习如何做到这一点。
- en: 'Exercise 3.04: Deleting a Deployment'
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.04：删除部署
- en: 'In this exercise, we will delete the Deployment we created in the previous
    exercise:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将删除在上一个练习中创建的部署：
- en: 'Get a list of existing Deployments using the following command:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令获取现有部署的列表：
- en: '[PRE51]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can expect an output similar to the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以期望看到类似以下的输出：
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s say that, for the purpose of this exercise, we want to delete the `kubeserve`
    Deployment that we created in the previous exercise. Use the following command
    to delete the Deployment:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设，为了这个练习的目的，我们想要删除在上一个练习中创建的`kubeserve`部署。使用以下命令来删除部署：
- en: '[PRE53]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The sample output will be similar to the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 示例输出将类似于以下内容：
- en: '[PRE54]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Get the list of Deployments to check and make sure that the target Deployment
    has been deleted successfully:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取部署列表以检查并确保目标部署已成功删除：
- en: '[PRE55]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You should see an output similar to the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You can use the `kubectl delete` command to delete any other object as well.
    However, as we mentioned earlier, in cases such as pods managed by Deployments,
    it is pointless to delete individual pods as the Deployment will just recreate
    them, so you need to delete the Deployment.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`kubectl delete`命令来删除任何其他对象。但是，正如我们之前提到的，在诸如由部署管理的Pod的情况下，删除单个Pod是没有意义的，因为部署将会重新创建它们，所以您需要删除部署。
- en: 'Activity 3.01: Editing a Live Deployment for a Real-Life Application'
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动3.01：编辑实时部署以进行真实应用程序
- en: Imagine that you are a SysOps engineer who has been asked to manage a cluster
    and deploy a web application. You have deployed it to your Kubernetes cluster
    and made it available to the public. You have been monitoring this application
    ever since it was deployed successfully, and you've detected that the web application
    has been experiencing throttling issues during peak times. Based on your monitoring,
    the solution that you want to implement is to assign more memory and CPU to this
    application. Therefore, you need to edit the Deployment so that you can allocate
    enough CPU and memory resources to run the application and test this application
    at the end. You need to demonstrate that your web application is up and running
    and that it can be accessed through a public IP address via a browser of your
    choice.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您是一名SysOps工程师，被要求管理一个集群并部署一个Web应用程序。您已经将其部署到您的Kubernetes集群，并使其对公众可用。自从成功部署以来，您一直在监视这个应用程序，并且您已经发现在高峰时段，Web应用程序遇到了限流问题。根据您的监控，您想要实施的解决方案是为这个应用程序分配更多的内存和CPU。因此，您需要编辑部署，以便为应用程序分配足够的CPU和内存资源来运行应用程序并在最后测试这个应用程序。您需要证明您的Web应用程序正在运行，并且可以通过您选择的浏览器通过公共IP地址访问。
- en: To simulate this scenario, we're going to deploy a sample application in a Kubernetes
    cluster and show you how to edit a live Deployment. Editing a live Deployment
    is something that you will need to do when fixing issues or for testing purposes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟这种情况，我们将在Kubernetes集群中部署一个示例应用程序，并向您展示如何编辑实时部署。编辑实时部署是您在修复问题或进行测试时需要做的事情。
- en: 'You can use the following command to get the YAML manifest file that you''re
    going to use in this activity:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令获取您将在此活动中使用的YAML清单文件：
- en: '[PRE57]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This manifest file defines all the different objects that are required to run
    the application, as well as the application itself.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此清单文件定义了运行应用程序所需的所有不同对象，以及应用程序本身。
- en: Note
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This manifest has been adapted from an open-source sample provided by Microsoft
    Azure, available at [https://github.com/Azure-Samples/azure-voting-app-redis](https://github.com/Azure-Samples/azure-voting-app-redis).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此清单已经改编自Microsoft Azure提供的开源示例，可在[https://github.com/Azure-Samples/azure-voting-app-redis](https://github.com/Azure-Samples/azure-voting-app-redis)上找到。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动：
- en: First, deploy the target web application using the `kubectl apply` command and
    the provided YAML definition file.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用`kubectl apply`命令和提供的YAML定义文件部署目标Web应用程序。
- en: Get the IP address of the service that exposes your application. For this simple
    scenario, this will be similar to *Exercise 2.03, Accessing a Pod via a Service*,
    from the previous chapter. Later chapters will explain how to work with ingress
    controllers and create ingress resources to expose the frontend applications.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取暴露您的应用程序的服务的IP地址。对于这种简单的情况，这将类似于*练习2.03，通过服务访问Pod*，来自上一章。后面的章节将解释如何使用入口控制器并创建入口资源来暴露前端应用程序。
- en: 'Use the `kubectl edit` command to edit the live deployment. You will need to
    edit the deployment named `melonvote-front`. The following are the fields that
    you need to modify to satisfy the requirements of this scenario. You can simply
    double these values:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl edit`命令编辑实时部署。您需要编辑名为`melonvote-front`的部署。以下是您需要修改以满足此场景要求的字段。您可以简单地将这些值加倍：
- en: 'a) `resources.limits.cpu`: This is the resource limit for CPU usage.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: a) `resources.limits.cpu`：这是CPU使用的资源限制。
- en: 'b) `resources.limits.memory`: This is the resource limit for memory usage.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: b) `resources.limits.memory`：这是内存使用的资源限制。
- en: 'c) `resources.requests.cpu`: This is the minimum CPU usage requested to get
    your application up and running.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 'c) `resources.requests.cpu`: 这是请求的最小CPU使用量，用于启动和运行您的应用程序。'
- en: 'd) `resources.requests.memory`: This is the minimum memory usage requested
    to get your application up and running.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'd) `resources.requests.memory`: 这是请求的最小内存使用量，用于启动和运行您的应用程序。'
- en: 'By the end of this activity, you will be able to see the UI of the application
    that you deployed with Kubernetes:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本活动结束时，您将能够看到您使用Kubernetes部署的应用程序的用户界面：
- en: '![Figure 3.16: Expected output of the activity'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.16：活动的预期输出'
- en: '](image/B14870_03_16.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14870_03_16.jpg)'
- en: 'Figure 3.16: Expected output of the activity'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16：活动的预期输出
- en: Note
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下地址找到：[https://packt.live/304PEoD](https://packt.live/304PEoD)。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter demystified how kubectl allows us to control our Kubernetes cluster
    using API calls. First, we learned how to set up an environment for kubectl commands
    and looked at a number of shortcuts. Furthermore, we covered how to create, edit,
    and delete a Kubernetes object using kubectl commands and looked at a Deployment
    as an example. Finally, we deployed a real-life application and showed you how
    to edit a live Deployment. Every example in this chapter has been applied in a
    general context; however, we believe that the skills developed in this chapter
    can help you resolve specific problems that you might encounter in a professional
    environment.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 本章揭开了kubectl如何允许我们使用API调用来控制Kubernetes集群的神秘面纱。首先，我们学习了如何为kubectl命令设置环境，并查看了一些快捷方式。此外，我们介绍了如何使用kubectl命令创建、编辑和删除Kubernetes对象，并以Deployment为例进行了介绍。最后，我们部署了一个真实的应用程序，并向您展示了如何编辑一个实时的Deployment。本章中的每个示例都是在一般情境下应用的；然而，我们相信本章中培养的技能可以帮助您解决在专业环境中可能遇到的特定问题。
- en: In the next chapter, you'll explore the other side of this bridge and dive deeper
    into how the API server works. You will also take a closer look at REST API requests
    and how the API server deals with them.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将探索这座桥的另一侧，并深入了解API服务器的工作原理。您还将更仔细地研究REST API请求以及API服务器如何处理它们。
