- en: Integration Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: So far, we have reviewed how to run your code and describe your services in
    Kubernetes. We also looked into how to utilize additional tools to get information
    about how your code is running on each pod and on aggregate. This chapter builds
    on this to look at how to use Kubernetes to validate your code, with examples
    of different ways to accomplish that testing, and suggestions for how to leverage
    Kubernetes for validation testing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了如何在Kubernetes中运行代码并描述服务。我们还研究了如何利用其他工具来获取有关代码在每个pod和整体上运行情况的信息。本章将在此基础上，探讨如何使用Kubernetes来验证代码，以及不同验证测试的示例，以及如何利用Kubernetes进行验证测试的建议。
- en: 'Topics for this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题包括：
- en: Testing strategies using Kubernetes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes的测试策略
- en: Simple validation with Bats
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bats进行简单验证
- en: Example – testing code with Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例 - 使用Python测试代码
- en: Example – testing code with Node.js
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例 - 使用Node.js测试代码
- en: Continuous integration with Kubernetes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes进行持续集成
- en: Testing strategies using Kubernetes
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes的测试策略
- en: 'There is a wide variety of kinds of tests that are used during development
    and validation, in software engineering. Across this taxonomy, there are some
    kinds of tests that utilize the strengths of Kubernetes extremely well. The terms
    associated with testing can be vague and confusing, so for clarity, we will briefly
    review the terms I''ll use and the differences between these kinds of tests. There
    are many more variants of these themes that I haven''t detailed here, but for
    the purpose of describing where Kubernetes is most effective, this list is sufficient:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，开发和验证过程中使用了各种测试。在这个分类中，有一些测试类型非常适合利用Kubernetes的优势。与测试相关的术语可能含糊不清，令人困惑，因此为了清晰起见，我们将简要回顾我将使用的术语以及这些测试类型之间的区别。这里没有详细介绍这些主题的更多变体，但为了描述Kubernetes最有效的地方，这个列表已经足够：
- en: '**Unit tests**: Unit tests are the *lowest level* of testing; this focuses
    on the interfaces, implementations, and modules within your application. Unit
    testing frequently implies isolated testing of just the component that the test
    focuses on. These tests are generally intended to be very fast, easily run on
    a developer''s system directly, and often with no access to external services
    upon which the relevant code may depend. These tests often do not deal with state
    or persistence, and primarily focus on business logic and interface validation.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试：单元测试是测试的最低级别；它侧重于应用程序中的接口、实现和模块。单元测试通常意味着仅对测试重点的组件进行隔离测试。这些测试通常旨在非常快速，可以直接在开发人员的系统上运行，并且通常不需要访问相关代码可能依赖的外部服务。这些测试通常不涉及状态或持久性，主要关注业务逻辑和接口验证。
- en: '**Functional tests**: Functional tests are the next step up from unit tests,
    implying that code the libraries are used against their underlying systems without
    fakes, mocks, or other layers that would otherwise pretend to act like the remote
    dependencies. These kinds of tests are usually applied to a subset of a service,
    testing and validating a full service, and using immediate dependencies (often
    a database or persistence store). Functional tests often imply a validation of
    state in persistence stores, and how that changes with the operation of your code.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试：功能测试是从单元测试中提升的下一步，意味着代码库针对其基础系统进行测试，而无需伪装、模拟或其他层，否则会假装像远程依赖一样运行。这种测试通常应用于服务的子集，测试和验证完整的服务，并使用即时依赖项（通常是数据库或持久性存储）。功能测试通常意味着对持久性存储中的状态进行验证，以及在代码运行过程中如何改变。
- en: '**Integration tests**: Integration tests assemble all the required parts of
    your software together and validate the individual components as well as the components,
    working together and their interactions. The state of the system is often defined
    or set as a key setup in integration tests, and because state is represented and
    validated within the system, tests have a tendency to be ordered and more linear,
    often using composed interactions to validate the code and how it works (and how
    it fails).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：集成测试将软件的所有必需部分组合在一起，并验证各个组件以及组件之间的工作和交互。系统的状态通常在集成测试中被定义或设置为关键设置，因为状态在系统中被表示和验证，所以测试往往是有序和更线性的，通常使用组合交互来验证代码的工作方式（以及失败方式）。'
- en: There is a blurry line between functional tests and integration tests, with
    the former typically being focused on a subset of your overall service being validated,
    and the latter representing either large portions or your service or the whole
    system at once.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试和集成测试之间存在模糊的界限，前者通常专注于验证整体服务的子集，而后者代表着服务的大部分或整个系统。
- en: '**End-to-end tests**: Where integration tests can mean testing a portion of
    a system, end-to-end tests are specific to meaning testing and validating the
    whole of a system and all its dependencies. Frequently, end-to-end tests and integration
    tests are used synonymously.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端到端测试**：集成测试可能意味着测试系统的一部分，而端到端测试则特指测试和验证整个系统及其所有依赖关系。通常，端到端测试和集成测试是可以互换使用的。'
- en: '**Performance tests**: Where the previous terms focused on the scope of validation
    between code and any underlying dependencies it interacts with, performance tests
    focus on the type of validation more than the scope. These tests intend to measure
    the efficiency or utilization of code and services; how much CPU and memory they
    utilize, and how fast they respond with a given set of underlying resources. Rather
    than focusing on the correctness of code, they focus on validation of scale and
    underlying service needs. Performance tests frequently require dependent systems
    to be not only operational, but fully resourced to provide accurate results, and
    run with some measure of expectation isolation so that external resource constraints
    don''t artificially limit the results.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能测试**：在先前的术语中，重点是代码和任何相关依赖项之间的验证范围，性能测试侧重于验证类型而不是范围。这些测试意在衡量代码和服务的效率或利用率；它们利用了多少CPU和内存，以及在给定一组基础资源的情况下它们的响应速度。它们不是专注于代码的正确性，而是专注于规模和基础服务需求的验证。性能测试通常需要依赖系统不仅正常运行，而且需要充分资源以提供准确的结果，并且在某种程度上具有期望隔离，以防止外部资源限制人为地限制结果。'
- en: '**Interactive/exploratory tests**: Interactive tests, sometimes also known
    as exploratory tests, are again not so much a term about scope as much as implying
    an intent. These kinds of tests typically require at least a portion of the system
    operational, and often imply the whole system is operational if not scaled to
    support high levels of requests. These tests focus on letting people interact
    with the system without any predefined or structured stream of events, and this
    same setup is often used for acceptance validation or refinement of other kinds
    of tests as a means of validating the tests themselves.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互/探索性测试**：交互测试，有时也被称为探索性测试，再次不是关于范围的术语，而是意味着一种意图。这些测试通常需要系统的至少一部分处于运行状态，并且通常意味着整个系统处于运行状态，如果不是为了支持高水平的请求。这些测试侧重于让人们与系统进行交互，而不需要预定义或结构化的事件流，这种设置通常也用于接受验证或其他测试类型的改进，作为验证测试本身的手段。'
- en: Reviewing resources needed for testing
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查测试所需的资源
- en: As we walk through this taxonomy of tests, the compute resources and time needed
    to run the tests typically grow and become more significant. Depending on the
    scope of the software being developed, it is quite possible to require more resources
    than can be accommodated in a single machine. And where lower-level tests can
    often be optimized to leverage all possible resources within a computer, the serialized
    nature of end-to-end tests tends to be less efficient and more time consuming
    in the validation process.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历测试的分类时，运行测试所需的计算资源和时间通常会增长并变得更加重要。根据正在开发的软件的范围，很可能需要比单台机器可以容纳的资源更多。而低级别的测试通常可以优化以利用计算机内的所有可能资源，端到端测试的串行性质往往效率较低，并且在验证过程中需要更多时间。
- en: As you establish your tests, you need to be aware of the size of the compute
    resources that are needed to validate your software. This can correspond to the
    process of determining how much memory and CPU a given pod needs, and extends
    to needing to be aware of all the resources for all the dependencies based on
    what you are testing and wanting to achieve.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立测试时，您需要意识到验证软件所需的计算资源的大小。这可能对应于确定给定pod需要多少内存和CPU的过程，并且需要意识到基于您正在测试和想要实现的内容，所有依赖项的所有资源。
- en: Where we have been using Minikube for most of these examples, modern development
    and dependencies can easily exceed the amount of resources you can give to Minikube
    for its single-node cluster.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数示例中，我们一直在使用Minikube，但是现代开发和依赖关系很容易超出Minikube单节点集群所能提供的资源量。
- en: Using Kubernetes in your testing is most effective where you want to set up
    and use large portions of your environment that correspond to integration testing
    and testing scenarios that expect a complete system with all dependencies operational.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中使用Kubernetes最有效的地方是，您希望设置和使用与集成测试和测试场景相对应的环境的大部分内容，并且期望具有所有依赖项运行的完整系统。
- en: You can, of course, use Kubernetes in the process of development where you run
    tests such as unit tests, or perhaps functional tests, within Kubernetes, although
    you may find far more benefit from leveraging Kubernetes when you are focusing
    more at integration, end-to-end, and those later portions of the taxonomy outlined
    previously.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当您专注于集成、端到端以及先前概述的分类的后续部分时，您当然可以在开发过程中使用Kubernetes运行诸如单元测试或功能测试之类的测试，尽管您可能会发现，在集成、端到端以及先前概述的分类的后续部分时，从Kubernetes中获得更多的好处。
- en: Because Kubernetes excels at describing a desired state for services and keeping
    them running, it can be very effectively used where you want to set up large portions
    or many services interacting together. Additionally, where you expect tests to
    take more time and resources, Kubernetes is a good fit, as it requires you to
    lock down the code into discrete, versioned containers, which can also take significant
    time and processing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Kubernetes擅长描述服务的期望状态并保持其运行，因此在您希望设置大部分或许多服务相互交互的地方，它可以被非常有效地使用。此外，如果您期望测试需要更多时间和资源，Kubernetes也是一个很好的选择，因为它要求您将代码锁定到离散的、有版本的容器中，这也可能需要大量的时间和处理。
- en: Patterns of using Kubernetes with testing
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes进行测试的模式
- en: There are quite a number of ways to use Kubernetes for testing, and one of the
    first things you need to determine is where you're running the system being tested,
    and where you are running the tests that will validate that system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多种方式可以使用Kubernetes进行测试，而您需要确定的第一件事情之一是，您正在运行被测试系统的位置，以及您正在运行将验证该系统的测试的位置。
- en: Tests local and system-under-test in Kubernetes
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes中测试本地和系统测试
- en: The most common pattern, especially while developing tests, is to run tests
    from your development machine against your code running within Kubernetes. After
    you create the tests, the same pattern can be employed to run your tests against
    a Kubernetes cluster housing your code from a continuous integration service.
    When you are starting out with development, you may be able to run all of this
    on your local development machine, with Minikube. In general, this pattern is
    an excellent way to get started, and solves the problem of getting feedback from
    the tests by running the tests where you want to get the feedback—either on your
    own development system, or from a CI system acting on your behalf.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的模式，特别是在开发测试时，是从开发机器上运行测试，针对在Kubernetes中运行的代码。创建测试后，可以使用相同的模式来针对托管代码的Kubernetes集群运行测试，从而实现持续集成服务。当您开始进行开发时，您可能能够在本地开发机器上运行所有这些操作，使用Minikube。总的来说，这种模式是一个很好的开始方式，并解决了通过在您想要获得反馈的地方运行测试来获得反馈的问题——无论是在您自己的开发系统上，还是在代表您运行的CI系统上。
- en: Tests local and system-under-test in Kubernetes namespaces
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在之前的模式中，以及本书中大多数示例中，我们使用了默认命名空间，但所有命令都可以通过简单地在kubectl命令中添加`-n <namespace>`来包括一个命名空间作为选项。
- en: If, or perhaps when, the system you are testing exceeds what Minikube can support,
    the common solution is to start using a remote cluster, either managed by you,
    your IT team, or a cloud provider. As you start to use remote compute to do this,
    sharing and isolation become important, particularly with tests that are dependent
    on the state of the system, where the control of that state is critical to understanding
    if the validation is correct or not. Kubernetes has good isolation in general,
    and taking advantage of how namespaces work can make the setup of your code and
    testing it significantly easier. You can leverage namespaces by running the related
    pods and services all in a single namespace, and consistently referencing between
    them by taking advantage of the short DNS names for each service. This can be
    visualized as a stack, where you can deploy many of these effectively in parallel. In
    the earlier pattern, and in most of the examples in this book, we have used the
    default namespace, but all of the commands can include a namespace as an option
    by simply adding on `-n <namespace>` to the kubectl commands.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您测试的系统超出了Minikube的支持范围，常见的解决方案是开始使用远程集群，无论是由您、您的IT团队还是云提供商管理。当您开始使用远程计算时，共享和隔离变得重要，特别是对于依赖于系统状态的测试，其中对该状态的控制对于理解验证是否正确非常关键。Kubernetes通常具有良好的隔离性，并且利用命名空间的工作方式可以使代码的设置和测试变得更加容易。您可以通过在单个命名空间中运行相关的pod和服务，并通过利用每个服务的短DNS名称在它们之间进行一致引用来利用命名空间。这可以被视为一个堆栈，您可以有效地并行部署许多这样的堆栈。
- en: Namespaces support quotas for a variety of resources, and you will want to see
    what is defined and validate that you have sufficient allowances set up. Especially
    in shared environments, using Quota to put a cap on consumption is common.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间支持各种资源的配额，您会想要查看定义的内容并验证您是否设置了足够的配额。特别是在共享环境中，使用配额来限制消耗是常见的。
- en: Tests in Kubernetes and system-under-test in Kubernetes namespaces
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes中的测试和Kubernetes命名空间中的系统
- en: A variation of the theme is to also package and run your tests within Kubernetes—either
    in the same namespace, or in a separate namespace from your system under test.
    This is slower than running the tests locally, as it requires you to package your
    tests into a container, just as you do with your code. The trade-off is having
    a very consistent means of running those tests and interacting with the system-under-test.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 主题的一个变化是在Kubernetes中打包和运行您的测试 - 无论是在相同的命名空间中，还是在与您的被测系统不同的命名空间中。这比在本地运行测试要慢，因为它要求您将测试打包到容器中，就像您对代码所做的那样。权衡是拥有非常一致的方式来运行这些测试并与被测系统进行交互。
- en: If you work in a very diverse development environment where everyone has a slightly
    different setup, then this pattern can consolidate the testing so that everyone
    has the same experience. Additionally, where local tests need to access the remote
    Kubernetes through exposed services (such as NodePort using Minikube, or perhaps
    `LoadBalancer` on a provider), you can simplify that access by using the service
    names, either within the same namespace or using the longer service names with
    the namespace included.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在一个非常多样化的开发环境中工作，每个人的设置都略有不同，那么这种模式可以整合测试，以便每个人都有相同的体验。此外，当本地测试需要通过暴露的服务（例如使用Minikube的NodePort，或者在提供程序上使用`LoadBalancer`）访问远程Kubernetes时，您可以通过使用服务名称来简化访问，无论是在相同的命名空间中还是在包含命名空间的较长的服务名称中。
- en: Another challenge with running tests within Kubernetes is getting the results.
    While it is quite possible to collect the results and post them to a remote location,
    this pattern is not common. A more frequent resolution when using this pattern
    is to have a cluster dedicated to testing that also includes some continuous integration
    infrastructure, either as a part of the cluster, or alongside and with dedicated
    access to the cluster, that then runs the tests and captures the results as a
    part of the test automation. We will look at continuous integration in more depth
    later in this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中运行测试的另一个挑战是获取结果。虽然完全可以收集结果并将其发布到远程位置，但这种模式并不常见。使用这种模式时更常见的解决方案是拥有一个专门用于测试的集群，其中还包括一些持续集成基础设施，可以作为集群的一部分，或者与集群并行并具有专用访问权限，然后运行测试并捕获结果作为测试自动化的一部分。我们将在本章后面更深入地研究持续集成。
- en: Simple validation with Bats
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bats进行简单验证
- en: A fairly common desire is to simply get everything deployed and make a few queries
    to validate that the resulting system is operational. As you do these operations,
    they are frequently captured in either Makefiles or shell scripts as simple programs
    to validate a baseline of functionality. Several years ago, a system called Bats,
    which stands for Bash Automated Testing System, was developed to make it slightly
    more convenient to run tests using shell scripts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相当普遍的愿望是简单地部署所有内容并进行一些查询，以验证生成的系统是否可操作。当您执行这些操作时，它们经常被捕获在Makefiles或shell脚本中，作为验证功能基线的简单程序。几年前，开发了一个名为Bats的系统，它代表Bash自动化测试系统，旨在使使用shell脚本运行测试变得更加方便。
- en: There are several examples of using Bats to test systems deployed in Kubernetes.
    The tests are generally straightforward and easy to read, and it is easy to extend
    and use. You can find more information on Bats at its GitHub home [https://github.com/sstephenson/bats](https://github.com/sstephenson/bats).
    You may see Bats used in some Kubernetes-related projects as well, for simple
    validation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个示例使用Bats来测试部署在Kubernetes中的系统。这些测试通常很简单易懂，易于扩展和使用。您可以在其GitHub主页[https://github.com/sstephenson/bats](https://github.com/sstephenson/bats)上找到更多关于Bats的信息。您可能也会在一些与Kubernetes相关的项目中看到Bats的使用，用于简单验证。
- en: Bitnami has set up an example GitHub repository to use as a starting point that
    uses Bats and Minikube, and was designed to also work with external CI systems
    such as Travis.CI. You can find the example at [https://github.com/bitnami/kubernetes-travis](https://github.com/bitnami/kubernetes-travis).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Bitnami已经建立了一个示例GitHub存储库，用作使用Bats和Minikube的起点，并且设计为与Travis.CI等外部CI系统一起使用。您可以在[https://github.com/bitnami/kubernetes-travis](https://github.com/bitnami/kubernetes-travis)找到示例。
- en: If you leverage Bats, you will want to have helper scripts to set up your deployments
    and wait until the relevant deployments are reporting ready, or fail the tests
    at setup. In the Bitnami example, the scripts `cluster_common.bash` and `libtest.bash`
    have these helper functions. If you want to use this path, you can start with
    the files from their repository and update and extend them to match your needs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Bats，您将需要有辅助脚本来设置您的部署，并等待相关部署报告就绪，或者在设置时失败测试。在Bitnami示例中，脚本`cluster_common.bash`和`libtest.bash`具有这些辅助函数。如果您想使用这条路径，可以从他们的存储库中开始，并更新和扩展它们以匹配您的需求。
- en: 'The integration tests start by loading the libraries and creating a local cluster,
    followed by deploying the system under test:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试从加载库和创建本地集群开始，然后部署正在测试的系统：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`deploy-stacks.bats` can be represented as a Bats test, and in the Bitnami
    example it validates that Kubernetes tools are all defined locally and then encapsulates
    the deployment itself as a test:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`deploy-stacks.bats`可以表示为一个Bats测试，在Bitnami示例中，它验证了Kubernetes工具在本地是否都已定义，然后将部署本身封装为一个测试：'
- en: 'This is from the example at [https://github.com/bitnami/kubernetes-travis/blob/master/tests/deploy-stack.bats](https://github.com/bitnami/kubernetes-travis/blob/master/tests/deploy-stack.bats):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自示例[https://github.com/bitnami/kubernetes-travis/blob/master/tests/deploy-stack.bats](https://github.com/bitnami/kubernetes-travis/blob/master/tests/deploy-stack.bats)：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The script `deploy.sh` is set up to either delete or create and load manifests
    just as we have been doing earlier in this book, by using the `kubectl create`,
    `kubectl delete`, or `kubectl apply` commands.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本`deploy.sh`设置为删除或创建和加载清单，就像我们在本书中早些时候所做的那样，使用`kubectl create`，`kubectl delete`或`kubectl
    apply`命令。
- en: 'Once that is complete, the integration test continues with getting access to
    the cluster. In the Bitnami example, they are using Kubernetes Ingress to consistently
    access the cluster, and have scripts set up to capture and return the IP address
    and URL path for accessing the underlying system through `Ingress`. You could
    also utilize `kubectl port-forward` or `kubectl proxy`, as we showed earlier in
    the book:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，集成测试继续获取对集群的访问。在Bitnami示例中，他们使用Kubernetes Ingress来一致地访问集群，并设置脚本来捕获和返回访问底层系统的IP地址和URL路径通过`Ingress`。您也可以使用`kubectl
    port-forward`或`kubectl proxy`，就像我们在本书中早些时候展示的那样：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once that is set, then the integration tests are invoked again using Bats,
    and the exit code from that whole process is captured and used to reflect whether
    the tests succeeded or failed:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，再次使用Bats调用集成测试，并捕获整个过程的退出代码，并用于反映测试是否成功或失败：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While this is easy to get started with, programming in bash quickly becomes
    its own speciality, and while basic bash usage is frequent and easily understood,
    some of the more complex helpers within that example can take some digging to
    fully understand.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很容易入门，但在bash中编程很快就成为了自己的专业领域，而基本的bash使用频繁且易于理解，但在该示例中的一些更复杂的辅助功能可能需要一些挖掘才能完全理解。
- en: If you are having trouble with a shell script, then a common debugging solution
    is to add `set -x` near the top of the script. Within bash, this turns on a command
    echo, so that all the commands within the script are echoed to standard out so
    that you can see what is happening.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在使用shell脚本时遇到问题，常见的调试解决方案是在脚本顶部附近添加`set -x`。在bash中，这会打开命令回显，以便将脚本中的所有命令回显到标准输出，以便您可以看到发生了什么。
- en: A good pattern to follow is to write tests in a language that you are familiar
    with. You can frequently leverage the testing frameworks of those languages to
    help you. You still may want to use shell scripts like the Bitnami example to
    set up and deploy your code to your cluster, and use the logic and structure of
    a language you are more comfortable with for the tests.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的模式是使用您熟悉的语言编写测试。您经常可以利用这些语言的测试框架来帮助您。您可能仍然希望使用像Bitnami示例那样的shell脚本来设置和部署代码到您的集群，并且对于测试，使用您更熟悉的语言的逻辑和结构。
- en: Example – integration testing with Python
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 使用Python进行集成测试
- en: In the case of Python, the example code here uses PyTest as a test framework.
    The example code can be found on GitHub, in the 0.7.0 branch of the repository
    [https://github.com/kubernetes-for-developers/kfd-flask/](https://github.com/kubernetes-for-developers/kfd-flask/).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的情况下，这里的示例代码使用PyTest作为测试框架。示例代码可以在GitHub上找到，位于存储库的0.7.0分支中[https://github.com/kubernetes-for-developers/kfd-flask/](https://github.com/kubernetes-for-developers/kfd-flask/)。
- en: 'You can download the example using the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令下载示例：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the example, I changed the code structure to move all the Python code for
    the application itself under the `src` directory, following the recommended pattern
    from PyTest. If you have not used PyTest before, reviewing their best practices
    at [https://docs.pytest.org/en/latest/goodpractices.html](https://docs.pytest.org/en/latest/goodpractices.html)
    is very worthwhile.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我改变了代码结构，将应用程序本身的所有Python代码移动到`src`目录下，遵循了PyTest的推荐模式。如果您以前没有使用过PyTest，请查看他们的最佳实践[https://docs.pytest.org/en/latest/goodpractices.html](https://docs.pytest.org/en/latest/goodpractices.html)，这是非常值得的。
- en: 'If you view the code or download it, you will also notice a new file, `test-dependencies.txt`,
    which defines a number of dependencies specific to testing. Python does not have
    a manifest where they separate out dependencies for production from ones used
    during development or testing, so I separated the dependencies out myself:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看代码或下载它，您还会注意到一个新文件`test-dependencies.txt`，其中定义了一些特定于测试的依赖项。Python没有一个将生产环境的依赖项与开发或测试中使用的依赖项分开的清单，所以我自己分开了这些依赖项：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The actual integration tests are housed under the directory `e2e_tests`, primarily
    as a pattern that would let you have a local directory for any unit or functional
    tests you wanted to create during normal development.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的集成测试存放在`e2e_tests`目录下，主要作为一个模式，让您在正常开发过程中可以有一个本地目录用于创建任何单元测试或功能测试。
- en: The pattern that I'm using in this example is leveraging our code in Kubernetes
    and accessing it external to the cluster, leveraging Minikube. The same pattern
    can work nicely with a cluster hosted in AWS, Google, or Azure if your environment
    requires more resources than you have available on your local development machine.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个示例中使用的模式是利用我们在Kubernetes中的代码，并在集群外部访问它，利用Minikube。如果您的环境需要比您本地开发机器上可用的资源更多，同样的模式也可以很好地与托管在AWS、Google或Azure中的集群配合使用。
- en: 'The `README` file in `e2e_tests` shows an example of how to run the tests.
    I take advantage of `pip` and `virtualenv` to set up a local environment, install
    the dependencies, and then use PyTest to run the tests directly:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`e2e_tests`中的`README`文件显示了如何运行测试的示例。我利用`pip`和`virtualenv`来设置本地环境，安装依赖项，然后使用PyTest直接运行测试：'
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you run through these tests, you should see output akin to the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这些测试，你应该会看到类似以下的输出：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'PyTest includes a large number of plugins, including a means to export the
    test results in JUnit XML format. You can get such a report created by PyTest
    by invoking it with the `--junitxml` option:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: PyTest包括大量的插件，包括一种以JUnit XML格式导出测试结果的方法。您可以通过使用`--junitxml`选项调用PyTest来获得这样的报告：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code within these tests leverages the examples we have built so far: our
    deployment YAML and the images we have made with the code in the repository. The
    tests do a simple verification that the cluster is available and healthy (and
    that we can communicate with it), and then uses `kubectl` to deploy our code.
    It then waits until the code is deployed, with a max timeout defined, before continuing
    on to interact with the service and get a simple response.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试中的代码利用了我们迄今为止构建的示例：我们的部署YAML和我们用代码在存储库中制作的图像。测试对集群的可用性和健康进行了简单的验证（以及我们是否可以与其通信），然后使用`kubectl`来部署我们的代码。然后等待代码部署，定义了最大超时时间，然后继续与服务交互并获得简单的响应。
- en: This example is primarily aimed at showing you how you can interact with a remote
    Kubernetes cluster, including using the `python-kubernetes` client library.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子主要是为了向您展示如何与远程Kubernetes集群交互，包括使用`python-kubernetes`客户端库。
- en: PyTest and pytest-dependency
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyTest和pytest-dependency
- en: 'PyTest is foremost a unit testing framework. Unit testing frameworks generally
    have different needs from integration tests, and fortunately PyTest has a means
    to allow a developer to specify that one test needs to run and complete before
    another. This is done with the `pytest-dependency` plugin. Within the code, you
    will see some of the test cases annotated with dependency markers. To use this
    plugin, you define which tests can be dependency targets, and for any test that
    needs to run after it, you define the tests upon which they depend:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: PyTest首先是一个单元测试框架。单元测试框架通常对集成测试有不同的需求，幸运的是，PyTest有一种方法允许开发人员指定一个测试需要在另一个测试之前运行和完成。这是通过`pytest-dependency`插件完成的。在代码中，您会看到一些测试用例被标记为依赖标记。要使用这个插件，您需要定义哪些测试可以成为依赖目标，以及任何需要在其后运行的测试，您需要定义它们依赖的测试：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The test checks to verify that the cluster is accessible and responding as
    healthy. This test doesn''t depend on any others, so it has just the basic annotation,
    and tests further down will specify that this test needs to have completed before
    they will run, with this annotation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试检查集群是否可访问并且响应正常。这个测试不依赖于其他任何测试，所以它只有基本的注释，而下面的测试将指定这个测试需要在运行之前完成，使用这个注释：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This can make the test annotations quite verbose, but allows you to explicitly
    define the ordering of execution. By default, most unit testing frameworks do
    not guarantee a specific order or execution, which can be critical when you are
    testing a system that includes state and changes to that state—exactly what we
    do with integration testing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会使测试注释非常冗长，但允许您明确定义执行顺序。默认情况下，大多数单元测试框架不保证特定的执行顺序，当您测试包含状态和对该状态的更改的系统时，这可能是至关重要的——这正是我们进行集成测试的内容。
- en: PyTest fixtures and the python-kubernetes client
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyTest固定装置和python-kubernetes客户端
- en: The preceding example also leverages a simple text fixture to provide us an
    instance of a Python Kubernetes client to interact with the cluster. The Python
    client can be awkward to use, since it is generated from an OpenAPI specification,
    and has class setups for each API endpoint, of which there are several. In particular,
    as sections of the Kubernetes API evolve through alpha, beta, and final release
    stages, these API endpoints will move, which means the client code you're using
    may need to change as you upgrade the version of the Kubernetes cluster with which
    you are interacting.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例还利用了一个简单的文本fixture，为我们提供了一个Python Kubernetes客户端的实例，以便与集群进行交互。Python客户端可能难以使用，因为它是从OpenAPI规范生成的，并且对于每个API端点都有类设置，而这些端点有好几个。特别是，随着Kubernetes
    API的各个部分通过alpha、beta和最终发布阶段的演变，这些API端点将移动，这意味着您使用的客户端代码可能需要随着您与之交互的Kubernetes集群版本的升级而更改。
- en: The `python-kubernetes` client does come with readily available source code
    and a generated index to all the methods, which I recommend having handy if you're
    going to use the client. The code is housed at [https://github.com/kubernetes-client/python](https://github.com/kubernetes-client/python),
    and the releases are stored in branches. The release that I was using was 5.0,
    which is paired with Kubernetes version 1.9 and supports earlier versions. The
    `README` that includes all the documentation for the OpenAPI-generated methods
    is available at [https://github.com/kubernetes-client/python/blob/release-5.0/kubernetes/README.md](https://github.com/kubernetes-client/python/blob/release-5.0/kubernetes/README.md).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`python-kubernetes`客户端确实带有现成的源代码和所有方法的生成索引，我建议如果您要使用客户端，最好随时准备好这些。代码存放在[https://github.com/kubernetes-client/python](https://github.com/kubernetes-client/python)，发布版本存储在分支中。我使用的版本是5.0，与Kubernetes版本1.9配对，并支持早期版本。包含所有OpenAPI生成方法文档的`README`可在[https://github.com/kubernetes-client/python/blob/release-5.0/kubernetes/README.md](https://github.com/kubernetes-client/python/blob/release-5.0/kubernetes/README.md)找到。'
- en: 'A PyTest fixture sets up the client for the other tests:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个PyTest fixture为其他测试设置了客户端：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, the client loads the locally available `kubeconfig` for access
    to the cluster. Depending on your development environment, you may want to investigate
    alternatives to authenticating to the cluster.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，客户端加载本地可用的`kubeconfig`以访问集群。根据您的开发环境，您可能需要调查其他身份验证到集群的替代方法。
- en: 'While it is possible to do the deployment with the python-kubernetes client,
    the example shows how to use the local `kubectl` command line to interact with
    the cluster as well. In this case, it''s significantly fewer lines than defining
    the full definition of what you want deployed in Python:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用python-kubernetes客户端进行部署，但示例还展示了如何使用本地`kubectl`命令行与集群进行交互。在这种情况下，与在Python中定义要部署的完整定义相比，代码行数要少得多：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you want to leverage other tools to deploy your code, this kind of mechanism
    can be invaluable, and is always a useful fallback in writing integration tests.
    Also note that this test depends on the test we mentioned earlier, forcing it
    to run after the cluster health validation test.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想利用其他工具部署您的代码，这种机制可能非常有价值，并且在编写集成测试时始终是一个有用的后备。还要注意，这个测试依赖于我们之前提到的测试，强制它在集群健康验证测试之后运行。
- en: Be aware that debugging these commands when the system fails can be more difficult,
    because so much is happening outside of the actual test with commands like these.
    You will want to be aware of what process is invoking the test, its permissions
    relative to your environment, and so forth.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当系统失败时调试这些命令可能会更加困难，因为很多事情都发生在实际测试之外，比如这样的命令。您需要了解调用测试的进程，它相对于您的环境的权限等。
- en: Waiting for state changes
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待状态变化
- en: 'Following the deployment, we expect the deployment and services to all become
    active, but this does not happen instantaneously. Depending on your environment,
    it may happen quite quickly, or fairly slowly. The bane of integration tests is
    not being able to know when something has completed, and working around the issue
    with an invocation of `sleep()` to wait a little longer. In this example, we explicitly
    check the status rather than just waiting an arbitrary amount of time and hoping
    the system is ready to go:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 部署后，我们期望部署和服务都变为活动状态，但这并不是瞬间发生的。根据您的环境，它可能会发生得非常快，也可能会发生得相当慢。集成测试的问题在于无法知道何时完成某些操作，并通过调用`sleep()`来解决问题，等待更长时间。在这个例子中，我们明确检查状态，而不是只等待任意时间，希望系统已准备就绪：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This example has a maximum timeout of `300` seconds for the deployment to become
    active, and includes a short delay in requesting the status of the environment
    before it will continue. Should the overall timeout be exceeded, the test will
    report a failure—and by using `pytest-dependency`, all the following tests that
    depend on this will not be run—short circuiting the testing process to report
    the failure.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的部署最大超时时间为`300`秒，包括在继续之前请求环境状态的短暂延迟。如果超过总超时时间，测试将报告失败，并且通过使用`pytest-dependency`，所有依赖于此的后续测试都不会运行，从而中断测试过程以报告失败。
- en: Accessing the deployment
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问部署
- en: The last two tests highlight two ways of interacting with the code running within
    the cluster.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个测试突出了与集群内运行的代码交互的两种方式。
- en: 'The first example expects something to be set up and running that provides
    access to the cluster outside of the test, and simply uses the Python `requests`
    library to make an HTTP request directly:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例期望设置并运行提供对测试之外的集群的访问，并简单地使用Python的`requests`库直接发出HTTP请求：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It''s an incredibly basic test and is fairly fragile. It uses a PyTest fixture
    defined earlier in the code to set up an invocation of `kubectl proxy` to provide
    access to the cluster:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的测试，而且相当脆弱。它使用了代码中早期定义的PyTest夹具来设置`kubectl proxy`的调用，以提供对集群的访问：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While this generally works, it's harder to track down issues when things fail,
    and the fixture mechanism wasn't entirely reliable in setting up (and tearing
    down) the proxy invocation in a forked shell command.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这通常有效，但当事情失败时，要追踪问题就更难了，而且在设置（和拆除）分叉shell命令中，夹具机制并不完全可靠。
- en: 'The second example uses the python-kubernetes client to access the service
    through a series of methods that allow you to easily invoke HTTP requests through
    the proxy that is included with Kubernetes. The client configuration takes care
    of the authentication to the cluster, and you access the code through the proxy
    by leveraging the client directly rather than using an external proxy to provide
    access:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例使用python-kubernetes客户端通过一系列方法访问服务，这些方法允许您通过Kubernetes附带的代理轻松调用HTTP请求。客户端配置负责对集群进行身份验证，并且您可以通过直接利用客户端而不是使用外部代理来访问代码，通过代理访问：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This mechanism is great if you don''t need to fiddle with headers or otherwise
    get complicated with your HTTP requests, which is more accessible when using a
    general Python client such as `requests`. There are a whole series of methods
    that support a variety of HTTP/REST style calls all prefixed with `proxy`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不需要在HTTP请求中操纵标头或以其他方式复杂化，这种机制非常适用，当使用通用的Python客户端（如`requests`）时更易于访问。有一整套支持各种HTTP/REST风格调用的方法，所有这些方法都以`proxy`为前缀：
- en: '`proxy_get`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_get`'
- en: '`proxy_delete`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_delete`'
- en: '`proxy_head`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_head`'
- en: '`proxy_options`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_options`'
- en: '`proxy_patch`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_patch`'
- en: '``proxy_put``'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '``proxy_put``'
- en: 'Each of these is mapped to the following endpoints:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都映射到以下端点：
- en: '`namespaced_pod`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespaced_pod`'
- en: '`namespaced_pod_with_path`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespaced_pod_with_path`'
- en: '`namespaced_service`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespaced_service`'
- en: '`namespaced_service_with_path`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespaced_service_with_path`'
- en: This gives you some flexibility in standard REST commands to send to either
    a pod directly, or to a service endpoint. The `with_path` option allows you to
    define the specific URI with which you're interacting on the pod or service.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这使您可以在标准的REST命令中发送命令，直接发送到pod或服务端点。`with_path`选项允许您定义与pod或服务上交互的特定URI。
- en: Example – integration testing with Node.js
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-使用Node.js进行集成测试
- en: The Node.js example uses mocha, chai, supertest, and the JavaScript kubernetes
    client in much the same fashion as the Python example. The example code can be
    found on GitHub, in the 0.7.0 branch of the repository at [https://github.com/kubernetes-for-developers/kfd-nodejs/](https://github.com/kubernetes-for-developers/kfd-nodejs/).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js示例与Python示例类似，使用了mocha、chai、supertest和JavaScript kubernetes客户端。示例代码可以在GitHub上找到，位于存储库的0.7.0分支中[https://github.com/kubernetes-for-developers/kfd-nodejs/](https://github.com/kubernetes-for-developers/kfd-nodejs/)。
- en: 'You can download the example using the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令下载示例：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I took advantage of Node.js''s mechanism to have development dependencies separate
    from production dependencies, and added most of these dependencies into `package.json`.
    I also went ahead and set up a simple unit test directly in a `test` directory,
    and a separate integration test in an `e2e-tests` directory. I also set up the
    commands so that you can run these tests through `npm`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我利用了Node.js的机制，将开发依赖项与生产依赖项分开，并将大部分这些依赖项添加到了`package.json`中。我还继续在`test`目录中直接设置了一个简单的单元测试，并在`e2e-tests`目录中设置了一个单独的集成测试。我还设置了命令，以便您可以通过`npm`运行这些测试：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For the unit tests, the code runs locally and takes advantage of `supertest`
    to access everything within a JavaScript runtime on your local machine. This doesn''t
    account for any remote services or systems (such as interacting with endpoints
    that depend on Redis):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单元测试，代码在本地运行，并利用`supertest`来访问本地计算机上的JavaScript运行时中的所有内容。这不包括任何远程服务或系统（例如与依赖于Redis的端点进行交互）：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Within the `e2e_tests` directory,  there is an analog of the Python tests,
    which validates the cluster is operational, sets up the deployment, and then accesses
    that code. This can be invoked with the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`e2e_tests`目录中，有一个类似于Python测试的模拟，用于验证集群是否正常运行，设置部署，然后访问该代码。可以使用以下命令调用此模拟：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Invoking the tests would show you something akin to the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 调用测试将显示类似以下内容：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Node.js tests and dependencies with mocha and chai
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用mocha和chai的Node.js测试和依赖项
- en: The test code itself is at `e2e_tests/integration_test.js`, and I leverage mocha
    and chai to lay out the tests in a BDD-style structure. A convenient side effect
    of the BDD structure with mocha and chai is that tests can be wrapped by `describe`
    and `it`, which structure how the tests get run. Anything within a `describe`
    block doesn't have a guaranteed ordering, but you can nest `describe` blocks to
    get the structure you want.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码本身位于`e2e_tests/integration_test.js`，我利用mocha和chai以BDD风格的结构布置了测试。使用mocha和chai的BDD结构的一个便利的副作用是，测试可以由`describe`和`it`包装，这样结构化了测试的运行方式。`describe`块内的任何内容都没有保证的顺序，但您可以嵌套`describe`块以获得所需的结构。
- en: Validating the cluster health
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证集群健康
- en: 'The JavaScript Kubernetes client is generated in much the same fashion as the
    Python client, from the OpenAPI definition and mapped to the releases of Kubernetes.
    You can find the client at [https://github.com/kubernetes-client/javascript](https://github.com/kubernetes-client/javascript),
    although this repository doesn''t have the same level of generated documentation
    as the Python client. Instead, the developers have gone to some length to reflect
    the types in TypeScript with the client, which results in editors and IDEs being
    able to do some level of automatic code completion as you are writing your tests:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript Kubernetes客户端与Python客户端以类似的方式生成，从OpenAPI定义中映射到Kubernetes的发布版本。你可以在[https://github.com/kubernetes-client/javascript](https://github.com/kubernetes-client/javascript)找到客户端，尽管这个存储库没有与Python客户端相同级别的生成文档。相反，开发人员已经花了一些精力用TypeScript反映了客户端中的类型，这导致编辑器和IDE在编写测试时能够做一定程度的自动代码补全：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The nesting of the code can make indenting and tracking at the right level quite
    tricky, so the test code leverages promises where it can to simplify the callback
    structures. The preceding example uses a Kubernetes client that automatically
    grabs credentials from the environment in which it's run, a feature of several
    of these clients, so be aware of it if you wish to arrange specific access.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的嵌套可能会使缩进和跟踪正确级别变得相当棘手，因此测试代码利用promise来简化回调结构。前面的示例使用了一个Kubernetes客户端，它会自动从运行它的环境中获取凭据，这是几个这些客户端的特性，因此如果你希望安排特定的访问，要注意这一点。
- en: Where the Python client had a method, `list_component_status`, the JavaScript
    pattern scrunches the names together with CamelCase formatting, so the same call
    here is `listComponentStatus`. The result is then passed in a promise, and we
    iterate through the various elements to verify that the cluster components are
    all reporting healthy.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Python客户端有一个方法`list_component_status`，而JavaScript模式则使用CamelCase格式将名称紧凑在一起，因此这里的调用是`listComponentStatus`。然后结果通过一个promise传递，我们遍历各种元素来验证集群组件是否都报告为健康状态。
- en: 'The example leaves in some commented out code that inspects the objects that
    were returned. With little external documentation, I found it convenient to see
    what was returned while developing the tests, and the common trick is to use the
    `util.inspect` function and log the results to `STDOUT`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中留下了一些被注释掉的代码，用于检查返回的对象。由于外部文档很少，我发现在开发测试时查看返回的内容很方便，常见的技巧是使用`util.inspect`函数并将结果记录到`STDOUT`中：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Deploying with kubectl
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用kubectl部署
- en: 'Following the Python example, I used `kubectl` on the command line to deploy
    the code, invoking it from the integration test:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python示例之后，我在命令行上使用`kubectl`部署代码，从集成测试中调用它：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This particular bit of code is dependent on where you have this test case and
    its relative directory to the deploy directory where the manifests are stored,
    and like the preceding example it uses promises to chain the validation of the
    execution of the invocation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这段特定的代码取决于你在哪里有这个测试用例，以及它相对于存储清单的部署目录的位置，就像前面的示例一样，它使用promises来链接调用的执行的验证。
- en: Waiting for the pods to become available
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待pod变得可用
- en: 'The process of waiting and retrying was significantly more tricky with Node.js,
    promises, and callbacks. In this case, I leveraged a capability of the mocha test
    library to allow a test to be retried and manipulate the overall timeout for a
    section of the test structure to get the same end result:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 等待和重试的过程在Node.js、promises和callbacks中更加棘手。在这种情况下，我利用了mocha测试库的一个功能，允许对测试进行重试，并操纵测试结构的整体超时，以获得相同的结果：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: By returning promises in the tests, every one of the tests is already asynchronous
    with a preset timeout that mocha provides of `20` seconds. Within each `describe`,
    you can tweak how mocha runs the tests—in this case, setting the overall timeout
    to five minutes and asserting that the test can be retried up to `30` times. To
    slow down the checking iterations, I also included a timeout promise that simply
    introduces a five-second delay before invoking the check of the cluster to get
    the pod health.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在测试中返回promises，每个测试已经是异步的，并且具有mocha提供的预设超时为`20`秒。在每个`describe`中，您可以调整mocha运行测试的方式，例如将整体超时设置为五分钟，并断言测试最多可以重试`30`次。为了减慢检查迭代，我还包括了一个超时promise，它在调用集群检查之前引入了五秒的延迟。
- en: Interacting with the deployment
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与部署进行交互
- en: 'The code to interact with the deployment is simpler than the Python example,
    utilizing the Kubernetes client and the proxy:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python示例相比，与部署进行交互的代码更简单，利用了Kubernetes客户端和代理：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this branch, I changed the code running from a stateful set to a deployment,
    as getting proxy access to the headless endpoints proved complicated. The stateful
    sets can be easily accessed from within the cluster via DNS, but mapping to external
    didn't appear to be easily supported in the current client code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个分支中，我将运行的代码从有状态集更改为部署，因为获取对无头端点的代理访问证明很复杂。有状态集可以通过DNS轻松从集群内部访问，但在当前客户端代码中似乎不容易支持映射到外部。
- en: 'Like the Python code, there''s a matrix of calls to make REST style requests
    through the client:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python代码一样，有一系列调用可以通过客户端进行REST风格的请求：
- en: '`proxyGET`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxyGET`'
- en: '`proxyDELETE`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxyDELETE`'
- en: '`proxyHEAD`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxyHEAD`'
- en: '`proxyOPTIONS`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxyOPTIONS`'
- en: '`proxyPATCH`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxyPATCH`'
- en: '`proxyPUT`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxyPUT`'
- en: 'And each is mapped to endpoints:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 并且每个都映射到端点：
- en: '`namespacedPod`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespacedPod`'
- en: '`namespacedPodWithPath`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespacedPodWithPath`'
- en: '`namespacedService`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespacedService`'
- en: '`namespacedServiceWithPath`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespacedServiceWithPath`'
- en: This gives you some flexibility in standard REST commands to send to either
    a pod directly or to a service endpoint. Like the Python code, the `withPath`
    option allows you to define the specific URI with which you're interacting on
    the pod or service.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这为您提供了一些灵活性，可以将标准的REST命令发送到Pod直接或服务端点。与Python代码一样，`withPath`选项允许您定义与Pod或服务上交互的特定URI。
- en: 'If you''re writing these tests in an editor such as Visual Studio Code, code
    completion will help provide some of the details that are otherwise missing from
    the documentation. The following is an example of code completion showing the
    `method` options:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在诸如Visual Studio Code之类的编辑器中编写这些测试，代码完成将帮助提供一些在文档中否则缺失的细节。以下是代码完成显示`method`选项的示例：
- en: '![](assets/6ccc784d-e1e6-4d88-8c5f-7a1265ae5400.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6ccc784d-e1e6-4d88-8c5f-7a1265ae5400.png)'
- en: 'And when you choose a method, the TypeScriptannotations are also available
    to show you what options the JavaScript methods expect:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当您选择一种方法时，TypeScript注释也可用于显示JavaScript方法期望的选项：
- en: '![](assets/b9556730-dee8-4b4b-ae6a-a9b11dbd364e.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b9556730-dee8-4b4b-ae6a-a9b11dbd364e.png)'
- en: Continuous integration with Kubernetes
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Kubernetes的持续集成
- en: Once you have integration tests, getting something operational to validate those
    tests is very important. If you don't run the tests, they're effectively useless—so
    having a means of consistently invoking the tests while you're doing development
    is important. It is fairly common to see continuous integration do a lot of the
    automated lifting for development.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有集成测试，获取一些操作来验证这些测试非常重要。如果您不运行测试，它们实际上是无用的-因此在开发过程中始终调用测试的方法非常重要。通常会看到持续集成为开发做了大量自动化工作。
- en: 'There are a number of options available to development teams to help you with
    continuous integration, or even its more advanced cousin, continuous deployment.
    The following tools are an overview of what was available at the time of writing,
    and in use by developers working with their code in containers and/or in Kubernetes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队有许多选项可帮助您进行持续集成，甚至是更高级的持续部署。以下工具是在撰写时可用的概述，并且由使用容器和/或Kubernetes中的代码的开发人员使用：
- en: '**Travis.CI**: Travis.CI ([https://travis-ci.org/](https://travis-ci.org/))
    is a hosted continuous integration service, and it is quite popular as the company
    offers free service with an easy means of plugging into GitHub for public and
    open source repositories. Quite a number of open source projects leverage Travis.CI
    to do basic testing validation.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Travis.CI：Travis.CI（[https://travis-ci.org/](https://travis-ci.org/)）是一个托管的持续集成服务，因为该公司提供了免费服务，并且可以轻松地与GitHub对接以用于公共和开源存储库。相当多的开源项目利用Travis.CI进行基本测试验证。
- en: '**Drone.IO**: Drone.IO ([https://drone.io/](https://drone.io/)) is a hosted
    or local option for continuous integration that is also open source software itself,
    hosted at [https://github.com/drone/drone](https://github.com/drone/drone). Drone
    has an extensive plugin library, including a plugin for Helm ([https://github.com/ipedrazas/drone-helm](https://github.com/ipedrazas/drone-helm)),
    which has made it attractive to some development teams who are using Helm to deploy
    their software.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drone.IO：Drone.IO（[https://drone.io/](https://drone.io/)）是一个托管或本地的持续集成选项，也是开源软件本身，托管在[https://github.com/drone/drone](https://github.com/drone/drone)。Drone拥有广泛的插件库，包括一个Helm插件（[https://github.com/ipedrazas/drone-helm](https://github.com/ipedrazas/drone-helm)），这使得它对一些使用Helm部署软件的开发团队很有吸引力。
- en: '**Gitlab**: Gitlab ([https://about.gitlab.com/](https://about.gitlab.com/))
    is an opensource source control solution that includes continuous integration.
    Like Drone, it can be leveraged in your local environment, or you can use the
    hosted version. Where the previous options were agnostic to the source control
    mechanism, Gitlab CI is tightly bound to Gitlab, effectively making it useful
    only if you''re also willing to use Gitlab.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gitlab：Gitlab（[https://about.gitlab.com/](https://about.gitlab.com/)）是一个开源的源代码控制解决方案，包括持续集成。与Drone一样，它可以在您的本地环境中使用，或者您可以使用托管版本。之前的选项对源代码控制机制是不可知的，Gitlab
    CI与Gitlab紧密绑定，有效地使其只有在您愿意使用Gitlab时才有用。
- en: '**Jenkins**: Jenkins ([https://jenkins.io/](https://jenkins.io/)) is the grandaddy
    of the CI solutions, originally known as Hudson, and it is used extensively in
    a wide variety of environments. A hosted version of Jenkins is available through
    some providers, but it is primarily a opensource solution that you''re expected
    to deploy and manage yourself. It has an amazing (perhaps overwhelming) number
    of plugins and options available to it, and notably a Kubernetes plugin ([https://github.com/jenkinsci/kubernetes-plugin](https://github.com/jenkinsci/kubernetes-plugin))
    that will let a Jenkins instance run its tests within a Kubernetes cluster.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins：Jenkins（[https://jenkins.io/](https://jenkins.io/)）是CI解决方案的鼻祖，最初被称为Hudson，并且在各种环境中被广泛使用。一些提供商提供了Jenkins的托管版本，但它主要是一个您需要自己部署和管理的开源解决方案。它有大量（也许是压倒性的）插件和选项可供选择，特别是一个Kubernetes插件（[https://github.com/jenkinsci/kubernetes-plugin](https://github.com/jenkinsci/kubernetes-plugin)），可以让Jenkins实例在Kubernetes集群中运行其测试。
- en: '**Concourse**: Concourse ([https://concourse-ci.org/](https://concourse-ci.org/)),
    like Jenkins, is an open source project rather than a hosted solution, built in
    the CloudFoundry project and focusing on pipelines for deployment as a first-class
    concept (it''s relatively new to some older projects such as Jenkins). Like Drone,
    it is set up to be a continuous delivery pipeline and an integral part of your
    development process.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Concourse**：Concourse（[https://concourse-ci.org/](https://concourse-ci.org/)），类似于Jenkins，是一个开源项目，而不是一个托管解决方案，它是在CloudFoundry项目中构建的，专注于部署管道作为一种第一类概念（对于一些较老的项目，如Jenkins，它相对较新）。与Drone一样，它被设置为一个持续交付管道，并且是您开发过程的一个重要部分。'
- en: Example – using Minikube with Travis.CI
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-在Travis.CI中使用Minikube
- en: The example earlier that showed using Bats to run a test was created by the
    team at Bitnami, and they also leveraged that same example repository for building
    and deploying code into an instance of Minikube hosted and run on Travis.CI. Their
    example repository is online at [https://github.com/bitnami/kubernetes-travis](https://github.com/bitnami/kubernetes-travis),
    and it installs Minikube as well as additional tooling to build and deploy into
    a small Kubernetes instance.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例展示了使用Bats运行测试，是由Bitnami团队创建的，并且他们还利用了相同的示例存储库来构建和部署代码到托管在Travis.CI上的Minikube实例。他们的示例存储库在线上[https://github.com/bitnami/kubernetes-travis](https://github.com/bitnami/kubernetes-travis)，它安装了Minikube以及其他工具来构建和部署到一个小的Kubernetes实例。
- en: Travis.CI is configured through a `.travis.yml` file, and the documentation
    for how to configure it and what options are available is hosted online at [https://docs.travis-ci.com](https://docs.travis-ci.com).
    Travis.CI, by default, will attempt to understand what language is being used,
    and orient its build scripts to the language, focusing primarily on running builds
    for every pull request and merge into a repository.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Travis.CI通过一个`.travis.yml`文件进行配置，有关如何配置以及可用选项的文档托管在[https://docs.travis-ci.com](https://docs.travis-ci.com)上。Travis.CI默认情况下会尝试理解正在使用的语言，并将其构建脚本定位到该语言，主要专注于对每个拉取请求和合并到存储库的构建进行运行。
- en: 'The Node.js example added a sample `.travis.yml` that sets up and runs the
    current integration test:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js示例添加了一个示例`.travis.yml`，用于设置和运行当前的集成测试：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The key `language`, which is set to `nodejs` in our example, defines a large
    part of how Travis will run. We define which versions of Node.js are used (`lts/*`)
    and by default the system would use `npm` , running `npm test` to validate our
    build. That would run our unit tests, but wouldn't invoke our integration tests.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 键`language`在我们的示例中设置为`nodejs`，它定义了Travis的运行方式的很大一部分。我们定义了使用哪些版本的Node.js（`lts/*`），默认情况下系统会使用`npm`，运行`npm
    test`来验证我们的构建。这将运行我们的单元测试，但不会调用我们的集成测试。
- en: You can extend what happens before the testing, and what is used by the tests,
    by manipulating the values under the keys `before_script` and `script`. In the
    preceding example, we preload `minikube` and `kubectl` by downloading them from
    their released locations, and the preceding example then starts Minikube and waits
    until the command `kubectl get nodes` returns with a positive result.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过操纵键`before_script`和`script`下的值来扩展测试之前发生的事情以及测试使用的内容。在前面的示例中，我们通过从它们的发布位置下载它们来预加载`minikube`和`kubectl`，然后启动Minikube并等待直到命令`kubectl
    get nodes`返回正面结果。
- en: 'By adding `npm run integration` under the key script, we override the default
    Node.js behavior and instead run our integration test. When the example was developed,
    updates were pushed to the 0.7.0 branch, which was open as a pull request to the
    main repository. The results of those updates were published into the hosted solution,
    available at [https://travis-ci.org/kubernetes-for-developers/kfd-nodejs](https://travis-ci.org/kubernetes-for-developers/kfd-nodejs).
    For example, the following is a build page showing a successful build:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在关键脚本下添加`npm run integration`，我们覆盖了默认的Node.js行为，而是运行我们的集成测试。当示例被开发时，更新被推送到了0.7.0分支，该分支作为主存储库的拉取请求是开放的。这些更新的结果被发布到托管解决方案，可在[https://travis-ci.org/kubernetes-for-developers/kfd-nodejs](https://travis-ci.org/kubernetes-for-developers/kfd-nodejs)上找到。例如，以下是一个显示成功构建的构建页面：
- en: '![](assets/cfdc6e56-9507-4163-a667-4afa57807b67.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cfdc6e56-9507-4163-a667-4afa57807b67.png)'
- en: Next steps
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: This example build does not do the entire process from source to container to
    deployment. Instead, it relies on a pre-built image with a tag that is set in
    the deployment manifests, managed in source control. Travis.CI does include the
    capability of building an image using Docker, and has documentation on how to
    leverage Docker to test a single container by itself at [https://docs.travis-ci.com/user/docker/](https://docs.travis-ci.com/user/docker/).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例构建并不涵盖从源代码到容器再到部署的整个过程。相反，它依赖于在源代码控制中管理的预构建镜像，并在部署清单中设置了标签。Travis.CI确实包括使用Docker构建镜像的能力，并有关于如何利用Docker测试单个容器的文档，网址为[https://docs.travis-ci.com/user/docker/](https://docs.travis-ci.com/user/docker/)。
- en: Travis also has the capability of storing credentials to build and push Docker
    images into an image repository, and recently added the capability of building
    in stages so that you can pipeline in a container build and then utilize it in
    your integration tests.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Travis还具有存储凭据以构建和推送Docker镜像到镜像存储库的能力，并最近增加了分阶段构建的能力，这样您就可以在容器构建中进行流水线处理，然后在集成测试中利用它。
- en: You need to update the Kubernetes declarations to use the image in question,
    and this example doesn't show that process. The common pattern for enabling this
    sort of functionality involves templating the manifests that we have stored in
    the deploy directory in our examples, and rendering them out with specific variables
    passed in.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要更新Kubernetes声明以使用相关镜像，而这个示例并没有展示这个过程。启用这种功能的常见模式涉及对我们在示例中存储在deploy目录中的清单进行模板化，并使用传入的特定变量进行渲染。
- en: 'Helm ([https://docs.helm.sh/](https://docs.helm.sh/)) is one way to accomplish
    this need: instead of having a `deploy` directory with the manifests, we might
    have a `charts` directory, and write up the manifests as templates. Helm uses
    a `values` file, which can be created as needed, to provide the variables that
    are used to render out the templates, and after creating a Docker image with a
    tag, that same tag value could be added to the `values` file and used for deployment.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Helm ([https://docs.helm.sh/](https://docs.helm.sh/)) 是实现这一需求的一种方式：我们可以有一个`charts`目录，而不是一个带有清单的`deploy`目录，并将清单编写为模板。
    Helm使用`values`文件，可以根据需要创建，以提供用于渲染模板的变量，并在创建带有标签的Docker镜像后，该标签值可以添加到`values`文件中并用于部署。
- en: Another option is a newer project called ksonnet ([https://ksonnet.io](https://ksonnet.io)),
    which builds on an opensource library, [http://jsonnet.org/](http://jsonnet.org/),
    to make a composable template-style language available that builds on prototypes
    for Kubernetes. ksonnet is relatively new and is still getting established. Using
    Helm, you utilize Go templates and need to have some familiarity with that format
    while creating the chart. ksonnet has its own style of writing the templates,
    and you can find a tutorial and examples at the project's site: [https://ksonnet.io/tour/welcome](https://ksonnet.io/tour/welcome).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是一个名为ksonnet的新项目([https://ksonnet.io](https://ksonnet.io))，它构建在一个开源库[http://jsonnet.org/](http://jsonnet.org/)上，以提供一个基于原型的可组合模板样式语言，用于构建Kubernetes。ksonnet相对较新，仍在建立中。使用Helm，您可以利用Go模板，并且在创建图表时需要对该格式有一定的了解。ksonnet有自己的模板编写风格，您可以在项目网站上找到教程和示例：[https://ksonnet.io/tour/welcome](https://ksonnet.io/tour/welcome)。
- en: Example – using Jenkins and the Kubernetes plugin
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-使用Jenkins和Kubernetes插件
- en: While not a hosted solution, Jenkins is one of the most frequently used continuous
    integration tools available. It is very simple to get an instance of Jenkins operational
    on a Kubernetes cluster, and thanks to a Kubernetes-specific plugin, it can also
    do all of its builds within a Kubernetes cluster.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是托管解决方案，但Jenkins是最常用的持续集成工具之一。在Kubernetes集群上运行Jenkins实例非常简单，并且由于Kubernetes特定插件的存在，它还可以在Kubernetes集群中进行所有构建。
- en: One of the quickest ways to install Jenkins in this fashion is to use Helm.
    The default Helm repository includes a maintained chart for running Jenkins, along
    with the configuration to use the Jenkins Kubernetes plugin. The chart that we
    will use is available on GitHub at [https://github.com/kubernetes/charts/tree/master/stable/jenkins](https://github.com/kubernetes/charts/tree/master/stable/jenkins).
    You can also get more details on the Jenkins Kubernetes plugin that gets installed
    with that chart at [https://wiki.jenkins.io/display/JENKINS/Kubernetes+Plugin](https://wiki.jenkins.io/display/JENKINS/Kubernetes+Plugin).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式安装Jenkins的最快方法之一是使用Helm。默认的Helm存储库包括一个维护的图表，用于运行Jenkins，以及使用Jenkins Kubernetes插件的配置。我们将使用的图表可在GitHub上找到[https://github.com/kubernetes/charts/tree/master/stable/jenkins](https://github.com/kubernetes/charts/tree/master/stable/jenkins)。您还可以在该图表安装的Jenkins
    Kubernetes插件的详细信息[https://wiki.jenkins.io/display/JENKINS/Kubernetes+Plugin](https://wiki.jenkins.io/display/JENKINS/Kubernetes+Plugin)。
- en: Installing Jenkins using Helm
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Helm安装Jenkins
- en: In this example, I'm going to walk through how you can set up and install Jenkins
    into a Minikube cluster on your local machine in order to experiment with it.
    You can use a very similar process to install into any Kubernetes cluster, but
    you will need to make some modifications depending on your target cluster.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我将演示如何在Minikube集群上设置和安装Jenkins到您的本地机器，以便进行实验。您可以使用非常类似的过程安装到任何Kubernetes集群，但是您需要根据目标集群进行一些修改。
- en: If you don't have Helm already installed on your laptop, you can install it
    by following the instructions at the project's website: [https://docs.helm.sh/using_helm/#installing-helm](https://docs.helm.sh/using_helm/#installing-helm).
    Once you have the command-line client on your local system, you can bootstrap
    the rest.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的笔记本电脑上尚未安装Helm，可以按照项目网站上的说明进行安装：[https://docs.helm.sh/using_helm/#installing-helm](https://docs.helm.sh/using_helm/#installing-helm)。一旦在本地系统上安装了命令行客户端，您就可以启动其余的工作。
- en: 'The first step will be to install Helm onto your cluster and update the repositories.
    This is accomplished by running two commands:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将Helm安装到您的集群并更新存储库。这可以通过运行两个命令来完成：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output will be very minimal, showing something akin to the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将非常简洁，类似于以下内容：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Tiller, as it mentions, is the server-side component of Helm, and it is responsible
    for coordinating the installations invoked from the `helm` command-line tool.
    By default, `helm init` will install Tiller into the `kube-system` namespace,
    so you can see it in your cluster using the following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如它提到的那样，Tiller是Helm的服务器端组件，负责协调从`helm`命令行工具调用的安装。默认情况下，`helm init`将Tiller安装到`kube-system`命名空间中，因此您可以使用以下命令在集群中查看它：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once it''s in the state `Running`, it is a good idea to get the latest repository
    index loaded. It comes with a number of charts already installed, but the charts
    do get updated fairly regularly, and this will ensure that you have the latest
    charts:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦处于`Running`状态，最好加载最新的存储库索引。它已经安装了许多图表，但是图表会定期更新，这将确保您拥有最新的图表：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The update process is usually pretty fast, returning something like the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 更新过程通常非常快，返回类似以下内容：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `"stable" chart repository` that it's mentioning is the one hosted on GitHub
    at the Kubernetes project: [https://github.com/kubernetes/charts](https://github.com/kubernetes/charts).
    Within that repository, there is a `stable` directory that includes all the charts.
    If you use the command `helm search`, it will display a list of charts and the
    relevant versions, which matches with the GitHub repository.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 它提到的“stable”图表存储库是托管在GitHub上的Kubernetes项目的一个：[https://github.com/kubernetes/charts](https://github.com/kubernetes/charts)。在该存储库中，有一个包含所有图表的`stable`目录。如果您使用`helm
    search`命令，它将显示图表和相关版本的列表，与GitHub存储库匹配。
- en: 'Using the `helm search jenkins` command will show you the target we''ll be
    using:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`helm search jenkins`命令将显示我们将要使用的目标：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that charts have a chart version as well as a reported *app version*. Many
    charts wrap existing opensource projects, and the charts are maintained separately
    from the systems they deploy. Charts within the `stable` repository at the Kubernetes
    project strive to be examples of how to build charts as well as to be useful to
    the community at large. In this case, the chart version is `0.14.1`, and it is
    reported to be deploying Jenkins version `2.73`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，图表除了报告的*应用程序版本*外，还有图表版本。许多图表包装现有的开源项目，并且图表与它们部署的系统分开维护。Kubernetes项目中的`stable`存储库中的图表力求成为构建图表的示例，并且对整个社区有用。在这种情况下，图表版本是`0.14.1`，并且报告部署Jenkins版本为`2.73`。
- en: 'You can get more details on the specific chart using the `helm inspect` command,
    for example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`helm inspect`命令获取有关特定图表的更多详细信息，例如：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will show you a large amount of output, starting with the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向您显示大量的输出，从以下内容开始：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The very top is the information that goes into the chart repository index and
    what is used to provide the results from the `helm search` commands, and the section
    after that is the configuration options that the chart supports.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部是输入图表存储库索引的信息，用于提供`helm search`命令的结果，之后的部分是图表支持的配置选项。
- en: Most charts strive to have and use good defaults, but expect that you might
    provide overridden values where appropriate. In the case of deploying Jenkins
    into Minikube, we will want to do just that, as the default `values.yaml` that
    the chart uses expects to use a `LoadBalancer`, which Minikube doesn't support.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数图表都力求具有并使用良好的默认值，但是预期您可能会在适当的地方提供覆盖的值。在将Jenkins部署到Minikube的情况下，我们将要这样做，因为图表使用的默认`values.yaml`期望使用`LoadBalancer`，而Minikube不支持。
- en: You can see the full details of `values.yaml` in the extended output of `helm
    inspect`. Before you install anything with Helm, it is a good idea to see what
    it is doing on your behalf, and what values it offers for configuration.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`helm inspect`的扩展输出中查看`values.yaml`的完整详细信息。在使用Helm安装任何内容之前，最好看看它代表您做了什么，以及它提供了哪些配置值。
- en: 'We will create a small `yaml` file to override just one of the defaults: `Master.ServiceType`.
    If you scan through the output of the `helm inspect` command, you will see a reference
    to changing this to install on Minikube.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个小的`yaml`文件来覆盖默认值之一：`Master.ServiceType`。如果您扫描`helm inspect`命令的输出，您将看到将其更改以在Minikube上安装的引用。
- en: 'Create a `jenkins.yaml` file with the following content:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`jenkins.yaml`的文件，内容如下：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we can see what Helm will create when we ask it to install, using the
    options `--dry-run` and `--debug` to get detailed output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到当我们要求其安装时Helm将创建什么，使用`--dry-run`和`--debug`选项获取详细输出：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Running this command will dump a lot of information to your Terminal screen,
    the rendered manifests of everything that Helm would install on your behalf. You
    can see the deployments, secrets, configmaps, and services.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将向您的终端屏幕转储大量信息，即Helm将代表您安装的所有内容的呈现清单。您可以看到部署、秘密、配置映射和服务。
- en: 'You can start the installation process by running that exact same command,
    minus the `--dry-run` and `--debug` options:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行完全相同的命令来开始安装过程，减去`--dry-run`和`--debug`选项：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will provide you with a list of all the Kubernetes objects that it has
    created, and then some notes:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您提供它创建的所有Kubernetes对象的列表，然后是一些注释：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The notes that are generated are rendered as a template and generally provide
    instructions for how to access the service. You can always get this same information
    repeated to you using the `helm status` command.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的注释被呈现为模板，并通常提供有关如何访问服务的说明。您始终可以使用`helm status`命令重复获取相同的信息。
- en: 'When we invoked Helm, we named this `release j` to keep it short and simple.
    To get information about the current state of this release, use the following
    command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用Helm时，我们将此命名为`release j`以使其简短和简单。要获取有关此版本当前状态的信息，请使用以下命令：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is a fairly large installation and it will take a while to install. You
    can watch the events that roll out from this installation using a command such
    as `kubectl get events -w`. This will update events as the deployment progresses,
    with output looking something like the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当大的安装，安装需要一段时间。您可以使用诸如`kubectl get events -w`之类的命令观看从此安装中滚出的事件。这将随着部署的进行而更新事件，输出看起来类似于以下内容：
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Once the deployment is fully available, you can start to access it using the
    instructions in the notes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署完全可用，您可以开始使用注释中的说明访问它。
- en: Accessing Jenkins
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问Jenkins
- en: 'The chart and images together make some secrets as the deployment is progressing
    to hold things such as the password to access Jenkins. The notes include a command
    to use to get this password from Kubernetes and display it on your Terminal:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图表和图像一起制作一些秘密，因为部署正在进行中，以保存诸如访问Jenkins的密码之类的东西。注释包括一个命令，用于从Kubernetes获取此密码并在您的终端上显示它：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run that command and copy the output, as we''ll need it to log in to your instance
    of Jenkins. The next commands tell you how to get a URL to access Jenkins. You
    can use those commands to get the information and open a browser to access Jenkins.
    If you deployed this to Minikube, you can also use Minikube to open a browser
    window for the relevant service:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该命令并复制输出，因为我们需要它来登录到您的Jenkins实例。接下来的命令告诉您如何获取访问Jenkins的URL。您可以使用这些命令获取信息并打开浏览器访问Jenkins。如果您将其部署到Minikube，还可以使用Minikube打开相关服务的浏览器窗口：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The first page will provide you with a request for credentials. Use `admin`
    as the username and the password that you read in the preceding command:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 第一页将为您提供凭据请求。使用`admin`作为用户名和您在前面命令中读取的密码：
- en: '![](assets/e3fafc03-9858-4270-bfa6-e33828d6519e.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e3fafc03-9858-4270-bfa6-e33828d6519e.png)'
- en: 'Then, logging in should provide you with administrative access to Jenkins:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，登录应该为您提供对Jenkins的管理访问权限：
- en: '![](assets/1cdf14f1-5fdf-48be-ad3b-4fbf3b4cd0bb.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1cdf14f1-5fdf-48be-ad3b-4fbf3b4cd0bb.png)'
- en: Updating Jenkins
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新Jenkins
- en: 'When you connect, and in the preceding example, you may see a menu item in
    red with a number. This is how Jenkins alerts you to things that you should consider
    immediately updating. I highly recommend that you click on the number and review
    what it''s presenting:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当您连接时，在前面的示例中，您可能会看到一个红色菜单项和一个数字。这是Jenkins提醒您应立即考虑更新的方式。我强烈建议您单击该数字并查看它所呈现的内容：
- en: '![](assets/51ee8772-f058-4a34-b1ca-41d41c6928bf.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/51ee8772-f058-4a34-b1ca-41d41c6928bf.png)'
- en: While the charts and base images are maintained, updates or considerations that
    can't be determined in advance can become available. Plugins to Jenkins, in particular,
    can get updated, and Jenkins reviews the existing plugins for possible updates.
    You can click on the buttons on this page to run the updates, restart Jenkins,
    or learn more about its suggestions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然图表和基本图像是维护的，但无法提前确定的更新或考虑因素可能会变得可用。特别是，Jenkins的插件可能会得到更新，并且Jenkins会审查现有的插件以进行可能的更新。您可以单击此页面上的按钮来运行更新，重新启动Jenkins，或了解更多关于其建议的信息。
- en: The Jenkins chart includes a `persistent-volume-claim` where plugin updates
    are stored, so unless you disabled it, you can safely load updates to the Jenkins
    plugins and tell it to restart itself to have those plugin updates take effect.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins图表包括一个`persistent-volume-claim`，用于存储插件更新，因此，除非您禁用它，您可以安全地加载Jenkins插件的更新，并告诉它重新启动以使这些插件更新生效。
- en: Example pipeline
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例管道
- en: One of the benefits to this install is that jobs you create can run pipelines
    that completely build and run within the Kubernetes cluster. Pipelines can be
    defined as something you build using the tooling within Jenkins, you can enter
    them directly, or you can load them from source control.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 安装的一个好处是，您创建的作业可以运行完全在Kubernetes集群内构建和运行的管道。管道可以被定义为您在Jenkins内部使用工具构建的东西，您可以直接输入它们，或者您可以从源代码控制中加载它们。
- en: The example code for the Python/Flask application has a basic Jenkinsfile to
    show you how this can work. The Jenkinsfile was added to the 0.7.0 branch, and
    you can view it online at [https://github.com/kubernetes-for-developers/kfd-flask/blob/0.7.0/Jenkinsfile](https://github.com/kubernetes-for-developers/kfd-flask/blob/0.7.0/Jenkinsfile).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Python/Flask应用程序的示例代码具有基本的Jenkinsfile，以向您展示这如何工作。 Jenkinsfile已添加到0.7.0分支，您可以在[https://github.com/kubernetes-for-developers/kfd-flask/blob/0.7.0/Jenkinsfile](https://github.com/kubernetes-for-developers/kfd-flask/blob/0.7.0/Jenkinsfile)上在线查看。
- en: The pipeline is set up to be used from source control, build a Docker image,
    and interact with Kubernetes. The example does not push the image to a repository
    or deploy the image, following the same pattern as the previous Travis.CI example.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 管道设置为从源代码控制中使用，构建Docker镜像，并与Kubernetes交互。示例不会将图像推送到存储库或部署图像，与之前的Travis.CI示例遵循相同的模式。
- en: 'To enable this example in your instance of Jenkins, you will want to navigate
    to the front page of Jenkins and select New Item. From there, select Multibranch
    Pipeline and name the job `kfd-flask-pipeline`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Jenkins的实例中启用此示例，您需要导航到Jenkins的首页并选择New Item。然后，选择Multibranch Pipeline并将作业命名为`kfd-flask-pipeline`：
- en: '![](assets/6f374ec3-fe39-4455-b37f-6ea631365d5e.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6f374ec3-fe39-4455-b37f-6ea631365d5e.png)'
- en: 'Once created, the critical item to enter is the location of content from source
    control. You can enter `https://github.com/kubernetes-for-developers/kfd-flask`
    to use this example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，输入的关键项目是来自源代码控制的内容位置。您可以输入`https://github.com/kubernetes-for-developers/kfd-flask`来使用此示例：
- en: '![](assets/5e672215-e2bc-44c9-90e6-b3bee02439b9.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5e672215-e2bc-44c9-90e6-b3bee02439b9.png)'
- en: Save the configuration, and it should build the example, reaching out to GitHub,
    getting the pipeline, and then configuring it and running it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 保存配置，它应该构建示例，连接到GitHub，获取管道，然后配置并运行它。
- en: 'Loading the various images can take quite a bit of time, and once it is complete
    the results will be available in Jenkins:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 加载各种图像可能需要相当长的时间，一旦完成，结果将在Jenkins中可用：
- en: '![](assets/bad25e3c-e8af-4fe0-a602-092d2ca7d17e.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bad25e3c-e8af-4fe0-a602-092d2ca7d17e.png)'
- en: In the pipeline example, it checks out from source control, builds a new Docker
    image with a tag name based on the branch and `git commit`, and then later interacts
    with Kubernetes to show you the list of current pods active in the cluster in
    which its running.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道示例中，它从源代码控制中检出，使用基于分支和`git commit`的标签名称构建新的Docker镜像，然后与Kubernetes交互，向您显示正在运行的集群中当前活动的Pod的列表。
- en: Jenkins has the same needs as our Travis.CI example, such as changing the manifests
    to run a complete sequence, and this is something you can solve by using Helm
    or perhaps ksonnet to build onto the preceding example.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins与我们的Travis.CI示例有相同的需求，例如更改清单以运行完整的序列，您可以通过使用Helm或者ksonnet来构建前面的示例来解决这个问题。
- en: Next steps with pipelines
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道的下一步
- en: 'The full extent of what you can do with Jenkins pipelines is beyond what we
    can cover here, but the full documentation for both pipelines and the Kubernetes
    plugin additions is available online:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Jenkins管道做的事情远远超出了我们在这里可以涵盖的范围，但是管道和Kubernetes插件附加功能的完整文档都可以在线获得：
- en: '[https://jenkins.io/doc/book/pipeline/syntax/](https://jenkins.io/doc/book/pipeline/syntax/)
    provides documentation on the pipeline syntax, how to write pipelines, and what
    options are built in by default.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://jenkins.io/doc/book/pipeline/syntax/](https://jenkins.io/doc/book/pipeline/syntax/)提供了有关管道语法、如何编写管道以及默认内置选项的文档。'
- en: '[https://github.com/jenkinsci/kubernetes-plugin](https://github.com/jenkinsci/kubernetes-plugin)
    offers details on what the Jenkins Kubernetes plugin does and how it operates,
    as well as including examples of how to use it with some sample pipelines at its
    GitHub repo: [https://github.com/jenkinsci/kubernetes-plugin/tree/master/examples](https://github.com/jenkinsci/kubernetes-plugin/tree/master/examples).'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/jenkinsci/kubernetes-plugin](https://github.com/jenkinsci/kubernetes-plugin)提供了Jenkins
    Kubernetes插件的详细信息以及其操作方式，还包括如何在GitHub存储库中使用一些示例管道的示例：[https://github.com/jenkinsci/kubernetes-plugin/tree/master/examples](https://github.com/jenkinsci/kubernetes-plugin/tree/master/examples)。'
- en: The general Jenkins documentation is very extensive, available at [https://jenkins.io/doc/](https://jenkins.io/doc/),
    along with more details about how to create and use a Jenkinsfile at [https://jenkins.io/doc/book/pipeline/jenkinsfile/](https://jenkins.io/doc/book/pipeline/jenkinsfile/).
    A significant benefit to using a Jenkinsfile is that the declaration for what
    your pipelines should do can be stored alongside your code in source control.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般的Jenkins文档非常广泛，可在[https://jenkins.io/doc/](https://jenkins.io/doc/)找到，以及有关如何创建和使用Jenkinsfile的更多详细信息[https://jenkins.io/doc/book/pipeline/jenkinsfile/](https://jenkins.io/doc/book/pipeline/jenkinsfile/)。使用Jenkinsfile的一个重要好处是，您可以将管道应该执行的声明与源代码一起存储在源代码控制中。
- en: '[https://jenkins.io/doc/pipeline/steps/credentials-binding/](https://jenkins.io/doc/pipeline/steps/credentials-binding/)
    details one way to expose secrets and credentials so that you can use them within
    pipelines, for example, to push image updates to DockerHub, Quay, or your own
    private image repository.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://jenkins.io/doc/pipeline/steps/credentials-binding/](https://jenkins.io/doc/pipeline/steps/credentials-binding/)详细介绍了一种公开秘密和凭据的方法，以便您可以在流水线中使用它们，例如，将图像更新推送到DockerHub、Quay或您自己的私有图像存储库。'
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we delved into how to use Kubernetes when testing your code.
    We looked at the patterns you might explore with integration testing. We pointed
    at a simple example of using shell scripts to run integration tests within Kubernetes,
    and then dove more deeply into examples using Python and Node.js that run integration
    tests using Kubernetes. Finally, we wrapped up the chapter with an overview of
    options that are readily available for continuous integration that can use a cluster,
    and explored two options: using Travis.CI as a hosted solution and how to use
    Jenkins on your own Kubernetes cluster.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了在测试代码时如何使用Kubernetes。我们研究了您可能在集成测试中探索的模式。我们指出了使用shell脚本在Kubernetes中运行集成测试的简单示例，然后更深入地探讨了使用Python和Node.js的示例，这些示例使用Kubernetes运行集成测试。最后，我们总结了本章，概述了可以使用集群的持续集成的可用选项，并探讨了两个选项：使用Travis.CI作为托管解决方案以及如何在自己的Kubernetes集群上使用Jenkins。
- en: In the next chapter, we will look at how we can pull together multiple pieces
    that we have explored and show how to benchmark your code running on Kubernetes.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何将我们探索过的多个部分汇集在一起，并展示如何在Kubernetes上运行代码的基准测试。
