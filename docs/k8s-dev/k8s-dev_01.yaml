- en: Setting Up Kubernetes for Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为开发设置Kubernetes
- en: 'Welcome to *Kubernetes for Developers*! This chapter starts off by helping
    you get the tools installed that will allow you to take advantage of Kubernetes
    in your development. Once installed, we will interact with those tools a bit to
    verify that they are functional. Then, we will review some of the basic concepts
    that you will want to understand to effectively use Kubernetes as a developer.
    We will cover the following key resources in Kubernetes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到*面向开发人员的Kubernetes*！本章首先将帮助您安装工具，以便您可以在开发中充分利用Kubernetes。安装完成后，我们将与这些工具进行一些交互，以验证它们是否正常工作。然后，我们将回顾一些您作为开发人员想要了解的基本概念，以有效地使用Kubernetes。我们将介绍Kubernetes中的以下关键资源：
- en: Container
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: Pod
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod
- en: Node
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点
- en: Deployment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署
- en: ReplicaSet
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副本集
- en: What you need for development
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发所需的工具
- en: In addition to your usual editing and programming tools, you will want to install
    the software to leverage Kubernetes. The focus of this book is to let you do everything
    on your local development machine, while also allowing you to expand and leverage
    a remote Kubernetes cluster in the future if you need more resources. One of Kubernetes'
    benefits is how it treats one or one hundred computers in the same fashion, allowing
    you to take advantage of the resources you need for your software, and do it consistently,
    regardless of where they're located.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了您通常使用的编辑和编程工具之外，您还需要安装软件来利用Kubernetes。本书的重点是让您可以在本地开发机器上完成所有操作，同时也可以在将来如果需要更多资源，扩展和利用远程Kubernetes集群。Kubernetes的一个好处是它以相同的方式处理一个或一百台计算机，让您可以利用您软件所需的资源，并且无论它们位于何处，都可以一致地进行操作。
- en: 'The examples in this book will use command-line tools in a Terminal on your
    local machine. The primary one will be `kubectl`, which communicates with a Kubernetes
    cluster. We will use a tiny Kubernetes cluster of a single machine running on
    your own development system with Minikube. I recommend installing the community
    edition of Docker, which makes it easy to build containers for use within Kubernetes:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例将使用本地机器上终端中的命令行工具。主要的工具将是`kubectl`，它与Kubernetes集群通信。我们将使用Minikube在您自己的开发系统上运行的单台机器的微型Kubernetes集群。我建议安装Docker的社区版，这样可以轻松地构建用于Kubernetes内部的容器：
- en: '`kubectl`: `kubectl` (how to pronounce that is an amusing diversion within
    the Kubernetes community) is the primary command-line tool that is used to work
    with a Kubernetes cluster. To install `kubectl`, go to the page [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
    and follow the instructions relevant to your platform.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl`：`kubectl`（如何发音是Kubernetes社区内一个有趣的话题）是用于与Kubernetes集群一起工作的主要命令行工具。要安装`kubectl`，请访问页面[https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)并按照适用于您平台的说明进行操作。'
- en: '`minikube`: To install Minikube, go to the page [https://github.com/kubernetes/minikube/releases](https://github.com/kubernetes/minikube/releases)
    and follow the instructions for your platform.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minikube`：要安装Minikube，请访问页面[https://github.com/kubernetes/minikube/releases](https://github.com/kubernetes/minikube/releases)并按照适用于您平台的说明进行操作。'
- en: '`docker`: To install the community edition of Docker, go to the webpage [https://www.docker.com/community-edition](https://www.docker.com/community-edition)
    and follow their instructions for your platform.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker`：要安装Docker的社区版，请访问网页[https://www.docker.com/community-edition](https://www.docker.com/community-edition)并按照适用于您平台的说明进行操作。'
- en: Optional tools
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选工具
- en: In addition to `kubectl`, `minikube`, and `docker`, you may want to take advantage
    of additional helpful libraries and command-line tools.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`kubectl`、`minikube`和`docker`之外，您可能还想利用其他有用的库和命令行工具。
- en: '`jq` is a command-line JSON processor that makes it easy to parse results in
    more complex data structures. I would describe it as *grep''s cousin that''s better
    at dealing with JSON results*. You can install `jq` by following the instructions
    at [https://stedolan.github.io/jq/download/.](https://stedolan.github.io/jq/download/)
    More details on what `jq` does and how to use it can also be found at [https://stedolan.github.io/jq/manual/](https://stedolan.github.io/jq/manual/).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`jq`是一个命令行JSON处理器，它可以轻松解析更复杂的数据结构中的结果。我会将其描述为*更擅长处理JSON结果的grep表亲*。您可以按照[https://stedolan.github.io/jq/download/](https://stedolan.github.io/jq/download/)上的说明安装`jq`。关于`jq`的详细信息以及如何使用它也可以在[https://stedolan.github.io/jq/manual/](https://stedolan.github.io/jq/manual/)上找到。'
- en: Getting a local cluster up and running
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动本地集群
- en: Once Minikube and Kubectl are installed, get a cluster up and running. It is
    worthwhile to know the versions of the tools you're using, as Kubernetes is a
    fairly fast-moving project, and if you need to get assistance from the community,
    knowing which versions of these common tools will be important.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Minikube和Kubectl安装完成，就可以启动一个集群。值得知道你正在使用的工具的版本，因为Kubernetes是一个发展迅速的项目，如果需要从社区获得帮助，知道这些常用工具的版本将很重要。
- en: 'The versions of Minikube and `kubectl` I used while writing this are:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我在撰写本文时使用的Minikube和`kubectl`的版本是：
- en: 'Minikube: version 0.22.3'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minikube：版本0.22.3
- en: '`kubectl`: version 1.8.0'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl`：版本1.8.0'
- en: 'You can check the version of your copy with the following commands:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令检查您的副本的版本：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will output a version:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出一个版本：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you haven''t already done so while following the installation instructions,
    start a Kubernetes with Minikube. The simplest way is using the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在按照安装说明操作时还没有这样做，请使用Minikube启动Kubernetes。最简单的方法是使用以下命令：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will download a virtual machine image and start it, and Kubernetes on
    it, as a single-machine cluster. The output will look something like the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载一个虚拟机映像并启动它，以及在其上的Kubernetes，作为单机集群。输出将类似于以下内容：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Minikube will automatically create the files needed for `kubectl` to access
    the cluster and control it. Once this is complete, you can get information about
    the cluster to verify it is up and running.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube将自动创建`kubectl`访问集群和控制集群所需的文件。完成后，可以获取有关集群的信息以验证其是否正在运行。
- en: 'First, you can ask `minikube` about its status directly:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以直接询问`minikube`关于其状态：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And if we ask `kubectl` about its version, it will report both the version
    of the client and the version of the cluster that it is communicating with:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们询问`kubectl`关于其版本，它将报告客户端的版本和正在通信的集群的版本：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first output is the version of the `kubectl` client:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个输出是`kubectl`客户端的版本：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Immediately after, it will communicate and report the version of Kubernetes
    on your cluster:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 立即之后，它将通信并报告集群上Kubernetes的版本：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And we can use `kubectl` to ask for information about the cluster as well:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`kubectl`来请求有关集群的信息：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And see something akin to the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后会看到类似以下的内容：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This command primarily lets you know the API server that you''re communicating
    with is up and running. We can ask for the specific status of the key internal
    components using an additional command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令主要让您知道您正在通信的API服务器是否正在运行。我们可以使用附加命令来请求关键内部组件的特定状态：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Kubernetes also reports and stores a number of events that you can request
    to see. These show what is happening within the cluster:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes还报告并存储了许多事件，您可以请求查看这些事件。这些显示了集群内部发生的情况：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Resetting and restarting your cluster
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置和重新启动您的集群
- en: 'If you want to wipe out your local Minikube cluster and restart, it is very
    easy to do so. Issuing a command to `delete` and then `start` Minikube will wipe
    out the environment and reset it to a blank slate:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想清除本地Minikube集群并重新启动，这是非常容易做到的。发出一个`delete`命令，然后`start` Minikube将清除环境并将其重置为一个空白状态：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Looking at what's built-in and included with Minikube
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看Minikube内置和包含的内容
- en: 'With Minikube, you can bring up a web-based dashboard for the Kubernetes cluster
    with a single command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Minikube，您可以通过一个命令为Kubernetes集群启动基于Web的仪表板：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will open a browser and show you a web interface to the Kubernetes cluster.
    If you look at the URL address in the browser window, you'll see that it's pointing
    to the same IP address that was returned from the `kubectl cluster-info` command
    earlier, running on port `30000`. The dashboard is running inside Kubernetes,
    and it is not the only thing that is.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个浏览器，并显示一个Kubernetes集群的Web界面。如果您查看浏览器窗口中的URL地址，您会发现它指向之前从`kubectl cluster-info`命令返回的相同IP地址，运行在端口`30000`上。仪表板在Kubernetes内部运行，并且它不是唯一的运行在其中的东西。
- en: 'Kubernetes is self-hosting, in that supporting pieces for Kubernetes to function
    such as the dashboard, DNS, and more, are all run within Kubernetes. You can see
    the state of all these components by asking about the state of all Pods in the
    cluster:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是自托管的，支持Kubernetes运行的支持组件，如仪表板、DNS等，都在Kubernetes内部运行。您可以通过查询集群中所有Pod的状态来查看所有这些组件的状态：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that we used the `--all-namespaces` option in this command. By default,
    `kubectl` will only show you Kubernetes resources that are in the default namespace.
    Since we haven't run anything ourselves, if we invoked `kubectl get pods` we would
    just get an empty list. Pods aren't the only Kubernetes resources through; you
    can ask about quite a number of different resources, some of which I'll describe
    later in this chapter, and more in further chapters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此命令中我们使用了`--all-namespaces`选项。默认情况下，`kubectl`只会显示位于默认命名空间中的Kubernetes资源。由于我们还没有运行任何东西，如果我们调用`kubectl
    get pods`，我们将只会得到一个空列表。Pod并不是唯一的Kubernetes资源；您可以查询许多不同的资源，其中一些我将在本章后面描述，更多的将在后续章节中描述。
- en: 'For the moment, invoke one more command to get the list of services:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时，再调用一个命令来获取服务列表：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will output all the services:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出所有服务：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the service named `kubernetes-dashboard` has a `Cluster-IP` value, and
    the ports `80:30000`. That port configuration is indicating that within the Pods
    that are backing the `kubernetes-dashboard` service, it will forward any requests
    from port `30000` to port `80` within the container. You may have noticed that
    the IP address for the Cluster IP is very different from the IP address reported
    for the Kubernetes master that we saw previously in the `kubectl cluster-info`
    command.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意名为`kubernetes-dashboard`的服务具有`Cluster-IP`值和端口`80:30000`。该端口配置表明，在支持`kubernetes-dashboard`服务的Pod中，它将把来自端口`30000`的任何请求转发到容器内的端口`80`。您可能已经注意到，Cluster
    IP的IP地址与我们之前在`kubectl cluster-info`命令中看到的Kubernetes主节点报告的IP地址非常不同。
- en: It is important to know that everything within Kubernetes is run on a private,
    isolated network that is not normally accessible from outside the cluster. We
    will get into more detail on this in future chapters. For now, just be aware that
    `minikube` has some additional, special configuration within it to expose the
    dashboard.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，Kubernetes中的所有内容都在一个私有的、隔离的网络上运行，通常无法从集群外部访问。我们将在未来的章节中更详细地介绍这一点。现在，只需知道`minikube`在其中有一些额外的特殊配置来暴露仪表板。
- en: Verifying Docker
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证Docker
- en: Kubernetes supports multiple ways of running containers, Docker being the most
    common, and the most convenient. In this book, we will use Docker to help us create
    images that we will run within Kubernetes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes支持多种运行容器的方式，Docker是最常见、最方便的方式。在本书中，我们将使用Docker来帮助我们创建在Kubernetes中运行的镜像。
- en: 'You can see what version of Docker you have installed and verify it is operational
    by running the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令来查看您安装的Docker版本并验证其是否可操作：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Like `kubectl`, it will report the `docker` client version as well as the server
    version, and your output may look something like the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 像`kubectl`一样，它将报告`docker`客户端版本以及服务器版本，您的输出可能看起来像以下内容：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'By using the `docker images` command, you can see what container images are
    available locally, and using the `docker pull` command, you can request specific
    images. In our examples in the next chapter, we will be building upon the alpine
    container image to host our software, so let''s go ahead and pull that image to
    verify that your environment is working:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`docker images`命令，您可以查看本地可用的容器镜像，并使用`docker pull`命令，您可以请求特定的镜像。在下一章的示例中，我们将基于alpine容器镜像构建我们的软件，因此让我们继续拉取该镜像以验证您的环境是否正常工作：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can then see the images using the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用以下命令查看镜像：
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you get an error when trying to pull the alpine image, it may mean that you
    are required to work through a proxy, or otherwise have constrained access to
    the internet to pull images as you need. You may need to review Docker's information
    on how to set up and use a proxy if you are in this situation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在尝试拉取alpine镜像时出现错误，这可能意味着您需要通过代理工作，或者以其他方式受限制地访问互联网以满足您的镜像需求。如果您处于这种情况，您可能需要查看Docker关于如何设置和使用代理的信息。
- en: Clearing and cleaning Docker images
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除和清理Docker镜像
- en: 'Since we will be using Docker to build container images, it will be useful
    to know how to get rid of images. You have already seen the list of images with
    the `docker image` command. There are also intermediate images that are maintained
    by Docker that are hidden in that output. To see all the images that Docker is
    storing, use the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用Docker来构建容器镜像，了解如何摆脱镜像将是有用的。您已经使用`docker image`命令看到了镜像列表。还有一些由Docker维护的中间镜像在输出中是隐藏的。要查看Docker存储的所有镜像，请使用以下命令：
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you have only pulled the alpine image as per the preceding text, you likely
    won't see any additional images, but as you build images in the next chapter,
    this list will grow.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只按照前文拉取了alpine镜像，可能不会看到任何其他镜像，但在下一章中构建镜像时，这个列表将会增长。
- en: You can remove images with the `docker rmi` command followed by the name of
    the image. By default, Docker will attempt to maintain images that containers
    have used recently or referenced. Because of this, you may need to force the removal
    to clean up the images.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker rmi`命令后跟镜像的名称来删除镜像。默认情况下，Docker将尝试维护容器最近使用或引用的镜像。因此，您可能需要强制删除以清理镜像。
- en: 'If you want to reset and remove all the images and start afresh, there is a
    handy command that will do that. By tying together Docker images and `docker rmi`,
    we can ask it to force remove all the images it knows about:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想重置并删除所有镜像并重新开始，有一个方便的命令可以做到。通过结合Docker镜像和`docker rmi`，我们可以要求它强制删除所有已知的镜像：
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Kubernetes concept – container
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes概念 - 容器
- en: Kubernetes (and other technologies in this space) are all about managing and
    orchestrating containers. A container is really a name wrapped around a set of
    Linux technologies, the two most prominent being the container image format and
    the way Linux can isolate processes from one another, leveraging cgroups.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes（以及这个领域中的其他技术）都是关于管理和编排容器的。容器实际上是一个包裹了一系列Linux技术的名称，其中最突出的是容器镜像格式和Linux如何隔离进程，利用cgroups。
- en: For all practical purposes, when someone is speaking of a container, they are
    generally implying that there is an image with everything needed to run a single
    process. In this context, a container is not only the image, but also the information
    about what to invoke and how to run it. Containers also act like they have their
    own network access. In reality, it's being shared by the Linux operating system
    that's running the containers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际情况下，当有人谈论容器时，他们通常意味着有一个包含运行单个进程所需的一切的镜像。在这种情况下，容器不仅是镜像，还包括关于如何调用和运行它的信息。容器还表现得好像它们有自己的网络访问权限。实际上，这是由运行容器的Linux操作系统共享的。
- en: When we want to write code to run under Kubernetes, we will always be talking
    about packaging it up and preparing it to run within a container. The more complex
    examples later in the book will utilize multiple containers all working together.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要编写在Kubernetes下运行的代码时，我们总是在谈论将其打包并准备在容器内运行。本书后面更复杂的示例将利用多个容器一起工作。
- en: It is quite possible to run more than a single process inside a container, but
    that's generally frowned upon as a container is ideally suited to represent a
    single process and how to invoke it, and shouldn't be considered the same thing
    as a full virtual machine.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内运行多个进程是完全可能的，但这通常被视为不好的做法，因为容器理想上适合表示单个进程以及如何调用它，并且不应被视为完整虚拟机的同一物体。
- en: If you usually develop in Python, then you are likely familiar with using something
    like `pip` to download libraries and modules that you need, and you invoke your
    program with a command akin to `python your_file`. If you're a Node developer,
    then it is more likely you're familiar with `npm` or `yarn` to install the dependencies
    you need, and you run your code with `node your_file`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通常使用Python进行开发，那么你可能熟悉使用类似`pip`的工具来下载你需要的库和模块，并使用类似`python your_file`的命令来调用你的程序。如果你是Node开发人员，那么你更可能熟悉使用`npm`或`yarn`来安装你需要的依赖，并使用`node
    your_file`来运行你的代码。
- en: If you wanted to wrap that all up and run it on another machine, you would likely
    either redo all the instructions for downloading the libraries and running the
    code, or perhaps ZIP up the whole directory and move it where you want to run
    it. A container is a way to collect all the information together into a single
    image so that it can be easily moved around, installed, and run on a Linux operating
    system. Originally created by Docker, the specifications are now maintained by
    the **Open Container Initiative** (**OCI**) ([https://www.opencontainers.org](https://www.opencontainers.org)).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想把所有这些打包起来，在另一台机器上运行，你可能要重新执行所有下载库和运行代码的指令，或者可能将整个目录压缩成ZIP文件，然后将其移动到想要运行的地方。容器是一种将所有信息收集到单个镜像中的方式，以便可以轻松地移动、安装和在Linux操作系统上运行。最初由Docker创建，现在由**Open
    Container Initiative**（**OCI**）（[https://www.opencontainers.org](https://www.opencontainers.org)）维护规范。
- en: While a container is the smallest building block of what goes into Kubernetes,
    the smallest unit that Kubernetes works with is a Pod.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然容器是Kubernetes中的最小构建块，但Kubernetes处理的最小单位是Pod。
- en: Kubernetes resource – Pod
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes资源 - Pod
- en: A Pod is the smallest unit that Kubernetes manages and is the fundamental unit
    that the rest of the system is built on. The team that created Kubernetes found
    it worthwhile to let a developer specify what processes should always be run together
    on the same OS, and that the combination of processes running together should
    be the unit that's scheduled, run, and managed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Pod是Kubernetes管理的最小单位，也是系统其余部分构建在其上的基本单位。创建Kubernetes的团队发现让开发人员指定应始终在同一操作系统上运行的进程，并且应该一起运行的进程组合应该是被调度、运行和管理的单位是值得的。
- en: Earlier in this chapter, you saw that a basic instance of Kubernetes has some
    of its software running in Pods. Much of Kubernetes is run using these same concepts
    and abstractions, allowing Kubernetes to self-host its own software. Some of the
    software to run a Kubernetes cluster is managed outside the cluster itself, but
    more and more leverage the concept of Pods, including the DNS services, dashboard,
    and controller manager, which coordinate all the control operations through Kubernetes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，您看到Kubernetes的一个基本实例有一些软件在Pod中运行。Kubernetes的许多部分都是使用这些相同的概念和抽象来运行的，这使得Kubernetes能够自托管其自己的软件。一些用于运行Kubernetes集群的软件是在集群之外管理的，但越来越多地利用了Pod的概念，包括DNS服务、仪表板和控制器管理器，它们通过Kubernetes协调所有的控制操作。
- en: A Pod is made up of one or more containers and information associated with those
    containers. When you ask Kubernetes about a Pod, it will return a data structure
    that includes a list of one or more containers, along with a variety of metadata
    that Kubernetes uses to coordinate the Pod with other Pods, and policies of how
    Kubernetes should act and react if the program fails, is asked to be restarted,
    and so forth. The metadata can also define things such as *affinity*, which influences
    where a Pod can be scheduled in a cluster, expectations around how to get the
    container images, and more. It is important to know that a Pod is not intended
    to be treated as a durable, long-lived entity.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Pod由一个或多个容器以及与这些容器相关的信息组成。当您询问Kubernetes有关一个Pod时，它将返回一个数据结构，其中包括一个或多个容器的列表，以及Kubernetes用来协调Pod与其他Pod以及Kubernetes应该如何在程序失败时采取行动的各种元数据。元数据还可以定义诸如*亲和性*之类的东西，影响Pod在集群中可以被调度的位置，以及如何获取容器镜像等期望。重要的是要知道，Pod不打算被视为持久的、长期存在的实体。
- en: They are created and destroyed and essentially meant to be ephemeral. This allows
    separate logic—contained in controllers - to manage responsibilities such as scale
    and availability. It is this separation of duties that enables Kubernetes to provide
    a means for self-healing in the event of failures, and provide some auto-scaling
    capabilities.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被创建和销毁，本质上是短暂的。这允许单独的逻辑 - 包含在控制器中 - 来管理规模和可用性等责任。正是这种分工的分离使得Kubernetes能够在发生故障时提供自我修复的手段，并提供一些自动扩展的能力。
- en: 'A Pod being run by Kubernetes has a few specific guarantees:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由Kubernetes运行的Pod具有一些特定的保证：
- en: All the containers for a Pod will be run on the same Node
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Pod中的所有容器将在同一节点上运行。
- en: Any container running within a Pod will share the Node's network with any other
    containers in the same Pod
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Pod中运行的任何容器都将与同一Pod中的其他容器共享节点的网络
- en: Containers within a Pod can share files through volumes, attached to the containers
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod中的容器可以通过挂载到容器的卷共享文件。
- en: A Pod has an explicit life cycle, and will always remain on the Node in which
    it was started
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Pod有一个明确的生命周期，并且始终保留在它启动的节点上。
- en: For all practical purposes, when you want to know what's running on a Kubernetes
    cluster, you are generally going to want to know about the Pods running within
    Kubernetes and their state.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，当您想要了解Kubernetes集群上运行的内容时，通常会想要了解Kubernetes中运行的Pod及其状态。
- en: Kubernetes maintains and reports on the Pod's status, as well as the state of
    each of the containers that make up the Pod. The states for a container are `Running`,
    `Terminated`, and `Waiting`. The life cycle of a Pod is a bit more complicated,
    consisting of a strictly defined Phase and a set of PodStatus. Phase is one of
    `Pending`, `Running`, `Succeeded`, `Failed`, or `Unknown`, and the specific details
    of what's included in a Phase is documented at [https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes维护并报告Pod的状态，以及组成Pod的每个容器的状态。容器的状态包括`Running`、`Terminated`和`Waiting`。Pod的生命周期稍微复杂一些，包括严格定义的阶段和一组PodStatus。阶段包括`Pending`、`Running`、`Succeeded`、`Failed`或`Unknown`，阶段中包含的具体细节在[https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase)中有文档记录。
- en: A Pod can also contain Probes, which actively check the container for some status
    information. Two common probes that are deployed and used by Kubernetes controllers
    are a `livenessProbe` and a `readinessProbe`. The livenessProbe defines whether
    the container is up and running. If it isn't, the infrastructure in Kubernetes
    kills the relevant container and then applies the restart policy defined for the
    Pod. The `readinessProbe` is meant to indicate whether the container is ready
    to service requests. The results of the `readinessProbe` are used in conjunction
    with other Kubernetes mechanisms such as services (which we will detail later)
    to forward traffic to the relevant container. In general, the probes are set up
    to allow the software in a container to provide a feedback loop to Kubernetes.
    You can find more detail on Probes, how to define them, and how they are used
    at [https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes).
    We will dig into probes in detail in a future chapter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Pod还可以包含探针，用于主动检查容器的某些状态信息。Kubernetes控制器部署和使用的两个常见探针是`livenessProbe`和`readinessProbe`。`livenessProbe`定义容器是否正在运行。如果没有运行，Kubernetes基础设施会终止相关容器，然后应用为Pod定义的重启策略。`readinessProbe`用于指示容器是否准备好提供服务请求。`readinessProbe`的结果与其他Kubernetes机制（稍后我们将详细介绍）一起使用，以将流量转发到相关容器。通常，探针被设置为允许容器中的软件向Kubernetes提供反馈循环。您可以在[https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes)找到有关探针的更多详细信息，如何定义它们以及它们的用途。我们将在未来的章节中详细讨论探针。
- en: Namespaces
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: Pods are collected into namespaces, which are used to group Pods together for
    a variety of purposes. You already saw one example of namespaces when we asked
    for the status of all the Pods in the cluster with the `--all-namespaces` option
    earlier.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Pod被收集到命名空间中，用于将Pod组合在一起以实现各种目的。在之前使用`--all-namespaces`选项请求集群中所有Pod的状态时，您已经看到了命名空间的一个示例。
- en: Namespaces can be used to provide quotas and limits around resource usage, have
    an impact on DNS names that Kubernetes creates internal to the cluster, and in
    the future may impact access control policies. If no namespace is specified when
    interacting with Kubernetes through `kubectl`, the command assumes you are working
    with the default namespace, named `default`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间可用于提供资源使用配额和限制，对Kubernetes在集群内部创建的DNS名称产生影响，并且在将来可能会影响访问控制策略。如果在通过`kubectl`与Kubernetes交互时未指定命名空间，则命令会假定您正在使用名为`default`的默认命名空间。
- en: Writing your code for Pods and Containers
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写您的Pods和容器的代码
- en: One of the keys to successfully using Kubernetes is to consider how you want
    your code to operate, and to structure it so that it fits cleanly into a structure
    of Pods and Containers. By structuring your software solutions to break problems
    down into components that operate with the constraints and guarantees that Kubernetes
    provides, you can easily take advantage of parallelism and container orchestration
    to use many machines as seamlessly as you would use a single machine.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 成功使用Kubernetes的关键之一是考虑您希望代码如何运行，并将其结构化，使其清晰地适应Pod和容器的结构。通过将软件解决方案结构化为将问题分解为符合Kubernetes提供的约束和保证的组件，您可以轻松地利用并行性和容器编排，以像使用单台机器一样无缝地使用多台机器。
- en: The guarantees and abstractions that Kubernetes provides are reflective of years
    of experience that Google (and others) have had in running their software and
    services at a massive scale, reliably, and redundantly, leveraging the pattern
    of horizontal scaling to tackle massive problems.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供的保证和抽象反映了Google（和其他公司）在以大规模、可靠和冗余的方式运行其软件和服务方面多年的经验，利用水平扩展的模式来解决重大问题。
- en: Kubernetes resource – Node
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes资源-节点
- en: A Node is a machine, typically running Linux, that has been added to the Kubernetes
    cluster. It can be a physical machine or a virtual machine. In the case of `minikube`,
    it is a single virtual machine that is running all the software for Kubernetes.
    In larger Kubernetes clusters, you may have one or several machines dedicated
    to just managing the cluster and separate machines where your workloads run. Kubernetes
    manages its resources across Nodes by tracking their resource usage, scheduling,
    starting (and if needed, restarting) Pods, as well as coordinating the other mechanisms
    that connect Pods together or expose them outside the cluster.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 节点是一台机器，通常运行Linux，已添加到Kubernetes集群中。它可以是物理机器或虚拟机。在`minikube`的情况下，它是一台运行Kubernetes所有软件的单个虚拟机。在较大的Kubernetes集群中，您可能有一台或多台专门用于管理集群的机器，以及单独的机器用于运行工作负载。Kubernetes通过跟踪节点的资源使用情况、调度、启动（如果需要，重新启动）Pod，以及协调连接Pod或在集群外部公开它们的其他机制来管理其资源。
- en: Nodes can (and do) have metadata associated with them so that Kubernetes can
    be aware of relevant differences, and can account for those differences when scheduling
    and running Pods. Kubernetes can support a wide variety of machines working together,
    and run software efficiently across all of them, or limit scheduling Pods to only
    machines that have the required resources (for example, a GPU).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 节点可以（而且确实）与它们关联的元数据，以便Kubernetes可以意识到相关的差异，并在调度和运行Pod时考虑这些差异。Kubernetes可以支持各种各样的机器共同工作，并在所有这些机器上高效运行软件，或者将Pod的调度限制在只有所需资源的机器上（例如，GPU）。
- en: Networks
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络
- en: We previously mentioned that all the containers in a Pod share the Node's network.
    In addition, all Nodes in a Kubernetes cluster are expected to be connected to
    each other and share a private cluster-wide network. When Kubernetes runs containers
    within a Pod, it does so within this isolated network. Kubernetes is responsible
    for handling IP addresses, creating DNS entries, and making sure that a Pod can
    communicate with another Pod in the same Kubernetes cluster.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，Pod中的所有容器共享节点的网络。此外，Kubernetes集群中的所有节点都应该相互连接并共享一个私有的集群范围网络。当Kubernetes在Pod中运行容器时，它是在这个隔离的网络中进行的。Kubernetes负责处理IP地址，创建DNS条目，并确保一个Pod可以与同一Kubernetes集群中的另一个Pod进行通信。
- en: Another resource, Services, which we will dig into later, is what Kubernetes
    uses to expose Pods to one another over this private network or handle connections
    in and out of the cluster. By default, a Pod running in this private, isolated
    network is not exposed outside of the Kubernetes cluster. Depending on how your
    Kubernetes cluster was created, there are multiple avenues for opening up access
    to your software from outside the cluster, which we'll detail later with Services
    that include LoadBalancer, NodePort, and Ingress.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个资源是服务，我们稍后会深入研究，这是 Kubernetes 用来在私有网络中向其他 Pod 公开或处理集群内外的连接的工具。默认情况下，在这个私有的隔离网络中运行的
    Pod 不会暴露在 Kubernetes 集群之外。根据您的 Kubernetes 集群是如何创建的，有多种方式可以打开从集群外部访问您的软件的途径，我们将在稍后的服务中详细介绍，包括负载均衡器、节点端口和入口。
- en: Controllers
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: Kubernetes is built with the notion that you tell it what you want, and it knows
    how to do it. When you interact with Kubernetes, you are asserting you want one
    or more resources to be in a certain state, with specific versions, and so forth.
    Controllers are where the brains exist for tracking those resources and attempting
    to run your software as you described. These descriptions can include how many
    copies of a container image are running, updating the software version running
    within a Pod, and handling the case of a Node failure where you unexpectedly lose
    part of your cluster.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的构建理念是告诉它你想要什么，它知道如何去做。当您与 Kubernetes 交互时，您断言您希望一个或多个资源处于特定状态，具有特定版本等等。控制器是跟踪这些资源并尝试按照您描述的方式运行软件的大脑所在的地方。这些描述可以包括运行容器镜像的副本数量、更新
    Pod 中运行的软件版本，以及处理节点故障的情况，其中您意外地失去了集群的一部分。
- en: 'There are a variety of controllers used within Kubernetes, and they are mostly
    hidden behind two key resources that we will dig into further: Deployments and
    ReplicaSets.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中使用了各种控制器，它们大多隐藏在我们将进一步深入研究的两个关键资源后面：部署和 ReplicaSets。
- en: Kubernetes resource – ReplicaSet
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 资源 – ReplicaSet
- en: A ReplicaSet wraps Pods, defining how many need to run in parallel. A ReplicaSet
    is commonly wrapped in turn by a deployment. ReplicaSets are not often used directly,
    but are critical to represent horizontal scaling—to represent the number of parallel
    Pods to run.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet 包装了 Pod，定义了需要并行运行多少个 Pod。ReplicaSet 通常又被部署包装。ReplicaSets 不经常直接使用，但对于表示水平扩展来说至关重要——表示要运行的并行
    Pod 的数量。
- en: A ReplicaSet is associated with a Pod and indicates how many instances of that
    Pod should be running within the cluster. A ReplicaSet also implies that Kubernetes
    has a controller that watches the ongoing state and knows how many of your Pod
    to keep running. This is where Kubernetes is really starting to do work for you,
    if you specified three Pods in a ReplicaSet and one fails, Kubernetes will automatically
    schedule and run another Pod for you.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet 与 Pod 相关联，并指示集群中应该运行多少个该 Pod 的实例。ReplicaSet 还意味着 Kubernetes 有一个控制器来监视持续状态，并知道要保持运行多少个
    Pod。这就是 Kubernetes 真正开始为您工作的地方，如果您在 ReplicaSet 中指定了三个 Pod，而其中一个失败了，Kubernetes
    将自动为您安排并运行另一个 Pod。
- en: Kubernetes resource – Deployment
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 资源 – 部署
- en: The most common and recommended way to run code on Kubernetes is with a deployment,
    which is managed by a deployment controller. We will explore deployments in the
    next and further chapters, both specifying them directly and creating them implicitly
    with commands such as `kubectl run`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上运行代码的最常见和推荐方式是使用部署，由部署控制器管理。我们将在接下来的章节中探讨部署，直接指定它们并使用诸如 `kubectl
    run` 等命令隐式创建它们。
- en: A Pod by itself is interesting, but limited, specifically because it is intended
    to be ephemeral. If a Node were to die (or get powered down), all the Pods on
    that Node would stop running. ReplicaSets provide self-healing capabilities. The
    work within the cluster to recognize when a Pod is no longer available and will
    attempt to schedule another Pod, typically to bring a service back online, or
    otherwise continue doing work.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Pod本身很有趣，但受限，特别是因为它旨在是短暂的。如果一个节点死掉（或者被关机），那个节点上的所有Pod都将停止运行。ReplicaSets提供了自我修复的能力。它们在集群内工作，以识别Pod何时不再可用，并尝试调度另一个Pod，通常是为了使服务恢复在线，或者继续工作。
- en: The deployment controller wraps around and extends the ReplicaSet controller,
    and is primarily responsible for rolling out software updates and managing the
    process of that rollout when you update your deployment resource with new versions
    of your software. The deployment controller includes metadata settings to know
    how many Pods to keep running so that you can enable a seamless rolling update
    of your software by adding new versions of a container, and stopping old versions
    when you request it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 部署控制器包装并扩展了ReplicaSet控制器，主要负责推出软件更新并管理更新部署资源的过程。部署控制器包括元数据设置，以了解要保持运行多少个Pod，以便通过添加容器的新版本来启用无缝滚动更新软件，并在您请求时停止旧版本。
- en: Representing Kubernetes resources
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代表Kubernetes资源
- en: Kubernetes resources can generally be represented as either a JSON or YAML data
    structure. Kubernetes is specifically built so that you can save these files,
    and when you want to run your software, you can use a command such as `kubectl
    deploy` and provide the definitions you've created previously, and it uses that
    to run your software. In our next chapter, we will start to show specific examples
    of these resources and build them up for our use.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes资源通常可以表示为JSON或YAML数据结构。Kubernetes专门设计成可以保存这些文件，当您想要运行软件时，可以使用诸如`kubectl
    deploy`之类的命令，并提供先前创建的定义，然后使用它来运行您的软件。在我们的下一章中，我们将开始展示这些资源的具体示例，并为我们的使用构建它们。
- en: As we get into the examples in the next, and future chapters, we will use YAML
    to describe our resources and request data through `kubectl` back in JSON format.
    All of these data structures are formally defined for each version of Kubernetes,
    along with the REST APIs that Kubernetes provides to manipulate them. The formal
    definitions of all Kubernetes resources are maintained with OpenAPI (also known
    as **Swagger**) in source code control, and can be viewed at [https://github.com/kubernetes/kubernetes/tree/master/api/swagger-spec](https://github.com/kubernetes/kubernetes/tree/master/api/swagger-spec).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入下一个和未来的章节中的示例时，我们将使用YAML来描述我们的资源，并通过`kubectl`以JSON格式请求数据。所有这些数据结构都是针对Kubernetes的每个版本进行正式定义的，以及Kubernetes提供的用于操作它们的REST
    API。所有Kubernetes资源的正式定义都在源代码控制中使用OpenAPI（也称为**Swagger**）进行维护，并可以在[https://github.com/kubernetes/kubernetes/tree/master/api/swagger-spec](https://github.com/kubernetes/kubernetes/tree/master/api/swagger-spec)上查看。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we installed `minikube` and `kubectl`, and used them to start
    a local Kubernetes cluster and briefly interact with it. We then walked through
    some of the key concepts that we will be using and exploring more in depth in
    future chapters, including container, Pod, node, deployment, and ReplicaSet.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们安装了`minikube`和`kubectl`，并使用它们启动了一个本地Kubernetes集群，并简要地与之交互。然后，我们简要介绍了一些关键概念，我们将在未来的章节中更深入地使用和探索，包括容器、Pod、节点、部署和ReplicaSet。
- en: In the next chapter, we will dive into what it takes to get your software into
    a container and tips for how to set that up within your own project. We will walk
    through an example in Python, and another in Node.js, which you can use as starting
    points for your own code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨将软件放入容器所需的步骤，以及如何在自己的项目中设置容器的技巧。我们将以Python和Node.js为例，演示如何将软件放入容器，你可以将其作为自己代码的起点。
