- en: Declarative Infrastructure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式基础设施
- en: 'Kubernetes is inherently a declarative system. In prior chapters, we have explored
    Kubernetes and some of its key concepts using commands such as `kubectl run` and
    `kubectl expose`. These commands are all imperative: do this thing now. Kubernetes
    does this by managing these resources as objects themselves. `kubectl` and the
    API server translate these requests into resource representations, and then store
    them, and it is the job of the various controllers to understand the current state
    and make it as requested.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes本质上是一个声明性系统。在之前的章节中，我们已经使用诸如`kubectl run`和`kubectl expose`之类的命令探讨了Kubernetes及其一些关键概念。这些命令都是命令式的：现在就做这件事。Kubernetes通过将这些资源作为对象本身来管理这些资源。`kubectl`和API服务器将这些请求转换为资源表示，然后存储它们，各种控制器的工作是了解当前状态并按照请求进行操作。
- en: We can take advantage of the declarative structures directly—all the Services,
    Pods, and more can be represented by either JSON or YAML files. In this chapter,
    we will move to define your applications as a declarative infrastructure. We will
    take the existing simple Kubernetes Pods and put them into declarations that you
    can manage alongside your code; stored in source control and deployed to run your
    software. We will also introduce ConfigMaps and Secrets, to allow you to define
    your configuration as well as your application structure, and explore how to use
    them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接利用声明性结构-所有服务、Pod和更多内容都可以用JSON或YAML文件表示。在本章中，我们将转而将您的应用程序定义为声明性基础设施。我们将把现有的简单Kubernetes
    Pod放入您可以与代码一起管理的声明中；存储在源代码控制中并部署以运行您的软件。我们还将介绍ConfigMaps和Secrets，以允许您定义配置以及应用程序结构，并探讨如何使用它们。
- en: 'The sections for this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的部分包括：
- en: Imperative versus declarative
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令式与声明式
- en: Declaring your first application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明您的第一个应用程序
- en: Kubernetes resource—Annotations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes资源-注释
- en: Kubernetes resource—ConfigMap
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes资源-ConfigMap
- en: Kubernetes resource—Secrets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes资源-秘密
- en: Python example with ConfigMap
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ConfigMap的Python示例
- en: Imperative versus declarative commands
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令式与声明式命令
- en: Our examples thus far have focused on quick and imperative commands such as
    `kubectl run` to create a deployment that in turn runs our software. This is convenient
    for something quick, but does not easily expose the full flexibility of the API.
    To leverage all the options available via Kubernetes, it is often more effective
    to manage files that describe the deployment you want.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的示例主要集中在快速和命令式的命令，例如`kubectl run`来创建一个部署，然后运行我们的软件。这对于一些快速操作很方便，但不容易暴露API的全部灵活性。要利用Kubernetes提供的所有选项，通常更有效的方法是管理描述您想要的部署的文件。
- en: When using these files, you can use commands such as `kubectl create`, `kubectl
    delete`, and `kubectl replace` along with the `-f` option to specify the file
    to use. The imperative commands are easy and effective for simple setups, but
    you quickly need a sequence of commands that you repeat again and again to take
    full advantage of all the capabilities. You might be storing sets of these commands
    in a cheatsheet, but that can get cumbersome and isn't always clear.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些文件时，您可以使用`kubectl create`、`kubectl delete`和`kubectl replace`命令，以及`-f`选项来指定要使用的文件。命令式命令对于简单的设置很容易有效，但您很快就需要一系列重复使用的命令，以充分利用所有功能。您可能会将这些命令集存储在一个备忘单中，但这可能会变得繁琐，而且并不总是清晰明了。
- en: Kubernetes offers a declarative mechanism as well, leveraging the `kubectl apply` command,
    which takes in files, reviews the current state, and manages the updates—creating,
    removing, and so on—as needed, while also keeping a simple audit log of the changes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes还提供了一种声明性机制，利用`kubectl apply`命令，该命令接受文件，审查当前状态，并根据需要管理更新-创建、删除等，同时保持更改的简单审计日志。
- en: I recommend using the `kubectl apply` command for anything more complex than
    running a single process, which will likely be most of your developed services.
    You may not need the audit trails in development. You probably would in a staging/canary
    environment or in production, so being familiar and comfortable with them is advantageous
    to understand them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议对于任何比运行单个进程更复杂的事情使用`kubectl apply`命令，这可能是您开发的大多数服务。您在开发中可能不需要审计跟踪。但在暂存/金丝雀环境或生产环境中可能需要，因此熟悉并熟悉它们对于理解它们是有利的。
- en: Best of all, but keeping the description of your application in files, you can
    include them in source control, treating them like code. This gives you a consistent
    means of sharing that application structure among your team members, all of which
    can use it to provide a consistent environment.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，通过将应用程序的描述放在文件中，您可以将它们包含在源代码控制中，将它们视为代码。这为您提供了一种一致的方式来在团队成员之间共享该应用程序结构，所有这些成员都可以使用它来提供一致的环境。
- en: The `kubectl apply` command has an `-f` option to specify a file or directory
    of files, as well as an `-R` option that will recursively descend directories
    if you are establishing a complex deployment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl apply`命令有一个`-f`选项，用于指定文件或文件目录，以及一个`-R`选项，如果您正在建立一个复杂的部署，它将递归地遍历目录。'
- en: As we go forward in this book, I will use declarative commands and configurations
    in YAML format (with comments) to describe and manipulate the Kubernetes resources.
    JSON can be used as well if you have a strong preference.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本书中的进展，我将使用YAML格式（带有注释）的声明性命令和配置来描述和操作Kubernetes资源。如果您有强烈的偏好，也可以使用JSON。
- en: 'Note: If you would like a command-line tool to parse YAML, there is an equivalent
    to `jq` for JSON: `yq`. Our examples won''t go into that much detail, but if you
    want to use the tool you can find more information about it at [https://yq.readthedocs.io](https://yq.readthedocs.io).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您想要一个命令行工具来解析YAML，那么有一个等价于`jq`用于JSON的工具：`yq`。我们的示例不会详细介绍，但如果您想使用该工具，可以在[https://yq.readthedocs.io](https://yq.readthedocs.io)找到更多信息。
- en: A wall of YAML
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一堵墙的YAML
- en: 'What do these configurations look like? The vast majority of them are managed
    in YAML format, and the options and configurations can seem overwhelming. Each
    resource in Kubernetes has its own format, and some of those formats are changing
    and under active development. You will notice that some of the APIs and object
    structures will actively reference either `alpha` or `beta` to indicate the state
    of maturity of those resources in the project. The project tends to use these
    terms in a very conservative manner:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置看起来是什么样子的？其中绝大多数是以YAML格式进行管理，选项和配置可能看起来令人不知所措。Kubernetes中的每个资源都有自己的格式，其中一些格式正在发生变化并处于积极开发中。您会注意到一些API和对象结构将积极引用`alpha`或`beta`，以指示项目中这些资源的成熟状态。该项目倾向于以非常保守的方式使用这些术语：
- en: '`alpha` tends to mean it is an early experiment and the data format may change,
    but something achieving the end goal will likely exist'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alpha`倾向于意味着这是一个早期实验，数据格式可能会发生变化，但很可能会存在实现最终目标的东西'
- en: '`beta` is more solid than purely experimental, and can likely be used in production
    loads, although the specific resource format hasn''t been entirely locked down
    and may change slightly over Kubernetes releases'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beta`比纯粹的实验更加可靠，很可能可以用于生产负载，尽管特定的资源格式尚未完全确定，并且可能会在Kubernetes发布过程中略微更改'
- en: Be aware that alpha and beta APIs evolve as new releases of Kubernetes are made
    available. If you use an earlier version, it may become deprecated and ultimately
    unavailable. You will need to track these updates with the version of Kubernetes
    you are using.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，随着Kubernetes的新版本发布，alpha和beta API会不断发展。如果您使用较早版本，它可能会变得不推荐使用，并最终不可用。您需要跟踪这些更新与您正在使用的Kubernetes版本。
- en: The formal documentation for the resources, their options, and formats, are
    hosted at [https://kubernetes.io](https://kubernetes.io) under reference documentation.
    As I write this, the current released version is 1.8, and the reference documentation
    for that is available at [https://kubernetes.io/docs/api-reference/v1.8/](https://kubernetes.io/docs/api-reference/v1.8/).
    This documentation is generated from the Kubernetes project source and updated
    each release, which generally comes out approximately every three months.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的正式文档、选项和格式托管在[https://kubernetes.io](https://kubernetes.io)的参考文档下。在我写这篇文章时，当前发布的版本是1.8，该版本的参考文档可在[https://kubernetes.io/docs/api-reference/v1.8/](https://kubernetes.io/docs/api-reference/v1.8/)上找到。该文档是从Kubernetes项目源代码生成的，并在每次发布时更新，通常每三个月左右发布一次。
- en: In addition to wading through the reference documentation, you can get the declaration
    from existing Kubernetes objects. When you request the Kubernetes resource using
    the `kubectl get` command you can add the `-o yaml --export` option.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了浏览参考文档之外，您还可以从现有的Kubernetes对象中获取声明。当您使用`kubectl get`命令请求Kubernetes资源时，可以添加`-o
    yaml --export`选项。
- en: The `-o yaml` option could instead be `-o json` if you prefer that format. `--export`
    will strip out some extraneous information that is specific to the current state
    and identity of the resource within Kubernetes, and won't benefit you to store
    externally.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢该格式，`-o yaml`选项可以改为`-o json`。`--export`将剥离一些与Kubernetes内部资源的当前状态和身份相关的多余信息，并且不会对您在外部存储时有所帮助。
- en: Although the capability isn’t quite complete with version 1.8, you should be
    able to ask for all resources in a namespace, store those configurations, and
    use those files to reproduce it exactly. In practice, there are a few bumps along
    the way, as the exported versions don't always have exactly what you want. At
    this point, it is far better to manage your own declaration files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在1.8版本中，这种能力还不完全，但您应该能够要求在一个命名空间中的所有资源，存储这些配置，并使用这些文件来精确地复制它。在实践中，会有一些小问题，因为导出的版本并不总是完全符合您的要求。在这一点上，更好的做法是管理自己的声明文件。
- en: Finally, I recommend using YAML as the format for these declarations. You could
    use JSON, but YAML allows you to add comments into the declarations, which are
    immensely useful for others reading those files—a capability that the JSON format
    doesn't share.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我建议使用YAML作为这些声明的格式。您可以使用JSON，但YAML允许您在声明中添加注释，这对于其他人阅读这些文件非常有用——这是JSON格式所没有的功能。
- en: Creating a simple deployment
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的部署
- en: 'Let''s start by looking at what `kubectl run` created for us, and work from
    there. We created the earlier simple deployments with the following commands:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看`kubectl run`为我们创建了什么，然后从那里开始。我们使用以下命令创建了之前的简单部署：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the examples, we dumped the state of the declaration with the `kubectl get
    deployment flask -o json` command. Let''s repeat that except using the `-o yaml
    --export` option:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们使用`kubectl get deployment flask -o json`命令转储了声明的状态。让我们重复一下，只是使用`-o yaml
    --export`选项：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output should look something like the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像下面这样：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The general format of any Kubernetes resource will have the same top four objects:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Kubernetes资源的一般格式都将具有相同的顶部四个对象：
- en: '`apiVersion`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiVersion`'
- en: '`kind`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`'
- en: '`metadata`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`'
- en: '`spec`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec`'
- en: 'If you are retrieving information from Kubernetes, you will see a fifth key:
    `status`. Status isn''t expected to be defined by a user, and is provided by Kubernetes
    when retrieving objects to share their current state. If you miss the `--export`
    option on a `kubectl get` command, it will include status.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从Kubernetes检索信息，您将看到第五个键：`status`。状态不需要由用户定义，并且在检索对象以共享其当前状态时由Kubernetes提供。如果您在`kubectl
    get`命令上错过了`--export`选项，它将包括状态。
- en: You will see metadata scattered throughout the objects, as the objects are related
    to each other and build conceptually on each other. The metadata is included per
    resource, even though it may be combined (as shown previously) into a single reference.
    For the deployment we created, it is using a declarative reference for a deployment,
    which wraps a ReplicaSet, which wraps a Pod.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到对象中散布着元数据，因为这些对象彼此相关，并在概念上相互构建。尽管它们可能被合并（如前面所示）成单个引用，但元数据被包含在每个资源中。对于我们创建的部署，它使用了部署的声明性引用，它包装了一个ReplicaSet，该ReplicaSet又包装了一个Pod。
- en: 'You can see the formal definition of each of these at the following URLs:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下URL中查看每个的正式定义：
- en: 'Deployment: [https://kubernetes.io/docs/api-reference/v1.8/#deployment-v1beta2-apps](https://kubernetes.io/docs/api-reference/v1.8/#deployment-v1beta2-apps)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Deployment：[https://kubernetes.io/docs/api-reference/v1.8/#deployment-v1beta2-apps](https://kubernetes.io/docs/api-reference/v1.8/#deployment-v1beta2-apps)
- en: 'ReplicaSet : [https://kubernetes.io/docs/api-reference/v1.8/#replicaset-v1beta2-apps](https://kubernetes.io/docs/api-reference/v1.8/#replicaset-v1beta2-apps)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReplicaSet：[https://kubernetes.io/docs/api-reference/v1.8/#replicaset-v1beta2-apps](https://kubernetes.io/docs/api-reference/v1.8/#replicaset-v1beta2-apps)
- en: 'Pod: [https://kubernetes.io/docs/api-reference/v1.8/#pod-v1-core](https://kubernetes.io/docs/api-reference/v1.8/#pod-v1-core)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod：[https://kubernetes.io/docs/api-reference/v1.8/#pod-v1-core](https://kubernetes.io/docs/api-reference/v1.8/#pod-v1-core)
- en: You may notice that ReplicaSet and Deployment are nearly identical. Deployment
    extends ReplicaSet and every instance of Deployment will have at least one ReplicaSet. Deployment
    includes declarative options (and the responsibility) for how to perform updates
    on running software. Kubernetes recommends that when you’re deploying code, you
    use a Deployment over a ReplicaSet directly, in order to specify exactly how you
    want it to react as you update it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到ReplicaSet和Deployment几乎是相同的。部署扩展了ReplicaSet，并且每个部署实例都至少有一个ReplicaSet。部署包括声明性选项（以及责任），用于如何在运行软件上执行更新。Kubernetes建议在部署代码时，使用部署而不是直接使用ReplicaSet，以便精确指定您希望它在更新时如何反应。
- en: Within the deployment `spec` ([https://kubernetes.io/docs/api-reference/v1.8/#deploymentspec-v1beta2-apps](https://kubernetes.io/docs/api-reference/v1.8/#deploymentspec-v1beta2-apps)),
    all the items under the key template are defined from the Pod template specification.
    You can view the details of the Pod template specification at [https://kubernetes.io/docs/api-reference/v1.8/#podtemplatespec-v1-core](https://kubernetes.io/docs/api-reference/v1.8/#podtemplate-v1-core).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署`spec`（[https://kubernetes.io/docs/api-reference/v1.8/#deploymentspec-v1beta2-apps](https://kubernetes.io/docs/api-reference/v1.8/#deploymentspec-v1beta2-apps)）中，所有在模板键下的项目都是从Pod模板规范中定义的。您可以在[https://kubernetes.io/docs/api-reference/v1.8/#podtemplatespec-v1-core](https://kubernetes.io/docs/api-reference/v1.8/#podtemplate-v1-core)查看Pod模板规范的详细信息。
- en: If you take a look at the online documentation, you will see a large number
    of options that we’re not specifying. When they aren’t specified, Kubernetes will
    still fill in values using the defaults defined in the specification.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看在线文档，您会看到许多我们没有指定的选项。当它们没有被指定时，Kubernetes仍会使用规范中定义的默认值填充这些值。
- en: You can specify as completely, or as lightly, as you desire. The number of required
    fields is quite small. You typically only need to define the optional fields when
    you want a different value than the default. As an example, for a deployment,
    the required fields are a name and the image to be deployed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要指定完整或轻量级的选项。所需字段的数量非常少。通常只有在您想要不同于默认值的值时，才需要定义可选字段。例如，对于一个部署，必需字段是名称和要部署的镜像。
- en: I recommend keeping to a minimal set of declarations in YAML as you create them
    for your own code. This will support easier understanding of your resource declarations,
    and along with the liberal use of comments, should make the resulting files easy
    to understand.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在为自己的代码创建声明时，我建议保持一组最小的 YAML 声明。这将有助于更容易理解您的资源声明，并且与大量使用注释一起，应该使得生成的文件易于理解。
- en: Declaring your first application
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明您的第一个应用程序
- en: Go ahead and pick one of the examples and create a deployment declaration, and
    try creating one using the declaration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 继续选择一个示例并创建一个部署声明，然后尝试使用该声明创建一个。
- en: 'I recommend making a directory called `deploy`, and putting your declaration
    file within that. This is using the `flask` example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议创建一个名为 `deploy` 的目录，并将您的声明文件放在其中。这是使用 `flask` 示例：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Remove the existing deployment before you try out your file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试您的文件之前，请删除现有的部署：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is a good practice to use the `--validate` option to have `kubectl` check
    the files, and you can use it with `--dry-run` to compare the file to anything
    existing in Kubernetes to let you know specifically what it will be doing.  YAML
    is easy to read, and unfortunately even easier to make formatting mistakes due
    to its use of whitespace to define the structure. Using the `--validate` option,
    `kubectl` will warn you of missing fields or other problems. Without it, `kubectl`
    will often fail quietly, simply ignoring what it doesn’t understand:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--validate` 选项是一个很好的做法，可以让 `kubectl` 检查文件，并且您可以将其与 `--dry-run` 一起使用，将文件与
    Kubernetes 中的任何现有内容进行比较，以便让您明确知道它将要执行的操作。 YAML 很容易阅读，但不幸的是，由于其使用空格来定义结构，很容易出现格式错误。使用
    `--validate` 选项，`kubectl` 将警告您缺少字段或其他问题。如果没有它，`kubectl` 通常会悄悄地失败，只是简单地忽略它不理解的内容：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should see results that look as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下结果：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you happened to make a typo, you''ll see an error reported in the output.
    I made an intentional typo in one of the keys, `metadata`, and the result was
    as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不小心打了错字，您将在输出中看到报告的错误。我在一个键中故意打了错字，`metadata`，结果如下：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once you are happy that the data validates and will work as you expect, you
    can create the object with the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您确信数据经过验证并且将按预期工作，您可以使用以下命令创建对象：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is still easy to make minor mistakes that aren''t immediately apparent,
    but become clear when you try and run the code. You can use the `kubectl get`
    command to inspect specific resources. I would encourage you to also use the `kubectl
    describe` command to see not only the state of the resources, but all related
    events from Kubernetes about it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在尝试运行代码时，仍然很容易犯一些不明显的小错误，但在尝试运行代码时会变得清晰。您可以使用 `kubectl get` 命令来检查特定资源。我建议您还使用
    `kubectl describe` 命令来查看有关 Kubernetes 的所有相关事件，而不仅仅是资源的状态：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once you are comfortable with the declaration working as expected, store it
    in source control along with your code. The example sections of this book will
    move to using stored configurations, and the Python and Node.js examples will
    be updated in this and future chapters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您对声明的工作原理感到满意，请将其与您的代码一起存储在源代码控制中。本书的示例部分将转移到使用存储的配置，并且本章和以后的章节将更新Python和Node.js示例。
- en: 'If you want to create Kubernetes resources and then later manage them with
    the `kubectl apply` command, you should use the `--save-config` option when running
    the `kubectl run` or `kubectl create` commands. This will explicitly add in the
    annotations that `kubectl apply` expects to be there when it''s run. If they aren''t
    there, the commands will still operate correctly, but you''ll get a warning:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要创建Kubernetes资源，然后使用`kubectl apply`命令对其进行管理，应在运行`kubectl run`或`kubectl create`命令时使用`--save-config`选项。这将明确添加`kubectl
    apply`在运行时期望存在的注释。如果它们不存在，命令仍将正常运行，但会收到警告：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ImagePullPolicy
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ImagePullPolicy
- en: 'If you use `:latest` tags in your code while trying things, you may have noticed
    that the value of `imagePullPolicy` was set to `Always`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在尝试事物时在代码中使用`:latest`标签，您可能已经注意到`imagePullPolicy`的值被设置为`Always`：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This tells Kubernetes to always attempt to load new Docker images from container
    repositories. If you use a tag other than `:latest`, then the default (`IfNotPresent`)
    will only attempt to reload the container images if it can't find them in its
    local cache.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Kubernetes始终尝试从容器存储库加载新的Docker镜像。如果使用的标签不是`:latest`，那么默认值(`IfNotPresent`)只会在本地缓存中找不到容器镜像时尝试重新加载它们。
- en: This is a technique that can be very useful while you are frequently updating
    your code. I recommend only using this when you are working by yourself, as sharing
    the knowledge of what exactly `:latest` means can be difficult and lead to a great
    deal of confusion.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种在频繁更新代码时非常有用的技术。我建议只在独自工作时使用这种技术，因为分享`：latest`的确切含义可能很困难，并且会导致很多混乱。
- en: It is generally considered a bad practice to use the `:latest` tag in any staging
    or production deployment, simply because of the uncertainty of what it references.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何暂存或生产部署中使用`:latest`标签通常被认为是一种不好的做法，仅仅是因为它引用的内容不确定。
- en: Audit trail
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审计跟踪
- en: 'When you use the `kubectl apply` command, it automatically maintains an audit
    trail for you in the Kubernetes resources as annotations. If you use the following
    command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`kubectl apply`命令时，它会自动在Kubernetes资源中的注释中为您维护审计跟踪。如果使用以下命令：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You''ll see fairly readable output akin to the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似以下的相当可读的输出：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The audit trail I mentioned is contained in the annotation `kubectl.kubernetes.io/last-applied-configuration`—which
    includes the last applied configuration. Because that annotation is fairly lengthy,
    it is clipped a bit in this output. You can see the full details if you dump the
    entire object with the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到的审计跟踪包含在注释`kubectl.kubernetes.io/last-applied-configuration`中，其中包括最后应用的配置。由于该注释相当长，因此在此输出中对其进行了修剪。如果要转储整个对象，可以查看完整的详细信息，如下所示：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The information we''re interested in here is `metadata` | `annotations`  `kubectl.kubernetes.io/last-applied-configuration`.
    The full detail in that annotation might look something like the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的信息是`metadata` | `annotations` `kubectl.kubernetes.io/last-applied-configuration`。该注释中的完整细节可能如下所示：
- en: '![](assets/caa72445-4fd3-45c6-82a8-c5b25d63efaa.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/caa72445-4fd3-45c6-82a8-c5b25d63efaa.png)'
- en: Kubernetes resource – Annotations
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes资源-注释
- en: Where labels and selectors are used for grouping and selecting sets of Kubernetes
    resources, Annotations provide a means of adding resource-specific metadata that
    can be accessed by either Kubernetes or in the containers it runs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 标签和选择器用于对Kubernetes资源进行分组和选择，而注释提供了一种添加特定于资源的元数据的方法，这些元数据可以被Kubernetes或其运行的容器访问。
- en: As you just saw, `kubectl apply` automatically applies an annotation to track
    the last applied configuration state of a resource when it is invoked. In the
    last chapter, you might have noticed the annotation that the deployment controllers
    used to track revision, `deployment.kubernetes.io/revision`, and we spoke of the `kubernetes.io/change-cause` annotation
    that was used by `kubectl` to display the change history of deployment rollouts.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您刚才看到的，`kubectl apply`在调用时会自动应用一个注释，以跟踪资源的最后应用配置状态。在上一章中，您可能已经注意到部署控制器用于跟踪修订版本的注释`deployment.kubernetes.io/revision`，我们还谈到了`kubernetes.io/change-cause`注释，该注释被`kubectl`用于显示部署发布的更改历史。
- en: Annotations can be simple values or complex blocks (as in the case of `kubectl.kubernetes.io/last-applied-configuration`).
    The examples so far are Kubernetes tools using annotations to share information,
    although annotations are also used to share information in a container for an
    application to use.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注释可以是简单的值或复杂的块（如`kubectl.kubernetes.io/last-applied-configuration`的情况）。到目前为止的示例是Kubernetes工具使用注释共享信息，尽管注释也用于在容器中共享信息供应用程序使用。
- en: You might use them to include information such as adding version control revision
    information, a build number, relevant human-readable contact information, and
    so forth.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用它们来包含诸如添加版本控制修订信息、构建编号、相关的可读联系信息等信息。
- en: 'Like labels, annotations can be added using an imperative `kubectl` command:
    `kubectl annotate`. In general, annotations use the same key mechanism that labels
    use, so any annotation that includes `kubernetes.io` in its prefix is something
    from the Kubernetes project.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与标签一样，注释可以使用命令`kubectl annotate`来添加。一般来说，注释使用与标签相同的键机制，因此任何包含`kubernetes.io`前缀的注释都是来自Kubernetes项目的内容。
- en: Labels are intended to group and organize Kubernetes objects – Pods, Deployments,
    Services, and so on. Annotations are intended to provide additional information
    specific to an instance (or a couple of instances) generally as additional data
    within the annotation itself.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 标签旨在对Kubernetes对象（Pod、部署、服务等）进行分组和组织。注释旨在为实例（或一对实例）提供特定的附加信息，通常作为注释本身的附加数据。
- en: Exposing labels and annotations in Pods
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Pod中公开标签和注释
- en: Kubernetes can expose data about a Pod in a container directly, typically as
    files in a specific filesystem, which your code can read and use. Labels, annotations,
    and more can be made available as files in your container through the container
    specification, and using what Kubernetes calls the `downwardAPI`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes可以直接在容器中公开有关Pod的数据，通常作为特定文件系统中的文件，您的代码可以读取和使用。标签、注释等可以通过容器规范作为文件在您的容器中提供，并使用Kubernetes所谓的`downwardAPI`。
- en: This can be a convenient way to expose annotation information such as build
    time, source code reference hash, and so forth in a container so that your runtime
    code can read and reference the information.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是一种方便的方式，可以在容器中公开注释信息，例如构建时间，源代码引用哈希等，以便您的运行时代码可以读取和引用这些信息。
- en: To make the Pods labels and annotations available, you define a volume mount
    for the container, and then specify the `downwardAPI` and items from it for the
    volume mount point.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Pod的标签和注释可用，您需要为容器定义一个卷挂载，然后指定`downwardAPI`和卷挂载点中的项目。
- en: 'Update the `flask` deployment file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`flask`部署文件：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The details in the lower section identify a mount point—a directory structure
    that will be created inside the container. It also specifies that the volume should
    be using the `downwardAPI` with specific metadata; in this case, the labels and
    annotations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面部分的细节标识了一个挂载点——将在容器内创建的目录结构。它还指定卷应该使用`downwardAPI`与特定的元数据；在这种情况下，是标签和注释。
- en: When you specify a volume mount location, take care not to specify a location
    that already exists and has files (such as/and so on) or the container may have
    trouble operating as expected. The mount point doesn't throw an error—it just
    overlays on whatever might already exist in the container at that location.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当您指定卷挂载位置时，请注意不要指定已经存在并且有文件的位置（例如/等），否则容器可能无法按预期运行。挂载点不会抛出错误-它只是覆盖容器中该位置可能已经存在的任何内容。
- en: 'You can apply this updated declaration with the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令应用此更新的声明：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we can open a shell to that running Pod, with a command like the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以打开一个shell到正在运行的Pod，使用以下命令：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And in that active shell, run the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在活动的shell中运行以下命令：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can compare this to the annotations on the Pod itself through the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下方式将其与Pod本身的注释进行比较：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A variety of data about the Pods can be exposed in the Pods, and the same data
    can be exposed to Pods via environment variables. The full set of data that can
    be exposed is detailed in the Kubernetes documentation ([https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/](https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/)).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Pod的各种数据可以在Pod中公开，并且可以通过环境变量将相同的数据公开给Pod。可以公开的完整数据集在Kubernetes文档中有详细说明（[https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/](https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/)）。
- en: While it may seem convenient and obvious to use this mechanism to provide a
    means of passing in configuration data, Kubernetes provides additional capabilities
    specifically for providing configuration to code within containers, including
    the private configuration needed for passwords, access tokens, and other secrets.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用这种机制来提供传递配置数据的方法可能看起来方便和明显，但Kubernetes提供了额外的功能，专门用于为容器内的代码提供配置，包括密码、访问令牌和其他机密信息所需的私有配置。
- en: Kubernetes resource – ConfigMap
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes资源 - ConfigMap
- en: When you create containers as read-only instances of your code, you quickly
    want a means to provide small changes in the form of flags or configuration. Perhaps,
    more importantly, you do not want to include private details such as API keys,
    passwords, or authentication tokens in your container images.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将容器创建为代码的只读实例时，您很快就会需要一种方式来提供标志或配置的小改变。也许更重要的是，您不希望在容器映像中包含诸如API密钥、密码或身份验证令牌等私人详细信息。
- en: Kubernetes supports two resources to help and link in exactly this kind of information.
    The first is a ConfigMap, which can be used individually or across Pods for your
    application deployment, providing a single place to update and propagate configuration
    for your application. Kubernetes also supports the concept of a Secret, a far
    more locked down type of configuration that is more tightly controlled and exposed
    only where you need it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes支持两种资源来帮助并链接这种类型的信息。第一种是ConfigMap，可以单独使用或跨Pod用于应用部署，为应用程序提供更新和传播配置的单一位置。Kubernetes还支持Secret的概念，这是一种更加严格控制和仅在需要时才公开的配置类型。
- en: For example, one might use a ConfigMap to control basic configuration of the
    example Redis deployment, and a Secret to distribute sensitive authentication
    credentials for clients to connect.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个人可能会使用ConfigMap来控制示例Redis部署的基本配置，并使用Secret来分发敏感的身份验证凭据，以供客户端连接。
- en: Creating a ConfigMap
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ConfigMap
- en: You can create a ConfigMap using the `kubectl` create `configmap` command, with
    the data for the configuration set on the command line, or coming from one or
    more files that you have stored. It also supports loading a directory of files
    for convenience.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`kubectl create configmap`命令创建ConfigMap，其中配置的数据可以在命令行上设置，也可以来自您存储的一个或多个文件。它还支持加载文件目录以方便使用。
- en: 'Creating from single key/value pairs on the command line is very simple, but
    probably the least convenient for managing configuration. For example, run the
    following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行创建单个键/值对非常简单，但可能是管理配置的最不方便的方式。例如，运行以下命令：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will create a ConfigMap named `example-config` with a single key/value
    pair. You can see the list of all configurations loaded with the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`example-config`的ConfigMap，其中包含一个键/值对。您可以使用以下命令查看加载的所有配置列表：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And view that ConfigMap using the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用以下命令查看ConfigMap：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And you can also request the raw data in YAML format:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以请求以YAML格式获取原始数据：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And you can also request the raw data in JSON format:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以请求以JSON格式获取原始数据：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The values for configurations created from literals will generally be strings.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从字面值创建的配置的值通常是字符串。
- en: If you want to create configuration values that your code can parse as a different
    type (number, Boolean, and so on), then you will want to either specify those
    configurations as files or define them as blobs inside the ConfigMap objects in
    YAML or JSON.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建代码可以解析为不同类型（数字、布尔值等）的配置值，则需要将这些配置指定为文件，或者在YAML或JSON格式的ConfigMap对象中定义它们为块。
- en: If you would prefer to manage the configuration in separate files, they can
    have multiple lines in a simple `key=value` format, one configuration per line.
    The `kubectl create configmap <name> --from-file <filename>` command will load
    those, creating a `configmap` name based on the filename, each with all the relevant
    data from the files included within it. If you already have configuration files
    that you're working with, you can use this option to make ConfigMaps based on
    those files.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望将配置分开存储在不同的文件中，它们可以以简单的`key=value`格式具有多行，每行一个配置。`kubectl create configmap
    <name> --from-file <filename>`命令将加载这些文件，创建一个基于文件名的`configmap`名称，其中包含来自文件的所有相关数据。如果您已经有要处理的配置文件，可以使用此选项基于这些文件创建ConfigMaps。
- en: 'For example, if you wanted a configuration file, `config.ini`, that you wanted
    to load into a ConfigMap:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想要一个名为`config.ini`的配置文件加载到ConfigMap中：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You could use the following command to create an `iniconfig` ConfigMap:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令创建一个`iniconfig` ConfigMap：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Dumping that data back out as a ConfigMap:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据转储回ConfigMap：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Should return you something akin to the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 应该返回类似以下的内容：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The pipe symbol  (`|`) in the YAML output defines a multiline input. These kinds
    of configurations won't be directly available as environment variables, as they
    are invalid for that format. They can be made available as files once you add
    them to your Pod specification. Adding them to your Pod specification is very
    similar to using the downward API to expose labels or annotations in a Pod's containers
    as files.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: YAML输出中的管道符号（`|`）定义了多行输入。这些类型的配置不会直接作为环境变量可用，因为它们对于该格式是无效的。一旦将它们添加到Pod规范中，它们可以作为文件提供。将它们添加到Pod规范中与使用向下API在Pod的容器中公开标签或注释的方式非常相似。
- en: Managing ConfigMaps
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理ConfigMaps
- en: Once you have created a ConfigMap, you can’t overwrite it with another ConfigMap
    using the `kubectl create` command. You can delete it and recreate it, although
    a more effective option would be managing the configuration declarations like
    other Kubernetes resources, updating it with the `kubectl apply` command.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了一个ConfigMap，就不能使用`kubectl create`命令用另一个ConfigMap覆盖它。您可以删除它并重新创建，尽管更有效的选项是像其他Kubernetes资源一样管理配置声明，使用`kubectl
    apply`命令进行更新。
- en: 'If you created an initial ConfigMap using the `kubectl create` command while
    you’re trying out some ideas, you can start managing that configuration using
    the `kubectl apply` command in the same fashion we used previously with deployments:
    exporting the YAML and then using `kubectl apply` from within that file.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在尝试一些想法时使用`kubectl create`命令创建了初始的ConfigMap，您可以开始使用`kubectl apply`命令来管理该配置，方式与我们之前在部署中使用的方式相同：导出YAML，然后从该文件中使用`kubectl
    apply`。
- en: 'For example, to get and store the configuration we created earlier in a deploy
    directory, you might use the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要获取并存储我们之前在deploy目录中创建的配置，您可以使用以下命令：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the 1.7 release of Kubernetes, there are a few fields added in the export
    that aren''t strictly needed, but also won’t hurt anything if you leave them in.
    Looking at the file, you should see something like the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes的1.7版本中，导出中添加了一些字段，这些字段并不是严格需要的，但如果您将它们留在那里也不会有任何问题。查看文件时，您应该看到类似以下内容：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The keys of `data`, `apiVersion`, `kind`, and metadata are all critical, but
    some of the subkeys under metadata aren’t required. For instance, you could delete
    `metadata.creationTimestamp` and `metadata.selfLink`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`、`apiVersion`、`kind`和metadata的键都是关键的，但metadata下的一些子键并不是必需的。例如，您可以删除`metadata.creationTimestamp`和`metadata.selfLink`。'
- en: 'You now still have the ConfigMap resource in Kubernetes, so the first time
    you run `kubectl apply`, it will alert you that you’re doing something a bit unexpected:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您在Kubernetes中仍然有ConfigMap资源，因此第一次运行`kubectl apply`时，它会警告您正在做一些有点意外的事情：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can get rid of this warning by using the `--save-config` option with your
    `kubectl create` commands, which will include the annotations that `kubectl apply`
    expects to be there.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在`kubectl create`命令中使用`--save-config`选项来摆脱此警告，这将包括`kubectl apply`期望存在的注释。
- en: 'At this point, `kubectl apply` has applied its diff and made the relevant updates.
    If you now retrieve the data from Kubernetes, it will have the annotations that
    `kubectl apply` adds when updating resources:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`kubectl apply`已应用了其差异并进行了相关更新。如果您现在从Kubernetes中检索数据，它将具有`kubectl apply`在更新资源时添加的注释。
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Exposing the configuration into your container images
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将配置暴露到您的容器映像中
- en: 'There are two primary ways to expose configuration data into your container:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要方法可以将配置数据暴露到您的容器中：
- en: Connecting the keys from one or more ConfigMaps into environment variables that
    are set for your Pod
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个或多个ConfigMaps的键连接到为您的Pod设置的环境变量中
- en: Kubernetes can map the data from one or more ConfigMaps into volumes that are
    mounted in your Pod
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes可以将一个或多个ConfigMaps中的数据映射到挂载在Pod中的卷中。
- en: The primary difference is that environment variables are typically set once
    at the start of invoking your container and are generally simple string values,
    where as ConfigMaps mounted as data in volumes can be more complex and will get
    updated if you update the ConfigMap resource.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于环境变量通常在调用容器启动时设置一次，并且通常是简单的字符串值，而作为卷中数据挂载的ConfigMaps可以更复杂，并且如果更新ConfigMap资源，它们将被更新。
- en: Note that no mechanism exists to explicitly tells your container that a ConfigMap
    value has been updated. As of version 1.9, Kubernetes does not include any means
    to signal to Pods and Containers that something has updated.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目前不存在明确告知容器 ConfigMap 值已更新的机制。截至 1.9 版本，Kubernetes 不包括任何方式来向 Pod 和容器发出更新的信号。
- en: Additionally, configuration data exposed as file mounts isn't updated immediately.
    There is a lag between updating the ConfigMap resource and seeing the changes
    reflected in the relevant Pods.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，作为文件挂载公开的配置数据不会立即更新。更新 ConfigMap 资源和在相关 Pod 中看到更改反映之间存在延迟。
- en: Environment variables
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境变量
- en: When defining a Pod specification, in addition to the mandatory name and image
    key, you can specify an `env` key. The environment key requires a name, and you
    can add a key that makes a reference using `valueFrom:` to get data from a ConfigMap.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义 Pod 规范时，除了强制的名称和镜像键之外，您还可以指定一个 `env` 键。环境键需要一个名称，并且您可以添加一个使用 `valueFrom:`
    引用 ConfigMap 中的数据的键。
- en: 'For example, to expose our example configuration as an environment variable,
    you could add the following stanza to a Pod specification:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将我们的示例配置公开为环境变量，您可以将以下段添加到 Pod 规范中：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can include multiple environment variables in the Pod specification, and
    each can reference a different ConfigMap if you have your configuration split
    up into multiple pieces to make it easier (or more sensible) to administer.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pod 规范中，您可以包含多个环境变量，并且每个环境变量可以引用不同的 ConfigMap，如果您的配置分成多个部分，以便更容易（或更合理）进行管理。
- en: You can also map the entirety of a ConfigMap that are all key/values into environment
    variables as a single block.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将整个 ConfigMap 映射为环境变量作为单个块的所有键/值。
- en: 'Instead of using individual keys under `env`, you can use `envFrom` and specify
    the ConfigMap, for example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `envFrom` 而不是在 `env` 下使用单独的键，并指定 ConfigMap，例如：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With this setup, every configuration data key/value will be loaded as an environment
    variable when the Pod starts.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此设置，每当 Pod 启动时，所有配置数据键/值都将作为环境变量加载。
- en: You can create keys in ConfigMap that are not legal to be environment variables,
    such as keys starting with a number. In those cases, Kubernetes will load all
    the other keys and record the failed keys in the event log, but otherwise not
    throw an error. You can use `kubectl get events` to see the failed messages, where
    it will show each key that it skipped because it was invalid.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 ConfigMap 中创建不适合作为环境变量的键，例如以数字开头的键。在这些情况下，Kubernetes 将加载所有其他键，并在事件日志中记录失败的键，但不会抛出错误。您可以使用
    `kubectl get events` 查看失败的消息，其中将显示因为无效而跳过的每个键。
- en: If you want to use one of the ConfigMap values that the arguments passed to
    the command to run within a container, you can also do that. When you specify
    the environment variables by `env` and name, you can reference that variable elsewhere
    in the Pod specification using `$(ENVIRONMENT_VARIABLE_NAME)`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要使用 ConfigMap 值中的一个作为在容器内运行的命令传递的参数，也可以这样做。当您通过 `env` 和名称指定环境变量时，您可以在 Pod
    规范中的其他地方引用该变量使用 `$(ENVIRONMENT_VARIABLE_NAME)`。
- en: 'For example, the following `spec` snippet uses the environment variable in
    the invocation of the container:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下 `spec` 片段在容器调用中使用了环境变量：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Exposing ConfigMap as files inside the container
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器内部将 ConfigMap 暴露为文件
- en: 'Exposing ConfigMap data into files within a container is very similar to how
    annotations and labels are exposed into a container. There are two parts to the
    specification on a Pod. The first is defining a volume for the container, including
    a name for it, and the location for where it should be mounted:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将ConfigMap数据暴露到容器中的文件中，与如何将注释和标签暴露到容器中非常相似。Pod规范有两个部分。第一部分是为容器定义一个卷，包括名称和应该挂载的位置：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The second part is a volume description that references the same name for the
    volume and lists ConfigMap as a property to indicate where to get the values:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是一个卷描述，引用了相同的卷名称，并将ConfigMap列为属性，指示从哪里获取这些值：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Once that specification is applied, the values will be available as files within
    the container:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用了该规范，这些值将作为容器内的文件可用：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can use either environment variables or config files to provide the configuration
    data to your application, just depending on which is easier or more comfortable
    for your needs. We will update the examples to use ConfigMaps and adding ConfigMaps
    to deployments as well as reference the values within the code for the sample
    applications.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用环境变量或配置文件来为应用程序提供配置数据，只需取决于哪种方式更容易或更符合您的需求。我们将更新示例，使用ConfigMaps并将ConfigMaps添加到部署中，并在示例应用程序的代码中引用这些值。
- en: Dependencies on ConfigMaps
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对ConfigMaps的依赖
- en: If you start referencing a ConfigMap in a Pod specification, you are creating
    a dependency on that ConfigMap for your resources. For example, if you added some
    of the preceding examples to expose `example-data` as an environment variable,
    but hadn’t added the `example-config` ConfigMap to Kubernetes, when you try to
    deploy or update the Pod, it will report an error.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您开始在Pod规范中引用ConfigMap，那么您正在为资源创建对该ConfigMap的依赖。例如，如果您添加了一些前面的示例来将`example-data`暴露为环境变量，但尚未将`example-config`
    ConfigMap添加到Kubernetes中，当您尝试部署或更新Pod时，它将报告错误。
- en: 'If this happens, the error will generally be reported in `kubectl get pods`
    or will be visible in the event log:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，错误通常会在`kubectl get pods`中报告，或者在事件日志中可见：
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If you add the ConfigMap after the fact, the Pod will start when the resource
    it needs is available.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在事后添加ConfigMap，当Pod需要的资源可用时，Pod将启动。
- en: Kubernetes resource – Secrets
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes资源 - Secrets
- en: ConfigMaps are great for general configuration, but are easily visible—which
    may not be desired. For some configuration, such as passwords, authorization tokens,
    or API keys, you often want a more controlled mechanism to protect those values.
    That’s what the resource Secrets are designed to solve.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMaps非常适用于一般配置，但很容易被看到，这可能不是期望的。对于一些配置，例如密码、授权令牌或API密钥，通常希望有一种更受控制的机制来保护这些值。这就是资源Secrets旨在解决的问题。
- en: Secrets are generally created (and managed) individually, and internally Kubernetes
    stores this data using `base64` encoding.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets通常是单独创建（和管理）的，并且在内部Kubernetes使用`base64`编码存储这些数据。
- en: 'You can create a secret on the command line by first writing the values into
    one or more files, and then specifying those files in the `create` command. Kubernetes
    will take care of doing all the relevant `base64` encoding and storing them away.
    For example, if you wanted to store a database username and password, you might
    do the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过首先将值写入一个或多个文件，然后在`create`命令中指定这些文件来在命令行上创建一个secret。Kubernetes将负责进行所有相关的`base64`编码并将其存储起来。例如，如果您想要存储数据库用户名和密码，您可以执行以下操作：
- en: '[PRE58]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that in naming the secret's name, you can use any alphanumeric character,
    a `-` or `.`, but an underscore is not allowed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在命名secret的名称时，您可以使用任何字母数字字符，`-`或`.`，但不允许使用下划线。
- en: 'If you use the following command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用以下命令：
- en: '[PRE59]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can see the Secret we just created:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们刚刚创建的秘密：
- en: '[PRE60]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And by using the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用以下方式：
- en: '[PRE61]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You see the secret reported as type `Opaque` and just the number of bytes associated
    with the data.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到秘密报告为类型`Opaque`，并且与数据关联的字节数。
- en: 'You can still get the secret using the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以使用以下方式获取秘密：
- en: '[PRE63]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This will reveal the `base64` encoded values:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示`base64`编码的值：
- en: '[PRE64]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And if you `base64` decode the value, you will see the original version:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您`base64`解码该值，您将看到原始版本：
- en: '[PRE65]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Be aware that anyone with access to your Kubernetes cluster resources can retrieve
    and view these secrets. Additionally, I do not recommend that you manage secrets
    like the rest of the declaration, stored in source control. Doing so exposes those
    secrets (in `base64` form) in your source control system.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，任何可以访问您的Kubernetes集群资源的人都可以检索和查看这些秘密。此外，我不建议您像其他声明一样管理秘密，存储在源代码控制中。这样做会在您的源代码控制系统中暴露这些秘密（以`base64`形式）。
- en: Exposing Secrets into a container
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将秘密暴露到容器中
- en: We can expose Secrets to a Pod in a very similar fashion to exposing ConfigMaps.
    Like ConfigMaps, you can choose to expose a Secret as an environment variable,
    or as a file mounted within a volume, specified by the Pod.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以与暴露ConfigMaps非常相似的方式将秘密暴露给Pod。与ConfigMaps一样，您可以选择将秘密作为环境变量或作为卷中的文件暴露，由Pod指定。
- en: The format for exposing a secret looks identical to exposing a ConfigMap value,
    except that it uses `secretKeyRef` instead of `configMapRef` in the specification.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露秘密的格式看起来与暴露ConfigMap值的格式相同，只是在规范中使用`secretKeyRef`而不是`configMapRef`。
- en: 'As an example, to expose the preceding example secret password as an environment
    variable, you might use the following in a Pod specification:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将前面的示例秘密密码作为环境变量暴露，您可以在Pod规范中使用以下内容：
- en: '[PRE67]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then looking within the container, the environment variables container `DB_PASSWORD`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在容器内查看，环境变量容器`DB_PASSWORD`：
- en: '[PRE68]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: A better path is to leverage the capability that Kubernetes includes for mounting
    secrets to be exposed as files inside the container. The configuration is very
    similar to exposing ConfigMap values, only defining the Secret as a volume property
    in the spec rather than ConfigMap.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是利用Kubernetes包含的将秘密挂载为容器内文件的能力。配置与暴露ConfigMap值非常相似，只是在规范中将Secret定义为卷属性，而不是ConfigMap。
- en: 'In the specification, you need to define a `volumeMount` for the container,
    which indicates its location in the container:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在规范中，您需要为容器定义一个`volumeMount`，指示其在容器中的位置：
- en: '[PRE71]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'And then define how the contents of that volume get populated from secrets:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后定义如何从秘密中填充该卷的内容：
- en: '[PRE72]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'After deploying with this configuration, the container has a `/secrets/db_password`
    file with the contents from our secret:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 部署使用此配置后，容器中将有一个`/secrets/db_password`文件，其中包含来自我们秘密的内容：
- en: '[PRE73]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Secrets and security – how secret are the secrets?
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 秘密和安全性-秘密有多秘密？
- en: Reasonably so, but not cryptographically secure, at least in Kubernetes 1.8\.
    If you are looking at the secrets from a security perspective, the constraints
    on secrets are better than leaving values in ConfigMap, but the security profile
    has significant limits.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 合理地说，但在Kubernetes 1.8中至少不是密码学安全的。如果您从安全的角度看待秘密，那么对秘密的约束要比将值留在ConfigMap中好，但安全配置文件有显着的限制。
- en: At the heart, the data for secrets is stored in plain-text (albiet encoded text)
    in etcd 3.0, which underpins Kubernetes 1.8\. It does not use encryption at rest,
    or symmetric keys to preserve (and access) the secrets. If you are running your
    own Kubernetes cluster, be aware that an unsecured etcd represents a significant
    weakness in the overall security of the cluster.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，密钥的数据以明文（尽管编码文本）存储在etcd 3.0中，etcd 3.0是Kubernetes 1.8的基础。它不使用静态密钥来保留（和访问）密钥。如果您正在运行自己的Kubernetes集群，请注意，未经保护的etcd代表集群整体安全性的一个重大弱点。
- en: For many applications and use cases, this is perfectly acceptable, but if you
    need to accommodate a higher security profile in your development and production
    environments, then you will want to look at tooling to work in conjunction with
    Kubernetes. The most commonly discussed alternative/extension is Vault, an open
    source project from HashiCorp. You can find more details about Vault at [https://www.vaultproject.io](https://www.vaultproject.io).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用程序和用例，这是完全可以接受的，但如果您需要在开发和生产环境中适应更高的安全配置文件，那么您将需要查看与Kubernetes配合使用的工具。最常讨论的替代/扩展是Vault，这是HashiCorp的一个开源项目。您可以在[https://www.vaultproject.io](https://www.vaultproject.io)找到有关Vault的更多详细信息。
- en: The Kubernetes project also isn’t standing still in regards to secrets and secret
    management, improving on their features as well. With the 1.7 release, Kubernetes
    included **Role-Based Access Control** (**RBAC**), and the project is maintaining
    and developing against a roadmap that will improve Kubernetes, capabilities around
    its security profile, as well as supporting easier coordination with external
    sources of secrets management (such as Vault) in the future.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes项目在秘密和秘密管理方面也在不断发展。在1.7版本中，Kubernetes包括**基于角色的访问控制**（**RBAC**），该项目正在根据路线图维护和开发，以改进Kubernetes的功能，提高其安全配置文件的能力，并在未来支持更容易与外部秘密管理源（如Vault）协调。
- en: Example – Python/Flask deployment with ConfigMap
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-使用ConfigMap的Python/Flask部署
- en: This example builds on our earlier Python/Flask example. This extension will
    add a ConfigMap that uses both environment variables and structured files, as
    well as code updates to consume and use those values.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例建立在我们之前的Python/Flask示例之上。此扩展将添加一个使用环境变量和结构化文件的ConfigMap，以及用于消耗和使用这些值的代码更新。
- en: 'To start, add a ConfigMap with both top-level values and a deeper configuration.
    The top values will be exposed as environment variables, and the multiline YAML
    will be exposed as a file inside the container:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加一个包含顶级值和更深层配置的ConfigMap。顶级值将公开为环境变量，多行YAML将公开为容器内的文件：
- en: '[PRE76]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This ConfigMap is mapped with updates to the Pod specification of the deployment
    with the `envFrom` key and as a volume to provide the file mapping:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ConfigMap与部署的Pod规范映射，使用`envFrom`键，并作为卷提供文件映射：
- en: '[PRE77]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This update makes a dependency on having a ConfigMap named `flask-config` on
    the Deployment. If the ConfigMap isn’t loaded and we try to load just that updated
    Deployment, it will not update the Deployment until that ConfigMap is available.
    To avoid the situation of accidentally missing a file, you can put both the ConfigMap
    and Deployment Spec in the same YAML file, separated by `---` on a new line. Then,
    you can deploy multiple resources in the order you specify when using the `kubectl
    apply` command.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此更新对部署有一个名为`flask-config`的ConfigMap的依赖。如果ConfigMap没有加载，并且我们尝试加载更新的部署，它将不会更新部署，直到该ConfigMap可用。为了避免意外丢失文件的情况，您可以将ConfigMap和部署规范放在同一个YAML文件中，用新行上的`---`分隔。然后，您可以在使用`kubectl
    apply`命令时按照指定的顺序部署多个资源。
- en: You may also keep each resource in a separate file, if that is easier to understand
    or manage, primarily depending on your preference. The `kubectl apply` command
    includes options to reference all files in a directory, including recursively–so
    order and structure the files; however, it makes the most sense to manage them
    yourself.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将每个资源保存在单独的文件中，如果这样更容易理解或管理，主要取决于您的偏好。`kubectl apply`命令包括选项来引用目录中的所有文件，包括递归地
    - 因此，对文件进行排序和结构化；但是，最好自己管理它们。
- en: 'To match this example, the code at [https://github.com/kubernetes-for-developers/kfd-flask](https://github.com/kubernetes-for-developers/kfd-flask)
    has a tag that you can use to update all the files at once:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了匹配这个示例，[https://github.com/kubernetes-for-developers/kfd-flask](https://github.com/kubernetes-for-developers/kfd-flask)上的代码有一个标签，您可以使用它来一次更新所有文件：
- en: '[PRE78]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '(If you skipped the earlier example, you may need to clone the repository first:
    `git clone https://github.com/kubernetes-for-developers/kfd-flask`)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: （如果您跳过了之前的示例，您可能需要首先克隆存储库：`git clone https://github.com/kubernetes-for-developers/kfd-flask`）
- en: 'With the code updated, deploy the updates:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 更新代码后，部署更新：
- en: '[PRE79]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Once deployed, you may use `kubectl exec` to run an interactive shell in the
    Pod and inspect the deployment and what has been exposed.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 部署后，您可以使用`kubectl exec`在Pod中运行交互式shell，并检查部署和已暴露的内容。
- en: SIDEBAR – JSONPATH
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侧边栏 - JSONPATH
- en: 'We might look up the specific Pod using a command like the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似以下命令查找特定的Pod：
- en: '[PRE80]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This will find just the pods matching the `app=flask` selector and print out
    human-readable output akin to the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅查找与`app=flask`选择器匹配的Pod，并打印出类似以下的人类可读输出：
- en: '[PRE81]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This same data is available in a structured form (JSON, YAML, and so on) that
    we can parse with tools such as `jq`. Kubectl includes two additional options
    to make it a more convenient tool—you can use `JSONPATH or GO_TEMPLATE` to dig
    out specific values. With `JSONPATH` built into the `kubectl` client instead of
    doing the preceding two-step process to get the Pod name, you can directly get
    the specific details we want to use, which is the name:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这些相同的数据以结构化形式（JSON、YAML等）可用，我们可以使用诸如`jq`之类的工具进行解析。Kubectl包括两个额外的选项，使其成为一个更方便的工具
    - 您可以使用`JSONPATH或GO_TEMPLATE`来挖掘特定的值。使用内置到`kubectl`客户端的`JSONPATH`，而不是执行前面的两步骤来获取Pod名称，您可以直接获取我们想要使用的特定细节，即名称：
- en: '[PRE82]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This should return the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回以下内容：
- en: '[PRE83]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This can be easily embedded into a shell command using `$()` to execute it inline.
    This ends up being a much more complex command, but it takes care of the step
    where we ask Kubernetes what the relevant Pod name is, which is critical for many
    of the interaction commands.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以很容易地嵌入到一个shell命令中，使用`$()`来内联执行它。这最终会成为一个更复杂的命令，但它会处理我们询问Kubernetes相关Pod名称的步骤，这对于许多交互命令来说至关重要。
- en: 'As an example, we can open an interactive shell within the Pod associated with
    this deployment using the following command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用以下命令在与此部署相关联的Pod中打开交互式shell：
- en: '[PRE84]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This gets the name of the Pod and embeds that into `kubectl exec` to run an
    interactive session with the `/bin/sh` command.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这获取了Pod的名称，并将其嵌入到`kubectl exec`中，以使用`/bin/sh`命令运行交互式会话。
- en: 'Once you have this session open, you can see the environment variables that
    have been set with the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您打开了这个会话，您可以查看已设置的环境变量，如下所示：
- en: '[PRE85]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This will show you all the environment variables set, one of which should be
    the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示设置的所有环境变量，其中之一应该是以下内容：
- en: '[PRE86]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You can see the more complex configuration data:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看更复杂的配置数据：
- en: '[PRE87]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: We crafted the ConfigMap to have the correct location for this file based on
    what we put into the Deployment specification. If we change the Deployment Spec,
    but not the ConfigMap, the location embedded within the environment variable `CONFIG_FILE`
    will then be incorrect.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们精心制作了ConfigMap，根据我们放入部署规范的内容，为该文件的正确位置。如果我们更改部署规范，但不更改ConfigMap，则嵌入在环境变量`CONFIG_FILE`中的位置将不正确。
- en: With Kubernetes Deployment, ConfigMap, and Service specifications in YAML, there
    is a lot of duplicate data that is not abstracted out. From a developer’s perspective,
    this will feel awkward, violating the do not repeat yourself mantra that is commonly
    respected. There is a lot of repetition and places for small changes to unfortunately
    impact on the deployment specification.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes部署、ConfigMap和服务规范的YAML，存在许多未抽象出的重复数据。从开发人员的角度来看，这将感到尴尬，违反了常见的不要重复自己的口头禅。有很多重复和小改变的地方，不幸地影响了部署规范。
- en: The Kubernetes project is evolving the means of interacting with these files,
    with efforts to make generating the relevant configurations more with projects
    that are still early in development. As Kubernetes continues to mature, this should
    evolve to have more code-like qualities when defining the resource declarations.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes项目正在发展与这些文件交互的方式，努力使生成相关配置更加与仍处于早期开发阶段的项目相匹配。随着Kubernetes的不断成熟，在定义资源声明时，这应该会演变为更具有代码样式的特质。
- en: Using the ConfigMap within Python/Flask
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python/Flask中使用ConfigMap
- en: 'Within Python, you can view environment variables using os.environ, for example:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，您可以使用os.environ查看环境变量，例如：
- en: '[PRE88]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You can set a default value when using `os.environ.get` in your code to handle
    a case when the environment variable isn’t set:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中使用`os.environ.get`时，您可以设置默认值来处理环境变量未设置的情况：
- en: '[PRE89]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We set the `CONFIG_FILE` environment variable here to show you how it could
    be done, but it is not strictly necessary to read the configuration file–more
    a convenience to allow you to override that value if desired.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里设置`CONFIG_FILE`环境变量，以向您展示如何完成此操作，但严格来说，不一定需要读取配置文件-更多是为了方便您在需要时覆盖该值。
- en: 'Python also includes a module to parse and read INI-style configuration files,
    like the one we added in ConfigMap. Continuing with the example:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Python还包括一个模块来解析和读取INI风格的配置文件，就像我们在ConfigMap中添加的那样。继续使用示例：
- en: '[PRE90]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'From here, ConfigParser has loaded a section named `DEFAULT` with all the environment
    variables, and we could retrieve one of them:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，ConfigParser已加载了名为`DEFAULT`的部分，其中包含所有环境变量，我们可以检索其中的一个：
- en: '[PRE91]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We can extend the parser with a section based on the INI file stored in that
    ConfigMap, which is exposed on the filesystem at `/etc/flask-config/feature.flags`
    with the following code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用基于存储在ConfigMap中的INI文件的部分来扩展解析器，该文件在文件系统上公开为`/etc/flask-config/feature.flags`，代码如下：
- en: '[PRE92]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'And now the parser will be loaded with the `DEFAULT` section from the environment
    variables, and the `''features''` section from the ConfigMap data:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在解析器将加载来自环境变量的`DEFAULT`部分和来自ConfigMap数据的`'features'`部分：
- en: '[PRE93]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'And the ConfigParser enables you to include defaults in your code as well:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigParser还可以使您在代码中包含默认值：
- en: '[PRE94]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We then use that kind of code to set debugging enabled or disabled based on
    that ConfigMap:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用这种代码来根据ConfigMap设置调试启用或禁用：
- en: '[PRE95]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: You can find more details on how to leverage Python 3’s ConfigParser at [https://docs.python.org/3/library/configparser.html](https://docs.python.org/3/library/configparser.html).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.python.org/3/library/configparser.html](https://docs.python.org/3/library/configparser.html)找到有关如何利用Python
    3的ConfigParser的更多详细信息。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to take advantage of the declarative nature
    of Kubernetes in detail and managing our application through specification files.
    We also looked at Annotations, ConfigMap, and Secrets and how those can be created
    and then used from within Pods. We closed the chapter with updating our Python
    and Node.js applications to use ConfigMaps to run the example code we set up previously,
    and looked briefly at how to leverage the built-in `JSONPATH` within `kubectl`
    to make that tool more immediately powerful at providing the specific information
    you want.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细讨论了如何充分利用Kubernetes的声明性特性，并通过规范文件来管理我们的应用程序。我们还讨论了Annotations、ConfigMap和Secrets以及如何创建并在Pods内部使用它们。我们在本章中还更新了我们的Python和Node.js应用程序，以使用ConfigMaps来运行我们之前设置的示例代码，并简要介绍了如何利用kubectl中内置的`JSONPATH`来使该工具更具即时提供所需特定信息的强大功能。
