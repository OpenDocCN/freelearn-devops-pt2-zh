- en: Pod and Container Lifecycles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pod和容器的生命周期
- en: With Kubernetes being a declarative system, the lifecycle and hooks that are
    offered for Pods and Containers are the points where your code can take actions.
    Pods have a lifecycle, as do containers, and Kubernetes offers a number of places
    where you can provide explicit feedback to the system to have it operate as you’d
    like. In this chapter, we will dig into the expected lifecycle, hooks available
    to use, and examples of how to use them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Kubernetes是一个声明性系统，为Pod和容器提供的生命周期和钩子是代码可以采取行动的地方。Pod有一个生命周期，容器也有一个生命周期，Kubernetes提供了许多地方，您可以向系统提供明确的反馈，以便它按照您的意愿运行。在本章中，我们将深入探讨预期的生命周期，可用的钩子以及如何使用它们的示例。
- en: 'The topics will include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 主题将包括：
- en: Pod lifecycle
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod生命周期
- en: Container lifecycle
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器生命周期
- en: Probes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探针
- en: 'Container hook: post-start and pre-stop'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器钩子：post-start和pre-stop
- en: Initialization containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化容器
- en: How to handle a graceful shutdown
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理优雅关闭
- en: Pod lifecycle
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pod生命周期
- en: The lifecycle of a Pod is an aggregate of several components, as a Pod has a
    number of moving parts that can be in a variety of states as it operates. The
    representation of the lifecycle is how Kubernetes manages running your code for
    you, in conjunction with the control and feedback loops that work from the various
    controllers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Pod的生命周期是几个组件的聚合，因为Pod有许多移动部分，可以处于各种状态，它的表示是Kubernetes如何管理你的代码运行，与各种控制器一起工作的控制和反馈循环。
- en: '![](assets/ab64835b-8b77-4df5-8e09-b3f564cea9c8.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ab64835b-8b77-4df5-8e09-b3f564cea9c8.png)'
- en: 'The states of a Pod''s lifecycle are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Pod生命周期的状态有：
- en: '**Pending**: The Pod has been created through the API, and is in the process
    of being scheduled, loaded, and run on one of the Nodes'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起**：Pod已通过API创建，并正在被调度，加载并在其中一个节点上运行的过程中'
- en: '**Running**: The Pod is fully operational and the software is running within
    the cluster'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行**：Pod完全运行，并且软件在集群中运行'
- en: '**Succeeded (or) Failed**: The Pod has finished operation (normally or crashed)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成功（或）失败**：Pod已完成操作（正常或崩溃）'
- en: '**There is a fourth state**: Unknown, which is a fairly rare occurrence and
    is typically only seen when there’s a problem internal to Kubernetes where it
    doesn’t know the current state of containers, or is unable to communicate with
    its underlying systems to determine that state'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**还有第四种状态**：未知，这是一个相当罕见的情况，通常只在Kubernetes内部出现问题时才会出现，它不知道容器的当前状态，或者无法与其底层系统通信以确定该状态。'
- en: If you are working with long-running code in Containers, then most of the time
    will be spent in running. If you are making use of shorter, batch-oriented code
    within Kubernetes using Job or CronJob, then the final status (Succeeded or Failed)
    may be what you are interested in.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在容器中运行长时间运行的代码，那么大部分时间将花在运行中。如果您在Kubernetes中使用Job或CronJob运行较短的批处理代码，则最终状态（成功或失败）可能是您感兴趣的。
- en: Container lifecycle
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器生命周期
- en: 'Containers also have a state that is managed individually for them, since each
    Pod can have one or more Containers. The Container states are simpler and quite
    direct:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个Pod可以有一个或多个容器，因此容器也有一个由它们单独管理的状态。容器的状态更简单，而且非常直接：
- en: Waiting
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待
- en: Running
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行
- en: Terminated
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止
- en: '![](assets/f141ab2e-01ec-4e6e-be7c-7e5b0fa7c4e5.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f141ab2e-01ec-4e6e-be7c-7e5b0fa7c4e5.png)'
- en: The container states will all have a timestamp associated with them, indicating
    when the cluster recorded the container in that state. If more than one state
    has been processed through, there will also be a last state field. As containers
    are fairly ephemeral, it is fairly common to see a previous state of Terminated,
    which includes information about when the container started, when it finished,
    its exit code, and a string entry about why it terminated called Reason.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 容器状态都有与之关联的时间戳，指示集群记录容器处于该状态的时间。如果经过了多个状态的处理，还会有一个最后状态字段。由于容器相当短暂，因此通常会看到先前状态为
    Terminated，其中包括容器启动时间、完成时间、退出代码以及有关其终止原因的字符串条目。
- en: 'The following is an example of the container states after your Pod has been
    processing a while (and in this example, after it had been updated a couple of
    times):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在您的 Pod 处理一段时间后容器状态的示例（在此示例中，经过多次更新后）：
- en: '![](assets/99c93667-9d8e-47fa-928a-84350ce562d6.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/99c93667-9d8e-47fa-928a-84350ce562d6.png)'
- en: You can see the additional details in a human-readable format within the output
    of the `kubectl describe pod` command, which is often most convenient for quickly
    understanding what's happening within the Pod.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `kubectl describe pod` 命令的输出中以人类可读的格式看到额外的详细信息，这通常是快速了解 Pod 内发生的情况最方便的方法。
- en: The states all have additional information within them to provide detail on
    what's happening. There is a formal PodStatus object available via the API. Each
    state has additional details that are available, and more generally the status
    object includes a list of conditions that are commonly exposed and visible in
    the output of describe or the raw YAML.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有状态都包含额外的信息，以提供正在发生的详细信息。API 中有一个正式的 PodStatus 对象可用。每个状态都有可用的额外详细信息，而且通常状态对象包括一系列常见的条件，这些条件通常在描述或原始
    YAML 的输出中是可见的。
- en: 'Using the `kubectl get pod ... -o yaml` command, you can see the data in a
    machine-parsable form, and see that there''s an additional detail that isn''t
    also exposed in the `describe` command. In the following screenshot, you can see
    the output related to the Pod and container states, including the conditions,
    container states, and related timestamps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl get pod ... -o yaml` 命令，您可以以机器可解析的形式看到数据，并且可以看到在 `describe` 命令中未公开的额外详细信息。在以下截图中，您可以看到与
    Pod 和容器状态相关的输出，包括条件、容器状态和相关时间戳：
- en: '![](assets/4c10fb77-c0ba-475e-8df0-c79784239f98.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4c10fb77-c0ba-475e-8df0-c79784239f98.png)'
- en: Conditions are added to the state of a Kubernetes object as the object goes
    through its lifecycle.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Kubernetes 对象经历其生命周期，条件被添加到其状态中。
- en: '![](assets/487c3b4c-5af2-4f94-88bf-2a6846f910fa.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/487c3b4c-5af2-4f94-88bf-2a6846f910fa.png)'
- en: 'Within the Pod state pending, there are two conditions that are commonly added:
    `Initialized` and `PodScheduled`. If the cluster is unable to run the requested
    Pod, then you may see the condition `Unschedulable` instead of `PodScheduled`. When
    the Pod is in the state of Running, there is also the condition **Ready** that
    is relevant and affects Kubernetes’ management of your code.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pod 状态 pending 中，通常会添加两个条件：`Initialized` 和 `PodScheduled`。如果集群无法运行请求的 Pod，则可能会看到条件
    `Unschedulable` 而不是 `PodScheduled`。当 Pod 处于 Running 状态时，还有一个与之相关的条件 **Ready**，它会影响
    Kubernetes 对代码的管理。
- en: Deployments, ReplicaSets, and Pods
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署、ReplicaSets 和 Pods
- en: Pods are not the only Kubernetes resources that takes advantage of, and expose, conditions.
    Deployments also use conditions to represent detail such as to the progress of
    a rollout of a code update, and the overall availability of the deployment.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 不是唯一利用和暴露条件的 Kubernetes 资源。部署也使用条件来表示详细信息，例如代码更新的部署进度以及部署的整体可用性。
- en: 'The two conditions you will see when using Deployments are:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用部署时，您将看到的两个条件是：
- en: Progressing
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进展中
- en: Available
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用
- en: Available will be true when the minimum number of replicas of the underlying
    Pods is available (the default is 1). Progressing will be set when the ReplicaSets
    and their related Pods are created and as they come available.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当底层Pod的最小副本数可用时（默认为1）时，Available将为true。当ReplicaSets及其相关的Pods被创建并且可用时，将设置Progressing。
- en: 'Kubernetes uses a consistent pattern in how its internal resources are related
    to each other. As we discussed in an earlier chapter, Deployments will have associated
    ReplicaSets, and ReplicaSets will have associated Pods. You can visualize this
    like a chain of objects, with the higher level being responsible for watching
    and maintaining the state of the next level down:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes在其内部资源之间的关系上使用了一致的模式。正如我们在前一章中讨论的那样，部署将有关联的副本集，而副本集将有关联的Pod。您可以将此可视化为一系列对象，其中较高级别负责监视和维护下一级别的状态：
- en: '![](assets/9306c080-96f0-4c5c-b045-89e063278d7d.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9306c080-96f0-4c5c-b045-89e063278d7d.png)'
- en: We have been focusing on Pod states and their lifecycle because that is where
    the code is represented and actually running. In most cases, you will be creating
    a deployment that will, in turn, have its own state and conditions. That will,
    in turn, create a ReplicaSet, and the ReplicaSet will create the Pod or Pods.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在关注Pod的状态及其生命周期，因为那里代表了代码并且实际在运行。在大多数情况下，您将创建一个部署，然后该部署将有自己的状态和条件。这将进而创建一个ReplicaSet，而ReplicaSet将创建Pod或Pods。
- en: When a Pod is being created, the system will attempt to first create the API
    resource itself, and then it will attempt to find a place to run it within the
    cluster. When the resource has been created, the Initialized condition is added
    to the status. When the cluster has identified where to run the Pod, the PodScheduled
    condition will be added. If the cluster can’t find a location to run the Pod as
    you’ve described, then the `Unschedulable` condition is added to the status.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当正在创建一个Pod时，系统将首先尝试创建API资源本身，然后它将尝试在集群中找到一个运行它的位置。当资源已创建时，将向状态添加Initialized条件。当集群已确定在哪里运行Pod时，将添加PodScheduled条件。如果集群无法找到一个可以按照您描述的方式运行Pod的位置，则将向状态添加`Unschedulable`条件。
- en: Getting a snapshot of the current state
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取当前状态的快照
- en: 'You can see the current snapshot of what Kubernetes knows about the state of
    your code using the `kubectl describe` or `kubectl get` command. If you are just
    trying to see the state for yourself interactively, then the `kubectl describe`
    command is the most valuable. Remember that Kubernetes manages a chain of objects
    related to running your code, so if you want to see a full snapshot, you will
    want to look at the status of each of the objects: deployment, ReplicaSet, and
    Pods. In practice, looking at the state of deployment and then jumping down to
    Pods will often provide you with any detail you want.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`kubectl describe`或`kubectl get`命令查看Kubernetes对代码状态的当前快照。如果您只是想要交互式地查看状态，那么`kubectl
    describe`命令是最有价值的。请记住，Kubernetes管理与运行代码相关的一系列对象，因此如果您想要查看完整的快照，您将需要查看每个对象的状态：部署、ReplicaSet和Pods。实际上，查看部署的状态，然后跳转到Pods通常会为您提供所需的任何细节。
- en: 'You can see these details of what Kubernetes is doing with your code by looking
    at the raw data for your Pod using `kubectl get pod`, or by using the `describe`
    command. You want to look for `Status` and `Conditions`.  For example, when we
    earlier created a `nodejs` application deployment, the chain of objects created:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`kubectl get pod`查看Pod的原始数据，或者使用`describe`命令来查看Kubernetes对您的代码正在做什么。您需要查找`Status`和`Conditions`。例如，当我们之前创建了一个`nodejs`应用程序部署时，创建了一系列对象：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can see the snapshot of its current state using the `kubectl describe`
    command to look at the deployment:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`kubectl describe`命令查看部署的当前状态快照：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will present information that looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将呈现类似于以下信息：
- en: '![](assets/9891c670-bf4d-4b81-99f7-816736917932.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9891c670-bf4d-4b81-99f7-816736917932.png)'
- en: 'And you can use `kubectl describe` to get additional details by looking at
    the ReplicaSet:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`kubectl describe`通过查看ReplicaSet获取其他详细信息：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](assets/28406acd-c028-4c76-9b45-af93951aec4e.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/28406acd-c028-4c76-9b45-af93951aec4e.png)'
- en: 'And finally, use it one more time to look at the Pods created by the Deployment
    and ReplicaSet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，再次使用它来查看部署和ReplicaSet创建的Pod：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](assets/fc6e5004-3a19-4852-b6b1-58dd10ec74cf.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fc6e5004-3a19-4852-b6b1-58dd10ec74cf.png)'
- en: The events that are listed at the bottom of the output from `kubectl describe`
    will show you the sequence of what happened related to the Pod.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从`kubectl describe`输出底部列出的事件将显示与Pod相关的发生的顺序。
- en: 'If you want to use the status in a script, or otherwise use a program to parse
    the output, then you can use the `kubectl get` command, specifying a data format
    for the output such as YAML. For example, the same Pod output in YAML might be
    retrieved using the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在脚本中使用状态，或者以其他方式使用程序解析输出，那么可以使用`kubectl get`命令，指定输出的数据格式，如YAML。例如，可以使用以下命令检索YAML中的相同Pod输出：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The lower portion of the output under the key status will hold the state-snapshot
    information:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 输出底部的状态键下将保存状态快照信息：
- en: '![](assets/aac29ffc-2486-405a-b053-6fbdb449f2f2.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aac29ffc-2486-405a-b053-6fbdb449f2f2.png)'
- en: While not shown in the output from `kubectl describe`, each condition is tracked
    with a last updated time, a time when it last changed, a type, and a status. In
    addition, each container is listed with its own state.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在`kubectl describe`的输出中没有显示，但每个条件都有最后更新时间、上次更改时间、类型和状态。此外，每个容器都列有其自己的状态。
- en: 'The list of Pod conditions that you could see could grow with future versions
    of Kubernetes, and today includes the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在未来的Kubernetes版本中看到的Pod条件列表可能会增加，今天包括以下内容：
- en: '**PodScheduled**: Transitioned to true when the Pod has been scheduled on a
    Node and the process to start loading it onto the node has begun.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PodScheduled**：当Pod已在节点上调度并且开始将其加载到节点上的过程时转换为true。'
- en: '**Initialized**: Initialized will be marked true when all containers for the
    Pod have been loaded, and after any initialization containers defined have run
    to completion.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已初始化：当Pod的所有容器已加载，并且定义的任何初始化容器已运行完成时，将标记为true。
- en: '**Ready**: The Pod has been loaded and started per the specification. This
    value won’t be marked as true until the readiness probe and the liveness probe
    have completed successfully (if either or both are defined).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ready**：Pod已根据规范加载和启动。在就绪探测和存活探测成功完成（如果定义了任一或两者），此值不会标记为true。'
- en: '**Unschedulable**: This condition will only be listed and asserted when the
    Kubernetes cluster is unable to match available resources to the Pod’s needs.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unschedulable**：当Kubernetes集群无法将可用资源与Pod的需求匹配时，将列出并断言此条件。'
- en: Sometimes the states (such as `Succeeded` or `Failed`) will also include a `Reason`,
    which includes some text output intended to make it easier to understand what
    happened. And as you can see from the preceding output, timestamps are included
    for all the state changes. Since this is a snapshot in time, the timestamps can
    provide breadcrumb clues to understand the order of what happened, and how long
    ago it happened.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有时状态（例如`Succeeded`或`Failed`）还会包括一个`Reason`，其中包括一些文本输出，旨在使理解发生了什么变得更容易。正如您可以从前面的输出中看到的那样，所有状态更改都包括时间戳。由于这是一个时间点的快照，时间戳可以提供线索，以了解发生的顺序以及多久之前发生的。
- en: As a final note, the events associated with the Pod will often provide useful
    descriptive notes of what has happened (or failed to happen) while your Pod was
    starting. Utilizing all the details provided from describe, Pod status, conditions,
    and events, provides the best status updates external to the Pod’s logs themselves.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要注意的是，与Pod相关的事件通常会提供有用的描述性注释，说明在启动Pod时发生了什么（或者未发生什么）。利用从描述、Pod状态、条件和事件中提供的所有细节，可以提供最佳的状态更新，这些更新是Pod日志之外的外部状态更新。
- en: The lifecycle of Pods also includes hooks or feedback mechanisms that you can
    specify to allow your application to provide feedback on how it is doing. One
    of these mechanisms, the condition `Ready`, you have seen previously. Kubernetes
    lets your application provide specific feedback on if it is ready to accept traffic,
    and if it is healthy. These feedback mechanisms are called **probes**, and can
    be optionally defined in your Pod specification.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Pod的生命周期还包括您可以指定的钩子或反馈机制，以允许您的应用程序提供有关其运行情况的反馈。其中一个机制是`Ready`条件，您之前已经见过。Kubernetes允许您的应用程序提供特定的反馈，以确定它是否准备好接受流量，以及它的健康状况。这些反馈机制称为**探针**，可以选择在Pod规范中定义。
- en: Probes
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探针
- en: The two probes enabled in Kubernetes are the liveness probe and readiness Probe.
    They are complimentary, but different in intent and usage, and can be defined
    for each container within a Pod. In both cases, they provide a means for your
    code to influence how Kubernetes manages the containers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中启用的两种探针是存活探针和就绪探针。它们是互补的，但在意图和用法上有所不同，并且可以为Pod中的每个容器定义。
- en: Liveness probe
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存活探针
- en: 'The most basic probe is the Liveness probe. If defined, it provides a command
    or URL that Kubernetes can use to determine whether a Pod is still operational.
    If the call succeeds, Kubernetes will assume the container is healthy; if it fails
    to respond, then the Pod can be handled as the `restartPolicy` is defined. The
    result is binary: either the probe succeeds, and Kubernetes believes your Pod
    is running, or it fails, so Kubernetes believes your Pod is no longer functional.
    In the latter case, it will check with the defined RestartPolicy to choose what
    to do.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的探针是存活探针。如果定义了存活探针，它将提供一个命令或URL，Kubernetes可以使用它来确定Pod是否仍在运行。如果调用成功，Kubernetes将假定容器是健康的；如果未能响应，则可以根据定义的`restartPolicy`来处理Pod。结果是二进制的：要么探针成功，Kubernetes认为您的Pod正在运行，要么失败，Kubernetes认为您的Pod不再可用。在后一种情况下，它将根据定义的RestartPolicy来选择要执行的操作。
- en: The default value for `restartPolicy` is `Always`, meaning if a container within
    the Pod fails, Kubernetes will always attempt to restart it. Other values that
    you can define include `OnFailure` and `Never`. When a container is restarted,
    Kubernetes will track how often that occurs and will slow down the frequency of
    restarts if they are happening in quick succession, capped at a maximum of five
    minutes between restart attempts. The number of restarts is tracked and visible
    as `restartcount` in the output of `kubectl describe`, and the key `restartCount`
    in the data output from `kubectl get.`
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`restartPolicy`的默认值为`Always`，这意味着如果Pod中的容器失败，Kubernetes将始终尝试重新启动它。您可以定义的其他值包括`OnFailure`和`Never`。当容器重新启动时，Kubernetes将跟踪重新启动发生的频率，并且如果它们在快速连续发生，则会减慢重新启动的频率，最多在重新启动尝试之间间隔五分钟。重新启动次数在`kubectl
    describe`的输出中作为`restartcount`进行跟踪和可见，并且在`kubectl get`的数据输出中作为`restartCount`键进行跟踪。'
- en: If a liveness probe isn't explicitly defined, the probe is assumed to succeed
    and the container is automatically set to live. If the container itself were to
    crash or exit, Kubernetes would react and restart it as per the `restartPolicy`,
    but no other active checks are taking place. This allows you to handle a scenario
    where your code has frozen or deadlocked and is no longer responding, even though
    the process continues to run.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未明确定义存活探针，则假定探针将成功，并且容器将自动设置为活动状态。如果容器本身崩溃或退出，Kubernetes将做出反应并根据`restartPolicy`重新启动它，但不会进行其他活动检查。这允许您处理代码已经冻结或死锁并且不再响应的情况，即使进程仍在运行。
- en: 'A liveness probe can be defined to check the health of the Pod through one
    of three methods:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义存活探针来通过以下三种方法检查Pod的健康状况：
- en: '`ExecAction`: This invokes a command within the Pod to get a response, and
    the result of the exit code of that command invocation is what’s used in the liveness
    check. A result of anything other than `0` represents a failure.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecAction`：这在Pod内部调用命令以获取响应，并且该命令调用的退出代码的结果用于存活检查。除`0`之外的任何结果都表示失败。'
- en: '`TCPSocketAction`: This attempts to open a socket, but doesn’t manipulate or
    interact with the socket beyond attempting to open it. If the socket opens, the
    probe is successful, and if it fails or fails after a timeout, then the probe
    fails.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TCPSocketAction`：这尝试打开一个套接字，但除了尝试打开它之外，不会操作或与套接字交互。如果套接字打开，则探针成功，如果失败或在超时后失败，则探针失败。'
- en: '`HTTPGetAction`: Similar to the socket option, this makes an HTTP connection
    to your Pod as a URI specified, and the response code of the HTTP request is what
    is used to determine the success/failure of the liveness probe.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTPGetAction`：类似于套接字选项，这将作为指定的URI对您的Pod进行HTTP连接，并且HTTP请求的响应代码用于确定存活探针的成功/失败。'
- en: 'There are a number of variables that can configure the specifics of this probe
    as well:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多变量可以配置此探针的具体内容：
- en: '`activeDeadlineSeconds` (not set by default): This value is most commonly used
    with Jobs rather than long-running Pods to put a maximum cap on how long the job
    will be allowed to operate. This number will include any time taken by initialization
    containers, which will be discussed further later in this chapter.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activeDeadlineSeconds`（默认情况下未设置）：此值通常与作业一起使用，而不是长时间运行的Pod，以对作业的最长运行时间设置最大限制。此数字将包括初始化容器所花费的任何时间，稍后在本章中将进一步讨论这一点。'
- en: '`initialDelaySeconds` (not set by default): This allows you to specify the
    number of seconds before starting probe checks. This is not set by default, so
    effectively defaults to 0 seconds.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialDelaySeconds`（默认情况下未设置）：这允许您指定在开始探测检查之前的秒数。默认情况下未设置，因此实际上默认为0秒。'
- en: '`timeoutSeconds` (defaults to 1): This provides a timeout in case the command
    or URL request takes a significant period of time to return. If the timeout expires
    before the command returns, it is presumed to have failed.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeoutSeconds`（默认为1）：如果命令或URL请求需要很长时间才能返回，这提供了一个超时。如果超时在命令返回之前到期，则假定它已失败。'
- en: '`periodSeconds` (defaults to 10): This defines the frequency of how often Kubernetes
    will run the probe - either invoking the command, checking the socket availability,
    or making the URL request.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`periodSeconds`（默认为10）：这定义了Kubernetes运行探测的频率——无论是调用命令、检查套接字可用性还是进行URL请求。'
- en: '`successThreshold` (defaults to 1): This is the number of times that the probe
    needs to return success in order to set the state of the container to `active`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`successThreshold`（默认为1）：这是探测需要返回成功的次数，以便将容器的状态设置为“活动”。'
- en: '`failureThreshold` (defaults to 3): This is the minimum number of consecutive
    failures of the probe that will trigger marking the container as unhealthy.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failureThreshold`（默认为3）：这是触发将容器标记为不健康的探测的最小连续失败次数。'
- en: If you define a URL to request and leave everything else to defaults, the normal
    pattern will require three failure responses—a timeout or non-200 response code—before
    it will consider the container `dead` and apply the `restartPolicy`. Each check
    by default is 10 seconds apart, so your container could be dead for up to 30 seconds
    with these defaults before the system applies the `restartPolicy`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您定义一个URL来请求并将其他所有内容保持默认状态，正常模式将需要三个失败响应——超时或非200响应代码——然后才会考虑将容器标记为“死亡”并应用“restartPolicy”。默认情况下，每次检查间隔为10秒，因此在这些默认情况下，您的容器在系统应用“restartPolicy”之前可能会死亡长达30秒。
- en: 'If you are using an HTTP-based probe, you have a number of additional variables
    that can be defined while making the HTTP request:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用基于HTTP的探测，可以在进行HTTP请求时定义许多其他变量。
- en: '`host`: Defaults to the Pod IP address.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`：默认为Pod IP地址。'
- en: '`scheme`: HTTP or https. Kubernetes 1.8 defaults to HTTP'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scheme`：HTTP或https。Kubernetes 1.8默认为HTTP'
- en: '`path`: Path of the URI request.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：URI请求的路径。'
- en: '`HttpHeaders`: Any custom headers to be included in the request.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpHeaders`：要包含在请求中的任何自定义标头。'
- en: '`port`: Port on which to make the HTTP request.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`：进行HTTP请求的端口。'
- en: Readiness probe
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 就绪探测
- en: The second probe available is the readiness probe, most often used in parallel
    with the liveness probe. The readiness probe is expected to respond positively
    only when your application is ready and able to service normal requests. For example,
    if you want to wait until your database is fully operational, or pre-load some
    caches that can take a few seconds, you probably don’t want to return a positive
    response for a readiness probe until those operations have completed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个可用的探测是就绪探测，通常与活跃探测并行使用。就绪探测只有在应用程序准备好并能够处理正常请求时才会做出积极响应。例如，如果您希望等待直到数据库完全可操作，或者预加载一些可能需要几秒钟的缓存，您可能不希望在这些操作完成之前对就绪探测返回积极响应。
- en: Like the liveness probe, if it is not defined, the system assumes that as soon
    as your code is running that it is also ready to accept requests. If you have
    code that takes a few seconds to get fully operational, then it is very worthwhile
    to define and utilize a readiness probe, as this will work with any Services to
    automatically update Endpoints so that traffic isn’t routed to an instance when
    it is unable to service traffic.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与活跃探测一样，如果未定义，则系统会假定一旦您的代码运行，它也准备好接受请求。如果您的代码需要几秒钟才能完全运行，那么定义和利用就绪探测是非常值得的，因为这将与任何服务一起自动更新端点，以便在无法处理流量时不会将流量路由到实例。
- en: The same options are available for configuring a readiness probe, one of `ExecAction`,
    `TCPSocketAction`, or `HTTPGetAction`. As with the liveness probe, the same variables
    can be used to tune the frequency of probe requests, timeouts, and a number of
    successes and/or failures to trigger a state change. If you modified the values
    in your liveness probe, then you probably do not want to set your readiness probe
    to be any more frequent than your liveness probe.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 配置就绪探针的相同选项可用，其中之一是 `ExecAction`、`TCPSocketAction` 或 `HTTPGetAction`。与存活探针一样，可以使用相同的变量来调整探针请求的频率、超时以及触发状态更改的成功和/或失败次数。如果您修改了存活探针中的值，那么您可能不希望将就绪探针设置为比存活探针更频繁。
- en: As a reminder, when a readiness probe fails, a container isn’t automatically
    restarted. If you want that functionality, you should be using the liveness probe.
    The readiness probe is specifically set up to allow a Pod to indicate that it
    can’t yet process traffic, but it expects it will be able to shortly. As the probe
    updates, the Pod status will be updated to set Ready to be positive or negative,
    and the related Ready condition will also be updated. As this happens, any services
    that are using this pod will get notified of those updates and will change to
    send traffic (or not) based on the readiness value.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，当就绪探针失败时，容器不会自动重新启动。如果您需要该功能，您应该使用存活探针。就绪探针专门设置为允许 Pod 指示它尚不能处理流量，但它预计很快就能够。随着探针的更新，Pod
    状态将被更新为设置 Ready 为正或负，并且相关的 Ready 条件也将被更新。随着这一过程的发生，使用此 Pod 的任何服务都将收到这些更新的通知，并将根据就绪值更改发送流量（或不发送）。
- en: You can view the readiness probe as an implementation of the circuit breaker
    pattern, and a means of load shedding. While running with multiple copies of a
    Pod, if one instance gets overloaded or has some temporary condition, it can respond
    negatively to the readiness probe and the service mechanism within Kubernetes
    will direct any further requests to the other Pods.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将就绪探针视为断路器模式的实现，以及负载分担的一种手段。在运行多个 Pod 的情况下，如果一个实例过载或出现一些临时条件，它可以对就绪探针做出负面响应，Kubernetes
    中的服务机制将把任何进一步的请求转发到其他 Pod。
- en: Adding a probe to our Python example
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的 Python 示例添加探针
- en: 'Like previous examples, the code is available in GitHub in the [https://github.com/kubernetes-for-developers/kfd-flask](https://github.com/kubernetes-for-developers/kfd-flask) project. [I
    won''t show all the changes, but you can check out the code from branch `0.3.0`
    using this command: `git checkout 0.3.0`. The Docker images built from this code
    are likewise available under the `0.3.0` tag from the `quay.io` repository.](https://github.com/kubernetes-for-developers/kfd-flask)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前的示例一样，代码在 GitHub 中可用在 [https://github.com/kubernetes-for-developers/kfd-flask](https://github.com/kubernetes-for-developers/kfd-flask)
    项目中。[我不会展示所有更改，但您可以使用此命令从分支 `0.3.0` 检出代码：`git checkout 0.3.0`。从该代码构建的 Docker 镜像同样可以在
    `quay.io` 仓库的 `0.3.0` 标签下找到。](https://github.com/kubernetes-for-developers/kfd-flask)
- en: 'In this update, the project includes a secondary deployment of Redis to match
    some of the concepts from the previous chapter. The specification for the deployment
    has also been updated to specifically add a liveness probe and a readiness probe.
    The updated deployment specification now reads:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更新中，该项目包括了 Redis 的辅助部署，以匹配上一章中的一些概念。部署的规范也已更新，特别添加了存活探针和就绪探针。更新后的部署规范现在如下：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The probes are in bold. Both probes are using the same port as the rest of the
    application (`5000`), and their own respective endpoints. The liveness probe is
    set to delay one second before starting to check, and the readiness probe is set
    to delay five seconds before starting to check, and both are set to a slightly
    tighter frequency of five seconds.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 探针以粗体显示。两个探针都使用与应用程序的其余部分相同的端口（`5000`），以及它们自己各自的端点。就绪探针设置为延迟一秒开始检查，就绪探针设置为延迟五秒开始检查，两者都设置为稍微更紧密的频率，为五秒。
- en: The Python code has also been updated, primarily to implement the methods that
    respond to `/alive` and `/ready` for the liveness and readiness probes, respectively.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码也已经更新，主要是为了实现响应于就绪和活动探针的`/alive`和`/ready`方法。
- en: 'The liveness probe is the simplest, replying with a static response that just
    preserves the validation that the underlying flask code is responding to HTTP
    requests:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就绪探针是最简单的，只是回复一个静态响应，仅保留底层flask代码对HTTP请求的响应验证：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The readiness probe extends on this pattern, but verifies that an underlying
    service (Redis in this case) is available and responding before replying positively.
    This code doesn't actually rely on Redis, but in your own code you may rely on
    a remote service being available and have some method that will indicate if that
    service is both available and responsive. As mentioned earlier, this is effectively
    an implementation of the circuit breaker pattern, and along with the service construct,
    allows Kubernetes to help direct load to instances that can respond.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就绪探针扩展了这种模式，但在回复肯定之前验证了底层服务（在本例中为Redis）是否可用和响应。这段代码实际上并不依赖于Redis，但在您自己的代码中，您可能依赖于远程服务可用，并且有一些方法可以指示该服务是否可用和响应。如前所述，这实际上是断路器模式的一种实现，并且与服务构造一起，允许Kubernetes帮助将负载定向到可以响应的实例。
- en: 'In this case, we take advantage of the `redis ping()` capability, exposed in
    the Python library:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们利用了Python库中公开的`redis ping()`功能：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The other updates in the code initialize the `redis_store` variable in the code,
    and add the DNS entry to the matching service into a `configMap` so the application
    code can use it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的其他更新初始化了代码中的`redis_store`变量，并将DNS条目添加到`configMap`中，以便应用程序代码可以使用它。
- en: Running the Python probes example
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Python探针示例
- en: 'If you check out the `0.3.0` branch, you can investigate this code and run
    it locally in your own instance of Minikube or another Kubernetes cluster. To
    check out the code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看`0.3.0`分支，您可以调查此代码并在您自己的Minikube实例或另一个Kubernetes集群中本地运行它。要查看代码：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The final command will create the service and deployment `redis-master`, and
    the service, `configmap`, and deployment for the Python/flask code. If you then
    use the `kubectl describe` command, you can see the probes defined and their values:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个命令将创建`redis-master`的服务和部署，以及Python/flask代码的服务、configmap和部署。然后，您可以使用`kubectl
    describe`命令查看定义的探针及其值：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](assets/4c11e8f7-0b0f-4fb9-b60c-0aa2f9aa67a0.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4c11e8f7-0b0f-4fb9-b60c-0aa2f9aa67a0.png)'
- en: 'You can also look at the logs for the single flask Pod that''s operational
    and see the requests being processed:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以查看正在运行的单个flask Pod的日志，并查看正在处理的请求：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Adding a probe to our Node.js example
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的Node.js示例添加探针
- en: Adding example probes to the Node.js/express-based application follows exactly
    the same pattern as the Python application. And like the Python example, the code
    and specifications for this are available at GitHub under the [https://github.com/kubernetes-for-developers/kfd-nodejs](https://github.com/kubernetes-for-developers/kfd-nodejs) project,
    associated with branch `0.3.0`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 向基于Node.js/express的应用程序添加示例探测与Python应用程序完全相同的模式。与Python示例一样，此代码和规范可在GitHub的[https://github.com/kubernetes-for-developers/kfd-nodejs](https://github.com/kubernetes-for-developers/kfd-nodejs)项目下的分支`0.3.0`中找到。
- en: 'The probes add nearly the same specification to the Node.js deployment:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 探测器向Node.js部署添加了几乎相同的规范：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, the probes are requesting against the same HTTP responses that
    the application provides, and the same port. The URI paths are longer, taking
    advantage of the application's structure, which uses a single bit of code for
    routes under a specific URI, so we are able to bundle the readiness and liveness
    probes into a single new `probes.js` router.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，探测器请求与应用程序提供的相同的HTTP响应和相同的端口。URI路径更长，利用了应用程序的结构，该结构使用单个代码段用于特定URI下的路由，因此我们能够将就绪性和存活性探测器捆绑到一个新的`probes.js`路由中。
- en: The main application is updated to create a probes router and bind it in on
    application start, and then the code within the router itself provides the responses.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用程序已更新以创建一个探测器路由并在应用程序启动时绑定它，然后路由本身的代码提供响应。
- en: 'The code for `probes.js` is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`probes.js`的代码如下：'
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Like the preceding Python example, the liveness probe returns a static response,
    and is just used to validate that `express` is still responding to HTTP requests.
    The readiness probe is more involved, wrapping `db.ping()` in an asynchronous
    wait/catch and checking the value. If it's negative, or an error occurs, then
    we return a `500` response. If it's positive, then we return a static positive
    result.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的Python示例一样，存活性探测返回静态响应，仅用于验证`express`是否仍然响应HTTP请求。就绪性探测更为复杂，它在异步等待/捕获中包装了`db.ping()`并检查其值。如果为负，或发生错误，则返回`500`响应。如果为正，则返回静态的积极结果。
- en: 'Using `kubectl describe deployment nodejs` will show the configuration with
    the probes operational, very much like the Python example, and `kubectl log nodejs-65498dfb6f-5v7nc`
    will show the requests from the probes being responded to:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl describe deployment nodejs`将显示配置，其中包含操作探测器，非常类似于Python示例，而`kubectl
    log nodejs-65498dfb6f-5v7nc`将显示来自探测器的请求得到了响应：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can test the operation of the readiness probe by terminating the Redis service.
    If we invoke the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过终止Redis服务来测试就绪性探测的操作。如果我们调用以下命令：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Fairly shortly, the results of `kubectl get pods` will show the Pod alive,
    but not `ready`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get pods`的结果很快就会显示Pod是活动的，但不是`ready`的：'
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'While the `redis-master` deployment is shut down, you can get some interesting
    details from the Node.js deployment. Use `kubectl describe` to show the deployment:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当`redis-master`部署关闭时，您可以从Node.js部署中获取一些有趣的细节。使用`kubectl describe`来显示部署：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](assets/da7a3247-b66b-4996-95b3-e1e6d441ec52.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/da7a3247-b66b-4996-95b3-e1e6d441ec52.png)'
- en: 'And use `kubectl describe` to look at the related Pods as well:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用`kubectl describe`来查看相关的Pods：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](assets/60099d6b-f9f7-45fd-a898-93493110249a.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/60099d6b-f9f7-45fd-a898-93493110249a.png)'
- en: Note that `Condition Ready` is now `false`, and the status of the Node.js container
    has a state of `Running, but Ready of False`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Condition Ready`现在是`false`，而Node.js容器的状态为`Running`，但`Ready`为`False`。
- en: If the Redis deployment is recreated or restored, then the services will all
    come back online as you would expect.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新创建或恢复Redis部署，则服务将像您期望的那样全部恢复在线。
- en: Container lifecycle hooks
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器生命周期钩子
- en: Kubernetes also provides some hooks within the lifecycle of each container that
    can be used at setup and teardown time for containers. These are called container
    lifecycle hooks, and are defined for each container, rather than for the Pod overall.
    When you want to configure some additional functionality specific to the container
    when you have multiple containers per Pod, these can be extremely useful.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes还提供了一些在每个容器的生命周期中可以在容器的设置和拆卸时间使用的钩子。这些称为容器生命周期钩子，为每个容器定义，而不是为整个Pod定义。当您想要为Pod中的多个容器配置一些特定于容器的附加功能时，这些钩子非常有用。
- en: The two hooks you can define for each container are post-start and pre-stop.
    The post-start and pre-stop hooks are intended to be invoked at least once, but
    Kubernetes does not make any guarantees that these hooks will be invoked only
    once. This means while it is likely rare, the post-start or pre-stop hooks may
    be invoked more than once.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器可以定义两个钩子：post-start和pre-stop。post-start和pre-stop钩子预期至少被调用一次，但Kubernetes不保证这些钩子只会被调用一次。这意味着虽然可能很少见，post-start或pre-stop钩子可能会被调用多次。
- en: Neither of these hooks accept parameters, and are defined in the same fashion
    as a container’s run command. When used, they are expected to be self-contained,
    relatively short running commands that always return. When these hooks are being
    invoked, Kubernetes suspends management of the container until the hook completes
    and returns. Because of this, it is critical that executables invoked for these
    hooks don’t hang or run indefinitely, as Kubernetes doesn’t have a means of watching
    for this scenario and responding to a failure to complete or return a value.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些钩子都不接受参数，并且以与容器运行命令相同的方式定义。当使用时，它们预期是自包含的、相对短暂的命令，总是返回。当这些钩子被调用时，Kubernetes暂停对容器的管理，直到钩子完成并返回。因此，对于这些钩子调用的可执行文件不要挂起或无限运行至关重要，因为Kubernetes没有一种方式来监视这种情况并响应无法完成或返回值的失败。
- en: In the case of post-start, the container state won’t be moved to the Running
    state until the post-start hook. The post-start hook is also not guaranteed to
    be invoked either before or after the main command for the container is invoked.
    In the case of pre-stop, the container won’t be terminated until the pre-stop
    hook completes and is returned.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在post-start的情况下，容器状态直到post-start钩子完成之前不会转移到运行状态。post-start钩子也不能保证在容器的主要命令之前或之后被调用。在pre-stop的情况下，容器直到pre-stop钩子完成并返回后才会被终止。
- en: 'These two hooks can be invoked using one of two handlers: Exec and HTTP. Exec
    runs a specific command inside the container and in the same process space as
    the container, much like using a `kubectl exec` invocation. The HTTP handler sets
    up for an HTTP request against the container. In either case, if the hook returns
    a failure code the container is killed.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个钩子可以使用Exec和HTTP两种处理程序之一来调用：Exec在容器内部以及与容器相同的进程空间中运行特定命令，就像使用`kubectl exec`一样。HTTP处理程序设置用于针对容器的HTTP请求。在任何情况下，如果钩子返回失败代码，容器将被终止。
- en: The logs from these hooks are not exposed in Pod events or logging. If the handler
    fails, it broadcasts an event that can be seen with the `kubectl describe` command.
    These two events are `FailedPostStartHook` and `FailedPreStopHook`, respectively.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些钩子的日志不会在Pod事件或日志中公开。如果处理程序失败，它会广播一个事件，可以使用`kubectl describe`命令查看。这两个事件分别是`FailedPostStartHook`和`FailedPreStopHook`。
- en: The pre-stop hook can be very useful when you want an external command to be
    invoked to cleanly shut down a running process, such as invoking `nginx -s quit`.
    This can be especially useful if you're using someone else's code, especially
    if it has a more complex shutdown process than responding correctly to the SIGTERM
    signal. We will discuss how to gracefully shut down Kubernetes a bit later in
    this chapter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 预停钩子在你想要外部命令被调用来干净地关闭运行中的进程时非常有用，比如调用 `nginx -s quit`。如果你正在使用别人的代码，尤其是它有一个比正确响应
    SIGTERM 信号更复杂的关闭过程，这将特别有用。我们将在本章稍后讨论如何优雅地关闭 Kubernetes。
- en: 'The post-start hook is often useful when you want to create a semaphore file
    within the container, or invoke an HTTP request call whenever the container starts.
    More often, the need is for initialization or pre-condition validation before
    your main code starts, and there is another option to use for that functionality:
    initialization containers.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 后启动钩子在你想要在容器内创建一个信号文件，或者在容器启动时调用 HTTP 请求时经常有用。更常见的情况是在主代码启动之前进行初始化或前置条件验证，而有另一个选项可用于该功能：初始化容器。
- en: Initialization containers
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化容器
- en: Initialization containers are containers that can be defined on your Pod, and
    will be invoked in the specific sequence that they are defined prior to your main
    container (or containers) being started. Initialization containers became a normal
    part of Pod specification in Kubernetes version 1.6.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化容器是可以在你的 Pod 上定义的容器，并且将在定义它们之前的特定顺序中被调用，然后才会启动你的主容器（或容器）。初始化容器在 Kubernetes
    1.6 版本中成为 Pod 规范的正常部分。
- en: These containers can use the same container image and simply have alternate
    commands, but they can also use entirely different images, leveraging the Kubernetes
    Pod guarantees of shared network and filesystem mounts to do initialization and
    setup work prior to the main container operating. These containers also use namespaces,
    so they can be given specific access that the main container doesn't have; consequently,
    they can be given access to Kubernetes Secrets that the main container cannot
    access.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些容器可以使用相同的容器镜像并简单地具有替代命令，但它们也可以使用完全不同的镜像，利用 Kubernetes Pod 共享网络和文件系统挂载的保证来进行初始化和设置工作，以便在主容器运行之前进行。这些容器还使用命名空间，因此它们可以获得主容器没有的特定访问权限；因此，它们可以访问主容器无法访问的
    Kubernetes Secrets。
- en: Initialization containers are expected to have code that runs to completion
    and exits with a success response. As mentioned previously, these containers are
    also invoked in sequence, and will not run in parallel; each one has to complete
    before the next one will be started. When the containers have all completed, Kubernetes
    initializes the Pod and runs the defined container (or containers). If an initialization container
    fails, then the Pod is presumed to have failed and the whole kit is terminated
    (or more specifically, handled per the `restartPolicy`).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化容器预期具有可以运行到完成并以成功响应退出的代码。正如之前提到的，这些容器也按顺序调用，并不会并行运行；每个容器都必须在下一个容器启动之前完成。当所有容器都完成时，Kubernetes
    初始化 Pod 并运行定义的容器（或容器）。如果初始化容器失败，那么 Pod 被认为已经失败，并且整个套件被终止（或更具体地说，根据 `restartPolicy`
    处理）。
- en: Initialization containers allow you to do all kinds of setup prior to your main
    process being run. Some examples of what you might do include writing configuration
    files that the main Pod container needs to have, verifying that a service is available
    and active prior to starting the main container, retrieving and initializing content
    such as pulling data from a Git repository or file service, for the main container
    to use, or even just enforcing a delay prior to starting the main container or
    containers.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化容器允许您在运行主进程之前进行各种设置。您可能要做的一些例子包括编写主Pod容器需要的配置文件，验证服务在启动主容器之前是否可用和活动，检索和初始化内容，比如从Git存储库或文件服务中拉取数据供主容器使用，或者在启动主容器之前强制延迟。
- en: While the initialization containers are running, the Pod status will show `Init:`
    followed by some initialization container-specific state. If everything is going
    well and as expected, it will report the number of initialization containers that
    are listed and how many have been run to completion. If an initialization container
    fails, then `Init:` will be followed by `Error` or `CrashLoopBackOff`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化容器运行时，Pod状态将显示`Init:`，后面跟着一些初始化容器特定的状态。如果一切顺利，符合预期，它将报告列出的初始化容器数量以及已经完成运行的数量。如果初始化容器失败，那么`Init:`后面将跟着`Error`或`CrashLoopBackOff`。
- en: 'Initialization containers are specified in the Pod specification at the same
    level as the main container or containers and as a list, each with its own name,
    image, and command to invoke. For example, we could add an `init` container to
    our Python flask specification that will only return when Redis is up and available.
    An example of that might be the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化容器在Pod规范中被指定在与主容器相同级别的位置，并且作为一个列表，每个初始化容器都有自己的名称、镜像和要调用的命令。例如，我们可以在Python
    flask规范中添加一个`init`容器，它只会在Redis可用时才返回。一个例子可能是以下内容：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this case, the initialization container code is just a loop written in the
    shell that checks to see if there is a response to the DNS entry `redis-master`,
    and it runs indefinitely until that succeeds. If you were to look at the Pod prior
    to the `redis-master` service being established and having a relevant DNS entry,
    you would see the status of that Pod listed with `Init:0/1`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，初始化容器的代码只是一个在shell中编写的循环，检查是否有对`redis-master`的DNS条目的响应，并且会一直运行直到成功。如果在`redis-master`服务建立并具有相关的DNS条目之前查看Pod，您将看到该Pod的状态列出为`Init:0/1`。
- en: 'For example, `kubectl get pods`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，`kubectl get pods`:'
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](assets/7e5adb95-c678-498b-924e-112aba2a69f3.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7e5adb95-c678-498b-924e-112aba2a69f3.png)'
- en: You may notice that this output doesn't match the previous example; the command
    in the preceding output is looking for a DNS response to `redis`, where we named
    the service `redis-service`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，这个输出与之前的例子不匹配；在前面的输出中，命令是在寻找对`redis`的DNS响应，而我们将服务命名为`redis-service`。
- en: In this case, the initialization container will never complete and the Pod will
    remain in `pending` status indefinitely. In this case, you will need to manually
    delete the deployment, or if you make a modification that allows it to work, you
    will need to manually delete the Pods that are stuck initializing, as they won't
    otherwise be cleaned up.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，初始化容器将永远无法完成，Pod将无限期地保持在`pending`状态。在这种情况下，您需要手动删除部署，或者如果您进行了修改以使其工作，您需要手动删除那些卡在初始化状态的Pod，否则它们将无法被清理。
- en: Once the initialization container has completed successfully, you can see the
    results in the `kubectl describe` output from the Pod, or again via the data exposed
    with the `kubectl get` command.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化容器成功完成，您可以通过Pod的`kubectl describe`输出或者再次通过`kubectl get`命令暴露的数据来查看结果。
- en: The following is an extended example of the output that you will see from `kubectl
    describe`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你将从`kubectl describe`中看到的输出的扩展示例。
- en: '![](assets/3fd0907c-1d4c-4f56-a14c-20fee8b8ef12.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3fd0907c-1d4c-4f56-a14c-20fee8b8ef12.png)'
- en: 'The output of `describe` extends beyond a single Terminal page; you should
    continue to scroll down to see the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe`的输出超出了单个终端页面；你应该继续向下滚动以查看以下内容：'
- en: '![](assets/248aa190-9878-410a-a140-baba10022671.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/248aa190-9878-410a-a140-baba10022671.png)'
- en: Quick interactive testing
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速交互式测试
- en: If you are trying to make a quick one-liner initialization container, it's often
    useful to try out a command interactively, especially if you're using a very minimal
    container such as `busybox`. The commands you want may not be available, so it's
    best to try it out quickly to verify it can work as you expect.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图创建一个快速的一行初始化容器，尤其是当你使用非常简化的容器比如`busybox`时，交互式地尝试命令通常是很有用的。你想要的命令可能不可用，所以最好快速尝试一下，以验证它是否能按你的期望工作。
- en: 'To run a `busybox` container interactively, and delete it all when it''s complete,
    you can use a command such as the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要交互式地运行一个`busybox`容器，并在完成后删除它，你可以使用以下命令：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And then try out this command within the container:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在容器内尝试这个命令：
- en: '![](assets/ac15c96e-7170-4b62-bd3d-fe9562463fef.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ac15c96e-7170-4b62-bd3d-fe9562463fef.png)'
- en: Handling a graceful shutdown
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理优雅的关闭
- en: With the lifecycle hooks, we mentioned the pre-stop hook that can be defined
    and enabled, but if you're writing your own code, then you may find it just as
    easy to respect the SIGTERM signal that Kubernetes uses to tell containers to
    shut down.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在生命周期钩子中，我们提到了可以定义和启用的pre-stop钩子，但如果你正在编写自己的代码，那么尊重Kubernetes用于告诉容器关闭的SIGTERM信号可能同样容易。
- en: 'If you aren''t familiar with SIGTERM, it is one of the functions that Linux
    supports from the kernel—a means of sending an interrupt to a running process.
    The process can listen for these signals, and you can choose how they respond
    when they are received. There are two signals that you can''t `ignore` and the
    operating system will enforce, regardless of what you implement: SIGKILL and SIGSTOP.
    The signal that Kubernetes uses when it wants to shut down a container is SIGTERM.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉SIGTERM，它是Linux内核支持的功能之一——用于向运行中的进程发送中断的一种方式。进程可以监听这些信号，你可以选择它们在接收到时如何响应。有两个信号是你不能“忽略”的，无论你实现了什么，操作系统都会强制执行：SIGKILL和SIGSTOP。Kubernetes在想要关闭容器时使用的信号是SIGTERM。
- en: The kind of events where you will receive this signal aren't just on error or
    user-invoked deletion, but also when you roll out a code update leveraging the
    rolling update mechanism that deployment uses. It can also happen if you take
    advantage of any of the autoscaling features, which can dynamically increase (and
    decrease) the number of replicas within a `replicaSet`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你将收到这个信号的事件类型不仅仅是错误或用户触发的删除，还包括当你使用部署所使用的滚动更新机制进行代码更新时。如果你利用了任何自动扩展功能，它也可能发生，这些功能可以动态增加（和减少）`replicaSet`中的副本数量。
- en: When you respond to the signal, you will generally want to save any needed state,
    close any connections, and then terminate your application.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当你响应这个信号时，通常会想要保存任何需要的状态，关闭任何连接，然后终止你的应用程序。
- en: If you are creating a service that others will use through Kubernetes as well,
    then one of the first things you might want to do is change an internal variable
    that will trigger any readiness probe to respond with `false`, sleep for a few
    seconds, and then do any finalization and termination. That will allow the service
    construct within Kubernetes to redirect any further connections, and all active
    connections can be completed, drained, and shut down politely.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在创建一个其他人也会通过Kubernetes使用的服务，那么您可能想要做的第一件事之一是更改一个内部变量，以触发任何就绪探针以响应`false`，然后休眠几秒钟，然后进行任何最终操作和终止。这将允许Kubernetes中的服务构造重定向任何进一步的连接，并且所有活动连接都可以完成、排空并礼貌地关闭。
- en: Once Kubernetes sends the signal, it starts a timer. The default value of that
    timer is 30 seconds, and it can be defined on your Pod specification with the
    value `terminateGracePeriodSeconds` if you need or want a longer value. If the
    container hasn't exited by the time that timer expires, Kubernetes will attempt
    to force it using the SIGKILL signal.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Kubernetes发送信号，它就会启动一个计时器。该计时器的默认值为30秒，如果您需要或希望更长的值，可以在Pod规范中使用`terminateGracePeriodSeconds`的值进行定义。如果容器在计时器到期时尚未退出，Kubernetes将尝试使用SIGKILL信号强制退出。
- en: If you have invoked `kubectl delete deploy nodejs`, for example, and then seen
    the Pods remaining for a while with the status `Terminating`, that is what was
    happening.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您调用了`kubectl delete deploy nodejs`，然后看到Pods保持一段时间处于`Terminating`状态，那就是发生了这种情况。
- en: SIGTERM in Python
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的SIGTERM
- en: 'As an example, if you want to handle SIGTERM in Python, then you can import
    the signal module and reference a handler to do whatever you want. For example,
    a simple shut down immediately and exit bit of code might be:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想在Python中处理SIGTERM，那么您可以导入signal模块并引用一个处理程序来执行任何您想要的操作。例如，一个简单的立即关闭并退出的代码可能是：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The signal handler logic can be as complex, or as simple, as your code requires.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理程序的逻辑可以像您的代码要求的那样复杂或简单。
- en: SIGTERM in Node.js
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js中的SIGTERM
- en: 'As an example, if you want to handle SIGTERM in Node.js, then you can use the
    process module that is implicitly created in every Node.js process to handle the
    signals and to exit the application. To match the preceding Python example, a
    simple shut down immediately and exit bit of code might be as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想在Node.js中处理SIGTERM，那么您可以使用在每个Node.js进程中隐式创建的process模块来处理信号并退出应用程序。与之前的Python示例相匹配，一个简单的关闭立即并退出的代码可能如下所示：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started with looking at the Pod lifecycle and status details
    in depth, expanding to show multiple ways of revealing relevant details, and describing
    what Kubernetes does beneath the covers while running your software. We then looked
    at the feedback loops that your program can provide with liveness and readiness
    probes, and reviewed examples of enabling those in both Python and Node.js. Following
    on from the probes and how your code can interact with Kubernetes cleanly, we
    looked at the common cases for startup and initialization, and graceful shutdown.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们首先深入了解了Pod的生命周期和状态细节，展示了多种揭示相关细节的方式，并描述了Kubernetes在运行软件时的内部操作。然后，我们看了一下您的程序可以通过活跃性和就绪性探针提供的反馈循环，并回顾了在Python和Node.js中启用这些探针的示例。在探针和代码如何与Kubernetes清洁地交互之后，我们看了一下启动和初始化以及优雅关闭的常见情况。
- en: In the next chapter, we look at how to use Kubernetes and open source to provide
    basic observability for your applications, specifically monitoring and logging.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下如何使用Kubernetes和开源提供应用程序的基本可观察性，特别是监控和日志记录。
