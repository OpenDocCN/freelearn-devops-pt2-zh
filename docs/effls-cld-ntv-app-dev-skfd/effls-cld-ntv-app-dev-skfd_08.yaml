- en: '[*Chapter 6*](B17385_06_PreFinal_PD_ePub.xhtml#_idTextAnchor074): Working with
    Skaffold Container Image Builders and Deployers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第6章*](B17385_06_PreFinal_PD_ePub.xhtml#_idTextAnchor074)：使用Skaffold容器映像构建器和部署器'
- en: In the previous chapter, we took a deep dive into the Skaffold CLI and its pipeline
    stages. We also looked at the Skaffold configuration. In this chapter, we will
    introduce you to reactive programming by creating a Reactive Spring Boot CRUD
    application. We will then learn about Skaffold's pluggable architecture, which
    supports different methods of building and deploying container images to a Kubernetes
    cluster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们深入研究了Skaffold CLI及其流水线阶段。我们还研究了Skaffold配置。在本章中，我们将通过创建一个Reactive Spring
    Boot CRUD应用程序来向您介绍响应式编程。然后，我们将了解Skaffold的可插拔架构，该架构支持不同的构建和部署容器映像到Kubernetes集群的方法。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Creating a Reactive Spring Boot CRUD application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Reactive Spring Boot CRUD应用程序
- en: Working with Skaffold container image builders
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Skaffold容器映像构建器
- en: Exploring Skaffold container image deployers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Skaffold容器映像部署器
- en: By the end of this chapter, you will have gained a solid understanding of Skaffold's
    supported container image builders, including Jib, Docker, and Buildpacks. You
    will also learn about Helm, kubectl, and Kustomize, which are supported by Skaffold
    to help deploy your containerized application to Kubernetes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将对Skaffold支持的容器映像构建器（包括Jib、Docker和Buildpacks）有了扎实的理解。您还将了解到Helm、kubectl和Kustomize，这些工具由Skaffold支持，帮助您将容器化的应用程序部署到Kubernetes。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, you will need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中的示例，您将需要以下内容：
- en: Helm ([https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/))
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm ([https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/))
- en: Kustomize ([https://kubectl.docs.kubernetes.io/installation/kustomize/](https://kubectl.docs.kubernetes.io/installation/kustomize/))
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kustomize ([https://kubectl.docs.kubernetes.io/installation/kustomize/](https://kubectl.docs.kubernetes.io/installation/kustomize/))
- en: Eclipse ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/))
    or the IntelliJ IDE ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/))
    或 IntelliJ IDE ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
- en: Git ([https://git-scm.com/downloads](https://git-scm.com/downloads))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git ([https://git-scm.com/downloads](https://git-scm.com/downloads))
- en: Skaffold ([https://skaffold.dev/docs/install/](https://skaffold.dev/docs/install/))
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Skaffold ([https://skaffold.dev/docs/install/](https://skaffold.dev/docs/install/))
- en: Spring Boot 2.5
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 2.5
- en: OpenJDK 16
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenJDK 16
- en: minikube ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
    or Docker Desktop for macOS and Windows ([https://www.docker.com/products/dockerdesktop](https://www.docker.com/products/dockerdesktop))
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: minikube ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
    或Docker Desktop for macOS和Windows ([https://www.docker.com/products/dockerdesktop](https://www.docker.com/products/dockerdesktop))
- en: You can download the code examples for this chapter from this book's GitHub
    repository at [https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/tree/main/Chapter06](https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/tree/main/Chapter06).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本书的GitHub存储库[https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/tree/main/Chapter06](https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/tree/main/Chapter06)下载本章的代码示例。
- en: Creating a Reactive Spring Boot CRUD application
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Reactive Spring Boot CRUD应用程序
- en: To demonstrate working with various container image builders that Skaffold supports,
    we will create a simple Reactive Spring Boot `CRUD` REST application. We expose
    a REST endpoint called `/employee` when the app is accessed locally through curl
    or a REST client such as Postman, which will return with employee data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示使用Skaffold支持的各种容器镜像构建器，我们将创建一个简单的Reactive Spring Boot `CRUD` REST应用程序。当应用程序通过curl或Postman等REST客户端在本地访问时，我们会暴露一个名为`/employee`的REST端点，它将返回员工数据。
- en: First, to build some context, let's discuss the reactive way of building an
    application. Reactive programming (https://projectreactor.io/) is a new way of
    building non-blocking applications that are asynchronous, event-driven, and require
    a small number of threads to scale. What also keeps them separate from typical
    non-reactive applications is that they can provide the backpressure mechanism
    to ensure producers don't overwhelm consumers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了建立一些上下文，让我们讨论一下构建应用程序的反应式方式。反应式编程（https://projectreactor.io/）是构建非阻塞应用程序的一种新方式，它是异步的、事件驱动的，并且需要少量线程来扩展。它们与典型的非反应式应用程序的另一个区别是，它们可以提供背压机制，以确保生产者不会压倒消费者。
- en: Spring WebFlux is a reactive web framework that was introduced with Spring 5\.
    Spring WebFlux doesn't require a servlet container and can be run on non-blocking
    containers such as Netty and Jetty. We would need to add the `spring-boot-starter-webflux`
    dependency to add support for Spring WebFlux. With Spring MVC, we have Tomcat
    as the default embedded server, while with WebFlux, we get Netty. Spring WebFlux
    controllers typically return reactive types; that is, Mono or Flux instead of
    collections or domain objects.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux是一个反应式Web框架，是在Spring 5中引入的。Spring WebFlux不需要servlet容器，可以在非阻塞容器（如Netty和Jetty）上运行。我们需要添加`spring-boot-starter-webflux`依赖项来添加对Spring
    WebFlux的支持。使用Spring MVC时，我们有Tomcat作为默认的嵌入式服务器，而使用WebFlux时，我们得到Netty。Spring WebFlux控制器通常返回反应式类型，即Mono或Flux，而不是集合或领域对象。
- en: 'The following are the Maven dependencies that will be used for this Spring
    Boot application:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将用于此Spring Boot应用程序的Maven依赖项：
- en: '![Figure 6.1 – Maven dependencies'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 - Maven依赖项'
- en: '](image/Figure_6.1_B17385.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.1_B17385.jpg)'
- en: Figure 6.1 – Maven dependencies
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 - Maven依赖项
- en: 'Let''s start by walking through the code of the application:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从应用程序的代码开始讲解：
- en: 'Here, we have an employee table with five columns: `id`, `first_name`, `last_name`,
    `age`, and `salary`. The `id` column is auto-incremented. The other columns follow
    the default snake case naming scheme. The following `schema.sql` SQL file is available
    from the `src/main/resources/schema.sql` path, in the source code directory:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们有一个包含五列的员工表：`id`、`first_name`、`last_name`、`age`和`salary`。`id`列是自动递增的。其他列遵循默认的蛇形命名方案。以下的`schema.sql`
    SQL文件位于源代码目录中的`src/main/resources/schema.sql`路径下：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since the H2 driver is on the classpath and we don't have to specify a connection
    URL, Spring Boot automatically starts an embedded H2 database at application startup.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于H2驱动程序位于类路径上，我们不必指定连接URL，Spring Boot会在应用程序启动时自动启动嵌入式H2数据库。
- en: 'To initialize the database schema at application startup, we also need to register
    `ConnectionFactoryInitializer` to pick up the `schema.sql` file, as mentioned
    in the following main class for our application. Here, we are also saving a few
    `Employee` entities that we can use later:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在应用程序启动时初始化数据库架构，我们还需要注册`ConnectionFactoryInitializer`来获取`schema.sql`文件，如下面我们应用程序的主类所述。在这里，我们还保存了一些`Employee`实体，以便以后使用：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With Spring Data R2DBC, you don''t have to write an implementation of the repository
    interface as it creates an implementation for you at runtime. `EmployeeRepository`
    extends `ReactiveCrudRepository` and inherits various methods for saving, deleting,
    and finding employee entities using reactive types. Following is the CRUD repository:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Spring Data R2DBC，您不必编写存储库接口的实现，因为它会在运行时为您创建一个实现。`EmployeeRepository`扩展了`ReactiveCrudRepository`，并继承了使用响应式类型保存、删除和查找员工实体的各种方法。以下是CRUD存储库：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Following is the `EmployeeService` class:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`EmployeeService`类：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the following REST controller class, you can see that all the endpoints
    either return Flux or Mono reactive types:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下REST控制器类中，您可以看到所有端点都返回Flux或Mono响应式类型：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is the `Employee` domain class:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Employee`领域类：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s run this application with the `mvn spring-boot:run` command. You will
    see the following logs once the application is up and running:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`mvn spring-boot:run`命令运行此应用程序。一旦应用程序启动运行，您将看到以下日志：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the output after accessing the `/employee` REST endpoint:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`/employee` REST端点后的输出如下：
- en: '![Figure 6.2 – REST endpoint response'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – REST端点响应'
- en: '](image/Figure_6.2_B17385.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.2_B17385.jpg)'
- en: Figure 6.2 – REST endpoint response
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – REST端点响应
- en: In this section, we learned about the reactive programming model and created
    a Reactive Spring Boot CRUD application. In the next section, we will look at
    the different ways of containerizing your Java application with Skaffold.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了响应式编程模型，并创建了一个响应式Spring Boot CRUD应用程序。在下一节中，我们将看看使用Skaffold将您的Java应用程序容器化的不同方法。
- en: Working with Skaffold container image builders
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Skaffold容器镜像构建器
- en: 'From [*Chapter 3*](B17385_03_Final_PD_ePub.xhtml#_idTextAnchor034), *Skaffold
    – Easy-Peasy Cloud-Native Kubernetes Application Development*, we know that Skaffold
    currently supports the following container image builders:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从[*第3章*](B17385_03_Final_PD_ePub.xhtml#_idTextAnchor034)，*Skaffold – 简单易用的云原生Kubernetes应用开发*，我们知道Skaffold目前支持以下容器镜像构建器：
- en: Dockerfile
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile
- en: Jib (Maven and Gradle)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jib（Maven和Gradle）
- en: Bazel
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bazel
- en: Cloud-native Buildpacks
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生Buildpacks
- en: Custom scripts
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义脚本
- en: kaniko
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kaniko
- en: Google Cloud Build
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud Build
- en: In this section, we will cover these in detail by using them with the Spring
    Boot application we just built in the previous section. Let's talk about Dockerfile
    first.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过在上一节中构建的Spring Boot应用程序中详细介绍它们。让我们先谈谈Dockerfile。
- en: Dockerfile
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dockerfile
- en: Docker is the gold standard for creating containers for many years. Even though
    there are many alternatives to Docker today, but it is still alive and kicking.
    Docker architecture depends on a daemon process that must be running to service
    all of your Docker commands. Then there is a Docker CLI that sent the commands
    to the Docker daemon for execution. The daemon process does what is required to
    push, pull, run container images, and so on. Docker expects a file called Dockerfile,
    handwritten by you, containing steps and instructions that it understands. This
    Dockerfile is then used to create a container image of your application with a
    command such as `docker build`. The advantage here is that this allows for a different
    customization level while making a container image of your application, as per
    your needs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Docker多年来一直是创建容器的黄金标准。即使今天有许多Docker的替代品，但它仍然活跃。Docker架构依赖于必须运行以服务所有Docker命令的守护进程。然后有一个Docker
    CLI，它将命令发送到Docker守护进程以执行。守护进程执行所需的操作，如推送、拉取、运行容器镜像等。Docker期望一个名为Dockerfile的文件，由您手动编写，其中包含它理解的步骤和指令。然后使用诸如`docker
    build`之类的命令使用此Dockerfile创建应用程序的容器镜像。这里的优势在于，这允许根据您的需求对应用程序的容器镜像进行不同的定制级别。
- en: To build an image with Docker, we need to add a few instructions to our Dockerfile.
    Those instructions act as input, and then the Docker daemon process creates an
    image with those instructions. Let's look at an example to understand the working
    of a typical Dockerfile for a Java application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Docker构建镜像，我们需要向Dockerfile添加一些指令。这些指令作为输入，然后Docker守护进程使用这些指令创建镜像。让我们看一个示例，以了解典型Dockerfile用于Java应用程序的工作原理。
- en: '![Figure 6.3 – Docker build flow'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – Docker构建流程'
- en: '](image/Figure_6.3_B17385.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.3_B17385.jpg)'
- en: Figure 6.3 – Docker build flow
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – Docker构建流程
- en: 'We will use the following Dockerfile to containerize our application:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下Dockerfile来容器化我们的应用程序：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From the preceding code block, we can see the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码块中，我们可以看到以下内容：
- en: The `FROM` instruction indicates the base image for our application.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM`指令表示我们应用程序的基础镜像。'
- en: The `COPY` instruction, as the name suggests, will copy the local .jar file
    that was built by Maven into our image.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY`指令，顾名思义，将由Maven构建的本地.jar文件复制到我们的镜像中。'
- en: The `ENTRYPOINT` instruction acts as an executable for our container while it's
    starting.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`指令在容器启动时充当可执行文件。'
- en: 'In the `skaffold.yaml` file, we have added a new profile named `docker`. The
    following are the relevant parts of the `docker` profile:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`skaffold.yaml`文件中，我们添加了一个名为`docker`的新配置文件。以下是`docker`配置文件的相关部分：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can run the build with the `skaffold dev –profile=docker` command. The output
    should be similar to what we saw previously in *Figure 6.2*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`skaffold dev –profile=docker`命令运行构建。输出应该与我们之前在*图6.2*中看到的类似。
- en: Jib
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jib
- en: '**Jib** (https://github.com/GoogleContainerTools/jib) stands for **Java Image
    Builder** and is purely written in Java. You already know that Jib allows Java
    developers to build containers using build tools such as Maven and Gradle. However,
    it has a CLI tool that can be used for non-Java applications such as Python on
    Node.js.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jib** (https://github.com/GoogleContainerTools/jib)代表**Java Image Builder**，纯粹由Java编写。您已经知道Jib允许Java开发人员使用诸如Maven和Gradle之类的构建工具构建容器。但是，它还有一个CLI工具，可用于非Java应用程序，如Python或Node.js。'
- en: 'The significant advantage of using Jib is that you don''t need to know anything
    about installing Docker or maintaining a Dockerfile. To containerize your Java
    application, you don''t have to go through countless Docker tutorials. Jib is
    daemonless. Furthermore, as Java developers, we only care about the artifact (that
    is, jar file), and with Jib, we don''t have to deal with any of the Docker commands.
    Using Jib, a Java developer can add the plugin to the build tool of their choice
    (Maven/Gradle), and with minimum configuration, you have your application containerized.
    Jib takes your application source code as input and outputs the container image
    of your application. Following is the build flow of your Java application with
    Jib:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jib的重要优势是您无需了解安装Docker或维护Dockerfile的任何内容。要使您的Java应用程序容器化，您无需阅读无数的Docker教程。Jib是无守护进程的。此外，作为Java开发人员，我们只关心构件（即jar文件），并且使用Jib，我们不必处理任何Docker命令。使用Jib，Java开发人员可以将插件添加到他们选择的构建工具（Maven/Gradle）中，并且只需进行最少的配置，即可使应用程序容器化。Jib将您的应用程序源代码作为输入，并输出您的应用程序的容器镜像。以下是使用Jib构建您的Java应用程序的流程：
- en: '![Figure 6.4 – Jib build flow'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – Jib构建流程'
- en: '](image/Figure_6.4_B17385.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.4_B17385.jpg)'
- en: Figure 6.4 – Jib build flow
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – Jib构建流程
- en: 'Let''s try to build the application we created in the previous section with
    Jib:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用Jib构建上一节中创建的应用程序：
- en: 'First, we will create the `skaffold.yaml` file using the Skaffold `init` command,
    as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用Skaffold的`init`命令创建`skaffold.yaml`文件，如下所示：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Jib cleverly split your application image layers into the following for faster
    rebuilds:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Jib巧妙地将应用程序图像层分成以下几个部分，以加快重建速度：
- en: -Classes
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: -类
- en: -Resources
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: -资源
- en: -Project Dependencies
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: -项目依赖项
- en: -Snapshot and all other dependencies
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: -快照和所有其他依赖项
- en: The goal is to separate files that often change as compared to the ones which
    are rarely changed. The immediate benefit is that you don't have to rebuild the
    entire application because Jib only rebuilds the layer containing the changed
    files and reuse cached layers for files that didn't change.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是将经常更改的文件与很少更改的文件分开。直接的好处是，您不必重建整个应用程序，因为 Jib 只重新构建包含更改文件的层，并重用未更改文件的缓存层。
- en: 'With Jib, you might see the following warning in logs if you don''t specify
    the image digest:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Jib，如果您不指定镜像摘要，您可能会在日志中看到以下警告：
- en: '[WARNING] Base image `''adoptopenjdk/openjdk16''` does not use a specific image
    `digest - build` may not be reproducible.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[警告] 基础镜像 `''adoptopenjdk/openjdk16''` 没有使用特定的镜像摘要 - 构建可能不可重现。'
- en: 'You can overcome this by using the proper image digest. For example, in `maven-jib-plugin`,
    you can make the following changes, while in the `skaffold.yaml` file, you can
    specify the image digest:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用正确的镜像摘要来克服这一点。例如，在 `maven-jib-plugin` 中，您可以进行以下更改，而在 `skaffold.yaml`
    文件中，您可以指定镜像摘要：
- en: '`<plugin>`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`<plugin>`'
- en: '`   <groupId>com.google.cloud.tools</groupId>`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`<groupId>com.google.cloud.tools</groupId>`'
- en: '`   <artifactId>jib-maven-plugin</artifactId>`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`<artifactId>jib-maven-plugin</artifactId>`'
- en: '`   <version>3.1.1</version>`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`<version>3.1.1</version>`'
- en: '`   <configuration>`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`<configuration>`'
- en: '`      <from>`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh:       <from>
- en: '`<image>adoptopenjdk/openjdk16@           sha256:b40f81a9f7e7e4533ed0c` `           6ac794ded9f653807f757e2b8b4e1
               fe729b6065f7f5</image>`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`<image>adoptopenjdk/openjdk16@           sha256:b40f81a9f7e7e4533ed0c` `           6ac794ded9f653807f757e2b8b4e1
               fe729b6065f7f5</image>`'
- en: '`      </from>`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh:       </from>
- en: '`      <to>`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh:       <to>
- en: '`         <image>docker.io/hiashish/image</image>`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`<image>docker.io/hiashish/image</image>`'
- en: '`      </to>`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh:       </to>
- en: '`   </configuration>`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`</configuration>`'
- en: '`</plugin>`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`</plugin>`'
- en: 'Following is the Kubernetes service manifest:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Kubernetes服务清单：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Following is the Kubernetes deployment manifest:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Kubernetes部署清单：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we must run the `skaffold dev` command. The following is the output:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须运行 `skaffold dev` 命令。以下是输出：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With minikube, we can use the `minikube service reactive-web-app` command to
    open the exposed service. We will use the URL mentioned in the following screenshot
    to access our application:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `minikube service reactive-web-app` 命令可以在 minikube 中打开暴露的服务。我们将使用以下截图中提到的
    URL 来访问我们的应用程序：
- en: '![Figure 6.5 – Exposed service URL'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5 - 暴露的服务URL'
- en: '](image/Figure_6.5_B17385.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.5_B17385.jpg)'
- en: Figure 6.5 – Exposed service URL
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 - 暴露的服务URL
- en: After accessing the `http://127.0.0.1:55174/employee` URL, we should get an
    output similar to *Figure 6.2*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 `http://127.0.0.1:55174/employee` URL 后，我们应该得到类似于 *图6.2* 的输出。
- en: Bazel
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bazel
- en: 'Bazel is an open source, multilanguage, fast, and scalable build tool similar
    to Maven and Gradle. Skaffold provides support for Bazel and it can load images
    to the local Docker daemon. Bazel requires two files: `WORKSPACE` and `BUILD`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Bazel 是一个类似于 Maven 和 Gradle 的开源、多语言、快速和可扩展的构建工具。Skaffold 支持 Bazel，并且可以将镜像加载到本地
    Docker 守护程序中。Bazel 需要两个文件：`WORKSPACE` 和 `BUILD`。
- en: The `WORKSPACE` file is typically available at the root directory of your project.
    This file indicates the Bazel workspace. It looks for build inputs and stores
    the build output in the directory where the `WORKSPACE` file was created.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKSPACE` 文件通常位于项目的根目录。此文件指示 Bazel 工作区。它查找构建输入，并将构建输出存储在创建 `WORKSPACE` 文件的目录中。'
- en: 'The `BUILD` file instructs Bazel on what to build and how to build different
    parts of your project. The following is an example of a `BUILD` file for a Java
    application. In this example, we are instructing Bazel to use the `java_binary`
    rule to create a `.jar` file for our application:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`BUILD`文件指示Bazel要构建什么以及如何构建项目的不同部分。以下是一个Java应用程序的`BUILD`文件示例。在这个例子中，我们指示Bazel使用`java_binary`规则为我们的应用程序创建一个`.jar`文件：'
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To build your project, you can run commands such as `build //: ReactiveWebApp`.
    The following is the `skaffold.yaml` file, which contains a `bazel` profile:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '要构建您的项目，您可以运行诸如`build //: ReactiveWebApp`之类的命令。以下是包含`bazel`配置文件的`skaffold.yaml`文件：'
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next we have Buildpacks.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们有Buildpacks。
- en: Buildpacks
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Buildpacks
- en: Heroku first created Buildpacks ([https://buildpacks.io/](https://buildpacks.io/))
    in 2011\. It is now part of the CNCF foundation. Just like Jib, Buildpacks can
    also work without the need for a Dockerfile. However, you will need a Docker daemon
    process up and running for it to work. With Buildpacks, the input is your application
    source code, and the output is the container image. It's pretty similar to Jib
    in this respect, though Jib can work without a Docker daemon.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku在2011年首次创建了Buildpacks（[https://buildpacks.io/](https://buildpacks.io/)）。它现在是CNCF基金会的一部分。就像Jib一样，Buildpacks也可以在不需要Dockerfile的情况下工作。但是，您需要一个正在运行的Docker守护程序进程才能使其工作。使用Buildpacks，输入是您的应用程序源代码，输出是容器镜像。在这方面，它与Jib非常相似，尽管Jib可以在没有Docker守护程序的情况下工作。
- en: 'In the background, Buildpacks does a lot of work, including retrieving dependencies,
    processing assets, handling caching, and compiling code for whatever language
    your app has been built in:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，Buildpacks做了很多工作，包括检索依赖项，处理资产，处理缓存以及为应用程序使用的任何语言编译代码：
- en: '![Figure 6.6 – Buildpacks build flow'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6 - Buildpacks构建流程'
- en: '](image/Figure_6.6_B17385.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.6_B17385.jpg)'
- en: Figure 6.6 – Buildpacks build flow
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 - Buildpacks构建流程
- en: As explained earlier, Skaffold requires a local Docker daemon to build an image
    with Buildpacks. Skaffold will execute the build inside a container using the
    builder specified in the Buildpacks configuration of your `skaffold.yaml` file.
    Also, you don't have to install the pack CLI as the Google Cloud Buildpacks project
    ([https://github.com/GoogleCloudPlatform/buildpacks](https://github.com/GoogleCloudPlatform/buildpacks))
    provides builder images for tools such as Skaffold. You can choose to skip this,
    but upon successfully building it, Skaffold will push the image to the remote
    registry.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所解释的，Skaffold需要一个本地的Docker守护程序来使用Buildpacks构建镜像。Skaffold将在容器内部使用`skaffold.yaml`文件中Buildpacks配置中指定的构建器执行构建。此外，您不必安装pack
    CLI，因为Google Cloud Buildpacks项目（[https://github.com/GoogleCloudPlatform/buildpacks](https://github.com/GoogleCloudPlatform/buildpacks)）提供了用于工具如Skaffold的构建器镜像。您可以选择跳过此步骤，但在成功构建后，Skaffold将把镜像推送到远程注册表。
- en: Tip
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Starting with Spring Boot version 2.3, Spring Boot includes direct Buildpacks
    support for both Maven and Gradle projects. With the `mvn spring-boot:build-image`
    command, you can create an image of your application that''s loaded to your locally
    running Docker daemon. Although you are not required to maintain a Dockerfile,
    Buildpacks depends on the Docker daemon process. If you don''t have the Docker
    daemon running locally, you will get the following error while executing the Maven
    command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从Spring Boot 2.3版本开始，Spring Boot直接支持Maven和Gradle项目的Buildpacks。使用`mvn spring-boot:build-image`命令，您可以创建一个加载到本地运行的Docker守护程序的应用程序镜像。虽然您不需要维护Dockerfile，但Buildpacks依赖于Docker守护程序进程。如果您在本地没有运行Docker守护程序，执行Maven命令时将会收到以下错误：
- en: '`Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:2.4.2:build-image
    (default-cli) on project imagebuilder: Execution default-cli of goal org.springframework.boot:spring-boot-maven-plugin:2.4.2:build-image
    failed: Connection to the Docker daemon at ''localhost'' failed with error "[61]
    Connection refused"; ensure the Docker daemon is running and accessible`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '“无法执行目标org.springframework.boot:spring-boot-maven-plugin:2.4.2:build-image
    (default-cli) on project imagebuilder: Execution default-cli of goal org.springframework.boot:spring-boot-maven-plugin:2.4.2:build-image
    failed: Connection to the Docker daemon at ''localhost'' failed with error "[61]
    Connection refused"; ensure the Docker daemon is running and accessible”'
- en: 'To build our application with Buildpacks, we have added a new profile `name`
    of `pack` and used that to add a new `build` section to the `skaffold.yaml` configuration
    file. In the `builder` field, we are instructing Skaffold to use the `gcr.io/buildpacks/builder:v1`  builder
    image. The following are the relevant parts of the configuration file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Buildpacks构建我们的应用程序，我们添加了一个名为`pack`的新配置文件，并将其用于向`skaffold.yaml`配置文件的`build`部分添加一个新的部分。在`builder`字段中，我们指示Skaffold使用`gcr.io/buildpacks/builder:v1`构建器映像。以下是配置文件的相关部分：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can run the build with the `skaffold dev –profile=pack` command. The output
    should be similar to what we saw in *Figure 6.2*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`skaffold dev –profile=pack`命令运行构建。输出应该类似于我们在*图6.2*中看到的。
- en: Tip
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Spring Boot Buildpacks integration can be used to push an image to a remote
    container registry. We would need to make the following changes in `pom.xml` to
    do this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot Buildpacks集成可用于将映像推送到远程容器注册表。我们需要在`pom.xml`中进行以下更改：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Custom script
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义脚本
- en: You can use the custom script option if none of the supported container image
    builders work for your use case. With this option, you can write custom scripts
    or choose a build tool of your liking. You can configure a custom script by adding
    a custom field to each corresponding artifact in the build section of the `skaffold.yaml`
    file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有支持的容器映像构建器适用于您的用例，您可以使用自定义脚本选项。通过此选项，您可以编写自定义脚本或选择您喜欢的构建工具。您可以通过在`skaffold.yaml`文件的构建部分的每个相应构件中添加一个自定义字段来配置自定义脚本。
- en: 'In the following example `skaffold.yaml` file, we have created a new profile
    named `custom`. In the `buildCommand` field, we have used the `build.sh` script
    to containerize our Spring Boot application:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例`skaffold.yaml`文件中，我们创建了一个名为`custom`的新配置文件。在`buildCommand`字段中，我们使用`build.sh`脚本来将我们的Spring
    Boot应用程序容器化：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `build.sh` script file contains the following content. It uses the `docker
    build` command to create an image of our application. Skaffold will supply `$IMAGE`
    (that is, the fully qualified image name environment variable) to the custom build
    script:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`build.sh`脚本文件包含以下内容。它使用`docker build`命令来创建我们应用程序的映像。Skaffold将提供`$IMAGE`（即完全限定的映像名称环境变量）给自定义构建脚本：'
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next we move to kaniko.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们转向kaniko。
- en: kaniko
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kaniko
- en: '**kaniko** is an open source tool that''s used to build container images from
    a Dockerfile inside a container or Kubernetes cluster. kaniko doesn''t require
    privileged root access to build container images.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: kaniko是一个开源工具，用于在容器或Kubernetes集群内部从Dockerfile构建容器映像。kaniko不需要特权根访问权限来构建容器映像。
- en: kaniko has no dependency on a Docker daemon and executes each command within
    a Dockerfile entirely in the user space. With kaniko, you can start building container
    images in environments that can't securely run a Docker daemon, such as a standard
    Kubernetes cluster. So, how does kaniko work? Well, kaniko uses an executor image
    called `gcr.io/kaniko-project/executor`, and this image runs inside a container.
    It is not recommended to run the kaniko executor binary in another image as it
    might not work.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: kaniko不依赖于Docker守护程序，并在用户空间完全执行Dockerfile中的每个命令。使用kaniko，您可以在无法安全运行Docker守护程序的环境中开始构建容器映像，例如标准Kubernetes集群。那么，kaniko是如何工作的呢？嗯，kaniko使用一个名为`gcr.io/kaniko-project/executor`的执行器映像，该映像在容器内运行。不建议在另一个映像中运行kaniko执行器二进制文件，因为它可能无法正常工作。
- en: 'Let''s see how this is done:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何完成的：
- en: 'We will use the following Dockerfile with kaniko to build the container image
    of our application:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用以下Dockerfile与kaniko构建应用程序的容器映像：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is the relevant part of `skaffold.yaml`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是`skaffold.yaml`的相关部分：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we have added a new profile called `kaniko` to build our container images
    inside the Google Kubernetes cluster. You will learn more about GKE in [*Chapter
    8*](B17385_08_Final_PD_ePub.xhtml#_idTextAnchor099), *Deploying a Spring Boot
    Application to Google Kubernetes Engine Using Skaffold*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个名为`kaniko`的新配置文件，以在Google Kubernetes集群中构建我们的容器映像。您将在[*第8章*](B17385_08_Final_PD_ePub.xhtml#_idTextAnchor099)中了解更多关于GKE的信息，*使用Skaffold将Spring
    Boot应用部署到Google Kubernetes Engine*。
- en: 'An important point to highlight in this `skaffold.yaml` file is that we would
    need a credential from the active Kubernetes cluster to build our image inside
    the cluster. For that, a GCP service account is required. This account has a storage
    admin role so that images can be pulled and pushed. We can use the following command
    to build and deploy our application to GKE:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`skaffold.yaml`文件中需要强调的一个重要点是，我们需要从活动的Kubernetes集群获取凭据，以便在集群内构建我们的映像。为此，需要一个GCP服务帐户。此帐户具有存储管理员角色，以便可以拉取和推送映像。我们可以使用以下命令构建并将应用程序部署到GKE：'
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will be using a remote Kubernetes cluster hosted on GCP for this demo. Let''s
    get started:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在GCP上托管的远程Kubernetes集群上进行演示。让我们开始吧：
- en: 'First, we need to create a service account for kaniko with permissions to pull
    and push images from/to `gcr.io`. Then, we need to download the JSON service account
    file and rename the file `kaniko-secret`. Also, make sure that you do not append
    `.json` to the filename; create a Kubernetes secret using the following command.
    You need to make sure that the Kubernetes context is set to a remote Kubernetes
    cluster:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要为kaniko创建一个服务帐户，该帐户具有从`gcr.io`拉取和推送映像的权限。然后，我们需要下载JSON服务帐户文件并将文件重命名为`kaniko-secret`。还要确保不要在文件名后添加`.json`；使用以下命令创建Kubernetes密钥。您需要确保Kubernetes上下文设置为远程Kubernetes集群：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Since we are going to push the image to **Google Container Registry** (**GCR**),
    we have mentioned the `–default-repo` flag so that it always points to GCR. The
    following are the logs:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将把映像推送到**Google容器注册表**（**GCR**），我们已经提到了`--default-repo`标志，以便它始终指向GCR。以下是日志：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the following logs, you can see that kaniko started building images inside
    the container by downloading base images for different stages of the build. kaniko
    started packaging and downloading the dependencies for our Spring Boot application:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下日志中，您可以看到kaniko开始在容器内构建映像，下载不同构建阶段的基础映像。kaniko开始打包和下载我们的Spring Boot应用程序的依赖项：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the following logs, you can see that the build was successful and that kaniko
    was able to push the image to GCR. Then, we deployed the image to the Google Kubernetes
    cluster using `kubectl`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下日志中，您可以看到构建成功，并且kaniko能够将映像推送到GCR。然后，我们使用`kubectl`将映像部署到Google Kubernetes集群：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the following screenshot, we can see that after the deployment, a pod is
    running and that the service that''s been exposed is of the **Load balancer**
    type:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，我们可以看到部署后，一个pod正在运行，并且暴露的服务是**Load balancer**类型：
- en: '![Figure 6.7 – Pod running and the service exposed for external access'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7 – Pod运行和服务暴露给外部访问'
- en: '](image/Figure_6.7_B17385.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.7_B17385.jpg)'
- en: Figure 6.7 – Pod running and the service exposed for external access
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – Pod运行和服务暴露给外部访问
- en: 'The following is the output after accessing the `/employee` REST endpoint of
    our Spring Boot application using the endpoints exposed by GKE:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 访问我们的Spring Boot应用程序的`/employee` REST端点后，使用GKE公开的端点的输出如下：
- en: '![Figure 6.8 – REST application response'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8 – REST应用程序响应'
- en: '](image/Figure_6.8_B17385.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.8_B17385.jpg)'
- en: Figure 6.8 – REST application response
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – REST应用程序响应
- en: Google Cloud Build
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google Cloud Build
- en: Cloud Build is a service that runs your build using GCP infrastructure. Cloud
    Build works by importing source code from various repositories or Google Cloud
    Storage spaces, executing a build, and producing artifacts such as container images.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Build是一个使用GCP基础设施运行构建的服务。Cloud Build通过从各种存储库或Google Cloud Storage空间导入源代码，执行构建，并生成容器镜像等工件来工作。
- en: 'We created a new profile named `gcb` in `skaffold.yaml` to trigger the remote
    build of our application using Google Cloud Build. The following is the relevant
    part of the `skaffold.yaml` profile section:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`skaffold.yaml`中创建了一个名为`gcb`的新配置文件，以使用Google Cloud Build触发我们应用程序的远程构建。以下是`skaffold.yaml`配置文件部分的相关部分：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can run the following command to start the remote build of our application
    with Google Cloud Build:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行以下命令来开始使用Google Cloud Build远程构建我们的应用程序：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If this is your first time doing this, make sure that you have enabled the
    Cloud Build API, either from the **Cloud Console** dashboard or through the gcloud
    CLI. Otherwise, you may get the following error:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是您第一次这样做，请确保已经从**Cloud Console**仪表板或通过gcloud CLI启用了Cloud Build API。否则，您可能会收到以下错误：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can enable the Cloud Build API via the **Cloud Console** dashboard by visiting
    the URL mentioned in the error logs and clicking on the **ENABLE** button, as
    shown in the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问错误日志中提到的URL并单击**ENABLE**按钮来通过**Cloud Console**仪表板启用Cloud Build API，如下截图所示：
- en: '![Figure 6.9 – Enabling the Cloud Build API'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9 – 启用Cloud Build API'
- en: '](image/Figure_6.9_B17385.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.9_B17385.jpg)'
- en: Figure 6.9 – Enabling the Cloud Build API
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 启用Cloud Build API
- en: 'You need to make sure that, in your `kubeconfig` file, the GKE remote cluster
    is the active cluster for this deployment before running the actual command to
    start the build and deployment process. The following is the output of the `skaffold
    run` command. In the following logs, you can see that our entire source code is
    packaged as a `tar.gz` file and sent to the Google Cloud Storage location. From
    there, Cloud Build picks it and starts building our image:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行实际命令启动构建和部署过程之前，您需要确保在您的`kubeconfig`文件中，GKE远程集群是此部署的活动集群。以下是`skaffold run`命令的输出。在以下日志中，您可以看到我们的整个源代码被打包为`tar.gz`文件并发送到Google
    Cloud Storage位置。然后，Cloud Build会获取它并开始构建我们的镜像：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the following logs, you can see that the image has been built, tagged, and
    pushed to GCR. Then, using `kubectl`, the application is deployed to GKE, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下日志中，您可以看到镜像已经构建、标记并推送到GCR。然后，使用`kubectl`，应用程序被部署到GKE，如下所示：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the **Workload** section of GKE, you can see that **reactive-web-app** has
    been deployed and that its status is OK, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在GKE的**Workload**部分，您可以看到**reactive-web-app**已经部署，并且其状态为OK，如下所示：
- en: '![Figure 6.10 – Application deployed successfully on GKE'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.10 – 应用程序成功部署在GKE上'
- en: '](image/Figure_6.10_B17385.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.10_B17385.jpg)'
- en: Figure 6.10 – Application deployed successfully on GKE
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 - 应用程序成功部署在GKE上
- en: In this section, we learned about the different ways we can containerize our
    Reactive Spring Boot CRUD application.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何以不同的方式将我们的Reactive Spring Boot CRUD应用程序容器化。
- en: In the next section, we will explore different ways to deploy an application
    to Kubernetes with Skaffold.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨使用Skaffold将应用程序部署到Kubernetes的不同方法。
- en: Exploring Skaffold container image deployers
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Skaffold容器镜像部署程序
- en: 'In this section, we will look at the container image deployment methods supported
    by Skaffold. With Skaffold, you can deploy your application to Kubernetes using
    the following three tools:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看Skaffold支持的容器镜像部署方法。使用Skaffold，您可以使用以下三种工具将应用程序部署到Kubernetes：
- en: Helm
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm
- en: kubectl
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl
- en: Kustomize
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kustomize
- en: Let's discuss them in detail.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论一下。
- en: Helm
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm
- en: '**Helm** is the package manager, and **charts** are the packages for your Kubernetes
    applications. It allows you to define, install, and update your Kubernetes application
    easily. You can write charts for your applications or use production-ready, pre-packaged
    charts for popular software such as MySQL and MongoDB from a stable chart repository.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**Helm**是软件包管理器，**charts**是您的Kubernetes应用程序的软件包。它允许您轻松定义、安装和更新您的Kubernetes应用程序。您可以为您的应用程序编写图表，或者从稳定的图表存储库中使用用于流行软件（如MySQL和MongoDB）的生产就绪的预打包图表。'
- en: Until Helm 2, Helm followed a client-server architecture. However, due to significant
    changes being made to the architecture with Helm 3, it is a client-only architecture.
    Therefore, there is no need to have a server-side component such as **Tiller**
    installed on your Kubernetes cluster.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 直到Helm 2，Helm遵循客户端-服务器架构。然而，由于Helm 3对架构进行了重大更改，它是一个仅客户端的架构。因此，在您的Kubernetes集群上不需要安装**Tiller**等服务器端组件。
- en: 'Now, let''s learn more about Helm:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更多地了解Helm：
- en: 'Skaffold will not install Helm for us, so we must install it using the Homebrew
    package manager for macOS:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Skaffold不会为我们安装Helm，因此我们必须使用macOS的Homebrew软件包管理器进行安装：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For Windows, you can download it using chocolatey:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows，您可以使用chocolatey进行下载：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can also download Helm using an installer script, which will download the
    latest version:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用安装程序脚本下载Helm，该脚本将下载最新版本：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we will create a Helm chart skeleton using the following command:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用以下命令创建Helm图表骨架：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We will create a new Skaffold profile called `jibWithHelm` to build an image
    with Jib and then deploy it using Helm:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`jibWithHelm`的新Skaffold配置文件，以使用Jib构建图像，然后使用Helm部署它：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, the image name under the `build` section should match the image name given
    under the `artifactOverrides` section of the `skaffold.yaml` file. Otherwise,
    you will get an error.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`build`部分下的图像名称应与`skaffold.yaml`文件的`artifactOverrides`部分下给定的图像名称匹配。否则，将会出现错误。
- en: We have also provided the path to the `values.yaml` file under the `valuesFiles`
    section of the `skaffold.yaml` file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`skaffold.yaml`文件的`valuesFiles`部分提供了指向`values.yaml`文件的路径。
- en: 'The typical convention for defining image references with Helm is through the
    `values.yaml` file. The following is the content of the `values.yaml` file that
    will be referenced by Helm:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Helm定义图像引用的典型约定是通过`values.yaml`文件。以下是将由Helm引用的`values.yaml`文件的内容：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The values in the `values.yaml` file will be referenced inside a templated
    resource file, as shown in the following code snippet. This templated file is
    located inside `reactive-web-app-helm/templates/**.yaml`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`values.yaml`文件中的值将在模板化资源文件中被引用，如下面的代码片段所示。此模板文件位于`reactive-web-app-helm/templates/**.yaml`中：'
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After running `skaffold run --profile=jibWithHelm`, Skaffold will build the
    image using Jib and deploy it to GKE using Helm charts. This will result in the
    following output:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`skaffold run --profile=jibWithHelm`后，Skaffold将使用Jib构建图像，并使用Helm图表将其部署到GKE。这将导致以下输出：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can verify whether the pods are running by going to the **Workloads** section
    of GKE. In the following screenshot, we can see that we have a pod running:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过转到GKE的**工作负载**部分来验证pod是否正在运行。在下面的截图中，我们可以看到我们有一个正在运行的pod：
- en: '![Figure 6.11 – Helm Charts deployed successfully on GKE'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 - Helm图表在GKE上成功部署
- en: '](image/Figure_6.11_B17385.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.11_B17385.jpg)'
- en: Figure 6.11 – Helm Charts deployed successfully on GKE
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 - Helm图表在GKE上成功部署
- en: 'Similarly, under the **Services & Ingress** section, we can see that an **External
    load balancer** type of service has been exposed for external access:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在**服务和入口**部分下，我们可以看到已经为外部访问暴露了一个**外部负载均衡器**类型的服务：
- en: '![Figure 6.12 – LoadBalancer service type exposed on GKE'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.12 - 在GKE上暴露的LoadBalancer服务类型'
- en: '](image/Figure_6.12_B17385.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_6.12_B17385.jpg)'
- en: Figure 6.12 – LoadBalancer service type exposed on GKE
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 - 在GKE上暴露的LoadBalancer服务类型
- en: After accessing the application using the URL mentioned in the **Endpoints**
    column, the output should be similar to what we saw in *Figure 6.2*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Endpoints**列中使用URL访问应用程序后，输出应该类似于我们在*图6.2*中看到的。
- en: kubectl
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kubectl
- en: kubectl is a command-line tool that's used to run commands on your Kubernetes
    cluster. It interacts with the Kubernetes API Server to run those commands. You
    can use it to accomplish various tasks, such as viewing logs of a pod, create
    Kubernetes
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl是一个命令行工具，用于在Kubernetes集群上运行命令。它与Kubernetes API服务器交互以运行这些命令。您可以使用它来完成各种任务，例如查看pod的日志，创建Kubernetes
- en: 'resources such as deployments, find out about the state of your cluster, and
    pods among others. In the following code snippet, you can see that we are using
    kubectl for deployment purposes. The Kubernetes manifests are under the `k8s`
    directory:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 例如部署资源，了解集群的状态和pod等。在下面的代码片段中，您可以看到我们正在使用kubectl进行部署。Kubernetes清单位于`k8s`目录下：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Kustomize
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kustomize
- en: Kustomize, as its name suggests, is a template-free declarative approach to
    Kubernetes configuration, management, and customization options. With Kustomize,
    we provide a base skeleton and patches. In this approach, compared to Helm, we
    provide a base deployment and then describe the differences for different environments.
    For example, we can have different numbers of replicas and health checks for production
    as compared to staging. Kustomize can installed separately and since version 1.14
    of kubectl, we can use the `-k` command. Follow the instructions mentioned at
    [https://kubectl.docs.kubernetes.io/installation/kustomize/](https://kubectl.docs.kubernetes.io/installation/kustomize/)
    to install it on your supported OS.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize，顾名思义，是一种无模板的声明性方法，用于Kubernetes配置、管理和自定义选项。使用Kustomize，我们提供一个基本的框架和补丁。在这种方法中，与Helm相比，我们提供一个基本的部署，然后描述不同环境的差异。例如，我们可以在生产环境和暂存环境中有不同数量的副本和健康检查。Kustomize可以单独安装，自kubectl的1.14版本以来，我们可以使用`-k`命令。请按照[https://kubectl.docs.kubernetes.io/installation/kustomize/](https://kubectl.docs.kubernetes.io/installation/kustomize/)中提到的说明在支持的操作系统上安装它。
- en: 'In the following example, we have a profile called `kustomizeProd` and are
    using Kustomize as the deployment strategy for our application:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们有一个名为`kustomizeProd`的配置文件，并且正在使用Kustomize作为我们应用的部署策略：
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We must have the following directory structure for Kustomize to work properly.
    In the following directory, you can see that under the `kustomization/base` directory,
    we have our original YAML files describing the resources we want to deploy in
    the GKE cluster. We will never touch these files; instead, we will just apply
    customization above them to create new resources definitions:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Kustomize正常工作，我们必须具有以下目录结构。在下面的目录中，您可以看到在`kustomization/base`目录下，我们有描述我们想要在GKE集群中部署的资源的原始YAML文件。我们永远不会触及这些文件；相反，我们只会在它们之上应用定制来创建新的资源定义：
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We have a file named `kustomization.yaml` inside this `base` folder. It describes
    the resources you use. The resources are the paths to the Kubernetes manifests
    files relative to the current file:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`base`文件夹中有一个名为`kustomization.yaml`的文件。它描述了您使用的资源。这些资源是相对于当前文件的Kubernetes清单文件的路径：
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we have the `kustomization/overlays/prod` folder, which has a `kustomization.yaml`
    file inside it. It contains the following content:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`kustomization/overlays/prod`文件夹，其中包含一个`kustomization.yaml`文件。它包含以下内容：
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you can see, in `base`, we didn't define any environment variables, a replicas
    count, or resource constraints. But for production scenarios, we must add those
    things above our base. To do so, we just have to create the chunk of YAML we would
    like to apply above our base and reference it inside the `kustomization.yaml`
    file. We have already added this YAML to the list of `patchesStrategicMerge` in
    the `kustomization.yaml` file.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您能看到，在`base`中，我们没有定义任何环境变量、副本数或资源约束。但是对于生产场景，我们必须在我们的基础之上添加这些内容。为此，我们只需创建我们想要应用在我们的基础之上的YAML块，并在`kustomization.yaml`文件中引用它。我们已经将这个YAML添加到`kustomization.yaml`文件中的`patchesStrategicMerge`列表中。
- en: 'The `increase_replica.yaml` file contains two replicas and looks like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`increase_replica.yaml`文件包含两个副本，内容如下：'
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `resources_constraint.yaml` file contains the resource request and limit
    and looks like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources_constraint.yaml`文件包含资源请求和限制，内容如下：'
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, we can run the `skaffold run --profile=kustomizeProd --default-repo=gcr.io/basic-curve-316617`
    command. This will deploy the application to GKE using Kustomize. The output we
    get should be similar to what we saw previously in *Figure 6.2*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行`skaffold run --profile=kustomizeProd --default-repo=gcr.io/basic-curve-316617`命令。这将使用Kustomize将应用程序部署到GKE。我们得到的输出应该与我们之前在*图6.2*中看到的类似。
- en: In this section, we looked at the tools we can use with Skaffold to deploy applications
    to a Kubernetes cluster.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看了一下我们可以使用Skaffold来将应用程序部署到Kubernetes集群的工具。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started by introducing ourselves to reactive programming
    and built a Spring Boot CRUD application. We were also introduced to Skaffold's
    supported container image builders, including Docker, kaniko, Jib, and Buildpacks.
    We covered them by looking at their practical implementations. We also discussed
    the different ways we can deploy images to a Kubernetes cluster using tools such
    as kubectl, Helm, and Kustomize.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了响应式编程，并构建了一个Spring Boot CRUD应用程序。我们还介绍了Skaffold支持的容器镜像构建工具，包括Docker、kaniko、Jib和Buildpacks。我们通过实际实现来了解了它们。我们还讨论了使用诸如kubectl、Helm和Kustomize等工具将镜像部署到Kubernetes集群的不同方式。
- en: In this chapter, we gained a solid understanding of tools such as Jib, kaniko,
    Helm, and Kustomize, to name a few. You can apply your knowledge of these tools
    to build and deploy your containers.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对诸如Jib、kaniko、Helm和Kustomize等工具有了扎实的了解。您可以运用这些工具的知识来构建和部署您的容器。
- en: In the next chapter, we will build and deploy a Spring Boot application to Kubernetes
    using Google's Cloud Code extension.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用Google的Cloud Code扩展构建和部署一个Spring Boot应用程序到Kubernetes。
- en: Further reading
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about Skaffold, take a look at the Skaffold documentation: [https://skaffold.dev/docs/](https://skaffold.dev/docs/).'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Skaffold的信息，请查看Skaffold文档：[https://skaffold.dev/docs/](https://skaffold.dev/docs/)。
