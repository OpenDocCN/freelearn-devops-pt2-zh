- en: '[*Chapter 9*](B17385_09_Final_PD_ePub.xhtml#_idTextAnchor116): Creating a Production-Ready
    CI/CD Pipeline with Skaffold'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第9章*](B17385_09_Final_PD_ePub.xhtml#_idTextAnchor116)：使用Skaffold创建一个生产就绪的CI/CD流水线'
- en: In the previous chapter, we learned how to deploy a Spring Boot application
    to Google Cloud Platform using Skaffold. In this chapter, the focus will be on
    introducing you to GitHub Actions and their related concepts. We will also demonstrate
    how we can create a production-ready **continuous integration (CI)** and **continuous
    deployment (CD)** pipeline of a Spring Boot application using Skaffold and GitHub
    Actions. In the last section, we will get familiarized with GitOps concepts and
    learn about creating a continuous delivery pipeline for Kubernetes applications
    using Argo CD and Skaffold.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用Skaffold将Spring Boot应用部署到Google Cloud Platform。在本章中，重点将介绍GitHub
    Actions及其相关概念。我们还将演示如何使用Skaffold和GitHub Actions创建一个生产就绪的Spring Boot应用的**持续集成（CI）**和**持续部署（CD）**流水线。在最后一节中，我们将熟悉GitOps概念，并学习如何使用Argo
    CD和Skaffold为Kubernetes应用创建持续交付流水线。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Getting started with GitHub Actions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GitHub Actions入门
- en: Creating a GitHub Action workflow
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建GitHub Actions工作流
- en: Creating a CI/CD pipeline with GitHub Actions and Skaffold
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GitHub Actions和Skaffold创建CI/CD流水线
- en: Implementing a GitOps workflow with Argo CD and Skaffold
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Argo CD和Skaffold实现GitOps工作流
- en: By the end of this chapter, you will have a solid understanding of how you can
    create an effective CI/CD pipeline using GitHub Actions and Skaffold.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，您将对如何使用GitHub Actions和Skaffold创建有效的CI/CD流水线有扎实的理解。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Eclipse ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/))
    or IntelliJ IDE ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/))
    或 IntelliJ IDE ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
- en: GitHub account
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub账户
- en: Spring Boot 2.5
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 2.5
- en: OpenJDK 16
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenJDK 16
- en: The code from the GitHub repository can be found at [https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-using-Skaffold/tree/main/Chapter07](https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-using-Skaffold/tree/main/Chapter07).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub存储库中的代码可以在[https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-using-Skaffold/tree/main/Chapter07](https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-using-Skaffold/tree/main/Chapter07)找到。
- en: Getting started with GitHub Actions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GitHub Actions入门
- en: GitHub Actions allows you to build, test, and deploy your workloads from your
    GitHub repository GitHub Actions is event-driven; for example, when someone creates
    a pull request, opens an issue, does a deployment, and so on. The specific actions
    are triggered based upon the events. You can even create your own GitHub Actions
    to customize the workflow based upon your use case. There is a great marketplace
    available too, at https://github.com/marketplace, from where you can integrate
    existing GitHub Actions into your workflow.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions允许您从GitHub存储库构建、测试和部署工作负载。GitHub Actions是事件驱动的；例如，当有人创建拉取请求、打开问题、进行部署等时。具体的操作是基于事件触发的。您甚至可以创建自己的GitHub
    Actions来根据您的用例定制工作流。还有一个很棒的市场可用，网址为https://github.com/marketplace，您可以从中将现有的GitHub
    Actions集成到您的工作流中。
- en: 'GitHub Actions uses a YAML syntax file to define events, jobs, actions, and
    commands. In the following diagram, you can see a complete list of GitHub Actions
    components:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions使用YAML语法文件来定义事件、作业、操作和命令。在下图中，您可以看到GitHub Actions组件的完整列表：
- en: '![Figure 9.1 – GitHub Actions components'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – GitHub Actions组件'
- en: '](image/Figure_9.1_B17385.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.1_B17385.jpg)'
- en: Figure 9.1 – GitHub Actions components
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – GitHub Actions组件
- en: 'Let''s discuss the GitHub components in detail:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论GitHub组件：
- en: '**Workflow**: This is used to build, test, package, release, or deploy the
    project on GitHub. A workflow consists of jobs and is triggered by events. The
    workflow is defined in a YAML syntax file available in your GitHub repository
    inside the `.github/workflows` directory.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作流**：这用于在GitHub上构建、测试、打包、发布或部署项目。工作流由作业组成，并由事件触发。工作流在您的GitHub存储库中的`.github/workflows`目录中以YAML语法文件定义。'
- en: '**Events**: This represents an activity that triggers a workflow; for example,
    pushing changes to a branch or creating a pull request.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：这代表触发工作流的活动；例如，将更改推送到分支或创建拉取请求。'
- en: '**Jobs**: This consists of steps that are executed on a runner. It uses steps
    to control the order in which actions are performed. You can run multiple jobs
    for your workflow. They can be run in parallel or sequentially.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作业**：这由在runner上执行的步骤组成。它使用步骤来控制操作执行的顺序。您可以为工作流运行多个作业。它们可以并行或顺序运行。'
- en: '**Steps**: These represent an action, that is, checking out source code or
    shell command.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤**：这些代表一个动作，即检出源代码或shell命令。'
- en: '**Actions**: These represent commands that you would like to run, such as checking
    out your source code or downloading JDK.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作**：这些代表您想要运行的命令，比如检出您的源代码或下载JDK。'
- en: '**Runners**: This is a server hosted on GitHub that has the runner application
    installed. You can host your own runner or use the one provided by GitHub. Your
    jobs defined in the workflow are executed on the runner machine. It sends the
    results, progress, and logs back to the GitHub repository. GitHub-hosted runners
    support Ubuntu Linux, Microsoft Windows, and macOS.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跑步者**：这是一个托管在GitHub上的服务器，安装了runner应用程序。您可以托管自己的runner，也可以使用GitHub提供的runner。在工作流中定义的作业在runner机器上执行。它将结果、进度和日志发送回GitHub存储库。GitHub托管的runner支持Ubuntu
    Linux、Microsoft Windows和macOS。'
- en: Now we have learned details about GitHub Action components. In the next section,
    we will create a GitHub Action workflow for a Spring Boot application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了GitHub Action组件的详细信息。在下一节中，我们将为Spring Boot应用程序创建一个GitHub Action工作流。
- en: Creating a GitHub Actions workflow
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建GitHub Actions工作流
- en: 'In this section, we will create a workflow that will build a Spring Boot Java
    application with GitHub Actions. This workflow will build a Spring Boot application
    using the `mvn clean install` Maven build tool command. The following is an example
    of a workflow file of building a Java project with Maven:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个使用GitHub Actions构建Spring Boot Java应用程序的工作流。这个工作流将使用`mvn clean install`
    Maven构建工具命令来构建一个Spring Boot应用程序。以下是使用Maven构建Java项目的工作流文件示例：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the explanation of the workflow YAML file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是工作流YAML文件的解释：
- en: In the workflow YAML file, we have subscribed to a `push` and `pull` request
    event. So whenever a `pull` request is raised or change is pushed for the main
    branch, this workflow will trigger.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工作流YAML文件中，我们已经订阅了`push`和`pull`请求事件。因此，每当为主分支提出`pull`请求或推送更改时，此工作流将触发。
- en: Then inside the `jobs` section, first we have specified that the job will run
    on a `ubuntu` Linux operating system runner hosted by GitHub.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在`jobs`部分，我们首先指定该作业将在GitHub托管的`ubuntu` Linux操作系统runner上运行。
- en: In `steps`, we have defined the actions that need to be executed for this workflow.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`steps`中，我们已经定义了需要执行此工作流的操作。
- en: First, we are checking out the source code on the runner using `actions/checkout@v2`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`actions/checkout@v2`在runner上检出源代码。
- en: Then we are installing dependencies such as Java. We doing that using the `AdoptOpenJDK/install-jdk@v1`
    action.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们安装诸如Java之类的依赖项。我们使用`AdoptOpenJDK/install-jdk@v1`操作来做到这一点。
- en: In the last and final step, we are building a Java project using the `mvn clean
    install` command.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一步中，我们正在使用`mvn clean install`命令构建一个Java项目。
- en: Let's see this workflow in action. So next, we will create this workflow in
    our GitHub repository and trigger the workflow by pushing changes to the main
    branch.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个工作流是如何运作的。接下来，我们将在我们的GitHub存储库中创建这个工作流，并通过将更改推送到主分支来触发工作流。
- en: 'We will be using the Spring Boot application we created in [*Chapter 7*](B17385_07_Final_PD_ePub.xhtml#_idTextAnchor092),
    *Building and Deploying a Spring Boot Application with the Cloud Code Plugin*,
    for this demonstration. I have already explained the application in detail so
    I will not be explaining it again here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在[*第7章*](B17385_07_Final_PD_ePub.xhtml#_idTextAnchor092)中创建的Spring Boot应用程序，*使用Cloud
    Code插件构建和部署Spring Boot应用程序*，进行演示。我已经详细解释了应用程序，所以在这里不会再次解释：
- en: The first step is to create the workflow YAML file inside your GitHub repository.
    This can be done by navigating to the **Actions** tab in your GitHub repository
    and clicking on the **set up a workflow yourself** link as shown in the following
    screenshot:![Figure 9.2 – Getting started with GitHub Actions
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是在您的GitHub存储库中创建工作流YAML文件。这可以通过导航到GitHub存储库的**Actions**选项卡，并点击**自己设置工作流**链接来完成，如下截图所示：![图9.2
    – 使用GitHub Actions入门
- en: '](image/Figure_9.2_B17385.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.2_B17385.jpg)'
- en: Figure 9.2 – Getting started with GitHub Actions
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 使用GitHub Actions入门
- en: 'In the next screen, paste the content of the workflow YAML file that we discussed
    earlier. Refer to the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，粘贴我们之前讨论过的工作流YAML文件的内容。请参考以下截图：
- en: '![Figure 9.3 – Creating a workflow'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 – 创建工作流'
- en: '](image/Figure_9.3_B17385.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.3_B17385.jpg)'
- en: Figure 9.3 – Creating a workflow
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 创建工作流
- en: After you click on the **Start commit** button, a new commit message window
    will open where you can enter the commit message.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**开始提交**按钮后，将打开一个新的提交消息窗口，您可以在其中输入提交消息。
- en: Then click on **Commit new file** to add the workflow file to the GitHub repository:![Figure
    9.4 – Committing the workflow file
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击**提交新文件**将工作流文件添加到GitHub存储库中：![图9.4 – 提交工作流文件
- en: '](image/Figure_9.4_B17385.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.4_B17385.jpg)'
- en: Figure 9.4 – Committing the workflow file
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 提交工作流文件
- en: 'Inside the repository, now you can see that there is a `.github/workflows`
    directory and inside that directory, we have the `main.yml` workflow file:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在存储库中，现在您可以看到有一个`.github/workflows`目录，在该目录中，我们有`main.yml`工作流文件：
- en: '![Figure 9.5 – GitHub workflow file added to your repository'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5 – 将GitHub工作流文件添加到您的存储库'
- en: '](image/Figure_9.5_B17385.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.5_B17385.jpg)'
- en: Figure 9.5 – GitHub workflow file added to your repository
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 将GitHub工作流文件添加到您的存储库
- en: 'This also creates a commit and pushes a change to the repository, which triggers
    the workflow. In the following screenshot, you can see the workflow is triggered
    and in progress:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会创建一个提交并将更改推送到存储库，从而触发工作流。在下面的截图中，您可以看到工作流已触发并正在进行中：
- en: '![Figure 9.6 – Executing the GitHub workflow'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 – 执行GitHub工作流'
- en: '](image/Figure_9.6_B17385.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.6_B17385.jpg)'
- en: Figure 9.6 – Executing the GitHub workflow
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 执行GitHub工作流
- en: 'In the following screenshot, you can see the pipeline is green and the triggered
    workflow has completed successfully:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，您可以看到流水线是绿色的，触发的工作流已成功完成：
- en: '![Figure 9.7 – GitHub workflow completed successfully'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 – GitHub工作流成功完成'
- en: '](image/Figure_9.7_B17385.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.7_B17385.jpg)'
- en: Figure 9.7 – GitHub workflow completed successfully
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – GitHub工作流成功完成
- en: We have successfully built a Spring Boot application using GitHub Actions. The
    next section will use Skaffold and GitHub Actions to create a CI/CD pipeline for
    a Spring Boot application from the GitHub repository.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功使用GitHub Actions构建了一个Spring Boot应用程序。下一部分将使用Skaffold和GitHub Actions为GitHub仓库中的Spring
    Boot应用程序创建一个CI/CD流水线。
- en: Creating a CI/CD pipeline with GitHub Actions and Skaffold
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GitHub Actions和Skaffold创建CI/CD流水线
- en: CI and CD are among the main pillars of the DevOps life cycle. As the name suggests,
    **continuous integration** (**CI**) is a software development practice where developers
    commit the code to a version control system several times a day. In **continuous
    deployment** (**CD**), software functionalities are delivered frequently through
    automated deployments, and there is no manual intervention or approval in this
    process. Only a failed test would halt your deployment to production. Another
    thing that is often confused with continuous deployment is continuous delivery,
    but they are different in reality. In continuous delivery, the main focus is on
    release and the release strategy and doing the actual deployment to production
    with approval. It is often termed **single-click deployment**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: CI和CD是DevOps生命周期的主要支柱之一。顾名思义，**持续集成**（**CI**）是一种软件开发实践，开发人员每天多次将代码提交到版本控制系统。在**持续部署**（**CD**）中，软件功能通过自动部署频繁交付，这个过程中没有手动干预或批准。只有测试失败才会阻止部署到生产环境。经常与持续部署混淆的是持续交付，但它们在现实中是不同的。在持续交付中，主要关注的是发布和发布策略，并通过批准实际部署到生产环境。它经常被称为**单击部署**。
- en: By now, you will have developed some understanding of how GitHub Actions is
    event-driven and can automate your software development tasks. You will have also
    learned that you can trigger your entire CI/CD pipeline from your GitHub repository
    using GitHub Actions based upon certain events such as Git push or creating a
    pull request on a particular branch.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您将对GitHub Actions如何基于事件驱动并可以自动化软件开发任务有一定的了解。您还将了解到您可以根据GitHub仓库中的某些事件（如Git推送或在特定分支上创建拉取请求）触发整个CI/CD流水线。
- en: This section will focus on deploying a Spring Boot application to Google Kubernetes
    Engine using Skaffold and GitHub Actions. The workflow will closely mimic how
    we typically do the deployment in production using a CI/CD pipeline.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将重点介绍使用Skaffold和GitHub Actions将Spring Boot应用程序部署到Google Kubernetes引擎。工作流程将紧密模仿我们通常如何使用CI/CD流水线在生产环境中进行部署。
- en: Before we proceed further with this task, there are a few prerequisites that
    we should be aware of. The following are some of the highlighted prerequisites.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行此任务之前，我们应该了解一些先决条件。以下是一些重点先决条件。
- en: Prerequisites
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'Please take a note of the following prerequisites:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下先决条件：
- en: You need to create a new Google Cloud Project (or select an existing project).
    This part is already done in [*Chapter 8*](B17385_08_Final_PD_ePub.xhtml#_idTextAnchor099),
    *Deploying a Spring Boot Microservice to Google Cloud Platform Using Skaffold*,
    and we will use the same project.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要创建一个新的Google Cloud项目（或选择现有项目）。这部分在[*第8章*](B17385_08_Final_PD_ePub.xhtml#_idTextAnchor099)中已经完成，*使用Skaffold将Spring
    Boot微服务部署到Google Cloud平台*，我们将使用相同的项目。
- en: Please make sure that you enable the **Container Registry** and **Kubernetes
    Engine** APIs.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请确保您启用了**容器注册表**和**Kubernetes引擎**API。
- en: You also have to create a new **Google Kubernetes Engine** (**GKE**) cluster
    or select an existing GKE cluster.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还需要创建一个新的**Google Kubernetes引擎**（**GKE**）集群或选择现有的GKE集群。
- en: If not done already, you also need to create a JSON service account key for
    the service account and add Kubernetes Engine Developer and Storage Admin roles.
    Service account keys are a safe way of accessing your cloud resources from outside.
    To establish the identity of a service account, a public/private key pair is used.
    The public key is stored in Google Cloud and the private key is available to you.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果尚未完成，您还需要为服务帐户创建JSON服务帐户密钥，并添加Kubernetes引擎开发人员和存储管理员角色。服务帐户密钥是从外部访问您的云资源的安全方式。为了建立服务帐户的身份，使用公钥/私钥对。公钥存储在Google
    Cloud中，私钥可供您使用。
- en: 'To create a service account key, click on **IAM & Admin** on the left-hand
    side navigation bar on the Google Cloud Console. Click on **Service accounts**
    and then you will see the following screen:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建服务帐户密钥，请在Google Cloud控制台的左侧导航栏上单击**IAM和管理**。单击**服务帐户**，然后您将看到以下屏幕：
- en: '![Figure 9.8  – Service account of your GCP project'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 - 您的GCP项目的服务帐户'
- en: '](image/Figure_9.8_B17385.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.8_B17385.jpg)'
- en: Figure 9.8  – Service account of your GCP project
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 - 您的GCP项目的服务帐户
- en: 'Now click the email address of the service account and select **Keys** from
    the right-hand side tab. Click on **ADD KEY** and select **Create new key,** as
    shown in the following screenshot:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在单击服务帐户的电子邮件地址，并从右侧选项卡中选择**密钥**。单击**添加密钥**，然后选择**创建新密钥**，如下面的屏幕截图所示：
- en: '![Figure 9.9 – Adding a key to your service account'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9 - 为您的服务帐户添加密钥'
- en: '](image/Figure_9.9_B17385.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.9_B17385.jpg)'
- en: Figure 9.9 – Adding a key to your service account
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 - 为您的服务帐户添加密钥
- en: 'Choose **JSON** for **Key type** and click on **CREATE**. It will download
    the keys to your system, as shown here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**JSON**作为**密钥类型**，然后单击**创建**。它将下载密钥到您的系统，如下所示：
- en: '![Figure 9.10 – Selecting the key type for your service account'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 - 为您的服务帐户选择密钥类型
- en: '](image/Figure_9.10_B17385.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.10_B17385.jpg)'
- en: Figure 9.10 – Selecting the key type for your service account
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 - 为您的服务帐户选择密钥类型
- en: 'You need to add the following Cloud IAM roles to your service account:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要向您的服务帐户添加以下Cloud IAM角色：
- en: 'a. **Kubernetes Engine Developer**: This role will allow you to deploy to GKE.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: a. **Kubernetes引擎开发人员**：此角色将允许您部署到GKE。
- en: 'b. **Storage Admin**: This role will allow you to publish the container image
    to the Google Container registry:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: b. **存储管理员**：此角色将允许您将容器映像发布到Google容器注册表：
- en: '![Figure 9.11 – Adding roles for your service account'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 - 为您的服务帐户添加角色
- en: '](image/Figure_9.11_B17385.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.11_B17385.jpg)'
- en: Figure 9.11 – Adding roles for your service account
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 - 为您的服务帐户添加角色
- en: 'Add the following secrets to your GitHub repository''s secrets. You can add
    GitHub repository secrets by navigating to the **Settings** tab and then clicking
    on **Secrets** on the left-hand side navigation bar. There, click on **New repository
    secret** and add the following secrets:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将以下机密添加到您的GitHub存储库的机密中。您可以通过导航到**设置**选项卡，然后单击左侧导航栏上的**机密**来添加GitHub存储库机密。在那里，单击**新存储库机密**，然后添加以下机密：
- en: 'a. **PROJECT_ID**: The Google Cloud project ID'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: a. **PROJECT_ID**：Google Cloud项目ID
- en: 'b. **SERVICE_ACCOUNT_KEY**: The content of the service account JSON file'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: b. **SERVICE_ACCOUNT_KEY**：服务帐户JSON文件的内容
- en: 'Refer to the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下屏幕截图：
- en: '![Figure 9.12 – Adding secrets to your GitHub repository'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 - 为您的GitHub存储库添加密钥
- en: '](image/Figure_9.12_B17385.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.12_B17385.jpg)'
- en: Figure 9.12 – Adding secrets to your GitHub repository
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 - 为您的GitHub存储库添加密钥
- en: With this, we have completed all the prerequisites. In the next section, we
    will create a CI/CD pipeline using GitHub Actions and Skaffold.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经完成了所有的先决条件。在下一节中，我们将使用GitHub Actions和Skaffold创建CI/CD流水线。
- en: Implementing CI/CD workflow with GitHub Actions and Skaffold
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用GitHub Actions和Skaffold实现CI/CD工作流程
- en: In this section, we will create a production-ready CI/CD pipeline using Skaffold
    and GitHub Actions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Skaffold和GitHub Actions创建一个生产就绪的CI/CD流水线。
- en: 'The following figure demonstrates the CI/CD workflow with Skaffold and GitHub
    Actions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示演示了使用Skaffold和GitHub Actions的CI/CD工作流程：
- en: '![Figure 9.13 – CI/CD workflow with Skaffold'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.13 – 使用Skaffold的CI/CD工作流程'
- en: '](image/Figure_9.13_B17385.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.13_B17385.jpg)'
- en: Figure 9.13 – CI/CD workflow with Skaffold
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – 使用Skaffold的CI/CD工作流程
- en: 'We will use the following workflow YAML file. Here, I have explained the workflow
    YAML file with comments in each step:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下工作流程YAML文件。在这里，我已经在每个步骤的注释中解释了工作流程YAML文件：
- en: 'Specify the name and event of the workflow:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定工作流程的名称和事件：
- en: '[PRE1]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then we pass GitHub secrets as environment variable:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将GitHub的秘密作为环境变量传递：
- en: '[PRE2]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we define the job that runs on an Ubuntu Linux runner hosted by GitHub:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义在GitHub托管的Ubuntu Linux运行器上运行的作业：
- en: '[PRE3]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While defining steps, the first step is to check out source code and then install
    Java 16:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义步骤时，第一步是检出源代码，然后安装Java 16：
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then we set up the `gcloud` CLI:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们设置`gcloud` CLI：
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, download `kubectl` for post-deployment verification and `skaffold` for
    continuous delivery:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，下载`kubectl`进行部署后验证和`skaffold`进行持续交付：
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, cache artifacts such as dependencies to improve workflow execution time:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，缓存诸如依赖项之类的工件，以提高工作流程执行时间：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Configure docker to use the gcloud command-line tool as a credential helper
    for authentication:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置docker以使用gcloud命令行工具作为身份验证的凭据助手：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Get the GKE credentials and deploy to the cluster using the `skaffold run`
    command, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 获取GKE凭据并使用`skaffold run`命令部署到集群，如下所示：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, build and deploy to GKE using `skaffold run` and do verification with
    `kubectl get all` post deployment:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`skaffold run`构建和部署到GKE，并在部署后使用`kubectl get all`进行验证：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can use this workflow YAML file in your project and replace the secrets
    with your values. If you have placed the `skaffold.yaml` file in the root directory
    of your repository then it's OK, otherwise you can pass the `–filename` flag with
    the `skaffold run` command to point to the Skaffold configuration file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在项目中使用此工作流程YAML文件，并用您的值替换秘密。如果您已将`skaffold.yaml`文件放在存储库的根目录中，那就没问题，否则您可以在`skaffold
    run`命令中传递`--filename`标志，指向Skaffold配置文件。
- en: 'If the workflow is executed successfully then you should see the following
    output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果工作流程成功执行，则应该看到以下输出：
- en: '![Figure 9.14 –  Successful build and deployment to GKE with Skaffold'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14 – 使用Skaffold成功构建和部署到GKE'
- en: '](image/Figure_9.14_B17385.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.14_B17385.jpg)'
- en: Figure 9.14 –  Successful build and deployment to GKE with Skaffold
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 使用Skaffold成功构建和部署到GKE
- en: In this section, we have successfully built and deployed a Spring Boot application
    to a remote cluster with a customized CI/CD pipeline from the GitHub repository
    using Skaffold and GitHub Actions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经成功地使用Skaffold和GitHub Actions从GitHub存储库构建和部署了一个Spring Boot应用程序到远程集群，使用了定制的CI/CD流水线。
- en: Next, let's see how we implement the workflow with Argo CD and Skaffold while
    understanding what they are.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看在理解它们是什么的同时，如何使用Argo CD和Skaffold实现工作流程。
- en: Implementing a GitOps workflow with Argo CD and Skaffold
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Argo CD和Skaffold实现GitOps工作流程
- en: In [*Chapter 4*](B17385_04_Final_PD_ePub.xhtml#_idTextAnchor044), *Understanding
    Skaffold's Features and Architecture*, while explaining Skaffold features, we
    briefly talked about how we can use the `skaffold render` and `skaffold apply`
    commands to create a GitOps style continuous delivery workflow with Skaffold.
    In this section, we will implement a GitOps workflow using Skaffold and Argo CD.
    But first, let's understand what GitOps is and its benefit.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B17385_04_Final_PD_ePub.xhtml#_idTextAnchor044)中，*了解Skaffold的功能和架构*，在解释Skaffold功能时，我们简要讨论了如何使用`skaffold
    render`和`skaffold apply`命令使用Skaffold创建GitOps风格的持续交付工作流程。在本节中，我们将使用Skaffold和Argo
    CD实现GitOps工作流程。但首先，让我们了解GitOps及其好处。
- en: What is GitOps, and what are its benefits?
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是GitOps，以及它的好处是什么？
- en: The word *GitOps* was coined by a company named Weaveworks. The idea behind
    GitOps is to consider Git as a single source of truth for your application and
    declarative infrastructure. Using Git to manage your declarative infrastructure
    makes it easy for developers because they interact with Git daily. Once you add
    configuration inside Git, you get the benefits of version control, such as reviewing
    changes using pull requests, audit, and compliance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*GitOps*一词是由一家名为Weaveworks的公司创造的。GitOps背后的理念是将Git视为应用程序和声明性基础设施的单一真相来源。使用Git管理声明性基础设施使开发人员更容易，因为他们每天都与Git进行交互。一旦您在Git中添加配置，您就会获得版本控制的好处，例如使用拉取请求审查更改，审计和合规性。'
- en: With GitOps, we create automated pipelines to roll out changes to your infrastructure
    when someone pushes changes to a Git repository. Then we use GitOps tools to compare
    the actual production state of your application with what you have defined under
    source control. Then it also tells you when your cluster doesn't match what you
    have in production and automatically or manually reconciles it with the desired
    state. This is true CD.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过GitOps，我们创建自动化流水线，以在有人向Git存储库推送更改时向您的基础设施推出更改。然后，我们使用GitOps工具将您的应用程序的实际生产状态与您在源代码控制下定义的状态进行比较。然后，当您的集群与您在生产环境中拥有的不匹配时，它还会告诉您，并自动或手动将其与期望状态进行协调。这就是真正的持续交付。
- en: You can easily roll back your changes from Kubernetes by doing a simple `git`
    `revert`. In disaster scenarios or if someone accidentally nuked your entire Kubernetes
    cluster, we could quickly reproduce your whole cluster infrastructure from Git.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过简单的`git` `revert`从Kubernetes中回滚更改。在灾难情景中，或者如果有人意外地摧毁了整个Kubernetes集群，我们可以快速地从Git中重新生成整个集群基础设施。
- en: 'Now, let''s understand a few benefits of GitOps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解一下GitOps的一些好处：
- en: Using GitOps, the team is shipping 30-100 changes per day to production. Of
    course, you need to use deployment strategies such as blue-green and canary to
    validate your changes before making them available to all the users. The overall
    benefit is an increase in developer productivity.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GitOps，团队每天向生产环境发布30-100个更改。当然，您需要使用部署策略，如蓝绿部署和金丝雀发布，在向所有用户提供更改之前验证您的更改。总体好处是增加开发人员的生产力。
- en: You get a better developer experience with GitOps as developers are pushing
    code and not containers. Moreover, they use familiar tools such as Git and don't
    need to know about the internals of Kubernetes (that is, `kubectl` commands).
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过GitOps，开发人员推送代码而不是容器，从而获得更好的开发人员体验。此外，他们使用熟悉的工具，如Git，并且不需要了解Kubernetes的内部（即`kubectl`命令）。
- en: By putting declarative infrastructure as code in the Git repository, you automatically
    get benefits such as audit trail for your cluster, such as who did what and when.
    It further ensures the compliance and stability of your Kubernetes cluster.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将声明性基础设施作为代码放入Git存储库中，您自动获得诸如集群审计跟踪（例如谁在什么时候做了什么）的好处。它进一步确保了Kubernetes集群的合规性和稳定性。
- en: You can also recover your cluster faster, in case of a disaster, from hours
    to minutes because your entire system is described in Git.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在灾难发生时，您也可以更快地恢复集群，从几个小时到几分钟，因为您的整个系统都在Git中描述。
- en: Your application code is already on Git, and with GitOps, your operation tasks
    are part of the same end-to-end workflows. You have a consistent Git workflow
    across your entire organization.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序代码已经在Git上，并且通过GitOps，您的操作任务是同一端到端工作流程的一部分。您在整个组织中都有一致的Git工作流程。
- en: It's only fair that we also cover some details about Argo CD so that it's easier
    to understand the later part where we implement a GitOps workflow using Skaffold
    and Argo CD.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，我们也应该涵盖一些关于Argo CD的细节，这样在后面实现使用Skaffold和Argo CD的GitOps工作流程时会更容易理解。
- en: What is Argo CD?
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Argo CD？
- en: As per the official documentation of **Argo CD**, [https://argo-cd.readthedocs.io/en/stable/](https://argo-cd.readthedocs.io/en/stable/),
    it is a declarative, GitOps continuous delivery tool for Kubernetes. In the previous
    section, we used the term *GitOps tool* that can compare and sync the application
    state if it deviates from what we have defined in the Git repository, so it is
    safe to say that Argo CD is the tool that handles this automation. Kubernetes
    introduced us to the concept of control loops through which Kubernetes checks
    whether the number of replicas running matches with the desired number of replicas.
    Argo CD leverages the same **Kubernetes** (**K8s**) capabilities, and its core
    component is `argocd-application-controller`, which is basically a Kubernetes
    controller. It monitors the state of your application and adjusts the cluster
    accordingly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 根据**Argo CD**的官方文档，[https://argo-cd.readthedocs.io/en/stable/](https://argo-cd.readthedocs.io/en/stable/)，它是一个声明性的、GitOps的Kubernetes持续交付工具。在前一节中，我们使用了术语*GitOps工具*，它可以比较和同步应用程序状态，如果与Git存储库中定义的不一致，那么可以说Argo
    CD是处理这种自动化的工具。Kubernetes通过控制循环的概念介绍了我们，通过这个概念，Kubernetes检查运行的副本数量是否与期望的副本数量匹配。Argo
    CD利用了相同的**Kubernetes**（**K8s**）功能，它的核心组件是`argocd-application-controller`，基本上是一个Kubernetes控制器。它监视您的应用程序状态，并相应地调整集群。
- en: And now it's time to learn about GitOps by implementing it with Skaffold and
    Argo CD on Google Kubernetes Engine. Let's begin.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过在Google Kubernetes Engine上使用Skaffold和Argo CD来实现GitOps了。让我们开始吧。
- en: Continuous delivery with Argo CD and Skaffold on GKE
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在GKE上使用Argo CD和Skaffold进行持续交付
- en: Before we begin, we need to make sure that we have met the following prerequisites.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要确保已满足以下先决条件。
- en: We first need to install `kubectl`.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先需要安装`kubectl`。
- en: The current Kubernetes context is set to a remote GKE cluster. You can verify
    the current context with the `kubectl config current-context` command.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前的Kubernetes上下文设置为远程GKE集群。您可以使用`kubectl config current-context`命令验证当前上下文。
- en: 'We can run this demonstration on the local Kubernetes cluster but, ideally,
    you would be running it with a managed Kubernetes service such as GKE. Let''s
    begin:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在本地Kubernetes集群上运行这个演示，但是理想情况下，您应该在像GKE这样的托管Kubernetes服务上运行它。让我们开始吧：
- en: 'First, we will install Argo CD on GKE using the following command:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用以下命令在GKE上安装Argo CD：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We created a separate namespace, `argocd,` and all Argo CD-related components
    will be part of it. We can verify the installation by navigating to the workloads
    section under GKE.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个单独的命名空间`argocd`，所有与Argo CD相关的组件都将成为其中的一部分。我们可以通过转到GKE下的工作负载部分来验证安装。
- en: 'In the following screenshot, you can see that Argo CD stateful set components,
    that is, `argocd-application-controller`, and deployment components such as `argocd-server`
    are up and running on GKE:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，您可以看到Argo CD的有状态集组件，即`argocd-application-controller`，以及部署组件，如`argocd-server`正在在GKE上运行：
- en: '![Figure 9.15 –  Argo CD Kubernetes resources deployed to GKE'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.15 - Argo CD Kubernetes资源部署到GKE'
- en: '](image/Figure_9.15_B17385.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.15_B17385.jpg)'
- en: Figure 9.15 –  Argo CD Kubernetes resources deployed to GKE
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 - Argo CD Kubernetes资源部署到GKE
- en: Next, we can install the Argo CD CLI. This is an optional step as we will be
    using the Argo CD UI instead.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以安装 Argo CD CLI。这是一个可选步骤，因为我们将使用 Argo CD UI。
- en: 'Next, we need to expose the Argo CD API server as by default it is not exposed
    for external access. We can run the following command to change the service type
    to `LoadBalancer`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要公开Argo CD API服务器，因为默认情况下它不会对外部访问公开。我们可以运行以下命令将服务类型更改为`LoadBalancer`：
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the following screenshot, you can see that the service type has changed
    to `External load balancer` and we will access the Argo CD GUI using that IP address:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到服务类型已更改为“外部负载均衡器”，我们将使用该IP地址访问 Argo CD GUI：
- en: '![Figure 9.16 –  Argo CD API server exposed as LoadBalancer'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.16 - Argo CD API服务器公开为LoadBalancer'
- en: '](image/Figure_9.16_B17385.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.16_B17385.jpg)'
- en: Figure 9.16 –  Argo CD API server exposed as LoadBalancer
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 - Argo CD API服务器公开为LoadBalancer
- en: You can even use ingress or `kubectl` port forwarding for accessing the Argo
    CD API server without exposing the service.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以使用ingress或`kubectl`端口转发来访问Argo CD API服务器，而无需暴露服务。
- en: 'We can now access the Argo CD GUI using the default admin user name and get
    the password using the following command:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用默认的管理员用户名访问Argo CD GUI，并使用以下命令获取密码：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should see the following login screen:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下登录界面：
- en: '![Figure 9.17 – Argo CD login screen'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.17 - Argo CD登录界面'
- en: '](image/Figure_9.17_B17385.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.17_B17385.jpg)'
- en: Figure 9.17 – Argo CD login screen
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 - Argo CD登录界面
- en: 'After logging in, click the **+ NEW APP** button, as shown in the following
    screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，点击**+新应用**按钮，如下面的屏幕截图所示：
- en: '![Figure 9.18 – Create application'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.18 - 创建应用程序'
- en: '](image/Figure_9.18_B17385.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.18_B17385.jpg)'
- en: Figure 9.18 – Create application
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18 - 创建应用程序
- en: 'In the next screen, enter your application name, choose the default project,
    and set **SYNC POLICY** to **Automatic**:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，输入您的应用程序名称，选择默认项目，并将**同步策略**设置为**自动**：
- en: '![Figure 9.19 – Argo CD application onboarding'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.19 - Argo CD应用程序入职'
- en: '](image/Figure_9.19_B17385.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.19_B17385.jpg)'
- en: Figure 9.19 – Argo CD application onboarding
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19 - Argo CD应用程序入职
- en: 'Enter the source Git repository URL. Provide the path for Kubernetes manifests
    inside the Git repository. Argo CD polls your Git repository every 3 minutes to
    apply updated manifests to your Kubernetes cluster. You can avoid this delay by
    setting up a webhook event:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入源Git存储库URL。提供Git存储库中Kubernetes清单的路径。 Argo CD每3分钟轮询一次您的Git存储库，以将更新的清单应用到您的Kubernetes集群。您可以通过设置webhook事件来避免此延迟：
- en: '![Figure 9.20 – Providing application Git repository details to Argo CD'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.20 - 向 Argo CD 提供应用程序Git存储库详细信息'
- en: '](image/Figure_9.20_B17385.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.20_B17385.jpg)'
- en: Figure 9.20 – Providing application Git repository details to Argo CD
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20 - 向 Argo CD 提供应用程序Git存储库详细信息
- en: 'For **DESTINATION**, set cluster to in-cluster and **Namespace** to **default,**
    as shown in the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将目的地设置为集群内部，并将命名空间设置为默认值，如下面的屏幕截图所示：
- en: '![Figure 9.21 –  Providing destination cluster details to Argo CD'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.21 - 向 Argo CD 提供目的地集群详细信息'
- en: '](image/Figure_9.21_B17385.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.21_B17385.jpg)'
- en: Figure 9.21 –  Providing destination cluster details to Argo CD
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21 - 向 Argo CD 提供目的地集群详细信息
- en: 'After filling out the required information, click **CREATE** at the top of
    the UI to create the application. After clicking on the **CREATE** button, the
    Kubernetes manifests available in the Git repository at the path `Chapter09/gitops`
    are retrieved, and Argo CD performs `kubectl apply` on those manifests:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 填写所需信息后，点击UI顶部的**CREATE**来创建应用程序。点击**CREATE**按钮后，将从Git存储库的路径`Chapter09/gitops`中检索到的Kubernetes清单，并且Argo
    CD对这些清单执行`kubectl apply`：
- en: '![](image/Figure_9.22_B17385.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](image/Figure_9.22_B17385.jpg)'
- en: Figure 9.22 – Create application
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22 - 创建应用程序
- en: 'After creating the application, you should see the following screen. The **Status**
    is **Progressing**:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序后，您应该看到以下屏幕。**状态**为**进行中**：
- en: '![Figure 9.23 – Application created and synced'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.23 - 应用程序已创建并同步'
- en: '](image/Figure_9.23_B17385.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.23_B17385.jpg)'
- en: Figure 9.23 – Application created and synced
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23 - 应用程序已创建并同步
- en: 'Click on the application and you will see the following screen:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 点击应用程序，您将看到以下屏幕：
- en: '![Figure 9.24 – Application deployed and in Healthy status'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.24 - 应用程序部署并处于健康状态'
- en: '](image/Figure_9.24_B17385.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.24_B17385.jpg)'
- en: Figure 9.24 – Application deployed and in Healthy status
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24 - 应用程序部署并处于健康状态
- en: You can see the deployments, `svc`, and pods listed here. The application **SYNC
    STATUS** is **Synced** and **APP HEALTH** is **Healthy**. Argo CD has built-in
    health checks for different Kubernetes resource types such as Deployment and ReplicaSets.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处看到部署、`svc`和pod的列表。应用程序**同步状态**为**已同步**，**应用健康**为**健康**。Argo CD对不同的Kubernetes资源类型（如Deployment和ReplicaSets）内置了健康检查。
- en: 'We have set up the continuous delivery workflow for our application, and the
    application is synced successfully. Now we will try to test the workflow by doing
    some local changes with the following steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为我们的应用程序设置了持续交付工作流程，并且应用程序已成功同步。现在我们将尝试通过以下步骤进行一些本地更改来测试工作流程：
- en: Set the default container registry to GCR using the `skaffold config set default-repo
    gcr.io/project-id` command.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`skaffold config set default-repo gcr.io/project-id`命令将默认容器注册表设置为GCR。
- en: We will build, tag, and push the container image using the `skaffold build`
    command.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`skaffold build`命令构建、标记和推送容器映像。
- en: Then we will run the `skaffold render` command. This command will generate hydrated
    (that is, with newly generated image tags) Kubernetes manifests to a file that
    we will later commit and push to the Git repository. The GitOps pipeline using
    Argo CD will pick and sync those changes to the target Kubernetes cluster.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将运行`skaffold render`命令。该命令将生成水合物（即，带有新生成的图像标签）的Kubernetes清单文件，我们将稍后提交并推送到Git存储库。使用Argo
    CD的GitOps流水线将挑选并同步这些更改到目标Kubernetes集群。
- en: Let's begin with this process.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个过程开始。
- en: 'We will make cosmetic code changes, increase replicas from one to two and run
    the `skaffold render` command. As per the `skaffold.yaml` file, the Kubernetes
    manifests are defined in the k8s directory. While running the `skaffold render`
    command, we will also pass the `--output=gtipos/manifest.yaml` flag so that we
    can later push it to the Git repository. The following is the output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行一些代码的外观更改，将副本数从1增加到2，并运行`skaffold render`命令。根据`skaffold.yaml`文件，Kubernetes清单在k8s目录中定义。在运行`skaffold
    render`命令时，我们还将传递`--output=gtipos/manifest.yaml`标志，以便稍后将其推送到Git存储库。以下是输出：
- en: '[PRE14]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I just wanted to highlight that `skaffold render` doesn't generate anew but
    will use existing Kubernetes manifests and update the image with a new tag.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我只想强调一下，`skaffold render`不会生成新的，而是将使用现有的Kubernetes清单并使用新标签更新图像。
- en: 'Finally, we commit the changes and push them to the GitHub repository with
    the following command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下命令提交更改并将其推送到GitHub存储库：
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Soon after the push, Argo CD will sync the changes to the GKE cluster, as shown
    in the following screenshot:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 推送后不久，Argo CD将同步更改到GKE集群，如下截图所示：
- en: '![Figure 9.25 – Increased number of replicas'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.25 – 增加副本数'
- en: '](image/Figure_9.25_B17385.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.25_B17385.jpg)'
- en: Figure 9.25 – Increased number of replicas
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25 – 增加副本数
- en: In the screenshot, you can see that now we have two pods running as we have
    increased the number of replicas.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在截图中，您可以看到现在我们有两个正在运行的pod，因为我们增加了副本数。
- en: The following screenshot illustrates a typical GitOps workflow with Skaffold
    and Argo CD. We have pretty much already covered the same steps so far. Let's
    try to summarize what we have learned so far.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了使用Skaffold和Argo CD的典型GitOps工作流程。到目前为止，我们已经基本上涵盖了相同的步骤。让我们尝试总结到目前为止我们学到了什么。
- en: '![](image/Figure_9.26_B17385.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](image/Figure_9.26_B17385.jpg)'
- en: Figure 9.26 – GitOps workflow with Skaffold and Argo CD
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.26 – 使用Skaffold和Argo CD的GitOps工作流程
- en: 'We can conclude the following from the screenshot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从截图中得出以下结论：
- en: A developer commits and pushes code changes to the Git repository.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员提交并推送代码更改到Git存储库。
- en: Continuous integration pipeline kicks in and using skaffold build, we will build,
    tag, and push the image to container registry.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续集成流水线启动，并使用skaffold构建，我们将构建、标记并推送图像到容器注册表。
- en: We will also generate hydrated manifests using skaffold render and commit them
    to either the same or different repository.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将使用skaffold render生成水合物清单，并将其提交到相同或不同的存储库。
- en: Either sync action is triggered using CI webhook, or changes are pulled after
    regular polling intervals by Argo CD controller running inside the Kubernetes
    cluster.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CI webhook触发任一同步操作，或者在Kubernetes集群内运行的Argo CD控制器定期轮询间隔后拉取更改。
- en: Further, the Argo CD controller will compare the live state against the desired
    target state (as per the git commit done on the config repository).
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，Argo CD控制器将比较实时状态与期望的目标状态（根据配置存储库上的git提交）。
- en: If Argo CD detects that the application is OutOfSync, it will apply the latest
    changes to the Kubernetes cluster.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Argo CD检测到应用程序处于OutOfSync状态，它将应用最新更改到Kubernetes集群。
- en: 'In this section, we have learned how to create a GitOps pipeline combining
    two powerful tools: Skaffold and Argo CD. We could have used the `skaffold apply`
    command instead of Argo CD but the `skaffold apply` command always uses `kubetcl`
    to deploy resources to the target cluster. If you have an application bundled
    as Helm charts then it will not work. Furthermore, with Argo CD, you can combine
    Argo Rollouts to do blue-green and canary deployments as they are natively not
    supported with Skaffold.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何结合两个强大工具Skaffold和Argo CD创建GitOps流水线。我们本可以使用`skaffold apply`命令代替Argo
    CD，但`skaffold apply`命令总是使用`kubetcl`将资源部署到目标集群。如果您的应用程序打包为Helm图表，则它将无法工作。此外，使用Argo
    CD，您可以结合Argo Rollouts进行蓝绿部署和金丝雀部署，因为它们在Skaffold中原生不受支持。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned how you can use GitHub Actions to automate
    your development workflows. We started the chapter by explaining GitHub Actions
    and their components. We explained GitHub Actions and related concepts with an
    example. In the example, we explained how you could build, test, and deploy your
    Java applications from your GitHub repository. Then we described how you could
    create a CI/CD pipeline for your Kubernetes applications using Skaffold and GitHub
    Actions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了如何使用GitHub Actions自动化您的开发工作流程。我们通过解释GitHub Actions及其组件来开始本章。我们通过示例解释了GitHub
    Actions和相关概念。在示例中，我们解释了如何从GitHub存储库构建、测试和部署Java应用程序。然后我们描述了如何使用Skaffold和GitHub
    Actions为您的Kubernetes应用程序创建CI/CD流水线。
- en: You have discovered how you can take advantage of GitHub Actions and combine
    them with Skaffold to create CI/CD pipelines. Then in the final section, we took
    deep dive into setting up GitOps style continuous delivery workflow with Skaffold
    and Argo CD. We have learned that in GitOps we consider Git repository as a single
    source of truth for any change related to your infrastructure. We have also demonstrated
    how we can implement GitOps pipeline with Argo CD and Skaffold.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解了如何利用GitHub Actions并将其与Skaffold结合，创建CI/CD流水线。然后在最后一节中，我们深入探讨了如何使用Skaffold和Argo
    CD建立GitOps风格的持续交付工作流。我们已经了解到，在GitOps中，我们将Git存储库视为与基础架构相关的任何更改的唯一真相来源。我们还演示了如何使用Argo
    CD和Skaffold实现GitOps流水线。
- en: In the next chapter, we will talk about Skaffold alternatives, and we will also
    cover its best practices and common pitfalls.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Skaffold的替代方案，还将涵盖其最佳实践和常见陷阱。
- en: Further reading
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Learn more about automating workflow with GitHub actions from Automating Workflows
    with GitHub Actions ([https://www.packtpub.com/product/automating-workflows-with-github-actions/9781800560406](https://www.packtpub.com/product/automating-workflows-with-github-actions/9781800560406)),
    published by Packt.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Packt出版的《使用GitHub Actions自动化工作流》([https://www.packtpub.com/product/automating-workflows-with-github-actions/9781800560406](https://www.packtpub.com/product/automating-workflows-with-github-actions/9781800560406))了解如何使用GitHub
    actions自动化工作流。
- en: Learn more about GitHub from GitHub Essentials ([https://www.packtpub.com/product/github-essentials-second-edition/9781789138337](https://www.packtpub.com/product/github-essentials-second-edition/9781789138337)),
    published by Packt.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Packt出版的《GitHub Essentials》([https://www.packtpub.com/product/github-essentials-second-edition/9781789138337](https://www.packtpub.com/product/github-essentials-second-edition/9781789138337))了解更多关于GitHub的内容。
