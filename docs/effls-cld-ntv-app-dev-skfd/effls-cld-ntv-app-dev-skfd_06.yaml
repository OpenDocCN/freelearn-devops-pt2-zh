- en: '[*Chapter 4*](B17385_04_Final_PD_ePub.xhtml#_idTextAnchor044): Understanding
    Skaffold''s Features and Architecture'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第4章*]：理解Skaffold的功能和架构'
- en: In the previous chapter, we gained a basic understanding of Skaffold through
    some coding examples. This chapter will cover the features that are provided by
    Skaffold. Additionally, we will explore Skaffold's internals by looking at its
    architecture, workflow, and the `skaffold.yaml` configuration file.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过一些编码示例对Skaffold有了基本的了解。本章将介绍Skaffold提供的功能。此外，我们将通过查看其架构、工作流程和`skaffold.yaml`配置文件来探索Skaffold的内部。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding Skaffold's features
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Skaffold的功能
- en: Demystifying Skaffold's architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭秘Skaffold的架构
- en: Understanding the Skaffold workflow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Skaffold的工作流程
- en: Deciphering Skaffold's configuration with `skaffold.yaml`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`skaffold.yaml`解密Skaffold的配置
- en: By the end of this chapter, you will have a solid understanding of the features
    that Skaffold provides, and how it performs all the magic, by looking at its workflow
    and architecture.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将对Skaffold提供的功能有扎实的了解，并通过查看其工作流程和架构来了解它是如何完成所有魔术的。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, you will need to have the
    following software installed:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章的示例，您需要安装以下软件：
- en: Eclipse ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/))
    or IntelliJ IDE ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/))
    或 IntelliJ IDE ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
- en: Git ([https://git-scm.com/downloads](https://git-scm.com/downloads))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git ([https://git-scm.com/downloads](https://git-scm.com/downloads))
- en: Skaffold ([https://skaffold.dev/docs/install/](https://skaffold.dev/docs/install/))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Skaffold ([https://skaffold.dev/docs/install/](https://skaffold.dev/docs/install/))
- en: Docker Desktop for macOS and Windows ([https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop))
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Desktop for macOS和Windows ([https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop))
- en: You can download the code examples for this chapter from the GitHub repository
    at [https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold](https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub存储库[https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold](https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold)下载本章的代码示例。
- en: Understanding Skaffold's features
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Skaffold的功能
- en: In [*Chapter 3*](B17385_03_Final_PD_ePub.xhtml#_idTextAnchor034), *Skaffold
    – Easy-Peasy Cloud-Native Kubernetes Application Development*, we were introduced
    to Skaffold. We uncovered some of its features by building and deploying a Spring
    Boot application to the local Kubernetes cluster. However, Skaffold is capable
    of far more than that, so let's take a look at some of its features.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*]，*Skaffold – Easy-Peasy Cloud-Native Kubernetes Application Development*中，我们介绍了Skaffold。我们通过构建和部署Spring
    Boot应用程序到本地Kubernetes集群来揭示了一些功能。然而，Skaffold能做的远不止这些，让我们来看看它的一些功能。
- en: 'Skaffold has the following features:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold具有以下功能：
- en: '**Easy to share**: Sharing your project among the same or different teams,
    provided they already have Skaffold installed, is effortless. They have to run
    the following commands to proceed with their development activities:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于共享**：在同一团队或不同团队之间共享项目非常简单，只要他们已经安装了Skaffold，就可以运行以下命令继续开发活动：'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Integrated with IDE**: Many IDEs, such as IntelliJ and VS Code, support the
    **Cloud Code** plugin developed by Google, which internally uses Skaffold and
    its API to provide a better developer experience while developing a Kubernetes
    application. Using the IntelliJ or VS code **Google Cloud Code Extension** plugin
    makes it easier for you to create, edit, and update the `skaffold.yaml` file with
    its code completion feature. For example, to give you a little more context regarding
    this, the plugin can detect that the project is using Skaffold to build and deploy
    by looking at the `skaffold.yaml` configuration file:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与IDE集成**：许多IDE，如IntelliJ和VS Code，支持由Google开发的**Cloud Code**插件，该插件内部使用Skaffold及其API，在开发Kubernetes应用程序时提供更好的开发者体验。使用IntelliJ或VS
    code的**Google Cloud Code Extension**插件可以更轻松地使用其代码补全功能创建、编辑和更新`skaffold.yaml`文件。例如，为了让您对此有更多的上下文，插件可以通过查看`skaffold.yaml`配置文件来检测项目是否正在使用Skaffold进行构建和部署：'
- en: '![Figure 4.1 – The IntelliJ Cloud code plugin detects the Skaffold configuration'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 – IntelliJ Cloud code插件检测到Skaffold配置'
- en: '](image/Figure_4.1_B17385.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.1_B17385.jpg)'
- en: Figure 4.1 – The IntelliJ Cloud code plugin detects the Skaffold configuration
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – IntelliJ Cloud code插件检测到Skaffold配置
- en: You can also look up supported builders and deployers with Skaffold using the
    code completion feature. We will cover the Cloud Code plugin specifically in [*Chapter
    7*](B17385_07_Final_PD_ePub.xhtml#_idTextAnchor092),  *Building and Deploying
    a Spring Boot Application with the Cloud Code Plugin*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用代码补全功能查找Skaffold支持的构建器和部署器。我们将在[*第7章*](B17385_07_Final_PD_ePub.xhtml#_idTextAnchor092)中专门介绍Cloud
    Code插件，*使用Cloud Code插件构建和部署Spring Boot应用程序*。
- en: '**File sync**: Skaffold has an excellent file sync feature. It can copy the
    changed files directly to an already running container to avoid rebuilding, redeploying,
    and restarting the container.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件同步**：Skaffold具有出色的文件同步功能。它可以直接将更改的文件复制到已经运行的容器中，以避免重新构建、重新部署和重新启动容器。'
- en: We will learn more about this in [*Chapter 5*](B17385_05_Final_PD_ePub.xhtml#_idTextAnchor052),
    *Installing Skaffold and Demystifying Its Pipeline Stages*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第5章*](B17385_05_Final_PD_ePub.xhtml#_idTextAnchor052)中了解更多信息，*安装Skaffold并揭秘其流水线阶段*。
- en: '**Super-fast local development**: In the previous chapter, you learned that
    building and deploying an application with Skaffold is pretty quick as it can
    figure out whether your Kubernetes context is set to a local Kubernetes cluster
    and will avoid pushing the image to a remote container registry. Therefore, you
    can bypass that expensive network hop and also preserve the battery life of your
    laptop.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超快速本地开发**：在上一章中，您了解到使用Skaffold构建和部署应用程序非常快速，因为它可以确定您的Kubernetes上下文是否设置为本地Kubernetes集群，并且将避免将镜像推送到远程容器注册表。因此，您可以避免昂贵的网络跳跃，同时也可以延长笔记本电脑的电池寿命。'
- en: Not only that, but Skaffold detects your code changes in real time and automates
    the build, push, and deploy workflows. So, you can continue working within your
    inner development loop with the focus on coding, and there is no need to leave
    that loop until you are completely sure about the change you are making. This
    not only accelerates your inner development loop but also makes you more productive.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，Skaffold实时检测您的代码更改，并自动化构建、推送和部署工作流程。因此，您可以在内部开发循环中继续工作，专注于编码，而无需离开该循环，直到您完全确定所做的更改。这不仅加快了您的内部开发循环，还使您更加高效。
- en: '**Effortless remote development**: So far, while reading this book, you might
    have the impression that Skaffold can only accelerate the inner development loop.
    Oh, boy! You are in for a surprise as Skaffold can handle outer development loop
    workflows as well. For example, you can use Skaffold to create full-fledged production-ready
    CI/CD pipelines. We will cover this specifically in [*Chapter 9*](B17385_09_Final_PD_ePub.xhtml#_idTextAnchor116),
    *Creating a Production-Ready CI/CD Pipeline with Skaffold*. Not only that, but
    you can also switch your Kubernetes context in your local development environment
    using commands such as `kubectl config use-context context-name` and perform a
    deployment to a remote cluster of your choice.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻松的远程开发**：到目前为止，在阅读本书时，你可能会认为Skaffold只能加速内部开发循环。哦，天哪！你会惊喜地发现Skaffold也可以处理外部开发循环工作流。例如，你可以使用Skaffold创建成熟的生产就绪的CI/CD流水线。我们将在[*第9章*](B17385_09_Final_PD_ePub.xhtml#_idTextAnchor116)中具体介绍这一点，*使用Skaffold创建生产就绪的CI/CD流水线*。不仅如此，你还可以使用命令如`kubectl
    config use-context context-name`在本地开发环境中切换Kubernetes上下文，并将部署到你选择的远程集群。'
- en: Since we are talking about remote development, I just wanted to highlight another
    point—you don't need to run Docker daemon if you are using the `jib-maven` plugin
    for a remote build (that is, if you are pushing to a remote container registry).
    You can also use something like **Google Cloud Build** to do remote builds. Cloud
    Build is a service provided by **Google Cloud Platform** that you can use to execute
    your builds and create serverless CI/CD pipelines in the cloud for your cloud-native
    applications. It might be slow if you run it from your local system, but it's
    worth exploring.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在讨论远程开发，我想强调另一点——如果你正在使用`jib-maven`插件进行远程构建（即，如果你要推送到远程容器注册表），你就不需要运行Docker守护进程。你也可以使用像**Google
    Cloud Build**这样的工具进行远程构建。Cloud Build是**Google Cloud Platform**提供的一项服务，你可以使用它在云中执行构建，并为云原生应用程序创建无服务器CI/CD流水线。如果你从本地系统运行它可能会比较慢，但值得探索。
- en: '**Built-in image tag management**: In the previous chapter, while declaring
    Kubernetes deployment manifests, we only mentioned the image name and not the
    image tag while building and deploying the Spring Boot application. For example,
    in the following snippet from the previous chapter, in the `image:` field, we
    only mentioned the image name:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置镜像标签管理**：在上一章中，在声明Kubernetes部署清单时，我们只提到了镜像名称，而没有在构建和部署Spring Boot应用程序时提到镜像标签。例如，在上一章的以下片段中，在`image:`字段中，我们只提到了镜像名称：'
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Typically, we have to tag an image before pushing and then use the same image
    tag while pulling. For example, you would also have to specify the image tag in
    the following format:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们必须在推送之前给镜像打标签，然后在拉取时使用相同的镜像标签。例如，你还必须以以下格式指定镜像标签：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The reason for this is that Skaffold automatically generates the image tag for
    you, out of the box, every time you rebuild the image. This is so that you don't
    have to edit the Kubernetes manifests manually. The default tagging strategy with
    Skaffold is `gitCommit`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Skaffold会在每次重新构建镜像时自动生成镜像标签，这样你就不必手动编辑Kubernetes清单文件。Skaffold的默认标记策略是`gitCommit`。
- en: We will cover this in greater detail in [*Chapter 5*](B17385_05_Final_PD_ePub.xhtml#_idTextAnchor052),
    *Installing Skaffold and Demystifying Its Pipeline Stages*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第5章*](B17385_05_Final_PD_ePub.xhtml#_idTextAnchor052)中更详细地介绍这一点，*安装Skaffold并揭秘其流水线阶段*。
- en: '**Lightweight**: Skaffold is entirely a CLI tool. There are no server-side
    components to look for while working with Skaffold. This makes it extremely lightweight,
    easy to use, and there is no maintenance burden. The size of the Skaffold binary
    is around 63 MB.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻量级**：Skaffold完全是一个CLI工具。在使用Skaffold时不需要寻找服务器端组件。这使得它非常轻量、易于使用，而且没有维护负担。Skaffold二进制文件的大小约为63MB。'
- en: '**Pluggable architecture**: Skaffold has a pluggable architecture. This will
    eventually mean that you can pick and choose a build and deploy tool of your choice.
    Bring your own tools, and Skaffold will adjust itself accordingly.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可插拔架构**：Skaffold具有可插拔架构。这最终意味着您可以选择构建和部署工具。自带您自己的工具，Skaffold将相应地调整自己。'
- en: '**Purpose-built for CI/CD pipelines**: Skaffold can help you to create effective
    CI/CD pipelines. For example, you can use the `skaffold run` command to execute
    an end-to-end pipeline or use individual commands such as `skaffold build` or
    `skaffold deploy`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专为CI/CD流水线而设计**：Skaffold可以帮助您创建有效的CI/CD流水线。例如，您可以使用`skaffold run`命令执行端到端的流水线，或者使用诸如`skaffold
    build`或`skaffold deploy`之类的单独命令。'
- en: Furthermore, with commands such as `skaffold render` and `skaffold apply`, you
    can create a **GitOps**-style continuous delivery workflow for your application.
    GitOps allows you to store your application's desired state inside a Git repository
    in the form of Kubernetes manifests. It also allows others to view your infrastructure
    as code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过诸如`skaffold render`和`skaffold apply`之类的命令，您可以为应用程序创建**GitOps**风格的持续交付工作流程。GitOps允许您将应用程序的期望状态存储在Git存储库中，以Kubernetes清单的形式。它还允许其他人将您的基础架构视为代码。
- en: '**Effortless environment management**: Skaffold allows you to define, build,
    test, and deploy configurations for different environments. You can keep one set
    of configurations for development or staging and another for production. Also,
    you can keep completely different configurations on a per-environment basis. You
    can achieve this by using Skaffold profiles. This is relatively similar to the
    `profiles` feature provided for Spring Boot applications.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻松的环境管理**：Skaffold允许您为不同的环境定义、构建、测试和部署配置。您可以为开发或分段保留一组配置，为生产保留另一组配置。此外，您可以根据每个环境保持完全不同的配置。您可以通过使用Skaffold配置文件来实现这一点。这与为Spring
    Boot应用程序提供的`profiles`功能相对类似。'
- en: 'Please refer to the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下截图：
- en: '![Figure 4.2 – Skaffold profiles'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 – Skaffold配置文件'
- en: '](image/Figure_4.2_B17385.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.2_B17385.jpg)'
- en: Figure 4.2 – Skaffold profiles
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – Skaffold配置文件
- en: 'A typical Skaffold profile consists of the following parts:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的Skaffold配置文件包括以下部分：
- en: '`build`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`构建`'
- en: '`test`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`测试`'
- en: '`activation`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`激活`'
- en: '`deploy`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`部署`'
- en: '`name`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名称`'
- en: '`patches`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`补丁`'
- en: Some of these parts are quite obvious, as they explain the unique name of the
    profile, the build steps, the deployment steps, and how the images are tested.
    Let's move on to discuss patches and activation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些部分是相当明显的，因为它们解释了配置文件的唯一名称、构建步骤、部署步骤以及如何测试图像。让我们继续讨论补丁和激活。
- en: First, let's understand patches.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解补丁。
- en: Skaffold profile patches
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Skaffold配置文件补丁
- en: 'As the name suggests, patches are a more verbose way of overriding individual
    values in a `skaffold.yaml` file. For example, in the following snippet, instead
    of overriding the whole build section, the `dev` profile defines a different `Dockerfile`
    for the first artifact:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，补丁是一种更详细的方式，用于覆盖`skaffold.yaml`文件中的单个值。例如，在以下代码片段中，`dev`配置文件定义了第一个构件的不同`Dockerfile`，而不是覆盖整个构建部分：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the `op` string underneath the `patches` section specifies the operation
    to be performed by this patch. The `path` string specifies the position in the
    `.yaml` file where the operation that you defined in the `op` string takes place,
    and the `value` object specifies the value it should be replaced with.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`patches`部分下面的`op`字符串指定了此补丁要执行的操作。`path`字符串指定了`.yaml`文件中您在`op`字符串中定义的操作发生的位置，`value`对象指定了应替换的值。
- en: 'The following operations are supported:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 支持以下操作：
- en: '`add`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加
- en: '`remove`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除
- en: '`replace`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换
- en: '`move`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动
- en: '`copy`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制
- en: '`test`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: To summarize, here, we instruct Skaffold to replace the `Dockerfile` that was
    used to build the first `docker.io/hiashish/skaffold-example` image with a different
    `Dockerfile` named `Dockerfile_dev`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在这里，我们指示Skaffold使用名为`Dockerfile_dev`的不同`Dockerfile`替换用于构建第一个`docker.io/hiashish/skaffold-example`镜像的`Dockerfile`。
- en: Now, let's discuss activation objects in profiles.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论配置文件中的激活对象。
- en: Skaffold profile activation
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Skaffold配置文件激活
- en: 'You can activate a profile in Skaffold in one of the following two ways:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下两种方式之一在Skaffold中激活配置文件：
- en: Using a CLI
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CLI
- en: With `skaffold.yaml` activations
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`skaffold.yaml`激活
- en: 'First, let''s discuss how you can activate a profile using CLI. For example,
    in the following `skaffold.yaml` file, underneath the `profiles` section, we have
    declared a profile name, called `gcb`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论如何使用CLI激活配置文件。例如，在下面的`skaffold.yaml`文件中，在`profiles`部分下面，我们声明了一个名为`gcb`的配置文件名称：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This profile will be activated when running the `skaffold run` or `skaffold
    dev` command by passing either the `--profile` or `–p` CLI flag. If you run the
    following command, then Skaffold will use **Google Cloud Build** to build the
    artifacts:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行`skaffold run`或`skaffold dev`命令时，可以通过传递`--profile`或`-p`CLI标志来激活此配置文件。如果运行以下命令，则Skaffold将使用**Google
    Cloud Build**来构建这些构件：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice that we have not specified the `deploy` section underneath the `gcb`
    profile. This means that Skaffold will continue to use `kubectl` for deployment.
    If your use case requires multiple profiles, you can use the `-p` flag numerous
    times or pass comma-separated profiles, as shown in the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在`gcb`配置文件下面没有指定`deploy`部分。这意味着Skaffold将继续使用`kubectl`进行部署。如果您的用例需要多个配置文件，您可以多次使用`-p`标志或传递逗号分隔的配置文件，如下面的命令所示：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s try to understand this using another example. In this example, we will
    use the Spring Boot application that we built in [*Chapter 3*](B17385_03_Final_PD_ePub.xhtml#_idTextAnchor034),
    *Skaffold – Easy-Peasy Cloud-Native Kubernetes Application Development*. In that
    scenario, we used Jib to containerize the application; however, in this example,
    we will use a multistage Docker build to create a slim Docker image of our application.
    The following is the `Dockerfile` of our Spring Boot application:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用另一个例子来理解这个。在这个例子中，我们将使用我们在[*第3章*](B17385_03_Final_PD_ePub.xhtml#_idTextAnchor034)中构建的Spring
    Boot应用程序，*Skaffold – Easy-Peasy Cloud-Native Kubernetes Application Development*。在那种情况下，我们使用Jib来将应用程序容器化；然而，在这个例子中，我们将使用多阶段Docker构建来创建我们应用程序的精简Docker镜像。以下是我们Spring
    Boot应用程序的`Dockerfile`：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can explain the multistage `Dockerfile` build as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以解释多阶段`Dockerfile`构建如下：
- en: In the first stage of the build, we have used the `maven:3-adoptopenjdk-16`
    image to build and create `jar` for our application using the `mvn clean package`
    Maven command.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建的第一阶段中，我们使用`maven:3-adoptopenjdk-16`镜像使用`mvn clean package` Maven命令构建和创建了我们的应用程序的`jar`。
- en: In the second stage, we have copied `jar` we made in the previous build stage
    and created a new final image based on a significantly smaller *Java 16 JRE base
    image*.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二阶段，我们复制了在上一个构建阶段中制作的`jar`并基于一个明显更小的*Java 16 JRE基础镜像*创建了一个新的最终镜像。
- en: The final Docker image does not include the JDK or Maven image, just the JRE
    image. The only downside to this approach is that the build time is higher because
    all of the required dependencies need to be downloaded during the first stage
    of the build.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终的Docker镜像不包括JDK或Maven镜像，只包括JRE镜像。这种方法的唯一缺点是构建时间更长，因为在构建的第一阶段需要下载所有必需的依赖项。
- en: Tip
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can use Docker multistage builds to create slimmer Docker images of your
    application. The size of a typical JDK image is around 650 MB, and with the Docker
    multistage build, we can reduce its size by half by using JRE as the base image
    in the last stage of the multistage build.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Docker多阶段构建来创建更小的应用程序Docker镜像。典型的JDK镜像大小约为650 MB，通过使用JRE作为多阶段构建的最后阶段的基础镜像，我们可以将其大小减半。
- en: Additionally, you can further reduce the size of the image using Java tools
    such as `jdeps` and `jlink` (introduced in Java 9). While `jdeps` helps you to
    identify the required JVM modules, `jlink` allows you to create a customized JRE.
    With the combination of these tools, you can create a customized JRE, which results
    in an even slimmer Docker image of your application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以使用Java工具如`jdeps`和`jlink`（在Java 9中引入）进一步减小镜像的大小。`jdeps`帮助您识别所需的JVM模块，`jlink`允许您创建定制的JRE。通过这些工具的组合，您可以创建一个定制的JRE，从而使您的应用程序的Docker镜像更加精简。
- en: 'To demonstrate the use of profiles, we will make the following changes to the
    `skaffold.yaml` file. The following is the `skaffold.yaml` file in which we added
    a new profile called `docker`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示配置文件的使用，我们将对`skaffold.yaml`文件进行以下更改。以下是我们在`skaffold.yaml`文件中添加了一个名为`docker`的新配置文件：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will use the `skaffold run --profile docker` command to build and deploy
    our Spring Boot application. The following is the output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`skaffold run --profile docker`命令来构建和部署我们的Spring Boot应用程序。以下是输出：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding logs, you can see that, first, Skaffold began building our
    image using Docker. Also, we have used a multistage build, and then, in steps
    1 to 6, we are into the first stage of the build, wherein we created the `jar`
    of our application inside the container:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的日志中，您可以看到，首先，Skaffold开始使用Docker构建我们的镜像。此外，我们使用了多阶段构建，然后在步骤1到6中，我们进入了构建的第一阶段，在其中我们在容器内创建了我们应用程序的`jar`：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: in *steps 6 to 10*, we are in the second stage of the build where we have used
    `adoptopenjdk:16-jre` as the base image since we only need JRE to run our application.
    Typically, JRE images are of a smaller size than JDK.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6到10*中，我们处于构建的第二阶段，我们使用`adoptopenjdk:16-jre`作为基础镜像，因为我们只需要JRE来运行我们的应用程序。通常，JRE镜像比JDK镜像要小。
- en: 'This final output is our containerized application, which should appear as
    follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最终的输出是我们的容器化应用程序，应该如下所示：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, Skaffold deploys our containerized application to the local Kubernetes
    cluster.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Skaffold将我们的容器化应用部署到本地Kubernetes集群。
- en: 'Another way to activate a profile is to use the activation object array in
    `skaffold.yaml` to automatically activate a profile based upon the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 激活配置文件的另一种方法是在`skaffold.yaml`中使用激活对象数组自动激活配置文件，具体取决于以下内容：
- en: '`kubeContext`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubeContext`'
- en: 'An environment variable: `env`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个环境变量：`env`
- en: A Skaffold command
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Skaffold命令
- en: 'Please refer to the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下截图：
- en: '![Figure 4.3 – Skaffold profile activation using the skaffold.yaml file'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 - 使用skaffold.yaml文件激活Skaffold配置文件'
- en: '](image/Figure_4.3_B17385.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.3_B17385.jpg)'
- en: Figure 4.3 – Skaffold profile activation using the skaffold.yaml file
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 - 使用skaffold.yaml文件激活Skaffold配置文件
- en: Let's attempt to understand this activation option using an example.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一个例子来理解这个激活选项。
- en: 'In the following code example, we have two profiles—`profile-staging` and `profile-production`.
    As their names suggest, `profile-staging` will be used for the staging environment,
    while `profile-production` will be used for the production environment:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，我们有两个配置文件——`profile-staging`和`profile-production`。正如它们的名称所暗示的，`profile-staging`将用于分段环境，而`profile-production`将用于生产环境：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, `profile-staging` will be automatically activated if the `ENV` environment
    variable key matches the value staging. We have not specified the build, test,
    and deploy steps for this specific profile, so it will continue to use the options
    we have provided in the main section of the `skaffold.yaml` file. In addition
    to this, `profile-production` will be automatically activated if the following
    criteria are satisfied. Note that it only runs the profile production stage if
    all of these criteria are activated:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果`ENV`环境变量键匹配值分段，`profile-staging`将自动激活。我们没有为此特定配置文件指定构建、测试和部署步骤，因此它将继续使用我们在`skaffold.yaml`文件的主要部分中提供的选项。除此之外，只有在满足以下条件时，`profile-production`才会自动激活。请注意，只有在满足所有这些条件时，它才会运行配置文件生产阶段：
- en: The `ENV` environment variable key matches the value production.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV`环境变量键匹配值生产。'
- en: The Kubernetes context is set to **GKE** (which is short for **Google Kubernetes
    Engine**).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes上下文设置为**GKE**（即**Google Kubernetes Engine**的缩写）。
- en: The Skaffold command that is used is `scaffold run`.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的Skaffold命令是`scaffold run`。
- en: Note that `profile-production` will use Google's Cloud Build for the build and
    will default to `kubectl` for the deployment (as it's not explicitly specified).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`profile-production`将使用Google的Cloud Build进行构建，并默认使用`kubectl`进行部署（因为没有明确指定）。
- en: This segregation also allows you to use various tools to build and deploy within
    different environments. For example, you might use Docker to create images in
    a local development and `Jib` for production. In the case of a deployment, you
    might use `kubectl` in development and Helm in production.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离还允许您在不同的环境中使用各种工具进行构建和部署。例如，您可能会在本地开发中使用Docker创建映像，而在生产中使用`Jib`。在部署的情况下，您可能会在开发中使用`kubectl`，而在生产中使用Helm。
- en: 'In the previous chapter, I explained that Skaffold, by default, looks for the
    current Kubernetes context from the `kube config` file that is located in `${HOME}/.kube/config
    path`. If you wish to change it, you can do that while running the `skaffold dev`
    command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我解释了Skaffold默认情况下会从位于`${HOME}/.kube/config`路径的`kube config`文件中查找当前的Kubernetes上下文。如果您希望更改它，可以在运行`skaffold
    dev`命令时进行更改：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also mention `kubeContext` in the `skaffold.yaml` file as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在`skaffold.yaml`文件中提到`kubeContext`，如下所示：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The flag passed via the CLI takes precedence over the `skaffold.yaml` file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过CLI传递的标志优先于`skaffold.yaml`文件。
- en: Next, let's discuss how Skaffold configures or adjusts itself to different local
    Kubernetes clusters.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论Skaffold如何配置或调整自己以适应不同的本地Kubernetes集群。
- en: A local Kubernetes cluster
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地Kubernetes集群
- en: By now, you should have realized that Skaffold provides sensible, smart defaults
    to make the development process easier without you having to tell it to do things.
    If your Kubernetes context is set to a local Kubernetes cluster, then there is
    no need to push an image to a remote Kubernetes cluster. Instead, Skaffold will
    move the image to the local Docker daemon to speed up the development cycle.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经意识到Skaffold提供了明智的、智能的默认值，使开发过程更加轻松，而无需告诉它要做什么。如果您的Kubernetes上下文设置为本地Kubernetes集群，那么就没有必要将映像推送到远程Kubernetes集群。相反，Skaffold将映像移动到本地Docker守护程序，以加快开发周期。
- en: 'So far, we have only discussed the Kubernetes cluster that comes with Docker
    Desktop, but this is not the only option you have. There are various ways in which
    to set up and run a local Kubernetes cluster. For example, you have the following
    choices when creating a local Kubernetes cluster:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了与Docker Desktop一起提供的Kubernetes集群，但这并不是您唯一的选择。有多种方式可以设置和运行本地Kubernetes集群。例如，在创建本地Kubernetes集群时，您有以下选择：
- en: Docker Desktop ([https://docs.docker.com/desktop/kubernetes/#enable-kubernetes](https://docs.docker.com/desktop/kubernetes/#enable-kubernetes))
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Desktop ([https://docs.docker.com/desktop/kubernetes/#enable-kubernetes](https://docs.docker.com/desktop/kubernetes/#enable-kubernetes))
- en: Minikube ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minikube ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
- en: Kind ([https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/))
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kind ([https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/))
- en: k3d ([https://k3d.io/](https://k3d.io/))
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: k3d ([https://k3d.io/](https://k3d.io/))
- en: If any of these supported Kubernetes installations are available for local development,
    Skaffold expects that Kubernetes' context is as shown in the following table.
    Otherwise, it will assume that we are deploying to a remote Kubernetes cluster.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些支持的Kubernetes安装可用于本地开发，则Skaffold期望Kubernetes的上下文如下表所示。否则，它将假定我们正在部署到远程Kubernetes集群。
- en: 'Skaffold detects a local cluster based on the Kubernetes context name, as described
    in the following table:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下表格中描述的Kubernetes上下文名称，Skaffold会检测本地集群：
- en: '![Table 4.1 – The Kubernetes context supported by Skaffold'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![表4.1 - Skaffold支持的Kubernetes上下文'
- en: '](image/Table_4.1_B17385.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_4.1_B17385.jpg)'
- en: Table 4.1 – The Kubernetes context supported by Skaffold
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 - Skaffold支持的Kubernetes上下文
- en: 'However, for other nonstandard local cluster setups, such as when running `minikube`
    with a custom profile (for instance, `minikube` `start -p my-profile`), you can
    use the following commands to tell Skaffold that you are using a local Kubernetes
    cluster:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于其他非标准的本地集群设置，比如使用自定义配置运行`minikube`（例如，`minikube` `start -p my-profile`），您可以使用以下命令告诉Skaffold您正在使用本地Kubernetes集群：
- en: 'First, set up the Docker environment for Skaffold using the following command:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令为Skaffold设置Docker环境：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, instruct Skaffold to consider `my-profile` as a local cluster using the
    following command:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下命令指示Skaffold将`my-profile`视为本地集群：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this section, we took a deep dive into the features that Skaffold provides.
    Now, let's discuss Skaffold's architecture.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了Skaffold提供的功能。现在，让我们讨论Skaffold的架构。
- en: Demystifying Skaffold's architecture
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解密Skaffold的架构
- en: 'As mentioned in the previous section, Skaffold has been designed with pluggability
    in mind. The following is a visualization of the Skaffold architecture:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Skaffold的设计考虑了可插拔性。以下是Skaffold架构的可视化：
- en: '![Figure 4.4 – The Skaffold architecture'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 - Skaffold架构'
- en: '](image/Figure_4.4_B17385.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.4_B17385.jpg)'
- en: Figure 4.4 – The Skaffold architecture
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 - Skaffold架构
- en: From this architecture diagram, you can conclude that Skaffold has a modular
    design. However, what is a modular design?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个架构图中，您可以得出结论，Skaffold具有模块化设计。但是，什么是模块化设计？
- en: Well, a modular design, or modularity in design, is a design principle that
    subdivides a system into smaller parts called modules, which can be independently
    created, modified, replaced, or exchanged with other modules or between different
    systems.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，模块化设计，或者说设计中的模块化，是一种将系统细分为称为模块的较小部分的设计原则，这些模块可以独立创建、修改、替换或与其他模块或不同系统之间交换。
- en: 'With this definition, we can define the following modules for Skaffold:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个定义，我们可以为Skaffold定义以下模块：
- en: Container image builders
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像构建器
- en: Container testing tools/strategy
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器测试工具/策略
- en: Container image taggers
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器映像标签器
- en: Container deployment tools
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器部署工具
- en: 'Now, let''s discuss each of these tools/modules in more detail. Currently,
    Skaffold supports the following container image builders:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地讨论每个这些工具/模块。目前，Skaffold支持以下容器映像构建器：
- en: '**Dockerfile**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dockerfile**'
- en: '**Jib (Maven and Gradle)**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jib（Maven和Gradle）**'
- en: '**Bazel**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bazel**'
- en: '**Cloud-Native Buildpacks**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cloud-Native Buildpacks**'
- en: '**Custom Script**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义脚本**'
- en: 'For deployment to Kubernetes, Skaffold supports the following tools:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于部署到Kubernetes，Skaffold支持以下工具：
- en: '**Helm**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Helm**'
- en: '**kubectl**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubectl**'
- en: '**kustomize**'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kustomize**'
- en: We will discuss these options in greater detail in [*Chapter 6*](B17385_06_PreFinal_PD_ePub.xhtml#_idTextAnchor074),
    *Working with Skaffold Container Image Builders and Deployers*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第6章*](B17385_06_PreFinal_PD_ePub.xhtml#_idTextAnchor074)中更详细地讨论这些选项，*使用Skaffold容器映像构建器和部署器*。
- en: 'Skaffold supports the following types of tests between the build and deployment
    phases of the pipeline:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold支持管道阶段之间的以下类型测试：
- en: Custom tests
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义测试
- en: Container structure tests
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器结构测试
- en: We will explore these options further in [*Chapter 5*](B17385_05_Final_PD_ePub.xhtml#_idTextAnchor052),  *Installing
    Skaffold and Demystifying Its Pipeline Stages*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第5章*](B17385_05_Final_PD_ePub.xhtml#_idTextAnchor052)中进一步探讨这些选项，*安装Skaffold并揭秘其流水线阶段*。
- en: 'As mentioned earlier, underneath the Skaffold **Features** section, Skaffold
    offers built-in image tag management. Currently, Skaffold supports multiple taggers
    and tag policies to tag images:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在Skaffold的**功能**部分下，Skaffold提供了内置的映像标签管理。目前，Skaffold支持多个标签器和标签策略来对映像进行标记：
- en: The `gitCommit` tagger
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gitCommit`标签器'
- en: The `inputDigest` tagger
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inputDigest`标签器'
- en: The `envTemplate` tagger
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`envTemplate`标签器'
- en: The `datetime` tagger
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`datetime`标签器'
- en: The `customTemplate` tagger
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customTemplate`标签器'
- en: The `sha256` tagger
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sha256`标签器'
- en: 'Knowing which image tag policy is supported is very easy with the IntelliJ
    Cloud Code plugin code completion feature. Let''s suppose you don''t specify the
    image tag policy in the `skaffold.yaml` file; in that case, the default policy
    is the `gitCommit` tagger:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过IntelliJ Cloud Code插件的代码完成功能，很容易知道支持哪种映像标签策略。假设您没有在`skaffold.yaml`文件中指定映像标签策略；在这种情况下，默认策略是`gitCommit`标签器：
- en: 'Take a look at the following screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下截图：
- en: '![Figure 4.5 – Skaffold''s supported image tag policies'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 – Skaffold支持的映像标签策略'
- en: '](image/Figure_4.5_B17385.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.5_B17385.jpg)'
- en: Figure 4.5 – Skaffold's supported image tag policies
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – Skaffold支持的映像标签策略
- en: Now, considering the pluggable architecture of Skaffold, you might use **Local
    Docker Daemon** for building images, `kubectl` for deployment to `minikube`, or
    any other supported local Kubernetes cluster. In this scenario, Skaffold will
    not push the image to a remote registry, and you can even skip the container structure
    tests by using the `-skipTests` flag.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑到Skaffold的可插拔架构，您可以使用**本地Docker守护程序**来构建映像，使用`kubectl`部署到`minikube`，或者任何其他支持的本地Kubernetes集群。在这种情况下，Skaffold将不会将映像推送到远程注册表，您甚至可以通过使用`-skipTests`标志跳过容器结构测试。
- en: 'The following diagram shows the tools used for local development in this scenario:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了在这种情况下用于本地开发的工具：
- en: '![Figure 4.6 – Skaffold in development'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6 – Skaffold在开发中'
- en: '](image/Figure_4.6_B17385.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.6_B17385.jpg)'
- en: Figure 4.6 – Skaffold in development
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – Skaffold在开发中
- en: While, in the case of the production scenario, you might use a Jib Maven or
    Gradle plugin to build the image, test the artifacts, push it to the remote registry,
    and, finally, deploy it to the remote Kubernetes cluster using Helm.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 而在生产场景中，您可能会使用Jib Maven或Gradle插件来构建映像，测试构件，将其推送到远程注册表，最后使用Helm将其部署到远程Kubernetes集群。
- en: 'The following diagram shows the tools used for the production scenario:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了生产场景中使用的工具：
- en: '![Figure 4.7 – Skaffold in production'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7–生产中的Skaffold'
- en: '](image/Figure_4.7_B17385.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.7_B17385.jpg)'
- en: Figure 4.7 – Skaffold in production
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7–生产中的Skaffold
- en: This completes our deep-dive analysis of the Skaffold architecture. Now, let's
    discuss the Skaffold workflow.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对Skaffold架构的深入分析。现在，让我们讨论Skaffold的工作流程。
- en: Understanding the Skaffold workflow
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Skaffold的工作流程
- en: 'Typically, Skaffold works in two modes, namely, *continuous development* or
    an *end-to-end pipeline* through commands such as `skaffold dev` and `skaffold
    run`. For example, when you run the `skaffold dev` command, the following steps
    are carried out by Skaffold:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Skaffold以两种模式工作，即*连续开发*或*端到端管道*，通过命令如`skaffold dev`和`skaffold run`。例如，当您运行`skaffold
    dev`命令时，Skaffold将执行以下步骤：
- en: Receive and watch your source code for changes.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收并监视您的源代码更改。
- en: Copy the changed files straight to `build` if the user marks them as eligible
    for copying.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户将更改的文件标记为可复制，则直接将其复制到`build`中。
- en: Build your artifacts from the source code.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从源代码构建您的构件。
- en: Test your built artifacts using `container-structure-tests` or custom scripts.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`container-structure-tests`或自定义脚本测试您构建的构件。
- en: Tag your artifacts.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的构件打标签。
- en: Push your artifacts (only if the Kubernetes context is set to a remote cluster).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推送您的构件（仅当Kubernetes上下文设置为远程集群时）。
- en: Update the Kubernetes manifests with the correct tags.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正确的标签更新Kubernetes清单。
- en: Deploy your artifacts.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署您的构件。
- en: Monitor the deployed artifacts with built-in health checks.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内置的健康检查监视部署的构件。
- en: Stream logs from the running pods.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从正在运行的pod中流式传输日志。
- en: Clean up any deployed artifacts on exit by pressing *Ctrl + C*.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按下*Ctrl + C*清除退出时部署的任何构件。
- en: 'In the case of the `skaffold run` command, the workflow is relatively similar.
    The only difference is the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`skaffold run`命令的情况下，工作流程相对类似。唯一的区别是以下内容：
- en: Skaffold will not continuously watch for code changes.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Skaffold不会持续监视代码更改。
- en: By default, Skaffold will not stream logs from the running pods.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Skaffold不会从正在运行的pod中流式传输日志。
- en: Skaffold will exit after *step 9* in the end-to-end pipeline mode.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在端到端管道模式结束后，Skaffold将在*步骤9*之后退出。
- en: 'The following diagram illustrates both the continuous development and end-to-end
    pipeline that we explained in the preceding steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了我们在前面步骤中解释的连续开发和端到端管道：
- en: '![Figure 4.8 – The Skaffold workflow'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8–Skaffold工作流程'
- en: '](image/Figure_4.8_B17385.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.8_B17385.jpg)'
- en: Figure 4.8 – The Skaffold workflow
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8–Skaffold工作流程
- en: You should now have an understanding of how Skaffold works in continuous development
    and end-to-end pipeline mode. Let's take a look at the components that are available
    in its configuration with the `skaffold.yaml` file.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该了解了Skaffold在连续开发和端到端管道模式下的工作方式。让我们看一下`skaffold.yaml`文件中可用的组件。
- en: Deciphering Skaffold's configuration with skaffold.yaml
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用skaffold.yaml解析Skaffold的配置
- en: Any action that Skaffold needs to perform should be clearly defined in the `skaffold.yaml`
    configuration file. In this configuration file, you must specify which tool Skaffold
    has to use to build an image and then deploy it to the Kubernetes cluster. Skaffold
    typically expects to find the configuration file as `skaffold.yaml` in the current
    directory; however, we can override the location using the `--filename` flag.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold需要执行的任何操作都应在`skaffold.yaml`配置文件中明确定义。在此配置文件中，您必须指定Skaffold必须使用哪个工具来构建图像，然后将其部署到Kubernetes集群。Skaffold通常期望在当前目录中找到配置文件`skaffold.yaml`；但是，我们可以使用`--filename`标志覆盖位置。
- en: Tip
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: We recommend that you keep the Skaffold configuration file in the root directory
    of the project.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您将Skaffold配置文件保存在项目的根目录中。
- en: 'The configuration file consists of the following main components:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件包括以下主要组件：
- en: '![Table 4.2 –  The skaffold.yaml file components'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![表4.2 - skaffold.yaml文件组件'
- en: '](image/Table_4.2_B17385.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '](图片/Table_4.2_B17385.jpg)'
- en: Table 4.2 –  The skaffold.yaml file components
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2 - skaffold.yaml文件组件
- en: 'Skaffold also supports a global configuration file, which is located in the
    `~/.skaffold/config` path. The following are the options it supports, which can
    be defined at the global level:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Skaffold还支持一个全局配置文件，位于`~/.skaffold/config`路径下。以下是它支持的选项，可以在全局级别定义：
- en: '![Table 4.3 – Skaffold global configuration options'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![表4.3 - Skaffold全局配置选项'
- en: '](image/Table_4.3_B17385.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](图片/Table_4.3_B17385.jpg)'
- en: Table 4.3 – Skaffold global configuration options
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.3 - Skaffold全局配置选项
- en: 'You can list, set, and unset these options in the command line easily by using
    the following commands:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令轻松在命令行中列出、设置和取消这些选项：
- en: '[PRE17]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For example, you can set the local cluster option to false. This will allow
    you to push an image to a remote registry after building the image. Please refer
    to the following commands:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以将本地集群选项设置为false。这将允许您在构建图像后将图像推送到远程注册表。请参考以下命令：
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, you can unset the configuration using the following commands:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以使用以下命令取消配置：
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this section, we covered the components of the `skaffold.yaml` configuration
    file. We also looked at some of the global configuration settings that you can
    set via the Skaffold CLI commands.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了`skaffold.yaml`配置文件的组件。我们还看了一些可以通过Skaffold CLI命令设置的全局配置设置。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced you to some of Skaffold's peculiarities, such as super-fast
    local development, effortless remote development, built-in tag management, lightweight
    capability, and file sync capability to name a few. These are compelling features
    that will help you to improve the developer experience. Additionally, we looked
    at the Skaffold architecture and discovered that Skaffold has a pluggable architecture.
    This means that you can always bring your own tools to build and deploy your applications.
    Following this, we covered the steps that typically occur within the Skaffold
    development workflow. Finally, at the end of the chapter, we studied the Skaffold
    main components and some global configurations supported via the Skaffold configuration.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了Skaffold的一些特点，例如超快速的本地开发、轻松的远程开发、内置标签管理、轻量级能力和文件同步能力等。这些是令人信服的功能，将帮助您改善开发人员体验。此外，我们还看了Skaffold的架构，并发现Skaffold具有可插拔的架构。这意味着您可以随时携带自己的工具来构建和部署应用程序。接下来，我们介绍了Skaffold开发工作流程中通常发生的步骤。最后，在本章末尾，我们研究了Skaffold的主要组件和一些通过Skaffold配置支持的全局配置。
- en: In this chapter, the main goal was to give you an insight into Skaffold's features
    and internals by looking at its architecture and typical development workflow.
    You have developed a deep understanding of Skaffold, and now it will be easier
    for you to connect the dots between the previous and upcoming chapters.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，主要目标是通过查看其架构和典型的开发工作流程，让您深入了解Skaffold的特性和内部工作原理。您已经对Skaffold有了深入的了解，现在您将更容易地连接前后章节之间的关系。
- en: In the next chapter, we will go through the different ways of installing Skaffold.
    Additionally, we will explore the Skaffold CLI commands.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍安装Skaffold的不同方法。此外，我们将探索Skaffold CLI命令。
- en: References
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考
- en: The official Skaffold documentation ([https://skaffold.dev/docs/](https://skaffold.dev/docs/))
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方Skaffold文档([https://skaffold.dev/docs/](https://skaffold.dev/docs/))
