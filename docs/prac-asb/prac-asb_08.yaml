- en: Consuming and Creating Plugins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用和创建插件
- en: Modules have been a very obvious and key part of our journey through Ansible
    so far. They are used to execute well-defined tasks and can be used either in
    one-off commands (using ad hoc commands) or as part of a much larger playbook.
    Plugins are just as important to Ansible, and we have used them in all of our
    testings so far without even realizing it! While modules are always used to create
    some kind of task in Ansible, the way that plugins are used depends on their use
    case. There are many different types of plugins; we will introduce them to you
    in this chapter and give you an idea of their purpose. But, as a taster, did you
    realize that when Ansible connects to a remote server using SSH, functionality
    is provided by a connection plugin? This demonstrates the important role that
    plugins play.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，模块一直是我们在Ansible中旅程中非常明显和关键的一部分。它们用于执行明确定义的任务，可以用于一次性命令（使用临时命令）或作为更大的playbook的一部分。插件对于Ansible同样重要，迄今为止我们一直在使用它们，甚至没有意识到！虽然模块始终用于在Ansible中创建某种任务，但插件的使用方式取决于它们的用例。有许多不同类型的插件；我们将在本章中向您介绍它们，并让您了解它们的目的。但是，作为一个引子，您是否意识到当Ansible使用SSH连接到远程服务器时，连接插件提供了功能？这展示了插件发挥的重要作用。
- en: In this chapter, we will provide you with an in-depth introduction to plugins,
    as well as show you how to explore the various plugins that come with Ansible.
    We'll then expand on this by demonstrating how you can create your own plugins
    and use them in an Ansible project, in very much the same way as we did with our
    custom module in the previous chapter. This will hopefully help you to understand
    the limitless possibilities that open source software such as Ansible provides.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为您提供对插件的深入介绍，并向您展示如何探索Ansible附带的各种插件。然后，我们将扩展这一点，演示如何创建自己的插件并在Ansible项目中使用它们，这与我们在上一章中使用自定义模块的方式非常相似。这将有助于您理解诸如Ansible等开源软件提供的无限可能性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Discovering the plugin types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现插件类型
- en: Finding the included plugins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找包含的插件
- en: Creating custom plugins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义插件
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [Chapter 1](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml), *Getting
    Started with Ansible*, and that you are using the most recent version available.
    The examples in this chapter are tested with Ansible 2.9\. This chapter also assumes
    that you have at least one additional host to test against; ideally, this should
    be Linux-based.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经按照[第1章](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml)中详细介绍的方式设置了Ansible的控制主机，并且您正在使用最新版本。本章中的示例是使用Ansible
    2.9进行测试的。本章还假设您至少有一个额外的主机进行测试；最好是基于Linux的主机。
- en: Although we will give specific examples of hostnames in this chapter, you are
    free to substitute them with your own hostname and/or IP addresses, and details
    of how to do this are provided at the appropriate places. The plugin development
    work covered in this chapter assumes the presence of a Python 2 or Python 3 development
    environment on your computer, and that you are running either Linux, FreeBSD,
    or macOS. Where additional Python modules are needed, their installation is documented.
    The task of building module documentation has some very specific requirements
    in Python 3.5 or later, so it is assumed you can install a suitable Python environment
    if you wish to attempt this.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章将给出主机名的具体示例，但您可以自由地用您自己的主机名和/或IP地址替换它们，如何做到这一点的详细信息将在适当的位置提供。本章涵盖的插件开发工作假设您的计算机上有Python
    2或Python 3开发环境，并且您正在运行Linux、FreeBSD或macOS。需要额外的Python模块时，它们的安装将有文档记录。构建模块文档的任务在Python
    3.5或更高版本中有一些非常具体的要求，因此假设您可以安装一个合适的Python环境，如果您希望尝试这样做。
- en: The code bundle for this chapter is available at [https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%206](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%206).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包可以在[https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%206](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%206)上找到。
- en: Finding included plugins
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找包含的插件
- en: As we discussed in the preceding section, plugins are not as apparent in Ansible
    as their module counterparts are, and yet we have been using them behind the scenes
    in every single Ansible command we've issued so far! Let's build on our work in
    the previous section, where we looked at the plugin documentation by looking at
    where we can find the source code for the plugins. This, in turn, will serve as
    a precursor to us building a simple plugin of our own.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中讨论的，插件在Ansible中并不像它们的模块对应物那样明显，然而迄今为止我们在每个单个Ansible命令中都在幕后使用它们！让我们在前一节的工作基础上继续，我们查看了插件文档，看看我们可以在哪里找到插件的源代码。这反过来将作为我们自己构建一个简单插件的前提。
- en: 'If you installed Ansible on a Linux system using a package manager (that is,
    via an RPM or DEB package), then the location of your plugins will depend on your
    OS. For example, on my test CentOS 7 system where I installed Ansible from the
    official RPM package, I can see the plugins installed here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Linux系统上使用软件包管理器（即通过RPM或DEB软件包）安装了Ansible，则您的插件位置将取决于您的操作系统。例如，在我安装了来自官方RPM软件包的Ansible的测试CentOS
    7系统上，我可以看到安装的插件在这里：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice how the plugins are separated into subdirectories, all named after their
    categories. If we want to look up the `paramiko_ssh` plugin that we reviewed the
    documentation of in the preceding section, we can look in the `connection/` subdirectory:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意插件是如何分成子目录的，所有子目录都以它们的类别命名。如果我们想查找我们在前一节中审查过文档的`paramiko_ssh`插件，我们可以在`connection/`子目录中查找：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, in general, I do not recommend that you edit or change the files installed
    from a package as you might all too easily overwrite them when upgrading the package.
    As one of our goals in this chapter is to write our own simple custom plugin,
    let''s look at how to find the plugins in the official Ansible source code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，总的来说，我不建议您编辑或更改从软件包安装的文件，因为在升级软件包时很容易覆盖它们。由于本章的目标之一是编写我们自己的简单自定义插件，让我们看看如何在官方Ansible源代码中找到插件：
- en: 'Clone the official Ansible repository from GitHub, as we did previously, and
    change the directory to the location of your clone:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GitHub克隆官方Ansible存储库，就像我们之前做的那样，并将目录更改为克隆的位置：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Within the official source code directory structure, you will find that the
    plugins are all contained (again, in categorized subdirectories) under `lib/ansible/plugins/`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在官方源代码目录结构中，您会发现所有插件都包含在`lib/ansible/plugins/`下（同样，以分类的子目录形式）：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can explore the connection-based plugins by looking in the `connection`
    directory:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过查看`connection`目录来探索基于连接的插件：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The exact contents of this directory will depend on the version of Ansible
    source code that you have cloned. At the time of writing, it looks as follows,
    with one Python file for each plugin (similar to how we saw one Python file for
    each module in [Chapter 5](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml),  *Consuming
    and Creating Modules*):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录的确切内容将取决于您克隆的Ansible源代码的版本。在撰写本文时，它看起来如下，每个插件都有一个Python文件（类似于我们在[第5章](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml)中看到的每个模块都有一个Python文件）：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can review the contents of each plugin to learn more about how they work,
    which is again part of the beauty of open source software:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以查看每个插件的内容，以了解它们的工作原理，这也是开源软件的美妙之处的一部分：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'An example of the beginning of this file is shown in the following code block
    to give you an idea of the kind of output you should be seeing if this command
    runs correctly:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块显示了此文件开头的示例，以便让您了解如果此命令运行正确，您应该看到的输出类型：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice the `DOCUMENTATION` block, which is very similar to what we saw when
    we were working with the module source code. If you explore the source code of
    each plugin, you will find that the structure bears some similarity to the module
    code structure. However, rather than simply taking this statement at face value,
    in the next section, let's get started with building our very own custom plugin
    to learn, through a practical example, how they are put together.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`DOCUMENTATION`块，它与我们在处理模块源代码时看到的非常相似。如果您探索每个插件的源代码，您会发现其结构与模块代码结构有些相似。但是，下一节，让我们开始构建我们自己的自定义插件，通过一个实际的例子来学习它们是如何组合在一起的，而不是简单地接受这种说法。
- en: Creating custom plugins
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义插件
- en: In this section, we will take you through a practical guide on creating your
    own plugin. The example will be, by necessity, simple. However, hopefully, it
    will serve you well in guiding you in the principles and best practices of plugin
    development and give you a solid foundation to build your own more complex plugins.
    We will even show you how to integrate these with your own playbooks and, when
    you're ready, submit them to the official Ansible project for inclusion.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将带您完成创建自己插件的实际指南。这个例子必然会很简单。但是，希望它能很好地指导您了解插件开发的原则和最佳实践，并为您构建自己更复杂的插件奠定坚实的基础。我们甚至会向您展示如何将这些与您自己的playbooks集成，并在准备就绪时将它们提交给官方Ansible项目以供包含。
- en: 'As we noted when we built our own module, Ansible is written in Python, and
    its plugins are no exception. As a result, you will need to write your plugin
    in Python; so, to get started on developing your own plugin, you will need to
    make sure you have Python and a few essential tools installed. If you already
    have Ansible running on your development machine, you probably have the required
    packages installed. However, if you are starting from scratch, you will need to
    install Python, the Python package manager (`pip`), and perhaps some other development
    packages. The exact process will vary widely between OSes, but here are some examples
    to get you started:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在构建自己的模块时所指出的，Ansible是用Python编写的，它的插件也不例外。因此，您需要用Python编写您的插件；因此，要开始开发自己的插件，您需要确保已安装Python和一些基本工具。如果您的开发机器上已经运行了Ansible，您可能已经安装了所需的软件包。但是，如果您从头开始，您需要安装Python、Python软件包管理器（`pip`）和可能一些其他开发软件包。具体的过程在不同的操作系统之间会有很大的不同，但是这里有一些示例供您参考：
- en: 'On Fedora, you can run the following command to install the required packages:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Fedora上，您可以运行以下命令来安装所需的软件包：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, on CentOS, you can run the following command to install the required
    packages:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，在CentOS上，您可以运行以下命令来安装所需的软件包：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On Ubuntu, you can run the following commands to install the packages you will
    need:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Ubuntu上，您可以运行以下命令来安装您需要的软件包：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you are working on macOS and using the Homebrew packaging system, the following
    command will install the packages you need:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在使用Homebrew包装系统的macOS，以下命令将安装您需要的软件包：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once you have installed the required packages, you will need to clone the Ansible
    Git repository to your local machine, as there are some valuable scripts in there
    that we will need later on in the module development process. Use the following
    command to clone the Ansible repository to your current directory on your development
    machine:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 安装所需的软件包后，您需要将Ansible Git存储库克隆到本地计算机，因为其中有一些有价值的脚本，我们在模块开发过程中将需要。使用以下命令将Ansible存储库克隆到开发机器上的当前目录：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With all of these prerequisites in place, let's get started with creating your
    own plugin. Although there are many similarities between coding modules and plugins,
    there are also fundamental differences. In fact, each of the different types of
    plugins that Ansible can work with is actually coded slightly differently and
    has different recommendations. Sadly, we don't have space to go through each one
    in this book, but you can find out more about the requirements for each plugin
    type from the official Ansible documentation at [https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html](https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些先决条件，让我们开始创建您自己的插件。虽然编写模块和插件之间有许多相似之处，但也有根本的不同之处。实际上，Ansible可以使用的不同类型的插件实际上是稍微不同编码的，并且有不同的建议。遗憾的是，我们在本书中没有空间来逐一介绍每一种插件，但您可以从官方Ansible文档中了解每种插件类型的要求。
- en: For our simple example, we'll create a filter plugin that replaces a given string
    with another. If you refer to the preceding documentation link, filter plugins
    are perhaps some of the easiest ones to code because there isn't a stringent requirement
    on the documentation in the same way that there is for modules. However, if we
    were to create a `lookup` plugin, we would be expected to create the same `DOCUMENTATION`,
    `EXAMPLES`, and `RETURN` documentation sections that we created in [Chapter 5](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml),
    *Consuming and Creating Modules*. We would also need to test and build our web
    documentation in the same way.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的简单示例，我们将创建一个过滤器插件，用另一个字符串替换给定的字符串。如果您参考前面的文档链接，过滤器插件可能是一些最容易编码的插件，因为与模块一样，对文档没有严格的要求。但是，如果我们要创建一个`lookup`插件，我们将期望创建与我们在[第5章](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml)中创建的`DOCUMENTATION`、`EXAMPLES`和`RETURN`文档部分相同的文档。我们还需要以相同的方式测试和构建我们的web文档。
- en: We have already covered this, so it doesn't serve to repeat the entirety of
    this process again in this chapter. Instead, we will focus on creating a filter
    plugin, first. In contrast with other Ansible plugins and modules, you can actually
    have several filters defined in a single Python plugin file. Filters are, by nature,
    quite compact to code. They are also numerous, so having one file per filter doesn't
    scale well. However, if you want to code other types of plugins (such as `lookup`
    plugins), you *will* need to create one Python file per plugin.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了这一点，因此在本章中不需要重复整个过程。相反，我们将首先专注于创建一个过滤器插件。与其他Ansible插件和模块不同，您实际上可以在单个Python插件文件中定义多个过滤器。过滤器本质上是相当紧凑的代码。它们也是众多的，因此每个过滤器一个文件的方式不太适用。但是，如果您想编写其他类型的插件（如`lookup`插件），*您将*需要为每个插件创建一个Python文件。
- en: Let's get started on creating our simple filter plugin. As we are only creating
    one, it will live in its own single Python file. You could propose a modification
    to one of the Ansible core filter Python files if you want to submit your code
    back to the Ansible project; but for now, we'll leave that as a project for you
    to complete yourself. Our filter file will be called `custom_filter.py` and it
    will live in a directory called `filter_plugins`, which must be in the same directory
    as your playbook.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建我们的简单过滤器插件。由于我们只创建一个，它将存在于自己的单独的Python文件中。如果您想将代码提交回Ansible项目，可以提出修改Ansible核心过滤器Python文件的建议；但现在，我们将把这个作为一个项目留给您自己完成。我们的过滤器文件将被称为`custom_filter.py`，它将存在于一个名为`filter_plugins`的目录中，该目录必须与您的playbook目录位于同一目录中。
- en: 'Perform the following steps to create and test your plugin code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来创建和测试您的插件代码：
- en: 'Start your plugin file with a header so that people will know who wrote the
    plugin and what license it is released under. Naturally, you should update both
    the copyright and license fields with values appropriate to your plugin, but the
    following text is given as an example for you to get started with:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在插件文件中以标题开始，以便人们知道谁编写了插件以及它发布的许可证。当然，您应该更新版权和许可字段，以适合您的插件的值，但以下文本作为一个示例供您开始使用：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we''ll add a very simple Python function—yours can be as complex as you
    want it to be, but for ours, we will simply use the Python `.replace` function
    to replace one string with another inside a `string` variable. The following example
    looks for instances of `Puppet` and replaces them with `Ansible`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个非常简单的Python函数——您的函数可以像您想要的那样复杂，但对于我们来说，我们将简单地使用Python的`.replace`函数来替换`string`变量中的一个字符串为另一个字符串。以下示例查找`Puppet`的实例，并将其替换为`Ansible`：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we need to create an object of the `FilterModule` class, which is how
    Ansible will know that this Python file contains a filter. Within this object,
    we can create a `filters` definition and return the value of our previously defined
    filter function to Ansible:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建`FilterModule`类的对象，这是Ansible将知道这个Python文件包含一个过滤器的方法。在这个对象中，我们可以创建一个`filters`定义，并将我们之前定义的过滤器函数的值返回给Ansible：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, this code is all incredibly simple and we''re able to use built-in
    Python functions, such as `replace`, to manipulate the strings. There isn''t a
    specific test harness for plugins in Ansible, so we will test out our plugin code
    by writing a simple playbook that will implement it. The following playbook code
    defines a simple string that includes the word `Puppet` in it and prints this
    to the console using the `debug` module, applying our newly defined filter to
    the string:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所看到的，这段代码非常简单，我们可以使用内置的Python函数，比如`replace`，来操作字符串。在Ansible中没有特定的插件测试工具，因此我们将通过编写一个简单的playbook来测试我们的插件代码。以下playbook代码定义了一个包含单词`Puppet`的简单字符串，并使用`debug`模块将其打印到控制台，应用我们新定义的过滤器到字符串：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, before we attempt to run this, let''s recap what the directory structure
    should look like. Just as we were able to utilize the custom module that we created
    in [Chapter 5](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml), *Consuming and Creating
    Modules*, by creating a `library/` subdirectory to house our module, we can also
    create a `filter_plugins/` subdirectory for our plugin. Your directory tree structure,
    when you have finished coding the various file details in the preceding code block,
    should look something like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们尝试运行之前，让我们回顾一下目录结构应该是什么样子的。就像我们能够利用我们在[第5章](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml)中创建的自定义模块一样，通过创建一个`library/`子目录来存放我们的模块，我们也可以为我们的插件创建一个`filter_plugins/`子目录。当你完成了前面代码块中各个文件的编码细节后，你的目录树结构应该是这样的：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s now run our little test playbook and see what output we get. If all
    goes well, it should look something like the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行一下我们的小测试playbook，看看我们得到了什么输出。如果一切顺利，它应该看起来像下面这样：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, our new filter plugin replaced the `Puppet` string in our variable's
    contents and replaced it with the `Ansible` string. This, of course, is just a
    silly test and not one you are likely to contribute back to the Ansible project.
    However, it shows how, in just six lines of code and with a modicum of Python
    knowledge, we have created our own filter plugin to manipulate a string. You could
    come up with something far more complex and useful, I'm sure!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的新过滤器插件将我们变量的内容中的`Puppet`字符串替换为`Ansible`字符串。当然，这只是一个愚蠢的测试，不太可能被贡献回Ansible项目。然而，它展示了如何在只有六行代码和一点点Python知识的情况下，我们创建了自己的过滤器插件来操作一个字符串。我相信你可以想出更复杂和有用的东西！
- en: 'Other plugin types require more effort than this; although we won''t go through
    the process of creating a filter plugin here, you''ll find coding a filter plugin
    more akin to coding a module, as you need to do the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 其他插件类型需要比这更多的工作；虽然我们不会在这里详细介绍创建过滤器插件的过程，但你会发现编写过滤器插件更类似于编写模块，因为你需要做以下工作：
- en: Include the `DOCUMENTATION`, `EXAMPLES`, and `RETURN` sections with the appropriate
    documentation.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括`DOCUMENTATION`、`EXAMPLES`和`RETURN`部分的适当文档。
- en: Ensure you have incorporated appropriate and sufficient error handling in the
    plugin.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你在插件中加入了适当和充分的错误处理。
- en: Test it thoroughly, including both the failure and success cases.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 彻底测试它，包括失败和成功的情况。
- en: 'As an example of this, let''s repeat the preceding process, but to create a
    `lookup` plugin, instead. This plugin will be based heavily on a simplified version
    of the file `lookup` plugin. However, we want to adapt our version to return only
    the first character of a file. You could adapt this example to perhaps read the
    header from a file, or you could add arguments to the plugin to allow you to extract
    a substring using character indexes. We will leave this enhancement activity as
    an exercise for you to carry out yourself. Let''s get started! Our new lookup
    plugin will be called `firstchar`, and as `lookup` plugins have a one-to-one mapping
    with their Python files, the plugin file will be called `firstchar.py`. (In fact,
    Ansible will use this filename as the name of the plugin—you won''t find a reference
    to it in the code anywhere!). If you intend to test this from a playbook, as executed
    previously, you should create this in a directory called `lookup_plugins/`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们重复前面的过程，但是创建一个`lookup`插件。这个插件将基于一个简化版本的`lookup`插件文件。然而，我们希望调整我们的版本，只返回文件的第一个字符。你可以根据需要调整这个示例，也许从文件中读取头文件，或者你可以添加参数到插件中，允许你使用字符索引提取子字符串。我们将把这个增强活动留给你自己去完成。让我们开始吧！我们的新lookup插件将被称为`firstchar`，而`lookup`插件与它们的Python文件是一对一的映射，插件文件将被称为`firstchar.py`。（事实上，Ansible将使用这个文件名作为插件的名称——你在代码中找不到对它的引用！）。如果你打算像之前执行的那样从playbook中测试这个插件，你应该在一个名为`lookup_plugins/`的目录中创建它：
- en: 'Start by adding a header to the plugin file, as before, so that the maintainer
    and copyright details are clear. We are borrowing a large chunk of the original
    `file.py` `lookup` plugin code for our example, so it is important we include
    the relevant credit:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，像之前一样在插件文件中添加一个头部，以便维护者和版权细节清晰可见。我们从原始的`file.py` `lookup`插件代码中借用了大部分内容，因此我们需要包含相关的来源信息：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, add in the Python 3 headers—these are an absolute requirement if you
    intend to submit your plugin via a **Pull Request** (**PR**) to the Ansible project:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加Python 3的头文件——如果你打算通过**Pull Request**（**PR**）提交你的插件到Ansible项目，这是绝对必需的。
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, add a `DOCUMENTATION` block to your plugin so that other users can understand
    how to interact with it:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在你的插件中添加一个`DOCUMENTATION`块，以便其他用户能够理解如何与它交互：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the relevant `EXAMPLES` blocks to show how to use your plugin, just as
    we did for modules:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加相关的`EXAMPLES`块，展示如何使用你的插件，就像我们为模块做的那样：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Also, make sure you document the `RETURN` values from your plugin:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要确保你记录了插件的`RETURN`值：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With the documentation complete, we can now start to work on our Python code.
    We will start by importing all the Python modules we need to make our module work.
    We''ll also set up the `display` object, which is used in verbose output and debugging.
    This should be used in place of the `print` statements in your plugin code if
    you need to display the `debug` output:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档完成后，我们现在可以开始编写我们的Python代码了。我们将首先导入所有需要使我们的模块工作的Python模块。我们还将设置`display`对象，它用于详细输出和调试。如果你需要显示`debug`输出，应该在插件代码中使用这个对象，而不是`print`语句：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will now create an object of the `LookupModule` class. Define a default
    function within this called `run` (this is expected for the Ansible `lookup` plugin
    framework) and initialize an empty array for our return data:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建一个`LookupModule`类的对象。在其中定义一个名为`run`的默认函数（这是Ansible `lookup`插件框架所期望的），并初始化一个空数组作为我们的返回数据：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With this in place, we will start a loop to iterate over each of the terms
    (which, in our simple plugin, will be the filenames passed to the plugin). Although
    we will only test this on simple use cases, the way that lookup plugins can be
    used means that they need to support the lists of `terms` to operate on. Within
    this loop, we display valuable debugging information and, most importantly, define
    an object with the details of each of the files we will open, called `lookupfile`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个，我们将开始一个循环，遍历每个术语（在我们的简单插件中，这将是传递给插件的文件名）。虽然我们只会在简单的用例上测试这个，但查找插件的使用方式意味着它们需要支持操作的`terms`列表。在这个循环中，我们显示有价值的调试信息，并且最重要的是，定义一个包含我们将要打开的每个文件的详细信息的对象，称为`lookupfile`：
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we will read in the file contents. This could be as simple as using one
    line of Python code, but we know from our work on modules in [Chapter 5](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml),
    *Consuming and Creating Modules*, that we should not take it for granted that
    we will be passed a file we can actually read. As a result, we will put the statement
    to read our file contents into a `try` block and implement exception handling
    to ensure that the behavior of the plugin is sensible, even in error cases, and
    that easy-to-understand error messages are passed back to the user, rather than
    to Python tracebacks:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将读取文件内容。这可能只需要一行Python代码，但我们从[第5章](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml)中对模块的工作中知道，我们不应该认为我们会得到一个实际可以读取的文件。因此，我们将把读取文件内容的语句放入一个`try`块中，并实现异常处理，以确保插件的行为是合理的，即使在错误情况下，也能传递易于理解的错误消息给用户，而不是Python的回溯信息：
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that within this, we append the first character of the file contents
    (denoted by the `[0]` index) to our empty array. We also remove any training spaces
    using `rstrip`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在其中，我们将文件内容的第一个字符（用`[0]`索引表示）附加到我们的空数组中。我们还使用`rstrip`删除任何尾随空格。
- en: 'Finally, we return the character we gathered from the file to Ansible with
    a `return` statement:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`return`语句将从文件中收集到的字符返回给Ansible：
- en: '[PRE28]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once again, we can create a simple test playbook to test out our newly created
    plugin:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们可以创建一个简单的测试playbook来测试我们新创建的插件：
- en: '[PRE29]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Again, we are using the debug module to print output to the console and referencing
    our `lookup` plugin to obtain the output.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用debug模块将输出打印到控制台，并引用我们的`lookup`插件来获取输出。
- en: 'Create the text file referenced in the previous code block, called `testdoc.txt`.
    This can contain anything you like—mine contains the following simple text:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建前面代码块中提到的文本文件，名为`testdoc.txt`。它可以包含任何你喜欢的内容——我的包含以下简单文本：
- en: '[PRE30]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For clarity, your final directory structure should look as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，你的最终目录结构应该如下所示：
- en: '[PRE31]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, when we run our new playbook, we should see an output similar to the following:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们运行我们的新playbook时，我们应该看到类似以下的输出：
- en: '[PRE32]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If all goes well, your playbook should return the first character of the text
    file you created. Naturally, there is a lot we could do to enhance this code,
    but this serves as a nice, simple example to get you started.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你的playbook应该返回你创建的文本文件的第一个字符。当然，我们可以做很多事情来增强这段代码，但这是一个很好的简单示例，可以让你开始。
- en: With this foundation in place, you should now have a reasonable idea of how
    to get started with writing your own plugins for Ansible. The next logical step
    for us is to look in greater depth at how we can test our newly written plugins,
    which we will do in the next section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个基础，你现在应该对如何开始编写自己的Ansible插件有一个合理的想法。我们下一个逻辑步骤是更深入地了解如何测试我们新编写的插件，我们将在下一节中进行。
- en: Learning to integrate custom plugins with Ansible source code
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习将自定义插件与Ansible源代码集成
- en: So far, we have only tested our plugin in a standalone manner. This is all well
    and good, but what if you actually wanted to add it either to your own fork of
    the Ansible source code—or, better yet, submit it back to the Ansible project
    for inclusion with a PR? Fortunately, this process is very similar to the one
    we covered in [Chapter 5](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml), *Consuming
    and Creating Modules*, only with slightly different folder structures.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是以独立的方式测试了我们的插件。这一切都很好，但如果你真的想要将它添加到你自己的Ansible源代码分支，或者更好的是，提交给Ansible项目以便包含在PR中，那该怎么办呢？幸运的是，这个过程与我们在[第5章](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml)中介绍的非常相似，只是文件夹结构略有不同。
- en: 'As before, your first task will be to obtain a copy of the official Ansible
    project source code—for example, by cloning the GitHub repository to your local
    machine:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，你的第一个任务将是获取官方Ansible项目源代码的副本——例如，通过将GitHub存储库克隆到你的本地机器上：
- en: '[PRE33]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, you will need to copy your plugin code into one of the appropriate plugin
    directories.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要将你的插件代码复制到一个适当的插件目录中。
- en: 'For example, our example filter would be copied to the following directory
    in the source code you just cloned:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，我们的示例过滤器将被复制到你刚刚克隆的源代码中的以下目录中：
- en: '[PRE34]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Similarly, our custom `lookup` plugin would go in the `lookup` plugin''s directory,
    using a command such as the following:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们的自定义`lookup`插件将放在`lookup`插件的目录中，使用如下命令：
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With your code copied into place, you need to test the documentation (that
    is, whether your plugin includes it) as before. You can build the `webdocs` documentation
    in exactly the same way as we did in [Chapter 5](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml),
    *Consuming and Creating Modules*, so we will not recap this here. However, as
    a refresher, we can quickly check whether the documentation renders correctly
    using the `ansible-doc` command, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码复制到位后，你需要像以前一样测试文档（即你的插件是否包含它）。你可以像我们在[第5章](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml)中那样构建`webdocs`文档，所以我们不会在这里重复。不过，作为一个提醒，我们可以快速检查文档是否正确渲染，使用`ansible-doc`命令，如下所示：
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you have seen so far, there is a great deal of overlap between plugin development
    and module development in Ansible. It is especially important to pay attention
    to error handling with exceptions to produce good quality, easy-to-understand
    error messages and to adhere to and uphold Ansible's high documentation standards.
    One additional item that we have not covered here is the plugin output. All plugins
    must return strings in Unicode; this ensures that they can run through the `jinja2`
    filters correctly. Further guidance can be found in the official Ansible documentation
    at [https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html](https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到在Ansible中插件开发和模块开发之间有很多重叠。特别重要的是要注意异常处理和生成高质量、易于理解的错误消息，并遵守和维护Ansible的高标准文档。我们在这里没有涵盖的一个额外的项目是插件输出。所有插件必须返回Unicode字符串；这确保它们可以正确通过`jinja2`过滤器运行。更多指导信息可以在官方Ansible文档中找到：[https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html](https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html)。
- en: Armed with this knowledge, you should now be well placed to begin your own plugin
    development work, and even to submit your code back to the community, if you desire.
    We'll offer a brief recap of this in the next section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，现在您应该可以开始自己的插件开发工作，甚至可以将您的代码提交回社区，如果您愿意的话。我们将在下一节简要回顾一下这一点。
- en: Sharing plugins with the community
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与社区分享插件
- en: You may wish to submit your new plugin to the Ansible project, just as we considered
    for our custom modules in [Chapter 5](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml),
    *Consuming and Creating Modules*. The process for doing this with plugins is almost
    identical to what you do for modules, which this section will recap.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望将您的新插件提交到Ansible项目，就像我们在[第5章](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml)中考虑我们的自定义模块一样，*使用和创建模块*。这个过程与模块的过程几乎完全相同，这一部分将对此进行回顾。
- en: Using the following process will submit a real request to the Ansible project
    on GitHub to merge the code you submit with their code. Do *not* follow this process
    unless you genuinely have a new module that is ready for submission to the Ansible
    codebase.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下流程将向GitHub上的Ansible项目提交一个真实的请求，将您提交的代码与他们的代码合并。除非您真的有一个准备提交到Ansible代码库的新模块，否则*不要*按照这个流程进行。
- en: 'In order to submit your plugin as a PR of the Ansible repository, you first
    need to fork the `devel` branch of the official Ansible repository. To do this,
    log into your GitHub account on your web browser (or create an account if you
    don''t already have one), and then navigate to [https://github.com/ansible/ansible.git](https://github.com/ansible/ansible.git).
    Click on Fork at the top-right corner of the page:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将您的插件作为Ansible存储库的PR提交，您首先需要fork官方Ansible存储库的`devel`分支。要做到这一点，在您的网络浏览器上登录GitHub账户（或者如果您还没有账户，创建一个），然后导航到[https://github.com/ansible/ansible.git](https://github.com/ansible/ansible.git)。点击页面右上角的Fork：
- en: '![](Images/e7b8c847-4112-4e50-bc4e-3fb49b62e8ef.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e7b8c847-4112-4e50-bc4e-3fb49b62e8ef.png)'
- en: 'Once you have forked the repository to your own account, we will walk you through
    the commands you need to run to add your module code to it and then to create
    the required PRs in order to merge your new module with the upstream Ansible project:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将存储库fork到您自己的账户，我们将指导您运行所需的命令，将您的模块代码添加到其中，然后创建必需的PRs，以便将您的新模块与上游Ansible项目合并：
- en: 'Clone the `devel` branch that you just forked to your local machine. Use a
    command similar to the following, but be sure to replace the URL with one that
    matches your own GitHub account:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆您刚刚fork到本地计算机的`devel`分支。使用类似以下命令的命令，但一定要用符合您自己GitHub账户的URL替换它：
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Copy your module code into the appropriate `plugins/` directory. The `copy`
    command used in the following code block is just an example to give you an idea
    as to what to do—in reality, you should choose the appropriate category subdirectory
    for your plugin as it won''t necessarily fit into the `lookup` category. Once
    you''ve added your Python file, perform a `git add` command to make Git aware
    of the new file, and then commit it with a meaningful `commit` message. Some example
    commands are shown here:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的模块代码复制到适当的`plugins/`目录中。以下代码块中使用的`copy`命令只是一个示例，让您了解要做什么——实际上，您应该选择适当的类别子目录来放置您的插件，因为它不一定适合`lookup`类别。一旦您添加了Python文件，执行`git
    add`命令使Git知道新文件，然后用有意义的`commit`消息提交它。这里显示了一些示例命令：
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, be sure to push the code to your forked repository using the following
    command:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，请确保使用以下命令将代码推送到您fork的存储库：
- en: '[PRE39]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Return to GitHub in your web browser and navigate to the Pull Requests page,
    as in the following screenshot. Click on the New pull request button:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中返回GitHub，并导航到Pull Requests页面，如下面的屏幕截图所示。点击New pull request按钮：
- en: '![](Images/25997bfa-230e-4627-9bef-042c675fb503.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/25997bfa-230e-4627-9bef-042c675fb503.png)'
- en: 'Follow the PR creation process, as guided by the GitHub website. Once you have
    successfully submitted your PR, you should be able to navigate to the list of
    PRs on the official Ansible source code repository and find yours there. An example
    of the PR list is shown in the following screenshot for your reference:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 按照GitHub网站的指导，完成PR创建过程。一旦您成功提交了您的PR，您应该能够导航到官方Ansible源代码存储库的PR列表，并在那里找到您的PR。以下是一个PR列表的示例截图，供您参考：
- en: '![](Images/c2be2eb5-8243-4e21-8d26-96e2769181b6.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c2be2eb5-8243-4e21-8d26-96e2769181b6.png)'
- en: As discussed previously, don't be alarmed if it takes a long time for your PR
    to be reviewed—this is simply due to how many PRs there are to review and process.
    You can always use your plugin code locally by adding it to a local `*_plugins/` directory,
    as we demonstrated earlier, so that the processing speed of your PR doesn't hinder
    your work with Ansible. Further details of where to place your plugin code when
    working locally can be found at [https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.html](https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.html).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果您的PR需要很长时间才能得到审查，不要感到惊慌 - 这仅仅是因为有很多PR需要审查和处理。您始终可以通过将插件代码添加到本地`*_plugins/`目录中来在本地使用您的插件代码，就像我们之前演示的那样，这样您的PR的处理速度不会妨碍您使用Ansible。有关在本地工作时放置插件代码的更多详细信息，请参阅[https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.html](https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.html)。
- en: That completes our look at the creation of plugins, including two working examples.
    Hopefully, you have found this journey informative and valuable and it has enhanced
    your ability to work with Ansible and extend its functionality where required.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了对插件创建的探讨，包括两个可工作的示例。希望您发现这段旅程是有益和有价值的，并且增强了您使用Ansible并在需要时扩展其功能的能力。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Ansible plugins are a core part of Ansible's functionality and we discovered,
    in this chapter, that we have been working with them throughout this book without
    even realizing it! Ansible's modular design makes it easy to extend and add functionality
    to, regardless of whether you are working with modules or the various types of
    plugins that are currently supported. Whether it's to add a new filter for string
    processing or a new way of looking up data (or perhaps even a new connection mechanism
    to new technology), Ansible plugins provide a complete framework that can extend
    Ansible far beyond its already extensive capabilities.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible插件是Ansible功能的核心部分，在本章中，我们发现在整本书中一直在使用它们，甚至没有意识到！Ansible的模块化设计使得无论您是使用模块还是当前支持的各种类型的插件，都可以轻松扩展和添加功能。无论是添加用于字符串处理的新过滤器，还是查找数据的新方法（或者甚至是连接到新技术的新连接机制），Ansible插件提供了一个完整的框架，可以将Ansible的功能远远扩展到其已经广泛的能力之外。
- en: In this chapter, we learned about the various types of plugins that are supported
    by Ansible, before exploring them in greater detail and looking at how you can
    obtain documentation and information on the existing ones. We then completed two
    practical examples to create two different types of plugin for Ansible while looking
    at the best practices for plugin development and how this overlaps with module
    development. We finished off by recapping how to submit our new plugin code as
    a PR back to the Ansible project.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Ansible支持的各种类型的插件，然后更详细地探讨了它们，并了解了如何获取现有插件的文档和信息。然后，我们完成了两个实际示例，为Ansible创建了两种不同类型的插件，同时探讨了插件开发的最佳实践以及这如何与模块开发重叠。最后，我们回顾了如何将我们的新插件代码作为PR提交回Ansible项目。
- en: In the next chapter, we will explore the best practices that you should adhere
    to when writing your Ansible playbooks to ensure that you produce manageable,
    high-quality automation code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨编写Ansible playbook时应遵循的最佳实践，以确保您生成可管理、高质量的自动化代码。
- en: Questions
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the following `ansible-doc` commands can you use to list the names
    of all the cache plugins?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下哪个`ansible-doc`命令来列出所有缓存插件的名称？
- en: A) `ansible-doc -a cache -l`
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: A) `ansible-doc -a cache -l`
- en: B) `ansible-doc cache -l`
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: B) `ansible-doc cache -l`
- en: C) `ansible-doc -a cache`
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: C) `ansible-doc -a cache`
- en: D) `ansible-doc -t cache -l`
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: D) `ansible-doc -t cache -l`
- en: E) `ansible-doc cache`
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: E) `ansible-doc cache`
- en: Which class do you need to add to your `lookup` plugin's code to include the
    bulk of the plugin code, including `run()`, the `items` loop, `try`, and `except`?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要将哪个类添加到您的`lookup`插件代码中，以包括大部分插件代码，包括`run()`、`items`循环、`try`和`except`？
- en: A) `LookupModule`
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: A) `LookupModule`
- en: B) `RunModule`
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: B) `RunModule`
- en: C) `StartModule`
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: C) `StartModule`
- en: D) `InitModule`
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: D) `InitModule`
- en: E) `LoadModule`
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: E) `LoadModule`
- en: 'True or false – in order to create custom plugins using Python, you need to
    install Python with the relevant dependencies on your OS:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假 - 为了使用Python创建自定义插件，您需要在您的操作系统上安装带有相关依赖项的Python：
- en: A) True
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: A) True
- en: B) False
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: B) False
- en: Further reading
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: You can find all of the plugins on Ansible by accessing the Ansible repository
    directly at [https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过直接访问Ansible存储库来找到所有插件，网址为[https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins](https://github.com/ansible/ansible/tree/devel/lib/ansible/plugins)。
