- en: Network Automation with Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible进行网络自动化
- en: Years ago, the standard practice was to configure every single network device
    by hand. This was possible mainly because the routers and switches were routing
    the traffic of physical servers, so not much configuration was needed on each
    networking device, and changes were slow-paced. In addition, humans were the only
    ones to have enough information on machines to set up networking. Everything was
    very manual in terms of both planning and execution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，标准做法是手动配置每个网络设备。这主要是因为路由器和交换机主要是路由物理服务器的流量，因此每个网络设备上不需要太多的配置，而且变化缓慢。此外，只有人类才有足够的信息来设置网络。无论是规划还是执行，一切都非常手动。
- en: Virtualization changed this paradigm, as it has resulted in thousands of machines
    being connected to the same switch or router, each with potentially different
    networking requirements. Changes are fast-paced and expected frequently, and with
    virtual infrastructures defined in code, it becomes a full-time job for a human
    administrator to just keep up with the changes to the infrastructure. Virtualization
    orchestration platforms have far better knowledge of the machine's location, and
    can even generate an inventory for us, as we saw in earlier chapters. Practically
    speaking, there is no way a human being can memorize or manage a modern, large-scale,
    virtualized infrastructure. As a result, it becomes clear that automation is a
    requirement when it comes to configuring the network infrastructure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化改变了这种范式，因为它导致了数千台机器连接到同一交换机或路由器，每台机器可能具有不同的网络需求。变化快速且频繁预期，并且随着虚拟基础架构的代码定义，人类管理员只需跟上基础设施的变化就成了全职工作。虚拟化编排平台对机器位置有更好的了解，甚至可以为我们生成清单，正如我们在前几章中看到的。实际上，没有办法让一个人类记住或管理现代大规模虚拟化基础设施。因此，很明显，自动化在配置网络基础设施时是必需的。
- en: 'We will learn more about this, and what we can do to automate our network,
    in this chapter by covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中学习更多关于这一点，以及我们可以做些什么来自动化我们的网络，内容包括以下主题：
- en: Why automate network management?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么要自动化网络管理？
- en: How Ansible manages networking devices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible如何管理网络设备
- en: How to enable network automation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何启用网络自动化
- en: The available Ansible networking modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的Ansible网络模块
- en: Connecting to network devices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到网络设备
- en: Environment variables for network devices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络设备的环境变量
- en: Custom conditional statements for networking devices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络设备的自定义条件语句
- en: Let's get started!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [Chapter 1](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml), *Getting
    Started with Ansible*, and are using the most recent version available – the examples
    in this chapter were tested with Ansible 2.9\. This chapter also assumes that
    you have at least one additional host to test against, and ideally, this should
    be Linux-based. Since this chapter is network device-centric, we understand that
    not everyone will have access to specific networking equipment to test on (for
    example, Cisco switches). Where examples are given and you have access to such
    devices, please feel free to explore the examples. However, if you do not have
    access to any network hardware, we will give an example using the freely available
    Cumulus VX, which offers a fully-featured demo of Cumulus Networks' switching
    environment. Although we will give specific examples of hostnames in this chapter,
    you are free to substitute them with your own hostname and/or IP addresses. Details
    of how to do this will be provided in the appropriate places.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假定您已经按照[第1章](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml) *开始使用Ansible*中详细介绍的方式设置了控制主机，并且正在使用最新版本——本章的示例是使用Ansible
    2.9进行测试的。本章还假定您至少有一个额外的主机进行测试，并且最好是基于Linux的。由于本章以网络设备为中心，我们理解并不是每个人都能够访问特定的网络设备进行测试（例如Cisco交换机）。在给出示例并且您可以访问这些设备的情况下，请随时探索这些示例。但是，如果您无法访问任何网络硬件，我们将使用免费提供的Cumulus
    VX进行示例演示，该软件提供了Cumulus Networks的交换环境的完整演示。尽管本章将给出特定主机名的示例，但您可以自由地用自己的主机名和/或IP地址替换它们。如何进行替换将在适当的位置提供详细信息。
- en: The code bundle for this chapter is available here: [https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%209](https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%209).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包在此处可用：[https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%209](https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%209)。
- en: Why automate network management?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要自动化网络管理？
- en: The way that we design data centers has radically changed in the last 30 years.
    In the 90s, a typical data center was full of physical machines, each with a very
    specific purpose. In many companies, the servers were bought by different vendors
    based on the purpose of the machine. This meant that there was a need for machines,
    network devices, and storage devices and that those devices were bought, provisioned,
    configured, and delivered.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的30年里，我们设计数据中心的方式发生了根本性的变化。在90年代，典型的数据中心充满了具有非常特定目的的物理机器。在许多公司，服务器是根据机器的用途由不同的供应商购买的。这意味着需要机器、网络设备和存储设备，并且这些设备被购买、配置和交付。
- en: The big drawback here was the significant lag between identifying the need for
    the machine and its delivery. In that period, this was acceptable, since the majority
    of companies had very few systems and they tended to change very rarely. Also,
    this approach was very expensive as a lot of devices were under-utilized.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个重大缺点是在确定需要机器和交付之间存在显著的滞后。在那段时间里，这是可以接受的，因为大多数公司的系统非常少，它们很少改变。此外，这种方法非常昂贵，因为许多设备被低效利用。
- en: 'With the progress of society and companies in the world of technology, we know
    that today, it has become important for companies to cut their infrastructure
    deployment time and costs. This opened the road for a new idea: virtualization.
    By creating a virtualization cluster, you do not need to have physical hosts that
    are of the correct size, so you can provision a number of them up front, add them
    to a resource pool, and then create the right-sized machines in your virtualization
    platform. This means that when a new machine is needed, you can create it with
    a few clicks and it will be ready in seconds.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 随着社会和科技公司的进步，我们知道今天，对于公司来说削减基础设施部署时间和成本变得非常重要。这为一个新的想法打开了道路：虚拟化。通过创建一个虚拟化集群，您不需要拥有正确尺寸的物理主机，因此您可以预先配置一些主机，将它们添加到资源池中，然后在虚拟化平台中创建合适尺寸的机器。这意味着当需要新的机器时，您可以通过几次点击创建它，并且几秒钟内就可以准备好。
- en: This shift also allowed enterprises to move from a per-project infrastructure,
    with each project being deployed with its own unique data center requirements,
    to one large central infrastructure that can have its behavior defined by software
    and configuration. This means that one single network infrastructure can support
    all projects, regardless of their scale. We call this a virtual data center infrastructure,
    and in this infrastructure, we try to make use of generic design patters as much
    as possible. This allows enterprises to deploy, switch, and serve infrastructure
    at a large scale to enable a multitude of projects so that they can be successfully
    implemented by simply subdividing them (for example, by creating virtual servers).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转变还使企业能够从每个项目都部署具有独特数据中心要求的基础设施转变为一个可以由软件和配置定义行为的大型中央基础设施。这意味着一个单一的网络基础设施可以支持所有项目，而不管它们的规模如何。我们称之为虚拟数据中心基础设施，在这种基础设施中，我们尽可能地利用通用设计模式。这使得企业能够以大规模部署、切换和提供基础设施，以便通过简单地对其进行细分（例如创建虚拟服务器）来成功实施多种项目。
- en: Another big advantage that virtualization brought is the decoupling of workloads
    and physical hosts. Historically, since a workload was tied to a physical host,
    if the host died, the workload itself died, if not properly replicated on different
    hardware. Virtualization solved this problem since the workload is now tied to
    one or more virtual hosts, but those can be moved freely from a physical host
    to another one.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化带来的另一个重大优势是工作负载和物理主机的解耦。从历史上看，由于工作负载与物理主机绑定，如果主机死机，工作负载本身也会死机，除非在不同硬件上进行适当复制。虚拟化解决了这个问题，因为工作负载现在与一个或多个虚拟主机绑定，但这些虚拟主机可以自由地从一个物理主机移动到另一个物理主机。
- en: This ability to provision machines quickly and the ability of such machines
    to move from one host to another created an issue with networking configuration
    management. Before, it was acceptable for a human to tweak the configuration details
    while installing the new machine, but now, machines move from one host to another
    (and therefore from one physical switch port to another) without any human intervention.
    This means that the system needed to update network configurations as well.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 快速配置机器的能力以及这些机器能够从一个主机移动到另一个主机的能力，导致了网络配置管理的问题。以前，人为地在安装新机器时调整配置细节是可以接受的，但现在，机器在主机之间移动（因此从一个物理交换机端口移动到另一个端口）而不需要任何人为干预。这意味着系统也需要更新网络配置。
- en: In the same time period, VLANs affirmed their presence in networking, which
    allowed the utilization of network devices to be dramatically improved, and therefore
    optimize their costs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，VLAN在网络中占据了一席之地，这使得网络设备的利用得到了显著改善，从而优化了它们的成本。
- en: Today, we work at an even larger scale, where virtual objects (machines, containers,
    functions, and so on) move in our data centers, fully managed by software systems,
    and where humans are less and less involved in the process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们在更大的规模上工作，虚拟对象（机器、容器、函数等）在我们的数据中心中移动，完全由软件系统管理，人类参与的越来越少。
- en: In this kind of environment, automating networking is a key part of their success.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种环境中，自动化网络是他们成功的关键部分。
- en: Today, there are some companies (the famous "cloud providers") that work at
    a scale where manual network management is not only impracticable but impossible,
    even when employing huge teams of network engineers. On the other hand, there
    are many environments where it would be technically possible to manage network
    configurations (at least partially) manually, but it's still impractical.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，有一些公司（著名的“云服务提供商”）在一个规模上工作，手动网络管理不仅不切实际，而且即使雇佣了大量网络工程师团队，也是不可能的。另一方面，有许多环境在技术上可能（至少部分地）手动管理网络配置，但仍然不切实际。
- en: Aside from the time required to configure a network device, the biggest advantage
    – from my perspective – of network automation is the opportunity to drastically
    reduce human errors. If a human has to configure a VLAN on 100 devices, chances
    are, they are going to make a few errors in the process. This is absolutely normal,
    but still problematic since those configurations will need to be fully tested
    and amended. Often, the problem doesn't stop here, because when a device breaks
    and therefore needs to be replaced, a human has to configure the new device in
    the same way the old one was configured. Often – over time – the configurations
    change and – very often – there is no clear way to trace this, so while replacing a
    faulty network device, there might be problems for some rules that were present
    in the previous device but are not present in the new one.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配置网络设备所需的时间之外，网络自动化最大的优势（从我的角度来看）是大大减少人为错误的机会。如果一个人必须在100台设备上配置VLAN，很可能在这个过程中会出现一些错误。这是绝对正常的，但仍然是有问题的，因为这些配置将需要进行全面测试和修改。通常情况下，问题并不会止步于此，因为当设备损坏并因此需要更换时，人们必须以与旧设备相同的方式配置新设备。通常情况下，随着时间的推移，配置会发生变化，而且很多时候没有明确的方法来追踪这一点，因此在更换有故障的网络设备时，可能会出现一些在旧设备中存在但在新设备中不存在的规则问题。
- en: Now that we have discussed the need to automate network management, let's look
    at how to manage networking devices with Ansible.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了自动化网络管理的必要性，让我们看看如何使用Ansible管理网络设备。
- en: Learning how Ansible manages networking devices
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Ansible如何管理网络设备
- en: Ansible allows you to manage many different networking devices, including Arista
    EOS, Cisco ASA, Cisco IOS, Cisco IOS XR, Cisco NX-OS, Dell OS 6, Dell OS 9, Dell
    OS 10, Extreme EXOS, Extreme IronWare, Extreme NOS, Extreme SLX-OS, Extreme VOSS,
    F5 BIG-IP, F5 BIG-IQ, Junos OS, Lenovo CNOS, Lenovo ENOS, MikroTik RouterOS, Nokia
    SR OS, Pluribus Netvisor, VyOS, and OS, which supports NETCONF. As you can imagine,
    there are various ways we can make Ansible communicate with them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible允许您管理许多不同的网络设备，包括Arista EOS、Cisco ASA、Cisco IOS、Cisco IOS XR、Cisco NX-OS、Dell
    OS 6、Dell OS 9、Dell OS 10、Extreme EXOS、Extreme IronWare、Extreme NOS、Extreme SLX-OS、Extreme
    VOSS、F5 BIG-IP、F5 BIG-IQ、Junos OS、Lenovo CNOS、Lenovo ENOS、MikroTik RouterOS、Nokia
    SR OS、Pluribus Netvisor、VyOS和支持NETCONF的OS。正如您可以想象的那样，我们可以通过各种方式让Ansible与它们进行通信。
- en: Also, we have to remember that Ansible networking modules run on the controller
    host (the one where you issued the `ansible` command), while usually, the Ansible
    modules run on the target host. This difference is important because it allows
    Ansible to use different connection mechanisms based on the target device type.
    Remember that even when you have a host that has SSH management capabilities (which
    many switches have), Ansible, by very virtue of running its modules on the target
    host, needs the target host to have Python installed. Most switches (and embedded
    hardware) lack Python environments, and so we must make use of other connection
    protocols. The key ones supported by Ansible for network device management are
    given here.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们必须记住，Ansible网络模块在控制器主机上运行（即您发出`ansible`命令的主机），而通常，Ansible模块在目标主机上运行。这种差异很重要，因为它允许Ansible根据目标设备类型使用不同的连接机制。请记住，即使您的主机具有SSH管理功能（许多交换机都有），由于Ansible在目标主机上运行其模块，因此需要目标主机安装Python。大多数交换机（和嵌入式硬件）缺乏Python环境，因此我们必须使用其他连接协议。Ansible支持的用于网络设备管理的关键协议在此处给出。
- en: 'There are five main connection types that Ansible uses for connecting to those
    network devices, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible使用以下五种主要连接类型连接这些网络设备：
- en: '`network_cli`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`network_cli`'
- en: '`netconf`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`netconf`'
- en: '`httpapi`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httpapi`'
- en: '`local`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local`'
- en: '`ssh`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh`'
- en: 'When you create a connection with your networking device, you need to choose
    the connection mechanism based on the ones supported by your devices and your
    needs:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当您与网络设备建立连接时，您需要根据设备支持的连接机制和您的需求选择连接机制：
- en: '`network_cli` is supported by the majority of modules and it is the most similar
    to the way Ansible usually works with the non-networking modules. This mode uses
    a CLI via SSH. This protocol creates a persistent connection at the beginning
    of the configuration and keeps it alive for the whole duration of the task so
    that you don''t have to provide credentials for every subsequent task.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`network_cli` 得到大多数模块的支持，它与Ansible通常使用非网络模块的方式最相似。这种模式通过SSH使用CLI。该协议在配置开始时创建持久连接，并在整个任务的持续时间内保持连接，因此您不必为每个后续任务提供凭据。'
- en: '`netconf` is supported by very few modules (at the time of writing, these modules
    are just OSes that support NETCONF and Junos OS). This mode uses XML via SSH,
    so basically, it applies XML-based configurations to the device. This protocol
    creates a persistent connection at the beginning of the configuration and keeps
    it alive for the whole duration of the task so that you don''t have to provide
    credentials for every subsequent task.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`netconf` 受到很少模块的支持（在撰写本文时，这些模块只是支持NETCONF和Junos OS的操作系统）。这种模式通过SSH使用XML，因此基本上它将基于XML的配置应用到设备上。该协议在配置开始时创建持久连接，并在整个任务的持续时间内保持连接，因此您不必为每个后续任务提供凭据。'
- en: '`httpapi` is supported by a few modules (at the time of writing, these are
    Arista EOS, Cisco NX-OS, and Extreme EXOS). This mode uses the HTTP API that the
    device publishes. This protocol creates a persistent connection at the beginning
    of the configuration and keeps it alive for the whole duration of the task so
    that you don''t have to provide credentials for every subsequent task.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httpapi` 受到少量模块的支持（在撰写本文时，这些模块是Arista EOS、Cisco NX-OS和Extreme EXOS）。这种模式使用设备发布的HTTP
    API。该协议在配置开始时创建持久连接，并在整个任务的持续时间内保持连接，因此您不必为每个后续任务提供凭据。'
- en: '`Local` is supported by the majority of devices but is a deprecated mode. This
    is basically a vendor-dependent connection mode that may require some vendor packages
    to be used. This mode does not create a persistent connection, so at the start
    of every task, you will need to pass the credentials. When possible, avoid this
    mode.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Local`被大多数设备支持，但是它是一个已弃用的模式。这基本上是一个依赖于供应商的连接模式，可能需要使用一些供应商包。这种模式不会创建持久连接，因此在每个任务开始时，你都需要传递凭据。在可能的情况下，避免使用这种模式。'
- en: '`ssh` must not be forgotten in this section. Although a large number of devices
    depend upon the connection modes listed here, a new breed of devices is being
    created that run Linux natively on white box switch hardware. One such example
    is Cumulus Networks, and as the software is Linux-based, all configuration can
    be performed over SSH, as if the switch was actually just another Linux server.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本节中，`ssh` 不能被忘记。虽然许多设备依赖于此处列出的连接模式，但正在创建一种新型设备，它们在白盒交换机硬件上原生运行Linux。Cumulus
    Networks就是一个这样的例子，由于软件是基于Linux的，所有配置都可以通过SSH进行，就好像交换机实际上只是另一台Linux服务器一样。
- en: Knowing how Ansible connects to and communicates with your networking hardware
    is important as it gives you the understanding you need to build your Ansible
    playbooks and debug issues when things go wrong. In this section, we covered the
    communication protocols you will come across when working with networking hardware.
    We will build on this in the next section by looking at the fundamentals of starting
    out on our network automation journey with Ansible.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Ansible如何连接和与你的网络硬件通信是很重要的，因为它能让你理解你构建Ansible playbooks和调试问题时所需的知识。在本节中，我们介绍了在处理网络硬件时会遇到的通信协议。在下一节中，我们将在此基础上继续，看看如何使用Ansible开始我们的网络自动化之旅的基础知识。
- en: Enabling network automation
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用网络自动化
- en: Before you can use Ansible for network automation, you need to make sure you
    have everything you need.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在你使用Ansible进行网络自动化之前，你需要确保你拥有一切所需的东西。
- en: Based on the kind of connection method we are going to use, we need different
    dependencies. As an example, we are going to use a Cisco IOS device with `network_cli`
    connectivity.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们将要使用的连接方法的不同，我们需要不同的依赖。举例来说，我们将使用具有`network_cli`连接性的Cisco IOS设备。
- en: 'The only requirements for Ansible network automation to work are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible网络自动化的唯一要求如下：
- en: Ansible 2.5+
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 2.5+
- en: Proper connectivity with the network device
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与网络设备的正确连接
- en: 'First, we need to check the Ansible version:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检查Ansible的版本：
- en: 'To ensure that you have a recent Ansible version, you can run the following
    command:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你有一个最新的Ansible版本，你可以运行以下命令：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will tell you the version of your Ansible installation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉你你的Ansible安装的版本。
- en: 'If it''s 2.5 or better, you can issue the following command (with the appropriate
    options) to check the connectivity of your network device:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是2.5或更高版本，你可以发出以下命令（带有适当的选项）来检查网络设备的连接：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This should return your device's facts, which proves that we are able to connect. As
    for any other target, Ansible is able to retrieve facts, and this is usually the
    first thing Ansible does when interacting with a target.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回你设备的事实，证明我们能够连接。对于任何其他目标，Ansible都能够检索事实，这通常是Ansible与目标交互时的第一步。
- en: This is a key step since this allows Ansible to know the current state of the
    device and therefore act appropriately.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关键步骤，因为这使得Ansible能够了解设备的当前状态，从而采取适当的行动。
- en: By running the `ios_facts` module on our target device, we are just executing
    this first standard step (so no changes will be performed on the device itself
    or its configurations), but this will confirm that Ansible is able to connect
    all the way to the device and perform commands on it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在目标设备上运行`ios_facts`模块，我们只是执行了这个第一个标准步骤（因此不会对设备本身或其配置进行任何更改），但这将确认Ansible能够连接到设备并对其执行命令。
- en: Now, obviously, you could only actually run the preceding command and explore
    its behavior if you have access to a network device running Cisco IOS. We understand
    that not everyone will have the same networking equipment available to them for
    testing purposes (or indeed any!). Fortunately for us, a new breed of switches
    is becoming available – "white box" switches. These switches are made by a variety
    of manufacturers and are based on standardized hardware where you can install
    your own network operating system. One such operating system is Cumulus Linux,
    and a freely available test version of this, called Cumulus VX, is available for
    you to download.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，只有当你有权限访问运行Cisco IOS的网络设备时，你才能运行前面的命令并探索其行为。我们知道并非每个人都有相同的网络设备可用于测试（或者根本没有！）。幸运的是，一种新型交换机正在出现——“白盒”交换机。这些交换机由各种制造商制造，基于标准化硬件，你可以在上面安装自己的网络操作系统。Cumulus
    Linux就是这样一种操作系统，它的一个免费测试版本叫做Cumulus VX，可以供你下载。
- en: At the time of writing, the download link for Cumulus VX is [https://cumulusnetworks.com/products/cumulus-vx/](https://cumulusnetworks.com/products/cumulus-vx/).
    You will need to register to download it, but doing so gives you free access to
    the world of open networking.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Cumulus VX的下载链接是[https://cumulusnetworks.com/products/cumulus-vx/](https://cumulusnetworks.com/products/cumulus-vx/)。你需要注册才能下载，但这样做可以让你免费访问开放网络的世界。
- en: 'Simply download the image appropriate to your hypervisor (for example, VirtualBox)
    and then run it just as you would run any other Linux virtual machine. Once you''ve
    done this, you can connect to the Cumulus VX switch, just like you would any other
    SSH device. For example, to run an ad hoc command to gather facts about all the
    switch port interfaces (which are enumerated as `swp1`, `swp2`, and `swpX` on
    Cumulus VX), you would run the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 只需下载适合你的hypervisor（例如VirtualBox）的镜像，然后像运行任何其他Linux虚拟机一样运行它。完成后，你可以连接到Cumulus
    VX交换机，就像连接到任何其他SSH设备一样。例如，要运行一个关于所有交换机端口接口的事实的临时命令（在Cumulus VX上被枚举为`swp1`、`swp2`和`swpX`），你可以运行以下命令：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If successful, this should result in pages of information about the switch
    port interface for your Cumulus VX-powered virtual switch. On my test system,
    the first part of this output looks like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，这应该会导致关于Cumulus VX虚拟交换机的交换机端口接口的大量信息。在我的测试系统上，此输出的第一部分如下所示：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, working with white box switches using an operating system such
    as Cumulus Linux has the advantage that you can connect using the standard SSH
    protocol, and you can even use the built-in `setup` module to gather facts about
    it. Working with other proprietary hardware is not much more difficult, but simply
    requires more parameters to be specified, as we showed earlier in this chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，使用诸如Cumulus Linux之类的操作系统来使用白盒交换机的优势在于，您可以使用标准的SSH协议进行连接，甚至可以使用内置的`setup`模块来收集有关它的信息。使用其他专有硬件并不更加困难，但只是需要指定更多的参数，就像我们在本章前面展示的那样。
- en: Now that you know the fundamentals of enabling network automation, let's learn
    how to discover the appropriate networking modules for our desired automation
    task in Ansible.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了启用网络自动化的基本知识，让我们学习如何在Ansible中发现适合我们所需自动化任务的适当网络模块。
- en: Reviewing the available Ansible networking modules
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查可用的Ansible网络模块
- en: 'At the moment, there are thousands of modules on a total of more than 20 different
    networking platforms. Let''s learn how to find the ones more relevant to you:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，有超过20种不同的网络平台上的数千个模块。让我们学习如何找到对您更相关的模块：
- en: First of all, you need to know which device type you have and how Ansible calls
    it. On the [https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html)
    page, you can find the different device types that Ansible supports and how they
    are designated. In our example, we will use Cisco IOS as an example.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要知道您有哪种设备类型以及Ansible如何调用它。在[https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html)页面上，您可以找到Ansible支持的不同设备类型以及它们的指定方式。在我们的示例中，我们将以Cisco
    IOS为例。
- en: On the [https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html)
    page, you can search for the category dedicated to the family of switches you
    need, and you'll be able to see all the modules you can use.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html)页面上，您可以搜索专门针对您所需交换机家族的类别，并且您将能够看到所有可以使用的模块。
- en: The list of modules is way too big and family-specific for us to talk about
    them in depth. This list is getting larger every release, with often hundreds
    of new additions in every release.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 模块列表对于我们来说太大且特定于家族，无法对其进行深入讨论。每个版本都会有数百个新的模块添加，因此此列表每次发布都会变得更大。
- en: 'If you are familiar with how to configure the device in a manual fashion, you
    will quickly find the name of the modules fairly natural, so it will be easy for
    you to understand what they do. However, let''s go through a handful of examples
    from the collection of Cisco IOS modules – specifically, with reference to [https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html#ios](https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html#ios):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉如何以手动方式配置设备，您将很快发现模块的名称相当自然，因此您将很容易理解它们的功能。但是，让我们从Cisco IOS模块集合中挑选出一些例子，具体参考[https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html#ios](https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html#ios)：
- en: '`ios_banner`: As the name suggests, this module will allow you to tweak and
    modify the login banner (what in many systems is called `motd`).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ios_banner`：顾名思义，此模块将允许您微调和修改登录横幅（在许多系统中称为`motd`）。'
- en: '`ios_bgp`: This module allows you to configure BGP routes.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ios_bgp`：此模块允许您配置BGP路由。'
- en: '`ios_command`: This is the IOS equivalent of the Ansible `command` module,
    and it allows you to perform many different commands. As for the `command` module,
    this is a very powerful module, but it''s better to use specific modules for the
    operation we are going to perform, if they are available.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ios_command`：这是Ansible `command`模块的IOS等效模块，它允许您执行许多不同的命令。就像`command`模块一样，这是一个非常强大的模块，但最好使用特定的模块来执行我们要执行的操作，如果它们可用的话。'
- en: '`ios_config`: This module allows us to make pretty much any changes to the
    configuration file of the device. As for the `ios_command` module, this is a very
    powerful module, but it''s better to use specific modules for the operation we
    are going to perform, if they are available. The idempotency for this module is
    only guaranteed if no abbreviated commands are used.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ios_config`：此模块允许我们对设备的配置文件进行几乎任何更改。就像`ios_command`模块一样，这是一个非常强大的模块，但最好使用特定的模块来执行我们要执行的操作，如果它们可用的话。如果使用了缩写命令，则此模块的幂等性将无法保证。'
- en: '`ios_vlan`: This module allows the configuration of VLANs.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ios_vlan`：此模块允许配置VLAN。'
- en: These are just a few examples, but there are many more modules for Cisco IOS
    (27, at the time of writing), and if you cannot find a specific module to perform
    the operation you want, you can always fall back to `ios_command` and `ios_config`,
    which, thanks to their flexibility, will allow you to perform any operation you
    can think of.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一些例子，但对于Cisco IOS还有许多其他模块（在撰写本文时有27个），如果您找不到执行所需操作的特定模块，您总是可以退而使用`ios_command`和`ios_config`，由于它们的灵活性，将允许您执行任何您能想到的操作。
- en: In contrast, if you are working with a Cumulus Linux switch, you'll find there
    is just one module – `nclu` (see [https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html#cumulus](https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html#cumulus)).
    This reflects the fact that all configuration work in Cumulus Linux is handled
    with this command. If you need to customize the message of the day or other aspects
    of the Linux operating system, you can do this in the normal manner (for example,
    using the `template` or `copy` modules, which we have demonstrated previously
    in this book).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，如果你正在使用Cumulus Linux交换机，你会发现只有一个模块 - `nclu`（参见[https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html#cumulus](https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html#cumulus)）。这反映了在Cumulus
    Linux中所有配置工作都是用这个命令处理的事实。如果你需要自定义每日消息或Linux操作系统的其他方面，你可以以正常方式进行（例如，使用我们在本书中之前演示过的`template`或`copy`模块）。
- en: As ever, the Ansible documentation is your friend, and it should be your first
    port of call when you are learning how to automate commands on a new class of
    device. In this section, we have demonstrated a simple process for finding out
    which Ansible modules are available for your class of network device, using Cisco
    as a specific example (though you could apply these principles to any other device).
    Now, let's look at how Ansible connects to network devices.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，Ansible文档是你的朋友，当你学习如何在新类设备上自动化命令时，它应该是你的首要选择。在本节中，我们演示了一个简单的过程，用于查找适用于你的网络设备类别的Ansible模块，以Cisco作为具体示例（尽管你可以将这些原则应用于任何其他设备）。现在，让我们看看Ansible如何连接到网络设备。
- en: Connecting to network devices
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到网络设备
- en: As we have seen, there are some peculiarities in Ansible networking, so specific
    configurations are required.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Ansible网络中有一些特殊之处，因此需要特定的配置。
- en: In order to manage network devices with Ansible, you need to have at least one
    to test on. Let's assume we have a Cisco IOS system available to us. It is accepted
    that not everyone will have such a device to test on, so the following is offered
    as a hypothetical example only.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Ansible管理网络设备，你至少需要一个设备进行测试。假设我们有一个Cisco IOS系统可供使用。可以肯定的是，不是每个人都有这样的设备进行测试，因此以下内容仅作为假设示例提供。
- en: 'Going by the [https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html)
    page, we can see that the correct `ansible_network_os` for this device is `ios`
    and that we can connect to it using both `network_cli` and `local`. Since `local`
    is deprecated, we are going to use `network_cli`. Follow these steps to configure
    Ansible so that you can manage IOS devices:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html)页面，我们可以看到这个设备的正确`ansible_network_os`是`ios`，我们可以使用`network_cli`和`local`连接到它。由于`local`已经被弃用，我们将使用`network_cli`。按照以下步骤配置Ansible，以便你可以管理IOS设备：
- en: 'First, let''s create the inventory file with our devices in the `routers` group:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建包含我们设备的清单文件在`routers`组中：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To know which connection parameters to use, we will set Ansible''s special
    connection variables so that they define the connection parameters. We''ll do
    this in a group variables subdirectory of our playbook, so we will need to create
    the `group_vars/routers.yml` file with the following content:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要知道要使用哪些连接参数，我们将设置Ansible的特殊连接变量，以便它们定义连接参数。我们将在playbook的组变量子目录中进行这些操作，因此我们需要创建包含以下内容的`group_vars/routers.yml`文件：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By virtue of these special Ansible variables, it will know how to connect to
    your devices. We covered some of these examples earlier in this book, but as a
    recap, Ansible uses the values of those variables to determine its behavior in
    the following ways:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借这些特殊的Ansible变量，它将知道如何连接到你的设备。我们在本书的前面已经涵盖了一些这些示例，但作为一个回顾，Ansible使用这些变量的值来确定其行为的方式如下：
- en: '`ansible_connection`: This variable is used by Ansible to decide how to connect
    to the device. By choosing `network_cli`, we are instructing Ansible to connect
    to the CLI over SSH mode, as we discussed in the previous paragraph.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_connection`：这个变量被Ansible用来决定如何连接到设备。通过选择`network_cli`，我们指示Ansible以SSH模式连接到CLI，就像我们在前一段讨论的那样。'
- en: '`ansible_network_os`: This variable is used by Ansible to understand the device
    family of the device we are going to use. By choosing `ios`, we are instructing
    Ansible to expect a Cisco IOS device.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_network_os`：这个变量被Ansible用来理解我们将要使用的设备的设备系列。通过选择`ios`，我们指示Ansible期望一个Cisco
    IOS设备。'
- en: '`ansible_become`: This variable is used by Ansible so that we decide whether
    to perform privilege escalation on the device or not. By specifying `True`, we
    are telling Ansible to perform privilege escalation.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_become`：这个变量被Ansible用来决定是否在设备上执行特权升级。通过指定`True`，我们告诉Ansible执行特权升级。'
- en: '`ansible_become_method`: There are many different ways to perform privilege
    escalation on the various devices (normally `sudo` on a Linux server – this is
    the default setting), and for Cisco IOS , we must set this to `enable`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_become_method`：在各种设备上执行特权升级有许多不同的方法（通常在Linux服务器上是`sudo` - 这是默认设置），对于Cisco
    IOS，我们必须将其设置为`enable`。'
- en: With that, you have learned the necessary steps to connect to network devices.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，你已经学会了连接到网络设备的必要步骤。
- en: 'To validate that the connection is working as expected (assuming you have access
    to a router running Cisco IOS), you can run this simple playbook, called `ios_facts.yaml`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证连接是否按预期工作（假设你可以访问运行Cisco IOS的路由器），你可以运行这个简单的playbook，名为`ios_facts.yaml`：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can run this using a command such as the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令来运行这个过程：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If it returns successfully, this means that your configuration is correct and
    you've been able to give Ansible the necessary authorization to manage your IOS
    device.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它成功返回，这意味着你的配置是正确的，并且你已经能够给予Ansible管理你的IOS设备所需的授权。
- en: 'Similarly, if you wanted to connect to a Cumulus VX device, you could add another
    group variables file called `group_vars/cumulusvx.yml` containing the following
    code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果您想连接到Cumulus VX设备，您可以添加另一个名为`group_vars/cumulusvx.yml`的组变量文件，其中包含以下代码：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'An analogous playbook that returns all the facts about our Cumulus VX switches
    could look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类似的playbook，返回有关我们的Cumulus VX交换机的所有信息，可能如下所示：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can run this in a normal manner by using a command such as the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用以下命令以正常方式运行：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If successful, you should see the following output from your playbook run:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，您应该会从您的playbook运行中看到以下输出：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This demonstrates the techniques for connecting to two different types of network
    devices in Ansible, including one you can test by yourself without access to any
    special hardware. Now, let's build on this by looking at how to set environment
    variables for network devices in Ansible.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这演示了连接到Ansible中两种不同类型的网络设备的技术，其中一种您可以自行测试，而无需访问任何特殊硬件。现在，让我们通过查看如何为Ansible中的网络设备设置环境变量来进一步学习。
- en: Environment variables for network devices
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络设备的环境变量
- en: Very often, the complexity of networks is high and the network systems are very
    varied. For those reasons, Ansible has a huge amount of variables that can help
    you tweak it so that you can make Ansible fit your environment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的复杂性很高，网络系统也非常多样化。因此，Ansible拥有大量的变量，可以帮助您调整它，使Ansible适应您的环境。
- en: Let's suppose you have two different networks (that is, one for computing and
    one for network devices) that can't communicate directly, but have to pass through
    a bastion host to reach one from the other. Since we have Ansible in the computing
    network, we will need to jump networks using the bastion host to configure an
    IOS router in the management network. Also, our target switch needs a proxy to
    reach the internet.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有两个不同的网络（即一个用于计算，一个用于网络设备），它们不能直接通信，但必须通过堡垒主机才能从一个网络到达另一个网络。由于我们在计算网络中使用了Ansible，我们需要通过堡垒主机跳转网络，以配置管理网络中的IOS路由器。此外，我们的目标交换机需要代理才能访问互联网。
- en: 'To connect to the IOS router in the database network, we will need to create
    a new group for our network devices, which are on a separate network. For this
    example, this might be specified as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到数据库网络中的IOS路由器，我们需要为我们的网络设备创建一个新的组，这些设备位于一个单独的网络上。例如，对于这个例子，可能会指定如下：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Following the creation of our updated inventory, we can create a new group
    variables file, such as `group_vars/bastion_routers.yaml`, with the following
    content:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了更新后的清单后，我们可以创建一个新的组变量文件，例如`group_vars/bastion_routers.yaml`，其中包含以下内容：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also do the same for our Cumulus VX switches if they are behind a bastion
    server by creating a `group_vars/bastion_cumulusvx.yml` file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的Cumulus VX交换机位于堡垒服务器后面，我们也可以创建一个`group_vars/bastion_cumulusvx.yml`文件来实现相同的效果：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In addition to the options we discussed in the previous section, we now have
    two additional options:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在上一节中讨论的选项之外，我们现在还有两个额外的选项：
- en: '`ansible_ssh_common_args`: This is a very powerful option that allows us to
    add additional options to the SSH connections so that we can tweak their behavior.
    These options should be fairly straightforward to identify since you are already
    using them in your SSH configurations to simply SSH to the target machine. In
    this specific case, we are adding a `ProxyCommand`, which is the SSH directive
    to perform a jump to a host (usually a bastion host) so that we can enter the
    target host securely.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_ssh_common_args`：这是一个非常强大的选项，允许我们向SSH连接添加额外的选项，以便我们可以调整它们的行为。这些选项应该相当容易识别，因为您已经在您的SSH配置中使用它们，只需简单地SSH到目标机器。在这种特定情况下，我们正在添加一个`ProxyCommand`，这是执行跳转到主机（通常是堡垒主机）的SSH指令，以便我们可以安全地进入目标主机。'
- en: '`http_proxy`: This option, which is below the `proxy_env` option, is key in
    environments where network isolation is strong, and therefore your machines can''t
    interact with the internet unless they use a proxy.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http_proxy`：这个选项位于`proxy_env`选项下面，在网络隔离很强的环境中非常关键，因此您的机器除非使用代理，否则无法与互联网进行交互。'
- en: 'Assuming you have set up passwordless (for example, SSH key-based) access to
    your bastion host, you should be able to run an ad hoc Ansible `ping` command
    against your Cumulus VX host, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经设置了无密码（例如基于SSH密钥的）访问到您的堡垒主机，您应该能够对您的Cumulus VX主机运行一个临时的Ansible `ping`命令，如下所示：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that the use of the bastion server becomes transparent – you can carry
    on automating with Ansible as if you were on the same flat network. If you have
    access to a Cisco IOS-based device, you should be able to run a similar command
    against the `bastion_routers` group as well and achieve similarly positive results.
    Now that you have learned the necessary steps to set environment variables for
    network devices, and indeed access them with Ansible, even when they are on isolated
    networks, let's learn how to set conditional statements for networking devices.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，堡垒服务器的使用变得透明 - 您可以继续使用Ansible进行自动化，就好像您在同一个平面网络上一样。如果您可以访问基于Cisco IOS的设备，您也应该能够对`bastion_routers`组运行类似的命令，并取得类似的积极结果。现在您已经学会了为网络设备设置环境变量的必要步骤，以及如何使用Ansible访问它们，即使它们在隔离的网络中，让我们学习如何为网络设备设置条件语句。
- en: Conditional statements for networking devices
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络设备的条件语句
- en: Although there are no networking-specific Ansible conditionals, conditionals
    are fairly common in networking-related Ansible usage.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有特定于网络的Ansible条件语句，但在与网络相关的Ansible使用中，条件语句是相当常见的。
- en: In networking, it's common to enable and disable ports. To have data pass through
    the cable, both ports at the ends of the cable should be enabled and result in
    a "connected" state (some vendors will use different names for this, but the idea
    is the same).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中，启用和禁用端口是很常见的。要使数据通过电缆，电缆两端的端口都应该启用，并且结果为“连接”状态（一些供应商可能会使用不同的名称，但概念是相同的）。
- en: Let's suppose we have two Arista Networks EOS devices and we issued the ON status
    on the ports and need to wait for the connection to be up before proceeding.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个Arista Networks EOS设备，并且我们在端口上发出了ON状态，并且需要等待连接建立后再继续。
- en: 'To wait for the `Ethernet4` interface to be enabled, we will need to add the
    following task in our playbook:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要等待`Ethernet4`接口启用，我们需要在我们的playbook中添加以下任务：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`eos_command` is the module that allows us to issue free-formed commands to
    an Arista Networks EOS device. The command itself needs to be specified in an
    array in the `commands` option. With the `wait_for` option, we can specify a condition,
    and Ansible will reiterate on the specified task until the condition is satisfied.
    Since the command''s output is redirected to the `json` utility, the output will
    be a JSON, so we can traverse its structure using Ansible''s ability to manipulate
    JSON data.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`eos_command`是允许我们向Arista Networks EOS设备发出自由形式命令的模块。命令本身需要在`commands`选项中指定为数组。通过`wait_for`选项，我们可以指定一个条件，Ansible将在指定任务上重复，直到条件满足。由于命令的输出被重定向到`json`实用程序，输出将是一个JSON，因此我们可以使用Ansible操作JSON数据的能力来遍历其结构。'
- en: 'We can achieve similar results on Cumulus VX – for example, we can query the
    facts gathered from the switch to see if port `swp2` is enabled. If it is not,
    then we will enable it; however, if it is enabled, we will skip the command. We
    can do this with a simple playbook, follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Cumulus VX上实现类似的结果——例如，我们可以查询从交换机收集的事实，看看端口`swp2`是否已启用。如果没有启用，那么我们将启用它；但是，如果已启用，我们将跳过该命令。我们可以通过一个简单的playbook来实现这一点，如下所示：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Notice the use of the `when` clause in our task, meaning we should only issue
    the configuration directive if `swp2` is not active. If we were to run this playbook
    for the first time on an unconfigured Cumulus Linux switch, we should see an output
    similar to the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们任务中`when`子句的使用，意味着我们只应在`swp2`不活动时发出配置指令。如果我们在未配置的Cumulus Linux交换机上第一次运行此playbook，我们应该看到类似以下的输出：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As we can see, the `nclu` module committed our change to the switch configuration.
    However, if we were to run the playbook a second time, the output should be more
    like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`nclu`模块将我们的更改提交到了交换机配置中。然而，如果我们再次运行playbook，输出应该更像这样：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This time, the task was skipped as the Ansible facts show that port `swp2` is
    already enabled. This is obviously an incredibly simple example, but it shows
    how you can work with conditionals on a network device very much in the same way
    that you have already seen conditionals being used on Linux servers, earlier in
    this book.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，任务被跳过了，因为Ansible事实显示端口`swp2`已经启用。这显然是一个非常简单的例子，但它展示了你可以如何在网络设备上使用条件语句，这与你之前在本书中已经看到的在Linux服务器上使用条件语句的方式非常相似。
- en: That concludes our brief look at network device automation with Ansible – more
    in-depth work would require a look at network configurations and necessitate more
    hardware, so this is beyond the scope of this book. However, I hope that this
    information demonstrates to you that Ansible can be used effectively to automate
    and configure a wide array of network devices.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对使用Ansible进行网络设备自动化的简要介绍——更深入的工作需要查看网络配置，并需要更多的硬件，因此这超出了本书的范围。然而，我希望这些信息向你展示了Ansible可以有效地用于自动化和配置各种网络设备。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Modern large-scale infrastructures that change rapidly necessitate automation
    of network tasks. Fortunately, Ansible supports a wide array of network devices,
    from proprietary hardware such as Cisco IOS-based devices, through to open standards
    such as white box switches that run operating systems such as Cumulus Linux. Ansible
    is a powerful and supportive tool when it comes to managing your network configuration
    and allows you to implement changes quickly and safely. You can even replace entire
    devices in your network and be confident in your ability to put the correct configuration
    on the new device in place by virtue of your Ansible playbooks.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 快速变化的现代大规模基础设施需要自动化网络任务。幸运的是，Ansible支持各种网络设备，从专有硬件，如基于Cisco IOS的设备，到运行操作系统如Cumulus
    Linux的白盒交换机等开放标准。当涉及管理网络配置时，Ansible是一个强大而有支持性的工具，它允许你快速而安全地实施变更。你甚至可以在网络中替换整个设备，并且有信心能够通过你的Ansible
    playbook在新设备上放置正确的配置。
- en: In this chapter, you learned about the reasons for automating network management.
    You then looked at how Ansible manages network devices, how to enable network
    automation in Ansible, and how to locate the Ansible modules necessary to perform
    the automation tasks you wish to complete. Then, through practical examples, you
    learned how to connect to network devices, how to set environment variables (and
    connect to isolated networks via bastion hosts), and how to apply conditional
    statements to Ansible tasks for network device configuration.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了自动化网络管理的原因。然后，你看了Ansible如何管理网络设备，如何在Ansible中启用网络自动化，以及如何找到执行你希望完成的自动化任务所需的Ansible模块。然后，通过实际示例，你学会了如何连接到网络设备，如何设置环境变量（并通过堡垒主机连接到隔离网络），以及如何对Ansible任务应用条件语句以配置网络设备。
- en: In the next chapter, we will learn how to manage Linux containers and cloud
    infrastructures using Ansible.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用Ansible管理Linux容器和云基础设施。
- en: Questions
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of these is NOT one of the four major connection types that Ansible uses
    for connecting to those network devices?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个不是Ansible用于连接这些网络设备的四种主要连接类型之一？
- en: A) `netconf`
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: A) `netconf`
- en: B) `network_cli`
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: B) `network_cli`
- en: C) `local`
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: C) `local`
- en: D) `netstat`
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: D) `netstat`
- en: E) `httpapi`
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: E) `httpapi`
- en: 'True or False: The `ansible_network_os` variable is used by Ansible to understand
    the device family of the device we are going to use.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：`ansible_network_os`变量被Ansible用来理解我们将要使用的设备的设备系列。
- en: A) True
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: A) True
- en: B) False
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: B) False
- en: 'True or False: In order to connect to an IOS router in a separate network,
    you need to specify the special connection variables for the host, possibly as
    inventory group variables.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：为了连接到一个独立网络中的IOS路由器，您需要指定主机的特殊连接变量，可能作为清单组变量。
- en: A) True
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: A) 正确
- en: B) False
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: B) 错误
- en: Further reading
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The official documentation about Ansible networking: [https://docs.ansible.com/ansible/latest/network/index.html](https://docs.ansible.com/ansible/latest/network/index.html)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Ansible网络的官方文档：[https://docs.ansible.com/ansible/latest/network/index.html](https://docs.ansible.com/ansible/latest/network/index.html)
