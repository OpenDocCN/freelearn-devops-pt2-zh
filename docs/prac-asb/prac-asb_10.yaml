- en: Advanced Ansible Topics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级Ansible主题
- en: Up to this point, we have worked hard to give you a solid foundation of Ansible,
    so that whatever your desired automation task, you can implement it with ease
    and confidence. However, when you really start to ramp up your automation, how
    do you ensure that you can handle any condition that arises in a graceful manner?
    For example, how can you ensure that when you have to initiate long-running actions,
    you can run them asynchronously and come back to them to check on the results
    reliably later? Or, if you are updating a large group of servers, how can you
    ensure that the play fails early if a handful of servers suffer failures? The
    last thing you want to do is to roll out a broken update (let's face it, problems
    do occur with everyone's code from time to time) across a hundred servers—far
    better to detect that a small percentage have failed and abort the entire play
    on this basis than attempt to continue and break an entire load-balanced cluster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经努力为您提供了Ansible的坚实基础，这样无论您想要的自动化任务是什么，您都可以轻松自如地实现它。然而，当您真正开始加速自动化时，您如何确保能够以一种优雅的方式处理任何出现的情况呢？例如，当您必须启动长时间运行的操作时，如何确保您可以异步运行它们，并在稍后可靠地检查结果？或者，如果您正在更新一大群服务器，如何确保如果一小部分服务器出现故障，play会及早失败？您最不希望做的事情就是在一百台服务器上部署一个有问题的更新（让我们面对现实，每个人的代码都会不时出现问题）——最好的办法是检测到一小部分服务器失败并根据这个基础中止整个play，而不是试图继续并破坏整个负载均衡集群。
- en: In this chapter, we will look at how to solve these particular issues, as well
    as many more, using some of the more advanced features of Ansible to control playbook
    flow and error handling. We will explore, through practical examples, how to perform
    rolling updates with Ansible, how to work with proxies and jump hosts (which is
    vital for secure environments and often for core network configuration), and how
    to secure sensitive Ansible data at rest using the native Ansible Vault technology.
    By the end of this chapter, you will have a full picture of how to run Ansible not
    only in a small environment but also in a large, secure, mission-critical environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看如何解决这些特定问题，以及使用Ansible的一些更高级功能来控制playbook流程和错误处理。我们将通过实际示例探讨如何使用Ansible执行滚动更新，如何使用代理和跳板主机（这对于安全环境和核心网络配置通常至关重要），以及如何使用本地Ansible
    Vault技术在静态环境中保护敏感的Ansible数据。通过本章结束时，您将全面了解如何在小型环境中以及在大型、安全、关键任务的环境中运行Ansible。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Asynchronous versus synchronous actions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步与同步操作
- en: Controlling play execution for rolling updates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制滚动更新的play执行
- en: Configuring the maximum failure percentage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置最大失败百分比
- en: Setting task execution delegation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置任务执行委托
- en: Using the `run_once` option
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`run_once`选项
- en: Running playbooks locally
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地运行playbooks
- en: Working with proxies and jump hosts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代理和跳板主机
- en: Configuring playbook prompts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置playbook提示
- en: Placing tags in the plays and tasks
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在play和任务中放置标签
- en: Securing data with Ansible Vault
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible Vault保护数据
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [Chapter 1](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml), *Getting
    Started with Ansible*, and are using the most recent version available. The examples
    in this chapter are tested with Ansible 2.9\. This chapter also assumes that you
    have at least one additional host to test against and ideally, this should be
    Linux-based. Although we will give specific examples of hostnames in this chapter,
    you are free to substitute them with your own hostname and/or IP addresses; details
    of how to do this are provided at the appropriate places.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经按照[第1章](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml)中详细介绍的方式在控制主机上设置了Ansible，并且正在使用最新版本。本章的示例是在Ansible
    2.9版本下测试的。本章还假设您至少有一个额外的主机进行测试，并且最好是基于Linux的。虽然本章将给出特定主机名的示例，但您可以自由地用自己的主机名和/或IP地址替换它们；如何做到这一点的详细信息将在适当的位置提供。
- en: The code bundle for this chapter is available at[ https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%208](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%208).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包可以在[https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%208](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%208)上找到。
- en: Asynchronous versus synchronous actions
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步与同步操作
- en: As we have seen in this book so far, Ansible plays are executed in sequence,
    with each task running to completion before the next task is started. Although
    this is often advantageous for flow control and logical sequencing, there are
    times when you may not want this. In particular, it might be the case that a particular
    task runs for longer than the configured SSH connection timeout and as Ansible
    uses SSH to perform its automation tasks on most platforms, this would be an issue.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在本书中看到，Ansible play 是按顺序执行的，每个任务在下一个任务开始之前都会完成。虽然这通常有利于流程控制和逻辑顺序，但有时你可能不希望这样。特别是，可能会出现某个任务运行时间长于配置的SSH连接超时时间，而Ansible在大多数平台上使用SSH来执行自动化任务，这可能会成为一个问题。
- en: Fortunately, Ansible tasks can be run asynchronously—that is to say, tasks can
    be run in the background on the target host and polled on a regular basis. This
    is in contrast to synchronous tasks, where the connection to the target host is
    kept open until the task completes (which runs the risk of a timeout occurring).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Ansible任务可以异步运行，也就是说，任务可以在目标主机上后台运行，并定期轮询。这与同步任务形成对比，同步任务会保持与目标主机的连接，直到任务完成（这会导致超时的风险）。
- en: 'As ever, let''s explore this through a practical example. Suppose we have two
    servers in a simple INI-formatted inventory:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，让我们通过一个实际的例子来探讨这个问题。假设我们在一个简单的INI格式清单中有两台服务器：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, in order to simulate a long-running task, we''ll run the `sleep` command
    using the `shell` module. However, rather than have it run with the SSH connection
    blocked for the duration of the `sleep` command, we''ll add two special parameters
    to the task, as shown:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了模拟一个长时间运行的任务，我们将使用`shell`模块运行`sleep`命令。但是，我们不会让它在`sleep`命令的持续时间内阻塞SSH连接，而是会给任务添加两个特殊参数，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The two new parameters are `async` and `poll`. The `async` parameter tells Ansible
    that this task should be run asynchronously (so that the SSH connection will not
    be blocked) for a maximum of `30` seconds. If the task runs for longer than this
    configured time, Ansible considers the task to have failed and the play is failed,
    accordingly. When `poll` is set to a positive integer, Ansible checks the status
    of the asynchronous task at the specified interval—in this example, every `5`
    seconds. If `poll` is set to `0`, then the task is run in the background and never
    checked—it is up to you to write a task to manually check its status later on.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 两个新参数是`async`和`poll`。`async`参数告诉Ansible这个任务应该异步运行（这样SSH连接就不会被阻塞），最多运行`30`秒。如果任务运行时间超过配置的时间，Ansible会认为任务失败，整个操作也会失败。当`poll`设置为正整数时，Ansible会以指定的间隔（在这个例子中是每`5`秒）检查异步任务的状态。如果`poll`设置为`0`，那么任务会在后台运行，不会被检查，需要你编写一个任务来手动检查它的状态。
- en: If you don't specify the `poll` value, it will be set to the default value defined
    by the `DEFAULT_POLL_INTERVAL` configuration parameter of Ansible (which is `10`
    seconds).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不指定`poll`值，它将被设置为Ansible的`DEFAULT_POLL_INTERVAL`配置参数定义的默认值（即`10`秒）。
- en: 'When you run this playbook, you will find that it runs just like any other
    playbook; from the terminal output, you won''t be able to see any difference.
    But behind the scenes, Ansible checks the task every `5` seconds until it succeeds
    or reaches the `async` timeout value of `30` seconds:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个playbook时，你会发现它的运行方式和其他playbook一样；从终端输出中，你看不出任何区别。但在幕后，Ansible会每`5`秒检查任务，直到成功或达到`30`秒的`async`超时值：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you want to check on the task later (that is, if `poll` is set to `0`),
    you could add a second task to your playbook so that it looks as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想稍后检查任务（也就是说，如果`poll`设置为`0`），你可以在playbook中添加第二个任务，使其如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this playbook, the initial asynchronous task is defined as before, except
    we have now set `poll` to `0`. We have also chosen to register the result of this
    task to a variable called `long_task`—this is so that we can query the job ID
    for the task when we check it later on. The next (new) task in the play uses the
    `async_status` module to check on the job ID we registered from the first task
    and loops until the job either finishes or reaches `30` retries—whichever comes
    first. When using these in a playbook, you almost certainly wouldn''t add the
    two tasks back to back like this—usually, you would perform additional tasks in
    between them—but to keep this example simple, we will run the two tasks sequentially.
    Running this playbook should yield an output similar to the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个playbook中，初始的异步任务与之前一样定义，只是现在我们将`poll`设置为`0`。我们还选择将这个任务的结果注册到一个名为`long_task`的变量中，这样我们在后面检查时就可以查询任务的作业ID。play中的下一个（新的）任务使用`async_status`模块来检查我们从第一个任务中注册的作业ID，并循环直到作业完成或达到`30`次重试为止。在playbook中使用这些时，你几乎肯定不会像这样连续添加两个任务——通常情况下，你会在它们之间执行其他任务，但为了保持这个例子简单，我们将连续运行这两个任务。运行这个playbook应该会产生类似以下的输出：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code block, we can see that the long-running task is left running
    and the next task polls its status until the conditions we set are met. In this
    case, we can see that the task finished successfully and the overall play result
    was successful. Asynchronous actions are especially useful for large downloads,
    package updates, and other tasks that might take a long time to run. You may find
    them useful in your playbook development, especially in more complex infrastructures.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码块中，我们可以看到长时间运行的任务一直在运行，下一个任务会轮询其状态，直到满足我们设置的条件。在这种情况下，我们可以看到任务成功完成，整个操作结果也是成功的。异步操作对于大型下载、软件包更新和其他可能需要长时间运行的任务特别有用。在你的playbook开发中，特别是在更复杂的基础设施中，你可能会发现它们很有用。
- en: With this under our belt, let's take a look at another advanced technique that
    might be useful in large infrastructures—performing rolling updates with Ansible.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个基础，让我们来看看另一个在大型基础设施中可能有用的高级技术——使用Ansible进行滚动更新。
- en: Control play execution for rolling updates
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制滚动更新的play执行
- en: By default, Ansible parallelizes tasks on multiple hosts at the same time to
    speed up automation tasks in large inventories. The setting for this is defined
    by the `forks` parameter in the Ansible configuration file, which defaults to
    `5` (so, by default, Ansible attempts to run its automation job on five hosts
    at the same time).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible会在多个主机上并行执行任务，以加快大型清单中的自动化任务。这个设置由Ansible配置文件中的`forks`参数定义，默认值为`5`（因此，默认情况下，Ansible尝试在五个主机上同时运行自动化任务）。
- en: In a load-balanced environment, this is not ideal, especially if you want to
    avoid downtime. Suppose we have five frontend servers in an inventory (or perhaps
    even fewer). If we allow Ansible to update all of these at the same time, the
    end users may experience a loss of service. So, it is important to consider updating
    all of the servers at different times. Let's reuse our inventory from the previous
    section with just two servers in it. Obviously, if these were in a load-balanced
    environment, it would be vital that we only update one of these at a time; if
    both were taken out of service simultaneously, then end users would definitely
    lose access to the service until the Ansible play completes successfully.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在负载均衡环境中，这并不理想，特别是如果你想避免停机时间。假设我们的清单中有五个前端服务器（或者甚至更少）。如果我们允许Ansible同时更新所有这些服务器，终端用户可能会遇到服务中断。因此，重要的是考虑在不同的时间更新所有服务器。让我们重用上一节中的清单，其中只有两个服务器。显然，如果这些服务器在负载均衡环境中，我们只能一次更新一个；如果同时取出服务，那么终端用户肯定会失去对服务的访问，直到Ansible
    play成功完成。
- en: 'The answer to this is to use the `serial` keyword in the play definition to
    determine how many hosts are operated on at once. Let''s demonstrate this through
    a practical example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是在play定义中使用`serial`关键字来确定一次操作多少个主机。让我们通过一个实际的例子来演示这一点：
- en: 'Create the following simple playbook to run two commands on the two hosts in
    our inventory. The content of the command is not important at this stage, but
    if you run the `date` command using the `command` module, you will be able to
    see the time that each task is run, as well as if you specify `-v` to increase
    the verbosity when you run the play:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下简单的playbook，在我们的清单中的两个主机上运行两个命令。在这个阶段，命令的内容并不重要，但如果你使用`command`模块运行`date`命令，你将能够看到每个任务运行的时间，以及当你运行play时，如果指定了`-v`来增加详细信息：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, if you run this play, you will see that it performs all the operations
    on each host simultaneously, as we have fewer hosts than the default number of
    forks—`5`. This behavior is normal for Ansible, but not really what we want as
    our users will experience service outage:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你运行这个play，你会发现它在每个主机上同时执行所有操作，因为我们的主机数量少于默认的fork数量——`5`。这种行为对于Ansible来说是正常的，但并不是我们想要的，因为我们的用户将会遇到服务中断：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s modify the play definition, as shown. We''ll leave the `tasks`
    sections exactly as they were in *step 1*:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们修改play定义，如下所示。我们将`tasks`部分保持与*步骤1*中完全相同：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice the presence of the `serial: 1` line. This tells Ansible to complete
    the play on `1` host at a time before moving on to the next. If we run the play
    again, we can see this in action:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '注意`serial: 1`这一行的存在。这告诉Ansible在移动到下一个主机之前一次在1个主机上完成play。如果我们再次运行play，我们可以看到它的运行情况：'
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Much better! If you imagine that this playbook actually disables these hosts
    on a load balancer, performs an upgrade, and then re-enables the hosts on the
    load balancer, this is exactly how you would want the operation to proceed. Doing
    so without the `serial: 1` directive would result in all the hosts being removed
    from the load balancer at once, causing a loss of service.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '太好了！如果你想象一下，这个playbook实际上是在负载均衡器上禁用这些主机，执行升级，然后重新启用负载均衡器上的主机，这正是你希望操作进行的方式。如果没有`serial:
    1`指令，所有主机将同时从负载均衡器中移除，导致服务中断。'
- en: 'It is useful to note that the `serial` directive can also take a percentage
    instead of an integer. When you specify a percentage, you are telling Ansible
    to run the play on that percentage of hosts at one time. So, if you have `4` hosts
    in your inventory and specify `serial: 25%`, Ansible will only run the play on
    one host at a time. If you have `8` hosts in your inventory, it will run the play
    on two hosts at a time. I''m sure you get the idea!'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '值得注意的是，`serial`指令也可以取百分比而不是整数。当你指定一个百分比时，你告诉Ansible一次在百分之多少的主机上运行play。所以，如果你的清单中有4个主机，并指定`serial:
    25%`，Ansible将一次只在一个主机上运行play。如果你的清单中有8个主机，它将一次在两个主机上运行play。我相信你明白了！'
- en: 'You can even build on this by passing a list to the `serial` directive. Consider
    the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以通过将列表传递给`serial`指令来构建这个。考虑以下代码：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This tells Ansible to run the play on `1` host, initially, then on the next
    `3`, and then on batches of `5` at a time until the inventory is completed. You
    can also specify a list of percentages in place of the integer numbers of hosts.
    In doing this, you will build up a robust playbook that can perform rolling updates
    without causing a loss of service to end users. With this complete, let's further build
    on this knowledge by looking at controlling the maximum failure percentage that
    Ansible can tolerate before it aborts a play, which will again be useful in highly
    available or load-balanced environments such as this.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Ansible一开始在1个主机上运行play，然后在接下来的3个主机上运行，然后一次在5个主机上运行，直到清单完成。你也可以在整数主机数的位置指定一个百分比列表。通过这样做，你将建立一个强大的playbook，可以执行滚动更新而不会导致终端用户服务中断。完成这一点后，让我们进一步通过控制Ansible在中止play之前可以容忍的最大失败百分比来增进这一知识，这在高可用或负载平衡环境中将会再次非常有用。
- en: Configuring the maximum failure percentage
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置最大失败百分比
- en: In its default mode of operation, Ansible continues to execute a play on a batch
    of servers (the batch size is determined by the `serial` directive we discussed
    in the preceding section) as long as there are hosts in the inventory and a failure
    isn't recorded. Obviously, in a highly available or load-balanced environment
    (such as the one we discussed previously), this is not ideal. If there is a bug
    in your play, or perhaps a problem with the code being rolled out, the last thing
    that you want is for Ansible to faithfully roll it out to all servers in the cluster,
    causing a service outage because all the nodes suffered a failed upgrade. It would
    be far better, in this kind of environment, to fail early on and leave at least
    some hosts in the cluster untouched until someone can intervene and resolve the
    issue.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在其默认操作模式下，只要库存中有主机并且没有记录失败，Ansible就会继续在一批服务器上执行播放（批处理大小由我们在前一节中讨论的`serial`指令确定）。显然，在高可用或负载平衡环境中（如我们之前讨论的环境），这并不理想。如果您的播放中有错误，或者可能存在代码问题，您最不希望的是Ansible忠实地将其部署到集群中的所有服务器，导致服务中断，因为所有节点都遭受了失败的升级。在这种环境中，最好的做法是尽早失败，并且在某人能够介入并解决问题之前至少保留一些主机不受影响。
- en: 'For our practical example, let''s consider an expanded inventory with `10`
    hosts in it. We''ll define this as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的实际示例，让我们考虑一个扩展的库存，其中有`10`个主机。我们将定义如下：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s create a simple playbook to run on these hosts. We will set our
    batch size to `5` and `max_fail_percentage` to `50%` in the play definition:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个简单的playbook在这些主机上运行。我们将在play定义中将批处理大小设置为`5`，将`max_fail_percentage`设置为`50%`：
- en: 'Create the following play definition to demonstrate the use of the `max_fail_percentage`
    directive:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下play定义来演示`max_fail_percentage`指令的使用：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have defined `10` hosts in our inventory, so it will process them in batches
    of 5 (as specified by `serial: 5`). We will fail the entire play and stop performing
    processing if more than 50% of the hosts in one batch fails.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在库存中定义了`10`个主机，因此它将以5个一组（由`serial: 5`指定）进行处理。如果一批中超过50%的主机失败，我们将失败整个播放并停止处理。'
- en: The number of failed hosts must exceed the value of `max_fail_percentage`; if
    it is equal, the play continues. So, in our example, if exactly 50% of our hosts
    failed, the play would still continue.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 失败主机的数量必须超过`max_fail_percentage`的值；如果相等，则播放继续。因此，在我们的示例中，如果我们的主机正好有50%失败，播放仍将继续。
- en: 'Next, we will define two simple tasks. The first task has a special clause
    under it that we use to deliberately simulate a failure—this line starts with
    `failed_when` and we use it to tell the task that if it runs this task on the
    first three hosts in the batch, then it should deliberately fail this task regardless
    of the result; otherwise, it should allow the task to run as normal:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义两个简单的任务。第一个任务下面有一个特殊的子句，我们用它来故意模拟一个失败——这一行以`failed_when`开头，我们用它告诉任务，如果它在批次中的前三个主机上运行此任务，那么无论结果如何，它都应该故意失败此任务；否则，它应该允许任务正常运行：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we''ll add a second task that will always succeed. This is run if
    the play is allowed to continue, but not if it is aborted:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加一个始终成功的第二个任务。如果播放被允许继续，则运行此任务，但如果播放被中止，则不运行：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, we have deliberately constructed a playbook that will run on a 10-host inventory
    in batches of 5 hosts at a time, but the play is aborted if more than 50% of the
    hosts in any given batch experiences a failure. We have also deliberately set
    up a failure condition that causes three of the hosts in the first batch of 5 (60%) to
    fail.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们故意构建了一个将在10个主机库存中以5个主机一组的方式运行的playbook，但是如果任何给定批次中超过50%的主机经历失败，则播放将中止。我们还故意设置了一个失败条件，导致第一批5个主机中的三个（60%）失败。
- en: 'Run the playbook and let''s observe what happens:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行playbook，让我们观察发生了什么：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice the results of this playbook. We deliberately failed three of the first
    batch of 5, exceeding the threshold for `max_fail_percentage` that we set. This
    immediately causes the play to abort and the second task is not performed on the
    first batch of 5\. You will also notice that the second batch of 5, out of the
    10 hosts, is never processed, so our play was truly aborted. This is exactly the
    behavior you would want to see to prevent a failed update from rolling out across
    a cluster. Through the careful use of batches and `max_fail_percentage`, you can
    safely run automated tasks across an entire cluster without the fear of breaking
    the entire cluster in the event of an issue. In the next section, we will take
    a look at another feature of Ansible that can be incredibly useful when it comes
    to working with clusters—task delegation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意此playbook的结果。我们故意使前5个批次中的三个失败，超过了我们设置的`max_fail_percentage`的阈值。这立即导致播放中止，并且第二个任务不会在前5个批次上执行。您还会注意到，10个主机中的第二批次从未被处理，因此我们的播放确实被中止。这正是您希望看到的行为，以防止失败的更新在整个集群中传播。通过谨慎使用批处理和`max_fail_percentage`，您可以在整个集群上安全运行自动化任务，而不必担心在出现问题时破坏整个集群。在下一节中，我们将介绍Ansible的另一个功能，当涉及到与集群一起工作时，这个功能可能非常有用——任务委派。
- en: Setting task execution delegation
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置任务执行委托
- en: In every play we have run so far, we have assumed that all the tasks are executed
    on each host in the inventory in turn. However, what if you need to run one or
    two tasks on a different host? For example, we have talked about the concept of
    automating upgrades on clusters. Logically, however, we would want to automate
    the entire process, including the removal of each host in turn from the load balancer
    and its return after the task is completed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们运行的每个play都假设所有任务都按顺序在库存中的每个主机上执行。但是，如果您需要在不同的主机上运行一个或两个任务怎么办？例如，我们已经谈到了在集群上自动升级的概念。但是从逻辑上讲，我们希望自动化整个过程，包括从负载平衡器中逐个删除每个主机并在任务完成后将其返回。
- en: 'Although we still want to run our play across our entire inventory, we certainly
    don''t want to run the load balancer commands from those hosts. Let''s once again
    explain this in more detail with a practical example. We''ll reuse the two simple host
    inventories that we used earlier in this chapter:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们仍然希望在整个清单上运行我们的play，但我们肯定不希望从这些主机上运行负载均衡器命令。让我们再次通过一个实际示例详细解释这一点。我们将重用本章前面使用的两个简单主机清单：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, to work on this, let''s create two simple shell scripts in the same directory
    as our playbook. These are only examples as setting up a load balancer is beyond
    the scope of this book. However, imagine that you have a shell script (or other
    executables) that you can call that can add and remove hosts to and from a load
    balancer:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在与我们的playbook相同的目录中创建两个简单的shell脚本来处理这个问题。这只是示例，因为设置负载均衡器超出了本书的范围。但是，请想象您有一个可以调用的shell脚本（或其他可执行文件），可以将主机添加到负载均衡器中并从中删除：
- en: 'For our example, let''s create a script called `remove_from_loadbalancer.sh`,
    which will contain the following:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的示例，让我们创建一个名为`remove_from_loadbalancer.sh`的脚本，其中包含以下内容：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will also create a script called `add_to_loadbalancer.sh`, which will contain
    the following:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将创建一个名为`add_to_loadbalancer.sh`的脚本，其中包含以下内容：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Obviously, in a real-world example, there would be much more code in these scripts!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在实际示例中，这些脚本中会有更多的代码！
- en: 'Now, let''s create a playbook that will perform the logic we outlined here.
    We''ll first create a very simple play definition (you are free to experiment
    with the `serial` and `max_fail_percentage` directives as you wish) and an initial
    task:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个playbook，执行我们在这里概述的逻辑。我们首先创建一个非常简单的play定义（您可以自由地尝试`serial`和`max_fail_percentage`指令），以及一个初始任务：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice the task structure—most of it will be familiar to you. We are using the
    `command` module to call the script we created earlier, passing the hostname from
    the inventory being removed from the load balancer to the script. We use the `chdir`
    argument with the `playbook_dir` magic variable to tell Ansible that the script
    is to be run from the same directory as the playbook.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意任务结构——大部分内容对您来说应该很熟悉。我们使用`command`模块调用我们之前创建的脚本，将从要从负载均衡器中移除的清单中的主机名传递给脚本。我们使用`chdir`参数和`playbook_dir`魔术变量告诉Ansible脚本要从与playbook相同的目录中运行。
- en: The special part of this task is the `delegate_to` directive, which tells Ansible
    that even though we're iterating through an inventory that doesn't contain `localhost`,
    we should run this action on `localhost` (we aren't copying the script to our
    remote hosts, so it won't run if we attempt to run it from there).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务的特殊之处在于`delegate_to`指令，它告诉Ansible，即使我们正在遍历一个不包含`localhost`的清单，我们也应该在`localhost`上运行此操作（我们没有将脚本复制到远程主机，因此如果我们尝试从那里运行它，它将不会运行）。
- en: 'After this, we add a task where the upgrade work is carried out. This task
    has no `delegate_to` directive, and so it is actually run on the remote host from
    the inventory (as desired):'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们添加一个任务，其中进行升级工作。这个任务没有`delegate_to`指令，因此实际上是在清单中的远程主机上运行的（这是我们想要的）：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we add the host back to the load balancer using the second script
    we created earlier. This task is almost identical to the first:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用我们之前创建的第二个脚本将主机重新添加到负载均衡器。这个任务几乎与第一个任务相同：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s see this playbook in action:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看这个playbook的运行情况：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice how even though Ansible is working through the inventory (which doesn't
    feature `localhost`), the load balancer-related scripts are actually run from
    `localhost`, while the upgrade task is performed directly on the remote host.
    This, of course, isn't the only thing you can do with task delegation, but it's
    a common example of a way that it can help you.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使Ansible正在通过清单（其中不包括`localhost`）工作，与负载均衡器相关的脚本实际上是从`localhost`运行的，而升级任务是直接在远程主机上执行的。当然，这并不是您可以使用任务委派的唯一方式，但这是一个常见的例子，说明了它可以帮助您的一种方式。
- en: In truth, you can delegate any task to `localhost`, or even another non-inventory
    host. You could, for example, run an `rsync` command delegated to `localhost`
    to copy files to remote hosts using a similar task definition to the previous
    one. This is useful because although Ansible has a `copy` module, it can't perform
    the advanced recursive `copy` and `update` functions that `rsync` is capable of.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，您可以将任何任务委派给`localhost`，甚至是另一个非清单主机。例如，您可以委派一个`rsync`命令给`localhost`，使用类似于前面的任务定义来将文件复制到远程主机。这很有用，因为尽管Ansible有一个`copy`模块，但它无法执行`rsync`能够执行的高级递归`copy`和`update`功能。
- en: 'Also, note that you can choose to use a form of shorthand notation in your
    playbooks (and roles) for `delegate_to`, called `local_action`. This allows you
    to specify a task on a single line that would ordinarily be run with `delegate_to:
    localhost` added below it. Wrapping this all up into a second example, our playbook
    will look as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '另外，请注意，您可以选择在您的playbooks（和roles）中使用一种速记符号表示`delegate_to`，称为`local_action`。这允许您在单行上指定一个任务，该任务通常会在其下方添加`delegate_to:
    localhost`来运行。将所有这些内容整合到第二个示例中，我们的playbook将如下所示：'
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding shorthand notation is equivalent to the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上述速记符号等同于以下内容：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we run this playbook, we can see that `local_action` does indeed run `rsync`
    from `localhost`, enabling us to efficiently copy whole directory trees across
    to remote servers in the inventory:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个playbook，我们可以看到`local_action`确实从`localhost`运行了`rsync`，使我们能够高效地将整个目录树复制到清单中的远程服务器上：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This concludes our look at task delegation, although as stated, these are just
    two common examples. I'm sure you can think up some more advanced use cases for
    this capability. Let's continue looking at controlling the flow of Ansible code
    by proceeding, in the next section, to look at the special `run_once` option.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对任务委派的讨论，尽管如前所述，这只是两个常见的例子。我相信您可以想出一些更高级的用例来使用这个功能。让我们继续通过在下一节中查看特殊的`run_once`选项来控制Ansible代码的流程。
- en: Using the run_once option
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`run_once`选项
- en: When working with clusters, you will sometimes encounter a task that should
    only be executed once for the entire cluster. For example, you might want to upgrade
    the schema of a clustered database or issue a command to reconfigure a Pacemaker
    cluster that would normally be issued on one node and replicated to all other
    nodes by Pacemaker. You could, of course, address this with a special inventory
    with only one host in it, or even by writing a special play that references one
    host from the inventory, but this is inefficient and starts to make your code
    fragmented.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理集群时，有时会遇到一项任务，应该只对整个集群执行一次。例如，你可能想要升级集群数据库的模式，或者发出一个重新配置Pacemaker集群的命令，这通常会在一个节点上发出，并由Pacemaker复制到所有其他节点。当然，你可以通过一个特殊的只有一个主机的清单来解决这个问题，或者甚至通过编写一个特殊的play来引用清单中的一个主机，但这是低效的，并且开始使你的代码变得分散。
- en: 'Instead, you can write your code as you normally would, but make use of the
    special `run_once` directive for any tasks you want to run only once on your inventory.
    For example, let''s reuse the 10-host inventory that we defined earlier in this
    chapter. Now, let''s proceed to demonstrate this option, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以像平常一样编写你的代码，但是利用特殊的`run_once`指令来运行你想要在你的清单上只运行一次的任务。例如，让我们重用本章前面定义的包含10个主机的清单。现在，让我们继续演示这个选项，如下所示：
- en: 'Create the simple playbook as in the following code block. We''re using a debug
    statement to display some output, but in real life, you would insert your script
    or command that performs your one-off cluster function here (for example, upgrading
    a database schema):'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照下面的代码块创建简单的playbook。我们使用一个debug语句来显示一些输出，但在现实生活中，你可以插入你的脚本或命令来执行你的一次性集群功能（例如，升级数据库模式）：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let''s run this playbook and see what happens:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行这个playbook，看看会发生什么：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice that, just as desired, although the playbook was run on all 10 hosts
    (and, indeed, gathered facts from all 10 hosts), we only ran the upgrade task
    on one host.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，正如所期望的那样，尽管playbook在所有10个主机上运行了（并且确实从所有10个主机收集了信息），我们只在一个主机上运行了升级任务。
- en: 'It''s important to note that the `run_once` option applies per batch of servers,
    so if we add `serial: 5` to our play definition (running our play in two batches
    of 5 on our inventory of 10 servers), the schema upgrade task actually runs twice!
    It runs once as requested, but once per batch of servers, not once for the entire
    inventory. Be careful of this nuance when working with this directive in a clustered
    environment.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '重要的是要注意，`run_once`选项适用于每批服务器，因此如果我们在我们的play定义中添加`serial: 5`（在我们的10台服务器清单上以5台服务器的两批运行我们的play），模式升级任务实际上会运行两次！它按照要求运行一次，但是每批服务器运行一次，而不是整个清单运行一次。在处理这个指令时，要注意这个细微差别。'
- en: 'Add `serial: 5` to your play definition and rerun the playbook. The output
    should appear as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '将`serial: 5`添加到你的play定义中，并重新运行playbook。输出应该如下所示：'
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is how the `run_once` option is designed to work—you can observe, in the
    preceding output, that our schema upgrade ran twice, which is probably not something
    we wanted! However, with this awareness, you should be able to take advantage
    of this option to control your playbook flow across clusters and still achieve
    the results you want. Let's now move away from cluster-related Ansible tasks and
    look at the subtle but important difference between running playbooks locally
    and running them on `localhost`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`run_once`选项设计的工作原理 - 你可以观察到，在前面的输出中，我们的模式升级运行了两次，这可能不是我们想要的！然而，有了这个意识，你应该能够利用这个选项来控制你的playbook流程跨集群，并且仍然实现你想要的结果。现在让我们远离与集群相关的Ansible任务，来看一下在本地运行playbook和在`localhost`上运行playbook之间微妙但重要的区别。
- en: Running playbooks locally
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地运行playbook
- en: It is important to note that when we talk about running a playbook locally with
    Ansible, it is not the same as talking about running it on `localhost`. If we
    run a playbook on `localhost`, Ansible actually sets up an SSH connection to `localhost`
    (it doesn't differentiate its behavior or attempt to detect whether a host in
    the inventory is local or remote—it simply tries faithfully to connect).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当我们谈论使用Ansible在本地运行playbook时，这并不等同于在`localhost`上运行它。如果我们在`localhost`上运行playbook，Ansible实际上会建立一个到`localhost`的SSH连接（它不区分其行为，也不尝试检测清单中的主机是本地还是远程
    - 它只是忠实地尝试连接）。
- en: 'Indeed, we can try creating a `local` inventory file with the following contents:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以尝试创建一个包含以下内容的`local`清单文件：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, if we attempt to run the `ping` module in an ad hoc command against this
    inventory, we see the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试对这个清单运行一个ad hoc命令中的`ping`模块，我们会看到以下内容：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, Ansible set up an SSH connection that needed the host key to
    validate, as well as our SSH password. Now, although you could add the host key
    (as we did in the preceding code block), add key-based SSH authentication to your
    `localhost`, and so on, there is a more direct way of doing this.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Ansible建立了一个需要主机密钥验证的SSH连接，以及我们的SSH密码。尽管你可以添加主机密钥（就像我们在前面的代码块中所做的那样），为你的`localhost`添加基于密钥的SSH身份验证等等，但有一种更直接的方法来做到这一点。
- en: 'We can now modify our inventory so that it looks as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以修改我们的清单，使其如下所示：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We've added a special variable to our `localhost` entry—the `ansible_connection`
    variable—which defines which protocol is used to connect to this inventory host.
    So, we have told it to use a direct local connection instead of an SSH-based connectivity
    (which is the default).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`localhost`条目中添加了一个特殊的变量 - `ansible_connection`变量 - 它定义了用于连接到这个清单主机的协议。因此，我们告诉它使用直接的本地连接，而不是SSH连接（这是默认值）。
- en: 'It should be noted that this special value for the `ansible_connection` variable
    actually overrides the hostname you have put in your inventory. So, if we change
    our inventory to look as follows, Ansible will not even attempt to connect to
    the remote host called `frt01.example.com—`it will connect locally to the machine
    running the playbook (without SSH):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，`ansible_connection`变量的这个特殊值实际上覆盖了您在清单中放置的主机名。因此，如果我们将我们的清单更改为如下所示，Ansible甚至不会尝试连接到名为`frt01.example.com`的远程主机，它将在本地连接到运行playbook的机器（不使用SSH）：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can demonstrate this very simply. Let''s first check for the absence of
    a test file in our local `/tmp` directory:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非常简单地演示这一点。让我们首先检查一下我们本地`/tmp`目录中是否缺少一个测试文件：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s run an ad hoc command to touch this file on all hosts in the new
    inventory we just defined:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行一个临时命令，在我们刚刚定义的新清单中的所有主机上触摸这个文件：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The command ran successfully, so let''s see whether the test file is present
    on the local machine:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 命令成功运行，现在让我们看看本地机器上是否存在测试文件：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It is! So, the ad hoc command did not attempt to connect to `frt01.example.com`,
    even though this host name was in the inventory. The presence of `ansible_connection=local`
    meant that this command was run on the local machine without using SSH.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！因此，临时命令并没有尝试连接到`frt01.example.com`，即使这个主机名在清单中。`ansible_connection=local`的存在意味着这个命令在本地机器上运行，而不使用SSH。
- en: This ability to run commands locally without the need to set up SSH connectivity,
    SSH keys, and so on can be incredibly valuable, especially if you need to get
    things up and running quickly on your local machine. With this complete, let's
    take a look at how you can work with proxies and jump hosts using Ansible.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地运行命令而无需设置SSH连接、SSH密钥等，这种能力可能非常有价值，特别是如果您需要在本地机器上快速启动和运行。完成后，让我们看看如何使用Ansible处理代理和跳转主机。
- en: Working with proxies and jump hosts
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代理和跳转主机
- en: 'Often, when it comes to configuring core network devices, these are isolated
    from the main network via a proxy or jump host. Ansible lends itself well to automating
    network device configuration as most of it is performed over SSH: however, this
    is only helpful in a scenario where Ansible can either be installed and operated
    from the jump host—or, better yet, can operate via a host such as this.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在配置核心网络设备时，这些设备通过代理或跳转主机与主网络隔离。Ansible非常适合自动化网络设备配置，因为大部分操作都是通过SSH执行的：然而，这只在Ansible可以安装和从跳转主机操作的情况下才有帮助，或者更好的是可以通过这样的主机操作。
- en: Fortunately, Ansible can do exactly that. Let's assume that you have two Cumulus
    Networks switches in your network (these are based on a special distribution of
    Linux for switching hardware, which is very similar to Debian). These two switches
    have the `cmls01.example.com` and `cmls02.example.com` hostnames, but both can
    only be accessed from a host called `bastion.example.com`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Ansible确实可以做到这一点。假设您的网络中有两个Cumulus Networks交换机（这些基于Linux的特殊分发用于交换硬件，非常类似于Debian）。这两个交换机分别具有`cmls01.example.com`和`cmls02.example.com`的主机名，但都只能从名为`bastion.example.com`的主机访问。
- en: 'The configuration to support our `bastion` host is performed in the inventory,
    rather than in the playbook. We begin by defining an inventory group with the
    switches in, in the normal manner:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 支持我们的`bastion`主机的配置是在清单中进行的，而不是在playbook中。我们首先按照正常方式定义一个包含交换机的清单组：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, we can now start to get clever by adding some special SSH arguments
    into the inventory variables for this group. Add the following code to your inventory
    file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在我们可以开始变得聪明起来，通过在清单变量中添加一些特殊的SSH参数来实现。将以下代码添加到您的清单文件中：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This special variable content tells Ansible to add extra options when it sets
    up an SSH connection, including to proxy via the `bastion.example.com` host. The
    `-W %h:%p` options tell SSH to proxy the connection and to connect to the host
    specified by `%h` (this is either `cmls01.example.com` or `cmls02.example.com`)
    on the port specified by `%p` (usually port `22`).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特殊的变量内容告诉Ansible在设置SSH连接时添加额外的选项，包括通过`bastion.example.com`主机进行代理。`-W %h:%p`选项告诉SSH代理连接，并连接到由`%h`指定的主机（这通常是`cmls01.example.com`或`cmls02.example.com`），在由`%p`指定的端口上（通常是端口`22`）。
- en: 'Now, if we attempt to run the Ansible `ping` module against this inventory,
    we can see whether it works:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试对这个清单运行Ansible的`ping`模块，我们可以看到它是否有效：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You will notice that we can't actually see any differences in Ansible's behavior
    from the command-line output. On the surface, Ansible works just as it normally
    does and connects successfully to the two hosts. However, behind the scenes it
    proxies via `bastion.example.com`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，我们实际上无法在命令行输出中看到Ansible行为上的任何差异。表面上，Ansible的工作方式与平常一样，并且成功连接到了两个主机。然而，在幕后，它通过`bastion.example.com`进行代理。
- en: Note that this simple example assumes that you are connecting to both the `bastion`
    host and `switches` using the same username and SSH credentials (or in this case,
    keys). There are ways to provide separate credentials for both variables, but
    this involves more advanced usage of OpenSSH, which is beyond the scope of this
    book. However, this section intends to give you a starting point and demonstrate
    the possibility of this, and you are free to explore OpenSSH proxying by yourself.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个简单的例子假设您使用相同的用户名和SSH凭据（或在这种情况下，密钥）连接到`bastion`主机和`switches`。有方法可以为这两个变量提供单独的凭据，但这涉及到更高级的OpenSSH使用，这超出了本书的范围。然而，本节旨在给您一个起点，并演示这种可能性，您可以自行探索OpenSSH代理。
- en: Let's now change track  and explore how it is possible to set up Ansible to
    prompt you for data during a playbook run.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们改变方向，探讨如何设置Ansible在playbook运行期间提示您输入数据的可能性。
- en: Configuring playbook prompts
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置playbook提示
- en: So far, all of our playbooks have had their data specified for them at run time
    in variables we defined within the playbook. However, what if you actually want
    to obtain information from someone during a playbook run? Perhaps you want a user
    to select a version of a package to install? Or, perhaps you want to obtain a
    password from a user for an authentication task without storing it anywhere. (Although
    Ansible Value can encrypt the data at rest, some companies may forbid the storing
    of passwords and other such credentials in tools that they have not evaluated.)
    Fortunately for these instances (and many more), Ansible can prompt you for user
    input and store the input in a variable for future processing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的playbook都是在其中为它们指定的数据在运行时在playbook中定义的变量中。然而，如果您在playbook运行期间实际上想要从某人那里获取信息怎么办？也许您希望用户选择要安装的软件包的版本？或者，也许您希望从用户那里获取密码，以用于身份验证任务，而不将其存储在任何地方。（尽管Ansible
    Value可以加密静态数据，但一些公司可能禁止在他们尚未评估的工具中存储密码和其他凭据。）幸运的是，对于这些情况（以及许多其他情况），Ansible可以提示您输入用户输入，并将输入存储在变量中以供将来处理。
- en: 'Let''s reuse the two host frontend inventories we defined at the beginning
    of this chapter. Now, let''s demonstrate how to capture data from users during
    a playbook run with a practical example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重用本章开头定义的两个主机前端清单。现在，让我们通过一个实际的例子演示如何在playbook运行期间从用户那里获取数据：
- en: 'Create a simple play definition in the usual manner, as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以通常的方式创建一个简单的play定义，如下所示：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we''ll add a special section to the play definition. We previously defined
    a `vars` section, but this time we will define one called `vars_prompt` (which
    enables you to do just that—define variables through user prompts). In this section,
    we will prompt for two variables—one for a user ID and one for a password. One
    will be echoed to the screen, while the other won''t be, by setting `private:
    yes`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，我们将在play定义中添加一个特殊的部分。我们之前定义了一个`vars`部分，但这次我们将定义一个叫做`vars_prompt`的部分（它使您能够通过用户提示定义变量）。在这个部分，我们将提示两个变量——一个是用户ID，一个是密码。一个将被回显到屏幕上，而另一个不会，通过设置`private:
    yes`：'
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We''ll now add a single task to our playbook to demonstrate this prompting
    process of setting the variables:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将向我们的playbook添加一个任务，以演示设置变量的提示过程：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s run the playbook and see how it behaves:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行playbook并看看它的行为：
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, we are prompted for both variables, yet the password is not
    echoed to the terminal, which is important for security reasons. We can then make
    use of the variables later in the playbook. Here, we just used a simple `debug`
    command to demonstrate that the variables have been set; however, you would instead
    implement an actual authentication function in place of this.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们提示输入两个变量，但密码没有回显到终端，这对于安全原因很重要。然后我们可以在playbook中稍后使用这些变量。在这里，我们只是使用一个简单的`debug`命令来演示变量已经设置；然而，您可以在此处实现一个实际的身份验证功能，而不是这样做。
- en: With this complete, let's proceed to the next section and look at how you can
    selectively run your tasks from within your plays with the use of tags.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，让我们继续下一节，看看如何通过标记有选择地运行play中的任务。
- en: Placing tags in the plays and tasks
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在play和任务中放置标记
- en: We have discussed, at many points in this book, that as your confidence and
    experience with Ansible grows, it is likely that your playbooks will grow in size,
    scale, and complexity. While this is undoubtedly a good thing, there may be times
    when you only want to run a subset of a playbook, rather than running it from
    beginning to end. We have discussed how to conditionally run tasks based on the
    value of a variable or fact, but is there a way we can run them on the basis of
    a selection made at the time that the playbook is run?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的许多部分，我们已经讨论过，随着您对Ansible的信心和经验的增长，您的playbook可能会在大小、规模和复杂性上增长。虽然这无疑是一件好事，但有时您可能只想运行playbook的一个子集，而不是从头到尾运行它。我们已经讨论了如何根据变量或事实的值有条件地运行任务，但是否有一种方法可以根据在运行playbook时做出的选择来运行它们？
- en: 'Tags in Ansible plays are the solution to this, and in this section we will
    build a simple playbook with two tasks—each bearing a different tag—to show you
    how tags work. We will work with the two simple host inventories that we worked
    with previously:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible play中的标记是解决这个问题的方法，在本节中，我们将构建一个简单的playbook，其中包含两个任务——每个任务都有一个不同的标记，以向您展示标记的工作原理。我们将使用之前使用过的两个简单主机清单：
- en: 'Create the following simple playbook to perform two tasks—one to install the
    `nginx` package and the other to deploy a configuration file from a template:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下简单的playbook来执行两个任务——一个是安装`nginx`包，另一个是从模板部署配置文件：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let''s run the playbook in the usual manner, but with one difference—this
    time, we''ll add the `--tags` switch to the command line. This switch tells Ansible
    to only run the tasks that have tags matching the ones that are specified. So,
    for example, run the following command:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们以通常的方式运行playbook，但有一个区别——这一次，我们将在命令行中添加`--tags`开关。这个开关告诉Ansible只运行与指定标记匹配的任务。例如，运行以下命令：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Notice that the task to deploy the configuration file doesn't run. This is because
    it is tagged with `customize` and we did not specify this tag when running the
    playbook.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，部署配置文件的任务没有运行。这是因为它被标记为`customize`，而我们在运行playbook时没有指定这个标记。
- en: 'There is also a `--skip-tags` switch that does the reverse of the previous
    switch—it tells Ansible to skip the tags listed. So, if we run the playbook again
    but skip the `customize` tag, we should see an output similar to the following:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一个`--skip-tags`开关，它与前一个开关相反——它告诉Ansible跳过列出的标记。因此，如果我们再次运行playbook但跳过`customize`标记，我们应该会看到类似以下的输出：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This play run is identical because, rather than including only the `install`-tagged
    tasks, we skipped the tasks tagged with `customize`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个play运行是相同的，因为我们跳过了标记为`customize`的任务，而不是只包括`install`标记的任务。
- en: Note that if you don't specify either `--tags` or `--skip-tags`, then all the
    tasks are run, regardless of their tag.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您不指定`--tags`或`--skip-tags`，则所有任务都会运行，而不管它们的标记如何。
- en: A few notes about tags—first of all, each task can have more than one tag, so
    we see them specified in a YAML list format. If you use the `--tags` switch, a
    task will run if any of it's tags match the tag that was specified on the command
    line. Secondly, tags can be reused, so we could have five tasks that are all tagged
    `install`, and all five tasks would be performed or skipped if you requested them
    to do so via `--tags` or `--skip-tags`, respectively.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 关于标签的一些说明——首先，每个任务可以有多个标签，因此我们看到它们以YAML列表格式指定。如果使用`--tags`开关，如果任何一个标签与命令行上指定的标签匹配，任务将运行。其次，标签可以被重复使用，因此我们可以有五个被全部标记为`install`的任务，如果您通过`--tags`或`--skip-tags`要求执行它们，所有五个任务都将被执行或跳过。
- en: 'You can also specify more than one tag on the command line, running all the
    tasks that match any of the specified tags. Although the logic behind tags is
    relatively simple, it can take a little while to get used to it and the last thing
    you want to do is run your playbook on real hosts to check whether you understand
    tagging! A great way to figure this out is to add `--list-tasks` to your command,
    which—rather than running the playbook—lists the tasks from the playbook that
    would perform if you run it. Some examples are provided for you in the following
    code block, based on the example playbook we just created:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在命令行上指定多个标签，运行与任何指定标签匹配的所有任务。尽管标签背后的逻辑相对简单，但可能需要一点时间来适应它，而您最不希望做的事情就是在真实主机上运行playbook，以检查您是否理解标签！了解这一点的一个很好的方法是在您的命令中添加`--list-tasks`，这样—而不是运行playbook—会列出playbook中将要执行的任务。以下代码块为您提供了一些示例，基于我们刚刚创建的示例playbook：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, not only does `--list-tasks` show you which tasks would run,
    it also shows you which tags are associated with them, which helps you further
    understand how tagging works and ensure that you achieve the playbook flow that
    you wanted. Tags are an incredibly simple yet powerful way to control which parts
    of your playbook run and often when it comes to creating and maintaining large
    playbooks, it is better to be able to run only selected parts of the playbook
    at once. From here, we will move on to the final section of this chapter, where
    we will look at securing your variable data at rest by encrypting it with Ansible
    Vault.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`--list-tasks`不仅会显示哪些任务将运行，还会显示与它们关联的标签，这有助于您进一步理解标签的工作方式，并确保您实现了所需的playbook流程。标签是一种非常简单但强大的控制playbook中哪些部分运行的方法，通常在创建和维护大型playbook时，最好能够一次只运行所选部分的playbook。从这里开始，我们将继续进行本章的最后一部分，我们将看看如何通过使用Ansible
    Vault对变量数据进行加密来保护您的静止状态下的变量数据。
- en: Securing data with Ansible Vault
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible Vault保护数据
- en: Ansible Vault is a tool included with Ansible that allows you to encrypt your
    sensitive data at rest, while also using it in a playbook. Often, it is necessary
    to store login credentials or other sensitive data in a variable to allow a playbook
    to run unattended. However, this risks exposing your data to people who might
    use it with malicious intent. Fortunately, Ansible Vault secures your data at
    rest using AES-256 encryption, meaning your sensitive data is safe from prying
    eyes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Vault是Ansible附带的一个工具，允许您在静止状态下加密敏感数据，同时在playbook中使用它。通常，需要将登录凭据或其他敏感数据存储在变量中，以允许playbook无人值守运行。然而，这会使您的数据面临被恶意使用的风险。幸运的是，Ansible
    Vault使用AES-256加密在静止状态下保护您的数据，这意味着您的敏感数据不会被窥探。
- en: 'Let''s proceed with a simple example that shows you how you can use Ansible
    Vault:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行一个简单的示例，向您展示如何使用Ansible Vault：
- en: 'Start by creating a new vault to store sensitive data in; we''ll call this
    file `secret.yml`. You can create this using the following command:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个新的保险库来存储敏感数据；我们将称这个文件为`secret.yml`。您可以使用以下命令创建这个文件：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Enter the password you have chosen for the vault when prompted and confirm it
    by entering it a second time (the vault that accompanies this book on GitHub is
    encrypted with the `secure` password).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示时输入您为保险库选择的密码，并通过第二次输入来确认它（本书在GitHub上附带的保险库是用`secure`密码加密的）。
- en: 'When you have entered the password, you will be set to your normal editor (defined
    by the `EDITOR` shell variable). On my test system, this is `vi`. Within this
    editor, you should create a `vars` file, in the normal manner, containing your
    sensitive data:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您输入密码后，您将被设置为您的正常编辑器（由`EDITOR` shell变量定义）。在我的测试系统中，这是`vi`。在这个编辑器中，您应该以正常的方式创建一个`vars`文件，其中包含您的敏感数据：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Save and exit the editor (press *Esc*, then `:wq` in `vi`). You will exit to
    the shell. Now, if you look at the contents of your file, you will see that they
    are encrypted and are safe from anyone who shouldn''t be able to read the file:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并退出编辑器（在`vi`中按*Esc*，然后输入`:wq`）。您将退出到shell。现在，如果您查看文件的内容，您会发现它们已经被加密，对于任何不应该能够读取文件的人来说是安全的：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'However, the great thing about Ansible Vault is that you can use this encrypted
    file in a playbook as if it were a normal `variables` file (although, obviously,
    you have to tell Ansible your vault password). Let''s create a simple playbook
    as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，Ansible Vault的伟大之处在于，您可以在playbook中像使用普通的`variables`文件一样使用这个加密文件（尽管显然，您必须告诉Ansible您的保险库密码）。让我们创建一个简单的playbook，如下所示：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `vars_files` directive is used in exactly the same way as it would be if
    you were using an unencrypted `variables` file. Ansible reads the headers of the
    `variables` files at run time and determines whether they are encrypted or not.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`vars_files`指令的使用方式与使用未加密的`variables`文件时完全相同。Ansible在运行时读取`variables`文件的头，并确定它们是否已加密。'
- en: 'Try running the playbook without telling Ansible what the vault password is—in
    this instance, you should receive an error such as this:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在不告诉Ansible保险库密码的情况下运行playbook——在这种情况下，您应该会收到类似于这样的错误：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Ansible correctly understands that we are trying to load a `variables` file
    that is encrypted with `ansible-vault`, but we must manually tell it the password
    for it to proceed. There are a number of ways of specifying passwords for vaults
    (more on this in a minute), but for simplicity, try running the following command
    and enter your vault password when prompted:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible正确地理解我们正在尝试加载使用`ansible-vault`加密的`variables`文件，但我们必须手动告诉它密码才能继续。有多种指定vault密码的方法（稍后会详细介绍），但为了简单起见，请尝试运行以下命令，并在提示时输入您的vault密码：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Success! Ansible decrypted our vault file and loaded the variables into the
    playbook, which we can see from the `debug` statement we created. Naturally, this
    defeats the purpose of using a vault, but it makes for a nice example.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！Ansible解密了我们的vault文件，并将变量加载到了playbook中，我们可以从我们创建的`debug`语句中看到。当然，这违背了使用vault的目的，但这是一个很好的例子。
- en: This is a very simple example of what you can do with vaults. There are multiple
    ways that you can specify passwords; you don't have to be prompted for them on
    the command line—they can be provided either by a plain text file that contains
    the vault password or via a script that could obtain the password from a secure
    location at run time (think of a dynamic inventory script, only for returning
    a password rather than a hostname). The `ansible-vault` tool itself can also be
    used to edit, view, and change the passwords in a vault file, or even decrypt
    it and turn it back into plain text. The user guide for Ansible Vault is a great
    place to start for more information ([https://docs.ansible.com/ansible/latest/user_guide/vault.html](https://docs.ansible.com/ansible/latest/user_guide/vault.html)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用vault的一个非常简单的例子。您可以指定密码的多种方式；您不必在命令行上提示输入密码-可以通过包含vault密码的纯文本文件提供，也可以通过脚本在运行时从安全位置获取密码（考虑一个动态清单脚本，只返回密码而不是主机名）。`ansible-vault`工具本身也可以用于编辑、查看和更改vault文件中的密码，甚至解密并将其转换回纯文本。Ansible
    Vault的用户指南是获取更多信息的绝佳起点（[https://docs.ansible.com/ansible/latest/user_guide/vault.html](https://docs.ansible.com/ansible/latest/user_guide/vault.html)）。
- en: 'One thing to note is that you don''t actually have to have a separate vault
    file for your sensitive data; you can actually include it inline in your playbook.
    For example, let''s try re-encrypting our sensitive data for inclusion in an otherwise
    unencrypted playbook (again, use the `secure` password for the vault if you are
    testing the examples from the GitHub repository accompanying this book). Run the
    following command in your shell (it should produce an output similar to what is
    shown):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，您实际上不必为敏感数据单独创建vault文件；您实际上可以将其内联包含在playbook中。例如，让我们尝试重新加密我们的敏感数据，以便包含在一个否则未加密的playbook中（再次使用`secure`密码作为vault的密码，如果您正在测试本书附带的GitHub存储库中的示例，请运行以下命令在您的shell中（它应该产生类似于所示的输出）：
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can copy and paste the output of this command into a playbook. So, if we
    modify our earlier example, it would appear as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此命令的输出复制并粘贴到playbook中。因此，如果我们修改我们之前的例子，它将如下所示：
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, when you run this playbook in exactly the same manner as we did before
    (specifying the vault password using a user prompt), you should see that it runs
    just as when we used an external encrypted `variables` file:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您以与之前完全相同的方式运行此playbook（使用用户提示指定vault密码）时，您应该看到它的运行方式与我们使用外部加密的`variables`文件时一样：
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Ansible Vault is a powerful and versatile tool for encrypting your sensitive
    playbook data at rest and should enable you (with a little care) to run most of
    your playbooks unattended without ever leaving passwords or other sensitive data
    in the clear. That concludes this section and this chapter; I hope that it has
    been useful for you.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Vault是一个强大而多功能的工具，可以在静止状态下加密您的敏感playbook数据，并且（只要小心）应该使您能够在不留下密码或其他敏感数据的情况下无人值守地运行大部分playbook。这就结束了本节和本章；希望对您有所帮助。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Ansible has many advanced features that allow you to run your playbooks in a
    variety of scenarios, whether that is upgrading a cluster of servers in a controlled
    manner; working with devices on a secure, isolated network; or controlling your
    playbook flow with prompts and tags. Ansible has been adopted by a large and ever-growing
    user base and, as such, is designed and evolved around solving real-world problems.
    Most of the advanced features of Ansible we discussed are centered around exactly
    this—solving real-world problems.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible具有许多高级功能，可以让您在各种场景中运行playbook，无论是在受控方式下升级服务器集群，还是在安全的隔离网络上使用设备，或者通过提示和标记来控制playbook流程。Ansible已被大量且不断增长的用户群体采用，因此它的设计和演变都是围绕解决现实世界问题而展开的。我们讨论的大多数Ansible的高级功能都是围绕着解决现实世界问题展开的。
- en: In this chapter, you learned about running tasks asynchronously in Ansible,
    before looking at the various features available for running playbooks to upgrade
    a cluster, such as running tasks on small batches of inventory hosts, failing
    a play early if a certain percentage of hosts fail, delegating tasks to a specific
    host, and even running tasks once, regardless of your inventory (or batch) size.
    You also learned about the difference between running playbooks locally as opposed
    to on `localhost` and how to use SSH-proxying to automate tasks on an isolated
    network via a `bastion` host. Finally, you learned about handling sensitive data
    without storing it unencrypted at rest, either through prompting the user at run
    time or through the use of Ansible Vault. You even learned about running a subset
    of your playbook tasks with tagging.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何在Ansible中异步运行任务，然后了解了运行playbook升级集群的各种功能，例如在小批量清单主机上运行任务，如果一定比例的主机失败则提前失败，将任务委派给特定主机，甚至无论清单（或批量）大小如何都运行任务一次。您还学习了在本地运行playbook与在`localhost`上运行playbook之间的区别，以及如何使用SSH代理自动化在`堡垒`主机上的隔离网络上的任务。最后，您学习了如何处理敏感数据，而不是以未加密的形式存储它，可以通过在运行时提示用户或使用Ansible
    Vault来实现。您甚至学习了如何使用标记来运行playbook任务的子集。
- en: In the next chapter, we will explore a topic we touched on briefly in this chapter in
    more detail—automating network device management with Ansible.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地探讨我们在本章中简要提到的一个主题 - 使用Ansible自动化网络设备管理。
- en: Questions
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which parameter allows you to configure the maximum number of hosts in a batch
    that will fail before a play is aborted?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个参数允许您配置在批处理中失败的最大主机数，然后播放被中止？
- en: A) `percentage`
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: A）`百分比`
- en: B) `max_fail`
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: B）`最大失败`
- en: C) `max_fail_percentage`
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: C）`最大失败百分比`
- en: D) `max_percentage`
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: D）`最大百分比`
- en: E) `fail_percentage`
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: E）`失败百分比`
- en: 'True or false – you can use the `--connect=local` parameter to run any playbooks
    locally without using SSH:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假 - 您可以使用`--connect=local`参数在本地运行任何playbooks而不使用SSH：
- en: A) True
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: A）真
- en: B) False
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: B）假
- en: 'True or false – in order to run a playbook asynchronously, you need to use
    the `async` keyword:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假 - 为了异步运行playbook，您需要使用`async`关键字：
- en: A) True
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: A）真
- en: B) False
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: B）假
- en: Further reading
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you install Passlib, which is a password-hashing library for Python 2 and
    3, `vars_prompt` is encrypted with any crypt scheme (such as `descrypt`, `md5crypt`,
    `sha56_crypt`, and more):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您安装了Passlib，这是Python 2和3的密码哈希库，`vars_prompt`将使用任何加密方案（如`descrypt`，`md5crypt`，`sha56_crypt`等）进行加密：
- en: '[https://passlib.readthedocs.io/en/stable/](https://passlib.readthedocs.io/en/stable/)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://passlib.readthedocs.io/en/stable/](https://passlib.readthedocs.io/en/stable/)'
