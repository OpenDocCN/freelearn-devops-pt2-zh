- en: Consuming and Creating Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用和创建模块
- en: Throughout this book, we have almost constantly referred to and made use of
    Ansible modules. We have treated these as "black boxes" – that is to say, we have
    just accepted that they exist and that they will work in a certain documented
    manner. However, one of the many great things about Ansible is that it is an open
    source product, and as such, not only can you view and modify its source code,
    but you can also write your own additions. To date, there are literally thousands
    of modules available for Ansible, handling everything from simple commands such
    as copying files and installing packages, through to configuring highly complex
    and bespoke networking equipment. This large array of modules has grown out of
    a genuine need to solve problems with Ansible, and the number included with each
    release of Ansible increases every time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们几乎不断地提到并使用Ansible模块。我们把这些模块视为“黑匣子”——也就是说，我们只是接受它们的存在，并且它们将以某种记录的方式工作。然而，关于Ansible的许多伟大之处之一是它是一个开源产品，因此，您不仅可以查看和修改其源代码，还可以编写自己的补充。迄今为止，已经有成千上万的模块可用于Ansible，处理从简单的命令，如复制文件和安装软件包，到配置高度复杂和定制的网络设备。这一大量的模块已经源于使用Ansible解决问题的真正需求，每次发布Ansible时，包含的模块数量都在增加。
- en: Sooner or later, you will come across a specific piece of functionality that
    doesn't exist in any of the current Ansible modules. Of course, you could attempt
    to fill this gap in functionally, either by writing your own module or by contributing
    enhancements to one of the existing modules back to the Ansible project for everyone
    else to benefit from. In this chapter, you will learn the basics of creating your
    own modules, as well as how to contribute your code back to the upstream Ansible
    project if you wish.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 迟早，您会遇到一个特定的功能，它在当前的Ansible模块中不存在。当然，您可以尝试填补这个功能上的空白，要么编写自己的模块，要么为现有模块的增强功能做出贡献，以便其他人也能从Ansible项目中受益。在本章中，您将学习创建自己模块的基础知识，以及如果愿意，如何将您的代码贡献回上游的Ansible项目。
- en: 'Specifically, in this chapter, you will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，您将涵盖以下主题：
- en: Executing multiple modules using the command line
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行执行多个模块
- en: Reviewing the module index
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查模块索引
- en: Accessing module documentation from the command line
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行访问模块文档
- en: Module return values
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块返回值
- en: Developing custom modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发自定义模块
- en: Let's get started!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [Chapter 1](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml), *Getting
    Started with Ansible*, and are using the most recent version available – the examples
    in this chapter were tested with Ansible 2.9\. This chapter also assumes that
    you have at least one additional host to test against. Ideally, this should be
    Linux-based. Although we will give specific examples of hostnames in this chapter,
    you are free to substitute them with your own hostname and/or IP addresses. Details
    of how to do this will be provided in the appropriate places.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假定您已经按照[第1章](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml) *开始使用Ansible*中详细介绍的方式设置了您的控制主机，并且正在使用最新版本——本章的示例是使用Ansible
    2.9进行测试的。本章还假定您至少有一个额外的主机进行测试。理想情况下，这应该是基于Linux的。尽管本章中将给出主机名的具体示例，但您可以自由地用您自己的主机名和/或IP地址替换它们。如何做到这一点的详细信息将在适当的地方提供。
- en: The module development work that will be covered in this chapter assumes the
    presence of a Python 2 or Python 3 development environment on your computer and
    that you are running either Linux, FreeBSD, or macOS. Where additional Python
    modules are needed, their installation is documented. The task of building module
    documentation has some very specific requirements around Python 3.5 or later,
    so you will need to install a suitable Python environment if you wish to attempt
    this.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的模块开发工作假定您的计算机上存在Python 2或Python 3开发环境，并且您正在运行Linux、FreeBSD或macOS。需要额外的Python模块时，它们的安装将被记录。构建模块文档的任务在Python
    3.5或更高版本周围有一些非常具体的要求，因此如果您希望尝试这个任务，您将需要安装一个合适的Python环境。
- en: The code bundle for this chapter is available here: [https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%205](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%205).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包在这里可用：[https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%205](https://github.com/PacktPublishing/Ansible-2-Cookbook/tree/master/Chapter%205)。
- en: Executing multiple modules using the command line
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令行执行多个模块
- en: As this chapter is all about modules and how to create them, let's recap how
    to use modules. We've done this throughout this book, but we have not drawn attention
    to some of the specifics related to how they work. One of the key things we have
    not discussed is how the Ansible engine talks to its modules and vice versa, so
    let's explore this now.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章主要讨论模块以及如何创建它们，让我们回顾一下如何使用模块。我们在整本书中都做过这个，但我们并没有特别关注它们工作的一些具体细节。我们没有讨论的关键事情之一是Ansible引擎如何与其模块进行通信，反之亦然，所以让我们现在来探讨一下。
- en: 'As ever, when working with Ansible commands, we need an inventory to run our
    commands against. For this chapter, as our focus is on the modules themselves,
    we will use a very simple and small inventory, as shown here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与以往一样，当使用Ansible命令时，我们需要一个清单来运行我们的命令。在本章中，由于我们的重点是模块本身，我们将使用一个非常简单和小的清单，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, for the first part of our recap, you can run a module very easily via
    an ad hoc command and use the `-m` switch to tell Ansible which module you want
    to run. Hence, one of the simplest commands you can run is the Ansible `ping` command,
    as shown here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾的第一部分，您可以通过一个临时命令轻松运行一个模块，并使用`-m`开关告诉Ansible您想要运行哪个模块。因此，您可以运行的最简单的命令之一是Ansible的`ping`命令，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, one thing we have not previously looked at is the communication between
    Ansible and its modules; however, let''s examine the output of the preceding command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们之前没有看过的一件事是Ansible和它的模块之间的通信；然而，让我们来检查一下前面命令的输出：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Did you notice the structure of the output – the curly braces, colons, and commas?
    Yes, Ansible uses JSON-formatted data to talk to its modules, and the modules
    report their data back to Ansible in JSON as well. The preceding output is, in
    fact, a subset of the JSON-formatted data returned to the Ansible engine by the
    `ping` module.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到输出的结构了吗 - 大括号、冒号和逗号？是的，Ansible使用JSON格式的数据与它的模块进行通信，模块也将它们的数据以JSON格式返回给Ansible。前面的输出实际上是`ping`模块通过JSON格式的数据结构向Ansible引擎返回的一个子集。
- en: Of course, we never have to worry about this as we work with the modules using
    either `key=value` pairs on the command line or YAML in playbooks and roles. Hence,
    the JSON is shielded from us, but this is an important fact to bear in mind as
    we head into the world of module development later in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们在使用模块时不必担心这一点，可以在命令行上使用`key=value`对或在playbooks和roles中使用YAML。因此，JSON对我们来说是屏蔽的，但这是一个重要的事实，当我们在本章后面进入模块开发的世界时要牢记在心。
- en: Ansible modules are just like functions in a high-level programming language,
    in that they take a well-defined list of arguments as input, perform their function,
    and then provide a set of output data, which is also well-defined and documented.
    We'll look at this in more detail later in this chapter. Of course, the preceding
    command didn't include any arguments, so this was the simplest possible invocation
    of a module via Ansible.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible模块就像高级编程语言中的函数一样，它们接受一组明确定义的参数作为输入，执行它们的功能，然后提供一组输出数据，这些数据也是明确定义和有文档记录的。我们稍后会更详细地看一下这一点。当然，前面的命令没有包括任何参数，所以这是通过Ansible最简单的模块调用。
- en: 'Now, let''s run another command that takes an argument and passes that data
    to the module:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行另一个带有参数的命令，并将数据传递给模块：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this case, we provided a single string as an argument to the command module,
    which Ansible, in turn, converts into JSON and passes down to the command module
    when it''s invoked. When you run this ad hoc command, you will see an output similar
    to the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们向命令模块提供了一个字符串作为参数，然后Ansible将其转换为JSON并传递给命令模块。当你运行这个临时命令时，你会看到类似以下的输出：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this instance, the output data does not appear to be JSON formatted; however,
    what Ansible prints to the Terminal when you run a module is only a subset of
    the data that each module returns – for example, both the `CHANGED` status and
    `rc=0` exit code from our command were passed back to Ansible in a JSON-formatted
    data structure – this was just hidden from us.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出数据似乎不是JSON格式的；然而，当你运行一个模块时，Ansible打印到终端的内容只是每个模块返回的数据的一个子集 - 例如，我们命令的`CHANGED`状态和`rc=0`退出代码都以JSON格式的数据结构传递回Ansible
    - 这只是对我们隐藏了。
- en: 'This point doesn''t need to be labored too much, but it is important to set
    a context. It is this context that we shall build upon throughout this chapter,
    so simply remember these key points:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点不需要过多强调，但设置一个上下文是很重要的。正是这个上下文将贯穿本章的始终，所以只需记住这些关键点：
- en: Communication between Ansible and its modules is done through JSON-formatted
    data structures.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible和它的模块之间的通信是通过JSON格式的数据结构完成的。
- en: Modules take input data that controls how they function (arguments).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块接受控制它们功能的输入数据（参数）。
- en: Modules always return data – at the very least, the status of the module's execution
    (for example, `changed`, `ok`, or `failed`).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块总是返回数据 - 至少是模块执行的状态（例如`changed`、`ok`或`failed`）。
- en: Of course, before you start coding your own modules, it makes sense to check
    whether a module that can perform all (or some) of the functionality you need
    already exists. We will explore this in the next section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在开始编写自己的模块之前，检查是否已经存在可以执行所有（或部分）所需功能的模块是有意义的。我们将在下一节中探讨这一点。
- en: Reviewing the module index
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查模块索引
- en: 'As discussed in the preceding section, Ansible provides thousands of modules
    to make it fast and easy to develop playbooks and run them across multiple host
    machines. How do you go about finding the right module to begin with, though,
    when there are so many? Fortunately, the Ansible documentation features a well-organized,
    categorized list of modules that you can consult to find your desired module – this
    is available here: [https://docs.ansible.com/ansible/latest/modules/modules_by_category.html](https://docs.ansible.com/ansible/latest/modules/modules_by_category.html).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的部分所讨论的，Ansible提供了成千上万的模块，使得快速轻松地开发playbooks并在多个主机上运行它们。然而，当有这么多模块时，你该如何找到合适的模块呢？幸运的是，Ansible文档提供了一个组织良好、分类清晰的模块列表，你可以查阅以找到你需要的模块
    - 可以在这里找到：[https://docs.ansible.com/ansible/latest/modules/modules_by_category.html](https://docs.ansible.com/ansible/latest/modules/modules_by_category.html)。
- en: 'Let''s suppose you want to see whether there is a native Ansible module that
    can help you configure and manage your Amazon Web Services S3 buckets. That''s
    a fairly precise, well-defined need, so let''s approach this in a logical manner:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要查看是否有一个原生的Ansible模块可以帮助你配置和管理你的亚马逊网络服务S3存储桶。这是一个相当明确、明确定义的需求，所以让我们以一种逻辑的方式来处理：
- en: 'Begin by opening the categorized module index in your web browser, as discussed
    previously:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，像之前讨论的那样，在你的网络浏览器中打开分类的模块索引：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we know that Amazon Web Services is almost certainly going to feature in
    the `Cloud` modules category, so let's open that in our browser.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们知道亚马逊网络服务几乎肯定会出现在`Cloud`模块类别中，所以让我们在浏览器中打开它。
- en: 'There are still hundreds, if not thousands, of modules listed on this page!
    So, let''s use the Find function (*Ctrl* + *F*) in the browser to see whether
    the `s3` keyword appears anywhere:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个页面上仍然列出了数百，甚至数千个模块！所以，让我们在浏览器中使用查找功能（*Ctrl* + *F*）来查看`s3`关键字是否出现在任何地方：
- en: '![](Images/dfa7f773-fcca-4f39-ae84-a0ecd968e7e9.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dfa7f773-fcca-4f39-ae84-a0ecd968e7e9.png)'
- en: 'We''re in luck – it does, and there are several more listings further down
    the page:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很幸运-确实如此，并且页面下方还有几个更多的列表：
- en: '![](Images/f0611a81-5115-4749-9a37-ff80186fc8d1.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f0611a81-5115-4749-9a37-ff80186fc8d1.png)'
- en: We now have a shortlist of modules to work with – granted, there are several,
    so we still need to work out which one (or ones) we will need for our playbook.
    As shown from the preceding short descriptions, this will depend on what your
    intended task is.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个要使用的模块的简短列表-当然，有几个，所以我们仍然需要弄清楚我们的playbook需要哪一个（或哪些）。正如前面的简短描述所示，这将取决于您的预期任务是什么。
- en: 'The short descriptions should be enough to give you some clues about whether
    the module will suit your needs or not. Once you have an idea, you can click on
    the appropriate document links to view more details about the module and how to
    work with it:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简短的描述应该足以给您一些关于模块是否适合您的需求的线索。一旦您有了想法，您可以单击适当的文档链接查看有关模块以及如何使用它的更多详细信息：
- en: '![](Images/cff1ffb2-7801-4c9f-ae0d-605181e91ae3.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cff1ffb2-7801-4c9f-ae0d-605181e91ae3.png)'
- en: As you can see, the documentation page for each module provides a great deal
    of information, including a longer description. If you scroll down the page, you
    will see a list of the possible arguments that you can provide the module with,
    some practical examples of how to use them, and some details about the outputs
    from the module. Also, note the Requirements section in the preceding screenshot –
    some modules, especially cloud-related ones, require additional Python modules
    before they will work, and if you attempt to run the `aws_s3` module from a playbook
    without installing the `boto`, `boto3`, and `botocore` modules on Python 2.6 or
    later, you will simply receive an error.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，每个模块的文档页面都提供了大量的信息，包括更长的描述。如果您向下滚动页面，您将看到可以向模块提供的可能参数列表，一些如何使用它们的实际示例，以及有关模块输出的一些详细信息。还要注意前面截图中的要求部分-一些模块，特别是与云相关的模块，在运行之前需要在Python
    2.6或更高版本上安装额外的Python模块，如果您尝试在没有在Python 2.6或更高版本上安装`boto`，`boto3`和`botocore`模块的情况下从playbook运行`aws_s3`模块，您将只会收到一个错误。
- en: All modules must have documentation like this created before they will be accepted
    as part of the Ansible project, so you must keep this in mind if you intend to
    submit your own modules. This is also one of the reasons for Ansible's popularity
    – with easy-to-maintain and well-documented standards, it is the perfect community
    platform for automation. The official Ansible website isn't the only place you
    can obtain documentation, however, as it is even available on the command line.
    We shall look at how to retrieve documentation via this route in the next section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模块必须在被接受为Ansible项目的一部分之前创建这样的文档，因此，如果您打算提交自己的模块，您必须牢记这一点。这也是Ansible流行的原因之一-具有易于维护和有良好文档的标准，它是自动化的完美社区平台。官方的Ansible网站并不是您可以获取文档的唯一地方，因为它甚至可以在命令行上使用。我们将在下一节中看看如何通过这种方式检索文档。
- en: Accessing module documentation from the command line
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从命令行访问模块文档
- en: As discussed in the preceding section, the Ansible project prides itself on
    its documentation, and making this documentation readily accessible is an important
    part of the project itself. Now, suppose you are working on an Ansible task (in
    a playbook, role, or even an ad hoc command) and you are in a data center environment
    where you only have access to the shell of the machine you are working on. How
    would you get access to the Ansible documentation?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一节所讨论的，Ansible项目以其文档为傲，并且使这些文档易于访问是项目本身的重要部分。现在，假设您正在进行Ansible任务（在playbook、角色或甚至是临时命令中），并且您在只能访问您正在工作的机器的shell的数据中心环境中。您将如何访问Ansible文档？
- en: Fortunately, part of the Ansible installation that we have not discussed yet
    is the `ansible-doc` tool, which is installed as standard along with the familiar
    `ansible` and `ansible-playbook` executables. The `ansible-doc` command includes
    a complete (text-based) library of documentation for all the modules that ship
    with the version of Ansible you have installed. This means that the very information
    you need in order to work with modules is at your fingertips, even if you are
    in the middle of a data center and without a working internet connection!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们还没有讨论的Ansible安装的一部分是`ansible-doc`工具，它与熟悉的`ansible`和`ansible-playbook`可执行文件一起作为标准安装。`ansible-doc`命令包括一个完整（基于文本的）文档库，其中包含您安装的Ansible版本附带的所有模块的文档。这意味着您需要的模块信息就在您的指尖，即使您在数据中心中并且没有工作的互联网连接！
- en: 'The following are some examples to show you how to interact with the `ansible-doc`
    tool:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例，向您展示如何与`ansible-doc`工具进行交互：
- en: 'You can list all of the modules that there''s documentation for on your Ansible
    control machine by simply issuing the following command:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过简单地发出以下命令在您的Ansible控制机上列出所有有文档的模块：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should see an output similar to the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个类似以下的输出：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are many pages of output, which just shows you how many modules there
    are! In fact, you can count them:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多页面的输出，这只是向您展示有多少模块！实际上，您可以计数它们：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That's right – 3,387 modules ship with Ansible 2.9.6!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 没错- Ansible 2.9.6附带了3,387个模块！
- en: 'As before, you can search for specific modules using your favorite shell tools
    to process the index; for example, you could `grep` for `s3` to find all of the
    S3-related modules, as we did interactively in the web browser in the previous
    section:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与以前一样，您可以使用您喜欢的shell工具来处理索引来搜索特定的模块；例如，您可以使用`grep`来查找所有与S3相关的模块，就像我们在上一节的Web浏览器中交互式地做的那样：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can easily look up the specific documentation for the module that interests
    us. Say we want to learn more about the `aws_s3` module – just as we did on the
    website, simply run the following:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以轻松查找我们感兴趣的模块的具体文档。假设我们想了解更多关于`aws_s3`模块的信息-就像我们在网站上所做的那样，只需运行以下命令：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This should produce an output similar to the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生一个类似以下的输出：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Although the formatting is somewhat different, `ansible-doc` tells us about
    the module, provides a list of all of the arguments (`OPTIONS`) that we can pass
    it, and as we scroll down, even gives some working examples and possible return
    values. We shall explore the topic of return values in the next section as they
    are important to understand, especially as we approach the topic of developing
    our own modules.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然格式有些不同，`ansible-doc`告诉我们关于该模块的信息，提供了我们可以传递的所有参数（`OPTIONS`）的列表，当我们向下滚动时，甚至给出了一些工作示例和可能的返回值。我们将在下一节中探讨返回值的主题，因为它们对于理解非常重要，特别是当我们接近开发自己的模块的主题时。
- en: Module return values
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块返回值
- en: As we discussed earlier in this chapter, Ansible modules return their results as
    structured data, formatted behind the scenes in JSON. You came across this return
    data in the previous example, both in the form of exit code and where we used
    the `register` keyword to capture the results of a task in an Ansible variable.
    In this section, we shall explore how to discover the return values for an Ansible
    module so that we can work with them later on in a playbook, for example, with
    conditional processing (see [Chapter 4](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml),
    *Playbooks and Roles*).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面讨论的那样，Ansible模块将它们的结果作为结构化数据返回，以JSON格式在后台格式化。在前面的例子中，你遇到了这些返回数据，既以退出代码的形式，也在我们使用`register`关键字来捕获任务结果的Ansible变量中。在本节中，我们将探讨如何发现Ansible模块的返回值，以便我们以后在playbook中使用它们，例如，进行条件处理（见[第4章](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml)，*Playbooks
    and Roles*）。
- en: Due to conserving space, we shall choose what is perhaps one of the simplest
    Ansible modules to work with when it comes to return values – the `ping` module.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空间有限，当涉及到返回值时，我们将选择可能是最简单的Ansible模块之一——`ping`模块。
- en: 'Without further ado, let''s use the `ansible-doc` tool that we learned about
    in the previous section and see what this says about the return values for this
    module:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 话不多说，让我们使用我们在上一节学到的`ansible-doc`工具，看看它对于这个模块的返回值有什么说：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you scroll to the bottom of the output from the preceding command, you should
    see something like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你滚动到前面命令的输出底部，你应该会看到类似这样的内容：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Hence, we can see that the `ping` module will only return one value, and that
    is called `ping`. `description` tells us what we should expect this particular
    return value to contain, while the `returned` field tells us that it will only
    be returned on `success` (if it would be returned on other conditions, these would
    be listed here). The `type` return value is a string (denoted by `str`), and although
    you can change the value with an argument provided to the `ping` module, the default
    return value (and hence `sample`) is `pong`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到`ping`模块只会返回一个值，那就是`ping`。`description`告诉我们我们应该期望这个特定的返回值包含什么，而`returned`字段告诉我们它只会在`success`时返回（如果它会在其他条件下返回，这些将在这里列出）。`type`返回值是一个字符串（用`str`表示），虽然你可以通过提供给`ping`模块的参数来改变值，但默认返回值（因此`sample`）是`pong`。
- en: Now, let's see what that looks like in practice. For example, there's nothing
    contained in those return values that would tell us whether the module ran successfully
    and whether anything was changed; however, we know that these are fundamental
    pieces of information about every module run.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看实际情况。例如，这些返回值中没有任何内容告诉我们模块是否成功运行以及是否有任何更改；然而，我们知道这些是关于每个模块运行的基本信息。
- en: 'Let''s put a very simple playbook together. We''re going to run the `ping`
    module with no arguments, capture the return values using the `register` keyword,
    and then use the `debug` module to dump the return values onto the Terminal:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把一个非常简单的playbook放在一起。我们将使用`ping`模块而不带任何参数运行，使用`register`关键字捕获返回值，然后使用`debug`模块将返回值转储到终端上：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s see what happens when we run this playbook:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们运行这个playbook时会发生什么：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that the `ping` module does indeed return a value called `ping`, which
    contains the `pong` string (as the ping was successful). However, you can see
    that there are, in fact, two additional return values that were not listed in
    the Ansible documentation. These accompany every single task run, and are hence
    implicit – that is to say, you can assume they will be among the data that's returned
    from every module. The `changed` return value will be set to `true` if the module
    run resulted in a change on the target host, while the `failed` return value will
    be set to `true` if the module run failed for some reason.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ping`模块确实返回一个名为`ping`的值，其中包含`pong`字符串（因为ping成功了）。然而，你可以看到实际上有两个额外的返回值，这些在Ansible文档中没有列出。这些伴随着每个任务运行，因此是隐式的
    - 也就是说，你可以假设它们将是从每个模块返回的数据中的一部分。如果模块运行导致目标主机上的更改，`changed`返回值将被设置为`true`，而如果模块运行因某种原因失败，`failed`返回值将被设置为`true`。
- en: Using the `debug` module to print the output from a module run is an incredibly
    useful trick if you want to gather more information about a module, how it works,
    and what sort of data is returned. At this point, we've covered just about all
    of the fundamentals of working with modules, so in the next section, we'll make
    a start on developing our very own (simple) module.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`debug`模块打印模块运行的输出是一个非常有用的技巧，如果你想收集关于模块、它的工作方式以及返回的数据类型的更多信息。在这一点上，我们已经涵盖了几乎所有关于模块工作的基础知识，所以下一节，我们将开始开发我们自己的（简单）模块。
- en: Developing custom modules
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发自定义模块
- en: Now that we're familiar with modules, how to call them, how to interpret their
    results, and how to find documentation on them, we can make a start on writing
    our own simple module. Although this will not include the deep and intricate functionality
    of many of the modules that ship with Ansible, it is hoped that this will give
    you enough information to proceed with confidence when you build out your own,
    more complex, ones.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了模块，如何调用它们，如何解释它们的结果以及如何找到它们的文档，我们可以开始编写我们自己的简单模块。虽然这不包括许多与Ansible一起提供的模块的深入和复杂的功能，但希望这将为您提供足够的信息，以便在构建您自己的更复杂的模块时能够自信地继续。
- en: 'One important point to note is that Ansible is written in Python, and as such,
    so are its modules. As a result, you will need to write your module in Python,
    and to get started with developing your own module, you will need to make sure
    you have Python and a few essential tools installed. If you are already running
    Ansible on your development machine, you probably have the required packages installed,
    but if you are starting from scratch, you will need to install Python, the Python
    package manager (`pip`), and perhaps some other development packages. The exact
    process will vary widely between operating systems, but here are some examples
    to get you started:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的要点是，Ansible是用Python编写的，因此它的模块也是用Python编写的。因此，您需要用Python编写您的模块，并且要开始开发自己的模块，您需要确保已安装Python和一些必要的工具。如果您已经在开发机器上运行Ansible，您可能已经安装了所需的软件包，但如果您从头开始，您需要安装Python、Python软件包管理器（`pip`）和可能一些其他开发软件包。确切的过程会因操作系统而异，但以下是一些示例，供您开始：
- en: 'On Fedora, you would run the following command to install the required packages:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Fedora上，您将运行以下命令来安装所需的软件包：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Similarly, on CentOS, you would run the following command to install the required
    packages:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，在CentOS上，您将运行以下命令来安装所需的软件包：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On Ubuntu, you would run the following commands to install the packages you
    need:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Ubuntu上，您将运行以下命令来安装所需的软件包：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you are working on macOS and are using the Homebrew packaging system, the
    following command will install the packages you need:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在macOS上使用Homebrew包管理系统，以下命令将安装您需要的软件包：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once you have the required packages installed, you will need to clone the Ansible
    Git repository to your local machine as there are some valuable scripts in there
    that we will need later on in the module development process. Use the following
    command to clone the Ansible repository to your current directory on your development
    machine:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 安装所需的软件包后，您需要将Ansible Git存储库克隆到本地机器，因为其中有一些有价值的脚本，我们在模块开发过程中将需要。使用以下命令将Ansible存储库克隆到开发机器上的当前目录：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally (although optionally), it is good practice to develop your Ansible modules
    in a virtual environment (`venv`) as this means any Python packages you need to
    install go in here, rather than in with your global system Python modules. Installing
    modules for the entire system in an uncontrolled manner can, at times, cause compatibility
    issues or even break local tools, and so although this is not a required step,
    it is highly recommended.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后（尽管是可选的），在虚拟环境（`venv`）中开发您的Ansible模块是一个很好的做法，因为这意味着您需要安装的任何Python软件包都在这里，而不是与全局系统Python模块一起。以不受控制的方式为整个系统安装模块有时可能会导致兼容性问题，甚至破坏本地工具，因此虽然这不是必需的步骤，但强烈建议这样做。
- en: 'The exact command to create a virtual environment for your Python module development
    work will depend on both the operating system you are running and the version
    of Python you are using. You should refer to the documentation for your Linux
    distribution for more information; however, the following commands were tested
    on CentOS 7.7 with the default Python 2.7.5 to create a virtual environment called
    `moduledev` inside the Ansible source code directory you just cloned from GitHub:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的Python模块开发工作创建虚拟环境的确切命令将取决于您正在运行的操作系统以及您使用的Python版本。您应该参考您的Linux发行版的文档以获取更多信息；但是，以下命令在默认Python
    2.7.5的CentOS 7.7上进行了测试，以在您刚刚从GitHub克隆的Ansible源代码目录中创建一个名为`moduledev`的虚拟环境：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With our development environment set up, let's start writing our first module.
    This module will be very simple as it's beyond the scope of this book to provide
    an in-depth discussion around how to write large amounts of Python code. However,
    we will code something that can use a function from a Python library to copy a
    file locally on the target machine.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的开发环境设置好了，让我们开始编写我们的第一个模块。这个模块将非常简单，因为本书的范围超出了如何编写大量Python代码的深入讨论。但是，我们将编写一些可以使用Python库中的函数在目标机器上本地复制文件的代码。
- en: 'Obviously, this overlaps heavily with existing module functionality, but it
    will serve as a nice concise example of how to write a simple Python program in
    a manner that allows Ansible to make use of it as a module. Now, let''s start
    coding our first module:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这与现有模块功能有很大的重叠，但它将作为一个很好的简洁示例，演示如何编写一个简单的Python程序，以便Ansible可以使用它作为模块。现在，让我们开始编写我们的第一个模块：
- en: 'In your preferred editor, create a new file called (for example) `remote_filecopy.py`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您喜欢的编辑器中，创建一个名为（例如）`remote_filecopy.py`的新文件：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Start with a shebang to indicate that this module should be executed with Python:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个shebang开始，表示这个模块应该用Python执行：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Although not mandatory, it is good practice to add copyright information, as
    well as your details, in the headers of your new module. By doing this, anyone
    using it will understand the terms under which they can use, modify, or redistribute
    it. The text given here is merely an example; you should investigate the various
    appropriate licenses for yourself and determine which is the best for your module:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然不是强制性的，但在新模块的头部添加版权信息以及您的详细信息是一个好习惯。通过这样做，任何使用它的人都会了解他们可以使用、修改或重新分发的条款。这里给出的文本仅仅是一个例子；您应该自行调查各种适当的许可证，并确定哪种对您的模块最合适：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It is also good practice to add an Ansible metadata section that includes `metadata_version`,
    `status`, and `supported_by` information immediately after the copyright section.
    Note that the `metadata_version` field represents the Ansible metadata version
    (which, at the time of writing, should be `1.1`) and is not related to the version
    of your module, nor the Ansible version you are using. The values suggested in
    the following code will be fine for just getting started, but if your module gets
    accepted into the official Ansible source code, they are likely to change:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在版权部分之后立即添加包含`metadata_version`、`status`和`supported_by`信息的Ansible元数据部分也是一个好习惯。请注意，`metadata_version`字段代表Ansible元数据版本（在撰写本文时应为`1.1`），与您的模块版本或您使用的Ansible版本无关。以下代码中建议的值对于刚开始使用是可以的，但如果您的模块被接受到官方的Ansible源代码中，它们可能会改变：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Remember `ansible-doc` and that excellent documentation that is available on
    the Ansible documentation website? That all gets automatically generated from
    special sections you add to this file. Let''s get started by adding the following
    code to our module:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住`ansible-doc`和Ansible文档网站上提供的优秀文档？所有这些都会自动生成，从你添加到这个文件的特殊部分。让我们开始通过向我们的模块添加以下代码来添加：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Pay particular attention to the `author` dictionary – to pass the syntax checks
    for inclusion in the official Ansible codebase, the author's name should be appended
    with their GitHub ID in brackets. If you don't do this, your module will still
    work, but it won't pass the test we'll perform later.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意`author`字典 - 为了通过官方Ansible代码库的语法检查，作者的名字应该在括号中附上他们的GitHub ID。如果不这样做，你的模块仍然可以工作，但它将无法通过我们稍后进行的测试。
- en: Notice how the documentation is in YAML format, enclosed between triple single
    quotes? The fields listed should be common to just about all modules, but naturally,
    if your module takes different options, you would specify these so that they match
    your module.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文档是用YAML格式编写的，用三个单引号括起来？列出的字段应该适用于几乎所有模块，但自然地，如果你的模块接受不同的选项，你应该指定这些选项以使其与你的模块匹配。
- en: 'The examples that you will find in the documentation are also generated from
    this file – they have their own special documentation section immediately after
    `DOCUMENTATION` and should provide practical examples on how you might create
    a task using your module, as shown in the following example:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档中的示例也是从这个文件生成的 - 它们在`DOCUMENTATION`后面有自己特殊的文档部分，并应该提供如何使用你的模块创建任务的实际示例，如下例所示：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The data that''s returned by your module to Ansible should also be documented
    in its own section. Our example module will return the following values:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的模块返回给Ansible的数据也应该在自己的部分中进行文档化。我们的示例模块将返回以下值：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Immediately after we have finished our documentation section, we should import
    any Python modules we''re going to use. Here, we will include the `shutil` module,
    which will be used to perform our file copy:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们完成文档部分后，应立即导入我们要使用的任何Python模块。在这里，我们将包括`shutil`模块，该模块将用于执行文件复制：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we''ve built up the module headers and documentation, we can actually
    start working on the code. Now, you can see just how much effort goes into the
    documentation of every single Ansible module! Our module should start by defining
    a `main` function, in which we will create an object of the `AnsibleModule` type and
    use an `argument_spec` dictionary to obtain the options that the module was called
    with:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经建立了模块头和文档，我们可以开始编写代码了。现在，你可以看到为每个单独的Ansible模块编写文档需要付出多少努力！我们的模块应该从定义一个`main`函数开始，在这个函数中，我们将创建一个`AnsibleModule`类型的对象，并使用一个`argument_spec`字典来获取模块调用时的选项：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At this stage, we have everything we need to write our module''s functional
    code – even the options that it was called with. Hence, we can use the Python
    `shutil` module to perform the local file copy, based on the arguments provided:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经拥有了编写模块功能代码所需的一切 - 甚至包括它被调用时的选项。因此，我们可以使用Python的`shutil`模块来执行本地文件复制，基于提供的参数：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At this point, we''ve executed the task our module was designed to complete.
    However, it is fair to say that we''re not done yet – we need to exit the module
    cleanly and provide our return values to Ansible. Normally, at this point, you
    would write some conditional logic to detect whether the module was successful
    and whether it actually performed a change on the target host or not. However,
    for simplicity, we''ll simply exit with the `changed` status every time – expanding
    this logic and making the return status more meaningful is left as an exercise
    for you:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经执行了我们的模块旨在完成的任务。然而，可以说我们还没有完成 - 我们需要清理地退出模块，并向Ansible提供我们的返回值。通常，在这一点上，你会编写一些条件逻辑来检测模块是否成功以及它是否实际上对目标主机进行了更改。然而，为简单起见，我们将简单地每次以`changed`状态退出
    - 扩展这个逻辑并使返回状态更有意义留给你作为练习：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `module.exit_json` method comes from `AnsibleModule`, which we created earlier
    – remember, we said it was important to know that data was passed back and forth
    using JSON!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`module.exit_json`方法来自我们之前创建的`AnsibleModule` - 记住，我们说过重要的是知道数据是如何使用JSON来回传递的！'
- en: 'As we approach the end of our module code, we must now tell Python where it
    can import the `AnsibleModule` object from. This can be done with the following
    line of code:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们接近模块代码的结尾时，我们现在必须告诉Python它可以从哪里导入`AnsibleModule`对象。可以通过以下代码行来完成：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now for the final two lines of code for the module – this is where we tell
    the module that it should be running the `main` function when it starts:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是模块的最后两行代码 - 这是我们告诉模块在启动时应该运行`main`函数的地方：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'That''s it – with a series of well-documented steps, you can write your own
    Ansible modules in Python. The next step is, of course, to test it, and before
    we actually test it in Ansible, let''s see whether we can run it manually in the
    shell. Of course, to make the module think it is being run within Ansible, we
    must generate some arguments in – you guessed it – JSON format. Create a file
    with the following contents to provide the arguments:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样 - 通过一系列良好记录的步骤，你可以用Python编写自己的Ansible模块。下一步当然是测试它，在我们实际在Ansible中测试之前，让我们看看是否可以在shell中手动运行它。当然，为了让模块认为它是在Ansible中运行，我们必须以JSON格式生成一些参数。创建一个文件，包含以下内容以提供参数：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Armed with this little snippet of JSON, you can execute your module directly
    with Python. If you haven''t already done so, you''ll need to set up your Ansible
    development environment as follows. Note that we also manually create the source
    file, `/tmp/foo`, so that our module can really perform the file copy:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个小小的JSON片段，你可以直接用Python执行你的模块。如果你还没有这样做，你需要按照以下方式设置你的Ansible开发环境。请注意，我们还手动创建了源文件`/tmp/foo`，这样我们的模块就可以真正执行文件复制了：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, you''re finally ready to run your module for the first time. You can do
    this as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你终于可以第一次运行你的模块了。你可以按照以下步骤进行：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Success! Your module works – and it both ingests and produces JSON data, as
    we discussed earlier in this chapter. Of course, there's much more to add to your
    module – we've not addressed `failed` or `ok` returns from the module, nor does
    it support check mode. However, we're off to a flying start, and if you want to
    learn more about Ansible modules and fleshing out your functionality, you can
    find more details here: [https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.html](https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.html).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！你的模块有效 - 它既接收又生成JSON数据，正如我们在本章前面讨论的那样。当然，你还有很多东西要添加到你的模块 - 我们还没有处理模块的`failed`或`ok`返回，也不支持检查模式。然而，我们已经有了一个良好的开端，如果你想了解更多关于Ansible模块和丰富功能的内容，你可以在这里找到更多详细信息：[https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.html](https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.html)。
- en: 'Note that when it comes to testing your module, creating arguments in a JSON
    file is hardly intuitive, although, as we have seen, it does work well. Luckily
    for us, it is easy to run our Ansible module in a playbook! By default, Ansible
    will check the playbook directory for a subdirectory called `library/` and will
    run referenced modules from here. Hence, we might create the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及测试你的模块时，创建一个JSON文件中的参数并不直观，尽管，正如我们所见，它确实运行良好。幸运的是，我们可以很容易地在playbook中运行我们的Ansible模块！默认情况下，Ansible将检查playbook目录是否有一个名为`library/`的子目录，并将从这里运行引用的模块。因此，我们可以创建以下内容：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, create a simple inventory file in this playbook directory, just as we
    did previously, and add a playbook with the following contents:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这个playbook目录中创建一个简单的清单文件，就像我们之前做的那样，并添加一个带有以下内容的playbook：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For the purposes of clarity, your final directory structure should look like
    this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，你的最终目录结构应该如下所示：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, try running the playbook in the usual manner and see what happens:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试以通常的方式运行playbook，看看会发生什么：
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Success! Not only have you tested your Python code locally, but you have also
    successfully run it on two remote servers in an Ansible playbook. That was really
    easy, which just proves how straightforward it is to get started expanding your
    Ansible modules to meet your own bespoke needs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！你不仅在本地测试了你的Python代码，而且还成功地在Ansible playbook中的两台远程服务器上运行了它。这真的很容易，这证明了扩展你的Ansible模块以满足你自己的定制需求是多么简单。
- en: Despite the success of running this piece of code, we've not checked the documentation
    yet, nor tested its operation from Ansible. Before we address these issues in
    more detail, in the next section, we'll take a look at some of the common pitfalls
    of module development and how to avoid them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管成功运行了这段代码，但我们还没有检查文档，也没有从Ansible中测试它的操作。在我们更详细地解决这些问题之前，在下一节中，我们将看看模块开发的一些常见陷阱以及如何避免它们。
- en: Avoiding common pitfalls
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免常见陷阱
- en: It is vital that your modules are well thought out and handle error conditions
    gracefully – people are going to rely on your module someday to automate a task
    on perhaps thousands of servers, and so the last thing they want is to spend significant
    amounts of time debugging errors, especially trivial ones that could have been
    trapped or handled gracefully. In this section, we'll look specifically at error
    handling and ways to do this so that playbooks will still run and exit gracefully.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你的模块必须经过深思熟虑，并且要优雅地处理错误条件 - 有一天人们将依赖于你的模块来自动化可能在成千上万台服务器上执行的任务，所以他们最不想做的就是花费大量时间调试错误，尤其是那些本来可以被捕获或优雅处理的琐碎错误。在本节中，我们将具体看看错误处理和如何做到这一点，以便playbook仍然可以正常运行并优雅退出。
- en: One piece of overall guidance before we get started is that just like documentation
    receives a high degree of attention in Ansible, so should your error messages.
    They should be meaningful and easy to interpret, and you should steer clear of
    meaningless strings such as `Error!`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，一个总体的指导是，就像文档在Ansible中受到高度关注一样，你的错误消息也应该如此。它们应该是有意义的，易于解释，你应该避免无意义的字符串，比如`Error!`。
- en: 'So, right now, if we remove the source file that we''re attempting to copy
    and then rerun our module with the same arguments, I think you''ll agree that
    the output is neither pretty nor meaningful, unless you happen to be a hardened
    Python developer:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在，如果我们删除我们试图复制的源文件，然后用相同的参数重新运行我们的模块，我认为你会同意输出既不漂亮也不有意义，除非你碰巧是一个经验丰富的Python开发者：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can, without a doubt, do better. Let''s make a copy of our module and add
    a little code to it. First of all, replace the `shutil.copy` lines of code with
    the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们毫无疑问可以做得更好。让我们复制一份我们的模块，并向其中添加一些代码。首先，用以下代码替换`shutil.copy`行：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is some incredibly basic exception handling in Python, but what it does
    is allow the code to try the `shutil.copy` task. However, if this fails and an
    exception is raised, rather than exiting with a traceback, we exit cleanly using
    the `module.fail_json` call. This will tell Ansible that the module failed and
    cleanly sends a JSON-formatted error message back. Naturally, we could do a lot
    to improve the error message; for example, we could obtain the exact error message
    from the `shutil` module and pass it back to Ansible, but again, this is left
    as an exercise for you to complete.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Python中一些非常基本的异常处理，但它允许代码尝试`shutil.copy`任务。但是，如果这失败并引发了异常，我们不会使用回溯退出，而是使用`module.fail_json`调用干净地退出。这将告诉Ansible模块失败，并干净地发送JSON格式的错误消息回去。当然，我们可以做很多事情来改进错误消息；例如，我们可以从`shutil`模块获取确切的错误消息并将其传递回Ansible，但是这又留给您来完成。
- en: 'Now, when we try and run the module with a non-existent source file, we will
    see the following cleanly formatted JSON output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们尝试使用不存在的源文件运行模块时，我们将看到以下清晰格式的JSON输出：
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'However, the module still works in the same manner as before if the copy succeeds:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果复制成功，模块仍然以与以前相同的方式工作：
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With this simple change to our code, we can now cleanly and gracefully handle
    the failure of the file copy operation and report something more meaningful back
    to the user rather than using a traceback. Some additional pointers for exception
    handling and processing in your modules are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对我们的代码进行这个简单的更改，我们现在可以干净而优雅地处理文件复制操作的失败，并向用户报告一些更有意义的内容，而不是使用回溯。在您的模块中进行异常处理和处理的一些建议如下：
- en: Fail quickly – don't attempt to keep processing after an error.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速失败-在出现错误后不要尝试继续处理。
- en: Return the most meaningful possible error messages using the various module
    JSON return functions.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用各种模块JSON返回函数返回最有意义的可能错误消息。
- en: Never return a traceback if there's any way you can avoid it.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有任何方法可以避免返回回溯，请不要返回回溯。
- en: Try making errors meaningful in the context of the module and what it does (for
    example, for our module, `File copy error` is more meaningful than `File error` – and
    I think you'll easily come up with even better error messages).
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使错误在模块和其功能的上下文中更有意义（例如，对于我们的模块，`文件复制错误`比`文件错误`更有意义-我认为您很容易想出更好的错误消息）。
- en: Don't bombard the user with errors; instead, try to focus on reporting the most
    meaningful ones, especially when your module code is complex.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要用错误轰炸用户；相反，尝试专注于报告最有意义的错误，特别是当您的模块代码很复杂时。
- en: That completes our brief yet practical look at error handling in Ansible modules.
    In the next section, we shall return to the documentation we included in our module,
    including how to build it into HTML documentation so that it can go on the Ansible
    website (and indeed, if your module gets accepted into the Ansible source code,
    this is exactly how the web documentation will be generated).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对Ansible模块中错误处理的简要而实用的介绍。在下一节中，我们将回到我们在模块中包含的文档，包括如何将其构建为HTML文档，以便它可以放在Ansible网站上（如果您的模块被接受为Ansible源代码的一部分，这正是Web文档将如何生成）。
- en: Testing and documenting your module
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和记录您的模块
- en: We have already put a great deal of work into documenting our module, as we
    discussed earlier in this chapter. However, how can we see it, and how can we
    check that it compiles correctly into the HTML that would go on the Ansible website
    if it were accepted as part of the Ansible source code?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章前面讨论过，已经为我们的模块做了大量的文档工作。但是，我们如何查看它，以及如何检查它是否正确编译为HTML，如果它被接受为Ansible源代码的一部分，它将放在Ansible网站上？
- en: 'Before we get into actually viewing our documentation, we should make use of
    a tool called `ansible-test`, which was newly added in the 2.9 release. This tool
    can perform a sanity check on our module code to ensure that our documentation
    meets all the standards required by the Ansible project team and that the code
    is structured correctly (for example, the Python `import` statements should always
    come after the documentation blocks). Let''s get started:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际查看文档之前，我们应该使用一个名为`ansible-test`的工具，这个工具是在2.9版本中新增的。这个工具可以对我们的模块代码进行健全性检查，以确保我们的文档符合Ansible项目团队所需的所有标准，并且代码结构正确（例如，Python的`import`语句应该始终放在文档块之后）。让我们开始吧：
- en: 'To run the sanity tests, assuming you have cloned the official repository,
    change into this directory and set up your environment. Note that if your standard
    Python binary isn''t Python 3, the `ansible-test` tool will not run, so you should
    ensure Python 3 is installed and, if necessary, set up a virtual environment to
    ensure you are using Python 3\. This can be done as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行健全性测试，假设您已经克隆了官方存储库，请切换到此目录并设置您的环境。请注意，如果您的标准Python二进制文件不是Python 3，`ansible-test`工具将无法运行，因此您应确保已安装Python
    3，并在必要时设置虚拟环境以确保您正在使用Python 3。可以按照以下步骤完成：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, use `pip` to install the Python requirements so that you can run the
    `ansible-test` tool:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`pip`安装Python要求，以便您可以运行`ansible-test`工具：
- en: '[PRE47]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, provided you have copied your module code into the appropriate location
    in the source tree (an example copy command is shown here), you can run the sanity
    tests as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只要您已将模块代码复制到源树中的适当位置（此处显示了一个示例复制命令），您可以按以下方式运行健全性测试：
- en: '[PRE48]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: From the preceding output, you can see that apart from one warning related to
    us not having a base branch to compare against, the module code that we developed
    earlier in this chapter has passed all the tests. If you had an issue with the
    documentation (for example, the author name format was incorrect), this would
    be given as an error.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，您可以看到除了一个警告与我们没有基本分支进行比较之外，我们在本章前面开发的模块代码已经通过了所有测试。如果您对文档有问题（例如，作者名称格式不正确），这将被视为错误。
- en: 'Now that we have passed the sanity checks with `ansible-test`, let''s see whether
    the documentation looks right by using the `ansible-doc` command. This is very
    easy to do. First of all, exit your virtual environment, if you are still in it,
    and change to the Ansible source code directory you cloned from GitHub earlier.
    Now, you can manually tell `ansible-doc` where to look for modules instead of
    the default path. This means that you could run the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过了`ansible-test`的检查，让我们看看使用`ansible-doc`命令文档是否正确。这很容易做到。首先，退出你的虚拟环境，如果你还在其中，然后切换到你之前从GitHub克隆的Ansible源代码目录。现在，你可以手动告诉`ansible-doc`在哪里查找模块，而不是默认路径。这意味着你可以运行以下命令：
- en: '[PRE49]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You should be presented with the textual rendering of the documentation we
    created earlier – an example of the first page is shown here to give you an idea
    of how it should look:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到我们之前创建的文档的文本呈现 - 这里显示了第一页的示例，以便让你了解它应该是什么样子：
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Excellent! So, we can already access our module documentation using `ansible-doc` and
    indeed confirm that it renders correctly in text mode. However, how do we go about
    building the HTML version? Fortunately, there is a well-defined process for this,
    which we shall outline here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！所以，我们已经可以使用`ansible-doc`访问我们的模块文档，并确保它在文本模式下呈现正确。但是，我们如何构建HTML版本呢？幸运的是，这方面有一个明确定义的过程，我们将在这里概述：
- en: 'Under `lib/ansible/modules/`, you will find a series of categorized directories
    that modules are placed under – ours fits best under the `files` category, so
    copy it to this location in preparation for the build process to come:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`lib/ansible/modules/`下，你会发现一系列分类的目录，模块被放置在其中 - 我们的最适合放在`files`类别下，所以将其复制到这个位置，为即将到来的构建过程做准备：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Change to the `docs/docsite/` directory as the next step in the documentation
    creation process:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为文档创建过程的下一步，切换到`docs/docsite/`目录：
- en: '[PRE52]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Build a documentation-based Python file. Use the following command to do so:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个基于文档的Python文件。使用以下命令来完成：
- en: '[PRE53]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, in theory, making the Ansible documentation should be this simple; however,
    unfortunately, at the time of writing, the source code for Ansible v2.9.6 refuses
    to build `webdocs`. This will no doubt be fixed in due course as, at the time
    of writing, the documentation build scripts are being ported to Python 3\. To
    get the `make webdocs` command to run at all, I had to clone the source code for
    Ansible v2.8.10 as a starting point.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，理论上，制作Ansible文档应该是这么简单的；然而，不幸的是，在写作时，Ansible v2.9.6的源代码拒绝构建`webdocs`。随着时间的推移，这无疑会得到修复，因为在写作时，文档构建脚本正在迁移到Python
    3。为了让`make webdocs`命令运行，我不得不将Ansible v2.8.10的源代码克隆为起点。
- en: Even in this environment, on CentOS 7, the `make webdocs` command fails unless
    you have some very specific Python 3 requirements in place. These are not well-documented,
    but from testing, I can tell you that Sphinx v2.4.4 works. The version supplied
    with CentOS 7 is too old and fails, while the newest version available from the
    Python module repositories (v3.0.1, at the time of writing) is not compatible
    with the build process and fails.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个环境中，在CentOS 7上，`make webdocs`命令也会失败，除非你有一些非常特定的Python 3要求。这些要求没有很好地记录，但从测试中，我可以告诉你，Sphinx
    v2.4.4可以工作。CentOS 7提供的版本太旧并且失败，而Python模块仓库提供的最新版本（写作时为v3.0.1）与构建过程不兼容并且失败。
- en: 'Once I''d started working from the Ansible v2.8.10 source tree, I had to make
    sure I had removed any preexisting `sphinx` modules from my Python 3 environment
    (you need Python 3.5 or above to build the documentation locally – if you don''t
    have this installed on your node, please do this before proceeding) and then ran
    the following commands:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我从Ansible v2.8.10源代码树开始工作，我必须确保我已经从我的Python 3环境中删除了任何现有的`sphinx`模块（你需要Python
    3.5或更高版本才能在本地构建文档 - 如果你的节点上没有安装这个，请在继续之前安装）然后运行以下命令：
- en: '[PRE54]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'With this in place, you will be able to successfully run `make webdocs` to
    build your documentation. You will see pages of output. A successful run should
    end with something like the output shown here:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，你就可以成功地运行`make webdocs`来构建你的文档。你会看到很多输出。一个成功的运行应该以类似于这里显示的输出结束：
- en: '[PRE55]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, notice how, at the end of this process, the `make` command tells us where
    to look for the compiled documentation. If you look in here, you will find the
    following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请注意，在这个过程结束时，`make`命令告诉我们在哪里查找编译好的文档。如果你在这里查找，你会找到以下内容：
- en: '[PRE56]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Try opening up the HTML file in your web browser – you should see that the page
    renders just like one of the documentation pages from the official Ansible project
    documentation! This enables you to check that your documentation builds correctly
    and looks and reads well in the context that it will be viewed in. It also gives
    you confidence that, when you submit your code to the Ansible project (if you
    are doing so), you are submitting something consistent with Ansible's documentation
    quality standards.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在你的网页浏览器中打开HTML文件 - 你应该看到页面的呈现就像官方Ansible项目文档中的一个页面！这使你能够检查你的文档是否构建正确，并且在将要查看的上下文中看起来和读起来都很好。这也让你有信心，当你提交你的代码到Ansible项目时（如果你这样做的话），你提交的是符合Ansible文档质量标准的东西。
- en: More information on building the documentation locally is provided here: [https://docs.ansible.com/ansible/latest/community/documentation_contributions.html#building-the-documentation-locally](https://docs.ansible.com/ansible/latest/community/documentation_contributions.html#building-the-documentation-locally).
    Although this is an excellent document, it does not currently reflect the compatibility
    issues around Sphinx, nor the build issues regarding Ansible 2.9\. Hopefully,
    however, it will give you all of the other pointers you need to get going with
    your documentation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在本地构建文档的更多信息，请参阅这里：[https://docs.ansible.com/ansible/latest/community/documentation_contributions.html#building-the-documentation-locally](https://docs.ansible.com/ansible/latest/community/documentation_contributions.html#building-the-documentation-locally)。虽然这是一个很好的文档，但它目前并没有反映出围绕Sphinx的兼容性问题，也没有反映出关于Ansible
    2.9的构建问题。然而，希望它会给你所有其他你需要开始你的文档的指针。
- en: The current process of building the documentation is currently a little fussy
    around the environments that are supported; however, hopefully, this is something
    that will be resolved in due course. In the meantime, the process outlined in
    this section has given you a tested and working process to start from.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 目前构建文档的过程在支持的环境方面有些麻烦；但是，希望这是一些将来会解决的问题。与此同时，本节中概述的过程已经为您提供了一个经过测试和可行的起点。
- en: The module checklist
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块清单
- en: 'In addition to the pointers and good practices that we have covered so far,
    there are a few more things you should adhere to in your module code to produce
    something that will be considered of a high standard for potential inclusion with
    Ansible. The following list is not exhaustive but will give you a good idea of
    the practices you should adhere to as a module developer:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们迄今为止涵盖的指针和良好的实践之外，在您的模块代码中还有一些事项，您应该遵循，以便产生一个被认为是符合Ansible潜在包含标准的东西。以下清单并不详尽，但会给您一个关于您作为模块开发人员应该遵循的实践的良好想法：
- en: Test your modules as much as you can, both in cases that will succeed and in
    those that cause errors. You can test them using JSON data, as we did in this
    chapter, or make use of them within a test playbook.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能多地测试您的模块，无论是在成功的情况下还是在导致错误的情况下。您可以使用JSON数据进行测试，就像我们在本章中所做的那样，或者在测试playbook中使用它们。
- en: Try and keep your Python requirements to a minimum. Sometimes, there is no way
    to avoid the need for additional Python dependencies (such as the `boto` requirements
    of the AWS-specific modules), but in general, the less you can use, the better.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量将您的Python要求保持在最低限度。有时，可能无法避免需要额外的Python依赖（例如AWS特定模块的`boto`要求），但一般来说，您使用的越少越好。
- en: Don't cache data for your module – the execution strategies of Ansible across
    differing hosts mean you are unlikely to get good results from doing this. Expect
    to gather all of the data you need on each run.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要为您的模块缓存数据 - Ansible在不同主机上的执行策略意味着您不太可能从中获得良好的结果。期望在每次运行时收集您需要的所有数据。
- en: Modules should be a single Python file – they shouldn't be distributed across
    multiple files.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块应该是一个单独的Python文件 - 它们不应该分布在多个文件中。
- en: 'Make sure you investigate and run the Ansible integration tests when you are
    submitting your module code. More information on these is available here: [https://docs.ansible.com/ansible/latest/dev_guide/testing_integration.html](https://docs.ansible.com/ansible/latest/dev_guide/testing_integration.html).'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在提交模块代码时调查并运行Ansible集成测试。有关这些测试的更多信息，请参阅：[https://docs.ansible.com/ansible/latest/dev_guide/testing_integration.html](https://docs.ansible.com/ansible/latest/dev_guide/testing_integration.html)。
- en: Make sure you include exception handling at the appropriate points in your module
    code, as we did in this chapter, to prevent issues.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在模块代码的适当位置包含异常处理，就像我们在本章中所做的那样，以防止出现问题。
- en: Do not use `PSCustomObjects` in Windows modules unless you absolutely cannot
    avoid it.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows模块中不要使用`PSCustomObjects`，除非您绝对无法避免它。
- en: Armed with the information you've gained from this chapter, you should have
    everything you need to start creating your own modules. You may not decide to
    submit them to the Ansible project, and there is certainly no requirement to do
    so. However, even if you don't, following the practices outlined in this chapter
    will ensure that you build a good quality module, regardless of its intended audience.
    Finally, on the basis that you do want to submit your source code to the Ansible
    project, in the next section, we'll look at how to do this through a pull request
    to the Ansible project.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借您从本章中获得的信息，您应该有开始创建自己的模块所需的一切。您可能决定不将它们提交到Ansible项目，并且确实没有这样的要求。但是，即使您不这样做，遵循本章中概述的实践将确保您构建一个高质量的模块，无论其预期的受众是谁。最后，基于您确实希望将源代码提交到Ansible项目的前提，在接下来的部分中，我们将看看如何通过向Ansible项目提交拉取请求来实现这一点。
- en: Contributing upstream – submitting a GitHub pull request
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向上游贡献 - 提交GitHub拉取请求
- en: When you've worked hard on your module and thoroughly tested and documented
    it, you might feel that it is time to submit it to the Ansible project for inclusion.
    Doing this means creating a pull request on the official Ansible repository. Although
    the intricacies of working with GitHub are beyond the scope of this book, we will
    give you a practically focused outline of the basic procedures involved.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当您努力工作在您的模块上并彻底测试和记录它之后，您可能会觉得是时候将其提交到Ansible项目以供包含了。这意味着在官方的Ansible存储库上创建一个拉取请求。虽然在GitHub上的操作细节超出了本书的范围，但我们将为您提供一个基本程序的实际焦点概述。
- en: Following the process outlined here will generate a real request against the
    Ansible project on GitHub so that the code you are committing can be merged with
    their code. *Do not* follow this process unless you genuinely have a new module
    that is ready for submission to the Ansible codebase.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循此处概述的过程将在GitHub上为Ansible项目生成一个真实的请求，以便您提交的代码可以与他们的代码合并。*除非*您真的有一个准备提交到Ansible代码库的新模块，否则*不要*遵循此过程。
- en: 'To submit your module as a pull request of the Ansible repository, you need
    to fork the `devel` branch of the official Ansible repository. To do this, log
    into your GitHub account from your web browser (or create an account if you don''t
    already have one), and then navigate to the URL shown in the following screenshot.
    Click Fork in the top-right corner. As a reminder, the official Ansible source
    code repository URL is [https://github.com/ansible/ansible.git](https://github.com/ansible/ansible.git):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要将您的模块作为Ansible存储库的拉取请求提交，您需要fork官方Ansible存储库的`devel`分支。要做到这一点，请从您的Web浏览器登录到您的GitHub帐户（或者如果您还没有帐户，则创建一个帐户），然后导航到以下截图中显示的URL。点击右上角的Fork。作为提醒，官方Ansible源代码存储库的URL是[https://github.com/ansible/ansible.git](https://github.com/ansible/ansible.git)：
- en: '![](Images/0779e17d-e64b-4699-8632-6bede2ca8db0.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0779e17d-e64b-4699-8632-6bede2ca8db0.png)'
- en: 'Now that you have forked the repository to your own account, we will walk through
    the commands you need to run in order to add your module code to it. Then, we''ll
    show you how to create the required **pull requests** (also known as **PRs**)
    so that you can merge your new module with the upstream Ansible project:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经将存储库分叉到您自己的账户，我们将演示您需要运行的命令，以将您的模块代码添加到其中。然后，我们将向您展示如何创建所需的**拉取请求**（也称为**PRs**），以便您可以将您的新模块与上游的Ansible项目合并：
- en: 'Clone the `devel` branch that you''ve just forked to your local machine. Use
    a command similar to the following, but be sure to replace the URL with the one
    that matches your own GitHub account:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆您刚刚分叉到本地机器的`devel`分支。使用类似以下的命令，但确保用与您自己GitHub账户匹配的URL替换它：
- en: '[PRE57]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Copy your module code into the appropriate modules directory – the `copy` command
    given in the following code is just an example to give you a clue as to what to
    do, but in reality, you should choose the appropriate category subdirectory for
    your module as it won''t necessarily fit into the `files` category. Once you''ve
    added your Python file, perform `git add` to make Git aware of the new file, and
    then commit it with a meaningful commit message. Some example commands are as
    follows:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的模块代码复制到适当的模块目录中-以下代码中给出的`copy`命令只是一个示例，让您知道该怎么做，但实际上，您应该选择适当的类别子目录来放置您的模块，因为它不一定适合`files`类别。添加完Python文件后，执行`git
    add`使Git知道新文件，然后用有意义的提交消息提交它。一些示例命令如下：
- en: '[PRE58]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, be sure to push the code to your forked repository using the following
    command:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，确保使用以下命令将代码推送到您分叉的存储库：
- en: '[PRE59]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Return to GitHub in your web browser and navigate to the Pull Requests page,
    as shown here. Click the New pull request button:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到GitHub网页浏览器，并导航到拉取请求页面，如下所示。点击“New pull request”按钮：
- en: '![](Images/2b2235ef-6a3a-4f76-9d4b-f035cb98cbdb.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2b2235ef-6a3a-4f76-9d4b-f035cb98cbdb.png)'
- en: 'Follow the pull request creation process through, as guided by the GitHub website.
    Once you have successfully submitted your pull request, you should be able to
    navigate to the list of pull requests on the official Ansible source code repository
    and find yours there. An example of the pull requests list is shown here for your
    reference:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 按照GitHub网站的指导，跟随拉取请求创建过程。一旦您成功提交了拉取请求，您应该能够导航到官方Ansible源代码存储库的拉取请求列表，并在那里找到您的拉取请求。拉取请求列表的示例如下：
- en: '![](Images/6148a8a0-6da2-4a93-882c-2b86faa880ce.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6148a8a0-6da2-4a93-882c-2b86faa880ce.png)'
- en: When this screenshot was taken, there were almost 31,000 closed pull requests
    and nearly 1,700 open for review! By the time you read this book, there will surely
    be many more, demonstrating how much Ansible relies on the open source community
    for its continued development and growth. Just think – you could be part of this!
    Don't be alarmed if it takes a long time for your pull request to get reviewed
    – this is simply a facet of how many pull requests there are to review and process.
    You can always use your module code locally by adding it to a local `library/`
    directory, as we demonstrated earlier, so that the speed of your pull request
    being processed doesn't hinder your work with Ansible. Further details of where
    to place your plugin code when working locally can be found here: [https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.html](https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.html).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当截图被拍摄时，几乎有31,000个关闭的拉取请求和将近1,700个待审核的！当您阅读本书时，肯定会有更多，这表明Ansible在持续发展和增长中非常依赖开源社区。想一想-你也可以成为其中的一部分！如果您的拉取请求被审查需要很长时间，不要惊慌-这只是因为有很多拉取请求需要审查和处理。您可以像我们之前演示的那样，将模块代码添加到本地的`library/`目录中，以便您的拉取请求被处理的速度不会妨碍您使用Ansible的工作。有关在本地工作时放置插件代码的更多详细信息可以在这里找到：[https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.html](https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.html)。
- en: 'There are many more ways to contribute to the Ansible project other than creating
    pull requests for custom modules. Here are some examples of other ways you can
    contribute to the project:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为自定义模块创建拉取请求之外，还有许多其他贡献到Ansible项目的方式。以下是一些其他贡献项目的示例：
- en: Review the Ansible documentation and report any bugs you find in it (one was
    filed in the creation of [Chapter 4](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml),
    *Playbooks and Roles*)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查Ansible文档并报告您发现的任何错误（在[第4章](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml)的创建中已经提交了一个）
- en: Create a local Ansible MeetUp to spread your knowledge about Ansible. If you
    are lucky enough to have one in your area already, consider attending it on a
    regular basis.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个本地的Ansible MeetUp来传播关于Ansible的知识。如果你的地区已经有了这样的聚会，考虑定期参加。
- en: Spread Ansible knowledge and awareness via social media with the appropriate
    account references and hashtags; for example, `@ansible`, `#ansible`, and so on.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过社交媒体传播关于Ansible的知识和意识，使用适当的账户引用和标签；例如，`@ansible`，`#ansible`等。
- en: That completes our journey of learning how to create modules, from the very
    first steps of looking into the theory of module operation, all of the way through
    to contributing your new module code to the official Ansible project on GitHub.
    We hope you have found this journey informative and valuable and that it enhances
    your ability to work with Ansible and extend its functionality where required.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们学习如何创建模块的旅程，从最初研究模块操作的理论步骤，一直到将您的新模块代码贡献给GitHub上官方的Ansible项目。我们希望您发现这段旅程有益和有价值，并且增强了您使用Ansible并在需要时扩展其功能的能力。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Modules are the very lifeblood of Ansible – without them, Ansible could not
    perform all of the complex and varied tasks it performs so well across a wide
    variety of systems. By virtue of being an open source project, it is incredibly
    easy to extend the functionality of Ansible by yourself, and in this chapter,
    we explored how you can, with a little Python knowledge, write your own custom
    module from scratch. Ansible is, at the time of writing, incredibly feature-rich,
    but this ease of customization and extension makes Ansible virtually limitless
    in terms of its potential, especially given the power and popularity of Python
    as a programming language.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是Ansible的生命线——没有它们，Ansible无法在各种系统上执行如此复杂和多样的任务。由于是开源项目，通过一点Python知识，您可以轻松扩展Ansible的功能。在本章中，我们探讨了如何从头开始编写自定义模块。截至目前，Ansible非常丰富多功能，但这种易于定制和扩展的特性使得Ansible在潜力方面几乎没有限制，尤其是考虑到Python作为一种编程语言的强大和流行。
- en: In this chapter, we started with a recap of how to execute multiple modules
    using the command line. We then explored the process of interrogating the current
    module index, as well as how to obtain documentation about modules to evaluate
    their suitability for our needs, regardless of whether we have an active internet
    connection or not. We then explored module data and its JSON format, before finally
    going on a journey through which we put together the code for a simple custom
    module. This provided you with a basis for creating your own modules in the future,
    if you so desire.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从回顾如何使用命令行执行多个模块开始。然后，我们探讨了询问当前模块索引的过程，以及如何获取模块文档来评估其是否适合我们的需求，无论我们是否有活动的互联网连接。然后，我们探讨了模块数据及其JSON格式，最后通过一个简单的自定义模块的编码过程，带您进行了一次旅程。这为您提供了在未来创建自己的模块的基础，如果您愿意的话。
- en: In the next chapter, we will explore the process of using and creating another
    core Ansible feature, known as plugins.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用和创建另一个核心的Ansible功能，即插件的过程。
- en: Discovering the plugin types
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现插件类型
- en: Ansible's code has always been designed to be modular—indeed, this is one of
    its core strengths. Whether that is through the use of modules to perform tasks
    or through plugins (as we will see shortly), Ansible's modular design allows it
    to be as versatile and powerful as it has demonstrated itself to be so far in
    this book. As with modules, Ansible plugins are all written in Python and are
    expected to ingest and return data in a certain well-defined format (more on this
    later). Ansible's plugins are often invisible in their function in that you rarely
    call them by name in your commands or playbooks, yet they are responsible for
    some of the most important features Ansible has to offer, including SSH connectivity,
    the ability to parse inventory files (in INI format, YAML, or otherwise), and
    the ability to run `jinja2` filters on your data.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的代码一直被设计为模块化的——这是它的核心优势之一。无论是通过使用模块执行任务还是通过插件（我们将很快看到），Ansible的模块化设计使其能够像本书中展示的那样多才多艺和强大。与模块一样，Ansible插件都是用Python编写的，并且期望以一定的格式摄取和返回数据（稍后会详细介绍）。Ansible的插件在功能上通常是不可见的，因为您在命令或playbook中很少直接调用它们，但它们负责提供Ansible提供的一些最重要的功能，包括SSH连接、解析清单文件（INI格式、YAML或其他格式）以及在数据上运行`jinja2`过滤器的能力。
- en: 'As ever, let''s validate the presence of a suitably installed version of Ansible
    on your test machine before proceeding further:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，在继续之前，让我们验证一下您的测试机上是否安装了合适的Ansible版本：
- en: '[PRE60]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As much work goes into documenting the plugins as it does in documenting the
    modules, and you will be pleased to know that there is a plugin index available
    at [https://docs.ansible.com/ansible/latest/plugins/plugins.html](https://docs.ansible.com/ansible/latest/plugins/plugins.html).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 插件的文档工作与模块的文档工作一样多，您会很高兴地知道，有一个插件索引可在[https://docs.ansible.com/ansible/latest/plugins/plugins.html](https://docs.ansible.com/ansible/latest/plugins/plugins.html)上找到。
- en: You can also use the `ansible-doc` command as we did before, only you need to
    add the `-t` switch to it, too. Plugins are always placed in an appropriate category
    as their function is radically different between categories. If you don't specify
    the `-t` switch with `ansible-doc`, you end up specifying the `ansible-doc -t`
    module, which returns a list of the available modules.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以像之前一样使用`ansible-doc`命令，只是您需要添加`-t`开关。插件总是放在适当的类别中，因为它们在类别之间的功能差异很大。如果您没有使用`-t`开关，您最终会指定`ansible-doc
    -t`模块，它会返回可用模块的列表。
- en: 'At the time of writing, the following plugin categories can be found in Ansible:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，Ansible中可以找到以下插件类别：
- en: '`become`: Responsible for enabling Ansible to obtain super-user access (for
    example, through `sudo`)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`become`: 负责使Ansible能够获得超级用户访问权限（例如，通过`sudo`）'
- en: '`cache`: Responsible for caching facts retrieved from backend systems to improve
    automation performance'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache`: 负责缓存从后端系统检索的事实，以提高自动化性能'
- en: '`callback`: Allows you to add new behaviors when responding to events—for example,
    changing the format that data is printed in the output in of an Ansible playbook
    run'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback`: 允许您在响应事件时添加新的行为，例如更改Ansible playbook运行输出中数据的格式'
- en: '`cliconf`: Provides abstractions to the command-line interfaces of various
    network devices, giving Ansible a standard interface to operate on'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cliconf`: 提供了对各种网络设备命令行界面的抽象，为Ansible提供了一个标准的操作接口'
- en: '`connection`: Provides connectivity from Ansible to remote systems (for example,
    over SSH, WinRM, Docker, and many more)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connection`: 提供了从Ansible到远程系统的连接（例如，通过SSH、WinRM、Docker等）'
- en: '`httpapi`: Tells Ansible how to interact with a remote system''s API (for example,
    for a Fortinet firewall)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httpapi`: 告诉Ansible如何与远程系统的API交互（例如，用于Fortinet防火墙）'
- en: '`inventory`: Provides Ansible with the ability to parse various static and
    dynamic inventory formats'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inventory`: 提供了解析各种静态和动态清单格式的能力'
- en: '`lookup`: Allows Ansible to look up data from an external source (for example,
    by reading a flat text file)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lookup`：允许Ansible从外部来源查找数据（例如，通过读取一个平面文本文件）'
- en: '`netconf`: Provides Ansible with abstractions to enable it to work with NETCONF-enabled
    networking devices'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`netconf`：为Ansible提供抽象，使其能够与启用NETCONF的网络设备一起工作'
- en: '`shell`: Provides Ansible with the ability to work with various shells on different
    systems (for example, `powershell` on Windows versus `sh` on Linux)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shell`：提供Ansible在不同系统上使用各种shell的能力（例如，在Windows上使用`powershell`，在Linux上使用`sh`）'
- en: '`strategy`: Provides plugins to Ansible with different execution strategies
    (for example, the debug strategy we saw in [Chapter 4](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml),
    *Playbooks and Roles*)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strategy`：为Ansible提供不同的执行策略插件（例如，我们在[第4章](2f8c4f41-8a8d-4f23-9df2-6979159e5992.xhtml)中看到的调试策略，*Playbooks
    and Roles*）'
- en: '`vars`: Provides Ansible with the ability to source variables from certain
    sources, such as the `host_vars` and `group_vars` directories we explored in [Chapter
    3](1bbd0c5e-1eb1-4521-b84d-16cc07083f64.xhtml), *Defining Your Inventory*)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vars`：提供Ansible从某些来源获取变量的能力，例如我们在[第3章](1bbd0c5e-1eb1-4521-b84d-16cc07083f64.xhtml)中探讨的`host_vars`和`group_vars`目录，*定义您的清单*）'
- en: 'We will leave exploring the plugin documentation on the Ansible website as
    an exercise for you to complete. However, if you want to explore the various plugins
    using the `ansible-doc` tool, you would need to run the following commands:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把在Ansible网站上探索插件文档作为您完成的练习留给您。但是，如果您想使用`ansible-doc`工具来探索各种插件，您需要运行以下命令：
- en: 'To use the `ansible-doc` command to list all the plugins available in a given
    category, you can run the following command:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`ansible-doc`命令列出给定类别中可用的所有插件，可以运行以下命令：
- en: '[PRE61]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This will return a textual index of the connection plugins, similar to what
    we saw when we were looking at the module documentation. The first few lines of
    the index output are shown here:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回连接插件的文本索引，类似于我们在查看模块文档时看到的内容。索引输出的前几行如下所示：
- en: '[PRE62]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can then explore the documentation for a given plugin. For example, if
    we want to learn about the `paramiko_ssh` plugin, we can issue the following command:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以探索给定插件的文档。例如，如果我们想了解`paramiko_ssh`插件，我们可以发出以下命令：
- en: '[PRE63]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You will find that the plugin documentation takes on a very familiar format,
    similar to what we saw for the modules in [Chapter 5](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml),
    *Consuming and Creating Modules*:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现插件文档采用非常熟悉的格式，与我们在[第5章](6f89dca6-e6ba-4229-a7fd-dc4ef5ca39f5.xhtml)中看到的模块的格式类似。
- en: '[PRE64]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Thanks to all the hard work and effort that goes into documenting every area
    of Ansible, you can easily find out about the plugins that are included with Ansible
    and how to work with them. So far, we have seen that the documentation for plugins
    is no less complete than it is for modules. In the next section of this chapter,
    we'll dive a bit deeper into how to find the plugin code that accompanies your
    Ansible distribution.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ansible各个领域的所有工作和努力，您可以轻松地了解包含在Ansible中的插件以及如何使用它们。到目前为止，我们已经看到，插件的文档与模块的文档一样完整。在本章的下一节中，我们将更深入地了解如何找到与您的Ansible发行版配套的插件代码。
- en: Questions
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which command line can be passed down as a parameter to a module?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令行可以作为参数传递给模块？
- en: A) `ansible dbservers -m command "/bin/echo 'hello modules'"`
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: A) `ansible dbservers -m command "/bin/echo 'hello modules'"`
- en: B) `ansible dbservers -m command -d "/bin/echo 'hello modules'"`
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: B) `ansible dbservers -m command -d "/bin/echo 'hello modules'"`
- en: C) `ansible dbservers -z command -a "/bin/echo 'hello modules'"`
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: C) `ansible dbservers -z command -a "/bin/echo 'hello modules'"`
- en: D) `ansible dbservers -m command -a "/bin/echo 'hello modules'"`
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: D) `ansible dbservers -m command -a "/bin/echo 'hello modules'"`
- en: E) `ansible dbservers -a "/bin/echo 'hello modules'"`
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: E) `ansible dbservers -a "/bin/echo 'hello modules'"`
- en: Which of the following practices is not recommended when you create a custom
    module and address exceptions?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建自定义模块并处理异常时，以下哪种做法是不推荐的？
- en: A) Design a custom module simply and never provide a traceback to the user,
    if you can avoid it.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: A) 设计一个简单的自定义模块，如果可以避免的话，不要向用户提供回溯。
- en: B) Fail your module code quickly, and verify that you are providing helpful
    and understandable exception messages.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: B) 快速失败您的模块代码，并验证您是否提供了有用和可理解的异常消息。
- en: C) Only display error messages for the most relevant exceptions, rather than
    all possible errors.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: C) 仅显示与最相关的异常相关的错误消息，而不是所有可能的错误。
- en: D) Ensure that your module documentation is relevant and easy to understand.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: D) 确保您的模块文档是相关的并且易于理解。
- en: E) Delete playbooks that result in errors and then recreate them from scratch.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: E) 删除导致错误的playbook，然后从头开始重新创建它们。
- en: 'True or False: To contribute to the Ansible upstream project, you need to submit
    your code to the `devel` branch.'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确或错误：要为Ansible上游项目做出贡献，您需要将代码提交到`devel`分支。
- en: A) True
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: A) True
- en: B) False
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: B) False
- en: Further reading
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Documentation regarding the common return values of modules in Ansible can be
    found here: [https://docs.ansible.com/ansible/latest/reference_appendices/common_return_values.html#common](https://docs.ansible.com/ansible/latest/reference_appendices/common_return_values.html#common).
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Ansible模块的常见返回值的文档可以在这里找到：[https://docs.ansible.com/ansible/latest/reference_appendices/common_return_values.html#common](https://docs.ansible.com/ansible/latest/reference_appendices/common_return_values.html#common)。
- en: Check out the following documentation for all the existing modules on Windows
    machines that you can use: [https://docs.ansible.com/ansible/latest/modules/list_of_windows_modules.html#windows-modules](https://docs.ansible.com/ansible/latest/modules/list_of_windows_modules.html#windows-modules).
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看以下文档，了解您可以在Windows机器上使用的所有现有模块：[https://docs.ansible.com/ansible/latest/modules/list_of_windows_modules.html#windows-modules](https://docs.ansible.com/ansible/latest/modules/list_of_windows_modules.html#windows-modules)。
- en: 'Some of the major module indexes, along with their categorization, can be found
    at the following links:'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些主要的模块索引以及它们的分类可以在以下链接找到：
- en: '**Cloud modules**: [https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '云模块: [https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_cloud_modules.html)'
- en: '**Clustering modules**: [https://docs.ansible.com/ansible/latest/modules/list_of_clustering_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_clustering_modules.html)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '集群模块: [https://docs.ansible.com/ansible/latest/modules/list_of_clustering_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_clustering_modules.html)'
- en: '**Commands modules**: [https://docs.ansible.com/ansible/latest/modules/list_of_commands_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_commands_modules.html)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '命令模块: [https://docs.ansible.com/ansible/latest/modules/list_of_commands_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_commands_modules.html)'
- en: '**Crypto modules**: [https://docs.ansible.com/ansible/latest/modules/list_of_crypto_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_crypto_modules.html)'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '加密模块: [https://docs.ansible.com/ansible/latest/modules/list_of_crypto_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_crypto_modules.html)'
- en: '**Database modules**: [https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '数据库模块: [https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_database_modules.html)'
- en: '**Identity modules**: [https://docs.ansible.com/ansible/latest/modules/list_of_identity_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_identity_modules.html)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '身份模块: [https://docs.ansible.com/ansible/latest/modules/list_of_identity_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_identity_modules.html)'
- en: '**All modules**: [https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '所有模块: [https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html)'
