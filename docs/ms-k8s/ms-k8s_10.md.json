["```\n{\n \"cniVersion\": \"0.3.0\",\n \"interfaces\": [ (this key omitted by IPAM plugins)\n {\n \"name\": \"<name>\",\n \"mac\": \"<MAC address>\", (required if L2 addresses are meaningful)\n \"sandbox\": \"<netns path or hypervisor identifier>\" (required for container/hypervisor interfaces, empty/omitted for host interfaces)\n }\n ],\n \"ip\": [\n {\n \"version\": \"<4-or-6>\",\n \"address\": \"<ip-and-prefix-in-CIDR>\",\n \"gateway\": \"<ip-address-of-the-gateway>\", (optional)\n \"interface\": <numeric index into 'interfaces' list>\n },\n ...\n ],\n \"routes\": [ (optional)\n {\n \"dst\": \"<ip-and-prefix-in-cidr>\",\n \"gw\": \"<ip-of-next-hop>\" (optional)\n },\n ...\n ]\n \"dns\": {\n \"nameservers\": <list-of-nameservers> (optional)\n \"domain\": <name-of-local-domain> (optional)\n \"search\": <list-of-additional-search-domains> (optional)\n \"options\": <list-of-options> (optional)\n }\n}\n```", "```\n{\n \"cniVersion\": \"0.3.0\",\n \"name\": \"dbnet\",\n \"type\": \"bridge\",\n // type (plugin) specific\n \"bridge\": \"cni0\",\n \"ipam\": {\n \"type\": \"host-local\",\n // ipam specific\n \"subnet\": \"10.1.0.0/16\",\n \"gateway\": \"10.1.0.1\"\n },\n \"dns\": {\n \"nameservers\": [ \"10.1.0.1\" ]\n }\n}  \n```", "```\nkubectl apply -f https://git.io/weave-kube \n```", "```\napiVersion: networking.k8s.io/v1kind: NetworkPolicy \nmetadata: \n name: test-network-policy \n namespace: default \nspec: \n podSelector: \n  matchLabels: \n    role: db \n ingress: \n  - from: \n     - namespaceSelector: \n        matchLabels: \n         project: awesome-project \n     - podSelector: \n        matchLabels: \n         role: frontend \n    ports: \n     - protocol: tcp \n       port: 6379 \n```", "```\n{ \n      \"kind\": \"Service\", \n      \"apiVersion\": \"v1\", \n      \"metadata\": { \n        \"name\": \"example-service\" \n      }, \n      \"spec\": { \n        \"ports\": [{ \n          \"port\": 8765, \n          \"targetPort\": 9376 \n        }], \n        \"selector\": { \n          \"app\": \"example\" \n        }, \n        \"type\": \"LoadBalancer\" \n      } \n} \n```", "```\n> kubectl expose rc example --port=8765 --target-port=9376 \\\n--name=example-service --type=LoadBalancer  \n```", "```\n> kubectl describe services example-service\n    Name:  example-service\n    Selector:   app=example\n    Type:     LoadBalancer\n    IP:     10.67.252.103\n    LoadBalancer Ingress: 123.45.678.9\n    Port:     <unnamed> 80/TCP\n    NodePort:   <unnamed> 32445/TCP\n    Endpoints:    10.64.0.4:80,10.64.1.5:80,10.64.2.4:80\n    Session Affinity: None\n    No events.\n```", "```\n    {\n      \"kind\": \"Service\",\n      \"apiVersion\": \"v1\",\n      \"metadata\": {\n        \"name\": \"example-service\"\n      },\n      \"spec\": {\n        \"ports\": [{\n          \"port\": 8765,\n          \"targetPort\": 9376\n        }],\n        \"selector\": {\n          \"app\": \"example\"\n        },\n        \"type\": \"LoadBalancer\"\n        \"externalTrafficPolicy: \"Local\"\n      }\n    }  \n```", "```\napiVersion: extensions/v1beta1 \nkind: Ingress \nmetadata: \n  name: test \nspec: \n  rules: \n  - host: foo.bar.com \n    http: \n      paths: \n      - path: /foo \n        backend: \n          serviceName: s1 \n          servicePort: 80 \n      - path: /bar \n        backend: \n          serviceName: s2 \n          servicePort: 80 \n```", "```\npackage main\nimport (\n  \"github.com/containernetworking/cni/pkg/ns\"\n  \"github.com/containernetworking/cni/pkg/skel\"\n  \"github.com/containernetworking/cni/pkg/types/current\"\n  \"github.com/containernetworking/cni/pkg/version\"\n  \"github.com/vishvananda/netlink\"\n)\n```", "```\nfunc cmdAdd(args *skel.CmdArgs) error { \n  args.IfName = \"lo\" \n  err := ns.WithNetNSPath(args.Netns, func(_ ns.NetNS) error { \n    link, err := netlink.LinkByName(args.IfName) \n    if err != nil { \n      return err // not tested \n    } \n\n    err = netlink.LinkSetUp(link) \n    if err != nil { \n      return err // not tested \n    } \n\n    return nil \n  }) \n  if err != nil { \n    return err // not tested \n  } \n\n  result := current.Result{} \n  return result.Print() \n} \n```", "```\nfunc cmdDel(args *skel.CmdArgs) error { \n  args.IfName = \"lo\" \n  err := ns.WithNetNSPath(args.Netns, func(ns.NetNS) error { \n    link, err := netlink.LinkByName(args.IfName) \n    if err != nil { \n      return err // not tested \n    } \n\n    err = netlink.LinkSetDown(link) \n    if err != nil { \n      return err // not tested \n    } \n\n    return nil \n  }) \n  if err != nil { \n    return err // not tested \n  } \n\n  result := current.Result{} \n  return result.Print() \n\n} \n```", "```\nfunc main() { \n  skel.PluginMain(cmdAdd, cmdDel, version.All) \n} \n```", "```\nfunc PluginMain(cmdAdd, cmdDel func(_ *CmdArgs) error, versionInfo version.PluginInfo) { \n  if e := PluginMainWithError(cmdAdd, cmdDel, versionInfo); e != nil { \n    if err := e.Print(); err != nil { \n      log.Print(\"Error writing error JSON to stdout: \", err) \n    } \n    os.Exit(1) \n  } \n} \n```", "```\nfunc PluginMainWithError(cmdAdd, cmdDel func(_ *CmdArgs) error, versionInfo version.PluginInfo) *types.Error { \n  return ( dispatcher{ \n    Getenv: os.Getenv, \n    Stdin:  os.Stdin, \n    Stdout: os.Stdout, \n    Stderr: os.Stderr, \n  }).pluginMain(cmdAdd, cmdDel, versionInfo) \n} \n```", "```\nfunc (t *dispatcher) pluginMain(cmdAdd, cmdDel func(_ *CmdArgs) error, versionInfo version.PluginInfo) *types.Error { \n  cmd, cmdArgs, err := t.getCmdArgsFromEnv() \n  if err != nil { \n    return createTypedError(err.Error()) \n  } \n\n  switch cmd { \n  case \"ADD\": \n    err = t.checkVersionAndCall(cmdArgs, versionInfo, cmdAdd) \n  case \"DEL\": \n    err = t.checkVersionAndCall(cmdArgs, versionInfo, cmdDel) \n  case \"VERSION\": \n    err = versionInfo.Encode(t.Stdout) \n  default: \n    return createTypedError(\"unknown CNI_COMMAND: %v\", cmd) \n  } \n\n  if err != nil { \n    if e, ok := err.(*types.Error); ok { \n      // don't wrap Error in Error \n      return e \n    } \n    return createTypedError(err.Error()) \n  } \n  return nil \n} \n```", "```\ntype NetConf struct { \n  types.NetConf \n  BrName                string `json:\"bridge\"` \n  IsGW                     bool   `json:\"isGateway\"` \n  IsDefaultGW         bool   `json:\"isDefaultGateway\"` \n  ForceAddress      bool   `json:\"forceAddress\"` \n  IPMasq                  bool   `json:\"ipMasq\"` \n  MTU                       int    `json:\"mtu\"` \n  HairpinMode         bool   `json:\"hairpinMode\"` \n  PromiscMode       bool   `json:\"promiscMode\"` \n} \n```", "```\nn, cniVersion, err := loadNetConf(args.StdinData) \n```", "```\nhostInterface, containerInterface, err := setupVeth(netns, br, args.IfName, n.MTU,  \n                                                                          n.HairpinMode) \n  if err != nil { \n    return err \n  } \n\n  // run the IPAM plugin and get back the config to apply \n  r, err := ipam.ExecAdd(n.IPAM.Type, args.StdinData) \n  if err != nil { \n    return err \n  } \n\n  // Convert the IPAM result was into the current Result type \n  result, err := current.NewResultFromResult(r) \n  if err != nil { \n    return err \n  } \n\n  if len(result.IPs) == 0 { \n    return errors.New(\"IPAM returned missing IP config\") \n  } \n\n  result.Interfaces = []*current.Interface{brInterface, hostInterface, containerInterface} \n```"]