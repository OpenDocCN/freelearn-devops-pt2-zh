["```\napiVersion: v1 \nkind: ConfigMap \nmetadata: \n  name: db-config \n  namespace: default \ndata: \n  db-ip-addresses: 1.2.3.4,5.6.7.8 \n\n> kubectl create -f .\\configmap.yamlconfigmap\n \"db-config\" created\n```", "```\n> kubectl get configmap db-config -o yaml\napiVersion: v1\ndata:\n  db-ip-addresses: 1.2.3.4,5.6.7.8\nkind: ConfigMap\nmetadata:\n creationTimestamp: 2017-01-09T03:14:07Z\n name: db-config\n namespace: default\n resourceVersion: \"551258\"\n selfLink: /api/v1/namespaces/default/configmaps/db-config\n uid: aebcc007-d619-11e6-91f1-3a7ae2a25c7d  \n```", "```\napiVersion: v1 \nkind: Pod \nmetadata: \n  name: some-pod \nspec: \n  containers: \n    - name: some-container \n      image: busybox \n      command: [ \"/bin/sh\", \"-c\", \"env\" ] \n      env: \n        - name: DB_IP_ADDRESSES \n          valueFrom: \n            configMapKeyRef: \n              name: db-config \n              key: db-ip-addresses         \n  restartPolicy: Never \n```", "```\n> kubectl logs some-pod\nHUE_REMINDERS_SERVICE_PORT=80\nHUE_REMINDERS_PORT=tcp://10.0.0.238:80\nKUBERNETES_PORT=tcp://10.0.0.1:443\nKUBERNETES_SERVICE_PORT=443\nHOSTNAME=some-pod\nSHLVL=1\nHOME=/root\nHUE_REMINDERS_PORT_80_TCP_ADDR=10.0.0.238\nHUE_REMINDERS_PORT_80_TCP_PORT=80\nHUE_REMINDERS_PORT_80_TCP_PROTO=tcp\nDB_IP_ADDRESSES=1.2.3.4,5.6.7.8\nHUE_REMINDERS_PORT_80_TCP=tcp://10.0.0.238:80\nKUBERNETES_PORT_443_TCP_ADDR=10.0.0.1\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nKUBERNETES_PORT_443_TCP_PORT=443\nKUBERNETES_PORT_443_TCP_PROTO=tcp\nKUBERNETES_SERVICE_PORT_HTTPS=443\nKUBERNETES_PORT_443_TCP=tcp://10.0.0.1:443\nHUE_REMINDERS_SERVICE_HOST=10.0.0.238\nPWD=/\nKUBERNETES_SERVICE_HOST=10.0.0.1 \n```", "```\napiVersion: v1 \nkind: Service \nmetadata: \n  name: nginx \n  labels: \n    app: nginx \nspec: \n  ports: \n  - port: 80 \n    name: web \n  clusterIP: None \n  selector: \n    app: nginx \n```", "```\napiVersion: apps/v1 \nkind: StatefulSet \nmetadata: \n  name: web \nspec: \n  serviceName: \"nginx\" \n  replicas: 3 \n  template: \n    metadata: \n      labels: \n        app: nginx \n```", "```\nspec: \n  terminationGracePeriodSeconds: 10 \n  containers: \n  - name: nginx \n    image: gcr.io/google_containers/nginx-slim:0.8 \n    ports: \n    - containerPort: 80 \n      name: web \n      volumeMounts: \n    - name: www \n      mountPath: /usr/share/nginx/html \n```", "```\nvolumeClaimTemplates: \n- metadata: \n    name: www \n  spec: \n    accessModes: [ \"ReadWriteOnce\" ] \n    resources: \n      requests: \n        storage: 1Gib \n```", "```\nFROM gcr.io/google_containers/ubuntu-slim:0.9  \n```", "```\nADD files / \n\nRUN set -e && echo 'debconf debconf/frontend select Noninteractive' | debconf-set-selections \\\n  && apt-get update && apt-get -qq -y --force-yes install --no-install-recommends \\  \n    openjdk-8-jre-headless \\\n    libjemalloc1 \\ \n    localepurge  \\\n    wget && \\\n  mirror_url=$( wget -q -O - http://www.apache.org/dyn/closer.cgi/cassandra/ \\\n        | sed -n 's#.*href=\"\\(http://.*/cassandra\\/[^\"]*\\)\".*#\\1#p' \\\n        | head -n 1 \\\n    ) \\\n    && wget -q -O - ${mirror_url}/${CASSANDRA_VERSION}/apache-cassandra-${CASSANDRA_VERSION}-bin.tar.gz \\\n        | tar -xzf - -C /usr/local \\\n    && wget -q -O - https://github.com/Yelp/dumb-init/releases/download/v${DI_VERSION}/dumb-init_${DI_VERSION}_amd64 > /sbin/dumb-init \\\n    && echo \"$DI_SHA  /sbin/dumb-init\" | sha256sum -c - \\\n    && chmod +x /sbin/dumb-init \\\n    && chmod +x /ready-probe.sh \\\n    && mkdir -p /cassandra_data/data \\\n    && mkdir -p /etc/cassandra \\\n    && mv /logback.xml /cassandra.yaml /jvm.options /etc/cassandra/ \\ \n    && mv /usr/local/apache-cassandra-${CASSANDRA_VERSION}/conf/cassandra-env.sh /etc/cassandra/ \\\n    && adduser --disabled-password --no-create-home --gecos '' --disabled-login cassandra \\\n    && chown cassandra: /ready-probe.sh \\ \n\nVOLUME [\"/$CASSANDRA_DATA\"] \n```", "```\n# 7000: intra-node communication \n# 7001: TLS intra-node communication \n# 7199: JMX \n# 9042: CQL \n# 9160: thrift service \n\nEXPOSE 7000 7001 7199 9042 9160 \n```", "```\nCMD [\"/sbin/dumb-init\", \"/bin/bash\", \"/run.sh\"] \n```", "```\nset -e \nCASSANDRA_CONF_DIR=/etc/cassandra \nCASSANDRA_CFG=$CASSANDRA_CONF_DIR/cassandra.yaml \n```", "```\n# we are doing StatefulSet or just setting our seeds \nif [ -z \"$CASSANDRA_SEEDS\" ]; then \n  HOSTNAME=$(hostname -f) \nFi \n```", "```\nCASSANDRA_RPC_ADDRESS=\"${CASSANDRA_RPC_ADDRESS:-0.0.0.0}\" \nCASSANDRA_NUM_TOKENS=\"${CASSANDRA_NUM_TOKENS:-32}\" \nCASSANDRA_CLUSTER_NAME=\"${CASSANDRA_CLUSTER_NAME:='Test Cluster'}\" \nCASSANDRA_LISTEN_ADDRESS=${POD_IP:-$HOSTNAME} \nCASSANDRA_BROADCAST_ADDRESS=${POD_IP:-$HOSTNAME} \nCASSANDRA_BROADCAST_RPC_ADDRESS=${POD_IP:-$HOSTNAME} \nCASSANDRA_DISK_OPTIMIZATION_STRATEGY=\"${CASSANDRA_DISK_OPTIMIZATION_STRATEGY:-ssd}\" \nCASSANDRA_MIGRATION_WAIT=\"${CASSANDRA_MIGRATION_WAIT:-1}\" \nCASSANDRA_ENDPOINT_SNITCH=\"${CASSANDRA_ENDPOINT_SNITCH:-SimpleSnitch}\" \nCASSANDRA_DC=\"${CASSANDRA_DC}\" \nCASSANDRA_RACK=\"${CASSANDRA_RACK}\" \nCASSANDRA_RING_DELAY=\"${CASSANDRA_RING_DELAY:-30000}\" \nCASSANDRA_AUTO_BOOTSTRAP=\"${CASSANDRA_AUTO_BOOTSTRAP:-true}\" \nCASSANDRA_SEEDS=\"${CASSANDRA_SEEDS:false}\" \nCASSANDRA_SEED_PROVIDER=\"${CASSANDRA_SEED_PROVIDER:-org.apache.cassandra.locator.SimpleSeedProvider}\" \nCASSANDRA_AUTO_BOOTSTRAP=\"${CASSANDRA_AUTO_BOOTSTRAP:false}\" \n\n# Turn off JMX auth \nCASSANDRA_OPEN_JMX=\"${CASSANDRA_OPEN_JMX:-false}\" \n# send GC to STDOUT \nCASSANDRA_GC_STDOUT=\"${CASSANDRA_GC_STDOUT:-false}\" \n```", "```\necho Starting Cassandra on ${CASSANDRA_LISTEN_ADDRESS}\necho CASSANDRA_CONF_DIR ${CASSANDRA_CONF_DIR}\n...\n```", "```\n# if DC and RACK are set, use GossipingPropertyFileSnitch \nif [[ $CASSANDRA_DC && $CASSANDRA_RACK ]]; then \n  echo \"dc=$CASSANDRA_DC\" > $CASSANDRA_CONF_DIR/cassandra-rackdc.properties \n  echo \"rack=$CASSANDRA_RACK\" >> $CASSANDRA_CONF_DIR/cassandra-rackdc.properties \n  CASSANDRA_ENDPOINT_SNITCH=\"GossipingPropertyFileSnitch\" \nfi \n```", "```\nif [ -n \"$CASSANDRA_MAX_HEAP\" ]; then \n  sed -ri \"s/^(#)?-Xmx[0-9]+.*/-Xmx$CASSANDRA_MAX_HEAP/\" \"$CASSANDRA_CONF_DIR/jvm.options\" \n  sed -ri \"s/^(#)?-Xms[0-9]+.*/-Xms$CASSANDRA_MAX_HEAP/\" \"$CASSANDRA_CONF_DIR/jvm.options\" \nfi \n\nif [ -n \"$CASSANDRA_REPLACE_NODE\" ]; then \n   echo \"-Dcassandra.replace_address=$CASSANDRA_REPLACE_NODE/\" >> \"$CASSANDRA_CONF_DIR/jvm.options\" \nfi \n```", "```\nfor rackdc in dc rack; do \n  var=\"CASSANDRA_${rackdc^^}\" \n  val=\"${!var}\" \n  if [ \"$val\" ]; then \n  sed -ri 's/^('\"$rackdc\"'=).*/1 '\"$val\"'/' \"$CASSANDRA_CONF_DIR/cassandra-rackdc.properties\" \n  fi \ndone \n```", "```\nfor yaml in \\  \n  broadcast_address \\ \n  broadcast_rpc_address \\ \n  cluster_name \\ \n  disk_optimization_strategy \\ \n  endpoint_snitch \\ \n  listen_address \\ \n  num_tokens \\  \n  rpc_address \\ \n  start_rpc \\  \n  key_cache_size_in_mb \\ \n  concurrent_reads \\ \n  concurrent_writes \\ \n  memtable_cleanup_threshold \\  \n  memtable_allocation_type \\ \n  memtable_flush_writers \\ \n  concurrent_compactors \\  \n  compaction_throughput_mb_per_sec \\ \n  counter_cache_size_in_mb \\ \n  internode_compression \\ \n  endpoint_snitch \\ \n  gc_warn_threshold_in_ms \\  \n  listen_interface  \\\n  rpc_interface  \\\n  ; do \n  var=\"CASSANDRA_${yaml^^}\" \n  val=\"${!var}\" \n  if [ \"$val\" ]; then \n    sed -ri 's/^(# )?('\"$yaml\"':).*/\\2 '\"$val\"'/' \"$CASSANDRA_CFG\" \n  fi \ndone \n\necho \"auto_bootstrap: ${CASSANDRA_AUTO_BOOTSTRAP}\" >> $CASSANDRA_CFG \n```", "```\n# set the seed to itself.  This is only for the first pod, otherwise \n# it will be able to get seeds from the seed provider \nif [[ $CASSANDRA_SEEDS == 'false' ]]; then \n  sed -ri 's/- seeds:.*/- seeds: \"'\"$POD_IP\"'\"/' $CASSANDRA_CFG \nelse # if we have seeds set them.  Probably StatefulSet \n  sed -ri 's/- seeds:.*/- seeds: \"'\"$CASSANDRA_SEEDS\"'\"/' $CASSANDRA_CFG \nfi \n\nsed -ri 's/- class_name: SEED_PROVIDER/- class_name: '\"$CASSANDRA_SEED_PROVIDER\"'/' $CASSANDRA_CFG \n```", "```\n# send gc to stdout \nif [[ $CASSANDRA_GC_STDOUT == 'true' ]]; then \n  sed -ri 's/ -Xloggc:\\/var\\/log\\/cassandra\\/gc\\.log//' $CASSANDRA_CONF_DIR/cassandra-env.sh \nfi \n\n# enable RMI and JMX to work on one port \necho \"JVM_OPTS=\\\"\\$JVM_OPTS -Djava.rmi.server.hostname=$POD_IP\\\"\" >> $CASSANDRA_CONF_DIR/cassandra-env.sh \n\n# getting WARNING messages with Migration Service \necho \"-Dcassandra.migration_task_wait_in_seconds=${CASSANDRA_MIGRATION_WAIT}\" >> $CASSANDRA_CONF_DIR/jvm.options \necho \"-Dcassandra.ring_delay_ms=${CASSANDRA_RING_DELAY}\" >> $CASSANDRA_CONF_DIR/jvm.options \n\nif [[ $CASSANDRA_OPEN_JMX == 'true' ]]; then \n  export LOCAL_JMX=no \n  sed -ri 's/ -Dcom\\.sun\\.management\\.jmxremote\\.authenticate=true/ -Dcom\\.sun\\.management\\.jmxremote\\.authenticate=false/' $CASSANDRA_CONF_DIR/cassandra-env.sh \n  sed -ri 's/ -Dcom\\.sun\\.management\\.jmxremote\\.password\\.file=\\/etc\\/cassandra\\/jmxremote\\.password//' $CASSANDRA_CONF_DIR/cassandra-env.sh \nfi \n```", "```\nexport CLASSPATH=/kubernetes-cassandra.jar\n\nsu cassandra -c \"$CASSANDRA_HOME/bin/cassandra -f\"  \n```", "```\nseed_provider: \n    - class_name: SEED_PROVIDER \n      parameters: \n          # seeds is actually a comma-delimited list of addresses. \n          # Ex: \"<ip1>,<ip2>,<ip3>\" \n          - seeds: \"127.0.0.1\"  \n```", "```\n# You can use a custom Snitch by setting this to the full class  \n# name of the snitch, which will be assumed to be on your classpath. \nendpoint_snitch: SimpleSnitch \n```", "```\npublic class KubernetesSeedProvider implements SeedProvider { \n   ... \n    /** \n     * Call kubernetes API to collect a list of seed providers \n     * @return list of seed providers \n     */ \n    public List<InetAddress> getSeeds() { \n        String host = getEnvOrDefault(\"KUBERNETES_PORT_443_TCP_ADDR\", \"kubernetes.default.svc.cluster.local\"); \n        String port = getEnvOrDefault(\"KUBERNETES_PORT_443_TCP_PORT\", \"443\"); \n        String serviceName = getEnvOrDefault(\"CASSANDRA_SERVICE\", \"cassandra\"); \n        String podNamespace = getEnvOrDefault(\"POD_NAMESPACE\", \"default\"); \n        String path = String.format(\"/api/v1/namespaces/%s/endpoints/\", podNamespace); \n        String seedSizeVar = getEnvOrDefault(\"CASSANDRA_SERVICE_NUM_SEEDS\", \"8\"); \n        Integer seedSize = Integer.valueOf(seedSizeVar); \n        String accountToken = getEnvOrDefault(\"K8S_ACCOUNT_TOKEN\", \"/var/run/secrets/kubernetes.io/serviceaccount/token\"); \n\n        List<InetAddress> seeds = new ArrayList<InetAddress>(); \n        try { \n            String token = getServiceAccountToken(accountToken); \n\n            SSLContext ctx = SSLContext.getInstance(\"SSL\"); \n            ctx.init(null, trustAll, new SecureRandom()); \n\n            String PROTO = \"https://\"; \n            URL url = new URL(PROTO + host + \":\" + port + path + serviceName); \n            logger.info(\"Getting endpoints from \" + url); \n            HttpsURLConnection conn = (HttpsURLConnection)url.openConnection(); \n\n            conn.setSSLSocketFactory(ctx.getSocketFactory()); \n            conn.addRequestProperty(\"Authorization\", \"Bearer \" + token); \n            ObjectMapper mapper = new ObjectMapper(); \n            Endpoints endpoints = mapper.readValue(conn.getInputStream(), Endpoints.class);    }    \n            ... \n        } \n        ... \n\n    return Collections.unmodifiableList(seeds);    \n} \n```", "```\napiVersion: v1 \nkind: Service \nmetadata: \n  labels: \n    app: cassandra \n  name: cassandra \nspec: \n  clusterIP: None \n  ports: \n    - port: 9042 \n  selector: \n    app: Cassandra \n```", "```\napiVersion: \"apps/v1\" \nkind: StatefulSet \nmetadata: \n  name: cassandra \n```", "```\nspec: \n  serviceName: cassandra \n  replicas: 3  \n  template: ... \n```", "```\ntemplate: \n  metadata: \n    labels: \n      app: cassandra \n  spec: \n    containers: ...   \n```", "```\ncontainers: \n   - name: cassandra \n      image: gcr.io/google-samples/cassandra:v12 \n      imagePullPolicy: Always \n```", "```\nports: \n- containerPort: 7000 \n  name: intra-node \n- containerPort: 7001 \n  name: tls-intra-node \n- containerPort: 7199 \n  name: jmx \n- containerPort: 9042 \n  name: cql \n```", "```\nresources: \n  limits: \n    cpu: \"500m\" \n    memory: 1Gi \n  requests: \n    cpu: \"500m\" \n    memory: 1Gi \n```", "```\nsecurityContext: \ncapabilities: \n  add: \n       - IPC_LOCK \n```", "```\n env: \n   - name: MAX_HEAP_SIZE \n     value: 512M \n   - name: CASSANDRA_SEEDS \n     value: \"cassandra-0.cassandra.default.svc.cluster.local\" \n  - name: POD_IP \n    valueFrom: \n      fieldRef: \n        fieldPath: status.podIP \n```", "```\nreadinessProbe: \n  exec: \n    command: \n    - /bin/bash \n    - -c \n    - /ready-probe.sh \n  initialDelaySeconds: 15 \n  timeoutSeconds: 5 \n```", "```\nvolumeMounts: \n- name: cassandra-data \n  mountPath: /cassandra_data \n```", "```\nvolumeClaimTemplates: \n- metadata: \n  name: cassandra-data \n  annotations: \n    volume.beta.kubernetes.io/storage-class: fast \nspec: \n  accessModes: [ \"ReadWriteOnce\" ] \n  resources: \n    requests: \n      storage: 1Gi \n```", "```\napiVersion: v1 \nkind: ReplicationController \nmetadata: \n  name: cassandra \n  # The labels will be applied automatically \n  # from the labels in the pod template, if not set \n  # labels: \n    # app: Cassandra \n```", "```\nspec: \n  replicas: 3 \n  # The selector will be applied automatically \n  # from the labels in the pod template, if not set. \n  # selector: \n      # app: Cassandra \n```", "```\ntemplate: \n    metadata: \n      labels: \n        app: Cassandra \n```", "```\nspec: \n  containers: \n    - command: \n        - /run.sh \n      image: gcr.io/google-samples/cassandra:v11 \n      name: cassandra \n```", "```\n resources: \n            limits: \n              cpu: 0.5 \n```", "```\n env: \n    - name: MAX_HEAP_SIZE \n      value: 512M \n    - name: HEAP_NEWSIZE \n      value: 100M \n    - name: CASSANDRA_SEED_PROVIDER \n      value: \"io.k8s.cassandra.KubernetesSeedProvider\" \n    - name: POD_NAMESPACE \n      valueFrom: \n         fieldRef: \n           fieldPath: metadata.namespace \n    - name: POD_IP \n      valueFrom: \n         fieldRef: \n           fieldPath: status.podIP \n```", "```\n ports: \n    - containerPort: 7000 \n      name: intra-node \n    - containerPort: 7001 \n      name: tls-intra-node \n    - containerPort: 7199 \n      name: jmx \n    - containerPort: 9042 \n      name: cql \n```", "```\nvolumeMounts: \n  - mountPath: /cassandra_data \n    name: data \n```", "```\nvolumes: \n  - name: data \n    emptyDir: {} \n```", "```\nspec: \n  affinity: \n    podAntiAffinity: \n      requiredDuringSchedulingIgnoredDuringExecution: \n      - labelSelector: \n          matchExpressions: \n          - key: app \n            operator: In \n            values: \n            - cassandra \n          topologyKey: kubernetes.io/hostname \n```", "```\napiVersion: apps/v1 \nkind: DaemonSet \nmetadata: \n  name: cassandra-daemonset \n```", "```\nspec: \n  template: \n    metadata: \n      labels: \n        app: cassandra \n    spec: \n      # Filter only nodes with the label \"app: cassandra\": \n      nodeSelector: \n        app: cassandra \n      containers: \n```"]