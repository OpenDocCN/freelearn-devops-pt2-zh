["```\n> kubectl proxy --port 8080  \n```", "```\n{\n \"paths\": [\n \"/api\",\n \"/api/v1\",\n \"/apis\",\n \"/apis/apps\",\n \"/apis/storage.k8s.io/v1\",\n .\n .\n .\n \"/healthz\",\n \"/healthz/ping\",\n \"/logs\",\n \"/metrics\",\n \"/swaggerapi/\",\n \"/ui/\",\n \"/version\"\n ]\n}\n```", "```\n{\n \"apiVersion\": \"v1\",\n \"kind\": \"Namespace\",\n \"metadata\": {\n \"creationTimestamp\": \"2017-12-25T10:04:26Z\",\n \"name\": \"default\",\n \"resourceVersion\": \"4\",\n \"selfLink\": \"/api/v1/namespaces/default\",\n \"uid\": \"fd497868-e95a-11e7-adce-080027c94384\"\n },\n \"spec\": {\n \"finalizers\": [\n \"kubernetes\"\n ]\n },\n \"status\": {\n \"phase\": \"Active\"\n }\n}\n```", "```\n$ http http://localhost:8080/api/v1/services\n{\n \"apiVersion\": \"v1\",\n \"items\": [\n {\n \"metadata\": {\n \"creationTimestamp\": \"2018-03-03T05:18:30Z\",\n \"labels\": {\n \"component\": \"apiserver\",\n \"provider\": \"kubernetes\"\n },\n \"name\": \"kubernetes\",\n \u2026\n },\n \"spec\": {\n \u2026\n },\n \"status\": {\n \"loadBalancer\": {}\n }\n },\n \u2026\n ],\n \"kind\": \"ServiceList\",\n \"metadata\": {\n \"resourceVersion\": \"1076\",\n \"selfLink\": \"/api/v1/services\"\n }\n}\n```", "```\n.items[].metadata.name\n```", "```\n$ http http://localhost:8080/api/v1/services | jq .items[].metadata.name\n\"kubernetes\"\n\"kube-dns\"\n\"kubernetes-dashboard\"  \n```", "```\n{\n \"kind\": \"Pod\",\n \"apiVersion\": \"v1\",\n \"metadata\":{\n \"name\": \"nginx\",\n \"namespace\": \"default\",\n \"labels\": {\n \"name\": \"nginx\"\n }\n },\n \"spec\": {\n \"containers\": [{\n \"name\": \"nginx\",\n \"image\": \"nginx\",\n \"ports\": [{\"containerPort\": 80}]\n }]\n }\n}\n```", "```\n> http POST http://localhost:8080/api/v1/namespaces/default/pods @nginx-pod.json  \n```", "```\n/api/v1/namespaces/default/pods  \n```", "```\nitems[].metadata.name,.items[].status.phase  \n```", "```\n> FILTER='.items[].metadata.name,.items[].status.phase'\n> http http://localhost:8080/api/v1/namespaces/default/pods | jq $FILTER \n\"nginx\"\n\"Running\"  \n```", "```\n> pip install kubernetes\n```", "```\n> python\nPython 3.6.4 (default, Mar  1 2018, 18:36:42)\n[GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>  \n```", "```\n>>> from kubernetes import client, config\n>>> config.load_kube_config()\n>>> v1 = client.CoreV1Api()  \n```", "```\n>>> from kubernetes import client, config\n>>> client.Configuration().host = 'http://localhost:8080'\n>>> v1 = client.CoreV1Api()  \n```", "```\n>>> attributes = [x for x in dir(v1) if not x.startswith('__')]\n>>> len(attributes)\n481  \n```", "```\n>>> import random\n>>> from pprint import pprint as pp\n>>> pp(random.sample(attributes, 10))\n['patch_namespaced_pod',\n 'connect_options_node_proxy_with_path_with_http_info',\n 'proxy_delete_namespaced_pod_with_path',\n 'delete_namespace',\n 'proxy_post_namespaced_pod_with_path_with_http_info',\n 'proxy_post_namespaced_service',\n 'list_namespaced_pod_with_http_info',\n 'list_persistent_volume_claim_for_all_namespaces',\n 'read_namespaced_pod_log_with_http_info',\n 'create_node']  \n```", "```\n>>> from collections import Counter\n>>> verbs = [x.split('_')[0] for x in attributes]\n>>> pp(dict(Counter(verbs)))\n{'api': 1,\n 'connect': 96,\n 'create': 36,\n 'delete': 56,\n 'get': 2,\n 'list': 56,\n 'patch': 48,\n 'proxy': 84,\n 'read': 52,\n 'replace': 50}  \n```", "```\n>>> help(v1.create_node)\nHelp on method create_node in module kuber-netes.client.apis.core_v1_api:\n\ncreate_node(body, **kwargs) method of kuber-netes.client.apis.core_v1_api.CoreV1Api instance\n create a Node\n This method makes a synchronous HTTP request by default. To make an\n asynchronous HTTP request, please pass async=True\n >>> thread = api.create_node(body, async=True)\n >>> result = thread.get()\n\n :param async bool\n :param V1Node body: (required)\n :param str pretty: If 'true', then the output is pretty printed.\n :return: V1Node\n If the method is called asynchronously,\n returns the request thread.\n```", "```\n >>> for ns in v1.list_namespace().items:\n...     print(ns.metadata.name)\n...\ndefault\nkube-public\nkube-system  \n```", "```\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n name: nginx-deployment\nspec:\n replicas: 3\n template:\n metadata:\n labels:\n app: nginx\n spec:\n containers:\n - name: nginx\n image: nginx:1.7.9\n ports:\n - containerPort: 80\n```", "```\n> pip install yaml\n```", "```\nfrom os import path\nimport yaml\nfrom kubernetes import client, config\n\ndef main():\n # Configs can be set in Configuration class directly or using\n # helper utility. If no argument provided, the config will be \n # loaded from default location.\n config.load_kube_config()\n\n with open(path.join(path.dirname(__file__), \n 'nginx-deployment.yaml')) as f:\n dep = yaml.load(f)\n k8s = client.AppsV1Api()\n status = k8s_beta.create_namespaced_deployment(\n body=dep, namespace=\"default\").status\n print(\"Deployment created. status='{}'\".format(status))\n\nif __name__ == '__main__':\n main()\n```", "```\nfrom kubernetes import client, config, watch\n\n# Configs can be set in Configuration class directly or using helper utility\nconfig.load_kube_config()\nv1 = client.CoreV1Api()\ncount = 10\nw = watch.Watch()\nfor event in w.stream(v1.list_namespace, _request_timeout=60):\n print(f\"Event: {event['type']} {event['object'].metadata.name}\") \n count -= 1\n if count == 0:\n w.stop()\n\nprint('Done.')\n```", "```\n>>> import subprocess\n>>> out = subprocess.check_output('kubectl').decode('utf-8')\n>>> print(out[:276])  \n```", "```\nfrom subprocess import check_output\n\ndef k(*args):\n     out = check_output(['kubectl'] + list(args))\n     return out.decode('utf-8')\nLet's use it to list all the running pods in the default namespace:\n>>> print(k('get', 'po'))\n\nNAME                               Ready   Status  Restarts      Age \nnginx-deployment-6c54bd5869-9mp2g   1/1    Running    0          18m\nnginx-deployment-6c54bd5869-lgs84   1/1    Running    0          18m\nnginx-deployment-6c54bd5869-n7468   1/1    Running    0        . 18m  \n```", "```\nfrom subprocess import check_output\nimport json\n\ndef k(use_json=False, *args):\n cmd = ['kubectl']\n\n cmd += list(args)\n if use_json:\n cmd += ['-o', 'json']\n out = check_output(cmd)\n if use_json:\n out = json.loads(out)\n else:\n out = out.decode('utf-8')\n return out\n```", "```\nresult = k('get', 'po', use_json=True)\nfor r in result['items']:\n    print(r['metadata']['name'])\n\nnginx-deployment-6c54bd5869-9mp2g\nnginx-deployment-6c54bd5869-lgs84\nnginx-deployment-6c54bd5869-n7468  \n```", "```\nk('delete', 'deployment', 'nginx-deployment')\nwhile len(k('get', 'po', use_json=True)['items']) > 0:\n   print('.')\nprint('Done.')\n\nDone. \n```", "```\napiVersion: apiextensions.k8s.io/v1beta1 \nkind: CustomResourceDefinition \nmetadata: \n  # name must match the spec fields below, and be in the form: <plural>.<group> \n  name: candies.awesome.corp.com \nspec: \n  # group name to use for REST API: /apis/<group>/<version> \n  group: awesome.corp.com \n  # version name to use for REST API: /apis/<group>/<version> \n  version: v1 \n  # either Namespaced or Cluster \n  scope: Namespaced \n  names: \n    # plural name to be used in the URL: /apis/<group>/<version>/<plural> \n    plural: candies \n    # singular name to be used as an alias on the CLI and for display \n    singular: candy \n    # kind is normally the CamelCased singular type. Your resource manifests use this. \n    kind: Candy \n    # shortNames allow shorter string to match your resource on the CLI \n    shortNames: \n    - cn \n```", "```\n> kubectl create -f crd.yaml \ncustomresourcedefinition \"candies.awesome.corp.com\" created \n```", "```\n> kubectl get crd\nNAME                                      AGE\ncandies.awesome.corp.com                  17m\n```", "```\n/apis/awesome.corp.com/v1/namespaces/<namespace>/candies/  \n```", "```\n>>> config.load_kube_config()\n>>> print(k('get', 'thirdpartyresources'))\nNAME                                           AGE\ncandies.awesome.corp.com                       24m \n```", "```\napiVersion: \"awesome.corp.com/v1\" \nkind: Candy \nmetadata: \n  name: chocolatem \nspec: \n  flavor: \"sweeeeeeet\" \n```", "```\n> kubectl create -f candy.yaml\ncandy \"chocolate\" created \n```", "```\n$ kubectl get candies\nNAME        AGE\nchocolate   2m  \n```", "```\n> kubectl get cn -o json\n{\n \"apiVersion\": \"v1\",\n \"items\": [\n {\n \"apiVersion\": \"awesome.corp.com/v1\",\n \"kind\": \"Candy\",\n \"metadata\": {\n \"clusterName\": \"\",\n \"creationTimestamp\": \"2018-03-07T18:18:42Z\",\n \"name\": \"chocolate\",\n \"namespace\": \"default\",\n \"resourceVersion\": \"4791773\",\n \"selfLink\": \"/apis/awesome.corp.com/v1/namespaces/default/candies/chocolate\",\n \"uid\": \"f7a6fd80-2233-11e8-b432-080027c94384\"\n },\n \"spec\": {\n \"flavor\": \"sweeeeeeet\"\n }\n }\n ],\n \"kind\": \"List\",\n \"metadata\": {\n \"resourceVersion\": \"\",\n \"selfLink\": \"\"\n }\n}  \n```", "```\napiVersion: \"awesome.corp.com/v1\" \nkind: Candy \nmetadata: \n  name: chocolate \n  finalizers: \n  - eat-me \n  - drink-me \nspec: \n  flavor: \"sweeeeeeet\" \n```", "```\n--feature-gates=CustomResourceValidation=false    \n```", "```\nvalidation:\n openAPIV3Schema:\n properties:\n spec:\n properties:\n cronSpec:\n type: string\n pattern: '^(\\d+|\\*)(/\\d+)?(\\s+(\\d+|\\*)(/\\d+)?){4}$'\n replicas:\n type: integer\n minimum: 1\n maximum: 10\n```", "```\ntype Scheduler struct { \n    config *Config \n} \n```", "```\ntype Config struct { \n    SchedulerCache schedulercache.Cache \n    Ecache     *core.EquivalenceCache \n    NodeLister algorithm.NodeLister \n    Algorithm  algorithm.ScheduleAlgorithm \n    GetBinder  func(pod *v1.Pod) Binder \n    PodConditionUpdater PodConditionUpdater \n    PodPreemptor PodPreemptor \n    NextPod func() *v1.Pod \n    WaitForCacheSync func() bool \n    Error func(*v1.Pod, error) \n    Recorder record.EventRecorder \n    StopEverything chan struct{} \n    VolumeBinder *volumebinder.VolumeBinder \n} \n```", "```\nfunc registerAlgorithmProvider(predSet, priSet sets.String) { \n    // Registers algorithm providers. By default we use 'DefaultProvider' \n    // but user can specify one to be used by specifying flag. \n    factory.RegisterAlgorithmProvider(factory.DefaultProvider, predSet, priSet) \n    // Cluster autoscaler friendly scheduling algorithm. \n    factory.RegisterAlgorithmProvider(ClusterAutoscalerProvider, predSet, \n        copyAndReplace(priSet, \"LeastRequestedPriority\", \"MostRequestedPriority\")) \n} \n```", "```\ntype ScheduleAlgorithm interface { \n    Schedule(*v1.Pod, NodeLister) (selectedMachine string, err error) \n    Preempt(*v1.Pod, NodeLister, error) (selectedNode *v1.Node,  \n                                         preemptedPods []*v1.Pod,  \n                                         cleanupNominatedPods []*v1.Pod,  \n                                         err error) \n    Predicates() map[string]FitPredicate \n    Prioritizers() []PriorityConfig \n} \n```", "```\ngit clone https://github.com/kubernetes/kubernetes.git\ncd kubernetes\nmake  \n```", "```\nFROM busybox\nADD ./_output/bin/kube-scheduler /usr/local/bin/kube-scheduler  \n```", "```\ndocker build -t custom-kube-scheduler:1.0 .  \n```", "```\n> docker login\n> docker push g1g1/custom-kube-scheduler \n```", "```\napiVersion: apps/v1 \nkind: Deployment \nmetadata: \n  labels: \n    component: scheduler \n    tier: control-plane \n  name: custom-scheduler \n  namespace: kube-system \nspec: \n  replicas: 1 \n  template: \n    metadata: \n      labels:  \n        component: scheduler \n        tier: control-plane \n        version: second \n    spec: \n      containers: \n      - command: \n        - /usr/local/bin/kube-scheduler \n        - --address=0.0.0.0 \n        - --leader-elect=false \n        - --scheduler-name=custom-scheduler \n        image: g1g1/custom-kube-scheduler:1.0 \n        livenessProbe: \n          httpGet: \n            path: /healthz \n            port: 10251 \n          initialDelaySeconds: 15 \n        name: kube-second-scheduler \n        readinessProbe: \n          httpGet: \n            path: /healthz \n            port: 10251 \n        resources: \n          requests: \n            cpu: '0.1' \n```", "```\n$ kubectl create -f custom-scheduler.yaml  \n```", "```\n$ kubectl get pods --namespace=kube-system\nNAME                              READY    STATUS  RESTARTS   AGE\n....\ncustom-scheduler-7cfc49d749-lwzxj  1/1     Running     0        2m\n...  \n```", "```\napiVersion: v1 \nkind: Pod \nmetadata: \n  name: some-pod \n  labels: \n    name: some-pod \nspec: \n  containers: \n  - name: some-container \n    image: gcr.io/google_containers/pause:2.0 \n```", "```\napiVersion: v1 \nkind: Pod \nmetadata: \n  name: some-pod \n  labels: \n    name: some-pod \nspec: \n  schedulerName: custom-scheduler \n  containers: \n  - name: some-container \n    image: gcr.io/google_containers/pause:2.0 \n```", "```\n$ kubectl get events  \n```", "```\nclusters:\n - name: remote-authentication-service\n cluster:\n certificate-authority: /path/to/ca.pem\n server: https://example.com/authenticate\n\nusers:\n - name: k8s-api-server\n user:\n client-certificate: /path/to/cert.pem\n client-key: /path/to/key.pem\n\ncurrent-context: webhook\ncontexts:\n- context:\n cluster: remote-authentication-service\n user: k8s-api-sever\n name: webhook\n```", "```\n{\n  \"apiVersion\": \"authentication.k8s.io/v1beta1\",\n  \"kind\": \"TokenReview\",\n  \"spec\": {\n    \"token\": \"<bearer token from original request headers>\"\n  }\n}    \n```", "```\n{ \n  \"apiVersion\": \"authentication.k8s.io/v1beta1\", \n  \"kind\": \"TokenReview\", \n  \"status\": { \n    \"authenticated\": true, \n    \"user\": { \n      \"username\": \"gigi@gg.com\", \n      \"uid\": \"42\", \n      \"groups\": [ \n        \"developers\", \n      ], \n      \"extra\": { \n        \"extrafield1\": [ \n          \"extravalue1\", \n          \"extravalue2\" \n        ] \n      } \n    } \n  } \n} \n```", "```\n{ \n  \"apiVersion\": \"authentication.k8s.io/v1beta1\", \n  \"kind\": \"TokenReview\", \n  \"status\": { \n    \"authenticated\": false \n  } \n} \n```", "```\n{\n  \"apiVersion\": \"authorization.k8s.io/v1beta1\",\n  \"kind\": \"SubjectAccessReview\",\n  \"spec\": {\n    \"resourceAttributes\": {\n      \"namespace\": \"awesome-namespace\",\n      \"verb\": \"get\",\n      \"group\": \"awesome.example.org\",\n      \"resource\": \"pods\"\n    },\n    \"user\": \"gigi@gg.com\",\n    \"group\": [\n      \"group1\",\n      \"group2\"\n    ]\n  }\n}\n```", "```\n{\n  \"apiVersion\": \"authorization.k8s.io/v1beta1\",\n  \"kind\": \"SubjectAccessReview\",\n  \"status\": {\n    \"allowed\": true\n  }\n} \n```", "```\n{\n  \"apiVersion\": \"authorization.k8s.io/v1beta1\",\n  \"kind\": \"SubjectAccessReview\",\n  \"status\": {\n    \"allowed\": false,\n    \"reason\": \"user does not have read access to the namespace\"\n  }\n}\n```", "```\n{ \n  \"apiVersion\": \"authorization.k8s.io/v1beta1\", \n  \"kind\": \"SubjectAccessReview\", \n  \"spec\": { \n    \"nonResourceAttributes\": { \n      \"path\": \"/logs\", \n      \"verb\": \"get\" \n    }, \n    \"user\": \"gigi@gg.com\", \n    \"group\": [ \n      \"group1\", \n      \"group2\" \n    ] \n  } \n} \n```", "```\napiVersion: admissionregistration.k8s.io/v1alpha1 \nkind: ExternalAdmissionHookConfiguration \nmetadata: \n  name: example-config \nexternalAdmissionHooks: \n- name: pod-image.k8s.io \n  rules: \n  - apiGroups: \n    - \"\" \n    apiVersions: \n    - v1 \n    operations: \n    - CREATE \n    resources: \n    - pods \n  failurePolicy: Ignore \n  clientConfig: \n    caBundle: <pem encoded ca cert that signs the server cert used by the webhook> \n    service: \n      name: <name of the front-end service> \n      namespace: <namespace of the front-end service> \n```", "```\ntype CustomMetricsProvider interface { \n    GetRootScopedMetricByName(groupResource schema.GroupResource,  \n                              name string,  \n                              metricName string) (*custom_metrics.MetricValue, error) \n    GetRootScopedMetricBySelector(groupResource schema.GroupResource,  \n                                  selector labels.Selector,  \n                                  metricName string) (*custom_metrics.MetricValueList,  \n                                                                  error) \n    GetNamespacedMetricByName(groupResource schema.GroupResource,  \n                              namespace string,  \n                              name string,  \n                              metricName string) (*custom_metrics.MetricValue, error) \n    GetNamespacedMetricBySelector(groupResource schema.GroupResource,  \n                                                           namespace string,  \n                                                           selector labels.Selector,  \n                                                           metricName string)  (*MetricValueList, error) \n    ListAllMetrics() []MetricInfo \n}  \n```"]