- en: Getting Started with Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用微服务
- en: In the previous chapter, you learned what Kubernetes is all about, and how it
    is well suited as a platform for developing, deploying, and managing microservices,
    and even played a little with your own local Kubernetes cluster. In this chapter,
    we are going to talk about microservices in general and why they are the best
    way to build complex systems. We will also discuss various aspects, patterns,
    and approaches that address common problems in microservice-based systems and
    how they compare to other common architectures, such as monolith and large services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您了解了Kubernetes的全部内容，以及它如何适合作为开发、部署和管理微服务的平台，甚至还在本地Kubernetes集群中玩了一点。在本章中，我们将讨论微服务的一般情况，以及为什么它们是构建复杂系统的最佳方式。我们还将讨论解决基于微服务的系统中常见问题的各种方面、模式和方法，以及它们与其他常见架构（如单体和大型服务）的比较。
- en: 'We will cover a lot of material in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖大量材料：
- en: Programming in the small – less is more
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在小规模编程中-少即是多
- en: Making your microservice autonomous
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使您的微服务自主
- en: Employing interfaces and contracts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口和契约
- en: Exposing your service via APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过API公开您的服务
- en: Using client libraries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用客户端库
- en: Managing dependencies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理依赖关系
- en: Orchestrating microservices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编排微服务
- en: Taking advantage of ownership
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用所有权
- en: Understanding Conway's law
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解康威定律
- en: Troubleshooting across multiple services
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨多个服务进行故障排除
- en: Utilizing shared service libraries
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用共享服务库
- en: Choosing a source control strategy
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择源代码控制策略
- en: Creating a data strategy
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据策略
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, you'll see some code examples using Go. I recommend that you
    install Go and try to build and run the code examples yourself.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将看到一些使用Go的代码示例。我建议您安装Go并尝试自己构建和运行代码示例。
- en: Installing Go with Homebrew on macOS
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在macOS上使用Homebrew安装Go
- en: 'On macOS, I recommend using Homebrew:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，我建议使用Homebrew：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, make sure the `go` command is available:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请确保`go`命令可用：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To see all the options, just type `go`. Also, make sure that you define `GOPATH`
    in your  `.bashrc` file and add `$GOPATH/bin` to your path.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有选项，只需输入`go`。此外，请确保在您的`.bashrc`文件中定义`GOPATH`并将`$GOPATH/bin`添加到您的路径中。
- en: Go comes with the Go CLI that provides many capabilities, but you may want to
    install additional tools. Check out [https://awesome-go.com/](https://awesome-go.com/).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Go带有Go CLI，提供了许多功能，但您可能希望安装其他工具。查看[https://awesome-go.com/](https://awesome-go.com/)。
- en: Installing Go on other platforms
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在其他平台上安装Go
- en: On other platforms, follow the official instructions here: [https://golang.org/doc/install.](https://golang.org/doc/install)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他平台上，请按照官方说明操作：[https://golang.org/doc/install.](https://golang.org/doc/install)
- en: The code
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码
- en: You can find the code for this chapter here: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter02).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的代码：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter02)。
- en: Programming in the small – less is more
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在小规模编程中-少即是多
- en: Think about the time you learned to program. You wrote little programs that
    accepted simple input, did a little processing, and produced some output. Life
    was good. You could hold the entire program in your head.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你学习编程的时候。你写了一些接受简单输入、进行一些处理并产生一些输出的小程序。生活很美好。你可以把整个程序都记在脑子里。
- en: 'You understood every line of code. Debugging and troubleshooting was easy.
    For example, consider a program to convert temperatures between Celsius and Fahrenheit:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您理解了每一行代码。调试和故障排除都很容易。例如，考虑一个用于在摄氏度和华氏度之间转换温度的程序：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This program is pretty simple. It does a decent job of validating its input
    and displaying usage information if something goes wrong. The actual computation
    the program does is just two lines of code that convert the temperature, but it
    is 45 lines long. There aren't even any comments. Yet, those 45 lines are pretty
    readable and easy to test. There aren't any third-party dependencies (just the
    Go standard library). There is no IO (files, databases, network). There is no
    need for authentication or authorization. There is no need to rate limit calls.
    There is no logging, no metrics collection. There is no versioning, health checks,
    or configuration. There is no deployment to multiple environments and no monitoring
    in production.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序非常简单。它很好地验证了输入，并在出现问题时显示了使用信息。程序实际执行的计算只有两行代码，用于转换温度，但代码长度为45行。甚至没有任何注释。然而，这45行代码非常易读且易于测试。没有第三方依赖（只有Go标准库）。没有IO（文件、数据库、网络）。不需要认证或授权。不需要限制调用速率。没有日志记录，没有指标收集。没有版本控制，健康检查或配置。没有在多个环境中部署和没有在生产中进行监控。
- en: 'Now, consider integrating this simple program into a big enterprise system.
    You''ll have to take into account many of these aspects. Other parts of the system
    will start using the temperature conversion functionality. Suddenly, the simplest
    operations might have cascading impacts. Changes to other parts of the system
    might affect the temperature converter:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑将这个简单的程序集成到一个大型企业系统中。您将不得不考虑其中许多方面。系统的其他部分将开始使用温度转换功能。突然之间，最简单的操作可能会产生连锁影响。系统的其他部分的更改可能会影响温度转换器：
- en: '![](assets/22d9b791-c406-4820-9c02-7d5de80d40bf.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/22d9b791-c406-4820-9c02-7d5de80d40bf.png)'
- en: This jump in complexity is natural. Large enterprise systems have many requirements.
    The promise of microservices is that by following proper architectural guidelines
    and established patterns, the additional complexity can be neatly packaged and
    used across many small microservices that work together to accomplish the system
    goals. Ideally, service developers can be shielded from the encompassing system
    most of the time. However, it takes a lot of effort to provide the right degree
    of isolation and still also allow for testing and debugging in the context of
    the entire system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种复杂性的增加是自然的。大型企业系统有许多要求。微服务的承诺是通过遵循适当的架构指南和已建立的模式，可以将额外的复杂性整齐地打包并用于许多小型微服务，这些微服务共同完成系统目标。理想情况下，服务开发人员大部分时间都可以不受包围系统的影响。然而，提供适当程度的隔离并且仍然允许在整个系统的上下文中进行测试和调试需要付出很大的努力。
- en: Making your microservice autonomous
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使您的微服务自主
- en: One of the best ways to fight complexity is to make your microservice autonomous.
    An autonomous service is a service that doesn't depend on other services in the
    system or third-party services. An autonomous service manages its own state and
    can be largely unaware of the rest of the system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对抗复杂性的最佳方法之一是使您的微服务自主。自主服务是一种不依赖于系统中其他服务或第三方服务的服务。自主服务管理自己的状态，并且在很大程度上可以不了解系统的其余部分。
- en: I like to think of autonomous microservices as similar to immutable functions.
    Autonomous services never change the state of other components in the system. The
    benefit of such services is that their complexity remains the same, regardless
    of how the rest of the system evolves and however they are being used by other
    services.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢将自主微服务看作类似于不可变函数。自主服务永远不会改变系统中其他组件的状态。这种服务的好处是，无论系统的其余部分如何发展，以及它们如何被其他服务使用，它们的复杂性都保持不变。
- en: Employing interfaces and contracts
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用接口和契约
- en: 'Interfaces are one of the best tools a software engineer can use. Once you
    expose something as an interface, you can freely change the implementation behind
    it. Interfaces are a construct that''s being used within a single process. They
    are extremely useful for testing interactions with other components, which are
    plentiful in microservice-based systems. Here is one of the interfaces of our
    sample application:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是软件工程师可以使用的最好工具之一。一旦将某物公开为接口，就可以自由更改其背后的实现。接口是在单个进程中使用的构造。它们对于测试与其他组件的交互非常有用，在基于微服务的系统中这种交互非常丰富。以下是我们示例应用程序的一个接口：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `UserManager` interface defines a few methods, their inputs, and outputs.
    However, it doesn't specify the semantics. For example, what happens if the `Login()`
    method is called for an already logged-in user? Is it an error? Is the previous
    session terminated and a new session created? Is it returning the existing session
    without an error (idempotent approach)? These kinds of questions are answered
    by contracts. Contracts are difficult to specify fully and Go doesn't provide
    any support for contracts. But, contracts are important and they always exist,
    even if only implicitly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserManager`接口定义了一些方法，它们的输入和输出。但是，它没有指定语义。例如，如果对已经登录的用户调用`Login()`方法会发生什么？这是一个错误吗？先前的会话是否终止并创建一个新会话？它是否返回现有会话而不出现错误（幂等方法）？这些问题由合同回答。合同很难完全指定，Go不提供对合同的任何支持。但是，合同很重要，它们总是存在的，即使只是隐含地存在。'
- en: Some languages don't support interfaces as a first-class syntactic construct
    of the language. However, it is very easy to accomplish the same effect. Languages
    with dynamic typing, such as Python, Ruby, and JavaScript, allow you to pass any
    object that satisfies the set of attributes and methods used by the caller. Static
    languages, such as C and C++, get by with sets of function pointers (C) or structs
    with only pure virtual functions (C++).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言不支持接口作为语言的第一类语法结构。但是，实现相同效果非常容易。动态类型的语言，如Python，Ruby和JavaScript，允许您传递任何满足调用者使用的属性和方法集的对象。静态语言，如C和C++，通过函数指针集（C）或仅具有纯虚函数的结构（C++）来实现。
- en: Exposing your service via APIs
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过API公开您的服务
- en: Microservices interact with each other and sometimes with the outside world
    over the network. A service exposes its capabilities through an API. I like to
    think of APIs as over-the-wire interfaces. Programming language interfaces use
    the syntax of the language they are written in (for example, Go's interface type).
    Modern network APIs also use some high-level representation. The foundation is
    UDP and TCP. However, microservices will typically expose their capabilities over
    web transports, such as HTTP (REST, GraphQL, SOAP), HTTP/2 (gRPC), or, in some
    cases, WebSockets. Some services may imitate other wire protocols, such as memcached,
    but this is useful in special situations. In 2019, there is really no reason to
    build your own custom protocol directly over TCP/UDP or use proprietary and language-specific
    protocols. Approaches such as Java RMI, .NET remoting, DCOM, and CORBA are better
    left in the past, unless you need to support some legacy code base.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务之间有时会通过网络相互交互，有时还会与外部世界进行交互。服务通过API公开其功能。我喜欢将API想象为通过网络的接口。编程语言接口使用其所编写的语言的语法（例如，Go的接口类型）。现代网络API也使用一些高级表示。基础是UDP和TCP。但是，微服务通常会通过Web传输公开其功能，例如HTTP（REST，GraphQL，SOAP），HTTP/2（gRPC），或者在某些情况下是WebSockets。一些服务可能模仿其他的线路协议，例如memcached，但这在特殊情况下很有用。在2019年，没有理由直接在TCP/UDP上构建自定义协议或使用专有和特定于语言的协议。像Java
    RMI，.NET remoting，DCOM和CORBA这样的方法最好留在过去，除非您需要支持一些遗留代码库。
- en: 'There are two categories of microservices, which are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种微服务的类别，如下所示：
- en: Internal microservices are only accessible to other microservices running typically
    in the same network/cluster and those services can expose more specialized APIs
    because you're in control of both services and their clients (other services).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部微服务只能被通常在相同网络/集群中运行的其他微服务访问，这些服务可以暴露更专业的API，因为你可以控制这两个服务及其客户端（其他服务）。
- en: External services are open to the world and often need to be consumed from web
    browsers or clients using multiple languages.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部服务对外开放，并且通常需要从Web浏览器或使用多种语言的客户端进行消费。
- en: The benefit of using standard network APIs over standard language-agnostic transports
    is that it enables the polyglot promise of microservices. Each service may be
    implemented in its own programming language (for example, one service in Go and
    another in Python) and they may even migrate to a completely different language
    later (Rust, anyone?) without disruption, as all these services interact through
    the network API. We will examine later the polyglot approach and its trade-offs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准网络API而不是标准语言无关的传输的好处在于它实现了微服务的多语言承诺。每个服务可以用自己的编程语言实现（例如，一个服务用Go，另一个用Python），它们甚至可以在以后完全不同的语言中迁移（比如Rust），而不会造成中断，因为所有这些服务都通过网络API进行交互。我们将在后面讨论多语言方法及其权衡。
- en: Using client libraries
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用客户端库
- en: Interfaces are very convenient to work with. You operate within your programming
    language environments, calling methods with native data types. Working with network
    APIs is different. You need to use a network library, depending on the transport.
    You need to serialize your payload and responses and deal with network errors,
    disconnects, and timeouts. The client library pattern encapsulates the remote
    service and all these decisions and presents you with a standard interface that,
    as a client of the service, you just call. The client library behind the scenes
    will take care of all the ceremony involved with invoking a network API. The law
    of leaky abstractions ([https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/))
    says that you can't really hide the network. However, you can hide it pretty effectively
    from the consumer service and configure it properly with policies regarding timeouts,
    retries, and caching.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接口非常方便。你可以在你的编程语言环境中操作，使用本地数据类型调用方法。使用网络API是不同的。你需要根据传输方式使用网络库。你需要序列化你的有效负载和响应，并处理网络错误、断开连接和超时。客户端库模式封装了远程服务和所有这些决策，并为你提供一个标准接口，作为服务的客户端，你只需调用它。客户端库在幕后会处理调用网络API所涉及的所有仪式。泄漏抽象的法则（[https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/)）说你实际上无法隐藏网络。然而，你可以很有效地隐藏它，使消费服务不受影响，并使用关于超时、重试和缓存的策略进行正确配置。
- en: One of the greatest selling points of gRPC is that it generates a client library
    for you.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC最大的卖点之一是它为你生成了一个客户端库。
- en: Managing dependencies
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理依赖关系
- en: 'Modern systems have a lot of dependencies. Managing them effectively is a big
    part of the **software development life cycle** (**SDLC**). There are two kinds
    of dependencies:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现代系统有很多依赖关系。有效地管理它们是**软件开发生命周期**（**SDLC**）的重要组成部分。有两种依赖关系：
- en: Libraries/packages (linked to the running service process)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库/包（链接到运行服务进程）
- en: Remote services (accessible over the network)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程服务（可通过网络访问）
- en: Each of these dependencies can be internal or third party. You manage libraries
    or packages through your language's package management system. Go had no official
    package management system for a long time and several solutions, such as Glide
    and Dep, came along. These days (Go 1.12), Go modules are the official solution.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖关系中的每一个都可以是内部的或第三方的。您通过语言的包管理系统来管理库或软件包。Go很长一段时间没有官方的包管理系统，出现了几种解决方案，例如Glide和Dep。如今（Go
    1.12），Go模块是官方解决方案。
- en: You manage remote services through the discovery of endpoints and tracking API
    versions. The difference between internal dependencies and third-party dependencies
    is the velocity of change. Internal dependencies will change much faster. With
    microservices, you'll have other microservices you depend on. Versioning and keeping
    track of the contracts behind the APIs become very important aspects of development.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过发现端点和跟踪API版本来管理远程服务。内部依赖和第三方依赖之间的区别在于变化的速度。内部依赖将更快地发生变化。使用微服务时，您将依赖于其他微服务。版本控制和跟踪API背后的合同成为开发中非常重要的方面。
- en: Coordinating microservices
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协调微服务
- en: When comparing a monolith system with a microservice-based system, one thing
    is clear. There is more of everything. The individual microservices are simpler
    and it's much easier to reason, modify, and troubleshoot individual services.
    But, understanding the whole system, making changes across multiple services,
    and debugging problems are more challenging. Many more interactions also happen
    over the network between separate microservices, where, with a monolith, these
    interactions would occur within the same process. It means that to benefit from
    microservices, you need a disciplined approach, you need to apply best practices,
    and have good tools at your disposal.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当将单体系统与基于微服务的系统进行比较时，有一件事是清楚的。一切都更多。单个微服务更简单，更容易理解，修改和排除单个服务的问题。但是，理解整个系统，跨多个服务进行更改和调试问题更具挑战性。还会在单独的微服务之间通过网络发生更多的交互，而在单体系统中，这些交互将在同一进程中发生。这意味着要从微服务中受益，您需要一种纪律严明的方法，需要应用最佳实践，并且需要有您可以使用的良好工具。
- en: The uniformity versus flexibility trade-off
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一性与灵活性的权衡
- en: 'Let''s say you have a hundred microservices, but they are all very small and
    very similar. They all use the same data store (for example, the same type of
    relational database). They are all configured in the same way (for example, a
    configuration file). They all report errors and logs to a centralized log server.
    They are all implemented using the same programming language (for example, Go).
    Typically, the system will handle several use cases. Each use case will involve
    some subset of these hundred microservices. There will also be some generic microservices
    that are used in most use cases (for example, an authorization service). Then,
    it may not be that difficult to understand the system as a whole, given some good
    documentation. You can look at each use case separately and, when you extend the
    system and add more use cases, and maybe grow to a thousand microservices, the
    complexity remains bounded:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一百个微服务，但它们都非常小且非常相似。它们都使用相同的数据存储（例如，相同类型的关系数据库）。它们都以相同的方式配置（例如，配置文件）。它们都将错误和日志报告给集中日志服务器。它们都使用相同的编程语言实现（例如，Go）。通常，系统将处理几个用例。每个用例将涉及这一百个微服务的一些子集。还将有一些通用微服务在大多数用例中使用（例如，授权服务）。然后，理解整个系统可能并不那么困难，只要有一些良好的文档。您可以单独查看每个用例，并且当您扩展系统并添加更多用例，并且可能增长到一千个微服务时，复杂性仍然受到限制。
- en: '![](assets/5ff8b12e-29ea-47cf-827d-3ecab507da8c.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5ff8b12e-29ea-47cf-827d-3ecab507da8c.png)'
- en: A good analogy is files and directories. Suppose you organize your music by
    genre, artist, and song. Initially, you had three genres, 20 artists, and 200
    songs. Then, you expanded everything and now have 10 genres, 50 artists, and 3,000
    songs. The organization is still the same old hierarchy of genre/artist/song.
    It's true that at some point when you scale, the sheer scale can present new problems.
    For example, with music, when you have so much music that it doesn't fit on your
    hard disk, you need a qualitatively different solution (for example, keep it in
    the cloud). The same is true for microservices, but the divide and conquer approach
    works well. If you reach internet-scale—Amazon, Google, Facebook—then, yes, you'll
    need much more elaborate solutions for every aspect.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的类比是文件和目录。假设您按流派、艺术家和歌曲组织您的音乐。最初，您有三种流派，20位艺术家和200首歌曲。然后，您扩展了一切，现在有10种流派，50位艺术家和3,000首歌曲。组织仍然是相同的旧的流派/艺术家/歌曲的层次结构。当您扩展到一定程度时，规模本身可能会带来新的问题。例如，对于音乐，当您的音乐太多，无法放入硬盘时，您需要一种质量上不同的解决方案（例如，将其保存在云中）。对于微服务也是如此，但分而治之的方法效果很好。如果您达到互联网规模——亚马逊、谷歌、Facebook——那么，是的，您需要更为复杂的解决方案来解决每个方面的问题。
- en: But, with uniform microservices, you sacrifice a number of benefits. For example,
    teams and developers may be forced to use a programming language that is not best
    for the task, or they'll have to abide by strict operational standards of logging
    and error reporting, even for small non-critical internal services.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用统一的微服务，你会牺牲许多好处。例如，团队和开发人员可能被迫使用不适合任务的编程语言，或者他们将不得不遵守严格的日志记录和错误报告的操作标准，即使是针对小型非关键的内部服务。
- en: You need to understand the pros and cons of uniform versus diverse microservices.
    There is a spectrum ranging from totally uniform microservices to a jungle of
    anything goes, where each microservice is a unique snowflake. Your responsibility
    is to find the sweet spot along this spectrum for your system.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要了解统一与多样化微服务的利弊。这是一个从完全统一的微服务到任何事物都可以的范围，每个微服务都是独特的雪花的光谱。您的责任是在这个光谱上找到系统的最佳位置。
- en: Taking advantage of ownership
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用所有权
- en: Since microservices are small. A single developer can own a whole microservice
    and understand it completely. Other developers may also be familiar with it, but
    even if just a single developer is familiar with a service, it should be relatively
    simple and painless for a new developer to take over because the scope is so limited
    and ideally similar.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务很小。一个开发人员可以拥有整个微服务并完全了解它。其他开发人员也可能熟悉它，但即使只有一个开发人员熟悉一个服务，新开发人员接手应该也相对简单和无痛，因为范围是如此有限且理想情况下相似。
- en: Sole ownership can be very powerful. The developer needs to communicate with
    the other developers and teams though the service API, but can iterate very fast
    on the implementation. You may still want other developers on the team to review
    the internal design and implementation, but even in the extreme case that the
    owner works completely on their own with no supervision, the potential damage
    is limited because the scope of each microservice is small and it interacts with
    the rest of the system through well-defined APIs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 独占所有权可以非常强大。开发人员需要通过服务API与其他开发人员和团队进行沟通，但可以在实现上非常快速地迭代。您可能仍希望团队中的其他开发人员审查内部设计和实现，但即使在极端情况下，所有者完全独立工作且没有监督，潜在的损害也是有限的，因为每个微服务的范围都很小，并且通过明确定义的API与系统的其余部分进行交互。
- en: The differences in productivity can be jaw-dropping.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 生产力的差异可能令人瞠目结舌。
- en: Understanding Conway's law
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解康威定律
- en: 'Conway''s law is defined as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 康威定律的定义如下：
- en: '"Organizations which design systems ... are constrained to produce designs
    which are copies of the communication structures of these organizations."'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 设计系统的组织受限于产生与这些组织的沟通结构相同的设计。
- en: 'This means the structure of the system will reflect the structure of the team
    building it. A famous variation by Eric Raymond is this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着系统的结构将反映构建它的团队的结构。埃里克·雷蒙德的一个著名变体是：
- en: '"If you have four groups building a compiler you''ll get a 4-pass compiler."'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: “如果有四个组建编译器的团队，你将得到一个4通道编译器。”
- en: 'This is very insightful and I''ve personally witnessed it time and again in
    many different organizations. This is very relevant to microservice-based systems.
    With lots of small microservices, you don''t need a dedicated team for each microservice.
    There will be some higher-level groups of microservices that work together to
    produce some aspect of the system. Now, the question is how to think about the
    high-level structure. There are three main options:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有洞察力，我个人在许多不同的组织中一再见证了这一点。这与基于微服务的系统非常相关。有了许多小的微服务，你不需要为每个微服务专门的团队。会有一些更高级别的微服务组合在一起，以产生系统的某些方面。现在，问题是如何考虑高层结构。有三个主要选项：
- en: Vertical
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直
- en: Horizontal
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平
- en: Matrix
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵
- en: 'Microservices can be very important in this regard. By being small autonomous
    components, they support all structures. But, what is even more important is when
    organizations need to transition from one approach to another. The usual trajectory
    is: horizontal | vertical | matrix.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，微服务可能非常重要。作为小型自治组件，它们支持所有结构。但更重要的是，当组织需要从一种方法转变为另一种方法时。通常的轨迹是：水平|垂直|矩阵。
- en: The organization can perform those transitions with much less friction if the
    software follows a microservice-based architecture. It can even be a deciding
    factor. Even an organization that doesn't follow microservice-based architecture
    decides to stay with an inappropriate structure because the risk and effort of
    breaking the monolith is too high.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果软件遵循微服务架构，组织可以以更少的摩擦进行这些转变。这甚至可能成为一个决定性因素。即使不遵循微服务架构的组织决定继续使用不合适的结构，因为打破单体的风险和努力太大。
- en: Vertical
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垂直
- en: 'The vertical approach takes a slice of functionality of the system that comprises
    multiple microservices and a team is fully responsible for that functionality,
    from design to implementation, through deployment and maintenance. Teams operate
    as silos and communication between them is typically limited and formal. This
    approach favors aspects of microservices, such as the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直方法将系统的功能切片，包括多个微服务，并且一个团队完全负责该功能，从设计到实施，再到部署和维护。团队作为孤立体运作，它们之间的沟通通常是有限和正式的。这种方法有利于微服务的一些方面，比如以下内容：
- en: Polyglot
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多语言
- en: Flexibility
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活性
- en: Independently moving pieces
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立移动的部分
- en: End-to-end ownership
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端的所有权
- en: Less formal contracts within the vertical slice
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直切片内部的合同不太正式
- en: Easy-to-scale to more vertical slices (just form another team)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于扩展到更多的垂直切片（只需组建另一个团队）
- en: Difficult to apply changes across vertical slices, especially as the number
    of vertical slices scales
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨垂直切片应用变更很困难，特别是随着垂直切片数量的增加。
- en: This approach is common in very large organizations due to its scalability advantages.
    It also requires a lot of creativity and effort to make improvements across the
    board. There will be duplication of effort between the silos. Aiming for complete
    reuse and coordination is futile. The trick with the vertical approach is to find
    the sweet spot, where common functionality is packaged in a way that can be used
    by multiple silos, but without requiring explicit coordination.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在非常大的组织中很常见，因为它具有可扩展性的优势。这也需要大量的创造力和努力来在全面上取得改进。筒仓之间会有工作重复。追求完全重用和协调是徒劳的。垂直方法的诀窍在于找到甜蜜点，将通用功能打包成一种可以被多个筒仓使用的方式，但不需要明确的协调。
- en: Horizontal
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 水平
- en: The horizontal approach looks at the system as a layered architecture. The team
    structure is organized along those layers. There may be a frontend group, backend
    group, and a DevOps group. Each group is responsible for all the aspects in their
    layer. Vertical functionality is implemented by a collaboration between different
    groups across all layers. This approach is more suitable for smaller organizations
    with a small numbers of products (sometimes just one).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 水平方法将系统视为分层架构。团队结构沿着这些层组织。可能会有一个前端组、后端组和一个DevOps组。每个组对他们层面的所有方面负责。垂直功能是通过所有层的不同组之间的协作来实现的。这种方法更适合产品数量较少的较小组织（有时只有一个）。
- en: The nice thing about the horizontal approach is that the organization can build
    expertise and share knowledge across entire horizontal layers. Typically, organizations
    start with a horizontal organization and, as they grow and then expand to more
    products, or possibly spread across multiple geographic locations, they divide
    into a more vertical structure. Within each silo, the structure is usually horizontal.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 水平方法的好处在于组织可以在整个水平层面建立专业知识并分享知识。通常，组织从水平组织开始，随着它们的增长，可能扩展到更多的产品，或者可能扩展到多个地理位置，它们会分成更垂直的结构。在每个筒仓内，结构通常是水平的。
- en: Matrix
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵
- en: The matrix organization is the most complicated. You have your vertical silos,
    but the organization recognizes that the amount of duplication and variation between
    the silos waste resources and also makes transferring people between vertical
    silos challenging if they diversify too much. With a matrix organization, in addition
    to the vertical silos, there are also cross-cutting groups that work with all
    vertical silos and try to bring some level of consistency, uniformity, and order.
    For example, the organization may dictate that all vertical silos must deploy
    their software to the cloud on AWS. In this case, there may be a cloud platform
    group that is managed outside the vertical silos and provides guidance, tooling,
    and other shared services for all the vertical silos. Security is another good
    example. Many organizations consider security an area that must be managed centrally
    and can't be left to the whims of each silo.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵组织是最复杂的。你有你的垂直筒仓，但组织认识到筒仓之间的重复和变化浪费资源，也使得在筒仓之间转移人员变得具有挑战性，如果它们分散得太多。在矩阵组织中，除了垂直筒仓，还有横切组，他们与所有垂直筒仓合作，并试图带来一定程度的一致性、统一性和秩序。例如，组织可能规定所有垂直筒仓必须将他们的软件部署到AWS云上。在这种情况下，可能会有一个云平台组，由垂直筒仓之外管理，并为所有垂直筒仓提供指导、工具和其他共享服务。安全性是另一个很好的例子。许多组织认为安全是必须集中管理的领域，不能任由每个筒仓的心情而定。
- en: Troubleshooting across multiple services
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨多个服务进行故障排除
- en: Since most of the functions of the system will involve interactions between
    multiple microservices, it's important to be able to follow a request coming in
    across all those microservices and various data stores. One of the best ways to
    accomplish this is distributed tracing, where you tag each request and can follow
    it from beginning to end.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于系统的大多数功能将涉及多个微服务之间的交互，能够跟踪请求从所有这些微服务和各种数据存储中进入是非常重要的。实现这一点的最佳方法之一是分布式跟踪，您可以为每个请求打上标记，并可以从头到尾跟踪它。
- en: 'The subtleties of debugging distributed systems in general and microservice-based
    ones take a lot of expertise. Consider the following aspects along the path of
    a single request through the system:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 调试分布式系统和基于微服务的系统的微妙之处需要很多专业知识。考虑单个请求通过系统的以下方面：
- en: The microservices processing the request may use different programming languages.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理请求的微服务可能使用不同的编程语言。
- en: The microservices may expose APIs using different transports/protocols.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务可以使用不同的传输/协议公开API。
- en: Requests may be part of asynchronous workflows that involve waiting in queues
    and/or periodical processing.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求可能是异步工作流的一部分，涉及在队列中等待和/或周期性处理。
- en: The persistent state of the request may be spread across many independent data
    stores controlled by different microservices.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求的持久状态可能分布在许多由不同微服务控制的独立数据存储中。
- en: When you need to debug a problem across the entire swath of microservices in
    the system, the autonomous nature of each microservice becomes a hindrance. You
    must build explicit support to be able to gain system-level visibility by aggregating
    internal information from multiple microservices.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要在系统中跨越整个微服务范围调试问题时，每个微服务的自治性变成了一种障碍。您必须构建明确的支持，以便通过聚合来自多个微服务的内部信息来获得系统级别的可见性。
- en: Utilizing shared service libraries
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用共享服务库
- en: 'If you choose the uniform microservices approach, it is very useful to have
    a shared library (or several libraries) that all services use and implement many
    cross-cutting concerns, such as the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择统一的微服务方法，拥有一个所有服务都使用并实现许多横切关注点的共享库（或多个库）非常有用，例如以下内容：
- en: Configuration
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置
- en: Secret management
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密管理
- en: Service discovery
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现
- en: API wrapping
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API包装
- en: Logging
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录
- en: Distributed tracing
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式跟踪
- en: This library may implement whole workflows, such as authentication and authorization,
    that interact with other microservices or third-party dependencies and do the
    heavy lifting for each microservice. This way, the microservice is only responsible
    for using these libraries properly and implements its own functionality.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库可以实现整个工作流程，比如与其他微服务或第三方依赖项交互的身份验证和授权，并为每个微服务进行繁重的工作。这样，微服务只负责正确使用这些库并实现自己的功能。
- en: This approach can work even if you choose the polyglot path and support multiple
    languages. You can implement this library for all the supported languages and
    the services themselves can be implemented in different languages.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您选择多语言路径并支持多种语言，这种方法也可以工作。您可以为所有支持的语言实现这个库，服务本身可以用不同的语言实现。
- en: However, there are costs associated with the maintenance and evolution of shared
    libraries and the rate of adopting them by all microservices. A real danger is
    that different microservices will use many versions of the shared libraries and
    cause subtle (or not so subtle) problems when services using different versions
    of the shared library try to communicate.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，共享库的维护和演进以及所有微服务采用它们的速度都会带来成本。一个真正的危险是不同的微服务将使用许多版本的共享库，并且当使用不同版本的共享库的服务进行通信时会导致微妙（或不那么微妙）的问题。
- en: The service mesh approach that we will explore later in the book can provide
    some answers to this issue.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在书中后面探讨的服务网格方法可以为这个问题提供一些答案。
- en: Choosing a source control strategy
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择源代码控制策略
- en: 'This is a very interesting scenario. There are two main approaches: monorepo
    and multiple repos. Let''s explore the pros and cons of each.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有趣的场景。有两种主要方法：monorepo和多个repos。让我们探讨每种方法的利弊。
- en: Monorepo
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Monorepo
- en: In the monorepo approach, your entire code base is in a single source control
    repository. It is very easy to perform operations over the entire code base. Whenever
    you make a change, it is reflected immediately in your entire code base. Versioning
    is pretty much off the table. That's great for keeping all your code in sync.
    But, if you do need to upgrade some parts of your systems incrementally, you'll
    need to come up with workarounds, such as creating a separate copy with your new
    changes. Also, the fact that your source code is always in sync doesn't mean that
    your deployed services are all using the latest version. If you always deploy
    all your services at once, you're pretty much building a monolith. Note that you
    may still have multiple repos if you contribute to third-party open source projects
    (even if you only use upstream versions after your changes were merged).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在monorepo方法中，你的整个代码库都在一个单一的源代码控制存储库中。对整个代码库执行操作非常容易。每当你进行更改时，它立即反映在整个代码库中。版本控制基本上不可行。这对于保持所有代码同步非常有用。但是，如果你确实需要逐步升级系统的某些部分，你需要想出解决方法，比如创建一个带有新更改的单独副本。此外，你的源代码始终保持同步并不意味着你部署的服务都在使用最新版本。如果你总是一次性部署所有服务，你基本上就是在构建一个单体应用。请注意，即使你的更改已经合并，你仍然可能有多个repo，如果你为第三方开源项目做出贡献（即使你只使用你的更改合并后的上游版本）。
- en: Another big issue with monorepo is that you might need a lot of custom tooling
    to manage your multi repo. Large companies, such as Google and Microsoft, use
    the multi-repo approach. They have special needs and the custom tooling aspect
    doesn't deter them. I'm on the fence if the multi-repo approach is appropriate
    for smaller organizations. However, I'll use a monorepo for the Delinkcious —the
    demo application—so, we will get to explore it together and form an opinion. A
    major downside is that many modern CI/CD tool chains use GitOps, which trigger
    changes in source control repos. When there is just one monorepo, you lose the
    one-to-one mapping between a source control repo and a microservice.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Monorepo的另一个大问题是，你可能需要大量定制工具来管理你的多个repo。像谷歌和微软这样的大公司使用多repo方法。他们有特殊的需求，定制工具方面并不会阻碍他们。我对于多repo方法是否适合较小的组织持保留态度。然而，我会在Delinkcious（演示应用）中使用monorepo，这样我们可以一起探索并形成意见。一个主要的缺点是许多现代CI/CD工具链使用GitOps，这会触发源代码控制repo中的更改。当只有一个monorepo时，你失去了源代码控制repo和微服务之间的一对一映射。
- en: Multiple repos
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个repos
- en: 'The multiple repos approach is exactly the opposite. Each project, and often
    each library, has a separate source control repository. Projects consume each
    other just like third-party libraries. There are several advantages to this approach:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 多repo方法恰恰相反。每个项目，通常每个库，都有一个单独的源代码控制存储库。项目之间相互消费，就像第三方库一样。这种方法有几个优点：
- en: Clear physical boundaries between projects and services.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目和服务之间清晰的物理边界。
- en: One-to-one mapping of source control repositories and services or projects.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码控制存储库和服务或项目之间的一对一映射。
- en: It is easy to map deployments of services to source control repositories.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将服务的部署映射到源代码控制存储库非常容易。
- en: Uniform treatment of all dependencies—internal and third party.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一对待所有依赖项——内部和第三方。
- en: 'However, there are significant costs to this approach, especially as the number
    of services and projects grows and the dependency graphs between them become more
    complicated:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法存在显著的成本，特别是随着服务和项目数量的增长以及它们之间的依赖关系图变得更加复杂时：
- en: Applying changes often requires changes across multiple repositories.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经常需要在多个存储库中应用变更。
- en: You often need to maintain multiple versions of a repository, as different services
    depend on different services.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常需要维护存储库的多个版本，因为不同的服务依赖不同的服务。
- en: It is difficult to apply cross-cutting changes across all repositories.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有存储库中应用横切变化是困难的。
- en: Hybrid
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合
- en: The hybrid approach involves using a small number of repositories. Each repository
    contains multiple services and projects. Each repository is isolated from the
    other repositories, but within each repo, multiple services and projects can be
    developed in lockstep. This approach balances the pros and cons of monorepo and
    multiple repos. It may be useful when there are clear organizational boundaries
    and often geographical boundaries. For example, if a company has multiple product
    lines that are completely independent, it may be a good idea to break each product
    line into its own monorepo.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 混合方法涉及使用少量存储库。每个存储库包含多个服务和项目。每个存储库与其他存储库隔离，但在每个存储库内，多个服务和项目可以同时开发。这种方法平衡了单存储库和多个存储库的利弊。当存在明确的组织边界和经常存在地理边界时，这可能是有用的。例如，如果一家公司有多个完全独立的产品线，将每个产品线分成自己的单存储库可能是一个好主意。
- en: Creating a data strategy
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据策略
- en: One the most important responsibilities of a software system is to manage data.
    There are many types of data, and most of the data, should survive any failure
    of the system or you should be able to reconstruct it. Data often has complex
    relationships with other data. This is very explicit with relational databases,
    but exists in other types of data, too. Monoliths typically use large data stores
    that keep all the related data and, as a result, can perform queries and transactions
    over the entire set of data. Microservices are different. Each microservice is
    autonomous and responsible for its data. However, the system as a whole needs
    to query and operate over data that is now stored in many independent data stores
    and managed by many different services. Let's examine how to address this challenge
    using best practices.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 软件系统最重要的责任之一是管理数据。有许多类型的数据，大多数数据应该在系统故障时幸存，或者您应该能够重建它。数据通常与其他数据有复杂的关系。这在关系数据库中非常明显，但也存在于其他类型的数据中。单体应用通常使用大型数据存储，保存所有相关数据，因此可以对整个数据集执行查询和事务。微服务是不同的。每个微服务都是自治的，负责自己的数据。然而，整个系统需要查询和操作现在存储在许多独立数据存储中并由许多不同服务管理的数据。让我们看看如何使用最佳实践来解决这一挑战。
- en: One data store per microservice
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个微服务一个数据存储
- en: The one data store per microservice is a crucial element of the microservice
    architecture. The moment two microservices can access directly the same data store,
    they are tightly coupled and are no longer independent. There are a few important
    nuances to understand. It may be OK for multiple microservices to use the same
    database instance, but they must not share the same logical database.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务一个数据存储是微服务架构的关键元素。一旦两个微服务可以直接访问相同的数据存储，它们就紧密耦合，不再是独立的。有一些重要的细微差别需要理解。多个微服务使用同一个数据库实例可能没问题，但它们不能共享相同的逻辑数据库。
- en: The database instance is a resource provisioning concern. In some cases, the
    team developing the microservice is responsible for provisioning its data stores
    too. In this case, the wise move may be to have physically separate DB instances
    for each microservice and not just logical ones. Note that when using cloud data
    stores, the microservice developer is not in control and unaware of the physical
    configuration of the data store.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库实例是一个资源配置问题。在某些情况下，开发微服务的团队也负责为其提供数据存储。在这种情况下，明智的做法可能是为每个微服务有物理上分开的数据库实例，而不仅仅是逻辑实例。请注意，在使用云数据存储时，微服务开发人员无法控制并且不知道数据存储的物理配置。
- en: 'We agree that two microservices shouldn''t share the same data store. But,
    what about a single microservice managing two or more data stores? This is generally
    also frowned upon. If your design calls for two separate data stores, it''s better
    to dedicate a microservice to each one:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同意两个微服务不应共享相同的数据存储。但是，如果一个单一的微服务管理两个或更多的数据存储呢？这通常也是不被赞同的。如果您的设计需要两个单独的数据存储，最好为每个专门指定一个微服务：
- en: '![](assets/7138b4e0-3d48-4cae-9be7-551d2f68fc2f.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7138b4e0-3d48-4cae-9be7-551d2f68fc2f.png)'
- en: There is one common exception—you may want to manage an in-memory data store
    (cache) and a persistent data store by the same microservice. The workflow is
    that the service is writing to the persistent store and the cache and serving
    queries from the cache. The cache is either refreshed periodically, or based on
    change notification, or when there is a cache miss.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个常见的例外情况——您可能希望由同一个微服务管理内存数据存储（缓存）和持久数据存储。工作流程是服务将数据写入持久存储和缓存，并从缓存中提供查询。缓存可以定期刷新，或者基于更改通知，或者在缓存未命中时刷新。
- en: But, even in this case, it may be a better design to have a separate centralized
    cache, such as Redis managed by a separate microservice. Remember that each microservice
    may have multiple instances in a large system that serves many users.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使在这种情况下，使用一个单独的集中式缓存，比如由一个单独的微服务管理的Redis，可能是更好的设计。请记住，在服务众多用户的大型系统中，每个微服务可能有多个实例。
- en: Another reason to abstract away the physical configuration and provisioning
    of data stores from the microservices themselves is that those configurations
    may be different in different environments. Your production environment may have
    physically separate data stores for each microservice, but, in your development
    environment, it may be better to have just one physical database instance with
    lots of small logical databases.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个将数据存储的物理配置和配置从微服务本身抽象出来的原因是，这些配置在不同的环境中可能是不同的。您的生产环境可能为每个微服务有物理上分开的数据存储，但在开发环境中，最好只有一个物理数据库实例，有许多小的逻辑数据库。
- en: Running distributed queries
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行分布式查询
- en: 'We agree that each microservice should have its own data store. This means that
    the overall state of the system will be distributed across multiple data stores,
    accessible only from their own microservices. Most interesting queries will involve
    data available in multiple data stores. Each consumer could just access all these
    microservices and aggregate all the data to satisfy their query. However, that
    is sub-optimal for several reasons:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同意每个微服务应该有自己的数据存储。这意味着系统的整体状态将分布在多个数据存储中，只能从它们自己的微服务中访问。大多数有趣的查询将涉及多个数据存储中可用的数据。每个消费者只需访问所有这些微服务并聚合所有数据以满足其查询。然而，出于几个原因，这是次优的：
- en: Consumers are intimately aware of how data is managed by the system.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者深刻了解系统如何管理数据。
- en: Consumers need to get access to each and every service that stores data relevant
    to the query.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者需要访问存储与查询相关数据的每项服务。
- en: Changing the architecture might require changes to a lot of consumers.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改架构可能需要更改许多消费者。
- en: 'There are two common solutions to address this issue: CQRS and API composition.
    The cool thing about it is that the services that enable both solutions have the
    same API, so it is possible to switch from one solution to another, or even mix
    and match without impacting users. This means that some queries will be serviced
    by CQRS and others by API composition, all implemented by the same service. Overall,
    I recommend to start with API composition and transition to CQRS only if the proper
    conditions exist and benefits are compelling, due to its much higher complexity.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的两种常见解决方案是CQRS和API组合。它的很酷之处在于，实现这两种解决方案的服务具有相同的API，因此可以在不影响用户的情况下从一种解决方案切换到另一种解决方案，甚至混合使用。这意味着一些查询将由CQRS提供服务，而另一些查询将由API组合提供服务，所有这些都由同一个服务实现。总的来说，我建议从API组合开始，只有在存在适当条件并且收益是强制性的情况下才过渡到CQRS，因为它的复杂性要高得多。
- en: Employing Command Query Responsibility Segregation
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用命令查询职责分离
- en: With **Command Query Responsibility Segregation** (**CQRS**), the data from
    the various microservices is aggregated to a new read-only data store that is
    designed to answer specific queries. The meaning of the name is that you separate
    (segregate) the responsibility of updating data (commands) from the responsibility
    of reading data (queries). Different services are in charge of those activities.
    It is often implemented by watching for changes to all data stores and requires
    a change notification system in place. You could use polling too, but that's often
    undesirable. This solution shines when there are known queries that are used often.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**命令查询职责分离**（**CQRS**），来自各种微服务的数据被聚合到一个新的只读数据存储中，该存储被设计用来回答特定的查询。名称的含义是，您将更新数据（命令）的责任与读取数据（查询）的责任分开（分离）。不同的服务负责这些活动。通常通过观察所有数据存储的变化来实现，并需要一个变更通知系统。您也可以使用轮询，但这通常是不可取的。当已知查询经常使用时，这种解决方案会发挥作用。
- en: Here is an illustration of CQRS in action. The CQRS service (responsible for
    queries) receives a change notification from the three microservices (responsible
    for updates) and aggregates them into its own data store.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是CQRS在实际中的示例。CQRS服务（负责查询）从三个微服务（负责更新）接收到变更通知，并将它们聚合到自己的数据存储中。
- en: 'When a query comes, the CQRS service responds by accessing its own aggregated
    view without hitting the microservices:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询到来时，CQRS服务通过访问自己的聚合视图来响应，而不会影响微服务：
- en: '![](assets/e8fdf295-52a4-45a9-b42e-5c2a8c766feb.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e8fdf295-52a4-45a9-b42e-5c2a8c766feb.png)'
- en: 'The pros are as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 优点如下：
- en: Queries don't interfere with updating the primary data store.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询不会干扰更新主数据存储。
- en: The aggregator service exposes an API that is tailored to specific queries.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合器服务公开了一个专门针对特定查询的API。
- en: It's easier to change the way data is managed behind the scenes without impacting
    consumers.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改数据在幕后的管理方式更容易，而不会影响消费者。
- en: Quick response time.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速响应时间。
- en: 'The cons are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点如下：
- en: It adds complexity to the system.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它给系统增加了复杂性。
- en: It duplicates the data.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它复制了数据。
- en: Partial views require explicit treatment.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分视图需要明确处理。
- en: Employing API composition
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用API组合
- en: The API composition approach is much more lightweight. On the surface, it looks
    just like the CQRS solution. It exposes an API that can answer well-known queries
    across multiple microservices. The difference is that it doesn't keep its own
    data store. Whenever a request comes in, it will access the individual microservices
    that contain the data, compose the results, and return them. This solution shines
    when the system doesn't support event notification for data changes and when the
    load of running queries against the primary data store is acceptable.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: API组合方法更加轻量级。表面上看，它看起来就像CQRS解决方案。它公开了一个API，可以跨多个微服务回答众所周知的查询。不同之处在于它不保留自己的数据存储。每当有请求进来时，它将访问包含数据的各个微服务，组合结果并返回。当系统不支持事件通知数据更改时，以及对主要数据存储运行查询的负载是可以接受的时，这种解决方案就会发光。
- en: 'Here is an illustration of API composition in action, where a query to an API
    composer service is translated under the covers to queries to three microservices:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是API组合在操作中的示例，其中对API组合器服务的查询在幕后被转换为对三个微服务的查询：
- en: '![](assets/65e81c02-8545-4248-97cf-31ecae54831b.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/65e81c02-8545-4248-97cf-31ecae54831b.png)'
- en: 'The pros are as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 优点如下：
- en: Lightweight solution.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量级解决方案。
- en: The aggregator service exposes an API that is tailored to specific queries.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合器服务公开了一个专门针对特定查询的API。
- en: Results are always up to date.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果始终是最新的。
- en: No architectural requirements, such as event notification.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有架构要求，比如事件通知。
- en: 'The cons are as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点如下：
- en: The failure of any service will fail the query. This requires policy decisions
    around retries and timeouts.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何服务的失败都将导致查询失败。这需要关于重试和超时的策略决策。
- en: A high number of queries might impact primary data stores.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量查询可能会影响主要数据存储。
- en: Using sagas to manage transactions across multiple services
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用saga来管理跨多个服务的事务
- en: The API composer and CQRS patterns provide adequate solutions for distributed
    queries when everything works well. However, maintaining distributed data integrity
    is a complex problem. If you store all your data in a single relational database
    and specify proper constraints in your schema, then you can rely on the database
    engine to take care of data integrity. The situation is very different with multiple
    microservices maintaining your data in isolated data stores (relational or non-relational).
    Data integrity is essential, but it must be maintained by your code. The saga
    pattern addresses this concern. Before diving into the saga pattern, let's understand
    data integrity in general.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切正常时，API组合器和CQRS模式为分布式查询提供了足够的解决方案。然而，维护分布式数据完整性是一个复杂的问题。如果您将所有数据存储在单个关系数据库中，并在架构中指定适当的约束条件，那么您可以依赖数据库引擎来处理数据完整性。但是，当多个微服务在隔离的数据存储中维护您的数据时（关系或非关系），情况就大不相同了。数据完整性是必不可少的，但必须由您的代码来维护。saga模式解决了这个问题。在深入了解saga模式之前，让我们先了解一般的数据完整性。
- en: Understanding ACID
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解ACID
- en: 'A common measure of data integrity is that all transactions that modify data
    have the ACID properties:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 数据完整性的一个常见度量是修改数据的所有事务都具有ACID属性：
- en: '**Atomic**: All operations in the transaction succeed or they all fail.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：事务中的所有操作都成功，或者全部失败。'
- en: '**Consistent**: The state of the data complies with all constraints before
    and after the transaction.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：事务之前和之后，数据的状态符合所有约束。'
- en: '**Isolated**: Concurrent transactions behave as if serialized.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：并发事务的行为就像被串行化一样。'
- en: '**Durable**: When a transaction completes successfully, the results are persisted.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：当事务成功完成时，结果被持久化。'
- en: The ACID properties are not specific to relational databases, but often used
    in that context, mostly because the relational schemas, with their formal constraints,
    provide a convenient measure of consistency. The isolation property often has
    serious performance implications and may be relaxed in some systems that prefer
    high-performance and eventual consistency.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ACID属性并不特定于关系数据库，但通常在这个背景下使用，主要是因为关系模式及其形式约束提供了一种方便的一致性度量。隔离性属性通常会对性能产生严重影响，并且在一些更偏向高性能和最终一致性的系统中可能会放宽。
- en: 'The durability property is pretty obvious. There is no point going to all the
    trouble if your data can''t be safely persisted. There are different levels of
    persistence:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 持久性属性是非常明显的。如果你的数据不能安全持久化，那么所有的努力都没有意义。持久性有不同的级别：
- en: '**Persistence to disk**: Can survive restart of the node, but no disk failure'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性到磁盘**：可以在节点重启时存活，但不能在磁盘故障时存活'
- en: '**Redundant memory on multiple nodes**: Can survive restart of a node and disk
    failure, but not temporary failure of all the nodes'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多个节点上的冗余内存**：可以在节点和磁盘故障时存活，但不能在所有节点暂时故障时存活'
- en: '**Redundant disks**: Can survive the failure of a disk'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冗余磁盘**：可以在磁盘故障时存活'
- en: '**Geo-distributed replicas**: Can survive a whole data center being down'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地理分布式副本**：可以在整个数据中心宕机时存活'
- en: '**Backups**: Cheaper to store a lot of information, but slower to restore and
    often lags behind real time'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备份**：存储大量信息更便宜，但恢复速度较慢，通常滞后于实时'
- en: The atomicity requirement is also a no-brainer. Nobody likes partial changes,
    which can violate data integrity and break the system in unpredictable ways that
    are difficult to troubleshoot.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 原子性要求也是显而易见的。没有人喜欢部分更改，这可能会违反数据完整性并以难以排查的方式破坏系统。
- en: Understanding the CAP theorem
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解CAP定理
- en: 'The CAP theorem states that a distributed system can''t have all three properties
    at the same time:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: CAP定理指出，分布式系统不能同时具备以下三个特性：
- en: Consistency
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性
- en: Availability
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性
- en: Partition resiliency
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区弹性
- en: In practice, you get to pick if you want a CP system or AP system. A **CP**
    system (**consistent and partition resilient**) is always consistent and will
    not serve queries or make changes if there is a network partitioning between components.
    It will function only when the system is fully connected. This obviously means
    that you don't have availability. On the other hand, an **AP** system (**available
    and partition resilient**) is always available and can operate in split-brain
    fashion. When the system splits, each part may continue to operate normally, but
    the system will be inconsistent because each part is unaware of transactions happening
    in the other part.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你可以选择CP系统或AP系统。**CP**系统（一致性和分区弹性）始终保持一致，并且在组件之间存在网络分区时不会提供查询或进行更改。它只在系统完全连接时才能运行。这显然意味着你没有可用性。另一方面，**AP**系统（可用性和分区弹性）始终可用，并且可以以分裂脑的方式运行。当系统分裂时，每个部分可能会继续正常运行，但系统将不一致，因为每个部分都不知道另一部分发生的事务。
- en: AP systems are often referred to as eventually consistent systems because, when
    connectivity is restored, some reconciliation process ensures the entire system
    syncs up again. An interesting variant is frozen systems, where, when a network
    partitioning occurs, they degrade gracefully and both parts continue to serve
    queries, but reject all modifications to the system. Note that there is no guarantee
    that, at the moment of partitioning, both parts are consistent because some transactions
    in one part may still not be replicated to the other part. Often, it is good enough
    because the divergence between the split part is small and will not increase over
    time because new changes are rejected.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: AP系统通常被称为最终一致系统，因为当恢复连接时，某些对账过程会确保整个系统再次同步。一个有趣的变体是冻结系统，在网络分区发生时，它们会优雅地退化，并且两个部分都会继续提供查询，但拒绝对系统的所有修改。请注意，在分区的那一刻，没有保证两个部分是一致的，因为一个部分中的一些事务可能仍未复制到另一部分。通常，这已经足够好了，因为分裂部分之间的差异很小，并且不会随着时间的推移而增加，因为新的更改会被拒绝。
- en: Applying the saga pattern to microservices
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将saga模式应用于微服务
- en: 'Relational databases can provide ACID compliance for distributed systems through
    algorithms, such as two-phase commit and control over all the data. The two-phase
    commit algorithm works in two phases: prepare and commit. However, the services
    that participate in the distributed transaction must share the same database.
    That doesn''t work for microservices that manage their own databases.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库可以通过算法（例如两阶段提交和对所有数据的控制）为分布式系统提供ACID合规性。两阶段提交算法分为准备和提交两个阶段。然而，参与分布式事务的服务必须共享相同的数据库。这对于管理自己的数据库的微服务来说是行不通的。
- en: Enter the saga pattern. The basic idea of the saga pattern is that there is
    centralized management of the operations across all the microservices and that,
    for each operation, there is a compensating operation that will be executed if,
    for some reason, the entire transaction can't be completed. This achieves the
    atomicity property of ACID. But, the changes on each microservice are visible
    immediately and not only at the end of the entire distributed transaction. This
    violates the consistency and isolation properties. This is not a problem if you
    design your system as AP, also known as, **eventually consistent**. But, it requires
    your code to be aware of it and be able to work with data that may be partially
    inconsistent or stale. In many cases, this is an acceptable compromise.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 进入saga模式。saga模式的基本思想是对所有微服务的操作进行集中管理，并且对于每个操作，如果由于某种原因整个事务无法完成，将执行一个补偿操作。这实现了ACID的原子性属性。但是，每个微服务上的更改立即可见，而不仅仅在整个分布式事务结束时才可见。这违反了一致性和隔离性属性。如果您将系统设计为AP，也就是**最终一致**，这不是问题。但是，这需要您的代码意识到这一点，并且能够处理可能部分不一致或过时的数据。在许多情况下，这是一个可以接受的妥协。
- en: How does a saga work? A saga is a set of operations and corresponding compensating
    operations on microservices. When an operation fails, its compensating operation
    and the compensating operations of all the previous operations are called in reverse
    order to roll back the entire state of the system.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: saga是如何工作的？saga是一组在微服务上的操作和相应的补偿操作。当一个操作失败时，将按相反的顺序调用其补偿操作以及所有先前操作的补偿操作，以回滚系统的整个状态。
- en: Sagas are not trivial to implement because the compensating operations might
    fail too. In general, the transient state must be persistent and marked as such
    and a lot of metadata must be stored to enable reliable rollback. A good practice
    is to have an out-of-band process run frequently and clean up failed sagas that
    didn't manage to complete all their compensating operations in real time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 实现sagas并不是一件简单的事，因为补偿操作也可能会失败。一般来说，瞬态状态必须是持久的，并标记为这样，必须存储大量的元数据以实现可靠的回滚。一个好的做法是有一个带外进程频繁运行，并清理在实时未能完成所有补偿操作的失败的sagas。
- en: A good way to think about sagas is as workflows. Workflows are cool because
    they enable long processes that even involve humans and not just software.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的理解sagas的方式是将其视为工作流程。工作流程很酷，因为它们可以实现长时间的过程，甚至涉及人类而不仅仅是软件。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered a lot of ground. We discussed the basic principle
    of microservices—less is more—and how breaking down your system to many small
    and self-contained microservices can help it scale. We also discussed the challenges
    that face developers utilizing the microservices architecture. We provided a slew
    of concepts, options, best practices, and pragmatic advice on architecting microservice-based
    systems. At this point, you should appreciate the flexibility that microservices
    offer, but also be a little apprehensive of the many ways you can choose to utilize
    them.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容。我们讨论了微服务的基本原则——少即是多——以及将系统分解为许多小型和自包含的微服务可以帮助其扩展。我们还讨论了开发人员在利用微服务架构时面临的挑战。我们提供了大量关于构建基于微服务的系统的概念、选项、最佳实践和务实建议。在这一点上，你应该欣赏到微服务提供的灵活性，但也应该对你可以选择利用它们的许多方式有些担忧。
- en: In the rest of the book, we will explore the terrain in detail and together
    build a microservice-based system using some of the best available frameworks
    and tools and deploy it on Kubernetes. In the next chapter, you'll meet Delinkcious—our
    sample application—that will serve as a hands-on laboratory. You will also get
    a glimpse into Go-kit, a microservice-based framework for constructing Go microservices.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将详细探讨这个领域，并一起使用一些最好的可用框架和工具构建一个基于微服务的系统，并将其部署在Kubernetes上。在下一章中，你将会遇到Delinkcious——我们的示例应用程序——它将作为一个动手实验室。你还将一窥Go-kit，这是一个用于构建Go微服务的微服务框架。
- en: Further reading
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: If you are interested in microservices, I recommend the following article as
    a starting point: [https://www.martinfowler.com/](https://www.martinfowler.com/)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对微服务感兴趣，我建议从以下文章开始阅读：[https://www.martinfowler.com/](https://www.martinfowler.com/)
