["```\n$ kubectl create namespace nuclio\n```", "```\n$ kubectl apply -f https://raw.githubusercontent.com/nuclio/nuclio/master/hack/k8s/resources/nuclio-rbac.yaml\n```", "```\n$ kubectl apply -f https://raw.githubusercontent.com/nuclio/nuclio/master/hack/k8s/resources/nuclio.yaml\n```", "```\n$ kubectl get pods --namespace nuclio\n NAME                               READY     STATUS    RESTARTS   AGE\n nuclio-controller-556774b65-mtvmm   1/1       Running   0          22m\n nuclio-dashboard-67ff7bb6d4-czvxp   1/1       Running   0          22m\n```", "```\n$ cd /usr/local/bin\n$ curl -LO https://github.com/nuclio/nuclio/releases/download/1.1.2/nuctl-1.1.2-darwin-amd64\n$ ln -s nuctl-1.1.2-darwin-amd64 nuctl\n```", "```\n$ kubectl create secret docker-registry registry-credentials -n nuclio \\\n --docker-username g1g1 \\\n --docker-password $DOCKERHUB_PASSWORD \\\n --docker-server registry.hub.docker.com \\\n --docker-email the.gigi@gmail.com\n\nsecret \"registry-credentials\" created\n```", "```\nconst (\n     LinkStatusPending = \"pending\"\n     LinkStatusValid   = \"valid\"\n     LinkStatusInvalid = \"invalid\"\n )\n\n type LinkStatus = string\n\n type Link struct {\n     Url         string\n     Title       string\n     Description string\n     Status      LinkStatus\n     Tags        map[string]bool\n     CreatedAt   time.Time\n     UpdatedAt   time.Time\n }\n```", "```\ntype CheckLinkRequest struct {\n     Username string\n     Url      string\n }\n```", "```\ntype LinkCheckerEvents interface {\n     OnLinkChecked(username string, url string, status LinkStatus)\n }\n```", "```\npackage link_checker\n\n import (\n     \"errors\"\n     \"net/http\"\n )\n\n // CheckLinks tries to get the headers of the target url and returns error if it fails\n func CheckLink(url string) (err error) {\n     resp, err := http.Head(url)\n     if err != nil {\n         return\n     }\n     if resp.StatusCode >= 400 {\n         err = errors.New(resp.Status)\n     }\n     return\n }\n```", "```\npackage link_checker_events\n\n import (\n     om \"github.com/the-gigi/delinkcious/pkg/object_model\"\n )\n\n type Event struct {\n     Username string\n     Url      string\n     Status   om.LinkStatus\n }\n```", "```\npackage link_checker_events\n\n import (\n     \"github.com/nats-io/go-nats\"\n     om \"github.com/the-gigi/delinkcious/pkg/object_model\"\n     \"log\"\n )\n\n type eventSender struct {\n     hostname string\n     nats     *nats.EncodedConn\n }\n\n func (s *eventSender) OnLinkChecked(username string, url string, status om.LinkStatus) {\n     err := s.nats.Publish(subject, Event{username, url, status})\n     if err != nil {\n         log.Fatal(err)\n     }\n }\n\n func NewEventSender(url string) (om.LinkCheckerEvents, error) {\n     ec, err := connect(url)\n     if err != nil {\n         return nil, err\n     }\n     return &eventSender{hostname: url, nats: ec}, nil\n }\n```", "```\npackage link_manager_events\n\n import (\n     om \"github.com/the-gigi/delinkcious/pkg/object_model\"\n )\n\n func Listen(url string, sink om.LinkManagerEvents) (err error) {\n     conn, err := connect(url)\n     if err != nil {\n         return\n     }\n\n     conn.QueueSubscribe(subject, queue, func(e *Event) {\n         switch e.EventType {\n         case om.LinkAdded:\n             {\n                 sink.OnLinkAdded(e.Username, e.Link)\n             }\n         case om.LinkUpdated:\n             {\n                 sink.OnLinkUpdated(e.Username, e.Link)\n             }\n         default:\n             // Ignore other event types\n         }\n     })\n\n     return\n }\n```", "```\n$ tree fun\n fun\n \u2514\u2500\u2500 link_checker\n \u251c\u2500\u2500 function.yaml\n \u2514\u2500\u2500 link_checker.go\n```", "```\npackage main\n\n import (\n     \"encoding/json\"\n     \"errors\"\n     \"fmt\"\n     \"github.com/nuclio/nuclio-sdk-go\"\n     \"github.com/the-gigi/delinkcious/pkg/link_checker\"\n     \"github.com/the-gigi/delinkcious/pkg/link_checker_events\"\n     om \"github.com/the-gigi/delinkcious/pkg/object_model\"\n )\n\n const natsUrl = \"nats-cluster.default.svc.cluster.local:4222\"\n```", "```\nfunc Handler(context *nuclio.Context, event nuclio.Event) (interface{}, error) { r := nuclio.Response{ StatusCode: 200, ContentType: \"application/text\", }\n\nbody := event.GetBody()\n var e om.CheckLinkRequest\n err := json.Unmarshal(body, &e)\n if err != nil {\n     msg := fmt.Sprintf(\"failed to unmarshal body: %v\", body)\n     context.Logger.Error(msg)\n\n     r.StatusCode = 400\n     r.Body = []byte(fmt.Sprintf(msg))\n     return r, errors.New(msg)\n\n }\n```", "```\nusername := e.Username\n url := e.Url\n if username == \"\" || url == \"\" {\n     msg := fmt.Sprintf(\"missing USERNAME ('%s') and/or URL ('%s')\", username, url)\n     context.Logger.Error(msg)\n\n     r.StatusCode = 400\n     r.Body = []byte(msg)\n     return r, errors.New(msg)\n }\n```", "```\nstatus := om.LinkStatusValid\nerr = link_checker.CheckLink(url)\nif err != nil {\nstatus = om.LinkStatusInvalid\n     }\n```", "```\n    sender, err := link_checker_events.NewEventSender(natsUrl)\n     if err != nil {\n         context.Logger.Error(err.Error())\n\n         r.StatusCode = 500\n         r.Body = []byte(err.Error())\n         return r, err\n     }\n\n     sender.OnLinkChecked(username, url, status)\n     return r, nil\n```", "```\napiVersion: \"nuclio.io/v1beta1\"\n kind: \"NuclioFunction\"\n spec:\n   description: >\n     A function that connects to NATS, checks incoming links and publishes LinkValid or LinkInvalid events.\n   runtime: \"golang\"\n   handler: main:Handler\n   minReplicas: 1\n   maxReplicas: 1\n   build:\n     commands:\n     - apk --update --no-cache add ca-certificates\n```", "```\n$ docker login\nLogin with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.\n Username: g1g1\n Password:\n Login Succeeded\n```", "```\n$ cd fun/link_checker\n$ nuctl deploy link-checker -n nuclio -p . --registry g1g1\n\n nuctl (I) Deploying function {\"name\": \"link-checker\"}\n nuctl (I) Building {\"name\": \"link-checker\"}\n nuctl (I) Staging files and preparing base images\n nuctl (I) Pulling image {\"imageName\": \"quay.io/nuclio/handler-builder-golang-onbuild:1.1.2-amd64-alpine\"}\n nuctl (I) Building processor image {\"imageName\": \"processor-link-checker:latest\"}\n nuctl (I) Pushing image {\"from\": \"processor-link-checker:latest\", \"to\": \"g1g1/processor-link-checker:latest\"}\n nuctl (I) Build complete {\"result\": {\"Image\":\"processor-link-checker:latest\"...}}\n nuctl (I) Function deploy complete {\"httpPort\": 31475}\n```", "```\n$ kubectl get nucliofunctions -n nuclio\n NAME           AGE\n link-checker   42m\n```", "```\n$ nuctl get function -n nuclio -o yaml\n metadata:\n name: link-checker\n namespace: nuclio\n spec:\n alias: latest\n build:\n path: .\n registry: g1g1\n timestamp: 1554442452\n description: |\nA function with a configuration that connects to NATS, listens to LinkAdded events, check the links and send LinkValid or LinkInvalid events.\n handler: main:Handler\n image: g1g1/processor-link-checker:latest\n imageHash: \"1554442427312071335\"\n maxReplicas: 1\n minReplicas: 1\n platform: {}\n readinessTimeoutSeconds: 30\n replicas: 1\n resources: {}\n runRegistry: g1g1\n runtime: golang\n serviceType: NodePort\n targetCPU: 75\n version: -1\n```", "```\n$ kubectl port-forward -n nuclio $(kubectl get pods -n nuclio -l nuclio.io/app=dashboard -o jsonpath='{.items[0].metadata.name}') 8070\n```", "```\nnuctl invoke link-checker -n nuclio --external-ips $(mk ip)\n```", "```\nfunc (m *LinkManager) AddLink(request om.AddLinkRequest) (err error) {\n     ...\n\n     // Trigger link check asynchronously (don't wait for result)\n     triggerLinkCheck(request.Username, request.Url)\n     return\n }\n```", "```\n// Nuclio functions listen by default on port 8080 of their service IP\n const link_checker_func_url = \"http://link-checker.nuclio.svc.cluster.local:8080\"\n\nfunc triggerLinkCheck(username string, url string) {\n     go func() {\n         checkLinkRequest := &om.CheckLinkRequest{Username: username, Url: url}\n         data, err := json.Marshal(checkLinkRequest)\n         if err != nil {\n             return\n         }\n\n         req, err := http.NewRequest(\"POST\", link_checker_func_url, bytes.NewBuffer(data))\n         req.Header.Set(\"Content-Type\", \"application/json\")\n         client := &http.Client{}\n         resp, err := client.Do(req)\n         if err != nil {\n             return\n         }\n         defer resp.Body.Close()\n     }()\n }\n```", "```\napiVersion: batch/v1\nkind: Job\nmetadata:\n  name: yeah-it-works\nspec:\n  template:\n    spec:\n      containers:\n      - name: yeah-it-works\n        image: python:3.6-alpine\n        command: [\"python\",  \"-c\", \"print('Yeah, it works in a Job!!!')\"]\n      restartPolicy: Never\n```", "```\n$ kubectl create -f job.yaml\n job.batch/yeah-it-works created\n\n $ kubectl get po | grep yeah-it-works\n yeah-it-works-flzl5            0/1     Completed   0          116s\n\n $ kubectl logs yeah-it-works-flzl5\n Yeah, it works in a Job!!!\n```"]