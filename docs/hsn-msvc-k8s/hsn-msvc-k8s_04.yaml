- en: Setting Up the CI/CD Pipeline
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置CI/CD流水线
- en: In a microservice-based system, there are many moving parts. Kubernetes is a
    rich platform that provides a lot of building blocks for your system. Managing
    and deploying all of these components reliably and predictably requires a high
    level of organization and automation. Enter the CI/CD pipeline.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于微服务的系统中，有许多组成部分。Kubernetes是一个提供了许多构建块的丰富平台。可靠和可预测地管理和部署所有这些组件需要高度的组织和自动化。这就是CI/CD流水线的作用。
- en: In this chapter, we will understand the problem the CI/CD pipeline solves, cover
    the different options for CI/CD pipelines for Kubernetes, and finally build a
    CI/CD pipeline for Delinkcious.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解CI/CD流水线解决的问题，介绍Kubernetes的CI/CD流水线的不同选项，并最终构建Delinkcious的CI/CD流水线。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Understanding a CI/CD pipeline
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解CI/CD流水线
- en: Options for Kubernetes CI/CD pipelines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes CI/CD流水线的选项
- en: GitOps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitOps
- en: Automated CI/CD
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化的CI/CD
- en: Building your images with CircleCI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CircleCI构建您的镜像
- en: Setting up continuous delivery for Delinkcious
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Delinkcious设置持续交付
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, you will work with CircleCI and Argo CD. I will show you how
    to install Argo CD in the Kubernetes cluster later. To set up CircleCI, for free,
    follow *Getti**ng started* instructions on their website at [https://circleci.com/docs/2.0/getting-started/](https://circleci.com/docs/2.0/getting-started/).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将使用CircleCI和Argo CD。我将向您展示如何稍后在Kubernetes集群中安装Argo CD。要免费设置CircleCI，请按照它们网站上的*入门*说明[https://circleci.com/docs/2.0/getting-started/](https://circleci.com/docs/2.0/getting-started/)。
- en: The code
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码
- en: The Delinkcious release for this chapter can be found at [https://github.com/the-gigi/delinkcious/releases/tag/v0.2](https://github.com/the-gigi/delinkcious/releases/tag/v0.2).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的Delinkcious版本可以在[https://github.com/the-gigi/delinkcious/releases/tag/v0.2](https://github.com/the-gigi/delinkcious/releases/tag/v0.2)找到。
- en: We will be working on the main Delinkcious code base, so there are no code snippets
    or examples.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在主要的Delinkcious代码库上工作，因此没有代码片段或示例。
- en: Understanding a CI/CD pipeline
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解CI/CD流水线
- en: The development life cycle of software systems goes from code, through testing,
    generating artifacts, even more testing, and eventually, deployment to production.
    The basic idea is that whenever a developer commits changes to their source control
    system (for example, GitHub), these changes are detected by the **continuous integration**
    (**CI**) system, which immediately runs the tests.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 软件系统的开发生命周期从代码开始，经过测试，生成构件，更多测试，最终部署到生产环境。基本思想是，每当开发人员向其源代码控制系统（例如GitHub）提交更改时，这些更改都会被**持续集成**（**CI**）系统检测到，并立即运行测试。
- en: This is often followed by a review by peers and merging the code changes (or
    a pull request) from a feature branch or development branch into the master. In
    the context of Kubernetes, the CI system is also responsible for building the
    Docker images for the services and pushing them to the image registry. At this
    point, we have Docker images that contain new code. This is where the CD system
    comes in.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常会由同行进行审查，并将代码更改（或拉取请求）从特性分支或开发分支合并到主分支。在Kubernetes的上下文中，CI系统还负责构建服务的Docker镜像并将其推送到镜像注册表。在这一点上，我们有包含新代码的Docker镜像。这就是CD系统的作用。
- en: When a new image becomes available, the **continuous delivery** (**CD**) system
    will deploy it to the target environment(s). CD is the process of ensuring that
    the overall system is in a desired state, which is done though provisioning and
    deployments. Sometimes, deployment can occur as a result of configuration change
    if the system doesn't support dynamic configuration. We will discuss configuration
    in great detail in [Chapter 5](0d340a5c-b2da-41ab-a50d-56bd985c10f2.xhtml), *Configuring
    Microservices with Kubernetes*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当新镜像可用时，**持续交付**（**CD**）系统将其部署到目标环境。CD是确保整个系统处于期望状态的过程，通过配置和部署来实现。有时，如果系统不支持动态配置，部署可能会因配置更改而发生。我们将在[第5章](0d340a5c-b2da-41ab-a50d-56bd985c10f2.xhtml)中详细讨论配置，*使用Kubernetes配置微服务*。
- en: So, a CI/CD pipeline is a set of tools that detect code changes and can take
    them all the way to production according to the processes and policies of the
    organization. It is typically the responsibility of DevOps engineers to build
    and maintain this pipeline, and it is used heavily by developers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，CI/CD流水线是一组工具，可以检测代码更改，并根据组织的流程和政策将其推送到生产环境。通常由DevOps工程师负责构建和维护此流水线，并且开发人员大量使用。
- en: Every organization and company (or even different groups within the same company)
    will have a specific process. In one of my first jobs, my first task was to replace
    a Perl-based build system (that's what CI/CD pipelines were called back then)
    with lots of recursive makefiles that nobody understood any more. That build system
    had to run code generation steps on Windows using some modeling software, compile
    and run C++ unit tests on two flavors of Unix (including an embedded flavor) using
    two different toolchains, and trigger open CVS. I chose Python and had to create
    everything from scratch.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组织和公司（甚至同一公司内的不同团队）都会有一个特定的流程。在我第一份工作中，我的第一个任务是用许多人都不再理解的递归makefile替换基于Perl的构建系统（那时候CI/CD流水线被称为这样）。该构建系统必须在Windows上运行代码生成步骤，使用一些建模软件，在两种不同的Unix平台上（包括嵌入式平台）使用两种不同的工具链编译和运行C++单元测试，并触发open
    CVS。我选择了Python，并不得不从头开始创建一切。
- en: It was fun, but very specific to this company. It's common to think of CI/CD
    pipelines as a workflow of steps driven by events.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣，但非常特定于这家公司。通常认为CI/CD流水线是由事件驱动的一系列步骤的工作流程。
- en: 'The following diagram demonstrates a simple CI/CD pipeline:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了一个简单的CI/CD流水线：
- en: '![](assets/6c83021d-cee3-4999-9aca-fcaee423eabf.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6c83021d-cee3-4999-9aca-fcaee423eabf.png)'
- en: 'The stages in this pipeline function as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此流水线中的各个阶段的功能如下：
- en: The developer commits their changes to GitHub (source control)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发人员将他们的更改提交到GitHub（源代码控制）
- en: The CI server runs the tests, builds a Docker image, and pushes the image to
    DockerHub (image registry)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI服务器运行测试，构建Docker镜像，并将镜像推送到DockerHub（镜像注册表）
- en: The Argo CD server detects that there is a new image available and deploys to
    the Kubernetes cluster
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Argo CD服务器检测到有新镜像可用，并部署到Kubernetes集群
- en: Now that we have understood the CI/CD pipeline, let's examine a specific CI/CD
    pipeline choice.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了CI/CD流水线，让我们来看一下特定的CI/CD流水线选择。
- en: Options for the Delinkcious CI/CD pipeline
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Delinkcious CI/CD流水线的选项
- en: 'Choosing a CI/CD pipeline for your system is a major decision. When I faced
    this decision for Delinkcious, I looked into several alternatives. There isn''t
    an obvious choice here. Kubernetes is moving fast and the tooling and processes
    struggle to catch up. I evaluated a few choices and settled on CircleCI for continuous
    integration and Argo CD for continuous delivery. I initially considered a one-stop
    shop for the entire CI/CD pipeline and, after reviewing some options, I decided
    that I preferred to consider them as two separate entities and chose a different
    solution for CI and CD. Let''s briefly review some of these options (there are
    many, many more):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的系统选择CI/CD流水线是一个重大决定。当我为Delinkcious面临这个决定时，我调查了几种替代方案。这里没有明显的选择。Kubernetes发展迅速，工具和流程难以跟上。我评估了几种选择，并选择了CircleCI进行持续集成和Argo
    CD进行持续交付。我最初考虑了一个整个CI/CD流水线的一站式解决方案，但在审查了一些选项后，我决定更喜欢将它们视为两个单独的实体，并为CI和CD选择了不同的解决方案。让我们简要回顾一些这些选项（还有很多很多）：
- en: Jenkins X
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins X
- en: Spinnaker
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spinnaker
- en: Travis CI and CircleCI
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Travis CI和CircleCI
- en: Tekton
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tekton
- en: Argo CD
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argo CD
- en: Rolling your own
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自己动手
- en: Jenkins X
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins X
- en: 'Jenkins X was my first choice and favorite. I read some articles and watched
    some presentations that made me want to like it. It provides all the features
    you want, including some advanced capabilities:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X是我的首选和最喜欢的。我读了一些文章，看了一些演示，让我想要喜欢它。它提供了您想要的所有功能，包括一些高级功能：
- en: Automated CI/CD
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化的CI/CD
- en: Environment promotion via GitOps
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过GitOps进行环境推广
- en: Pull request preview environments
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取请求预览环境
- en: Automatic feedback on your commit and pull requests
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对您的提交和拉取请求的自动反馈
- en: Under the cover, it utilizes Jenkins, which is a mature, albeit complex, product.
    The premise of Jenkins X is that it will mask the complexity of Jenkins and provide
    a Kubernetes-specific streamlined workflow.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，它利用了成熟但复杂的Jenkins产品。Jenkins X的前提是它将掩盖Jenkins的复杂性，并提供一个特定于Kubernetes的简化工作流程。
- en: 'I was disappointed by a couple of issues when I tried to actually use Jenkins
    X:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我尝试实际使用Jenkins X时，我对一些问题感到失望：
- en: It doesn't work out of the box and troubleshooting is complicated.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能直接使用，故障排除很复杂。
- en: It is very opinionated.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它非常主观。
- en: It doesn't support the monorepo approach well (or at all).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不很好地支持单一代码库方法（或根本不支持）。
- en: I tried to make it work for a while, but after reading about other people's
    experiences and seeing the lack of response in the Jenkins X slack community channels,
    I was turned off Jenkins X. I still like the idea, but it really has to be super
    stable before I try it again.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我试图让它工作一段时间，但在阅读了其他人的经验并看到Jenkins X的slack社区频道缺乏响应后，我对Jenkins X失去了兴趣。我仍然喜欢这个想法，但在我再次尝试之前，它真的必须非常稳定。
- en: Spinnaker
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spinnaker
- en: 'Spinnaker is an open source CI/CD solution from Netflix. It has many benefits,
    including the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Spinnaker是Netflix的开源CI/CD解决方案。它有很多好处，包括以下：
- en: It has been adopted by many companies.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它已被许多公司采用。
- en: It has a lot of integration with other products.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与其他产品有很多集成。
- en: It supports a lot of best practices.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持很多最佳实践。
- en: 'The downsides of Spinnaker are as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Spinnaker的缺点如下：
- en: It is a large and complicated system.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个庞大而复杂的系统。
- en: It has a steep learning curve.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个陡峭的学习曲线。
- en: It is not Kubernetes-specific.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不是特定于Kubernetes的。
- en: In the end, I decided to skip on Spinnaker – not because of any fault of Spinnaker
    itself, but because I don't have experience with it. I didn't want to learn such
    a large product from scratch while developing Delinkcious itself and writing this
    book. You may very well find that Spinnaker is the right CI/CD solution for you.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我决定放弃Spinnaker——不是因为Spinnaker本身有任何问题，而是因为我对它没有经验。在开发Delinkcious本身和写这本书的过程中，我不想从头开始学习这样一个庞大的产品。你可能会发现Spinnaker对你来说是正确的CI/CD解决方案。
- en: Travis CI and CircleCI
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Travis CI和CircleCI
- en: I prefer to separate the CI solution from the CD solution. Conceptually, the
    role of the CI process is to generate a container image and push it to a registry.
    It doesn't need to be aware of Kubernetes at all. The CD solution, on the other
    hand, must be Kubernetes-aware, and it ideally runs inside the cluster.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢将CI解决方案与CD解决方案分开。在概念上，CI流程的作用是生成一个容器镜像并将其推送到注册表。它根本不需要了解Kubernetes。另一方面，CD解决方案必须对Kubernetes有所了解，并且理想情况下在集群内运行。
- en: For CI, I considered Travis CI and CircleCI. Both provide free CI services for
    open source projects. I settled on CircleCI because it is more feature-complete
    and has a nicer UI, which is important. I'm sure Travis CI would work well too.
    I use Travis CI in some of my other open source projects. It's important to note
    that the CI part of the pipeline is completely Kubernetes-agnostic. The end result
    is a Docker image in an image registry. This Docker image can be used for other
    purposes and not necessarily deployed in a Kubernetes cluster.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CI，我考虑了Travis CI和CircleCI。两者都为开源项目提供免费的CI服务。我选择了CircleCI，因为它更具备功能完备，并且具有更好的用户界面，这很重要。我相信Travis
    CI也会很好用。我在其他一些开源项目中使用Travis CI。重要的是要注意，流水线的CI部分完全与Kubernetes无关。最终结果是镜像仓库中的Docker镜像。这个Docker镜像可以用于其他目的，而不一定要部署在Kubernetes集群中。
- en: Tekton
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tekton
- en: 'Tekton is a very interesting project. It is Kubernetes-native and has great
    abstractions of steps, tasks, runs, and pipelines. It is relatively young, but
    seems very promising. It was also selected as one of the inaugural projects of
    the CD Foundation: [https://cd.foundation/projects/](https://cd.foundation/projects/).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton是一个非常有趣的项目。它是Kubernetes原生的，具有很好的步骤、任务、运行和流水线的抽象。它相对年轻，但似乎非常有前途。它还被选为CD基金会的首批项目之一：[https://cd.foundation/projects/](https://cd.foundation/projects/)。
- en: It will be interesting to see how it evolves.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 看它如何发展将会很有趣。
- en: 'The advantages of Tekton are as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton的优点如下：
- en: Modern design and clean conceptual model
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代设计和清晰的概念模型
- en: Supported by the CD foundation
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 得到CD基金会的支持。
- en: Built on top of prow (the CI/CD solution of Kubernetes itself)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立在prow之上（Kubernetes自身的CI/CD解决方案）
- en: Kubernetes-native solution
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes原生解决方案
- en: 'The disadvantages of Tekton are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton的缺点如下：
- en: It's still fairly new and unstable.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它仍然相当新和不稳定。
- en: It doesn't have all the features and capabilities of other solutions.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有其他解决方案的所有功能和能力。
- en: Argo CD
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Argo CD
- en: 'The CD solution, as opposed to the CI solution, is very specific to Kubernetes.
    I picked Argo CD for several reasons:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与CI解决方案相反，CD解决方案非常特定于Kubernetes。我选择Argo CD有几个原因：
- en: Kubernetes-aware
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Kubernetes有认识
- en: Implemented on top of a general-purpose workflow engine (Argo)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立在通用工作流引擎（Argo）之上
- en: Great UI
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出色的用户界面
- en: Runs on your Kubernetes cluster
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的Kubernetes集群上运行
- en: Implemented in Go (not that important, but I like it)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Go实现（并不是很重要，但我喜欢它）
- en: 'Argo CD has a number of disadvantages, too:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD也有一些缺点：
- en: It isn't a member of the CD foundation or the CNCF (less recognition in the
    community).
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不是CD基金会或CNCF的成员（在社区中认可度较低）。
- en: Intuit, the primary company behind it, is not a major cloud-native powerhouse.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Intuit是其背后的主要公司，不是一个主要的云原生强大力量。
- en: Argo CD is a young project that comes from Intuit, who acquired the original
    developers of the Argo project – Applatix. I really like its architecture and,
    when I tried it, everything worked like a charm.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD是一个来自Intuit的年轻项目，他们收购了Argo项目的原始开发人员- Applatix。我真的很喜欢它的架构，当我尝试过它时，一切都像魔术一样运行。
- en: Rolling your own
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自己动手
- en: I briefly considered creating my own simple CI/CD pipeline. The operations are
    not complicated. For the purpose of this book, I didn't need a very reliable solution,
    and it would have been easy to explain exactly what happens at each step. However,
    with the reader in mind, I decided that it was best to use existing tools that
    can be utilized directly and also save me time developing a poor CI/CD solution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾简要考虑过创建自己的简单CI/CD流水线。操作并不复杂。对于本书的目的，我并不需要一个非常可靠的解决方案，而且很容易解释每个步骤发生了什么。然而，考虑到读者，我决定最好使用现有的工具，这些工具可以直接利用，并且还可以节省我开发一个糟糕的CI/CD解决方案的时间。
- en: At this point, you should have a good idea of the different options for CI/CD
    solutions on Kubernetes. We reviewed most of the popular solutions and chose CircleCI
    and Argo CD as the best fit for the Delinkcious CI/CD solution. Next, we'll discuss
    the hot new trend of GitOps.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该对Kubernetes上的CI/CD解决方案有了一个很好的了解。我们审查了大多数流行的解决方案，并选择了CircleCI和Argo CD作为Delinkcious
    CI/CD解决方案的最佳选择。接下来，我们将讨论GitOps的热门新趋势。
- en: GitOps
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitOps
- en: GitOps is a new buzzword, although the concept is not very new. It is another
    variant of *Infrastructure as Code*. The basic idea is that your code, configuration,
    and the resources it requires should all be described and stored in a source control
    repository where they are version controlled. Whenever you push a change to the
    repository, your CI/CD solution will respond and take the correct action. Even
    rollbacks can be initiated just by reverting to a previous version in your repository.
    The repository doesn't have to be Git, of course, but GitOps sounds way better
    than Source Control Ops, and most people use Git anyway, so here we are.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps是一个新的时髦词汇，尽管概念并不是很新。这是*基础设施即代码*的另一种变体。基本思想是您的代码、配置和所需的资源都应该在一个源代码控制存储库中进行描述和存储，并进行版本控制。每当您向存储库推送更改时，您的CI/CD解决方案将做出响应并采取正确的操作。甚至可以通过在存储库中恢复到先前版本来启动回滚。当然，存储库不一定是Git，但GitOps听起来比源代码控制运营好得多，大多数人都使用Git，所以我们就在这里了。
- en: Both CircleCI and Argo CD fully support and advocate the GitOps model. When
    your `git push` code changes, CircleCI will trigger on it and start building the
    correct images. When you `git push` changes to the Kubernetes manifests, Argo
    CD will trigger and deploy those changes to your Kubernetes cluster.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI和Argo CD都完全支持并倡导GitOps模型。当您`git push`代码更改时，CircleCI将触发并开始构建正确的镜像。当您`git
    push`更改到Kubernetes清单时，Argo CD将触发并将这些更改部署到您的Kubernetes集群。
- en: Now that we're clear on what GitOps is, we can start implementing the continuous
    integration part of the pipeline for Delinkcious. We will use CircleCI to build
    Docker images from source code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们清楚了GitOps是什么，我们可以开始为Delinkcious实施流水线的持续集成部分。我们将使用CircleCI从源代码构建Docker镜像。
- en: Building your images with CircleCI
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CircleCI构建您的镜像
- en: 'Let''s dive in and look at the Delinkcious CI pipeline. We will go over each
    step in the continuous integration process, which includes the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入研究Delinkcious CI流水线。我们将逐步介绍持续集成过程中的每个步骤，其中包括以下内容：
- en: Reviewing the source tree
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查源代码树
- en: Configuring the CI pipeline
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置CI流水线
- en: Understanding the build script
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解构建脚本
- en: Dockerizing a Go service with a multi-stage Dockerfile
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多阶段Dockerfile对Go服务进行Docker化
- en: Exploring the CircleCI user interface
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索CircleCI用户界面
- en: Reviewing the source tree
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查源代码树
- en: 'Continuous integration is about building and testing stuff. The first step
    is to understand what needs to be built and tested in Delinkcious. Let''s have
    another look at the Delinkcious source tree:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成是关于构建和测试的东西。第一步是了解Delinkcious中需要构建和测试的内容。让我们再看一下Delinkcious源代码树：
- en: '[PRE0]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `pkg` directory contains packages that are used by services and commands.
    We should run the unit tests of these packages. The `svc` directory contains our
    microservices. We should build those services, package each one in a properly
    versioned Docker image, and push those images to DockerHub (the image registry).
    The `cmd` directory currently contains end-to-end tests. Those are designed to
    run locally and don't need to be built by the CI pipeline (this can be changed
    if you want to add end-to-end tests to our testing processes).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg`目录包含服务和命令使用的包。我们应该运行这些包的单元测试。`svc`目录包含我们的微服务。我们应该构建这些服务，将每个服务打包到适当版本的Docker镜像中，并将这些镜像推送到DockerHub（镜像注册表）。`cmd`目录目前包含端到端测试。这些测试旨在在本地运行，不需要由CI管道构建（如果您想将端到端测试添加到我们的测试流程中，可以更改这一点）。'
- en: Configuring the CI pipeline
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置CI管道
- en: 'CircleCI is configured by a single YAML file with a standard name and location,
    that is, `<root directory>/.circleci/config.yaml`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI由一个标准名称和位置的单个YAML文件进行配置，即`<根目录>/.circleci/config.yaml`：
- en: '[PRE1]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s break it apart and understand what''s going on. The first part specifies
    the build job, and below that are the necessary Docker images `(golang` and `postgres`)
    and their environment. Then, we have the working directory, where the `build`
    commands should be executed:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分开来理解发生了什么。第一部分指定了构建作业，下面是必要的Docker镜像（`golang`和`postgres`）及其环境。然后，我们有工作目录，`build`命令应该在其中执行：
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next part is the build steps. The first step is just checkout. In the CircleCI
    UI, I associated the project with the Delinkcious GitHub repository so that it
    knows where to checkout from. If the repository is not public, then you''ll need
    to provide an access token, too. The second step is a `run` command that gets
    all the Go dependencies of Delinkcious:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分是构建步骤。第一步只是检出。在CircleCI UI中，我将项目与Delinkcious GitHub存储库关联起来，以便它知道从哪里检出。如果存储库不是公共的，那么您还需要提供访问令牌。第二步是一个`run`命令，用于获取Delinkcious的所有Go依赖项：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I had to explicitly `go get` the `ginkgo` framework and the `gomega` library
    because they are imported using Golang dot notation, which makes them invisible
    to `go get ./...`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须显式地`go get` `ginkgo`框架和`gomega`库，因为它们是使用Golang点符号导入的，这使它们对`go get ./...`不可见。
- en: 'Once we have all the dependencies, we can run the tests. I am using the `ginkgo`
    test framework in this case:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了所有的依赖，我们就可以运行测试。在这种情况下，我正在使用`ginkgo`测试框架：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next section is where it builds and pushes the Docker images. Since it
    requires access to the Docker daemon, it needs special setup via the `setup_remote_docker`
    step. The `docker_layer_caching` option is used to make everything more efficient
    and faster by reusing previous layers. The actual build out and push is handled
    by the `build.sh` script, which we will look at in the next section. Note that
    I made sure it''s executable via `chmod +x`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分是构建和推送Docker镜像的地方。由于它需要访问Docker守护程序，因此需要通过`setup_remote_docker`步骤进行特殊设置。`docker_layer_caching`选项用于通过重用先前的层使一切更高效和更快。实际的构建和推送由`build.sh`脚本处理，我们将在下一部分进行查看。请注意，我确保通过`chmod
    +x`是可执行的：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I'm just scratching the surface here. There is much more to CircleCI, with orbs
    for reusable configuration, workflows, triggers, and artifacts.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里只是浅尝辄止。CircleCI还有更多功能，包括用于可重用配置、工作流、触发器和构件的orbs。
- en: Understanding the build.sh script
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解build.sh脚本
- en: The `build.sh` script is available at [https://github.com/the-gigi/delinkcious/blob/master/build.sh](https://github.com/the-gigi/delinkcious/blob/master/build.sh).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`build.sh`脚本可在[https://github.com/the-gigi/delinkcious/blob/master/build.sh](https://github.com/the-gigi/delinkcious/blob/master/build.sh)找到。'
- en: Let's examine it bit by bit. There are several best practices we will follow
    here. First, it's a good idea to add a shebang with the path of the binary that
    will execute your script – that is, if you know where it is located. If you try
    to write a cross-platform script that works on many different platforms, you may
    need to rely on the path or other techniques. `set -eo pipefail` will fail out
    immediately (even in the middle of a pipe) if anything goes wrong.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步检查它。我们将在这里遵循几个最佳实践。首先，最好在脚本中添加一个shebang，其中包含将执行您的脚本的二进制文件的路径 - 也就是说，如果您知道它的位置。如果您尝试编写一个可以在许多不同平台上运行的跨平台脚本，您可能需要依赖路径或其他技术。`set
    -eo pipefail`将在任何出现问题时立即失败（即使在管道的中间）。
- en: 'This is highly recommended for production environments:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这在生产环境中是强烈推荐的：
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next few lines just set some variables for directories and the tags for
    the Docker images. There are two tags: `STABLE_TAB` and `TAG`. The `STABLE_TAG`
    tag has a major and minor version and doesn''t change in every build. The `TAG`
    includes the `CIRCLE_BUILD_NUM` provided by CircleCI and is incremented in every
    build. This means that the `TAG` is always unique. This is considered a best practice
    for tagging and versioning images:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行只是为目录和Docker镜像的标记设置了一些变量。有两个标记：`STABLE_TAB`和`TAG`。`STABLE_TAG`标记具有主要版本和次要版本，并且在每次构建中不会更改。`TAG`包括CircleCI提供的`CIRCLE_BUILD_NUM`，并且在每次构建中递增。这意味着`TAG`始终是唯一的。这被认为是标记和版本化镜像的最佳实践：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, we go to the `svc` directory, which is the parent directory of all our
    services, and log in to DockerHub using the environment variables we set in the
    CircleCI project.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进入`svc`目录，这是所有服务的父目录，并使用在CircleCI项目中设置的环境变量登录到DockerHub。
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we get to the main event. The script iterates over all the subdirectories
    of the `svc` directory looking for `Dockerfile`. If it finds a `Dockerfile`, it
    builds an image, tags it using a combination of service name and both `TAG` and
    `STABLE_TAG`, and finally pushes the tagged images to the registry:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到了主要事件。脚本遍历`svc`目录的所有子目录，寻找`Dockerfile`。如果找到`Dockerfile`，它会构建一个镜像，使用服务名称和`TAG`以及`STABLE_TAG`的组合对其进行标记，最后将标记的镜像推送到注册表：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Dockerizing a Go service with a multi-stage Dockerfile
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多阶段Dockerfile对Go服务进行Docker化
- en: 'The Docker images you build in a microservice system are very important. You
    will build many of them, and each one many, many times. These images will also
    be shipped back and forth over the wire, and they present a target for attackers.
    With this in mind, it makes sense to build images that have the following properties:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务系统中构建的Docker镜像非常重要。您将构建许多镜像，并且每个镜像都会构建多次。这些镜像也会在网络上传输，并且它们是攻击者的目标。考虑到这一点，构建具有以下属性的镜像是有意义的：
- en: Lightweight
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量级
- en: Present minimal attack surface
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供最小的攻击面
- en: 'This can be done by using a proper base image. For example, Alpine is very
    popular due to its small footprint. However, nothing beats the scratch base image.
    With Go-based microservices, you can literally create an image that just contains
    your service binary. Let''s continue peeling the onion and look into the Dockerfile
    of one of the services. Spoiler alert: they are all virtually identical, and just
    differ in terms of their service names.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用适当的基础镜像来实现。例如，由于其小的占用空间，Alpine非常受欢迎。然而，没有什么能比得上scratch基础镜像。对于基于Go的微服务，您可以创建一个只包含服务二进制文件的镜像。让我们继续剥离洋葱，看看其中一个服务的Dockerfile。剧透警告：它们几乎完全相同，只是在服务名称方面有所不同。
- en: You can find the `Dockerfile` of `link_service` at [https://github.com/the-gigi/delinkcious/blob/master/svc/link_service/Dockerfile](https://github.com/the-gigi/delinkcious/blob/master/svc/link_service/Dockerfile).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/the-gigi/delinkcious/blob/master/svc/link_service/Dockerfile](https://github.com/the-gigi/delinkcious/blob/master/svc/link_service/Dockerfile)找到`link_service`的`Dockerfile`。
- en: 'We are using the multi-stage `Dockerfile` here. We will build the image using
    the standard Golang image. The arcane magic in the last line is what it takes
    to build a truly static and self-contained Golang binary that doesn''t require
    a dynamic runtime library:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了多阶段的`Dockerfile`。我们将使用标准的Golang镜像构建镜像。最后一行中的神秘魔法是构建一个真正静态和自包含的Golang二进制文件所需的内容，它不需要动态运行时库：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We then copy the final binary into a scratch base image and create the smallest
    and most secure image possible. We exposed the `7070` port, which is the port
    the service listens on:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将最终的二进制文件复制到一个基于scratch的镜像中，并创建尽可能小和最安全的镜像。我们暴露了`7070`端口，这是服务监听的端口：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Exploring the CircleCI UI
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索CircleCI UI
- en: 'CircleCI has a very friendly UI. Here, you can set various project settings,
    explore your builds, and drill down into specific builds. Remember that we used
    a monorepo approach and that, in the `build.sh` file, we took care of building
    multiple services. From CircleCI''s point of view, Delinkcious is a single cohesive
    project. Here is the project''s view of Delinkcious, which displays the recent
    builds:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI有一个非常友好的UI。在这里，您可以设置各种项目设置，探索您的构建，并深入到特定的构建中。请记住，我们使用了monorepo方法，并且在`build.sh`文件中，我们负责构建多个服务。从CircleCI的角度来看，Delinkcious是一个单一的连贯项目。这是Delinkcious项目的视图，显示了最近的构建：
- en: '![](assets/9a97ae35-684e-46b5-a109-431a25306b59.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9a97ae35-684e-46b5-a109-431a25306b59.png)'
- en: 'Let''s drill down into a successful build. All is well and green:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入研究一下成功的构建。一切都很好，一切都是绿色的：
- en: '![](assets/a41c4da5-4506-4b5d-b58b-ba086564d8e1.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a41c4da5-4506-4b5d-b58b-ba086564d8e1.png)'
- en: 'You can even expand any step and check the console output. Here''s the output
    of the test stage:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以展开任何步骤并检查控制台输出。这是测试阶段的输出：
- en: '![](assets/5aa9ea2b-c03b-4f08-9d2b-be6cb0ac69af.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5aa9ea2b-c03b-4f08-9d2b-be6cb0ac69af.png)'
- en: 'This is cool, but it''s even more useful when things go wrong and you need
    to figure out why. For example, at one point, I tried to hide the `build.sh` script
    inside the `.circleci` directory next to the `config.yaml` file, but it wasn''t
    added to the Docker context and produced the following error:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷，但当事情出错时，你需要弄清楚原因时，它甚至更有用。例如，有一次，我试图将`build.sh`脚本隐藏在`.circleci`目录中，紧挨着`config.yaml`文件，但它没有被添加到Docker上下文中，并产生了以下错误：
- en: '![](assets/517f725d-a032-41db-9dc5-8c68fbf28b44.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/517f725d-a032-41db-9dc5-8c68fbf28b44.png)'
- en: Considering future improvements
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑未来的改进
- en: The Dockerfiles are pretty much duplicates, and there are some assumptions that
    can be parameterized. In the Kubernetes ecosystem, there are some interesting
    projects that help to address these concerns. Some of the solutions are for local
    development and can automatically generate the necessary Dockerfiles, while others
    are more targeted toward consistent and uniform production setups. We will look
    into some of these in later chapters. In this chapter, I want to keep it simple
    and avoid overwhelming you with too many options and layers of indirection.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile几乎是重复的，并且有一些可以参数化的假设。在Kubernetes生态系统中，有一些有趣的项目可以帮助解决这些问题。一些解决方案是用于本地开发的，可以自动生成必要的Dockerfile，而其他一些则更加针对一致和统一的生产设置。我们将在后面的章节中研究其中一些。在本章中，我希望保持简单，避免用太多选项和间接层来压倒你。
- en: Another opportunity for improvement is to test and build only services that
    have changed (or their dependencies have changed). As it stands, the `build.sh`
    script always builds all the images and tags them all with the same tags.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个改进的机会是仅测试和构建已更改的服务（或其依赖项已更改）。目前，`build.sh` 脚本总是构建所有图像，并使用相同的标签对它们进行标记。
- en: So far, we've built a complete CI pipeline using CircleCI and Docker. The next
    phase is to set up Argo CD as a continuous delivery pipeline.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用 CircleCI 和 Docker 构建了完整的 CI 管道。下一阶段是设置 Argo CD 作为持续交付管道。
- en: Setting up continuous delivery for Delinkcious
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Delinkcious 设置持续交付
- en: With continuous integration in CircleCI under our belt, we can turn our attention
    to continuous delivery. First, we'll see what it takes to deploy a Delinkcious
    microservice to a Kubernetes cluster, then we'll look into Argo CD itself, and
    finally, we'll set up complete continuous delivery for Delinkcious via Argo CD.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们掌握了 CircleCI 中的持续集成之后，我们可以将注意力转向持续交付。首先，我们将看看将 Delinkcious 微服务部署到 Kubernetes
    集群需要什么，然后我们将研究 Argo CD 本身，最后，我们将通过 Argo CD 为 Delinkcious 设置完整的持续交付。
- en: Deploying a Delinkcious microservice
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署 Delinkcious 微服务
- en: 'Each Delinkcious microservice has a set of Kubernetes resources defined in
    YAML manifests in its `k8s` subdirectory. Here is the link service `k8s` directory:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Delinkcious 微服务在其 `k8s` 子目录中定义了一组 Kubernetes 资源的 YAML 清单。这是 link 服务的 `k8s`
    目录：
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `link_manager.yaml` file contains two resources: the Kubernetes deployment
    and the Kubernetes service. The Kubernetes deployment is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`link_manager.yaml` 文件包含两个资源：Kubernetes 部署和 Kubernetes 服务。Kubernetes 部署如下：'
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The Kubernetes service is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 服务如下：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `db.yaml` file describes the database the link service uses to persist
    its state. Both can be deployed via `kubectl` in a single command by passing the
    `k8s` directory to `kubectl apply`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.yaml` 文件描述了 link 服务用于持久化其状态的数据库。可以通过将 `k8s` 目录传递给 `kubectl apply` 来一次性部署两者：'
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The main difference between kubectl create and `kubectl apply` is that `create`
    will return an error if a resource already exists.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl create 和 `kubectl apply` 之间的主要区别是，如果资源已经存在，`create` 将返回错误。
- en: Deploying from the command line with `kubectl` is nice, but our goal is to automate
    the process. Let's understand this.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl` 从命令行部署很好，但我们的目标是自动化这个过程。让我们来了解一下。
- en: Understanding Argo CD
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Argo CD
- en: 'Argo CD is an open source continuous delivery solution for Kubernetes. It was
    created by Intuit and adopted by many other companies, including Google, NVIDIA,
    Datadog, and Adobe. It has an impressive set of features, which are as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD 是 Kubernetes 的开源持续交付解决方案。它由 Intuit 创建，并被包括 Google、NVIDIA、Datadog 和 Adobe
    在内的许多其他公司采用。它具有一系列令人印象深刻的功能，如下所示：
- en: Automated deployment of apps to specific target environments
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序自动部署到特定目标环境
- en: CLI and web visualization of applications and differences between the desired
    and live states
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLI 和 Web 可视化应用程序以及所需状态和实际状态之间的差异
- en: Hooks for supporting advanced deployment patterns (blue/green and canary)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持高级部署模式的钩子（蓝/绿和金丝雀）
- en: Support for multiple config management tools (plain YAML, ksonnet, kustomize,
    Helm, and so on)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多个配置管理工具（普通 YAML、ksonnet、kustomize、Helm 等）
- en: Continuous monitoring of all deployed applications
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对所有部署的应用程序进行持续监控
- en: Manual or automated sync of applications to the desired state
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动或自动将应用程序同步到所需状态
- en: Rollback to any application state that's committed in the Git repository
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回滚到 Git 存储库中提交的任何应用程序状态
- en: Health assessment for all the components of the application
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对应用程序的所有组件进行健康评估
- en: SSO integration
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSO 集成
- en: GitOps webhook integration (GitHub, GitLab, and BitBucket)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitOps webhook integration (GitHub, GitLab, and BitBucket)
- en: Service account/access key management for integration with CI pipelines
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于与CI流水线集成的服务帐户/访问密钥管理
- en: Audit trails for application events and API calls
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用事件和API调用的审计跟踪
- en: Argo CD is built on Argo
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Argo CD是建立在Argo上的
- en: Argo CD is a specialized CD pipeline, but it is built on the solid Argo workflow
    engine. I like this layered approach a lot, where you have a robust general-purpose
    foundation for the problem of orchestrating a workflow composed of steps and then
    build on top of it with CD-specific features and capabilities.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD是一个专门的CD流水线，但它是建立在稳固的Argo工作流引擎之上的。我非常喜欢这种分层方法，您可以在这个坚实的通用基础上构建具有CD特定功能和能力的工作流程。
- en: Argo CD utilizes GitOps
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Argo CD利用GitOps
- en: Argo CD adheres to the GitOps approach. The basic principle is that the state
    of your system is stored in Git. Argo CD manages your live state versus the desired
    state by examining Git diffs and using Git primitives to roll back and reconcile
    the live state.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD遵循GitOps方法。基本原则是您系统的状态存储在Git中。Argo CD通过检查Git差异并使用Git基元来回滚和协调实时状态，来管理您的实时状态与期望状态。
- en: Getting started with Argo CD
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Argo CD
- en: 'Argo CD follows best practices and expects to be installed in a dedicated namespace
    on your Kubernetes cluster:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD遵循最佳实践，并期望在Kubernetes集群上的专用命名空间中安装：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s see what was created. Argo CD installed four types of objects: pods,
    services, deployments, and replica sets. Here are the pods:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建了什么。 Argo CD安装了四种类型的对象：pod、service、deployment和replica set。以下是pod：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here are the services:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是服务：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here are the deployments:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是部署：
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, here are the replica sets:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是副本集：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, Argo CD also installs two **custom resource definitions **(**CRDs**):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Argo CD还安装了两个**自定义资源定义**（**CRD**）：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'CRDs allow various projects to extend the Kubernetes API and add their own
    domain objects, as well as controllers to monitor them and other Kubernetes resources.
    Argo CD adds the concepts of an application and project to the world of Kubernetes.
    Soon, you will see how they integrate for the purposes of continuous delivery
    with built-in Kubernetes resources such as deployments, services, and pods. Let''s
    get started:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: CRD允许各种项目扩展Kubernetes API并添加自己的域对象，以及监视它们和其他Kubernetes资源的控制器。Argo CD将应用程序和项目的概念添加到Kubernetes的世界中。很快，您将看到它们如何集成，以实现内置Kubernetes资源（如部署、服务和pod）的持续交付目的。让我们开始吧：
- en: 'Install the Argo CD CLI:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Argo CD CLI：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Port-forward to access the Argo CD server:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端口转发以访问Argo CD服务器：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The initial password for the admin user is the name of the Argo CD server:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理员用户的初始密码是Argo CD服务器的名称：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Log in to the server:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到服务器：
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If it complains about an insecure login, just confirm by pressing *y*:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它抱怨登录不安全，只需按*y*确认：
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Alternatively, to skip the warning, type in the following:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，要跳过警告，请输入以下内容：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Then, you can change the password.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以更改密码。
- en: 'If you store your password in an environment variable (for example, `ARGOCD_PASSWORD`),
    then you can have a one-liner so that you can log in with no further questions
    being asked:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您将密码存储在环境变量中（例如`ARGOCD_PASSWORD`），那么您可以使用一行命令登录，而无需进一步提问：
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Configuring Argo CD
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Argo CD
- en: 'Remember to port-forward the argocd-server:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 记得端口转发到argocd-server：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, you can just browse to `https://localhost:8080` and provide the `admin`
    user''s password to log in:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您只需浏览到`https://localhost:8080`并提供`admin`用户的密码即可登录：
- en: '![](assets/89af4578-32da-4ec6-8162-c853c128dd08.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/89af4578-32da-4ec6-8162-c853c128dd08.png)'
- en: Configuring Argo CD is a pleasure. Its UI is very pleasant and easy to work
    with. It supports the Delinkcious monorepo out of the box, and there are no assumptions
    that each Git repository contains one application or project.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Argo CD是一种乐趣。它的用户界面非常愉快且易于使用。它支持Delinkcious monorepo，而且没有假设每个Git存储库只包含一个应用程序或项目。
- en: It will ask you for a Git repository to watch for changes, a Kubernetes cluster
    (defaults to the cluster it is installed on), and then it will try to detect the
    manifests in the repository. Argo CD supports multiple manifest formats and templates,
    such as Helm, ksonnet, and kustomize. We will introduce some of these fine tools
    later in this book. To keep things simple, we have configured each application
    with the directory that contains its raw `k8s` YAML manifests, which Argo CD also
    supports.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 它会要求您选择一个Git存储库以监视更改，一个Kubernetes集群（默认为安装在其上的集群），然后它将尝试检测存储库中的清单。Argo CD支持多种清单格式和模板，例如Helm、ksonnet和kustomize。我们将在本书的后面介绍其中一些优秀的工具。为了保持简单，我们已经为每个应用程序配置了包含其原始`k8s`
    YAML清单的目录，Argo CD也支持这些清单。
- en: When all is said and done, the Argo CD is ready to go!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 说到做到，Argo CD已经准备就绪！
- en: Using sync policies
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用同步策略
- en: By default, Argo CD detects when an application's manifests are out of sync,
    but doesn't sync automatically. This is a good default. In some cases, more tests
    need to run in dedicated environments before pushing changes to production. In
    other cases, a human must be in the loop. However, in many other cases, it's OK
    to automatically deploy changes to the cluster immediately and without human intervention.
    The fact that Argo CD follows GitOps also makes it very easy to sync back to any
    previous version (including the last one).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Argo CD会检测应用程序的清单是否不同步，但不会自动同步。这是一个很好的默认设置。在某些情况下，需要在专用环境中运行更多测试，然后再将更改推送到生产环境。在其他情况下，必须有人参与。然而，在许多其他情况下，可以立即自动部署更改到集群中，而无需人为干预。Argo
    CD遵循GitOps的事实也使得非常容易将同步回任何先前的版本（包括最后一个）。
- en: 'For Delinkcious, I chose auto sync because it is a demo project and the consequences
    of deploying a bad version are negligible. This can be done in the UI or from
    the CLI:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Delinkcious，我选择了自动同步，因为它是一个演示项目，部署错误版本的后果是可以忽略不计的。这可以在UI中或从CLI中完成：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The auto sync policy doesn''t guarantee that the application will always be
    in sync. There are limitations that govern the auto sync process, which are as
    follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 自动同步策略不能保证应用程序始终处于同步状态。自动同步过程受到一些限制，具体如下：
- en: Applications in error state will not attempt automated sync.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处于错误状态的应用程序将不会尝试自动同步。
- en: Argo CD will attempt only a single auto sync for a specific commit SHA and parameters.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argo CD将仅针对特定提交SHA和参数尝试一次自动同步。
- en: If auto sync failed for whatever reason, it will not attempt it again.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果由于任何原因自动同步失败，它将不会再次尝试。
- en: You can't roll back an application with auto sync.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您无法使用自动同步回滚应用程序。
- en: In all of these cases, you either have to make a change to the manifests to
    trigger another auto sync or sync manually. To roll back (or, in general, sync
    to a previous version), you must turn auto sync off.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，您要么必须对清单进行更改以触发另一个自动同步，要么手动同步。要回滚（或者一般地，同步到先前的版本），您必须关闭自动同步。
- en: 'Argo CD offers another policy for pruning resources on deployment. When an
    existing resource no longer exists in Git, Argo CD will not delete it by default.
    This is a safety mechanism that''s used to avoid destroying critical resources
    if someone makes a mistake while editing Kubernetes manifests. However, if you
    know what you''re doing (for example, for stateless applications), you can turn
    on automatic pruning:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD在部署时提供了另一种修剪资源的策略。当现有资源不再存在于Git中时，默认情况下Argo CD不会将其删除。这是一种安全机制，用于避免在编辑Kubernetes清单时出现错误时破坏关键资源。但是，如果您知道自己在做什么（例如，对于无状态应用程序），您可以打开自动修剪：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Exploring Argo CD
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Argo CD
- en: Now that we have logged in and configured Argo CD, let's explore it a little
    bit. I really like the UI, but you can do everything from the command line or
    through a REST API, too, if you want to access it programmatically.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经登录并配置了Argo CD，让我们稍微探索一下。我真的很喜欢UI，但如果您想以编程方式访问它，也可以通过命令行或REST API完成所有操作。
- en: 'I already configured Argo CD with the three Delinkcious microservices. Each
    service is considered an application in Argo CD speak. Let''s take a look at the
    Applications view:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经使用三个Delinkcious微服务配置了Argo CD。在Argo CD中，每个服务都被视为一个应用程序。让我们来看看应用程序视图：
- en: '![](assets/df0184c7-6233-48e9-acdd-69818bdbef64.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/df0184c7-6233-48e9-acdd-69818bdbef64.png)'
- en: 'There are a few interesting things here. Let''s talk about each one:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的东西。让我们来谈谈每一个：
- en: The project is an Argo CD concept for grouping applications.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目是用于分组应用程序的Argo CD概念。
- en: The namespace is the Kubernetes namespace where the application should be installed.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间是应用程序应安装的Kubernetes命名空间。
- en: The cluster is the Kubernetes cluster, that is, `https://kubernetes.default.svc` and
    this is the cluster where Argo CD is installed.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群是Kubernetes集群，即`https://kubernetes.default.svc`，这是安装了Argo CD的集群。
- en: The status tells you if the current application is in sync with its YAML manifests
    in the Git repository.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态告诉您当前应用程序是否与其Git存储库中的YAML清单同步。
- en: The health tells you if the application is OK.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康状态告诉您应用程序是否正常。
- en: The repository is the application's Git repository.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库是应用程序的Git存储库。
- en: The path is the relative path within the repository where the `k8s` YAML manifests
    live (Argo CD monitors this directory for changes).
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径是存储库中`k8s` YAML清单所在的相对路径（Argo CD监视此目录以进行更改）。
- en: 'Here is what you get from the `argocd` CLI:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您从`argocd` CLI中获得的内容：
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see (both in the UI and in the CLI), `link-manager` is out of sync.
    We can sync it by selecting Sync from the ACTIONS dropdown:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以在UI和CLI中看到的那样，`link-manager`不同步。我们可以通过从“ACTIONS”下拉菜单中选择“同步”来同步它。
- en: '![](assets/a502437e-8c5b-4674-8729-86ef2c59a169.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a502437e-8c5b-4674-8729-86ef2c59a169.png)'
- en: 'Alternatively, you can do this from the CLI:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以从CLI中执行此操作：
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'One of the coolest things about the UI is how it presents all the `k8s` resources
    associated with an application. By clicking on the `social-graph-manager` application,
    we get the following view:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: UI最酷的地方之一是它如何呈现与应用程序相关的所有`k8s`资源。点击`social-graph-manager`应用程序，我们会得到以下视图：
- en: '![](assets/82b4007d-977f-4a44-99fb-04fcfe418ba2.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/82b4007d-977f-4a44-99fb-04fcfe418ba2.png)'
- en: We can see the application itself, the services, the deployments, and the pods,
    including how many pods are running. This is actually a filtered view and, if
    we want to, we can add the replica sets associated with each deployment and the
    endpoints of each service to the display. However, these aren't interesting most
    of the time, so Argo CD doesn't display them by default.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到应用程序本身、服务、部署和Pod，包括运行的Pod数量。这实际上是一个经过筛选的视图，如果我们愿意，我们可以将与每个部署相关的副本集和每个服务的端点添加到显示中。但是，大多数情况下这些都不是很有趣，因此Argo
    CD默认不显示它们。
- en: 'We can click on a service and view a SUMMARY of its information, including
    the MANIFEST:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以点击一个服务，查看其信息的摘要，包括清单：
- en: '![](assets/aa33e5a2-434f-41e1-a431-0f1b81e471e9.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aa33e5a2-434f-41e1-a431-0f1b81e471e9.png)'
- en: 'For pods, we can even check the logs, as shown in the following screenshot,
    all from the comfort of the Argo CD UI:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Pods，我们甚至可以检查日志，如下面的截图所示，所有这些都可以在Argo CD的UI中轻松完成：
- en: '![](assets/a3d9eeff-e579-4f2f-ac1f-48bcb964819a.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a3d9eeff-e579-4f2f-ac1f-48bcb964819a.png)'
- en: Argo CD can already take you a long way. However, it has a lot more to offer,
    and we will dive into these offerings later on in this book.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD已经可以带您走很远。然而，它还有更多的提供，我们将在本书的后面深入探讨这些内容。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the importance of a CI/CD pipeline for a microservices-based
    distributed system. We reviewed some CI/CD options for Kubernetes and settled
    on a combination of CircleCI for the CI part (code change | Docker image) and
    Argo CD for the CD part (`k8s` manifest change | deployed application).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了基于微服务的分布式系统的CI/CD流水线的重要性。我们审查了一些针对Kubernetes的CI/CD选项，并确定了使用CircleCI进行CI部分（代码更改|Docker镜像）和Argo
    CD进行CD部分（`k8s`清单更改|部署的应用程序）的组合。
- en: We also covered the best practices for building Docker images using multi-stage
    builds, the `k8s` YAML manifests for Postgres DB, and the deployment and service
    `k8s` resources. Then, we installed Argo CD in the cluster, configured it to build
    all our microservices, and explored the UI and the CLI. At this point, you should
    have a clear understanding of the concept of CI/CD and how important it is, the
    pros and cons of various solutions, and how to choose the best option for your
    system.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了使用多阶段构建构建Docker镜像的最佳实践，Postgres DB的`k8s` YAML清单，以及部署和服务`k8s`资源。然后，我们在集群中安装了Argo
    CD，配置它来构建所有我们的微服务，并探索了UI和CLI。在这一点上，您应该对CI/CD的概念以及其重要性有清晰的理解，各种解决方案的利弊以及如何为您的系统选择最佳选项。
- en: However, there is much more to come. In later chapters, we will improve our
    CI/CD pipeline with additional tests, security checks, and advanced multi-environment
    deployment options.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有更多内容。在后面的章节中，我们将通过额外的测试、安全检查和高级多环境部署选项来改进我们的CI/CD流水线。
- en: In the next chapter, we will turn out attention to configuring our services.
    Configuration is a huge part of developing complex systems that need to be developed,
    tested, and deployed by large teams. We will explore various conventional configuration
    options, such as command-line arguments, environment variables, and configuration
    files, as well as more dynamic configuration options and the special configuration
    features of Kubernetes.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把注意力转向配置我们的服务。配置是开发复杂系统的重要部分，需要大型团队开发、测试和部署。我们将探讨各种传统配置选项，如命令行参数、环境变量和配置文件，以及更动态的配置选项和Kubernetes的特殊配置功能。
- en: Further reading
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following sources for more information regarding what
    was covered in this chapter:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下来源，了解本章涵盖的更多信息：
- en: 'Here are some good resources to expand your knowledge of the CI/CD options
    on Kubernetes. First and foremost, here are the two projects I use for the Delinkcious
    CI/CD solution:'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一些扩展您对Kubernetes上CI/CD选项的了解的好资源。首先，这是我用于Delinkcious CI/CD解决方案的两个项目：
- en: '**CircleCI**: [https://circleci.com/docs/](https://circleci.com/docs/)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CircleCI**: [https://circleci.com/docs/](https://circleci.com/docs/)'
- en: '**Argo**: [https://argoproj.github.io/docs/argo-cd/docs/](https://argoproj.github.io/docs/argo-cd/docs/)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Argo**: [https://argoproj.github.io/docs/argo-cd/docs/](https://argoproj.github.io/docs/argo-cd/docs/)'
- en: 'Then, there''s this free mini ebook about CI/CD with Kubernetes:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，还有这本关于Kubernetes的CI/CD的免费迷你电子书：
- en: '[https://thenewstack.io/ebooks/kubernetes/ci-cd-with-kubernetes/](https://thenewstack.io/ebooks/kubernetes/ci-cd-with-kubernetes/)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://thenewstack.io/ebooks/kubernetes/ci-cd-with-kubernetes/](https://thenewstack.io/ebooks/kubernetes/ci-cd-with-kubernetes/)'
- en: 'Finally, here are a couple of the other options I discarded for Delinkcious,
    but may be a good option for you:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，这里有一些我在Delinkcious中放弃的其他选项，但可能对你来说是一个不错的选择：
- en: '**Jenkins X**: [https://jenkins-x.io/](https://jenkins-x.io/)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Jenkins X: [https://jenkins-x.io/](https://jenkins-x.io/)'
- en: '**Spinnaker**: [https://www.spinnaker.io/](https://www.spinnaker.io/)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Spinnaker: [https://www.spinnaker.io/](https://www.spinnaker.io/)'
