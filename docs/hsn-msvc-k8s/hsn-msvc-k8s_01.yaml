- en: Introduction to Kubernetes for Developers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发人员的Kubernetes简介
- en: 'In this chapter, we will introduce you to Kubernetes. Kubernetes is a big platform
    and it''s difficult to do justice to it in just one chapter. Luckily, we have
    a whole book to explore it. Don''t worry if you feel a little overwhelmed. I''ll
    mention many concepts and capabilities briefly. In later chapters, we will cover
    many of these in detail, as well as the connections and interactions between those
    Kubernetes concepts. To spice things up and get hands-on early, you will also
    create a local Kubernetes cluster (Minikube) on your machine. This chapter will
    cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您介绍Kubernetes。Kubernetes是一个庞大的平台，在一个章节中很难充分展现它。幸运的是，我们有一整本书来探索它。如果您感到有些不知所措，请不要担心。我会简要提到许多概念和功能。在后面的章节中，我们将详细介绍其中的许多内容，以及这些Kubernetes概念之间的联系和互动。为了增加趣味并尽早动手，您还将在本地机器上创建一个Kubernetes集群（Minikube）。本章将涵盖以下主题：
- en: Kubernetes in a nutshell
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes简介
- en: The Kubernetes architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes架构
- en: Kubernetes and microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes和微服务
- en: Creating a local cluster
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个本地集群
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, you will need the following tools:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将需要以下工具：
- en: Docker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Kubectl
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubectl
- en: Minikube
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minikube
- en: Installing Docker
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker
- en: To install Docker, follow the instructions here: [https://docs.docker.com/install/#supported-platforms](https://docs.docker.com/install/#supported-platforms). I
    will use Docker for macOS.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Docker，请按照这里的说明操作：[https://docs.docker.com/install/#supported-platforms](https://docs.docker.com/install/#supported-platforms)。我将在macOS上使用Docker。
- en: Installing kubectl
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装kubectl
- en: 'To install kubectl, follow the instructions here: [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装kubectl，请按照这里的说明操作：[https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)。
- en: Kubectl is the Kubernetes CLI and we will use it extensively throughout the
    book.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl是Kubernetes的CLI，我们将在整本书中广泛使用它。
- en: Installing Minikube
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Minikube
- en: 'To install Minikube, follow the instructions here: [https://kubernetes.io/docs/tasks/tools/install-minikube/](https://kubernetes.io/docs/tasks/tools/install-minikube/).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Minikube，请按照这里的说明操作：[https://kubernetes.io/docs/tasks/tools/install-minikube/](https://kubernetes.io/docs/tasks/tools/install-minikube/)。
- en: Note that you need to install a hypervisor too. For the macOS, I find VirtualBox
    the most reliable. You may prefer another hypervisor, such as HyperKit. There
    will be more detailed instructions later when you get to play with Minikube.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您还需要安装一个hypervisor。对于macOS，我发现VirtualBox是最可靠的。您可能更喜欢另一个hypervisor，比如HyperKit。当您开始使用Minikube时，将会有更详细的说明。
- en: The code
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码
- en: The code for the chapter is available here: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter01](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter01)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码在这里可用：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter01](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter01)
- en: There is another Git repository for the Delinkcious sample application that
    we will build together: [https://github.com/the-gigi/delinkcious](https://github.com/the-gigi/delinkcious)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将一起构建的Delinkcious示例应用程序还有另一个Git存储库：[https://github.com/the-gigi/delinkcious](https://github.com/the-gigi/delinkcious)
- en: Kubernetes in a nutshell
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes简介
- en: In this section, you'll get a sense of what Kubernetes is all about, its history,
    and how it became so popular.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您将了解Kubernetes的全部内容，它的历史以及它是如何变得如此受欢迎的。
- en: Kubernetes – the container orchestration platform
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes - 容器编排平台
- en: The primary function of Kubernetes is deploying and managing a large number
    of container-based workloads on a fleet of machines (physical or virtual). This
    means that Kubernetes provides the means to deploy containers to the cluster.
    It makes sure to comply with various scheduling constraints and pack the containers
    efficiently into the cluster nodes. In addition, Kubernetes automatically watches
    your containers and restarts them if they fail. Kubernetes will also relocate
    workloads off problematic nodes to other nodes. Kubernetes is an extremely flexible
    platform. It relies on a provisioned infrastructure layer of compute, memory,
    storage, and networking, and, with these resources, it works its magic.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的主要功能是在一组机器（物理或虚拟）上部署和管理大量基于容器的工作负载。这意味着Kubernetes提供了将容器部署到集群的手段。它确保遵守各种调度约束，并将容器有效地打包到集群节点中。此外，Kubernetes会自动监视您的容器，并在它们失败时重新启动它们。Kubernetes还会将工作负载从有问题的节点重新定位到其他节点上。Kubernetes是一个非常灵活的平台。它依赖于计算、内存、存储和网络的基础设施层，并利用这些资源发挥其魔力。
- en: The history of Kubernetes
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes的历史
- en: Kubernetes and the entire cloud-native scene is moving at breakneck speed, but
    let's take a moment to reflect on how we got here. It will be a very short journey
    because Kubernetes came out of Google in June 2014, just a few years ago. When
    Docker became popular, it changed how people package, distribute, and deploy software.
    But, it soon became apparent that Docker doesn't scale on its own for large distributed
    systems. A few orchestration solutions became available, such as Apache Mesos,
    and later, Docker's own swarm. But, they never measured up to Kubernetes. Kubernetes
    was conceptually based on Google's Borg system. It brought together the design
    and technical excellence of a decade of Google engineering, but it was a new open
    source project. At OSCON 2015, Kubernetes 1.0 was released and the floodgates
    opened. The growth of Kubernetes, its ecosystem, and the community behind it,
    was as impressive as its technical excellence.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes和整个云原生领域发展迅猛，但让我们花点时间回顾一下我们是如何到达这里的。这将是一个非常简短的旅程，因为Kubernetes于2014年6月从谷歌推出，仅仅几年前。当Docker变得流行时，它改变了人们打包、分发和部署软件的方式。但很快就显而易见，Docker本身无法满足大型分布式系统的规模。一些编排解决方案变得可用，比如Apache
    Mesos，后来是Docker自己的swarm。但它们从未达到Kubernetes的水平。Kubernetes在概念上基于谷歌的Borg系统。它汇集了谷歌工程十年的设计和技术卓越性，但它是一个新的开源项目。在2015年的OSCON上，Kubernetes
    1.0发布了，大门敞开了。Kubernetes及其生态系统的增长以及背后的社区，与其技术卓越性一样令人印象深刻。
- en: Kubernetes means helmsman in Greek. You'll notice many nautical terms in the
    names of Kubernetes-related projects.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes在希腊语中意味着舵手。你会注意到许多与Kubernetes相关项目的航海术语。
- en: The state of Kubernetes
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes的现状
- en: Kubernetes is now a household name. The DevOps world pretty much equates container
    orchestration with Kubernetes. All major cloud providers offer managed Kubernetes
    solutions. It is ubiquitous in enterprise and in startup companies. While Kubernetes
    is still young and innovation keeps happening, it is all happening in a very healthy
    way. The core is rock solid, battle tested, and used in production across lots
    and lots of companies. There are very big players collaborating and pushing Kubernetes
    forward, such as Google (obviously), Microsoft, Amazon, IBM, and VMware.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes现在是家喻户晓的名字。DevOps世界几乎将容器编排与Kubernetes等同起来。所有主要的云服务提供商都提供托管的Kubernetes解决方案。它在企业和初创公司中无处不在。虽然Kubernetes仍然年轻，创新不断发生，但这一切都是以非常健康的方式进行的。核心非常稳固，经过了严格测试，并在许多公司的生产中使用。有一些非常大的参与者在合作并推动Kubernetes的发展，比如谷歌（显然）、微软、亚马逊、IBM和VMware。
- en: The **Cloud Native Computing Foundation** (**CNCF**) open source organization
    offers certification. Every 3 months, a new Kubernetes release comes out, which
    is the result of a collaboration between hundreds of volunteers and paid engineers.
    There is a large ecosystem surrounding the main project of both commercial and
    open source projects. You will see later how Kubernetes' flexible and extensible
    design encourages this ecosystem and helps in integrating Kubernetes into any
    cloud platform.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cloud Native Computing Foundation**（**CNCF**）开源组织提供认证。每3个月，都会推出一个新的Kubernetes版本，这是数百名志愿者和有偿工程师合作的结果。有一个庞大的生态系统围绕着商业和开源项目的主要项目。稍后您将看到，Kubernetes灵活和可扩展的设计鼓励了这个生态系统，并有助于将Kubernetes集成到任何云平台中。'
- en: Understanding the Kubernetes architecture
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Kubernetes架构
- en: Kubernetes is a marvel of software engineering. The architecture and design
    of Kubernetes are a big part in its success. Each cluster has a control plane
    and data plane. The control plane consists of several components, such as an API
    server, a metadata store for keeping the state of a cluster, and multiple controllers
    that are responsible for managing the nodes in the data plane and providing access
    to users. The control plane in production will be distributed across multiple
    machines for high availability and robustness. The data plane consists of multiple
    nodes, or workers. The control plane will deploy and run your pods (groups of
    containers) on these nodes, and then watch for changes and respond.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是软件工程的奇迹。Kubernetes的架构和设计是其成功的重要组成部分。每个集群都有一个控制平面和数据平面。控制平面由多个组件组成，例如API服务器，用于保持集群状态的元数据存储，以及负责管理数据平面中的节点并为用户提供访问权限的多个控制器。生产中的控制平面将分布在多台机器上，以实现高可用性和鲁棒性。数据平面由多个节点或工作节点组成。控制平面将在这些节点上部署和运行您的pod（容器组），然后监视更改并做出响应。
- en: 'Here is a diagram that illustrates the overall architecture:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个说明整体架构的图表：
- en: '![](assets/f4c49543-afdd-4a9f-98df-ec49113430c1.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f4c49543-afdd-4a9f-98df-ec49113430c1.png)'
- en: Let's review in detail the control plane and the data plane, as well as kubectl,
    which is the command-line tool you use to interact with the Kubernetes cluster.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细审查控制平面和数据平面，以及kubectl，这是您用来与Kubernetes集群交互的命令行工具。
- en: The control plane
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制平面
- en: 'The control plane consists of several components:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 控制平面由几个组件组成：
- en: API server
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API服务器
- en: The etcd metadata store
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: etcd元数据存储
- en: Scheduler
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度程序
- en: Controller manager
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器管理器
- en: Cloud controller manager
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云控制器管理器
- en: Let's examine the role of each component.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来审查每个组件的作用。
- en: The API server
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API服务器
- en: The **kube-api-server** is a massive REST server that exposes the Kubernetes
    API to the world. You can have multiple instances of the API server in your control
    plane for high-availability. The API server keeps the cluster state in etcd.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**kube-api-server**是一个大型的REST服务器，向世界公开Kubernetes API。您可以在控制平面中拥有多个API服务器实例，以实现高可用性。API服务器将集群状态保存在etcd中。'
- en: The etcd store
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: etcd存储
- en: The complete cluster is stored in etcd ([https://coreos.com/etcd/](https://coreos.com/etcd/)),
    a consistent and reliable, distributed key-value store. The **etcd store** is
    an open source project (developed by CoreOS, originally).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的集群存储在etcd（[https://coreos.com/etcd/](https://coreos.com/etcd/)）中，这是一个一致且可靠的分布式键值存储。**etcd存储**是一个开源项目（最初由CoreOS开发）。
- en: It is common to have three or five instances of etcd for redundancy. If you
    lose the data in your etcd store, you lose your cluster.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会有三个或五个etcd实例以实现冗余。如果您丢失了etcd存储中的数据，您将丢失整个集群。
- en: The scheduler
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度程序
- en: The **kube-scheduler** is responsible for scheduling pods to worker nodes. It
    implements a sophisticated scheduling algorithm that takes a lot of information
    into account, such as resource availability on each node, various constraints
    specified by the user, types of available nodes, resource limits and quotas, and
    other factors, such as affinity, anti-affinity, tolerations, and taints.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: kube调度器负责将pod调度到工作节点。它实现了一个复杂的调度算法，考虑了很多信息，比如每个节点上的资源可用性，用户指定的各种约束条件，可用节点的类型，资源限制和配额，以及其他因素，比如亲和性，反亲和性，容忍和污点。
- en: The controller manager
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器管理器
- en: 'The **kube-controller manager** is a single process that contains multiple
    controllers for simplicity. These controllers watch for events and changes to
    the cluster and respond accordingly:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: kube控制器管理器是一个包含多个控制器的单个进程，以简化操作。这些控制器监视集群的事件和变化，并做出相应的响应：
- en: '**Node controller**: Responsible for noticing and responding when nodes go
    down.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点控制器：负责在节点宕机时发现并做出响应。
- en: '**Replication controller**: This makes sure that there is the correct number
    of pods for each replica set or replication controller object.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制控制器：确保每个复制集或复制控制器对象有正确数量的pod。
- en: '**Endpoints controller**: This assigns for each service an endpoints object
    that lists the service''s pods.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端点控制器：为每个服务分配一个列出服务pod的端点对象。
- en: '**Service account and token controllers**: These initialize new namespaces
    with default service accounts and corresponding API access tokens.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务账户和令牌控制器：使用默认服务账户和相应的API访问令牌初始化新的命名空间。
- en: The data plane
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据平面
- en: 'The data plane is the collection of the nodes in the cluster that run your
    containerized workloads as pods. The data plane and control plane can share physical
    or virtual machines. This happens, of course, when you run a single node cluster,
    such as Minikube. But, typically, in a production-ready deployment, the data plane
    will have its own nodes. There are several components that Kubernetes installs
    on each node in order to communicate, watch, and schedule pods: kubelet, kube-proxy,
    and the container runtime (for example, the Docker daemon).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 数据平面是集群中运行容器化工作负载的节点的集合。数据平面和控制平面可以共享物理或虚拟机。当你运行单节点集群（比如Minikube）时，当然会发生这种情况。但是，通常在一个生产就绪的部署中，数据平面会有自己的节点。Kubernetes在每个节点上安装了几个组件，以便通信、监视和调度pod：kubelet、kube代理和容器运行时（例如Docker守护程序）。
- en: The kubelet
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kubelet
- en: 'The **kubelet** is a Kubernetes agent. It''s responsible for talking to the
    API server and for running and managing the pods on the node. Here are some of
    the responsibilities of the kubelet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: kubelet是一个Kubernetes代理。它负责与API服务器通信，并在节点上运行和管理pod。以下是kubelet的一些职责：
- en: Downloading pod secrets from the API server
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从API服务器下载pod的秘密
- en: Mounting volumes
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载卷
- en: Running the pod container via the **Container Runtime Interface** (**CRI**)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过容器运行时接口（CRI）运行pod容器
- en: Reporting the status of the node and each pod
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告节点和每个pod的状态
- en: Probe container liveness
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探测容器的存活状态
- en: The kube proxy
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kube代理
- en: The kube proxy is responsible for the networking aspects of the node. It operates
    as a local front for services and can forward TCP and UDP packets. It discovers
    the IP addresses of services via DNS or environment variables.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: kube代理负责节点的网络方面。它作为服务的本地前端运行，并且可以转发TCP和UDP数据包。它通过DNS或环境变量发现服务的IP地址。
- en: The container runtime
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器运行时
- en: Kubernetes eventually runs containers, even if they are organized in pods. Kubernetes
    supports different container runtimes. Originally, only Docker was supported.
    Now, Kubernetes runs containers through an interface called **CRI**, which is
    based on **gRPC**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes最终运行容器，即使它们是组织在pod中的。Kubernetes支持不同的容器运行时。最初，只支持Docker。现在，Kubernetes通过基于gRPC的**CRI**接口运行容器。
- en: '![](assets/b7e399a7-6d2c-4e1b-b8d3-6393bb8136c0.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b7e399a7-6d2c-4e1b-b8d3-6393bb8136c0.png)'
- en: Each container runtime that implements CRI can be used on a node controlled
    by the **kubelet**, as shown in the preceding diagram.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实现CRI的容器运行时都可以在由**kubelet**控制的节点上使用，如前图所示。
- en: Kubectl
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubectl
- en: '**Kubectl** is a tool you should get very comfortable with. It is your **command-line
    interface** (**CLI**) to your Kubernetes cluster. We will use kubectl extensively
    throughout the book to manage and operate Kubernetes. Here is a short list of
    the capabilities kubectl puts literally at your fingertips:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubectl**是一个你应该非常熟悉的工具。它是你的Kubernetes集群的**命令行接口**（**CLI**）。我们将在整本书中广泛使用kubectl来管理和操作Kubernetes。以下是kubectl在您的指尖上提供的功能的简短列表：'
- en: Cluster management
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群管理
- en: Deployment
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署
- en: Troubleshooting and debugging
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除和调试
- en: Resource management (Kubernetes objects)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源管理（Kubernetes对象）
- en: Configuration and metadata
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和元数据
- en: Just type `kubectl` to get a complete list of all the commands and `kubectl
    <command> --help` for more detailed info on specific commands.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 只需键入`kubectl`即可获得所有命令的完整列表，`kubectl <command> --help`以获取有关特定命令的更详细信息。
- en: Kubernetes and microservices – a perfect match
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes和微服务-完美匹配
- en: Kubernetes is a fantastic platform with amazing capabilities and a wonderful
    ecosystem. How does it help you with your system? As you'll see, there is a very
    good alignment between Kubernetes and microservices. The building blocks of Kubernetes,
    such as namespaces, pods, deployments, and services, map directly to important
    microservices concepts and an agile **software development life cycle** (**SDLC**).
    Let's dive in.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是一个具有惊人能力和美妙生态系统的平台。它如何帮助您的系统？正如您将看到的，Kubernetes和微服务之间有非常好的对齐。Kubernetes的构建块，如命名空间、pod、部署和服务，直接映射到重要的微服务概念和敏捷**软件开发生命周期**（**SDLC**）。让我们深入研究。
- en: Packaging and deploying microservices
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包和部署微服务
- en: When you employ a microservice-based architecture, you'll have lots of microservices.
    Those microservices, in general, may be developed independently, and deployed
    independently. The packaging mechanism is simply containers. Every microservice
    you develop will have a Dockerfile. The resulting image represents the deployment
    unit for that microservice. In Kubernetes, your microservice image will run inside
    a pod (possibly alongside other containers). But an isolated pod, running on a
    node, is not very resilient. The kubelet on the node will restart the pod's container
    if it crashes, but if something happens to the node itself, the pod is gone. Kubernetes
    has abstractions and resources that build on the pod.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用基于微服务的架构时，您将拥有大量的微服务。这些微服务通常可以独立开发和部署。打包机制只是容器。您开发的每个微服务都将有一个Dockerfile。生成的镜像代表该微服务的部署单元。在Kubernetes中，您的微服务镜像将在一个pod中运行（可能与其他容器一起）。但是，运行在节点上的隔离pod并不是非常有弹性。如果pod的容器崩溃，节点上的kubelet将重新启动pod的容器，但是如果节点本身发生了什么事情，pod就消失了。Kubernetes具有构建在pod上的抽象和资源。
- en: '**ReplicaSets** are sets of pods with a certain number of replicas. When you
    create a ReplicaSet, Kubernetes will make sure that the correct number of pods
    you specify always run in the cluster. The deployment resource takes it a step
    further and provides an abstraction that exactly aligns with the way you consider
    and think about microservices. When you have a new version of a microservice ready,
    you will want to deploy it. Here is a Kubernetes deployment manifest:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**ReplicaSets** 是具有一定数量副本的 pod 集。当你创建一个 ReplicaSet 时，Kubernetes 将确保你指定的正确数量的
    pod 始终在集群中运行。部署资源进一步提供了一个与你考虑和思考微服务方式完全一致的抽象。当你准备好一个微服务的新版本时，你会想要部署它。这是一个 Kubernetes
    部署清单：'
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The file can be found at [https://github.com/the-gigi/hands-on-microservices-with-kubernetes-code/blob/master/ch1/nginx-deployment.yaml.](https://github.com/the-gigi/hands-on-microservices-with-kubernetes-code/blob/master/ch1/nginx-deployment.yaml)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件可以在 [https://github.com/the-gigi/hands-on-microservices-with-kubernetes-code/blob/master/ch1/nginx-deployment.yaml.](https://github.com/the-gigi/hands-on-microservices-with-kubernetes-code/blob/master/ch1/nginx-deployment.yaml)
    找到
- en: 'This is a YAML file ([https://yaml.org/](https://yaml.org/)) that has some
    fields that are common to all Kubernetes resources, and some fields that are specific
    to deployments. Let''s break this down piece by piece. Almost everything you learn
    here will apply to other resources:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 YAML 文件（[https://yaml.org/](https://yaml.org/)），其中包含一些对所有 Kubernetes 资源通用的字段，以及一些特定于部署的字段。让我们一一分解。你在这里学到的几乎所有内容都适用于其他资源：
- en: 'The `apiVersion` field marks the Kubernetes resources version. A specific version
    of the Kubernetes API server (for example, V1.13.0) can work with different versions
    of different resources. Resource versions have two parts: an API group (in this
    case, `apps`) and a version number (`v1`). The version number may include **alpha**
    or **beta** designations:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiVersion` 字段标记了 Kubernetes 资源的版本。Kubernetes API 服务器的特定版本（例如 V1.13.0）可以与不同资源的不同版本一起工作。资源版本有两个部分：API
    组（在本例中为 `apps`）和版本号（`v1`）。版本号可能包括 **alpha** 或 **beta** 标识：'
- en: '[PRE1]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `kind` field specifies what resource or API object we are dealing with.
    You will meet many kinds of resources in this chapter and later:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind` 字段指定了我们正在处理的资源或 API 对象是什么。在本章和以后，你将遇到许多种类的资源：'
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `metadata` section contains the name of the resource (`nginx`) and a set
    of labels, which are just key-value string pairs. The name is used to refer to
    this particular resource. The labels allow for operating on a set of resources
    that share the same label. Labels are very useful and flexible. In this case,
    there is just one label (`app: nginx`):'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata` 部分包含了资源的名称（`nginx`）和一组标签，这些标签只是键值对字符串。名称用于指代特定的资源。标签允许对共享相同标签的一组资源进行操作。标签非常有用和灵活。在这种情况下，只有一个标签（`app:
    nginx`）：'
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we have a `spec` field. This is a ReplicaSet `spec`. You could create
    a ReplicaSet directly, but it would be static. The whole purpose of deployments
    is to manage its set of replicas. What''s in a ReplicaSet spec? Obviously, it
    contains the number of `replicas` (`3`). It has a selector with a set of `matchLabels`
    (also `app: nginx`), and it has a pod template. The ReplicaSet will manage pods
    that have labels that match `matchLabels`:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '接下来，我们有一个 `spec` 字段。这是一个 ReplicaSet `spec`。你可以直接创建一个 ReplicaSet，但它将是静态的。部署的整个目的是管理其副本集。ReplicaSet
    `spec` 中包含什么？显然，它包含了 `replicas` 的数量（`3`）。它有一个带有一组 `matchLabels`（也是 `app: nginx`）的选择器，并且有一个
    pod 模板。ReplicaSet 将管理具有与 `matchLabels` 匹配的标签的 pod：'
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s have a look at the pod template. The template has two parts: `metadata`
    and a `spec`. The `metadata` is where you specify the labels. The `spec` describes
    the `containers` in the pod. There may be one or more containers in a pod. In
    this case, there is just one container. The key field for a container is the image
    (often a Docker image), where you packaged your microservice. That''s the code
    we want to run. There is also a name (`nginx`) and a set of ports:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们看一下pod模板。模板有两个部分：`metadata`和`spec`。`metadata`是您指定标签的地方。`spec`描述了pod中的`containers`。一个pod中可能有一个或多个容器。在这种情况下，只有一个容器。容器的关键字段是镜像（通常是Docker镜像），其中打包了您的微服务。这是我们想要运行的代码。还有一个名称（`nginx`）和一组端口：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are more fields that are optional. If you want to dive in deeper, check
    out the API reference for the deployment resource at [https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#deployment-v1-apps](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#deployment-v1-apps).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多可选字段。如果您想深入了解，请查看部署资源的API参考[https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#deployment-v1-apps](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#deployment-v1-apps)。
- en: Exposing and discovering microservices
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露和发现微服务
- en: 'We deployed our microservice with a deployment. Now, we need to expose it,
    so that it can be used by other services in the cluster and possibly also make
    it visible outside the cluster. Kubernetes provides the `Service` resource for
    that purpose. Kubernetes services are backed up by pods, identified by labels:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用部署部署了我们的微服务。现在，我们需要暴露它，以便其他集群中的服务可以使用它，并且可能还可以使其在集群外可见。Kubernetes提供了`Service`资源来实现这一目的。Kubernetes服务由标签标识的pod支持：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Services discover each other inside the cluster, using DNS or environment variables.
    This is the default behavior. But, if you want to make a service accessible to
    the world, you will normally set an ingress object or a load balancer. We will
    explore this topic in detail later.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 服务在集群内部使用DNS或环境变量相互发现。这是默认行为。但是，如果您想使服务对外部可访问，通常会设置一个入口对象或负载均衡器。我们将在以后详细探讨这个主题。
- en: Securing microservices
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护微服务
- en: Kubernetes was designed for running large-scale critical systems, where security
    is of paramount concern. Microservices are often more challenging to secure than
    monolithic systems because there is so much internal communication across many
    boundaries. Also, microservices encourage agile development, which leads to a
    constantly changing system. There is no steady state you can secure once and be
    done with it. You must constantly adapt the security of the system to the changes.
    Kubernetes comes pre-packed with several concepts and mechanisms for secure development,
    deployment, and operation of your microservices. You still need to employ best
    practices, such as principle of least privilege, security in depth, and minimizing
    blast radius. Here are some of the security features of Kubernetes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是为运行大规模关键系统而设计的，安全性是至关重要的。微服务通常比单片系统更具挑战性，因为在许多边界上存在大量内部通信。此外，微服务鼓励敏捷开发，这导致系统不断变化。没有稳定的状态可以一次性确保安全。您必须不断调整系统的安全性以适应变化。Kubernetes预先配备了几个概念和机制，用于安全开发、部署和运行您的微服务。您仍然需要采用最佳实践，例如最小权限原则、深度安全和最小化影响范围。以下是Kubernetes的一些安全功能。
- en: Namespaces
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: Namespaces let you isolate different parts of your cluster from each other.
    You can create as many namespaces as you want and scope many resources and operations
    to their namespace, including limits, and quotas. Pods running in a namespace
    can only access directly their own namespace. To access other namespaces, they
    must go through public APIs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间可以让您将集群的不同部分相互隔离。您可以创建任意数量的命名空间，并将许多资源和操作范围限定在其命名空间内，包括限制和配额。在命名空间中运行的pod只能直接访问其自己的命名空间。要访问其他命名空间，它们必须通过公共API进行。
- en: Service accounts
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务账户
- en: 'Service accounts provide identity to your microservices. Each service account
    will have certain privileges and access rights associated with its account. Service
    accounts are pretty simple:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户为您的微服务提供身份。每个服务账户都将具有与其账户关联的特定特权和访问权限。服务账户非常简单：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can associate service accounts with a pod (for example, in the pod `spec`
    of a deployment) and the microservices that run inside the pod will have that
    identity and all the privileges and restrictions associated with that account.
    If you don't assign a service account, then the pod will get the default service
    account of its namespace. Each service account is associated with a secret used
    to authenticate it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将服务账户与pod关联（例如，在部署的pod `spec`中），并且在pod内部运行的微服务将具有该身份以及与该账户关联的所有特权和限制。如果不分配服务账户，则pod将获得其命名空间的默认服务账户。每个服务账户都与用于对其进行身份验证的秘密相关联。
- en: Secrets
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 秘密
- en: 'Kubernetes provides secret management capabilities to all microservices. The
    secrets can be encrypted at rest on etcd (since Kubernetes 1.7), and are always
    encrypted on the wire (over HTTPS). Secrets are managed per namespace. Secrets
    are mounted in pods as either files (secret volumes) or environment variables.
    There are multiple ways to create secrets. Secrets can contain two maps: `data`
    and `stringData`. The type of values in the data map can be arbitrary, but must
    be base64-encoded. Refer to the following, for example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes为所有微服务提供了秘密管理功能。秘密可以在etcd上（自Kubernetes 1.7起）加密存储，并且始终在传输过程中进行加密（通过HTTPS）。秘密是按命名空间管理的。秘密在pod中作为文件（秘密卷）或环境变量挂载。有多种方法可以创建秘密。秘密可以包含两个映射：`data`和`stringData`。数据映射中的值的类型可以是任意的，但必须是base64编码的。例如，请参考以下内容：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is how a pod can load secrets as a volume:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是pod如何将秘密加载为卷：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The end result is that the DB credentials secrets that are managed outside the
    pod by Kubernetes show up as a regular file inside the pod accessible through
    the path `/etc/db_creds`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，由Kubernetes在pod外部管理的DB凭据秘密显示为pod内部的常规文件，可通过路径`/etc/db_creds`访问。
- en: Secure communication
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全通信
- en: Kubernetes utilizes client-side certificates to fully authenticate both sides
    of any external communication (for example, kubectl). All communication to the
    Kubernetes API from outside should be over HTTP. Internal cluster communication
    between the API server and the kubelet on the node is over HTTPS too (the kubelet
    endpoint). But, it doesn't use a client certificate by default (you can enable
    it).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes利用客户端证书来完全验证任何外部通信的双方身份（例如kubectl）。所有从外部到Kubernetes API的通信都应该是通过HTTP进行的。API服务器与节点上的kubelet之间的内部集群通信也是通过HTTPS进行的（kubelet端点）。但是，默认情况下不使用客户端证书（您可以启用它）。
- en: Communication between the API server and nodes, pods, and services is, by default,
    over HTTP and is not authenticated. You can upgrade them to HTTPS, but note that
    the client certificate is checked, so don't run your worker nodes on public networks.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: API服务器与节点、pod和服务之间的通信默认情况下是通过HTTP进行的，并且没有经过身份验证。您可以将它们升级为HTTPS，但请注意客户端证书会被检查，因此不要在公共网络上运行工作节点。
- en: Network policies
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络策略
- en: In a distributed system, beyond securing each container, pod, and node, it is
    critical to also control communication over the network. Kubernetes supports network
    policies, which give you full flexibility to define and shape the traffic and
    access across the cluster.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，除了保护每个容器、pod和节点之外，还至关重要的是控制网络上的通信。Kubernetes支持网络策略，这使您可以完全灵活地定义和塑造整个集群中的流量和访问。
- en: Authenticating and authorizing microservices
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对微服务进行身份验证和授权
- en: Authentication and authorization are also related to security, by limiting access
    to trusted users and to limited aspects of Kubernetes. Organizations have a variety
    of ways to authenticate their users. Kubernetes supports many of the common authentication
    schemes, such as X.509 certificates, and HTTP basic authentication (not very secure),
    as well as an external authentication server via webhook that gives you ultimate
    control over the authentication process. The authentication process just matches
    the credentials of a request with an identity (either the original or an impersonated
    user). What that user is allowed to do is controlled by the authorization process.
    Enter RBAC.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证和授权也与安全性相关，通过限制对受信任用户和Kubernetes的有限方面的访问来实现。组织有多种方法来对其用户进行身份验证。Kubernetes支持许多常见的身份验证方案，例如X.509证书和HTTP基本身份验证（不太安全），以及通过webhook的外部身份验证服务器，这样可以对身份验证过程进行最终控制。身份验证过程只是将请求的凭据与身份（原始用户或冒充用户）进行匹配。授权过程控制着用户被允许做什么。进入RBAC。
- en: Role-based access control
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于角色的访问控制
- en: '**Role-based access control** (**RBAC**) is not required! You can perform authorization
    using other mechanisms in Kubernetes. However, it is a best practice. RBAC is
    based on two concepts: role and binding. A role is a set of permissions on resources
    defined as rules. There are two types of roles: `Role`, which applies to a single
    namespace, and `ClusterRole`, which applies to all namespaces in a cluster.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于角色的访问控制**（**RBAC**）并非必需！您可以使用Kubernetes中的其他机制执行授权。但这是最佳实践。RBAC基于两个概念：角色和绑定。角色是对资源的权限集，定义为规则。有两种类型的角色：`Role`，适用于单个命名空间，以及`ClusterRole`，适用于集群中的所有命名空间。'
- en: 'Here is a role in the default namespace that allows the getting, watching,
    and listing of all pods. Each role has three components: API groups, resources,
    and verbs:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认命名空间中的一个角色，允许获取、监视和列出所有的pod。每个角色都有三个组成部分：API组、资源和动词：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Cluster roles are very similar, except there is no namespace field because they
    apply to all namespaces.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 集群角色非常相似，只是没有命名空间字段，因为它们适用于所有命名空间。
- en: A binding is associating a list of subjects (users, user groups, or service
    accounts) with a role. There are two types of binding, `RoleBinding` and `ClusterRoleBinding`,
    which correspond to `Role` and `ClusterRole`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定是将一组主体（用户、用户组或服务帐户）与角色关联起来。有两种类型的绑定，`RoleBinding`和`ClusterRoleBinding`，它们对应于`Role`和`ClusterRole`。
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It's interesting that you can bind a `ClusterRole` to a subject in a single
    namespace. This is convenient for defining roles that should be used in multiple
    namespaces, once as a cluster role, and then binding them to specific subjects
    in specific namespaces.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，您可以将`ClusterRole`绑定到单个命名空间中的主体。这对于定义应在多个命名空间中使用的角色非常方便，一次作为集群角色，然后将它们绑定到特定命名空间中的特定主体。
- en: The cluster role binding is similar, but must bind a cluster role and always
    applies to the whole cluster.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 集群角色绑定类似，但必须绑定集群角色，并始终适用于整个集群。
- en: Note that RBAC is used to grant access to Kubernetes resources. It can regulate
    access to your service endpoints, but you may still need fine-grained authorization
    in your microservices.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，RBAC用于授予对Kubernetes资源的访问权限。它可以调节对您的服务端点的访问权限，但您可能仍然需要微服务中的细粒度授权。
- en: Upgrading microservices
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级微服务
- en: Deploying and securing microservices is just the beginning. As you develop and
    evolve your system, you'll need to upgrade your microservices. There are many
    important considerations regarding how to go about it that we will discuss later
    (versioning, rolling updates, blue-green, and canary). Kubernetes provides direct
    support for many of these concepts out of the box and the ecosystem built on top
    of it to provide many flavors and opinionated solutions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 部署和保护微服务只是开始。随着您的系统的发展和演变，您将需要升级您的微服务。关于如何进行这些操作有许多重要的考虑，我们稍后将讨论（版本控制、滚动更新、蓝绿部署和金丝雀发布）。Kubernetes直接支持许多这些概念，并且在其之上构建的生态系统提供了许多不同的风格和有见解的解决方案。
- en: The goal is often zero downtime and safe rollback if a problem occurs. Kubernetes
    deployments provide the primitives, such as updating a deployment, pausing a roll-out,
    and rolling back a deployment. Specific workflows are built on these solid foundations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 目标通常是零停机时间和安全回滚，如果出现问题。Kubernetes部署提供了原语，例如更新部署、暂停部署和回滚部署。具体的工作流程是建立在这些坚实的基础之上的。
- en: 'The mechanics of upgrading a service typically involve upgrading its image
    to a new version and sometimes changes to its support resources and access: volumes,
    roles, quotas, limits, and so on.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 升级服务的机制通常涉及将其镜像升级到新版本，有时还需要对其支持资源和访问进行更改：卷、角色、配额、限制等。
- en: Scaling microservices
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的扩展
- en: There are two aspects to scaling a microservice with Kubernetes. The first aspect
    is scaling the number of pods backing up a particular microservice. The second
    aspect is the total capacity of the cluster. You can easily scale a microservice
    explicitly by updating the number of replicas of a deployment, but that requires
    constant vigilance on your part. For services that have large variations in the
    volume of requests they handle over long periods (for example, business hours
    versus off hours or week days versus weekends), it might take a lot of effort.
    Kubernetes provides horizontal pod autoscaling, which is based on CPU, memory,
    or custom metrics, and can scale your service up and down automatically.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes扩展微服务有两个方面。第一个方面是扩展支持特定微服务的pod数量。第二个方面是集群的总容量。您可以通过更新部署的副本数量来显式地扩展微服务，但这需要您不断保持警惕。对于长时间内处理请求量有很大变化的服务（例如，工作时间与非工作时间或工作日与周末），这可能需要大量的工作。Kubernetes提供了基于CPU、内存或自定义指标的水平pod自动扩展，可以自动地扩展您的服务。
- en: 'Here is how to scale our `nginx` deployment that is currently fixed at three
    replicas to go between `2` and `5`, depending on the average CPU usage across
    all instances:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何扩展我们当前固定为三个副本的`nginx`部署，使其在所有实例的平均CPU使用率之间在`2`和`5`之间变化：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The outcome is that Kubernetes will watch CPU utilization of the pods that belong
    to the `nginx` deployment. When the average CPU over a certain period of time
    (5 minutes, by default) exceeds 90%, it will add more replicas until the maximum
    of 5, or until utilization drops below 90%. The HPA can scale down too, but will
    always maintain a minimum of two replicas, even if the CPU utilization is zero.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是Kubernetes将监视属于`nginx`部署的pod的CPU利用率。当一段时间内（默认为5分钟）的平均CPU超过90%时，它将添加更多副本，直到最多为5个，或者直到利用率低于90%。HPA也可以缩小规模，但即使CPU利用率为零，它也将始终保持至少两个副本。
- en: Monitoring microservices
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控微服务
- en: Your microservices are deployed and running on Kubernetes. You can update the
    version of your microservices whenever it is needed. Kubernetes takes care of
    healing and scaling automatically. However, you still need to monitor your system
    and keep track of errors and performance. This is important for addressing problems,
    but also for informing you on potential improvements, optimizations, and cost
    cutting.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你的微服务部署并在Kubernetes上运行。你可以在需要时更新微服务的版本。Kubernetes会自动处理修复和扩展。然而，你仍然需要监视你的系统并跟踪错误和性能。这对于解决问题很重要，但也对于通知你潜在的改进、优化和成本削减很重要。
- en: 'There are several categories of information that are relevant and that you
    should monitor:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有几类相关信息是重要的，你应该监控：
- en: Third-party logs
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方日志
- en: Application logs
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序日志
- en: Application errors
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序错误
- en: Kubernetes events
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes事件
- en: Metrics
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指标
- en: When considering a system composed of multiple microservices and multiple supporting
    components, the number of logs will be substantial. The solution is central logging,
    where all the logs go to a single place where you can slice and dice at your will.
    Errors can be logged, of course, but often it is useful to report errors with
    additional metadata, such as stack trace, and review them in their own dedicated
    environment (for example, sentry or rollbar). Metrics are useful for detecting
    performance and system health problems or trends over time.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑由多个微服务和多个支持组件组成的系统时，日志的数量将是可观的。解决方案是中央日志记录，所有日志都会发送到一个地方，你可以随意切割和分析。当然可以记录错误，但通常有用的是报告带有额外元数据的错误，比如堆栈跟踪，并在专用环境中审查它们（例如sentry或rollbar）。指标对于检测性能和系统健康问题或随时间变化的趋势是有用的。
- en: Kubernetes provides several mechanisms and abstractions for monitoring your
    microservices. The ecosystem provides a number of useful projects too.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了几种机制和抽象来监视你的微服务。该生态系统还提供了许多有用的项目。
- en: Logging
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: 'There are several ways to implement central logging with Kubernetes:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种实现与Kubernetes的中央日志记录的方法：
- en: Have a logging agent that runs on every node
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个节点上运行一个日志代理
- en: Inject a logging sidecar container to every application pod
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向每个应用程序pod注入一个日志边车容器
- en: Have your application send its logs directly to a central logging service
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的应用程序直接发送日志到中央日志服务
- en: There are pros and cons to each approach. But, the main thing is that Kubernetes
    supports all approaches and makes container and pod logs available for consumption.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都有其利弊。但是，主要的是Kubernetes支持所有方法，并使容器和pod日志可供使用。
- en: Refer to [https://kubernetes.io/docs/concepts/cluster-administration/logging/#cluster-level-logging-architectures](https://kubernetes.io/docs/concepts/cluster-administration/logging/#cluster-level-logging-architectures)
    for an in-depth discussion.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[https://kubernetes.io/docs/concepts/cluster-administration/logging/#cluster-level-logging-architectures](https://kubernetes.io/docs/concepts/cluster-administration/logging/#cluster-level-logging-architectures)进行深入讨论。
- en: Metrics
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指标
- en: Kubernetes comes with cAdvisor ([https://github.com/google/cadvisor](https://github.com/google/cadvisor)),
    which is a tool for collecting container metrics integrated into the kubelet binary.
    Kubernetes used to provide a metrics server called **heapster** that required
    additional backends and a UI. But, these days, the best in class metrics server
    is the open source Prometheus project. If you run Kubernetes on Google's GKE,
    then Google Cloud Monitoring is a great option that doesn't require additional
    components to be installed in your cluster. Other cloud providers also have integration
    with their monitoring solutions (for example, CloudWatch on EKS).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes附带了cAdvisor（[https://github.com/google/cadvisor](https://github.com/google/cadvisor)），这是一个用于收集容器指标的工具，集成到kubelet二进制文件中。Kubernetes以前提供了一个名为**heapster**的度量服务器，需要额外的后端和UI。但是，如今，最佳的度量服务器是开源项目Prometheus。如果你在Google的GKE上运行Kubernetes，那么Google
    Cloud Monitoring是一个不需要在你的集群中安装额外组件的好选择。其他云提供商也与他们的监控解决方案集成（例如，EKS上的CloudWatch）。
- en: Creating a local cluster
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建本地集群
- en: One of the strengths of Kubernetes as a deployment platform is that you can
    create a local cluster and, with relatively little effort, have a realistic environment
    that is very close to your production environment. The main benefit is that developers
    can test their microservices locally and collaborate with the rest of the services
    in the cluster. When your system is comprised of many microservices, the more
    significant tests are often integration tests and even configuration and infrastructure
    tests, as opposed to unit tests. Kubernetes makes that kind of testing much easier
    and requires much less brittle mocking.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes作为部署平台的一个优势是，你可以创建一个本地集群，并且只需相对较少的努力，就可以拥有一个非常接近生产环境的真实环境。主要好处是开发人员可以在本地测试他们的微服务，并与集群中的其他服务进行协作。当你的系统由许多微服务组成时，更重要的测试通常是集成测试，甚至是配置和基础设施测试，而不是单元测试。Kubernetes使这种测试变得更容易，需要更少脆弱的模拟。
- en: In this section, you will install a local Kubernetes cluster and some additional
    projects, and then have some fun exploring it using the invaluable kubectl command-line
    tool.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将安装一个本地Kubernetes集群和一些额外的项目，然后使用宝贵的kubectl命令行工具来探索它。
- en: Installing Minikube
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Minikube
- en: 'Minikube is a single node Kubernetes cluster that you can install anywhere.
    I used macOS here, but, in the past, I used it successfully on Windows too. Before
    installing Minikube itself, you must install a hypervisor. I prefer HyperKit:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube是一个可以在任何地方安装的单节点Kubernetes集群。我在这里使用的是macOS，但过去我也成功地在Windows上使用过。在安装Minikube本身之前，你必须安装一个hypervisor。我更喜欢HyperKit：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'But, I''ve run into trouble with HyperKit from time to time. If you can''t
    overcome the issues, I suggest using VirtualBox as the hypervisor instead. Run
    the following command to install VirtualBox via Homebrew:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我偶尔会遇到HyperKit的问题。如果你无法解决这些问题，我建议使用VirtualBox作为hypervisor。运行以下命令通过Homebrew安装VirtualBox：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, you can install Minikube itself. Homebrew is the best way to go again:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以安装Minikube本身。再次使用Homebrew是最好的方法：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you''re not on macOS, follow the official instructions here: [https://kubernetes.io/docs/tasks/tools/install-minikube/](https://kubernetes.io/docs/tasks/tools/install-minikube/).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是在macOS上，请按照官方说明进行操作：[https://kubernetes.io/docs/tasks/tools/install-minikube/](https://kubernetes.io/docs/tasks/tools/install-minikube/)。
- en: You must turn off any VPN before starting Minikube with HyperKit. You can restart
    your VPN after Minikube has started.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用HyperKit启动Minikube之前，你必须关闭任何VPN。在Minikube启动后，你可以重新启动VPN。
- en: 'Minikube supports multiple versions of Kubernetes. At the moment, the default
    version is 1.10.0, but 1.13.0 is already out and supported, so let''s use that
    version:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube支持多个版本的Kubernetes。目前，默认版本是1.10.0，但1.13.0已经发布并得到支持，所以让我们使用这个版本：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you''re using VirtualBox as your hypervisor, you don''t need to specify `--vm-driver`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用VirtualBox作为您的hypervisor，您不需要指定`--vm-driver`：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下内容：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Minikube will automatically download the Minikube VM (178.88 MB) if it's the
    first time you are starting your Minikube cluster.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是您第一次启动Minikube集群，Minikube将自动下载Minikube VM（178.88 MB）。
- en: At this point, your Minikube cluster is ready to go.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的Minikube集群已准备就绪。
- en: Troubleshooting Minikube
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Minikube故障排除
- en: 'If you run into some trouble (for example, if you forgot to turn off your VPN),
    try to delete your Minikube installation and restart it with verbose logging:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到问题（例如，如果您忘记关闭VPN），请尝试删除Minikube安装并使用详细日志重新启动：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If your Minikube installation just hangs (maybe waiting for SSH), you might
    have to reboot to unstick it. If that doesn''t help, try the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Minikube安装卡住了（可能在等待SSH），您可能需要重新启动以解除卡住。如果这样做没有帮助，请尝试以下操作：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Then, reboot again.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次重启。
- en: Verifying your cluster
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证您的集群
- en: 'If everything is OK, you can check your Minikube version:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，您可以检查您的Minikube版本：
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Minikube has many other useful commands. Just type `minikube` to see the list
    of commands and flags.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube还有许多其他有用的命令。只需输入`minikube`即可查看命令和标志列表。
- en: Playing with your cluster
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转您的集群
- en: 'Minikube is running, so let''s have some fun. Your kubectl is going to serve
    you well in this section. Let''s start by examining our node:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube正在运行，所以让我们玩得开心。在本节中，您的kubectl将为您提供良好的服务。让我们从检查我们的节点开始：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Your cluster already has some pods and services running. It turns out that
    Kubernetes is dogfooding and many of its own services are plain services and pods.
    But, those pods and services run in namespaces. Here are all the namespaces:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您的集群已经有一些正在运行的pod和服务。原来Kubernetes正在使用自己的服务和pod。但是，这些pod和服务在命名空间中运行。以下是所有的命名空间：
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To see all the services in all the namespaces, you can use the `--all-namespaces`
    flag:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有命名空间中的所有服务，可以使用`--all-namespaces`标志：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The Kubernetes API server, itself, is running as a service in the default namespace
    and then we have `kube-dns` and the `kubernetes-dashboard` running in the `kube-system`
    namespace.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API服务器本身作为默认命名空间中的服务运行，然后我们有`kube-dns`和`kubernetes-dashboard`在`kube-system`命名空间中运行。
- en: 'To explore the dashboard, you can run the dedicated Minikube command, `minikube
    dashboard`. You can also use `kubectl`, which is more universal and will work
    on any Kubernetes cluster:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索仪表板，您可以运行专用的Minikube命令`minikube dashboard`。您还可以使用`kubectl`，它更通用，可以在任何Kubernetes集群上运行：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, browse to `http://localhost:9090` and you will see the following dashboard:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，浏览`http://localhost:9090`，您将看到以下仪表板：
- en: '![](assets/48590ed9-0382-4c6e-8f48-180a7b2403e5.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/48590ed9-0382-4c6e-8f48-180a7b2403e5.png)'
- en: Installing Helm
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Helm
- en: 'Helm is the Kubernetes package manager. It doesn''t come with Kubernetes, so
    you have to install it. Helm has two components: a server-side component called
    `tiller`, and a CLI called `helm`.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Helm是Kubernetes包管理器。它不随Kubernetes一起提供，因此您必须安装它。Helm有两个组件：一个名为`tiller`的服务器端组件，以及一个名为`helm`的CLI。
- en: 'Let''s install `helm` locally first, using Homebrew:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用Homebrew在本地安装`helm`：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, properly initialize both the server and client type:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，正确初始化服务器和客户端类型：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With Helm in place, you can easily install all kinds of goodies in your Kubernetes
    cluster. There are currently `275` chars (the Helm term for a package) in the
    stable chart repository:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有了Helm，您可以轻松在Kubernetes集群中安装各种好东西。目前在稳定的图表存储库中有`275`个字符（Helm术语表示一个包）：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For example, check out all the releases tagged with the `db` type:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，查看所有标记为`db`类型的发布：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will use Helm a lot throughout the book.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中大量使用Helm。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you received a whirlwind tour of Kubernetes and got an idea
    of how well it aligns with microservices. The extensible architecture of Kubernetes
    empowers a large community of enterprise organizations, startup companies, and
    open source organizations to collaborate and create an ecosystem around Kubernetes
    that multiplies its benefits and ensures its staying power. The concepts and abstractions
    built into Kubernetes are very well suited for microservice-based systems. They
    support every phase of the SDLC, from development, through testing, and deployments,
    and all the way to monitoring and troubleshooting. The Minikube project lets every
    developer run a local Kubernetes cluster, which is great for experimenting with
    Kubernetes itself, as well as testing locally in an environment that is very similar
    to the production environment. The Helm project is a fantastic addition to Kubernetes
    and provides great value as the de facto package management solution. In the next
    chapter, we will dive into the world of microservices and learn why they are the
    best approach for developing complex and fast-moving distributed systems that
    run in the cloud.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您对Kubernetes进行了一个快速的介绍，并了解了它与微服务的契合程度。Kubernetes的可扩展架构赋予了大型企业组织、初创公司和开源组织一个强大的社区，使它们能够合作并围绕Kubernetes创建生态系统，从而增加其益处并确保其持久性。Kubernetes内置的概念和抽象非常适合基于微服务的系统。它们支持软件开发生命周期的每个阶段，从开发、测试、部署，一直到监控和故障排除。Minikube项目让每个开发人员都可以运行一个本地的Kubernetes集群，这对于在类似于生产环境的本地环境中进行Kubernetes实验和测试非常有用。Helm项目是Kubernetes的一个很棒的补充，作为事实上的软件包管理解决方案提供了巨大的价值。在下一章中，我们将深入了解微服务的世界，并了解它们为何是开发复杂且快速移动的分布式系统的最佳方法。
- en: Further reading
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: If you want to learn more about Kubernetes, I recommend my book, *Mastering
    Kubernetes – Second Edition*, published by Packt: [https://www.packtpub.com/application-development/mastering-kubernetes-second-edition](https://www.packtpub.com/application-development/mastering-kubernetes-second-edition)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于Kubernetes的信息，我推荐我的书《精通Kubernetes-第二版》，由Packt出版：[https://www.packtpub.com/application-development/mastering-kubernetes-second-edition](https://www.packtpub.com/application-development/mastering-kubernetes-second-edition)
