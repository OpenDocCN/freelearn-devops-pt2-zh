- en: Delinkcious - the Sample Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Delinkcious - 示例应用程序
- en: Delinkcious is a Delicious ([https://en.wikipedia.org/wiki/Delicious_(website)](https://en.wikipedia.org/wiki/Delicious_(website))) wannabe.
    Delicious used to be an internet hit that managed links for users. It was acquired
    by Yahoo, was bounced around, and sold multiple times. It was eventually purchased
    by Pinboard, which runs a similar service and intends to shut down Delicious soon.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Delinkcious是Delicious（[https://en.wikipedia.org/wiki/Delicious_(website)](https://en.wikipedia.org/wiki/Delicious_(website)）的模仿者。Delicious曾经是一个管理用户链接的互联网热门网站。它被雅虎收购，然后被转手多次。最终被Pinboard收购，后者运行类似的服务，并打算很快关闭Delicious。
- en: Delinkcious allows users store URLs in cool places on the web, tag them, and
    query them in various ways. Throughout this book, Delinkcious will serve as a
    live lab to demonstrate many microservices and Kubernetes concepts, as well as
    features in the context of a real-world application. The focus will be on the
    backend, so there will be no snazzy frontend web application or mobile app. I'll
    leave those as the dreaded exercise for you.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Delinkcious允许用户将URL存储在网络上的酷炫位置，对其进行标记，并以各种方式查询它们。在本书中，Delinkcious将作为一个实时实验室，演示许多微服务和Kubernetes概念，以及在真实应用程序环境中的功能。重点将放在后端，因此不会有时髦的前端Web应用程序或移动应用程序。我会把它们留给你作为可怕的练习。
- en: In this chapter, we will understand why I chose Go as the programming language
    of Delinkcious, and then look at **Go kit** – an excellent Go microservice toolkit
    that I'll use to build Delinkcious. Then, we will dissect the different aspects
    of Delinkcious itself using the social graph service as a running example.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解为什么我选择Go作为Delinkcious的编程语言，然后看看**Go kit** - 一个我将用来构建Delinkcious的优秀的Go微服务工具包。然后，我们将使用社交图服务作为一个运行示例，剖析Delinkcious本身的不同方面。
- en: 'We will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: The Delinkcious microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Delinkcious微服务
- en: The Delinkcious data storage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Delinkcious数据存储
- en: The Delinkcious API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Delinkcious API
- en: The Delinkcious client libraries
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Delinkcious客户端库
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you have followed along with this book so far, you will have already installed
    Go. I recommend installing a good Go IDE to follow the code in this chapter since
    there will be a lot to go through. Let's go through a couple of good options.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您迄今为止已经跟着本书走过，那么您已经安装了Go。我建议安装一个好的Go IDE来跟随本章的代码，因为需要大量的学习。让我们看看几个不错的选择。
- en: Visual Studio Code
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: '**Visual Studio Code**, also known as **VS Code** ([https://code.visualstudio.com/docs/languages/go](https://code.visualstudio.com/docs/languages/go)),
    is an open source IDE from Microsoft. It isn''t Go-specific but has deep integration
    with Go via a dedicated and sophisticated Go extension. It is considered the best
    free Go IDE.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**，也称为**VS Code**（[https://code.visualstudio.com/docs/languages/go](https://code.visualstudio.com/docs/languages/go)），是微软的开源IDE。它不是专门针对Go的，但通过专门和复杂的Go扩展，与Go有深度集成。它被认为是最好的免费Go
    IDE。'
- en: GoLand
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GoLand
- en: JetBrains' GoLand ([https://www.jetbrains.com/go/](https://www.jetbrains.com/go/))
    is my personal favorite. It follows the great tradition of IntelliJ IDEA, PyCharm,
    and other great IDEs. This is a paid version with a 30-day free trial. There is
    no Community Edition, unfortunately. If you can afford it, I highly recommend
    it. If you can't or don't want to pay for an IDE (totally reasonable), check out
    the other options.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JetBrains的GoLand（[https://www.jetbrains.com/go/](https://www.jetbrains.com/go/)）是我个人最喜欢的。它遵循了IntelliJ
    IDEA、PyCharm和其他优秀IDE的优良传统。这是一个付费版本，有30天的免费试用期。不幸的是，没有社区版。如果您有能力，我强烈推荐它。如果您不能或不想为IDE付费（完全合理），请查看其他选项。
- en: LiteIDE
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LiteIDE
- en: LiteIDE or LiteIDE X ([https://github.com/visualfc/liteide](https://github.com/visualfc/liteide))
    is a very interesting open source project. It is one of the earliest Go IDEs and
    it predates both GoLand and the Go extension for VS Code. I used it in the early
    days and was surprised by its quality. I eventually dropped it due to difficulties
    with interactive debugging via the **GNU Project Debugger** (**GDB**). It is actively
    developed, has a lot of contributors, and supports all the latest and greatest
    Go features, including Go 1.1 and the Go modules. You can now debug using Delve,
    which is the best of class Go debugger.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: LiteIDE或LiteIDE X ([https://github.com/visualfc/liteide](https://github.com/visualfc/liteide))是一个非常有趣的开源项目。它是最早的Go
    IDE之一，早于GoLand和VS Code的Go扩展。我在早期使用过它，并对其质量感到惊讶。最终我放弃了它，因为使用GNU Project Debugger（GDB）进行交互式调试时遇到了困难。它正在积极开发，有很多贡献者，并支持所有最新和最伟大的Go功能，包括Go
    1.1和Go模块。现在您可以使用Delve进行调试，这是最好的Go调试器。
- en: Other options
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他选项
- en: If you're a die-hard command-line person and don't like IDEs at all, you have
    options available. Most programming and text editors have some form of Go support.
    The Go wiki ([https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins](https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins))
    has a big list of IDEs and text editor plugins, so go and check that out.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是一个死忠的命令行用户，根本不喜欢IDE，您有可用的选项。大多数编程和文本编辑器都有某种形式的Go支持。Go维基（[https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins](https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins)）有一个大列表的IDE和文本编辑器插件，所以去看看吧。
- en: The code
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码
- en: 'In this chapter, there are no code files since you''ll just be getting to know
    the Delinkcious application:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，没有代码文件，因为您只会了解Delinkcious应用程序：
- en: It is hosted in its own GitHub repository, which can be found at: [https://github.com/the-gigi/delinkcious](https://github.com/the-gigi/delinkcious).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它托管在自己的GitHub存储库中，可以在以下位置找到：[https://github.com/the-gigi/delinkcious](https://github.com/the-gigi/delinkcious)。
- en: Check out the **v0.1** Tags | Releases: [https://github.com/the-gigi/delinkcious/releases/tag/v0.1](https://github.com/the-gigi/delinkcious/releases/tag/v0.1).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看**v0.1**标签 | 发布：[https://github.com/the-gigi/delinkcious/releases/tag/v0.1](https://github.com/the-gigi/delinkcious/releases/tag/v0.1)。
- en: Clone it and use your favorite IDE or text editor to follow up.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆它并使用您喜欢的IDE或文本编辑器进行跟进。
- en: Remember that the general code examples for this book are in another GitHub
    repository: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，本书的一般代码示例在另一个GitHub存储库中：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/)。
- en: Choosing Go for Delinkcious
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择Go用于Delinkcious
- en: 'I wrote and shipped production backend code in many fine languages such as
    C/C++, Python, C#, and, of course, Go. I also used a few not-so-fine languages,
    but let''s leave those out of the discussion. I decided to use Go as the programming
    language for Delinkcious because it is a superb language for microservices:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我用许多优秀的语言编写并发布了生产后端代码，如C/C++、Python、C#，当然还有Go。我也使用了一些不那么好的语言，但让我们不讨论这些。我决定使用Go作为Delinkcious的编程语言，因为它是微服务的绝佳语言：
- en: Go compiles to a single binary with no external dependencies (awesome for simple
    Dockerfiles).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go编译为单个二进制文件，没有外部依赖（对于简单的Dockerfile非常棒）。
- en: Go is very readable and easy to learn.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go非常易读和易学。
- en: Go has excellent support for network programming and concurrency.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go对网络编程和并发有很好的支持。
- en: Go is the implementation language of many cloud-native data stores, queues,
    and frameworks (including Docker and Kubernetes).
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go是许多云原生数据存储、队列和框架（包括Docker和Kubernetes）的实现语言。
- en: You may argue that microservices are supposed to be language agnostic and that
    I shouldn't focus on one language. This is true, but my goal is to be very hands-on
    in this book and dive deep into all the fine details of building microservices
    on Kubernetes. To do that, I had to make specific choices and stick to them. Trying
    to get the same level of depth in multiple languages would have been futile. That
    being said, the microservice boundaries are very clear (one of the advantages
    of microservices) and you can see how implementing a microservice in another language
    will present a few issues to the rest of the system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会说微服务应该是语言无关的，我不应该专注于一种语言。这是真的，但我的目标是在这本书中非常实际，并深入研究在Kubernetes上构建微服务的所有细节。为了做到这一点，我不得不做出具体的选择并坚持下去。试图在多种语言中达到相同的深度是徒劳的。也就是说，微服务的边界非常清晰（这是微服务的一个优点），你可以看到在另一种语言中实现微服务将对系统的其余部分造成一些问题。
- en: Getting to know Go kit
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Go kit
- en: 'You can write your microservices from scratch (in Go or any other language)
    and they will interact with each other just fine through their APIs. However,
    in a real-world system, there will be a large number of shared and/or cross-cutting
    concerns that you want to be consistent:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从头开始编写您的微服务（使用Go或任何其他语言），它们将通过它们的API很好地相互交互。然而，在现实世界的系统中，将有大量的共享和/或交叉关注点，您希望它们保持一致：
- en: Configuration
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置
- en: Secret management
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密管理
- en: Central logging
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中央日志记录
- en: Metrics
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指标
- en: Authentication
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: Authorization
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权
- en: Security
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: Distributed tracing
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式跟踪
- en: Service discovery
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现
- en: In practice, microservices in most large production systems will need to comply
    with certain policies for those concerns.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在大多数大型生产系统中，微服务需要遵守特定的政策。
- en: Enter Go kit ([https://gokit.io/](https://gokit.io/)). Go kit takes a very modular
    approach to the microservices space. It provides a high degree of separation of
    concerns, a recommended approach for structuring your microservice, and a lot
    of flexibility. As the website says, *Few opinions, lightly held*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Go kit（[https://gokit.io/](https://gokit.io/)）。Go kit对微服务空间采取了非常模块化的方法。它提供了高度的关注点分离，这是构建微服务的推荐方法，以及很大的灵活性。正如网站所说，*少数意见，轻松持有*。
- en: Structuring microservices with Go kit
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go kit构建微服务
- en: 'Go kit is all about best practices. Your business logic is implemented as pure
    Go libraries that only deal with interfaces and Go structs. All the complex aspects
    involved in APIs, serialization, routing, and networking will be relegated to
    clearly separate layers that are taking advantage of Go kit concepts and infrastructures
    such as transports, endpoints, and services. This makes for a great development
    experience, where you can evolve and test your application code in the simplest
    environment possible. Here is the interface for one of Delinkcious'' services
    – the social graph. Note that it is in plain Go. There is no notion of API, microservice,
    or even Go kit imports:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Go kit关注的是最佳实践。您的业务逻辑是作为纯Go库实现的，它只处理接口和Go结构。所有涉及API、序列化、路由和网络的复杂方面都将被分别放置在明确分离的层中，这些层利用了Go
    kit的概念和基础设施，如传输、端点和服务。这使得开发体验非常好，您可以在最简单的环境中演变和测试应用代码。这是Delinkcious服务之一-社交图的接口。请注意，它是纯Go的。没有API、微服务，甚至没有Go
    kit的导入：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The implementation of this interface resides in a Go package that is still
    completely agnostic of Go kit or even the fact it is being used in a microservice:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口的实现位于一个Go包中，它完全不知道Go kit甚至不知道它被用在微服务中：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A good way to think of a Go kit service is as an onion with different layers.
    At the core is your business logic and layered on top are various concerns such
    as routing, rate limiting, logging, and metrics, which are eventually exposed
    to other services or the world over transports:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将Go kit服务视为一个具有不同层的洋葱是一个很好的思路。核心是您的业务逻辑，上面叠加了各种关注点，如路由、速率限制、日志记录和度量标准，最终通过传输暴露给其他服务或全球：
- en: '![](assets/59dd4e46-c710-425f-a3b3-a15375980cc8.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/59dd4e46-c710-425f-a3b3-a15375980cc8.png)'
- en: Go kit primarily supports RPC-style communication by using a request-response
    model.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Go kit主要通过使用请求-响应模型支持RPC风格的通信。
- en: Understanding transports
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解传输
- en: One of the biggest concerns about microservices is that they interact with each
    other and clients over a network; that is, at least an order of magnitude more
    complicated than calling methods inside the same process. Go kit provides explicit
    support for the networking aspect of microservices through the transport concept.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务最大的问题之一是它们通过网络相互交互和与客户端交互；换句话说，至少比在同一进程内调用方法复杂一个数量级。Go kit通过传输概念明确支持微服务的网络方面。
- en: 'A Go kit transport encapsulates all the complexity and integrates with other
    Go kit constructs such as requests, responses, and endpoints. Go kit officially
    supports the following transports out of the box:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Go kit传输封装了所有复杂性，并与其他Go kit构造集成，如请求、响应和端点。Go kit官方支持以下传输方式：
- en: HTTP
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP
- en: gRPC
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC
- en: Thrift
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thrift
- en: net/rpc
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: net/rpc
- en: However, there are several more transports in its GitHub repository, including
    AMQP and NATS transports for message queuing and pub/sub. One cool thing about
    Go kit transports is that you can expose the same service through multiple transports
    without changing your code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在其GitHub存储库中还有几种传输方式，包括用于消息队列和发布/订阅的AMQP和NATS传输。Go kit传输的一个很酷的功能是，您可以在不更改代码的情况下通过多种传输方式公开相同的服务。
- en: Understanding endpoints
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解端点
- en: A Go kit microservice is really just a set of endpoints. Each endpoint corresponds
    to one method in your service interface. An endpoint is always associated with
    at least one transport and a handler that you implement to service the request.
    The Go kit endpoints support the RPC style of communication and have request and
    response structs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Go kit微服务实际上只是一组端点。每个端点对应于您服务接口中的一个方法。端点始终与至少一个传输和一个处理程序相关联，您实现该处理程序以处理请求。Go
    kit端点支持RPC通信风格，并具有请求和响应结构。
- en: 'Here is the factory function for the `Follow()` method endpoint:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Follow()`方法端点的工厂函数：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I will explain what's going on here soon. For now, just note that it accepts
    an `svc` argument of the `om.SocialGraphManager` type, which is an interface,
    and it invokes its `Follow()` method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我将很快解释这里发生了什么。现在，只需注意它接受`om.SocialGraphManager`类型的`svc`参数，这是一个接口，并调用其`Follow()`方法。
- en: Understanding services
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务
- en: This is where your code plugs into the system. When the endpoint is called,
    it invokes the corresponding method in your service implementation to do all the
    work. All the hard work of encoding and decoding requests and responses is done
    by the endpoint wrapper. You can focus on your application logic using the best
    abstractions that make sense.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的代码插入系统的地方。当调用端点时，它会调用您的服务实现中的相应方法来完成所有工作。端点包装器会完成请求和响应的编码和解码工作。您可以使用最合理的抽象来专注于应用逻辑。
- en: 'Here is the implementation of the `SocialGraphManager` function''s `Follow()`
    method:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`SocialGraphManager`函数的`Follow()`方法的实现：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Understanding middleware
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解中间件
- en: 'Go kit is composable, as demonstrated in the preceding onion diagram. In addition
    to the mandatory transports, endpoints, and services, Go kit uses the decorator
    pattern to optionally wrap services and endpoints with cross-cutting concerns,
    such as the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的洋葱图所示，Go kit是可组合的。除了必需的传输、端点和服务之外，Go kit还使用装饰器模式可选择地包装服务和端点，以处理横切关注点，例如以下内容：
- en: Resiliency (for example, retries with exponential backoff)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性（例如，带有指数回退的重试）
- en: Authentication and authorization
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证和授权
- en: Logging
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录
- en: Metrics collection
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 度量收集
- en: Distributed tracing
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式跟踪
- en: Service discovery
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现
- en: Rate limiting
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制
- en: This approach of a solid core with a small number of abstractions, such as transports,
    endpoints, and services, that can be extended using a uniform mechanism of middleware
    is easy to comprehend and work with. Go kit strikes the right balance between
    providing enough built-in functionality for middleware and leaving the floor open
    to your needs. For example, when running on Kubernetes, service discovery is taken
    care of for you. It's great that you don't have to work around Go kit in this
    case. Features and capabilities that you don't absolutely need are optional.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种以固定核心为基础的方法，使用少量的抽象，如传输、端点和服务，可以通过统一的中间件机制进行扩展，易于理解和使用。Go kit在为中间件提供足够的内置功能和留出空间以满足您的需求之间取得了平衡。例如，在Kubernetes上运行时，服务发现已经为您处理了。很棒的是，在这种情况下你不必绕过Go
    kit。您不绝对需要的功能和能力是可选的。
- en: Understanding clients
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解客户端
- en: In [Chapter 2](d4214218-a4e9-4df8-813c-e00df71da935.xhtml),* Getting Started
    with Microservices*, we discussed the client library principle of microservices.
    A microservice that talks to another microservice ideally utilizes a client library
    that's exposed through an interface. Go kit provides excellent support and guidelines
    for writing such client libraries. The using microservice simply receives an interface.
    It is actually totally agnostic to the fact it is talking to another service.
    For (almost) all intents and purposes, the remote service could be running in
    the same process. This is excellent for testing or for refactoring services and
    breaking a slightly too large service into two separate services.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](d4214218-a4e9-4df8-813c-e00df71da935.xhtml)中，*开始使用微服务*，我们讨论了微服务的客户端库原则。一个微服务与另一个微服务交流时，理想情况下会利用通过接口公开的客户端库。Go
    kit为编写这种客户端库提供了出色的支持和指导。使用微服务只需接收一个接口。它实际上对于它正在与另一个服务交流这一事实是完全不可知的。在（几乎）所有意图和目的上，远程服务可能正在同一个进程中运行。这对于测试或重构服务并将稍微过大的服务拆分为两个独立服务非常有用。
- en: Go kit has client endpoints that are similar to service endpoints but work in
    the opposite direction. Service endpoints decode requests, delegate work to the
    service, and encode responses. Client endpoints encode requests, invoke the remote
    service over the network, and decode the response.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Go kit具有类似于服务端点的客户端端点，但工作方向相反。服务端点解码请求，委托工作给服务，并编码响应。客户端端点编码请求，在网络上调用远程服务，并解码响应。
- en: 'Here is what the `Follow()` method of the client looks like:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是客户端的`Follow()`方法的样子：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Generating the boilerplate
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成样板
- en: The clean separation of concerns and neat architectural layering of Go kit has
    a price. The price is a lot of boring, mind-numbing, and error-prone boilerplate
    code for translating requests and responses between different structs and method
    signatures. It is useful to see and understand how Go kit can support strongly-typed
    interfaces in a generic way, but for large-scale projects, the preferred solution
    is to generate all the boilerplate from the Go interfaces and data types. There
    are several projects for this task, including one under development by Go kit
    itself called **kitgen** ([https://github.com/go-kit/kit/tree/master/cmd/kitgen](https://github.com/go-kit/kit/tree/master/cmd/kitgen)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Go kit的清晰关注点分离和整洁的架构分层是有代价的。代价是大量乏味、令人昏昏欲睡和容易出错的样板代码，用于在不同结构和方法签名之间转换请求和响应。了解Go
    kit如何以通用方式支持强类型接口是有用的，但对于大型项目，首选解决方案是从Go接口和数据类型生成所有样板。有几个项目可以完成这项任务，包括Go kit本身正在开发的一个名为**kitgen**的项目（[https://github.com/go-kit/kit/tree/master/cmd/kitgen](https://github.com/go-kit/kit/tree/master/cmd/kitgen)）。
- en: It is considered experimental at the moment. I'm a big fan of code generation
    and highly recommend it. However, in the following sections, we will look at a
    lot of manual boilerplate code to make it clear what's going on and avoid any
    magic.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 目前它被认为是实验性的。我非常喜欢代码生成，并强烈推荐它。然而，在接下来的章节中，我们将看到大量手动样板代码，以清楚地说明发生了什么，并避免任何魔法。
- en: Introducing the Delinkcious directory structure
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Delinkcious目录结构
- en: 'The Delinkcious system at this stage of initial development consists of three
    services:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始开发阶段，Delinkcious系统由三个服务组成：
- en: Link service
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接服务
- en: User service
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户服务
- en: Social graph service
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社交图服务
- en: 'The high-level directory structure includes the following sub directories:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 高级目录结构包括以下子目录：
- en: '`cmd`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd`'
- en: '`pkg`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pkg`'
- en: '`svc`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`svc`'
- en: 'The `root` directory also includes some common files such as `README.md` and
    the important `go.mod` and `go.sum` files to support the Go modules. I use the
    monorepo approach here, so the entire Delinkcious system will live in this directory
    structure and is considered a single Go module, albeit with many packages:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`root`目录还包括一些常见文件，如`README.md`和重要的`go.mod`和`go.sum`文件，以支持Go模块。我在这里使用monorepo方法，因此整个Delinkcious系统将驻留在这个目录结构中，并被视为单个Go模块，尽管有许多包：'
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The cmd subdirectory
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cmd子目录
- en: The `cmd` subdirectory contains various tools and commands to support development
    and operations, as well as end-to-end tests that involve multiple actors, services,
    or external dependencies; for example, testing a microservice via its client library.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmd`子目录包含各种工具和命令，以支持开发和运营，以及涉及多个参与者、服务或外部依赖的端到端测试；例如，通过其客户端库测试微服务。'
- en: 'At the moment, it only contains a single end-to-end test for the social graph
    service:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，它只包含了社交图服务的单个端到端测试：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The pkg subdirectory
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pkg子目录
- en: 'The `pkg` subdirectory is where all the packages live. It includes the implementation
    of the microservices, the client libraries, the abstract object model, other support
    packages, and unit tests. The bulk of the code is in the form of Go packages that
    are simple to develop and test before they are bundled into actual microservices:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg`子目录是所有包的所在地。它包括微服务的实现，客户端库，抽象对象模型，其他支持包和单元测试。大部分代码以Go包的形式存在，这些包在实际微服务之前很容易开发和测试：'
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The svc subdirectory
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: svc子目录
- en: 'The `svc` subdirectory is where the Delinkcious microservices live. Each microservice
    is a separate binary with its own main package. `delinkcious_service` is a public
    umbrella service that follows the API gateway ([https://microservices.io/patterns/apigateway.html](https://microservices.io/patterns/apigateway.html))
    pattern:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`svc`子目录是Delinkcious微服务的所在地。每个微服务都是一个独立的二进制文件，有自己的主包。`delinkcious_service`是一个遵循API网关模式的公共服务（[https://microservices.io/patterns/apigateway.html](https://microservices.io/patterns/apigateway.html)）：'
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Introducing the Delinkcious microservices
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Delinkcious微服务
- en: Let's examine the Delinkcious services in detail and peel the onion. We'll actually
    work our way from the inside out, starting with the service layer and going through
    the endpoints all the way to the transports.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细检查Delinkcious服务，并逐步分析。我们将从内部开始，从服务层开始，一直到传输层。
- en: 'There are three different services:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种不同的服务：
- en: Link service
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接服务
- en: User service
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户服务
- en: Social graph service
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社交图服务
- en: Together, they collaborate to provide the functionality of Delinkcious, which
    is to manage links for users and keep track of their social graph (followed/follower
    relationships).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它们共同合作，提供Delinkcious的功能，即为用户管理链接并跟踪他们的社交图（关注/粉丝关系）。
- en: The object model
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象模型
- en: 'The object model is the collection of all the interfaces and related data types
    that are implemented by the services. I chose to put all of them in a single package:
    `github.com/the-gigi/delinkcious/pkg/object_model`. It contains two files: `interfaces.go`
    and `types.go`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对象模型是所有接口和相关数据类型的集合，由服务实现。我选择把它们都放在一个包里：`github.com/the-gigi/delinkcious/pkg/object_model`。它包含两个文件：`interfaces.go`和`types.go`。
- en: 'The `interfaces.go` file contains the interfaces for the three Delinkcious
    services:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`interfaces.go`文件包含了三个Delinkcious服务的接口：'
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `types.go` file contains the structs that are used in the signatures of
    the various interface methods:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`types.go`文件包含了在各种接口方法的签名中使用的结构体：'
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `object_model` package is just using basic Go types, standard library types
    (`time.Time`), and user-defined types for the Delinkcious domain. It is all pure
    Go. At this level, there is no dependency or awareness of networking, APIs, microservices,
    or Go kit.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`object_model`包只是使用基本的Go类型、标准库类型（`time.Time`）和用户定义的类型来表示Delinkcious领域。这都是纯粹的Go。在这个层次上，没有网络、API、微服务或Go
    kit的依赖或意识。'
- en: The service implementation
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务实现
- en: 'The next layer is implementing the service interfaces as simple Go packages.
    At this point, each service has its own package:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一层是将服务接口实现为简单的Go包。在这一点上，每个服务都有自己的包：
- en: '`github.com/the-gigi/delinkcious/pkg/link_manager`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`github.com/the-gigi/delinkcious/pkg/link_manager`'
- en: '`github.com/the-gigi/delinkcious/pkg/user_manager`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`github.com/the-gigi/delinkcious/pkg/user_manager`'
- en: '`github.com/the-gigi/delinkcious/pkg/social_graph_manager`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`github.com/the-gigi/delinkcious/pkg/social_graph_manager`'
- en: Note that these are Go package names and not URLs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些是Go包名，而不是URL。
- en: 'Let''s examine the `social_graph_manager` package. It imports the `object_model`
    package as `om` because it needs to implement the `om.SocialGraphManager` interface.
    It defines a `struct` called `SocialGraphManager` that has a field called `store`
    of the `om.SocialGraphManager` type. So, the interface of the `store` field is
    identical to the interface of the manager in this case:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细检查`social_graph_manager`包。它将`object_model`包导入为`om`，因为它需要实现`om.SocialGraphManager`接口。它定义了一个名为`SocialGraphManager`的`struct`，其中有一个名为`store`的字段，类型为`om.SocialGraphManager`。因此，在这种情况下，`store`字段的接口与管理器的接口是相同的：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This may be a little confusing. The idea is that the `store` field implements
    the same interface so that the top-level manager can implement some validation
    logic and delegate the heavy lifting to the store. You will see this in action
    soon.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点令人困惑。想法是`store`字段实现相同的接口，以便顶级管理器可以实现一些验证逻辑并将繁重的工作委托给存储。您很快就会看到这一点。
- en: 'In addition, the fact that the `store` field is an interface allows us to use
    different stores that implement the same interface. This is very useful. The `NewSocialGraphManager()`
    function accepts a `store` field that must not be `nil`, and then returns a new
    instance of `SocialGraphManager` with the provided store:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`store`字段是一个接口的事实允许我们使用实现相同接口的不同存储。这非常有用。`NewSocialGraphManager()`函数接受一个`store`字段，该字段不能为`nil`，然后返回一个提供的存储的新的`SocialGraphManager`实例。
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `SocialGraphManager` struct itself is pretty simple. It performs some validity
    checks and then delegates the work to its `store`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`SocialGraphManager`结构本身非常简单。它执行一些有效性检查，然后将工作委托给它的`store`：'
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The social graph manager is a pretty simple library. Let's continue peeling
    the onion and look at the service itself, which lives under the `svc` subdirectory: [https://github.com/the-gigi/delinkcious/tree/master/svc/social_graph_service](https://github.com/the-gigi/delinkcious/tree/master/svc/social_graph_service).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 社交图管理器是一个非常简单的库。让我们继续剥离洋葱，看看服务本身，它位于`svc`子目录下：[https://github.com/the-gigi/delinkcious/tree/master/svc/social_graph_service](https://github.com/the-gigi/delinkcious/tree/master/svc/social_graph_service)。
- en: 'Let''s start with the `social_graph_service.go` file. We''ll go over the main
    parts that are similar for most services. The file lives in the `service` package,
    which is a convention I use. It imports several important packages:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`social_graph_service.go`文件开始。我们将介绍大多数服务相似的主要部分。该文件位于`service`包中，这是我使用的一个约定。它导入了几个重要的包：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The Go kit `http` transport package is necessary for services that use the HTTP
    transport. The `gorilla/mux` package provides top-notch routing capabilities.
    `social_graph_manager` is the implementation of the service that does all the
    heavy lifting. The `log` package is for logging, and the `net/http` package is
    for serving HTTP since it's an HTTP service.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Go kit `http`传输包对于使用HTTP传输的服务是必需的。`gorilla/mux`包提供了一流的路由功能。`social_graph_manager`是执行所有繁重工作的服务的实现。`log`包用于记录日志，`net/http`包用于提供HTTP服务，因为它是一个HTTP服务。
- en: 'There is just one function called `Run()`. It starts by creating a data store
    for the social graph manager and then creates the social graph manager itself,
    passing it the `store` field. So, the functionality of `social_graph_manager`
    is implemented in the package, but the `service` is responsible for making the
    policy decisions and passing a configured data store. If anything goes wrong at
    this point, the service just exits with a `log.Fatal()` call because there is
    no way to recover at this early stage:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个名为`Run()`的函数。它首先创建一个社交图管理器的数据存储，然后创建社交图管理器本身，并将`store`字段传递给它。因此，`social_graph_manager`的功能是在包中实现的，但`service`负责做出策略决策并传递配置好的数据存储。如果在这一点上出了任何问题，服务将通过`log.Fatal()`调用退出，因为在这个早期阶段没有办法恢复。
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The next part is constructing the handler for each endpoint. This is done by
    calling the `NewServer()` function of the HTTP transport for each endpoint. The
    parameters are the `Endpoint` factory function, which we will review soon, a request
    decoder function, and the `response` encoder function. For HTTP services, it is
    common for requests and responses to be encoded as JSON:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是为每个端点构建处理程序的部分。这是通过调用HTTP传输的`NewServer()`函数来完成的。参数是`Endpoint`工厂函数（我们很快将对其进行审查）、请求解码器函数和`response`编码器函数。对于HTTP服务，通常将请求和响应编码为JSON。
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At this point, we have `SocialGraphManager` properly initialized and the handlers
    for all the endpoints. It''s time to expose them to the world via the `gorilla`
    router. Each endpoint is associated with a route and a method. In this case, the
    `follow` and `unfollow` operations use the POST method and the `following` and
    `followers` operations use the GET method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经正确初始化了`SocialGraphManager`并且为所有端点准备好了处理程序。现在是时候通过`gorilla`路由器向世界公开它们了。每个端点都与一个路由和一个方法相关联。在这种情况下，`follow`和`unfollow`操作使用POST方法，`following`和`followers`操作使用GET方法：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The last part is just passing the configured router to the `ListenAndServe()`
    method of the standard HTTP package. This service is hardcoded to listen on port
    `9090`. Later on in this book, we will see how to configure things in a flexible
    and more industrial-strength way:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分只是将配置好的路由器传递给标准HTTP包的`ListenAndServe()`方法。该服务硬编码为监听端口`9090`。在本书的后面，我们将看到如何以灵活和更具产业实力的方式配置这些东西：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Implementing the support functions
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现支持函数
- en: As you may recall, the social graph implementation in the `pkg/social_graph_manager`
    package is completely transport agnostic. It implements the `SocialGraphManager`
    interface in terms of Go and couldn't care less whether the payload is JSON or
    protobuf and coming over the wire through HTTP, gRPC, Thrift, or any other method.
    The service is responsible for translation, encoding, and decoding. These support
    functions are implemented in the `transport.go` file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，`pkg/social_graph_manager`包中的社交图实现完全与传输无关。它根据Go实现`SocialGraphManager`接口，不管负载是JSON还是protobuf，以及通过HTTP、gRPC、Thrift或任何其他方法传输。服务负责翻译、编码和解码。这些支持函数在`transport.go`文件中实现。
- en: 'For each endpoint, there are three functions, which are the input to the HTTP
    transport''s `NewServer()` function of Go kit:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个端点，都有三个函数，它们是Go kit的HTTP传输`NewServer()`函数的输入：
- en: The `Endpoint` factory function
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Endpoint`工厂函数'
- en: The `request` decoder
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request`解码器'
- en: The `response` encoder
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response`编码器'
- en: 'Let''s start with the `Endpoint` factory function, which is the most interesting.
    Let''s use the `GetFollowing()` operation as an example. The `makeGetFollowingEndpoint()`
    function takes a `SocialGraphManager` interface as input (as you saw earlier,
    in practice, it will be the implementation in `pkg/social_graph_manager`). It
    returns a generic `endpoint.Endpoint` function, which a function that takes a
    `Context` and a generic `request` and returns a generic `response` and `error`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Endpoint`工厂函数开始，这是最有趣的部分。让我们以`GetFollowing()`操作为例。`makeGetFollowingEndpoint()`函数以`SocialGraphManager`接口作为输入（如你之前看到的，在实践中，它将是`pkg/social_graph_manager`中的实现）。它返回一个通用的`endpoint.Endpoint`函数，这是一个接受`Context`和通用`request`并返回通用`response`和`error`的函数：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The job of the `makeGetFollowingEndpoint()` method is to return a function
    that complies with this signature. It returns such a function that, in its implementation,
    takes the generic request (the empty interface) and type before asserting it to
    a concrete request, that is, `getByUsernameRequest`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeGetFollowingEndpoint()`方法的工作是返回一个符合这个签名的函数。它返回这样一个函数，在其实现中，接受通用请求（空接口）和类型，然后将其断言为具体的请求，即`getByUsernameRequest`：'
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is a key concept. We cross the boundary from a generic object, which could
    be from anything to a strongly typed struct. This ensures that, even though the
    Go kit endpoints operate in terms of empty interfaces, the implementation of our
    microservice is type checked. If the request doesn''t contain the right fields,
    it panics. I could also check whether it''s possible to do the type assert and
    return an error instead of panicking, which might be more appropriate in some
    contexts:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关键概念。我们从一个通用对象跨越边界，这个对象可以是任何东西，到一个强类型的结构体。这确保了，即使Go kit端点是以空接口的形式操作，我们的微服务的实现也经过了类型检查。如果请求不包含正确的字段，它会引发panic。我也可以检查是否可能进行类型断言，而不是引发panic，这在某些情况下可能更合适：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s take a look at the request itself. It is simply a struct with a single
    string field called `Username`. It has the JSON struct tag, which is optional
    in this case because the JSON package can automatically work with field names
    that differ from the actual JSON just by case like (`Username` versus `username`):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看请求本身。它只是一个带有一个名为`Username`的字符串字段的结构体。它有JSON结构标签，在这种情况下是可选的，因为JSON包可以通过大小写的不同来自动处理与实际JSON不同的字段名（例如`Username`与`username`）：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that the request type is `getByUsernameRequest` and not `getFollowingRequest`,
    as you may expect in order to be consistent with the operation it is supporting.
    The reason for this is that I actually use the same request for multiple endpoints.
    The `GetFollowers()` operation also requires a `username`, and `getByUsernameRequest`
    serves both `GetFollowing()` and `GetFollowers()`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，请求类型是`getByUsernameRequest`而不是`getFollowingRequest`，这可能与您期望的一致，以支持它正在支持的操作。原因是我实际上在多个端点上使用相同的请求。`GetFollowers()`操作也需要一个`username`，而`getByUsernameRequest`同时为`GetFollowing()`和`GetFollowers()`提供服务。
- en: 'At this point, we have the username from the request and we can invoke the
    `GetFollowing()` method of the underlying implementation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们从请求中得到了用户名，我们可以调用底层实现的`GetFollowing()`方法：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The result is a map of the users that the requested user is following and the
    standard error. However, this is an HTTP endpoint, so the next step is to package
    this information into the `getFollowingResponse` struct:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是请求用户正在关注的用户的映射和标准错误。但是，这是一个HTTP端点，所以下一步是将这些信息打包到`getFollowingResponse`结构体中：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following map can be translated into a JSON map of `string->bool`. However,
    there is no direct equivalent to the Go error interface. The solution is to encode
    the error as a string (via `err.Error()`), where an empty string represents no
    error:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下映射可以转换为`string->bool`的JSON映射。然而，Go错误接口没有直接的等价物。解决方案是将错误编码为字符串（通过`err.Error()`），其中空字符串表示没有错误：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is the entire function:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整个函数：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s take a look at the `decodeGetFollowingRequest()` function. It accepts
    the standard `http.Request` object. It needs to extract the username from the
    request and return a `getByUsernameRequest` struct that the endpoint can use later.
    At the HTTP request level, the username will be a part of the request path. The
    function will parse the path, extract the username, prepare the request, and return
    it or an error if anything goes wrong (for example, no username is provided):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看`decodeGetFollowingRequest()`函数。它接受标准的`http.Request`对象。它需要从请求中提取用户名，并返回一个`getByUsernameRequest`结构体，以便端点稍后可以使用。在HTTP请求级别，用户名将成为请求路径的一部分。该函数将解析路径，提取用户名，准备请求，并返回请求或错误（例如，未提供用户名）：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The last support function is the `encodeResonse()` function. In theory, each
    endpoint can have its own custom `response` encoding function. However, in this
    case, I am using a single generic function that knows how to encode all the responses
    into JSON:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个支持函数是`encodeResonse()`函数。理论上，每个端点都可以有自己的自定义`response`编码函数。但在这种情况下，我使用了一个通用函数，它知道如何将所有响应编码为JSON：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This requires all the response structs to be JSON serializable, which was taken
    care of by translating the Go error interface into a string by the endpoint implementation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要所有响应结构都可以被JSON序列化，这是通过将Go错误接口转换为端点实现的字符串来处理的。
- en: Invoking the API via a client library
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过客户端库调用API。
- en: 'The social graph manager is now accessible through an HTTP REST API. Here is
    a quick local demo. First, I will launch the Postgres DB (I have a Docker image
    called `postgres`), which is used as the data store, and then I will run the service
    itself in the `service` directory, that is, `delinkcious/svc/social_graph_service`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 社交图管理器现在可以通过HTTP REST API访问。这是一个快速的本地演示。首先，我将启动Postgres DB（我有一个名为`postgres`的Docker镜像），它用作数据存储，然后我将在`service`目录中运行服务本身，即`delinkcious/svc/social_graph_service`：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s add a couple of follower/following relationships by invoking the `/follow`
    endpoint. I will use the excellent HTTPie ([https://httpie.org/](https://httpie.org/)),
    which is a better `curl` in my honest opinion. However, you can use `curl` if
    you prefer:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`/follow`端点来添加一些关注/被关注的关系。我将使用出色的HTTPie（[https://httpie.org/](https://httpie.org/)），在我看来，这是一个更好的`curl`。但是，如果你喜欢，你也可以使用`curl`：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These two calls made the `gigi` user follow the `liat` and `guy` users. Let''s
    use the `/following` endpoint to verify this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个调用使`gigi`用户关注`liat`和`guy`用户。让我们使用`/following`端点来验证这一点：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The JSON response has an empty error, and the `following` map contains the `guy` and
    `liat` users, as expected.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: JSON响应中有一个空错误，`following`映射包含了`guy`和`liat`用户，如预期的那样。
- en: While a REST API is cool, we can do better. Instead of forcing the caller to
    understand the URL schema of our service and decode and encode JSON payloads,
    why not provide a client library that does all of that? This is especially true
    for internal microservices that all talk to each other using a small number of
    languages, and in many cases, just one language. The service and client can share
    the same interface and, maybe even some common types. In addition, Go kit provides
    support for client-side endpoints that are pretty similar to service-side endpoints.
    This translates directly into a very streamlined end-to-end developer experience,
    where you just stay in the programming language space. All the endpoints, transports,
    encoding, and decoding can remain hidden as an implementation detail for the most
    part.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然REST API很酷，但我们可以做得更好。我们不应该强迫调用者理解我们服务的URL模式，并解码和编码JSON负载，为什么不提供一个客户端库来完成所有这些呢？这对于所有使用少量语言进行交流的内部微服务来说尤其如此，在许多情况下，甚至只有一种语言。服务和客户端可以共享相同的接口，甚至可能有一些共同的类型。此外，Go
    kit提供了对客户端端点的支持，这些端点与服务端端点非常相似。这直接转化为一个非常简化的端到端开发者体验，你只需留在编程语言空间。所有端点、传输、编码和解码可以大部分时间保持隐藏，作为实现细节。
- en: 'The social graph service provides a client library that lives in the `pkg/social_graph_client`
    package. The `client.go` file is similar to the `social_graph_service.go` file
    and is responsible for creating a set of endpoints in the `NewClient()` function
    and returning the `SocialGraphManager` interface. The `NewClient()` function takes
    the base URL as an argument and then constructs a set of client endpoints using
    Go kit''s `NewClient()` function of the HTTP transport. Each endpoint requires
    a URL, a method (`GET` or `POST`, in this case), a `request` encoder, and a `response`
    decoder. It''s like a mirror image of the service. Then, it assigns the client
    endpoints to the `EndpointSet` struct, which can expose them through the `SocialGraphManager`
    interface:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 社交图服务提供了一个客户端库，位于`pkg/social_graph_client`包中。`client.go`文件类似于`social_graph_service.go`文件，负责在`NewClient()`函数中创建一组端点，并返回`SocialGraphManager`接口。`NewClient()`函数以基本URL作为参数，然后使用Go
    kit的HTTP传输的`NewClient()`函数构建一组客户端端点。每个端点都需要一个URL、一个方法（在本例中为`GET`或`POST`）、一个`request`编码器和一个`response`解码器。它就像服务的镜像。然后，它将客户端端点分配给`EndpointSet`结构体，可以通过`SocialGraphManager`接口公开它们：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `EndpointSet` struct is defined in the `endpoints.go` file. It contains
    the endpoints themselves, which are functions, and it implements the `SocialGraphManager`
    method, where it delegates the work to the endpoint''s functions:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`EndpointSet`结构体在`endpoints.go`文件中定义。它包含端点本身，这些端点是函数，并实现了`SocialGraphManager`方法，在其中将工作委托给端点的函数：'
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s examine the `EndpointSet` struct''s `GetFollowing()` method. It accepts
    the username as a string, and then it calls the endpoint with a `getByUserNameRequest`
    that''s populated with the input username. If calling the endpoint function returned
    an error, it just bails out. Otherwise, it does type assertion to convert the
    generic response into a `getFollowingResponse` struct. If its error string wasn''t
    empty, it creates a Go error from it. Eventually, it returns the following users
    from the response as a map:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`EndpointSet`结构体的`GetFollowing()`方法。它接受用户名作为字符串，然后调用带有填充输入用户名的`getByUserNameRequest`的端点。如果调用端点函数返回错误，它就会退出。否则，它进行类型断言，将通用响应转换为`getFollowingResponse`结构体。如果其错误字符串不为空，它会从中创建一个Go错误。最终，它将响应中的关注用户作为映射返回：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Storing data
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储数据
- en: 'We''ve seen how Go kit and our own code take an HTTP request with a JSON payload,
    translate it into a Go struct, invoke the service implementation, and encode the
    response as a JSON to return to the caller. Now, let''s take a deeper look at
    the persistent storage of the data. The social graph manager is responsible for
    maintaining the followed/follower relationships between users. There are many
    options for storing such data, including relational databases, key-value stores,
    and, of course, graph databases, which may be the most natural. I chose to use
    a relational database at this stage because it is familiar, reliable, and can
    support the following necessary operations well:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Go kit和我们自己的代码如何接受带有JSON负载的HTTP请求，将其转换为Go结构，调用服务实现，并将响应编码为JSON返回给调用者。现在，让我们更深入地了解数据的持久存储。社交图管理器负责维护用户之间的关注/粉丝关系。有许多选项可用于存储此类数据，包括关系数据库、键值存储，当然还有图数据库，这可能是最自然的。在这个阶段，我选择使用关系数据库，因为它熟悉、可靠，并且可以很好地支持所需的操作：
- en: Follow
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注
- en: Unfollow
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消关注
- en: Get followers
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取关注者
- en: Get following
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取以下
- en: 'However, if we later discover that we prefer a different data store or extend
    the relational DB with some caching mechanism, it will be very easy to do so because
    the data store of the social graph manager is hidden behind an interface. It is
    actually using the very same interface, that is, `SocialGraphManager`. As you
    may remember, the social graph manager package accepts a store argument of the `SocialGraphManager` type
    in its factory function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们后来发现我们更喜欢不同的数据存储或者扩展关系型数据库以添加一些缓存机制，那么很容易做到，因为社交图管理器的数据存储被隐藏在一个接口后面。它实际上使用的是同一个接口，即
    `SocialGraphManager`。正如您可能记得的那样，社交图管理器包在其工厂函数中接受了一个 `SocialGraphManager` 类型的存储参数：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Since the social graph manager interacts with its data store through this interface,
    changing implementations can be done without any code changes to the social graph
    manager itself.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于社交图管理器通过这个接口与其数据存储进行交互，因此可以在不对社交图管理器本身进行任何代码更改的情况下进行更改实现。
- en: I will take advantage of this for unit testing, where I use an in-memory data
    store that is easy to set up, can be quickly populated with test data, and allows
    me to run tests locally.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我将利用这一点进行单元测试，其中我使用一个易于设置的内存数据存储，可以快速填充测试数据，并允许我在本地运行测试。
- en: Let's look at the in-memory social graph data store, which can be found at [https://github.com/the-gigi/delinkcious/blob/master/pkg/social_graph_manager/in_memory_social_graph_store.go](https://github.com/the-gigi/delinkcious/blob/master/pkg/social_graph_manager/in_memory_social_graph_store.go).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看内存中的社交图数据存储，可以在[https://github.com/the-gigi/delinkcious/blob/master/pkg/social_graph_manager/in_memory_social_graph_store.go](https://github.com/the-gigi/delinkcious/blob/master/pkg/social_graph_manager/in_memory_social_graph_store.go)找到。
- en: 'It has very few dependencies – just the `SocialGraphManager` interface and
    the standard errors package. It defines a `SocialUser` struct, which contains
    a username and the names of the users it is following, as well as the names of
    the users that they are followed by:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 它几乎没有依赖关系 - 只有 `SocialGraphManager` 接口和标准错误包。它定义了一个 `SocialUser` 结构，其中包含用户名以及它正在关注的用户的名称，以及正在关注它的用户的名称：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The data store itself is a struct called `InMemorySocialGraphStore` that contains
    a map between usernames and the corresponding `SocialUser` struct:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储本身是一个名为 `InMemorySocialGraphStore` 的结构，其中包含用户名和相应的 `SocialUser` 结构之间的映射：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is all pretty pedestrian. The `InMemorySocialGraphStore` struct implements
    the `SocialGraphManager` interface methods. For example, here is the `Follow()`
    method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这都是相当普通的。`InMemorySocialGraphStore` 结构实现了 `SocialGraphManager` 接口方法。例如，这是 `Follow()`
    方法：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At this point, there is no need to focus on how it works too much. The main
    point I want to get across is that by using interfaces as abstractions, you can
    get a lot of flexibility and clean separation of concerns that helps a lot when
    you want to develop specific parts of the system or a service during testing.
    If you want to make significant changes, such as changing your underlying data
    stores or using multiple data stores interchangeably, then having an interface
    in place is a life saver.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，没有必要过多关注它的工作原理。我想要传达的主要观点是，通过使用接口作为抽象，您可以获得很大的灵活性和清晰的关注点分离，这在您想要在测试期间开发系统或服务的特定部分时非常有帮助。如果您想要进行重大更改，比如更改底层数据存储或可互换使用多个数据存储，那么拥有一个接口是一个救命稻草。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you got a close look at the Go kit toolkit, the overall Delinkcious
    system and its microservices, and got to drill down into the social graph component
    of Delinkcious. The main theme of this chapter is that Go kit provides clean abstractions,
    such as services, endpoints and transports, and generic functionality for breaking
    microservices into layers. Then, you add your code for a consistent system of
    loosely-coupled yet cohesive microservices. You also followed the path of a request
    from the client, all the way to the service and back through all the layers. At
    this point, you should have a general grasp of how Go kit helps shape the Delinkcious
    architecture and how it would benefit any other system. You may be a little overwhelmed
    by all of this information, but remember that the complexity it neatly packaged
    and that you can ignore it most of the time, focus on your application, and just
    reap the benefits.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您仔细了解了Go kit工具包，整个Delinkcious系统及其微服务，并深入研究了Delinkcious的社交图组件。本章的主题是，Go
    kit提供了清晰的抽象，如服务、端点和传输，以及用于将微服务分层的通用功能。然后，您可以为松散耦合但内聚的微服务系统添加代码。您还跟随了来自客户端的请求的路径，一直到服务，然后通过所有层返回。在这一点上，您应该对Go
    kit如何塑造Delinkcious架构以及它如何使任何其他系统受益有一个大致的了解。您可能会对所有这些信息感到有些不知所措，但请记住，这种复杂性被整齐地打包了起来，您大部分时间可以忽略它，专注于您的应用程序，并获得好处。
- en: In the next chapter, we'll address a very critical part of any modern microservices-based
    system – the CI/CD pipeline. We'll create a Kubernetes cluster, configure CircleCI,
    deploy the Argo CD continuous delivery solution, and see how to deploy Delinkcious
    on Kubernetes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论任何现代基于微服务的系统中非常关键的部分 - CI/CD流水线。我们将创建一个Kubernetes集群，配置CircleCI，部署Argo
    CD持续交付解决方案，并了解如何在Kubernetes上部署Delinkcious。
- en: Further reading
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Let''s refer to the following references:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们参考以下参考资料：
- en: To learn more about Go kit, check out [https://gokit.io/](https://gokit.io/).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于Go kit的信息，请访问[https://gokit.io/](https://gokit.io/)。
- en: To better understand the SOLID design principles that Delinkcious utilizes,
    check out [https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了更好地理解Delinkcious利用的SOLID设计原则，请查看[https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID)。
