- en: Configuring Microservices with Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes配置微服务
- en: 'In this chapter, we''re moving into the practical and real-world area of microservices
    configuration. Configuration is a big part of building complex distributed systems.
    In general, configuration concerns any aspect of the system that the code should
    be aware of, but that isn''t encoded in the code itself. Here are the topics we
    will discuss in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进入微服务配置的实际和现实世界领域。配置是构建复杂分布式系统的重要组成部分。一般来说，配置涉及代码应该意识到的系统的任何方面，但并未编码在代码本身中。以下是本章将讨论的主题：
- en: What is configuration all about?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置到底是什么？
- en: Managing configuration the old-fashioned way
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以老式方式管理配置
- en: Managing configuration dynamically
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态管理配置
- en: Configuring microservices with Kubernetes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes配置微服务
- en: By the end of this chapter, you will have a solid understanding of the value
    of configuration. You will also have learned the many ways to configure software
    both statically and dynamically, as well as the special configuration options
    that Kubernetes provides (one of its best features). You will have also gained
    the insights and knowledge to benefit from the flexibility and control Kubernetes
    provides you as a developer and operator.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将对配置的价值有扎实的了解。您还将学会静态和动态配置软件的许多方法，以及Kubernetes提供的特殊配置选项（其中之一是其最佳功能）。您还将获得洞察力和知识，以从Kubernetes作为开发人员和运营商提供的灵活性和控制中受益。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will look at a lot of Kubernetes manifests and will extend
    the capabilities of Delinkcious. There will be no need to install anything new.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看许多Kubernetes清单，并扩展Delinkcious的功能。不需要安装任何新东西。
- en: The code
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码
- en: 'As usual, the code is split between two Git repositories:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，代码分为两个Git存储库：
- en: You can find the code samples at [https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter05)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter05)找到代码示例
- en: You can find the updated Delinkcious application at [https://github.com/the-gigi/delinkcious/releases/tag/v0.3](https://github.com/the-gigi/delinkcious/releases/tag/v0.3)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/the-gigi/delinkcious/releases/tag/v0.3](https://github.com/the-gigi/delinkcious/releases/tag/v0.3)找到更新的Delinkcious应用程序
- en: What is configuration all about?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置到底是什么？
- en: 'Configuration is a very overloaded term. Let''s define it clearly for our purpose
    here: configuration mostly refers to operational data that''s needed for computation.
    The configuration may be different between environments. Here are some typical
    configuration items:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 配置是一个非常重载的术语。让我们为我们的目的清晰地定义它：配置主要是指计算所需的操作数据。配置可能在不同的环境之间有所不同。以下是一些典型的配置项：
- en: Service discovery
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现
- en: Support testing
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持测试
- en: Environment-specific metadata
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定于环境的元数据
- en: Secrets
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密
- en: Third-party configuration
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方配置
- en: Feature flags
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能标志
- en: Timeouts
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超时
- en: Rate limits
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制
- en: Various defaults
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种默认值
- en: In general, the code that processes the input data utilizes configuration data
    to control operational aspects of the computation, but not algorithmic aspects.
    There are special cases where, via configuration, you can switch between different
    algorithms at runtime, but that's crossing into gray areas. Let's keep it simple
    for our purposes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，处理输入数据的代码利用配置数据来控制计算的操作方面，而不是算法方面。有一些特殊情况，通过配置，您可以在运行时在不同的算法之间切换，但这已经涉及到灰色地带。让我们为我们的目的保持简单。
- en: When considering configuration, it's important to think about who is supposed
    to create and update the configuration data. It may or may not be the developer
    of the code—for example, rate limits may be determined by a DevOps team member,
    but feature flags will be set by the developer. Also, in different environments,
    different people may modify the same value. You'll typically have the most restrictions
    in production.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑配置时，重要的是要考虑谁应该创建和更新配置数据。可能是代码的开发者，也可能不是。例如，速率限制可能由DevOps团队成员确定，但功能标志将由开发人员设置。此外，在不同的环境中，不同的人可能修改相同的值。通常在生产中会有最严格的限制。
- en: Configuration and secrets
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置和秘密
- en: Secrets are credentials that are used to access databases and other services
    (internal and/or external). Technically, they are configuration data, but in practice,
    because of their sensitivity, they often need to be encrypted at rest and controlled
    more carefully. It is common to have secrets stored and managed separately from
    regular configurations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密是用于访问数据库和其他服务（内部和/或外部）的凭据。从技术上讲，它们是配置数据，但实际上，由于它们的敏感性，它们经常需要在静止时加密并进行更严格的控制。通常会将秘密存储和单独管理，而不是与常规配置分开。
- en: In this chapter, we will consider only nonsensitive configuration. In the next
    chapter, we will discuss secrets in detail. Kubernetes also separates configuration
    from secrets at the API level.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只考虑非敏感配置。在下一章中，我们将详细讨论秘密。Kubernetes还在API级别将配置与秘密分开。
- en: Managing configuration the old-fashioned way
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以老式方式管理配置
- en: 'When I say the old-fashioned way, I mean pre-Kubernetes static configuration.
    But as you''ll see, the old-fashioned way is sometimes the best way, and is often
    well supported by Kubernetes too. Let''s go over the various ways to configure
    a program, consider their pros and cons, and when they are appropriate. The configuration
    mechanisms we will cover here are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说老式方式时，我的意思是在Kubernetes之前的静态配置。但正如您将看到的，老式方式有时是最好的方式，而且通常也得到Kubernetes的良好支持。让我们来看看配置程序的各种方式，考虑它们的优缺点，以及何时适用。我们将在这里介绍的配置机制如下：
- en: No configuration (convention over configuration)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无配置（约定优于配置）
- en: Command-line arguments
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行参数
- en: Environment variables
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量
- en: Configuration files
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件
- en: While Delinkcious is implemented mostly in Go, we will use different programming
    languages to demonstrate the configuration options just for fun and variety.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Delinkcious主要是用Go实现的，但我们将使用不同的编程语言来演示配置选项，只是为了好玩和多样性。
- en: Convention over configuration
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约定优于配置
- en: 'Sometimes, you don''t really need configuration; the program can just make some
    decisions, document them, and that''s that. For example, the name of the directory
    of the output file could be configurable, but the program can just decide that
    it''s going to *output* and that''s that. The upside of this approach is that
    it is very predictable: you don''t have to think about configuration, and just
    by reading the code of the program, you know exactly what it does and where everything
    is supposed to be. The operators have very little work to do. The downside is
    that if more flexibility is needed, you have no recourse (for example, maybe there
    isn''t enough space on the volume the program is running on).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您实际上不需要配置；程序可以只做出一些决定，对其进行文档记录，就这样。例如，输出文件的目录名称可以是可配置的，但程序可以决定它将*输出*，就这样。这种方法的好处是非常可预测的：您不必考虑配置，只需通过阅读程序代码，就可以准确知道它的功能和一切应该在哪里。运营商的工作量很少。缺点是，如果需要更多的灵活性，您就没有办法（例如，可能程序运行的卷上没有足够的空间）。
- en: Note that convention over configuration doesn't mean that there is no configuration
    at all. It means that you can reduce the amount of configuration when using convention.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，约定优于配置并不意味着根本没有配置。这意味着在使用约定时可以减少配置的数量。
- en: 'Here is a little Rust program that prints the Fibonacci sequence up to 100
    to the screen. By convention, it makes the decision that it will not go over 100\.
    You can''t configure it to print more or fewer numbers without changing the code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小的Rust程序，它将斐波那契序列打印到屏幕上，直到100。按照约定，它决定不会超过100。您无法配置它以打印更多或更少的数字而不改变代码：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Command-line flags
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行标志
- en: 'Command-line flags or arguments are a staple of programming. When you run your
    program, you provide arguments that the program uses to configure itself. There
    are pros and cons of using them:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行标志或参数是编程的重要组成部分。运行程序时，您提供参数，程序使用这些参数来配置自身。使用它们有利有弊：
- en: '**Pros**:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: Very flexible
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常灵活
- en: Familiar and available in every programming language
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉并且在每种编程语言中都可用
- en: There are established best practices for short and long options
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关短选项和长选项的最佳实践已经建立
- en: Works well with interactive usage documentation
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与交互式使用文档配合良好
- en: '**Cons**:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: Arguments are always strings
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数始终是字符串
- en: Need to quote arguments that contain spaces
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要引用包含空格的参数
- en: Difficult to deal with multiline arguments
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以处理多行参数
- en: Restrictions on the number of command-line arguments
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行参数的数量限制
- en: Restrictions on the size of each argument
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个参数的大小限制
- en: Command-line arguments are often used for input in addition to configuration.
    The boundaries between input and configuration can be a little murky sometimes.
    In most cases, it doesn't really matter, but it can make it confusing to users
    that just want to pass their input to a program through a command-line argument
    and are presented with a large and confusing array of configuration options.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数通常用于输入以及配置。输入和配置之间的界限有时可能有点模糊。在大多数情况下，这并不重要，但对于只想通过命令行参数将其输入传递给程序的用户来说，这可能会让他们感到困惑，因为他们会看到一大堆令人困惑的配置选项。
- en: 'Here is a little Ruby program that writes the Fibonacci sequence up to a number that''s
    provided as a command-line argument:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小的Ruby程序，它将斐波那契序列写入到一个作为命令行参数提供的数字。
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Environment variables
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境变量
- en: Environment variables are another favorite. They are useful when your program
    runs in an environment that may be set up by another program (or a shell script).
    Environment variables are typically inherited from the parent environment. They
    are also used for running interactive programs when the user always wants to provide
    the same option (or set of options) to the program. Instead of typing a long command
    line with the same options again and again, it is much more convenient to set
    an environment variable once (maybe even in your profile) and just run the program
    with no arguments. A good example is the AWS CLI, which allows you to specify
    many configuration options as environment variables (for example, `AWS_DEFAULT_REGION`
    or `AWS_PROFILE`).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量是另一个受欢迎的选项。当您的程序在可能由另一个程序（或shell脚本）设置的环境中运行时，它们非常有用。环境变量通常从父环境继承。它们还用于运行交互式程序，当用户总是希望向程序提供相同的选项（或一组选项）时。与其一遍又一遍地输入带有相同选项的长命令行，不如设置一个环境变量（甚至可能在您的配置文件中）一次，然后无需参数运行程序。一个很好的例子是AWS
    CLI，它允许您将许多配置选项指定为环境变量（例如，`AWS_DEFAULT_REGION`或`AWS_PROFILE`）。
- en: 'Here is a little Python program that writes the Fibonacci sequence up to a
    number that is provided as an environment variable. Note that the `FIB_LIMIT`
    environment variable is read as a string and the program has to convert it into
    an integer:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小的Python程序，它会写出斐波那契数列，直到一个作为环境变量提供的数字。请注意，`FIB_LIMIT`环境变量被读取为字符串，程序必须将其转换为整数。
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Configuration files
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置文件
- en: Configuration files are particularly useful when you have a lot of configuration
    data, especially when that data has a hierarchical structure. In most cases, it
    would be too overwhelming to configure an application with tens or even hundreds
    of options via command-line arguments or environment variables. Configuration
    files have another advantage, which is that you can chain multiple configuration
    files. Often, applications have a search path where they look for configuration
    files, such as `/etc/conf`, and then the `home` directory and then the current
    directory. This provides a lot of flexibility since you have common configuration
    while you're also able to override some parts per user or per run.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件在有大量配置数据时特别有用，尤其是当这些数据具有分层结构时。在大多数情况下，通过命令行参数或环境变量配置应用程序的选项太过于繁琐。配置文件还有另一个优点，就是可以链接多个配置文件。通常，应用程序会在搜索路径中查找配置文件，例如`/etc/conf`，然后是`home`目录，然后是当前目录。这提供了很大的灵活性，因为您可以拥有通用配置，同时还能够覆盖某些用户或运行时的部分配置。
- en: Configuration files are great! You should think about what format is best for
    your use case. There are many options. Configuration file formats follow trends,
    and every few years a new star shines. Let's review some of the older formats,
    as well as some of the newer ones.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件非常棒！您应该考虑哪种格式最适合您的用例。有很多选择。配置文件格式会遵循趋势，每隔几年就会有新的亮点。让我们回顾一些旧格式，以及一些新格式。
- en: INI format
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: INI格式
- en: 'INI files were once all the rage on Windows. INI stands for **initialization**.
    Mucking around with `windows.ini` and `system.ini` to get something working was
    very common in the eighties. The format itself was very simple and included sections
    with sets of key–value pairs and comments. Here is a simple INI file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: INI文件曾经在Windows上非常流行。INI代表**初始化**。在八十年代，瞎折腾`windows.ini`和`system.ini`以使某些东西工作是非常常见的。格式本身非常简单，包括带有键-值对和注释的部分。这是一个简单的INI文件：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Windows API has functions for reading and writing INI files, so a lot of
    Windows applications used them as their configuration files.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Windows API有用于读取和写入INI文件的函数，因此许多Windows应用程序将它们用作配置文件。
- en: XML format
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML格式
- en: 'XML ([https://www.w3.org/XML/](https://www.w3.org/XML/)) is a W3C standard
    that was very popular in the nineties. It stands for **eXtensible Markup Language**,
    and it was used for *everything*: data, documents, APIs (SOAP), and, of course,
    configuration files. It is very verbose, and its main claim to fame is that it
    is self-describing and contains its own metadata. XML had schemas and many standards
    built on top of it. At some point, people thought that it would replace HTML (remember
    XHTML?). That''s all in the past now. Here is a sample XML configuration file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: XML ([https://www.w3.org/XML/](https://www.w3.org/XML/))是W3C标准，在九十年代非常流行。它代表**可扩展标记语言**，用于*一切*：数据，文档，API（SOAP），当然还有配置文件。它非常冗长，它的主要特点是自我描述并包含自己的元数据。XML有模式和许多建立在其之上的标准。有一段时间，人们认为它会取代HTML（还记得XHTML吗？）。那都是过去了。这是一个样本XML配置文件：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: JSON format
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON格式
- en: 'JSON ([https://json.org/](https://json.org/)) stands for **JavaScript Object
    Notation**. It became popular with the growth of dynamic web applications and
    REST APIs. Its conciseness compared to XML was a breath of fresh air, and it quickly
    took over the industry. Its claim to fame is that it translates one-to-one to
    JavaScript objects. Here is a simple JSON file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: JSON（[https://json.org/](https://json.org/)）代表**JavaScript对象表示法**。随着动态网络应用和REST
    API的增长，它变得越来越受欢迎。与XML相比，它的简洁性让人耳目一新，并迅速占领了行业。它的成名之处在于它可以一对一地转换为JavaScript对象。这是一个简单的JSON文件：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I personally never liked JSON as a configuration file format; it doesn't support
    comments, it is unnecessarily strict about extra commas at the end of arrays,
    and serializing dates and times to JSON is always a struggle. It is also pretty
    verbose, with all the quotes, parentheses, and the need to escape many characters
    (although it is not as bad as XML).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人从来不喜欢JSON作为配置文件格式；它不支持注释，对数组末尾的额外逗号要求过于严格，将日期和时间序列化为JSON总是很麻烦。它也非常冗长，需要用引号、括号，并且需要转义许多字符（尽管它不像XML那样糟糕）。
- en: YAML format
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAML格式
- en: You've seen a lot of YAML ([https://yaml.org/](https://yaml.org/)) already in
    this book, since the Kubernetes manifests are often written as YAML. YAML is a
    superset of JSON, but it also provides a much more concise syntax that is extremely
    human readable, as well as many more features, such as references, the autodetection
    of types, and support for aligned multiline values.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本书中已经看到了很多YAML（[https://yaml.org/](https://yaml.org/)），因为Kubernetes清单通常是以YAML编写的。YAML是JSON的超集，但它还提供了一个更简洁的语法，非常易于阅读，以及更多的功能，比如引用、类型的自动检测和对齐多行值的支持。
- en: 'Here is a sample YAML file with more fancy features than you typically see
    in a normal Kubernetes manifest:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有比通常在普通Kubernetes清单中看到的更多花哨功能的YAML文件的示例：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: YAML is not as popular as JSON, but it slowly gathered momentum. Big projects
    such as Kubernetes and AWS CloudFormation use YAML (alongside JSON, because it's
    a superset) as their configuration format. CloudFormation added YAML support later;
    Kubernetes started with YAML.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: YAML不像JSON那样受欢迎，但它慢慢地积聚了动力。像Kubernetes和AWS CloudFormation这样的大型项目使用YAML（以及JSON，因为它是超集）作为它们的配置格式。CloudFormation后来添加了对YAML的支持；Kubernetes从YAML开始。
- en: It is currently my favorite configuration file format; however, YAML has its
    gotchas and critics, especially when you're using some of its more advanced features.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它目前是我最喜欢的配置文件格式；然而，YAML有它的陷阱和批评，特别是当你使用一些更高级的功能时。
- en: TOML format
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TOML格式
- en: Enter TOML ([https://github.com/toml-lang/toml](https://github.com/toml-lang/toml))—**Tom's
    Obvious Minimal Language**. TOML is like an INI file on steroids. It is the least
    known of all the formats, but it has started to gain momentum since it is used
    by Cargo, Rust's package manager. TOML is between JSON and YAML on the expressiveness
    spectrum. It supports autodetected data types and comments, but it's not as powerful
    as YAML. That said, it is the easiest for humans to read and write. It supports
    nesting mostly via dot notation as opposed to indentation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 进入TOML（[https://github.com/toml-lang/toml](https://github.com/toml-lang/toml)）—**Tom's
    Obvious Minimal Language**。TOML就像是增强版的INI文件。它是所有格式中最不为人知的，但自从被Rust的包管理器Cargo使用以来，它开始获得动力。TOML在表现形式上介于JSON和YAML之间。它支持自动检测的数据类型和注释，但它不像YAML那样强大。尽管如此，它是最容易被人类阅读和编写的。它支持嵌套，主要是通过点符号而不是缩进。
- en: 'Here is an example of a TOML file; see how readable it is:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个TOML文件的示例；看看它有多可读：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Proprietary formats
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专有格式
- en: 'Some applications just come up with their own formats. Here is a sample configuration
    file for an Nginx web server:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序只是提出了自己的格式。这是一个Nginx web服务器的示例配置文件：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I don't recommend inventing yet another poorly conceived configuration format
    for your application. Between JSON, YAML, and TOML you should find the sweet spot
    between expressiveness, human readability, and familiarity. Also, there are libraries
    in all languages to parse and compose those familiar formats.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我不建议为您的应用程序发明另一个构思不周的配置格式。在JSON、YAML和TOML之间，您应该找到表达性、人类可读性和熟悉度之间的平衡点。此外，所有语言都有库来解析和组合这些熟悉的格式。
- en: Don't invent your own configuration format!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不要发明自己的配置格式！
- en: Hybrid configuration and defaults
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合配置和默认值
- en: 'So far, we have reviewed the primary configuration mechanisms:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经审查了主要的配置机制：
- en: Convention over configuration
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约定优于配置
- en: Command-line arguments
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行参数
- en: Environment variables
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量
- en: Configuration files
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件
- en: These mechanisms are not mutually exclusive. Many applications will support
    some and even all of them. Very often, there will be a configuration resolution
    mechanism where a configuration file has a standard name and location, but you
    will still be able to specify a different configuration file via an environment
    variable and override even that for a specific run using a command-line argument.
    You don't have to look very far. Kubectl is a program that looks for its configuration
    file in `$HOME/.kube` by default; you can specify a different file via the `KUBECONFIG` environment
    variable. You can specify a special config file for a particular command by passing
    the `--config` command-line flag.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些机制并不是互斥的。许多应用程序将支持其中一些，甚至全部。很多时候，会有一个配置解析机制，其中配置文件有一个标准的名称和位置，但您仍然可以通过环境变量指定不同的配置文件，并且甚至可以通过命令行参数为特定运行覆盖甚至那个。你不必走得太远。Kubectl是一个程序，默认情况下在`$HOME/.kube`中查找其配置文件；您可以通过`KUBECONFIG`环境变量指定不同的文件。您可以通过传递`--config`命令行标志为特定命令指定特殊的配置文件。
- en: 'Speaking of which, kubectl uses YAML as its configuration format as well. Here
    is my Minikube configuration file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，kubectl也使用YAML作为其配置格式。这是我的Minikube配置文件：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Kubectl supports multiple clusters/contexts in the same config file. You can
    switch between them via `kubectl use-context`; however, many people who work regularly
    with multiple clusters don't like to keep them all in the same config file, and
    prefer to have a separate file for each cluster and then switch between them using
    the `KUBECONFIG` environment variable or by passing `--config` on the command-line.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl支持在同一配置文件中的多个集群/上下文。您可以通过`kubectl use-context`在它们之间切换；然而，许多经常使用多个集群的人不喜欢将它们全部放在同一个配置文件中，而更喜欢为每个集群单独创建一个文件，然后通过`KUBECONFIG`环境变量或通过命令行传递`--config`来在它们之间切换。
- en: Twelve factor app configuration
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 十二要素应用程序配置
- en: Heroku was one of the pioneers of cloud platform as a service. In 2011, they
    published the 12 factor methodology for building web applications. It's a pretty
    solid approach, and was very innovative at the time. It also happened to be the
    best way to build applications that could be deployed easily on Heroku itself.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku是云平台即服务的先驱之一。2011年，他们发布了用于构建Web应用程序的12要素方法论。这是一个相当坚实的方法，并且在当时非常创新。它也恰好是在Heroku上轻松部署应用程序的最佳方式。
- en: For our purposes, the most interesting part of their website is the config section,
    which can be found at [https://12factor.net/config](https://12factor.net/config).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，他们网站最有趣的部分是配置部分，可以在[https://12factor.net/config](https://12factor.net/config)找到。
- en: In short, they recommend that web services and applications always store the
    configuration in environment variables. This is a safe but somewhat limited guideline.
    It means that the service has to be restarted whenever a configuration changes,
    and suffers from the general limitations of environment variables.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，他们建议Web服务和应用程序始终将配置存储在环境变量中。这是一个安全但有些有限的指导方针。这意味着每当配置更改时，服务都必须重新启动，并且受到环境变量的一般限制。
- en: Later, we will see how Kubernetes supports configuration as environment variables
    and configuration as configuration files, as well as a few special twists. But
    first, let's discuss dynamic configuration.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将看到Kubernetes如何支持将配置作为环境变量和配置文件，以及一些特殊的变化。但首先，让我们讨论动态配置。
- en: Managing configuration dynamically
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态管理配置
- en: So far, the configuration options we have discussed have been static. You have
    to restart and, in some cases (such as with embedded configuration files), redeploy
    your service to change its configuration. The nice thing about restarting your
    service when the configuration changes is that you don't have to worry about the
    impact of the new configuration changes on the in-memory state and the processing
    of in-flight requests because you're starting from scratch; however, the downside
    is that you lose all your in-flight requests (unless you are using a graceful
    shutdown) and any warmed-up caches or one-time initialization work, which could
    be substantial. You can mitigate this somewhat, though, by using rolling updates
    and blue-green deployments.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的配置选项都是静态的。你必须重新启动，并且在某些情况下（比如使用嵌入式配置文件），重新部署你的服务来改变它的配置。当配置改变时重新启动服务的好处是你不必担心新配置对内存状态和正在处理的请求的影响，因为你是从头开始的；然而，缺点是你会失去所有正在处理的请求（除非你使用优雅关闭）和任何已经预热的缓存或一次性初始化工作，这可能是相当大的。然而，你可以通过使用滚动更新和蓝绿部署来在一定程度上减轻这种情况。
- en: Understanding dynamic configuration
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解动态配置
- en: Dynamic configuration means that the service keeps running with the same code
    and the same in-memory state, but it can detect that the configuration has changed,
    and will dynamically adjust its behavior according to the new configuration. From
    the operator's perspective, when the configuration needs to change, they can just
    update the central configuration store and don't need to force a restart/redeployment
    of a service whose code didn't change.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 动态配置意味着服务保持运行，代码和内存状态保持不变，但它可以检测到配置已经改变，并根据新的配置动态调整其行为。从操作员的角度来看，当配置需要改变时，他们只需更新中央配置存储，而不需要强制重新启动/部署代码未改变的服务。
- en: It's important to understand that this is not a binary choice; some configuration
    may be static, and when it changes, you must restart the service, but some other
    configuration items may be dynamic.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解这不是一个二元选择；一些配置可能是静态的，当它改变时，你必须重新启动服务，但其他一些配置项可能是动态的。
- en: Since dynamic configuration can change the behavior of the system in a way that
    is not captured by source control, it's a common practice to keep a history and
    audit of who changed what and when. Let's look at when you should use dynamic
    configuration and when you shouldn't!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于动态配置可以改变系统的行为方式，这种改变无法通过源代码控制来捕捉，因此保留更改历史和审计是一个常见的做法。让我们看看什么时候应该使用动态配置，什么时候不应该使用！
- en: When is dynamic configuration useful?
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态配置何时有用？
- en: 'Dynamic configuration is useful in the following cases:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 动态配置在以下情况下很有用：
- en: If you just have a single instance of your service, then restarting means a
    mini-outage
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只有一个服务实例，那么重新启动意味着短暂的中断
- en: If you have feature flags that you want to switch back and forth quickly
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您有要快速切换的功能标志
- en: If you have services where initialization or dropping in-flight requests is
    expansive
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的服务需要初始化或丢弃正在进行中的请求是昂贵的
- en: If your service doesn't support advanced deployment strategies, such as rolling
    updates, or blue-green or canary deployments
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的服务不支持高级部署策略，例如滚动更新，蓝绿色或金丝雀部署
- en: When redeploying a new configuration file may pull in unrelated code changes
    from source control that are not ready for deployment yet
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新部署时，新的配置文件可能会从源代码控制中拉取未准备好部署的不相关代码更改
- en: When should you avoid dynamic configuration?
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时应避免动态配置？
- en: However, dynamic configuration is not a panacea for all situations. If you want
    to play it totally safe, then restarting your service when configuration changes
    makes things easier to comprehend and analyze. That being said, microservices
    are often simple enough that you can grasp all the implications of configuration
    changes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，动态配置并非适用于所有情况。如果您想要完全安全，那么在配置更改时重新启动服务会使事情更容易理解和分析。也就是说，微服务通常足够简单，您可以理解配置更改的所有影响。
- en: 'In the following situations, it may be better to avoid dynamic configuration:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，最好避免动态配置：
- en: Regulated services where configuration change must go through a vetting and
    approval process
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受监管的服务，配置更改必须经过审查和批准流程
- en: Critical services where the low risk of static configuration trumps any benefit
    of dynamic configuration
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键服务，静态配置的低风险胜过动态配置的任何好处
- en: A dynamic configuration mechanism doesn't exist and the benefits don't justify
    the development of such a mechanism
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态配置机制不存在，而且好处不足以证明开发这样的机制是合理的
- en: Existing system with a large number of services where the benefits of migration
    to a dynamic configuration doesn't justify the cost
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有系统具有大量服务，迁移到动态配置的好处不足以证明成本
- en: Advanced deployment strategies provide the benefits of dynamic configuration
    with static configuration and restarts/redeployments
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级部署策略提供了动态配置的好处，静态配置和重新启动/重新部署
- en: The added complexity of keeping track of and auditing configuration changes
    is too high
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪和审计配置更改的复杂性太高
- en: Remote configuration store
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程配置存储
- en: 'One of the options for dynamic configuration is a remote configuration store.
    All service instances can periodically query the configuration store, check whether
    the configuration has changed, and read the new configuration when it does. Possible
    options include the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 动态配置的一个选项是远程配置存储。所有服务实例可以定期查询配置存储，检查配置是否已更改，并在更改时读取新配置。可能的选项包括以下内容：
- en: Relational databases (Postgres, MySQL)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系数据库（Postgres，MySQL）
- en: Key–value stores (Etcd, Redis)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键-值存储（Etcd，Redis）
- en: Shared filesystems (NFS, EFS)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享文件系统（NFS，EFS）
- en: In general, if all/most of your services already work with a particular type
    of store, it is often simpler to put your dynamic configuration there. An anti-pattern
    is to store the configuration in the same store as the service-persistent store.
    The problem here is that the configuration will be spread across multiple data
    stores, and some configuration changes are central. It will be difficult to manage,
    keep track of, and audit configuration changes across all services.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，如果您的所有/大多数服务已经使用特定类型的存储，通常将动态配置放在那里会更简单。反模式是将配置存储在与服务持久存储相同的存储中。问题在于配置将分布在多个数据存储中，而且一些配置更改是中心化的。跨所有服务管理、跟踪和审计配置更改将会很困难。
- en: Remote configuration service
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程配置服务
- en: A more advanced approach is to create a dedicated configuration service. The
    purpose of this service is to provide a one-stop shop for all configuration needs.
    Each service will only have access to its configuration, and it's easy to implement
    control mechanisms for each and every configuration change. The downside of a
    configuration service is that you need to build it and maintain it. It can become
    a **single point of failure** (**SPOF**) too, if you're not careful.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的方法是创建一个专门的配置服务。此服务的目的是为所有配置需求提供一站式服务。每个服务将仅访问其配置，并且很容易为每个配置更改实现控制机制。配置服务的缺点是您需要构建它并进行维护。如果不小心的话，它也可能成为**单点故障**（SPOF）。
- en: So far, we have covered the many options for system configurations in great
    detail. Now, it's time to study what Kubernetes brings to the table.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经非常详细地介绍了系统配置的许多选项。现在，是时候研究一下Kubernetes带来了什么了。
- en: Configuring microservices with Kubernetes
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes配置微服务
- en: 'With Kubernetes or any container orchestrator, you have an interesting mix
    of configuration options. Kubernetes runs your containers for you. There is no
    way to set different environment options and command-line arguments for a specific
    run because Kubernetes decides when and where to run your container. What you
    can do is embed configuration files in your Docker image or change the command
    it is running; however, that means baking a new image for each configuration change
    and deploying it to your cluster. It''s not the end of the world, but it''s a
    heavyweight operation. You can also use the dynamic configuration options I mentioned
    earlier:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes或任何容器编排器，您有各种有趣的配置选项。Kubernetes为您运行容器。无法为特定运行设置不同的环境选项和命令行参数，因为Kubernetes决定何时何地运行容器。您可以将配置文件嵌入到Docker镜像中或更改其运行的命令；但是，这意味着为每个配置更改烘烤新镜像并将其部署到集群中。这并不是世界末日，但这是一个繁重的操作。您还可以使用我之前提到的动态配置选项：
- en: Remote configuration store
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程配置存储
- en: Remote configuration service
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程配置服务
- en: However, Kubernetes has some very neat tricks when it comes to dynamic configuration.
    The most innovative dynamic configuration mechanism is ConfigMaps. You can also
    get much fancier with custom resources. Let's dive in.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当涉及到动态配置时，Kubernetes有一些非常巧妙的技巧。最创新的动态配置机制是ConfigMaps。您还可以使用自定义资源更加复杂。让我们深入了解一下。
- en: Working with Kubernetes ConfigMaps
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes ConfigMaps
- en: 'ConfigMaps are Kubernetes resources that are managed by Kubernetes per namespace,
    and can be referenced by any pod or container. Here is the ConfigMap for the `link-manager`
    service:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMaps是由Kubernetes每个命名空间管理的Kubernetes资源，并且可以被任何pod或容器引用。这是`link-manager`服务的ConfigMap：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `link-manager` deployment resource imports it into the pod by using the
    `envFrom` key:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`link-manager`部署资源通过使用`envFrom`键将其导入到pod中：'
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The effect of this is that the key–value pairs in the ConfigMap''s `data` section
    are projected as environment variables when the `link-manager` service runs:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的效果是，当`link-manager`服务运行时，ConfigMap的`data`部分中的键值对将被投影为环境变量：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s see how Argo CD visualizes that the `link-manager` service has a ConfigMap.
    Note the top box named `link-service-config`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Argo CD如何可视化`link-manager`服务具有ConfigMap。请注意名为`link-service-config`的顶部框：
- en: '![](assets/b71de303-e97d-4664-a197-b5c73ba0ac54.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b71de303-e97d-4664-a197-b5c73ba0ac54.png)'
- en: 'You can even drill down and inspect the ConfigMap itself from the Argo CD UI
    by clicking on the ConfigMap box. Very slick:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以通过单击ConfigMap框从Argo CD UI中深入检查ConfigMap本身。非常漂亮。
- en: '![](assets/9bb535b3-a36d-4b39-ac03-0f0f9932b31a.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9bb535b3-a36d-4b39-ac03-0f0f9932b31a.png)'
- en: 'Note that since the ConfigMap is consumed as environment variables, this is
    static configuration. If you want to change any of it, you''ll need to restart
    the service. In Kubernetes, this can be done in a couple of ways:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于ConfigMap作为环境变量被消耗，这是静态配置。如果你想改变其中任何内容，你需要重新启动服务。在Kubernetes中，可以通过几种方式来实现：
- en: Killing the pods (the replica set of the deployment will create new pods)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杀死pod（部署的副本集将创建新的pod）
- en: Deleting and recreating the deployment (this has the same effect, but you don't
    need to kill pods explicitly)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除并重新创建部署（这有相同的效果，但不需要显式杀死pod）
- en: Applying some other change and redeploying
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用其他更改并重新部署
- en: 'Let''s see how the code uses it. This code can be found at [svc/link_manager/service/link_manager_service.go](https://github.com/the-gigi/delinkcious/blob/14c91f1c675dea9729d80876a3798897b925712a/svc/link_service/service/link_service.go#L37):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码如何使用它。这段代码可以在[svc/link_manager/service/link_manager_service.go](https://github.com/the-gigi/delinkcious/blob/14c91f1c675dea9729d80876a3798897b925712a/svc/link_service/service/link_service.go#L37)找到：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `os.Getenv()` standard library function gets `PORT` and `MAX_LINKS_PER_USER`
    from the environment. This is great because it allows us to test the service outside
    of the Kubernetes cluster and still configure it properly. For example, the link
    service end-to-end test—which is designed for local testing outside of Kubernetes—sets
    the environment variables before launching the social graph manager and the `link-manager`
    services:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.Getenv()`标准库函数从环境中获取`PORT`和`MAX_LINKS_PER_USER`。这很棒，因为它允许我们在Kubernetes集群之外测试服务，并正确配置它。例如，链接服务端到端测试——专为Kubernetes之外的本地测试设计——在启动社交图管理器和`link-manager`服务之前设置环境变量：'
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we've looked at how Delinkcious uses ConfigMaps, let's move on to the
    nuts and bolts of working with ConfigMaps.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过Delinkcious如何使用ConfigMaps，让我们继续进行ConfigMaps的工作细节。
- en: Creating and managing ConfigMaps
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和管理ConfigMaps
- en: 'Kubernetes gives you multiple ways to create ConfigMaps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了多种创建ConfigMaps的方法：
- en: From command-line values
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行值
- en: From one or more files
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个或多个文件
- en: From a whole directory
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从整个目录
- en: By directly creating a ConfigMap YAML manifest
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过直接创建ConfigMap YAML清单
- en: 'In the end, all ConfigMaps are a set of key–value pairs. What the keys and
    values are depends on the method of creating the ConfigMap. When playing with
    ConfigMaps, I find it useful to use the `--dry-run` flag so that I can see what
    ConfigMap will be created before committing to actually creating it. Let''s look
    at some examples. Here is how to create a ConfigMap from command-line arguments:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有的ConfigMaps都是一组键值对。键和值取决于创建ConfigMap的方法。在玩ConfigMaps时，我发现使用`--dry-run`标志很有用，这样我就可以在实际创建之前看到将要创建的ConfigMap。让我们看一些例子。以下是如何从命令行参数创建ConfigMap：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method should be used mostly for playing around with ConfigMaps. You have
    to specify each config item individually with a cumbersome `--from-literal` argument.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法主要用于玩转ConfigMaps。您必须使用繁琐的`--from-literal`参数逐个指定每个配置项。
- en: 'Creating a ConfigMap from a file is a much more viable method. It works well
    with the GitOps concept, where you can keep a history of the source configuration
    files that are used to create your ConfigMaps. We can create a very simple YAML
    file called `comics.yaml`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件创建ConfigMap是一种更可行的方法。它与GitOps概念很好地配合，您可以保留用于创建ConfigMaps的源配置文件的历史记录。我们可以创建一个非常简单的名为`comics.yaml`的YAML文件：
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, let''s create a ConfigMap from this file using the following command
    (well, just a dry `run`):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用以下命令从这个文件创建一个ConfigMap（好吧，只是一个干燥的`run`）：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'What''s interesting here is that the entire contents of the file are mapped
    to a single key: `comics.yaml`. The value is the entire contents of the file.
    The `|+` in YAML means that the following multiline block is one value. If we
    add additional `--from-file` arguments, then each file will have its own key in
    the ConfigMap. Similarly, if the argument to `--from-file` is a directory, then
    each file in the directory becomes a key in the ConfigMap.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，文件的整个内容都映射到一个键：`comics.yaml`。值是文件的整个内容。在YAML中，`|+`表示以下的多行块是一个值。如果我们添加额外的`--from-file`参数，那么每个文件将在ConfigMap中有自己的键。同样，如果`--from-file`的参数是一个目录，那么目录中的每个文件都将成为ConfigMap中的一个键。
- en: 'Finally, let''s look at a manually constructed ConfigMap. It''s not that difficult
    to do this: just add a bunch of key–value pairs under the `data` section:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一个手动构建的ConfigMap。这并不难做到：只需在`data`部分下添加一堆键值对即可：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we created dedicated `SUPERHERO` and `VILLAIN` keys.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了专门的`SUPERHERO`和`VILLAIN`键。
- en: 'Let''s see how pods can consume these ConfigMaps. The pod gets its environment
    from the `env-config` ConfigMap. It executes a command that watches the values
    of the `SUPERHERO` and `VILLAIN` environment variables and every two seconds echos
    the current values:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看pod如何消耗这些ConfigMap。pod从`env-config` ConfigMap中获取其环境。它执行一个命令，监视`SUPERHERO`和`VILLAIN`环境变量的值，并且每两秒钟回显当前值：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The ConfigMap must be created before the pod is started!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在启动pod之前创建ConfigMap！
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `kubectl` command is super useful for checking the output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl命令非常有用，可以用来检查输出：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As expected, the values match the ConfigMap. But what happens if we change
    the ConfigMap? The `kubectl edit configmap` command lets you update an existing
    ConfigMap in your editor:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，值与ConfigMap匹配。但是如果我们更改ConfigMap会发生什么呢？`kubectl edit configmap`命令允许您在编辑器中更新现有的ConfigMap：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''ve changed the superhero and villain to Batman and Joker. Let''s verify
    the changes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将超级英雄和反派更改为Batman和Joker。让我们验证一下更改：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The new values are there. Let''s check our pod logs. Nothing should change
    because the pod consumes the ConfigMap as environment variables that can''t be
    changed from the outside while the pod is running:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 新的值已经存在。让我们检查一下pod日志。什么都不应该改变，因为pod将ConfigMap作为环境变量消耗，而在pod运行时无法从外部更改：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, if we delete and recreate the pod, the picture is different:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们删除并重新创建pod，情况就不同了：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'I saved the best for last. Let''s look at some dynamic configuration in action.
    The pod named `some-other-pod` is consuming the ConfigMap called `file-config`
    as a file. First, it creates a volume called `config-volume` that gets populated
    from the `file-config` ConfigMap. Then, this volume is mounted into `/etc/config`.
    The command that''s running is simply watching the `/etc/config/comics` file:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我把最好的留到了最后。让我们看看一些动态配置的实际操作。名为`some-other-pod`的pod正在将名为`file-config`的ConfigMap作为文件进行消耗。首先，它创建了一个名为`config-volume`的卷，该卷从`file-config`
    ConfigMap中获取数据。然后，这个卷被挂载到`/etc/config`中。正在运行的命令只是简单地监视`/etc/config/comics`文件：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is the `file-config` ConfigMap:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`file-config` ConfigMap：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It has a key called `comics` (the filename), and the value is a multiline YAML
    string with superhero and villain entries (`Doctor Strange` and `Thanos`). When
    all is said and done, the contents of the comics key under the ConfigMap `data`
    section will be mounted inside the container as the `/etc/config/comics` file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个名为`comics`（文件名）的键，值是一个多行的YAML字符串，其中包含超级英雄和反派条目（`Doctor Strange`和`Thanos`）。说到做到，ConfigMap
    `data`部分下的comics键的内容将被挂载到容器中作为`/etc/config/comics`文件。
- en: 'Let''s verify this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证一下：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is looking good so far. Now for the main attraction. Let''s change the
    contents of the ConfigMap to the superhero Wonder Woman and villain Medusa. We''ll
    use the `kubectl apply` command this time instead of deleting and recreating the
    ConfigMap. The ConfigMap is updated properly, but we also get a warning for our
    efforts (it''s OK to ignore this):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切看起来都很好。现在是主要的吸引力。让我们将ConfigMap的内容更改为超级英雄神奇女侠和反派美杜莎。这次我们将使用`kubectl apply`命令，而不是删除和重新创建ConfigMap。ConfigMap被正确更新，但我们也会收到一个警告（可以忽略）：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note the preceding annotation. It's interesting that it stores the last applied
    change, which is available in the data and not the previous values for historical
    context.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面的注释。有趣的是，它存储了最后一次应用的更改，这在数据中是可用的，而不是以前的值用于历史上下文。
- en: Now, let's check the logs again *without* restarting the pod!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次检查日志，而不重新启动pod！
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Yes, this has been a great success! The pod now prints the updated configuration
    information with no need to restart.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是一个巨大的成功！现在pod打印出了更新的配置信息，无需重新启动。
- en: In this section, we have demonstrated how dynamic configuration works using
    ConfigMaps mounted as files. Let's look at what we should do when the configuration
    needs of large-scale systems are developed by multiple teams over long periods
    of time.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们演示了如何使用ConfigMaps作为文件挂载的动态配置。让我们看看当大规模系统的配置需求由多个团队在长时间内开发时，我们应该做些什么。
- en: Applying advanced configuration
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用高级配置
- en: For large-scale systems with lots of services and lots of configuration, you
    may want to have services that consume multiple ConfigMaps. This is separate from
    the fact that a single ConfigMap may contain multiple files, directories, and
    literal values, in any combination. For example, each service may have its own
    specific configuration, but it might also use some shared libraries that need
    to be configured as well. In this scenario, you can have one ConfigMap for the
    shared library and a separate ConfigMap for each service. In this case, the services
    will consume both their ConfigMap and the shared library's ConfigMap.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有大量服务和大量配置的大规模系统，您可能希望有一些消耗多个ConfigMaps的服务。这与单个ConfigMap可能包含多个文件、目录和文字值的事实是分开的，可以任意组合。例如，每个服务可能有自己特定的配置，但也可能使用一些需要配置的共享库。在这种情况下，您可以为共享库和每个服务单独创建一个ConfigMap。在这种情况下，服务将同时消耗它们自己的ConfigMap和共享库的ConfigMap。
- en: 'Another common scenario is to have different configuration for different environments
    (development, staging, and production). Since in Kubernetes each environment typically
    has its own namespace, you need to be creative here. ConfigMaps are scoped to
    their namespace. This means that even if your configuration across environments
    is identical, you still need to create a copy in each namespace. There are various
    solutions that you can use to manage this proliferation of configuration files
    and Kubernetes manifests in general. I will not get into the details of these,
    and will just mention some of the more popular options here in no particular order:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的情况是针对不同环境（开发、暂存和生产）有不同的配置。由于在Kubernetes中，每个环境通常都有自己的命名空间，您需要在这里有创意。ConfigMaps的作用域是它们的命名空间。这意味着即使您在各个环境中的配置是相同的，您仍然需要在每个命名空间中创建一个副本。有各种解决方案可以用来管理这种配置文件和Kubernetes清单的泛滥。我不会详细介绍这些内容，只是简单提一下一些更受欢迎的选项，没有特定顺序：
- en: '**Helm**: [https://helm.sh/](https://helm.sh/)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Helm: [https://helm.sh/](https://helm.sh/)'
- en: '**Kustomize**: [https://kustomize.io/](https://kustomize.io/)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kustomize: [https://kustomize.io/](https://kustomize.io/)'
- en: '**Jsonnet**: [https://jsonnet.org/articles/kubernetes.html](https://jsonnet.org/articles/kubernetes.html)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Jsonnet: [https://jsonnet.org/articles/kubernetes.html](https://jsonnet.org/articles/kubernetes.html)'
- en: '**Ksonnet**: [https://github.com/ksonnet/ksonnet](https://github.com/ksonnet/ksonnet)
    (not maintained anymore)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ksonnet**：[https://github.com/ksonnet/ksonnet](https://github.com/ksonnet/ksonnet)（不再维护）'
- en: You can also build some tooling yourself to do this. In the next section, we'll
    look at another alternative, which is very cool but more complicated—custom resources.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以自己构建一些工具来执行此操作。在下一节中，我们将看另一种选择，这种选择非常酷，但更复杂——自定义资源。
- en: Kubernetes custom resources
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes自定义资源
- en: Kubernetes is a very extensible platform. You can add your own resources to
    the Kubernetes API and enjoy all the benefits of the API machinery, including
    kubectl support to manage them. Yes, it's that good. The first thing you need
    to do is define a custom resource, also known as a CRD. The definition will specify
    endpoints on the Kubernetes API, the version, scope, kind, and the names that
    are used to interact with resources of this new type.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是一个非常可扩展的平台。您可以将自己的资源添加到Kubernetes API中，并享受API机制的所有好处，包括kubectl支持来管理它们。是的，就是这么好。您需要做的第一件事是定义自定义资源，也称为CRD。定义将指定Kubernetes
    API上的端点、版本、范围、种类以及与这种新类型的资源交互时使用的名称。
- en: 'Here is a superheroes CRD:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个超级英雄CRD：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Custom resources are available from all namespaces. The scope is relevant when
    constructing the URL from which it will be available and when deleting all objects
    from a namespace (a namespace scope CRD will be deleted with its namespace).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资源可以从所有命名空间中访问。当构建URL时，范围是相关的，并且在删除命名空间中的所有对象时（命名空间范围CRD将与其命名空间一起被删除）。
- en: 'Let''s create some superhero resources. The `antman` superhero has the same
    API version and kind that is defined in the superheroes CRD. It has a name in
    `metadata`, and `spec` is totally open. You can define whatever fields you want
    there. In this case, the fields are `superpower` and `size`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些超级英雄资源。`antman`超级英雄具有与超级英雄CRD中定义的相同的API版本和种类。它在`metadata`中有一个名字，而`spec`是完全开放的。你可以在那里定义任何字段。在这种情况下，字段是`superpower`和`size`：
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s check out the Hulk. It''s very similar, but also has a color field in
    its `spec`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看绿巨人。它非常相似，但在其`spec`中还有一个颜色字段：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s create the whole gang, starting with the CRD itself:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从CRD本身开始创建整个团队：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now let''s examine them with `kubectl`. We can use the short name, `hr`, here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用`kubectl`来检查它们。我们可以在这里使用`hr`的简称：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can also check the details of the superheroes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查超级英雄的详细信息：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is cool, but what can you do with custom resources? Well, a lot. If you
    think about it, you get a free CRUD API with CLI support and reliable persistent
    storage. Just invent your object model and create, get, list, update, and delete
    as many custom resources as you want. But it goes much further: you can have your
    own controller that watches over your custom resources and takes action when needed.
    This is actually how Argo CD works, as you can see from the following command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷，但自定义资源能做什么？很多。如果您考虑一下，您将获得一个带有CLI支持和可靠持久存储的免费CRUD API。只需发明您的对象模型，并创建、获取、列出、更新和删除尽可能多的自定义资源。但它还可以更进一步：您可以拥有自己的控制器，监视您的自定义资源，并在需要时采取行动。这实际上就是Argo
    CD的工作原理，您可以从以下命令中看到：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How does that help with configuration? Since custom resources are available
    across the cluster, you can use them for shared configuration across namespaces.
    CRDs can serve as centralized remote configuration services, as we discussed earlier
    in the *Dynamic configuration* section, but you don't need to implement anything
    yourself. Another option is to create a controller that watches over these CRDs
    and then copies them to proper ConfigMaps for each namespace automatically. You
    are only limited by your imagination with Kubernetes. The bottom line is that
    for large complicated systems where managing configuration is a large endeavor,
    Kubernetes gives you tools to scale your configuration. Let's turn our attention
    to one aspect of configuration that often causes a lot of difficulties on other
    systems—service discovery.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何帮助配置？由于自定义资源在整个集群中可用，你可以将它们用于跨命名空间的共享配置。CRDs可以作为集中的远程配置服务，正如我们在*动态配置*部分中讨论的那样，但你不需要自己实现任何东西。另一个选择是创建一个监视这些CRDs的控制器，然后自动将它们复制到适当的ConfigMaps中。在Kubernetes中，你只受到你的想象力的限制。最重要的是，对于管理配置是一项艰巨任务的大型复杂系统，Kubernetes为你提供了扩展配置的工具。让我们把注意力转向配置的一个方面，这在其他系统上经常会引起很多困难——服务发现。
- en: Service discovery
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: 'Kubernetes has built-in support for service discovery, without any additional
    work having to be done on your part. Each service has an endpoints resource that
    Kubernetes keeps up to date with the addresses of all the backing pods for that
    service. Here are the endpoints for a single node Minikube cluster. Note how each
    pod has its own IP address, even though there is only one physical node. This
    demonstrates the vaunted flat networking model of Kubernetes. Only the Kubernetes
    API server has a public IP address:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes内置支持服务发现，无需在你的部分进行任何额外的工作。每个服务都有一个endpoints资源，Kubernetes会及时更新该资源，其中包含该服务所有支持的pod的地址。以下是单节点Minikube集群的endpoints。请注意，即使只有一个物理节点，每个pod都有自己的IP地址。这展示了Kubernetes的著名的扁平网络模型。只有Kubernetes
    API服务器有一个公共IP地址。
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Normally, you don't deal directly with the endpoints resource. Each service
    is automatically exposed to other services in the cluster via both DNS and environment
    variables.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不会直接处理endpoints资源。每个服务都会自动通过DNS和环境变量向集群中的其他服务公开。
- en: If you deal with the discovery of external services running outside the Kubernetes
    cluster, then you're on your own. A good approach could be to add them to a ConfigMap
    and update it when those external services need to change. If you need to manage
    secret credentials to access those external services (which is very likely), it's
    best to put those in Kubernetes secrets, which we will cover in the next chapter.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处理发现在Kubernetes集群之外运行的外部服务，那么你就得自己解决。一个好的方法可能是将它们添加到ConfigMap中，并在这些外部服务需要更改时进行更新。如果你需要管理访问这些外部服务的秘密凭据（这很可能），最好将它们放在Kubernetes
    secrets中，我们将在下一章中介绍。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed everything related to configuration, not including
    secret management. First, we considered classic configuration, and then we looked
    at dynamic configuration, focusing on remote configure stores and remote configuration
    services.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了与配置相关的一切，但不包括秘密管理。首先，我们考虑了经典配置，然后我们看了动态配置，重点是远程配置存储和远程配置服务。
- en: Next, we discussed Kubernetes-specific options and in particular ConfigMaps.
    We went over all the ways a ConfigMap can be created and managed. We also saw
    how a pod can consume a ConfigMap as either environment variables (static configuration)
    or as configuration files in mounted volumes that get updated automatically when
    the corresponding ConfigMap is modified by an operator. Finally, we looked at
    even more powerful options, such as custom resources, and discussed the special
    yet very important case of service discovery. At this point, you should have a
    clear picture of configuration in general, and the available options to configure
    microservices either traditionally or in Kubernetes-specific ways.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了Kubernetes特定的选项，特别是ConfigMaps。我们介绍了ConfigMap可以被创建和管理的所有方式。我们还看到了一个pod可以如何使用ConfigMap，可以作为环境变量（静态配置），也可以作为挂载卷中的配置文件，当相应的ConfigMap被操作员修改时，这些配置文件会自动更新。最后，我们看了更强大的选项，比如自定义资源，并讨论了服务发现这个特殊但非常重要的案例。到这一点，你应该对一般的配置有一个清晰的认识，并了解了在传统方式或Kubernetes特定方式下配置微服务的可用选项。
- en: In the next chapter, we will look at the crucial topic of security. Microservice-based
    systems that are deployed in Kubernetes clusters often provide essential services
    and manage critical data. Securing both the data and the system itself is, in
    many cases, a top priority. Kubernetes provides multiple mechanisms across different
    layers to assist in building secure systems when following best practices.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下关键的安全主题。部署在Kubernetes集群中的基于微服务的系统通常提供基本服务并管理关键数据。在许多情况下，保护数据和系统本身是首要任务。Kubernetes在遵循最佳实践时提供了多种机制来协助构建安全系统。
- en: Further reading
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some resources for you to use so that you can understand the fine
    details of the concepts and mechanisms we discussed in this chapter:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些资源供您使用，以便您可以了解本章讨论的概念和机制的细节：
- en: '**12 Factor Apps**: [https://12factor.net/](https://12factor.net/)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**12因素应用**：[https://12factor.net/](https://12factor.net/)'
- en: '**Program Configuration in Python**: [http://www.drdobbs.com/open-source/program-configuration-in-python/240169310](http://www.drdobbs.com/open-source/program-configuration-in-python/240169310)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python中的程序配置**：[http://www.drdobbs.com/open-source/program-configuration-in-python/240169310](http://www.drdobbs.com/open-source/program-configuration-in-python/240169310)'
- en: '**Building a dynamic configuration service**: [https://www.compose.com/articles/building-a-dynamic-configuration-service-with-etcd-and-python/](https://www.compose.com/articles/building-a-dynamic-configuration-service-with-etcd-and-python/)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建动态配置服务**：[https://www.compose.com/articles/building-a-dynamic-configuration-service-with-etcd-and-python/](https://www.compose.com/articles/building-a-dynamic-configuration-service-with-etcd-and-python/)'
- en: '**Extending Kubernetes (video)**: [https://www.youtube.com/watch?v=qVZnU8rXAEU](https://www.youtube.com/watch?v=qVZnU8rXAEU)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展Kubernetes（视频）**：[https://www.youtube.com/watch?v=qVZnU8rXAEU](https://www.youtube.com/watch?v=qVZnU8rXAEU)'
