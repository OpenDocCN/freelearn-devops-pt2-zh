["```\n$ kubectl get svc\nNAME                TYPE      CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE\napi-gateway      LoadBalancer   10.103.167.102  <pending> 80:31965/TCP  6m2s\nkubernetes         ClusterIP    10.96.0.1         <none>    443/TCP      25m\nlink-db            ClusterIP    10.107.131.61     <none>    5432/TCP     8m53s \nlink-manager       ClusterIP    10.109.32.254     <none>    8080/TCP     8m53s\nnews-manager       ClusterIP    10.99.206.183     <none>    6060/TCP     7m45s\nnews-manager-redis ClusterIP     None             <none>    6379/TCP     7m45s\nsocial-graph-db    ClusterIP    10.106.164.24     <none>    5432/TCP     8m38s\nsocial-graph-manager ClusterIP   10.100.107.79    <none>    9090/TCP     8m37s\nuser-db             ClusterIP    None             <none>    5432/TCP     8m10s\nuser-manager        ClusterIP    10.108.45.93     <none>    7070/TCP     8m10s\n```", "```\n<service name>.<namespace>.svc.cluster.local\n```", "```\n$ dig +short social-graph-manager.default.svc.cluster.local\n10.107.162.99\n\n$ env | grep SOCIAL_GRAPH_MANAGER_SERVICE_HOST\nSOCIAL_GRAPH_MANAGER_SERVICE_HOST=10.107.162.99\n```", "```\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      svc: link\n      app: manager\n```", "```\n$ kubectl get endpoints\nNAME                   ENDPOINTS                                            AGE\napi-gateway            172.17.0.15:5000                                     1d\nkubernetes             192.168.99.137:8443                                  51d\nlink-db                172.17.0.19:5432                                     40d\n.\n.\n.\nsocial-graph-db        172.17.0.16:5432                                     50d\nsocial-graph-manager   172.17.0.18:9090                                     43d\n```", "```\n$ tree\n .\n \u251c\u2500\u2500 Dockerfile\n \u251c\u2500\u2500 README.md\n \u251c\u2500\u2500 api_gateway_service\n \u2502   \u251c\u2500\u2500 __init__.py\n \u2502   \u251c\u2500\u2500 api.py\n \u2502   \u251c\u2500\u2500 config.py\n \u2502   \u251c\u2500\u2500 news_client.py\n \u2502   \u251c\u2500\u2500 news_client_test.py\n \u2502   \u251c\u2500\u2500 news_pb2.py\n \u2502   \u251c\u2500\u2500 news_pb2_grpc.py\n \u2502   \u2514\u2500\u2500 resources.py\n \u251c\u2500\u2500 k8s\n \u2502   \u251c\u2500\u2500 api_gateway.yaml\n \u2502   \u251c\u2500\u2500 configmap.yaml\n \u2502   \u2514\u2500\u2500 secrets.yaml\n \u251c\u2500\u2500 requirements.txt\n \u251c\u2500\u2500 run.py\n \u2514\u2500\u2500 tests\n \u2514\u2500\u2500 api_gateway_service_test.py\n```", "```\nimport os\nfrom api_gateway_service.api import app\n\ndef main():\n    port = int(os.environ.get('PORT', 5000))\n    login_url = 'http://localhost:{}/login'.format(port)\n    print('If you run locally, browse to', login_url)\n    host = '0.0.0.0'\n    app.run(host=host, port=port)\n\nif __name__ == \"__main__\":\n    main()\n```", "```\n@app.route('/login')\ndef login():\n    callback = url_for('authorized', _external=True)\n    result = app.github.authorize(callback)\n    return result\n\n@app.route('/login/authorized')\ndef authorized():\n    resp = app.github.authorized_response()\n    if resp is None:\n        # return 'Access denied: reason=%s error=%s' % (\n        #     request.args['error'],\n        #     request.args['error_description']\n        # )\n        abort(401, message='Access denied!')\n    token = resp['access_token']\n    # Must be in a list or tuple because github auth code extracts the first\n    user = app.github.get('user', token=(token,))\n    user.data['access_token'] = token\n    return jsonify(user.data)\n\n@app.route('/logout')\ndef logout():\n    session.pop('github_token', None)\n    return 'OK'\n```", "```\ndef _get_user():\n    \"\"\"Get the user object or create it based on the token in the session\n\n    If there is no access token abort with 401 message\n    \"\"\"\n    if 'Access-Token' not in request.headers:\n        abort(401, message='Access Denied!')\n\n    token = request.headers['Access-Token']\n    user_data = github.get('user', token=dict(access_token=token)).data\n    if 'email' not in user_data:\n        abort(401, message='Access Denied!')\n\n    email = user_data['email']\n    name = user_data['name']\n\n    return name, email\n```", "```\nimport os\n\nfrom flask import Flask, url_for, session, jsonify\nfrom flask_oauthlib.client import OAuth\nfrom flask_restful import Api, abort\nfrom . import resources\nfrom .resources import Link\n```", "```\ndef create_app():\n    app = Flask(__name__)\n    app.config.from_object('api_gateway_service.config')\n    oauth = OAuth(app)\n    github = oauth.remote_app(\n        'github',\n        consumer_key=os.environ['GITHUB_CLIENT_ID'],\n        consumer_secret=os.environ['GITHUB_CLIENT_SECRET'],\n        request_token_params={'scope': 'user:email'},\n        base_url='https://api.github.com/',\n        request_token_url=None,\n        access_token_method='POST',\n        access_token_url='https://github.com/login/oauth/access_token',\n        authorize_url='https://github.com/login/oauth/authorize')\n    github._tokengetter = lambda: session.get('github_token')\n    resources.github = app.github = github\n```", "```\napi = Api(app)\n    resource_map = (\n        (Link, '/v1.0/links'),\n    )\n\n    for resource, route in resource_map:\n        api.add_resource(resource, route)\n\n    return app\n\napp = create_app()\n```", "```\nclass Link(Resource):\n    host = os.environ.get('LINK_MANAGER_SERVICE_HOST', 'localhost')\n    port = os.environ.get('LINK_MANAGER_SERVICE_PORT', '8080')\n    base_url = 'http://{}:{}/links'.format(host, port)\n\n    def get(self):\n        \"\"\"Get all links\n\n        If user doesn't exist create it (with no goals)\n        \"\"\"\n        username, email = _get_user()\n        parser = RequestParser()\n        parser.add_argument('url_regex', type=str, required=False)\n        parser.add_argument('title_regex', type=str, required=False)\n        parser.add_argument('description_regex', type=str, required=False)\n        parser.add_argument('tag', type=str, required=False)\n        parser.add_argument('start_token', type=str, required=False)\n        args = parser.parse_args()\n        args.update(username=username)\n        r = requests.get(self.base_url, params=args)\n\n        if not r.ok:\n            abort(r.status_code, message=r.content)\n\n        return r.json()\n```", "```\n$ docker images | grep g1g1.*0.3\ng1g1/delinkcious-user              0.3    07bcc08b1d73   38 hours ago    6.09MB\ng1g1/delinkcious-social-graph      0.3    0be0e9e55689   38 hours ago    6.37MB\ng1g1/delinkcious-news              0.3    0ccd600f2190   38 hours ago    8.94MB\ng1g1/delinkcious-link              0.3    9fcd7aaf9a98   38 hours ago    6.95MB\ng1g1/delinkcious-api-gateway       0.3    d5778d95219d   38 hours ago    493MB\n```", "```\nFROM python:alpine\nRUN apk add build-base\nCOPY requirements.txt /tmp\nWORKDIR /tmp\nRUN pip install -r requirements.txt\n```", "```\nrequests-oauthlib==1.1.0\nFlask-OAuthlib==0.9.5\nFlask-RESTful==0.3.7\ngrpcio==1.18.0\ngrpcio-tools==1.18.0\n```", "```\nIMAGE=g1g1/delinkcious-python-flask-grpc:0.1\ndocker build . -t $IMAGE\ndocker push $IMAGE\n```", "```\nFROM g1g1/delinkcious-python-flask-grpc:0.1\nMAINTAINER Gigi Sayfan \"the.gigi@gmail.com\"\nCOPY . /api_gateway_service\nWORKDIR /api_gateway_service\nEXPOSE 5000\nENTRYPOINT python run.py\n```", "```\n$ minikube addons enable ingress \n ingress was successfully enabled\n```", "```\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: api-gateway\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\nspec:\n  rules:\n  - host: delinkcio.us\n    http:\n      paths:\n      - path: /*\n        backend:\n          serviceName: api-gateway\n          servicePort: 80\n```", "```\n$ minikube service api-gateway --url\nhttp://192.168.99.138:31658\n```", "```\n$ export DELINKCIOUS_URL=$(minikube service api-gateway --url)\n```", "```\n$ export DELINKCIOUS_TOKEN=def7de18d9c05ce139e37140871a9d16fd37ea9d\n```", "```\n$ http \"${DELINKCIOUS_URL}/v1.0/links\" \"Access-Token: ${DELINKCIOUS_TOKEN}\"\nHTTP/1.0 200 OK\nContent-Length: 27\nContent-Type: application/json\nDate: Mon, 04 Mar 2019 00:52:18 GMT\nServer: Werkzeug/0.14.1 Python/3.7.2\n\n{\n    \"err\": \"\",\n    \"links\": null\n}\n```", "```\n$ http POST \"${DELINKCIOUS_URL}/v1.0/links\" \"Access-Token: ${DELINKCIOUS_TOKEN}\" url=http://gg.com title=example\nHTTP/1.0 200 OK\nContent-Length: 12\nContent-Type: application/json\nDate: Mon, 04 Mar 2019 00:52:49 GMT\nServer: Werkzeug/0.14.1 Python/3.7.2\n\n{\n    \"err\": \"\"\n}\n```", "```\n$ http POST \"${DELINKCIOUS_URL}/v1.0/links\" \"Access-Token: ${DELINKCIOUS_TOKEN}\" url=http://gg2.com title=example\nHTTP/1.0 200 OK\nContent-Length: 12\nContent-Type: application/json\nDate: Mon, 04 Mar 2019 00:52:49 GMT\nServer: Werkzeug/0.14.1 Python/3.7.2\n\n{\n    \"err\": \"\"\n}\n```", "```\n$ http \"${DELINKCIOUS_URL}/v1.0/links\" \"Access-Token: ${DELINKCIOUS_TOKEN}\"\nHTTP/1.0 200 OK\nContent-Length: 330\nContent-Type: application/json\nDate: Mon, 04 Mar 2019 00:52:52 GMT\nServer: Werkzeug/0.14.1 Python/3.7.2\n\n{\n    \"err\": \"\",\n    \"links\": [\n        {\n            \"CreatedAt\": \"2019-03-04T00:52:35Z\",\n            \"Description\": \"\",\n            \"Tags\": null,\n            \"Title\": \"example\",\n            \"UpdatedAt\": \"2019-03-04T00:52:35Z\",\n            \"Url\": \"http://gg.com\"\n        },\n        {\n            \"CreatedAt\": \"2019-03-04T00:52:48Z\",\n            \"Description\": \"\",\n            \"Tags\": null,\n            \"Title\": \"example\",\n            \"UpdatedAt\": \"2019-03-04T00:52:48Z\",\n            \"Url\": \"http://gg2.com\"\n        }\n    ]\n}\n```", "```\ntype NewsManager interface {\n        GetNews(request GetNewsRequest) (GetNewsResult, error)\n}\n\ntype GetNewsRequest struct {\n        Username   string\n        StartToken string\n}\n\ntype Event struct {\n        EventType EventTypeEnum\n        Username  string\n        Url       string\n        Timestamp time.Time\n}\n\ntype GetNewsResult struct {\n        Events    []*Event\n        NextToken string\n}\n```", "```\npackage news_manager\n\nimport (\n        \"errors\"\n        \"github.com/the-gigi/delinkcious/pkg/link_manager_events\"\n        om \"github.com/the-gigi/delinkcious/pkg/object_model\"\n        \"strconv\"\n        \"time\"\n)\n\ntype NewsManager struct {\n        eventStore *InMemoryNewsStore\n}\n\nfunc (m *NewsManager) GetNews(req om.GetNewsRequest) (resp om.GetNewsResult, err error) {\n        if req.Username == \"\" {\n                err = errors.New(\"user name can't be empty\")\n                return\n        }\n\n        startIndex := 0\n        if req.StartToken != \"\" {\n                startIndex, err := strconv.Atoi(req.StartToken)\n                if err != nil || startIndex < 0 {\n                        err = errors.New(\"invalid start token: \" + req.StartToken)\n                        return resp, err\n                }\n        }\n\n        events, nextIndex, err := m.eventStore.GetNews(req.Username, startIndex)\n        if err != nil {\n                return\n        }\n\n        resp.Events = events\n        if nextIndex != -1 {\n                resp.NextToken = strconv.Itoa(nextIndex)\n        }\n\n        return\n}\n```", "```\npackage news_manager\n\nimport (\n        \"errors\"\n        om \"github.com/the-gigi/delinkcious/pkg/object_model\"\n)\n\nconst maxPageSize = 10\n\n// User events are a map of username:userEvents\ntype userEvents map[string][]*om.Event\n\n// InMemoryNewsStore manages a UserEvents data structure\ntype InMemoryNewsStore struct {\n        userEvents userEvents\n}\n\nfunc NewInMemoryNewsStore() *InMemoryNewsStore {\n        return &InMemoryNewsStore{userEvents{}}\n}\n```", "```\nfunc (m *InMemoryNewsStore) GetNews(username string, startIndex int) (events []*om.Event, nextIndex int, err error) {\n        userEvents := m.userEvents[username]\n        if startIndex > len(userEvents) {\n                err = errors.New(\"Index out of bounds\")\n                return\n        }\n\n        pageSize := len(userEvents) - startIndex\n        if pageSize > maxPageSize {\n                pageSize = maxPageSize\n                nextIndex = startIndex + maxPageSize\n        } else {\n                nextIndex = -1\n        }\n\n        events = userEvents[startIndex : startIndex+pageSize]\n        return\n}\n```", "```\nfunc (m *InMemoryNewsStore) AddEvent(username string, event *om.Event) (err error) {\n        if username == \"\" {\n                err = errors.New(\"user name can't be empty\")\n                return\n        }\n\n        if event == nil {\n                err = errors.New(\"event can't be nil\")\n                return\n        }\n\n        if m.userEvents[username] == nil {\n                m.userEvents[username] = []*om.Event{}\n        }\n\n        m.userEvents[username] = append(m.userEvents[username], event)\n        return\n}\n```", "```\nsyntax = \"proto3\";\npackage pb;\n\nimport \"google/protobuf/timestamp.proto\";\n\nservice News {\n    rpc GetNews(GetNewsRequest) returns (GetNewsResponse) {}\n}\n\nmessage GetNewsRequest {\n    string username = 1;\n    string startToken = 2;\n}\n\nenum EventType {\n    LINK_ADDED = 0;\n    LINK_UPDATED = 1;\n    LINK_DELETED = 2;\n}\n\nmessage Event  {\n        EventType eventType = 1;\n        string username = 2;\n        string url = 3;\n        google.protobuf.Timestamp timestamp = 4;\n}\n\nmessage GetNewsResponse {\n        repeated Event events = 1;\n        string nextToken = 2;\n    string err = 3;\n}\n```", "```\nprotoc --go_out=plugins=grpc:. news.proto\n```", "```\npython -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. news.proto\n```", "```\npackage service\n\nimport (\n        \"fmt\"\n        \"github.com/the-gigi/delinkcious/pb/news_service/pb\"\n        nm \"github.com/the-gigi/delinkcious/pkg/news_manager\"\n        \"google.golang.org/grpc\"\n        \"log\"\n        \"net\"\n        \"os\"\n)\n\nfunc Run() {\n        port := os.Getenv(\"PORT\")\n        if port == \"\" {\n                port = \"6060\"\n        }\n```", "```\nlistener, err := net.Listen(\"tcp\", \":\"+port)\n        if err != nil {\n                log.Fatal(err)\n        }\n```", "```\nnatsHostname := os.Getenv(\"NATS_CLUSTER_SERVICE_HOST\")\n        natsPort := os.Getenv(\"NATS_CLUSTER_SERVICE_PORT\")\n```", "```\nsvc, err := nm.NewNewsManager(natsHostname, natsPort)\n        if err != nil {\n                log.Fatal(err)\n        }\n\n        gRPCServer := grpc.NewServer()\n        newsServer := newNewsServer(svc)\n        pb.RegisterNewsServer(gRPCServer, newsServer)\n```", "```\nfmt.Printf(\"News service is listening on port %s...\\n\", port)\n        err = gRPCServer.Serve(listener)\n        fmt.Println(\"Serve() failed\", err)\n}\n```", "```\npackage service\n\nimport (\n        \"context\"\n        \"github.com/go-kit/kit/endpoint\"\n        grpctransport \"github.com/go-kit/kit/transport/grpc\"\n        \"github.com/golang/protobuf/ptypes/timestamp\"\n        \"github.com/the-gigi/delinkcious/pb/news_service/pb\"\n        om \"github.com/the-gigi/delinkcious/pkg/object_model\"\n)\n```", "```\nfunc newEvent(e *om.Event) (event *pb.Event) {\n        event = &pb.Event{\n                EventType: (pb.EventType)(e.EventType),\n                Username:  e.Username,\n                Url:       e.Url,\n        }\n\n        seconds := e.Timestamp.Unix()\n        nanos := (int32(e.Timestamp.UnixNano() - 1e9*seconds))\n        event.Timestamp = &timestamp.Timestamp{Seconds: seconds, Nanos: nanos}\n        return\n}\n```", "```\nfunc decodeGetNewsRequest(_ context.Context, r interface{}) (interface{}, error) {\n        request := r.(*pb.GetNewsRequest)\n        return om.GetNewsRequest{\n                Username:   request.Username,\n                StartToken: request.StartToken,\n        }, nil\n}\n\nfunc encodeGetNewsResponse(_ context.Context, r interface{}) (interface{}, error) {\n        return r, nil\n}\n```", "```\nfunc makeGetNewsEndpoint(svc om.NewsManager) endpoint.Endpoint {\n        return func(_ context.Context, request interface{}) (interface{}, error) {\n                req := request.(om.GetNewsRequest)\n                r, err := svc.GetNews(req)\n                res := &pb.GetNewsResponse{\n                        Events:    []*pb.Event{},\n                        NextToken: r.NextToken,\n                }\n                if err != nil {\n                        res.Err = err.Error()\n                }\n                for _, e := range r.Events {\n                        event := newEvent(e)\n                        res.Events = append(res.Events, event)\n                }\n                return res, nil\n        }\n}\n```", "```\ntype handler struct {\n        getNews grpctransport.Handler\n}\n\nfunc (s *handler) GetNews(ctx context.Context, r *pb.GetNewsRequest) (*pb.GetNewsResponse, error) {\n        _, resp, err := s.getNews.ServeGRPC(ctx, r)\n        if err != nil {\n                return nil, err\n        }\n\n        return resp.(*pb.GetNewsResponse), nil\n}\n```", "```\nfunc newNewsServer(svc om.NewsManager) pb.NewsServer {\n        return &handler{\n                getNews: grpctransport.NewServer(\n                        makeGetNewsEndpoint(svc),\n                        decodeGetNewsRequest,\n                        encodeGetNewsResponse,\n                ),\n        }\n}\n```", "```\n$ kubectl apply -f https://github.com/nats-io/nats-operator/releases/download/v0.4.5/00-prereqs.yaml\n$ kubectl apply -f https://github.com/nats-io/nats-operator/releases/download/v0.4.5/10-deployment.yaml\n```", "```\napiVersion: nats.io/v1alpha2\nkind: NatsCluster\nmetadata:\n  name: nats-cluster\nspec:\n  size: 1\n  version: \"1.3.0\"\n```", "```\n$ kubectl apply -f nats_cluster.yaml\nnatscluster.nats.io \"nats-cluster\" configured\n\n$ kubectl get svc -l app=nats\nNAME                TYPE      CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE\nnats-cluster       ClusterIP  10.102.48.27  <none>       4222/TCP    5d\nnats-cluster-mgmt  ClusterIP   None         <none>        6222/TCP,8222/TCP,7777/TCP   5d\n```", "```\ntype LinkManagerEvents interface {\n        OnLinkAdded(username string, link *Link)\n        OnLinkUpdated(username string, link *Link)\n        OnLinkDeleted(username string, url string)\n}\n```", "```\nfunc NewLinkManager(linkStore LinkStore,\n        socialGraphManager om.SocialGraphManager,\n        eventSink om.LinkManagerEvents,\n        maxLinksPerUser int64) (om.LinkManager, error) {\n        if linkStore == nil {\n                return nil, errors.New(\"link store\")\n        }\n\n        if eventSink != nil && socialGraphManager == nil {\n                msg := \"social graph manager can't be nil if event sink is not nil\"\n                return nil, errors.New(msg)\n        }\n\n        return &LinkManager{\n                linkStore:          linkStore,\n                socialGraphManager: socialGraphManager,\n                eventSink:          eventSink,\n                maxLinksPerUser:    maxLinksPerUser,\n        }, nil\n}\n```", "```\nif m.eventSink != nil {\n                followers, err := m.socialGraphManager.GetFollowers(request.Username)\n                if err != nil {\n                        return err\n                }\n\n                for follower := range followers {\n                        m.eventSink.OnLinkAdded(follower, link)\n                }\n        }\n```", "```\npackage link_manager_events\n\nimport (\n        \"github.com/nats-io/go-nats\"\n        \"log\"\n\n        om \"github.com/the-gigi/delinkcious/pkg/object_model\"\n)\n\ntype eventSender struct {\n        hostname string\n        nats     *nats.EncodedConn\n}\n```", "```\nfunc (s *eventSender) OnLinkAdded(username string, link *om.Link) {\n        err := s.nats.Publish(subject, Event{om.LinkAdded, username, link})\n        if err != nil {\n                log.Fatal(err)\n        }\n}\n\nfunc (s *eventSender) OnLinkUpdated(username string, link *om.Link) {\n        err := s.nats.Publish(subject, Event{om.LinkUpdated, username, link})\n        if err != nil {\n                log.Fatal(err)\n        }\n}\n\nfunc (s *eventSender) OnLinkDeleted(username string, url string) {\n        // Ignore link delete events\n}\n```", "```\nfunc NewEventSender(url string) (om.LinkManagerEvents, error) {\n        ec, err := connect(url)\n        if err != nil {\n                return nil, err\n        }\n        return &eventSender{hostname: url, nats: ec}, nil\n}\n```", "```\nnatsHostname := os.Getenv(\"NATS_CLUSTER_SERVICE_HOST\")\n        natsPort := os.Getenv(\"NATS_CLUSTER_SERVICE_PORT\")\n\n        var eventSink om.LinkManagerEvents\n        if natsHostname != \"\" {\n                natsUrl := natsHostname + \":\" + natsPort\n                eventSink, err = nats.NewEventSender(natsUrl)\n                if err != nil {\n                        log.Fatal(err)\n                }\n        } else {\n                eventSink = &EventSink{}\n        }\n\n        svc, err := lm.NewLinkManager(store, socialGraphClient, eventSink, maxLinksPerUser)\n        if err != nil {\n                log.Fatal(err)\n        }\n```", "```\npackage link_manager_events\n\nimport (\n        om \"github.com/the-gigi/delinkcious/pkg/object_model\"\n)\n\nfunc Listen(url string, sink om.LinkManagerEvents) (err error) {\n        conn, err := connect(url)\n        if err != nil {\n                return\n        }\n\n        conn.Subscribe(subject, func(e *Event) {\n                switch e.EventType {\n                case om.LinkAdded:\n                        {\n                                sink.OnLinkAdded(e.Username, e.Link)\n                        }\n                case om.LinkUpdated:\n                        {\n                                sink.OnLinkAdded(e.Username, e.Link)\n                        }\n                default:\n                        // Ignore other event types\n                }\n        })\n\n        return\n}\n```", "```\npackage link_manager_events\n\nimport \"github.com/nats-io/go-nats\"\n\nconst subject = \"link-events\"\n\nfunc connect(url string) (encodedConn *nats.EncodedConn, err error) {\n        conn, err := nats.Connect(url)\n        if err != nil {\n                return\n        }\n\n        encodedConn, err = nats.NewEncodedConn(conn, nats.JSON_ENCODER)\n        return\n}\n```", "```\nfunc NewNewsManager(natsHostname string, natsPort string) (om.NewsManager, error) {\n        nm := &NewsManager{eventStore: NewInMemoryNewsStore()}\n        if natsHostname != \"\" {\n                natsUrl := natsHostname + \":\" + natsPort\n                err := link_manager_events.Listen(natsUrl, nm)\n                if err != nil {\n                        return nil, err\n                }\n        }\n\n        return nm, nil\n}\n```", "```\nfunc (m *NewsManager) OnLinkAdded(username string, link *om.Link) {\n        event := &om.Event{\n                EventType: om.LinkAdded,\n                Username:  username,\n                Url:       link.Url,\n                Timestamp: time.Now().UTC(),\n        }\n        m.eventStore.AddEvent(username, event)\n}\n```", "```\nfunc (m *NewsManager) OnLinkUpdated(username string, link *om.Link) {\n        event := &om.Event{\n                EventType: om.LinkUpdated,\n                Username:  username,\n                Url:       link.Url,\n                Timestamp: time.Now().UTC(),\n        }\n        m.eventStore.AddEvent(username, event)\n}\n```", "```\nfunc (m *InMemoryNewsStore) AddEvent(username string, event *om.Event) (err error) {\n        if username == \"\" {\n                err = errors.New(\"user name can't be empty\")\n                return\n        }\n        if event == nil {\n                err = errors.New(\"event can't be nil\")\n                return\n        }\n        if m.userEvents[username] == nil {\n                m.userEvents[username] = []*om.Event{}\n        }\n        m.userEvents[username] = append(m.userEvents[username], event)\n        return\n}\n```"]