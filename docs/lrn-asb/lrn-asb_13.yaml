- en: Hardening Your Servers Using Ansible and OpenSCAP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible和OpenSCAP加固您的服务器
- en: One of the advantages of using an orchestration and configuration tool like
    Ansible is that it can be used to generate and deploy a complex set of configurations
    in a repeatable task across many hosts. In this chapter, we are going to a look
    at a tool that actually generates the configuration for you to then apply.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像Ansible这样的编排和配置工具的优势之一是，它可以用于在许多主机上生成和部署一组复杂的配置，以便重复执行。在本章中，我们将看一下一个实际上为您生成配置然后应用的工具。
- en: In this chapter, we will learn how to harden a Red Hat-based CentOS 7.5.1804
    host using Ansible and OpenSCAP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Ansible和OpenSCAP加固基于Red Hat的CentOS 7.5.1804主机。
- en: Technical requirements
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We are going to be targeting a Vagrant box running CentOS Linux release 7.5.1804;
    we are using this box because it comes with the latest version of OpenSCAP. A
    copy of the final playbooks can be found in the repository that accompanies this
    book; the repository can be found at [https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter13/scap](https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter13/scap).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将针对运行CentOS Linux发行版7.5.1804的Vagrant虚拟机进行操作；我们使用这个虚拟机是因为它配备了最新版本的OpenSCAP。最终playbooks的副本可以在本书附带的存储库中找到；存储库位于[https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter13/scap](https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter13/scap)。
- en: OpenSCAP
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenSCAP
- en: We are going to be looking at one of a set of tools maintained by Red Hat called
    OpenSCAP. Before we continue, I feel I should warn you that the next section is
    going to contain a lot of abbreviations, starting with SCAP.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究由Red Hat维护的一组工具之一，名为OpenSCAP。在继续之前，我觉得我应该警告您，下一节将包含大量缩写，从SCAP开始。
- en: So, what is SCAP? The **Security Content Automation Protocol** (**SCAP**) is
    an open standard that encompasses several components, all of which are open standards
    themselves, to build a framework that allows you to automatically assess and remediate
    your hosts against the **National Institute of Standards and Technology** (**NIST**)
    Special Publication 800-53.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是SCAP？**安全内容自动化协议**（**SCAP**）是一个开放标准，包括几个组件，所有这些组件本身都是开放标准，用于构建一个框架，允许您自动评估和纠正您的主机针对**国家标准与技术研究所**（**NIST**）特刊800-53。
- en: This publication is a catalog of controls that is applied to all U.S. federal
    IT systems, apart from those maintained by the **National Security Agency** (**NSA**).
    These controls have been put in place to help implement the **Federal Information
    Security Management Act of 2002** (**FISMA**) across U.S federal departments.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这本出版物是一个控制目录，适用于所有美国联邦IT系统，除了由**国家安全局**（**NSA**）维护的系统。这些控制措施已经被制定，以帮助在美国联邦部门实施2002年**联邦信息安全管理法**（**FISMA**）。
- en: 'SCAP is made up of the following components:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: SCAP由以下组件组成：
- en: '**Asset Identification** (**AID**) is a data model used for asset identification.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资产识别**（**AID**）是用于资产识别的数据模型。'
- en: '**Asset Reporting Format** (**ARF**) is a vendor-neutral and technology agnostic
    data model for transporting information on assets between different reporting
    applications and services.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资产报告格式**（**ARF**）是一个供应商中立和技术不可知的数据模型，用于在不同的报告应用程序和服务之间传输资产信息。'
- en: '**Common Configuration Enumeration** (**CCE**) is a standard database of recommended
    configuration for common software. Each recommendation has a unique identifier.
    At the time of writing, the database has not been updated since 2013.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常见配置枚举**（**CCE**）是一个标准数据库，用于常见软件的推荐配置。每个建议都有一个唯一的标识符。在撰写本文时，该数据库自2013年以来尚未更新。'
- en: '**Common Configuration Scoring System** (**CCSS**) is the continuation of CCE.
    It is used for generating a score for various software and hardware configurations
    across all types of deployments.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常见配置评分系统**（**CCSS**）是CCE的延续。它用于为各种软件和硬件配置生成得分，涵盖所有类型的部署。'
- en: '**Common Platform Enumeration** (**CPE**) is a method of identifying hardware
    assets, operating systems, and software present in an organization''s infrastructure.
    Once identified, this data can then be used to search other databases to threat
    assess the asset.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常见平台枚举**（**CPE**）是一种识别组织基础设施中的硬件资产、操作系统和软件的方法。一旦识别，这些数据可以用于搜索其他数据库以评估资产的威胁。'
- en: '**Common Weakness Enumeration** (**CWE**) is a common language for dealing
    with and discussing the causes of weaknesses in system architecture, design, and
    code that may lead to vulnerabilities.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常见弱点枚举**（**CWE**）是一种处理和讨论系统架构、设计和代码中可能导致漏洞的弱点原因的通用语言。'
- en: '**Common Vulnerabilities and Exposures** (**CVE**) is a database of publicly
    acknowledged vulnerabilities. Most system administrators and IT professionals
    will have come across the CVE database at some point. Each vulnerability receives
    a unique ID; for example, most people will know CVE-2014-0160, which is also known
    as **Heartbleed**.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常见漏洞和暴露**（**CVE**）是一个公开承认的漏洞数据库。大多数系统管理员和IT专业人员在某个时候都会遇到CVE数据库。每个漏洞都有一个唯一的ID；例如，大多数人都会知道CVE-2014-0160，也被称为**心脏出血**。'
- en: '**Common Vulnerability Scoring System** (**CVSS**) is a method that helps capture
    the characteristics of a vulnerability to produce a normalized numerical score,
    which can then be used to describe the impact of a vulnerability, for example,
    low, medium, high, and critical.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常见漏洞评分系统**（**CVSS**）是一种帮助捕捉漏洞特征以产生标准化数值评分的方法，然后可以用于描述漏洞的影响，例如低、中、高和关键。'
- en: '**Extensible Configuration Checklist Description Format** (**XCCDF**) is an
    XML format for describing security checklists. It can also be used for configuration
    and benchmarks and provides a common language for all the parts of SCAP.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展配置清单描述格式**（**XCCDF**）是一种描述安全清单的XML格式。它也可以用于配置和基准，并为SCAP的所有部分提供一个通用语言。'
- en: '**Open Checklist Interactive Language** (**OCIL**) is a framework for expressing
    questions to an end user and also the procedures to process the responses in a
    standardized way.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放式清单交互语言**（**OCIL**）是一个用于向最终用户提出问题以及以标准化方式处理响应程序的框架。'
- en: '**Open Vulnerability and Assessment Language** (**OVAL**) is defined in XML
    and aims to standardize the transfer of security content across all of the tools
    and services offered by NIST, the MITRE Corporation, the **United States Computer
    Emergency Readiness Team** (**US-CERT**), and the United States **Department of
    Homeland Security** (**DHS**).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放式漏洞评估语言**（**OVAL**）以XML形式定义，旨在标准化NIST、MITRE公司、**美国计算机紧急应对小组**（**US-CERT**）和美国**国土安全部**（**DHS**）提供的所有工具和服务之间的安全内容传输。'
- en: '**Trust Model for Security Automation Data** (**TMSAD**) is an XML document
    that aims to define a common trust model which can be applied to the data being
    exchanged by all of the components that make up SCAP.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全自动化数据信任模型**（**TMSAD**）是一个旨在定义一个通用信任模型的XML文档，可应用于构成SCAP的所有组件交换的数据。'
- en: As you can imagine, there have been thousands of man-years that have gone into
    producing SCAP and the components that go to make its foundation. Some of the
    projects have been around in one form or another since the mid 90s, so they are
    well-established and considered the de facto standard when it comes to security
    best practices; however, I am sure you are thinking that it all sounds very complicated—after
    all, these are standards that have been defined and are being maintained by scholars,
    security professionals, and government departments.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以想象，SCAP及其基础组件的开发已经耗费了数千人年。其中一些项目自90年代中期以来一直存在，因此它们已经得到了很好的建立，并被认为是安全最佳实践的事实标准；但是，我相信您会认为这一切听起来非常复杂——毕竟，这些是由学者、安全专业人员和政府部门定义和维护的标准。
- en: This is where OpenSCAP comes in. The OpenSCAP project, maintained by Red Hat
    and also certificated by NIST for its support of the SCAP 1.2 standard, allows
    you to apply all of the best practices we have discussed using a command-line
    client.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是OpenSCAP的用武之地。由Red Hat维护的OpenSCAP项目还获得了NIST对其支持SCAP 1.2标准的认证，它允许您使用命令行客户端应用我们讨论的所有最佳实践。
- en: OpenSCAP, like a lot of Red Hat projects, is gaining support for Ansible and
    the current release introduces support for automatically generating Ansible playbooks
    to remediate non-conformance discovered during an OpenSCAP scan.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多Red Hat项目一样，OpenSCAP正在获得对Ansible的支持，当前版本引入了自动生成Ansible playbook以修复OpenSCAP扫描中发现的不符合规范的支持。
- en: The automatic remediation scripts in the current version of OpenSCAP are a work
    in progress and there are known issues, which we will address toward the end of
    the chapter. Because of this, your output may differ from that covered in this
    chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的OpenSCAP中的自动修复脚本还在不断改进中，存在已知问题，我们将在本章末解决这些问题。因此，您的输出可能与本章中介绍的内容有所不同。
- en: In the sections that follow, we will launch a CentOS 7.5.1804 Vagrant box, scan
    it, and generate the remediation playbook. As playbook support has only just been
    introduced, there is not yet 100% coverage of the fixes, so we will then scan
    the host a second time and then, using Ansible, generate a remediation bash script,
    and execute it on our host, before executing another scan, so we can compare the
    results of all three scans.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将启动一个CentOS 7.5.1804 Vagrant box，对其进行扫描，并生成修复playbook。由于playbook支持刚刚被引入，因此修复的覆盖率还不到100%，因此我们将再次扫描主机，然后使用Ansible生成修复的bash脚本，并在主机上执行它，然后再次执行扫描，以便比较所有三次扫描的结果。
- en: Preparing the host
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备主机
- en: 'Before we start scanning, we need a host to target, so let''s quickly create
    the folder structure and `Vagrantfile`. To create the structure, run the following
    commands:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始扫描之前，我们需要一个目标主机，因此让我们快速创建文件夹结构和`Vagrantfile`。要创建结构，请运行以下命令：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `scap/Vagrantfile` we created should contain the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`scap/Vagrantfile`应该包含以下代码：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This means that the host inventory file, `scap/production`, should contain
    the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着主机清单文件`scap/production`应包含以下内容：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can launch the Vagrant box with one of the following commands:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令之一启动Vagrant box：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have our target host ready, we can perform our initial scan.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的目标主机已准备就绪，我们可以执行初始扫描了。
- en: The playbook
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: playbook
- en: We are going to split the playbook into a few different roles. Unlike previous
    chapters, we are going to make a few of the roles reusable and pass parameters
    to them as they are executed. Our first role is a simple one, which installs the
    packages we need to run our OpenSCAP scan.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把playbook拆分成几个不同的角色。与以往的章节不同，我们将使其中一些角色可重用，并在执行它们时传递参数。我们的第一个角色是一个简单的角色，安装我们运行OpenSCAP扫描所需的软件包。
- en: Install role
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装角色
- en: 'As mentioned previously, this first role is a simple one that installs the
    packages we need to run a scan:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个第一个角色是一个简单的角色，安装我们运行扫描所需的软件包：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are a few defaults we need to set in `roles/install/defaults/main.yml`;
    these are:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`roles/install/defaults/main.yml`中设置一些默认值；这些是：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There is a task in `roles/install/tasks/main.yml` that installs the packages
    and also performs a `yum` update:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`roles/install/tasks/main.yml`中有一个任务，安装软件包并执行`yum`更新：'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That is it for this role; we will be calling it each time we run a scan to ensure
    that we have the correct packages installed to be running the scan itself.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个角色的全部内容；我们将在每次运行扫描时调用它，以确保我们安装了正确的软件包来运行扫描本身。
- en: Scan role
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描角色
- en: 'Now that we have the OpenSCAP packages installed, we can create a role that
    performs the scan:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了OpenSCAP软件包，我们可以创建一个执行扫描的角色：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As already mentioned, we will be reusing this role throughout the playbook,
    which presents us with an easily resolved problem. By default, even if you define
    the role several times, Ansible will only execute a role once during a playbook
    run. To allow the role to execute more than once, we need to add the following
    line to the top of the `roles/scan/meta/main.yml` file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将在整个手册中重复使用这个角色，这给我们带来了一个很容易解决的问题。默认情况下，即使你多次定义了角色，Ansible在手册运行期间也只会执行一次角色。为了允许角色执行多次，我们需要在`roles/scan/meta/main.yml`文件的顶部添加以下行：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This instructs Ansible to execute this one role multiple times during the playbook
    run. Next up, we need to add some variables to the `group_vars/common.yml` file.
    These key values will be shared across all of the roles we will be using in our
    playbook. The first set of nested variables looks like the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示Ansible在手册运行期间多次执行这个角色。接下来，我们需要向`group_vars/common.yml`文件添加一些变量。这些关键值将在我们手册中使用的所有角色之间共享。
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These define which profile we want to use and also which policy we want to
    apply. By default, OpenSCAP doesn''t ship with any policies; these were installed
    with the `scap-security-guide` package. This package provides several policies,
    which can all be found in `/usr/share/xml/scap/ssg/content/`; the following terminal
    screenshot shows a directory listing of that folder:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义了我们想要使用的配置文件和我们想要应用的策略。默认情况下，OpenSCAP不附带任何策略；这些是通过`scap-security-guide`软件包安装的。该软件包提供了几个策略，所有这些策略都可以在`/usr/share/xml/scap/ssg/content/`中找到；以下终端截图显示了该文件夹的目录列表：
- en: '![](assets/7d4643a7-32c1-4165-a75a-7a56b5158c46.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7d4643a7-32c1-4165-a75a-7a56b5158c46.png)'
- en: For our playbook, we are going to be using the `ssg-centos7-ds.xml` policy,
    or to give it its proper title, `PCI-DSS v3 Control Baseline for CentOS Linux
    7`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的手册，我们将使用`ssg-centos7-ds.xml`策略，或者给它一个适当的标题，`PCI-DSS v3 Control Baseline
    for CentOS Linux 7`。
- en: The **Payment Card Industry Data Security Standard** (**PCI-DSS**) is a standard
    that's been agreed upon by all of the major credit card operators that anyone
    handling cardholder data must adhere to. The standard is a set of security controls
    that are audited either by an external auditor or via a self-assessment questionnaire,
    depending on the number of transactions you handle.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**支付卡行业数据安全标准**（**PCI-DSS**）是所有主要信用卡运营商都同意的一个标准，任何处理持卡人数据的人都必须遵守该标准。该标准是一组安全控制，由外部审计员或通过自我评估问卷进行审核，具体取决于您处理的交易数量。'
- en: 'The following set of nested variables define whereabouts we will be storing
    the various files that are generated by the scans:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一组嵌套变量定义了我们将存储扫描生成的各种文件的位置：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we have remote and local paths for the HTML reports. This is
    because we will be copying the reports to our Ansible controller as part of the
    playbook run.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有HTML报告的远程和本地路径。这是因为我们将在手册运行过程中将报告复制到我们的Ansible控制器。
- en: 'Now that we have the shared variables, we need to add a single default variable
    to the `roles/scan/defaults/main.yml` file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了共享变量，我们需要在`roles/scan/defaults/main.yml`文件中添加一个单个默认变量：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the command we will be running to initiate the scan. At the time of
    writing, there are not any OpenSCAP modules, so we will need to execute the `oscap`
    commands using the `command` module. The interesting thing to note is that I have
    split the command over multiple lines in the variable so that it is easy to read.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将运行以启动扫描的命令。在撰写本文时，没有任何OpenSCAP模块，因此我们需要使用`command`模块执行`oscap`命令。值得注意的是，我已经将命令分成多行放在变量中，以便阅读。
- en: Because I used `>`, Ansible will actually render the command on a single line
    when it comes to applying the variable to the task, which means that we do not
    have to add `\` at the end of each line like we would need to if we were to run
    the multiline command on the command line.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我使用了`>`，当应用变量到任务时，Ansible实际上会将命令呈现为单行，这意味着我们不必像在命令行上运行多行命令时那样在每行末尾添加`\`。
- en: 'The final part of the role is the tasks themselves. We will be putting all
    of the tasks in the `roles/scan/tasks/main.yml` file, starting with the task that
    executes the command we defined:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 角色的最后部分是任务本身。我们将把所有任务放在`roles/scan/tasks/main.yml`文件中，从执行我们定义的命令的任务开始。
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `ignore_errors` is extremely important here. As far as Ansible is concerned,
    this task will always run unless we get a 100% clean bill of health from the scan.
    The next task copies the HTML report generated by the scan from our target host
    to our Ansible controller:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`ignore_errors`在这里非常重要。就Ansible而言，除非我们从扫描中获得100%的干净健康报告，否则这个任务将始终运行。下一个任务是将扫描生成的HTML报告从目标主机复制到我们的Ansible控制器：'
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we have two roles in place, we can look at running our first scan.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个角色，我们可以开始运行我们的第一个扫描。
- en: Running the initial scan
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行初始扫描
- en: 'Now that we have both the install and scan roles completed, we can run our
    first scan. The only file we have not covered yet is the `site.yml` one; this
    one looks like slightly different to the ones we have been using in other chapters:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了安装和扫描角色，我们可以运行我们的第一个扫描。我们还没有涵盖的唯一文件是`site.yml`；这个文件看起来与我们在其他章节中使用的文件略有不同：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, we are tagging the roles as well as passing a parameter when
    running the scan. For now, we are just going to run playbook without using any
    tags. To run the playbook, issue the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在为角色打标签，并在运行扫描时传递一个参数。现在，我们只是运行手册而不使用任何标签。要运行手册，请发出以下命令：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will give us the following results:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下结果：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I have truncated the scan results in this output, but when you run it, you will
    see a large section of failed output colored red. As already mentioned, this is
    to be expected and is nothing to worry about.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在此输出中截断了扫描结果，但当你运行它时，你会看到一个大部分失败的输出被标记为红色。如前所述，这是可以预料到的，不用担心。
- en: 'A copy of the HTML report for our initial scan should be on your Ansible controller
    now; you can open it in your browser with the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始扫描的HTML报告的副本现在应该在您的Ansible控制器上；您可以使用以下命令在浏览器中打开它：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Or, open the `generated` folder and double-click on `box1_report_01-initial-scan.html`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，打开`generated`文件夹，双击`box1_report_01-initial-scan.html`：
- en: '![](assets/e5ebc9c4-a064-48d6-b4f0-767d9402f75b.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e5ebc9c4-a064-48d6-b4f0-767d9402f75b.png)'
- en: As you can see from the example, our host failed 51 of the 94 checks OpenSCAP
    ran. Let's look at doing something about getting that number of failed checks
    down.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从示例中所见，我们的主机在OpenSCAP运行的94个检查中有51个失败。让我们看看如何解决这些失败的检查。
- en: Generating the remediation Ansible playbook
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成补救的Ansible playbook
- en: 'Before we continue, I must first draw your attention to the fact the report
    gives the following warning:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我必须首先提醒您报告给出了以下警告：
- en: Do not attempt to implement any of the settings in this guide without first
    testing them in a non-operational environment. The creators of this guidance assume
    no responsibility whatsoever for its use by other parties and makes no guarantees,
    expressed or implied, about its quality, reliability, or any other characteristic.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有在非运行环境中进行测试的情况下，请不要尝试实施本指南中的任何设置。本指南的创建者对其他方使用本指南不承担任何责任，并且对其质量、可靠性或任何其他特性不作任何明示或暗示的保证。
- en: While we are only targeting a test host here, if you like what you see and decide
    to look at implementing OpenSCAP against other workloads, please ensure that you
    take it slowly and test thoroughly before running against anything that is in
    use, even if it is just by developers—the changes made during the remediation
    we are about to carry out could have serious consequences on the running of your
    target host.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们这里只针对一个测试主机，如果您喜欢并决定查看针对其他工作负载实施OpenSCAP，请确保您慢慢进行测试，然后再运行，即使只是由开发人员使用，我们即将进行的补救可能会对目标主机的运行产生严重后果。
- en: 'Now that we have that warning out of the way, we can continue to look at securing
    our host using an automatically generated Ansible playbook:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经解决了这个警告，我们可以继续看如何使用自动生成的Ansible playbook来保护我们的主机：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With this role, we need a few defaults that define whereabouts our generated
    playbook will be sorted, and again we need to define the command that needs to
    run. These values can be found in `roles/fix-ansible/defaults/main.yml`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个角色，我们需要一些默认值，定义我们生成的playbook将被排序的位置，再次需要定义需要运行的命令。这些值可以在`roles/fix-ansible/defaults/main.yml`中找到。
- en: 'The first block deals with where the files we are going to be generating are
    stored on both the target host and locally:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个块处理我们将要生成的文件在目标主机和本地存储的位置：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next up, we have the command that needs to be executed to generate the playbook
    file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有需要执行的命令来生成playbook文件：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we have the locations of some folders and files that need to be in place
    before the playbook runs; otherwise, it will result in an error and a fail:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一些文件夹和文件的位置需要在运行playbook之前放在那里；否则，将导致错误和失败：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that we have the default variables in place, we can start adding tasks
    to `roles/fix-ansible/tasks/main.yml`, starting with one that uses the `file`
    module to put the missing folders and files in place:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了默认的变量，我们可以开始向`roles/fix-ansible/tasks/main.yml`添加任务，首先使用`file`模块放置缺失的文件夹和文件：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we are going to add a check to see whether the playbook file already
    exists on the target machine:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个检查，看看目标机器上的playbook文件是否已经存在：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are doing this so that we have a way of skipping running the playbook that
    has been generated. Next up, we run the command to generate the playbook:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了有一种跳过运行已生成的playbook的方法。接下来，我们运行命令来生成playbook：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, we are passing arguments that tell Ansible the command that
    creates the playbook file; if the file is there, then the command will not execute
    again. Now that we have the playbook on the machine, we need to copy it to our
    Ansible controller. Here, we are using the `fetch` module again:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从示例中所见，我们正在传递参数告诉Ansible创建playbook文件的命令；如果文件存在，则命令将不会再次执行。现在我们在机器上有了playbook，我们需要将其复制到我们的Ansible控制器上。在这里，我们再次使用`fetch`模块：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, we are using `when` so that the task only runs if the playbook
    file did not exist at the start of the role being run. Now that we have a copy
    of the playbook locally, we can run it. To do that, we are going be using the
    `local_action` module in combination with the `command` module to run Ansible
    within Ansible:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在使用`when`，以便任务仅在角色运行开始时playbook文件不存在时才运行。现在我们在本地有了playbook的副本，我们可以运行它。为此，我们将使用`local_action`模块与`command`模块结合在Ansible中运行Ansible：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There are a few different things happening here, so let''s break it down a
    little more, starting with the command we are running, which translates to:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了一些不同的事情，所以让我们更详细地分解一下，从我们正在运行的命令开始，这个命令的翻译是：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, we are having to pass the instructions for using `become` with
    the method of `sudo` as part of the command. This is because the Ansible playbook
    that is being generated does not account for you connecting externally using a
    user other than root.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们必须传递使用`become`与`sudo`方法作为命令的一部分的指令。这是因为生成的Ansible playbook没有考虑到您使用root以外的用户进行外部连接。
- en: 'The final task in this role writes the results of the previous task to a file
    on our Ansible controller:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个角色的最后一个任务将上一个任务的结果写入我们的Ansible控制器上的一个文件：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'That completes the role. We can run the playbook again to apply the fixes and
    remediation, then run another scan so that we can update the `site.yml` file so
    it reads:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了角色。我们可以再次运行playbook来应用修复和补救措施，然后运行另一个扫描，以便我们可以更新`site.yml`文件，使其读取：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see, we have removed the tags for the `fix-ansible` role and we
    have also  updated the report name for the second `scan`. We can start the playbook
    by running this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经删除了`fix-ansible`角色的标记，并且还更新了第二次扫描的报告名称。我们可以通过运行以下命令来启动playbook：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This gives us the following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下输出：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s take a look at the report and see what difference running the Ansible
    playbook has made:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下报告，看看运行Ansible playbook有什么不同：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output can be seen as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](assets/c5936eb5-8d14-42be-afa3-3a92e03deeef.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c5936eb5-8d14-42be-afa3-3a92e03deeef.png)'
- en: That's a little better than before; however, we are still failing 25 rules—why
    is that? Well, as already mentioned, work is still ongoing with porting all of
    the remediation rules over to Ansible; for example, if you open up the original
    scan results and scroll to the bottom, you should see that the Set SSH Idle Timeout
    Interval check failed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在比以前好一点了；然而，我们仍然有25条规则失败了—为什么呢？嗯，正如已经提到的，仍在进行将所有修复规则迁移到Ansible的工作；例如，如果你打开原始扫描结果并滚动到底部，你应该会看到设置SSH空闲超时间隔检查失败。
- en: 'Clicking on it will show you information on what OpenSCAP is checking, why
    they are checking it, and also why it should be fixed. And finally, at the bottom,
    you will notice that there are options to show both the shell and Ansible remediation
    solutions:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 点击它将向您显示OpenSCAP正在检查的信息，为什么他们正在检查，以及为什么应该修复。最后，在底部，您将注意到有显示shell和Ansible修复解决方案的选项：
- en: '![](assets/30f04aed-e541-4b71-8a17-5e0c2a58075a.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/30f04aed-e541-4b71-8a17-5e0c2a58075a.png)'
- en: Now, click on one of the remaining failures from the second report. You should
    notice that there is only an option for remediation using a shell script. We will
    be generating this in the next role, but before we move on, let's quickly look
    at the playbook that was generated.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击第二份报告中剩下的失败之一。你应该注意到只有使用shell脚本进行修复的选项。我们将在下一个角色中生成这个，但在我们继续之前，让我们快速看一下生成的playbook。
- en: 'The playbook I generated at the time of writing contained over 3,200 lines
    of code, so I am not going to cover them all here, but as we have already mentioned
    the Set SSH Idle Timeout Interval check, let''s take a look at the task in the
    playbook that applies the fix:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我在撰写时生成的playbook包含超过3200行的代码，所以我不打算在这里覆盖它们所有，但正如我们已经提到的设置SSH空闲超时间隔检查，让我们看一下playbook中应用修复的任务：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, it uses the lineinfile module to apply a variable that is defined
    at the very top of the playbook. Also, each of the tasks is tagged with quite
    a lot of information about which areas of the standard the fix comes under, and
    also the severity. This means we can get quite granular on which parts of the
    playbook run; for example, you could only run the low disruption changes by using
    the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它使用lineinfile模块来应用在playbook顶部定义的变量。此外，每个任务都带有关于修复所属的标准的许多信息，以及严重程度。这意味着我们可以对playbook运行的部分进行非常细致的控制；例如，您可以通过使用以下命令仅运行低干扰更改：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, at the bottom of the `box1_ansible.log` file, we can see that the
    playbook run made the following changes:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`box1_ansible.log`文件的底部，我们可以看到playbook运行做出了以下更改：
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Generating the remediation bash script
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成修复的bash脚本
- en: 'To remediate the remaining issues, we should generate and execute the bash
    script:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了纠正剩下的问题，我们应该生成并执行bash脚本：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As this is a nice-to-have, I am not going to go into any detail about the ins
    and outs of what we are adding here. The contents of `roles/fix-bash/defaults/main.yml`
    are similar to those in the `fix-ansible` role:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个很好的功能，我不打算详细介绍我们在这里添加的内容的各个方面。`roles/fix-bash/defaults/main.yml`的内容与`fix-ansible`角色中的内容类似：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The tasks in `roles/fix-bash/tasks/main.yml` are also similar and shouldn''t
    need any explanation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`roles/fix-bash/tasks/main.yml`中的任务也是类似的，不需要任何解释：'
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Update the `site.yml` file so it reads:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`site.yml`文件，使其读取：
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This means we can take the results of the scan that ran after the Ansible fix
    to generate the bash script that contains the remaining fixes; we are then doing
    one final scan. To apply the final batch of fixes, run the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以拿到在应用Ansible修复后运行的扫描结果，生成包含剩余修复的bash脚本；然后我们进行最后一次扫描。要应用最终的一批修复，运行以下命令：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This gives the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Check the final report by running:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行检查最终报告：
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This should show that the overall number of failed checks has reduced to just
    five:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该显示总共失败检查的数量已经减少到只有五个：
- en: '![](assets/f65a56a1-ee6e-4d15-aeda-298f3ce3782f.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f65a56a1-ee6e-4d15-aeda-298f3ce3782f.png)'
- en: Running a standalone scan
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行独立扫描
- en: 'When we created the scan role, it was mentioned that the role should be reusable.
    We also added tags to the role when we defined it in the `site.yml` file. Let''s
    take a quick look at how we can run just a scan outside of a full playbook run.
    To kick off the scan, run the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建扫描角色时，提到角色应该是可重用的。当我们在`site.yml`文件中定义角色时，我们还为角色添加了标记。让我们快速看一下我们如何可以仅运行扫描而不是完整的playbook运行。要启动扫描，请运行以下命令：
- en: '[PRE44]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will run only the parts of the playbook that are tagged `scan`, and we
    are also overriding the `report_name` variable that we are setting as part of
    calling the role in the `site.yml` file to call our `report box1_report_scan-only.html`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只运行标记为`scan`的playbook部分，并且我们还覆盖了`report_name`变量，这是我们在`site.yml`文件中调用角色时设置的，以调用我们的`report
    box1_report_scan-only.html`：
- en: '![](assets/d25ced72-4024-45a0-9642-f66b12df3583.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d25ced72-4024-45a0-9642-f66b12df3583.png)'
- en: Fixing the remaining failed checks
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复剩下的失败检查
- en: So far, we haven't had to put any hardcoded fixes in place to resolve any of
    the problems found in the scans. We have had to create a few files and folders
    to allow the fixes to be applied, but that was more to let the automated remediation
    work, rather than a fix.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有不得不采取任何硬编码的修复措施来解决扫描中发现的任何问题。我们不得不创建一些文件和文件夹来允许应用修复，但这更多是为了让自动修复工作，而不是修复。
- en: 'At the time of writing, there are known issues with two of the five problems
    that are currently showing on my scans; these are:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，我们已知有两个当前显示在我的扫描中的五个问题存在问题；它们是：
- en: '`xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands`'
- en: '`xccdf_org.ssgproject.content_rule_audit_rules_login_events`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xccdf_org.ssgproject.content_rule_audit_rules_login_events`'
- en: 'There are fixes being worked on. You can find them on Red Hat''s Bugzilla at:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正在进行修复。你可以在Red Hat的Bugzilla上找到它们：
- en: '[https://bugzilla.redhat.com/show_bug.cgi?id=1570802](https://bugzilla.redhat.com/show_bug.cgi?id=1570802)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bugzilla.redhat.com/show_bug.cgi?id=1570802](https://bugzilla.redhat.com/show_bug.cgi?id=1570802)'
- en: '[https://bugzilla.redhat.com/show_bug.cgi?id=1574586](https://bugzilla.redhat.com/show_bug.cgi?id=1574586)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://bugzilla.redhat.com/show_bug.cgi?id=1574586](https://bugzilla.redhat.com/show_bug.cgi?id=1574586)'
- en: 'So, leaving these two to one side, there are three I can fix now. To do this,
    I am going to create a separate role and playbook, as by the time you read this,
    the following fixes may not be needed:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将这两个放在一边，现在有三个我可以修复。为了做到这一点，我将创建一个单独的角色和playbook，因为在你阅读这篇文章的时候，以下的修复可能已经不再需要：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Jumping straight into `roles/final-fixes/tasks/main.yml`, our first fix is
    to rotate the logs daily rather than weekly, which is the default. To do this,
    we will use the `lineinfile` module to replace `weekly` with `daily`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 直接跳转到`roles/final-fixes/tasks/main.yml`，我们的第一个修复是将日志每天而不是每周进行轮转，这是默认设置。为了做到这一点，我们将使用`lineinfile`模块将`weekly`替换为`daily`：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The next task adds a fix that should make its way through to the `scap-security-guide`
    package at some point:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务添加了一个修复，应该在某个时候通过`scap-security-guide`软件包实现：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, here, we are using the `lineinfile` module again. This time,
    we are adding a line to `/etc/audit/rules.d/modules.rules` if it is not already
    present. This adds a rule that takes into account 32-bit kernels, as well as the
    64-bit ones, which the remediation scripts already configured.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里所看到的，我们再次使用`lineinfile`模块。这一次，如果`/etc/audit/rules.d/modules.rules`中不存在，我们将添加一行。这将添加一个规则，考虑到32位内核以及已经配置好的64位内核的修复脚本。
- en: 'Next, we are adding a fix for a script that should have been executed during
    the bash script execution. First of all, we need to create a file using the `file`
    module:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为应该在bash脚本执行期间执行的脚本添加了一个修复。首先，我们需要使用`file`模块创建一个文件：
- en: '[PRE48]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We then need to copy and then execute the portion of the bash script that failed
    when we first ran it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要复制并执行在我们第一次运行时失败的bash脚本的部分：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The bash script itself can be found at `roles/final-fixes/files/content_rule_file_permissions_var_log_audit.sh`,
    and it looks like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: bash脚本本身可以在`roles/final-fixes/files/content_rule_file_permissions_var_log_audit.sh`中找到，它看起来是这样的：
- en: '[PRE50]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, we need to create a playbook file called `final-fixes.yml`. This should
    run the role we have just created and then run a final scan:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建一个名为`final-fixes.yml`的playbook文件。这应该运行我们刚刚创建的角色，然后运行最终扫描：
- en: '[PRE51]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To run the playbook, use the following command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行playbook，请使用以下命令：
- en: '[PRE52]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This will give the following results:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '[PRE53]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Open the report that was generated using the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 打开使用以下命令生成的报告：
- en: '[PRE54]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This shows us that there are just the two medium checks with known issues that
    are still failing:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，仍然有两个中等检查存在已知问题，仍然失败：
- en: '![](assets/c78e226b-f378-44e9-a908-fdb0584971e6.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c78e226b-f378-44e9-a908-fdb0584971e6.png)'
- en: Hopefully, by the time you are reading this, your hosts will be getting a clean
    bill of health and this last section won't be needed, which is why I split it
    off from the main `site.yml` playbook.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在你阅读本文时，你的主机将得到一个干净的健康证明，这最后一部分将不再需要，这就是为什么我将它从主`site.yml` playbook中分离出来的原因。
- en: Destroying the Vagrant box
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁Vagrant box
- en: 'Don''t forget to destroy the Vagrant box once you have finished; you don''t
    want an idle virtual machine running on your host. To do this, run:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后不要忘记销毁Vagrant box；你不希望在主机上运行一个空闲的虚拟机。要做到这一点，请运行：
- en: '[PRE55]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Once the box has gone, I would recommend running through the scan and remediation
    a few times on a clean installation to get an idea of how this can be implemented
    on new hosts.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦box消失，我建议在干净的安装上多次运行扫描和修复，以了解如何在新主机上实现这一点。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we created a playbook that generated a playbook to remediate
    any PCI-DSS non-compliance errors found during a scan. As well as being really
    cool, it is also really practical if you imagine you are running a few dozen servers
    that all need to be compliant, and also that they all need a full audit history.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个playbook，生成了一个playbook，用于在扫描期间发现PCI-DSS不符合错误的修复。除了非常酷外，如果你想象一下你正在运行几十台需要符合标准的服务器，并且它们都需要完整的审计历史记录，这也是非常实用的。
- en: You now have the foundations of a playbook that you can use to target those
    hosts daily, to both audit them and store the results away from the host itself,
    but also depending on your configuration, you have a way of automatically resolving
    any non-conformance found during the scan.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了一个playbook的基础，可以每天用来定位这些主机，对它们进行审计，并将结果存储在主机之外，但是根据你的配置，你也有一种自动解决扫描期间发现的任何不符合标准的方法。
- en: The scans we have been doing in this chapter have all been host-based; in the
    next chapter, we are going to look at how we can scan hosts remotely.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中进行的扫描都是基于主机的；在下一章中，我们将看看如何远程扫描主机。
- en: Questions
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What effect does adding `>` to a multiline variable have?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`>`添加到多行变量会产生什么影响？
- en: 'True or false: OpenSCAP is certified by NIST.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确或错误：OpenSCAP已经获得NIST认证。
- en: Why are we telling Ansible to continue if the `scan` command is marked as failed?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们告诉Ansible在`scan`命令标记为失败时继续运行？
- en: Explain why we are using tags for certain roles.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释为什么我们对某些角色使用标签。
- en: 'True or false: We are using the `copy` command to copy the HTML reports from
    the remote host to the Ansible controller.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确或错误：我们使用`copy`命令将HTML报告从远程主机复制到Ansible控制器。
- en: Further reading
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find out more information on the technologies and organizations we
    have covered in this chapter at the following links:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到本章涵盖的技术和组织的更多信息：
- en: '**OpenSCAP**: [https://www.open-scap.org/](https://www.open-scap.org/)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSCAP：[https://www.open-scap.org/](https://www.open-scap.org/)
- en: '**Security Content Automation Protocol** (**SCAP**): [https://scap.nist.gov/](https://scap.nist.gov/)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全内容自动化协议（SCAP）：[https://scap.nist.gov/](https://scap.nist.gov/)
- en: '**NIST**: [https://www.nist.gov/](https://www.nist.gov/)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NIST：[https://www.nist.gov/](https://www.nist.gov/)
- en: '**MITRE Corporation**: [https://www.mitre.org/](https://www.mitre.org/)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 麻省理工学院：[https://www.mitre.org/](https://www.mitre.org/)
- en: '**Asset Identification (AID)**: [https://csrc.nist.gov/Projects/Security-Content-Automation-Protocol/Specifications/aid](https://csrc.nist.gov/Projects/Security-Content-Automation-Protocol/Specifications/aid)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资产识别（AID）：[https://csrc.nist.gov/Projects/Security-Content-Automation-Protocol/Specifications/aid](https://csrc.nist.gov/Projects/Security-Content-Automation-Protocol/Specifications/aid)
- en: '**Asset Reporting Format (ARF)**: [https://csrc.nist.gov/Projects/Security-Content-Automation-Protocol/Specifications/arf](https://csrc.nist.gov/Projects/Security-Content-Automation-Protocol/Specifications/arf)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资产报告格式（ARF）：[https://csrc.nist.gov/Projects/Security-Content-Automation-Protocol/Specifications/arf](https://csrc.nist.gov/Projects/Security-Content-Automation-Protocol/Specifications/arf)
- en: '**Common Configuration Enumeration (CCE)**: [https://cce.mitre.org](https://cce.mitre.org)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用配置标识（CCE）：[https://cce.mitre.org](https://cce.mitre.org)
- en: '**Common Configuration Scoring System** **(CCSS)**: [https://www.nist.gov/publications/common-configuration-scoring-system-ccss-metrics-software-security-configuration](https://www.nist.gov/publications/common-configuration-scoring-system-ccss-metrics-software-security-configuration)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用配置评分系统（CCSS）：[https://www.nist.gov/publications/common-configuration-scoring-system-ccss-metrics-software-security-configuration](https://www.nist.gov/publications/common-configuration-scoring-system-ccss-metrics-software-security-configuration)
- en: '**Common Platform Enumeration (CPE)**: [https://nvd.nist.gov/products/cpe](https://nvd.nist.gov/products/cpe)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用平台标识（CPE）：[https://nvd.nist.gov/products/cpe](https://nvd.nist.gov/products/cpe)
- en: '**Common Weakness Enumeration (CWE)**: [https://cwe.mitre.org/](https://cwe.mitre.org/)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用弱点枚举（CWE）：[https://cwe.mitre.org/](https://cwe.mitre.org/)
- en: '**Common Vulnerabilities and Exposures (CVE)**: [https://cve.mitre.org](https://cve.mitre.org)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用漏洞和暴露（CVE）：[https://cve.mitre.org](https://cve.mitre.org)
- en: '**Common Vulnerability Scoring System (CVSS)**: [https://www.first.org/cvss/](https://www.first.org/cvss/)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用漏洞评分系统（CVSS）：[https://www.first.org/cvss/](https://www.first.org/cvss/)
- en: '**Extensible Configuration Checklist Description Format (XCCDF)**: [https://csrc.nist.gov/Projects/Security-Content-Automation-Protocol/Specifications/xccdf](https://csrc.nist.gov/Projects/Security-Content-Automation-Protocol/Specifications/xccdf)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展配置清单描述格式（XCCDF）：[https://csrc.nist.gov/Projects/Security-Content-Automation-Protocol/Specifications/xccdf](https://csrc.nist.gov/Projects/Security-Content-Automation-Protocol/Specifications/xccdf)
- en: '**Open Checklist Interactive Language (OCIL)**: [https://csrc.nist.gov/Projects/Security-Content-Automation-Protocol/Specifications/ocil](https://csrc.nist.gov/Projects/Security-Content-Automation-Protocol/Specifications/ocil)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放清单交互语言（OCIL）：[https://csrc.nist.gov/Projects/Security-Content-Automation-Protocol/Specifications/ocil](https://csrc.nist.gov/Projects/Security-Content-Automation-Protocol/Specifications/ocil)
- en: '**Open Vulnerability and Assessment Language (OVAL)**: [https://oval.mitre.org](https://oval.mitre.org)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放漏洞和评估语言（OVAL）：[https://oval.mitre.org](https://oval.mitre.org)
- en: '**Trust Model for Security Automation Data (TMSAD)**: [https://www.nist.gov/publications/trust-model-security-automation-data-10-tmsad](https://www.nist.gov/publications/trust-model-security-automation-data-10-tmsad)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全自动化数据信任模型（TMSAD）：[https://www.nist.gov/publications/trust-model-security-automation-data-10-tmsad](https://www.nist.gov/publications/trust-model-security-automation-data-10-tmsad)
