# 第一章：Ansible 简介

在我们的第一章中，我们将研究 Ansible 出现之前的技术世界，以便了解为什么需要 Ansible。

在我们开始讨论 Ansible 之前，让我们快速讨论一下旧世界。我从 90 年代末开始就一直在使用服务器，大多数是用来提供网页服务的，而当时的情况已经完全不同了。为了让你了解我是如何操作我的早期服务器的，这里是我运行服务器的前几年的简要概述。

和当时的大多数人一样，我最初使用的是共享托管账户，在那时，我对服务器端的任何事情都几乎没有控制权。当时运行的网站已经超出了共享托管的范围。我转移到了专用服务器——我以为我可以在这里展示未来的系统管理员能力，但我错了。

我得到的服务器是 Cobalt RaQ 3，一个 1U 服务器设备，我认为它领先于当时的技术。然而，我没有 root 级别的访问权限，对于我需要做的一切，我都必须使用基于 Web 的控制面板。最终，我获得了一定级别的访问权限，可以使用 SSH 或 Telnet 访问服务器（我知道，那是早期），并开始通过在 Web 控制面板中进行更改并查看服务器上的配置文件来自学成为系统管理员。

过了一段时间，我换了服务器，这次我选择放弃任何基于 Web 的控制面板，只使用我在 Cobalt RaQ 上学到的知识来配置我的第一个真正的**Linux, Apache, MySQL, PHP** (**LAMP**)服务器，使用我做的笔记。我创建了自己的运行手册，包括一行命令来安装和配置我需要的软件，以及大量的涂鸦来帮助我解决问题并保持服务器运行。

当我为另一个项目获得了第二台服务器后，我意识到这可能是一个好时机，可以打字记录我的笔记，这样在需要部署服务器时就可以复制粘贴，我很高兴我这样做了，因为就在我的第一台服务器失败后不久，我的主机道歉并用一台更新的操作系统替换了它，配置也更高。

于是，我打开了我的 Microsoft Word 文件，里面有我做的笔记，然后逐条复制粘贴每条指令，根据我需要安装的内容和升级后的操作系统进行调整。几个小时后，我的服务器恢复正常运行，我的数据也被恢复了。

我学到的一个重要教训之一是，备份永远不嫌多，另一个是不要使用 Microsoft Word 来存储这些类型的笔记；命令并不在乎你的笔记是否都是用漂亮的格式和 Courier 字体编写的。它在乎的是使用正确的语法，而 Word 已经自动更正和格式化为打印格式。

所以，我在服务器上复制了历史文件，并将我的笔记转录成纯文本。这些笔记成为了接下来几年的基础，因为我开始对其中的部分内容进行脚本化，主要是那些不需要用户输入的部分。

这些命令片段、一行命令和脚本都是通过 Red Hat Linux 6 进行调整的，一直到 CentOS 3 和 4。

当我改变了角色，停止了从 Web 主机那里获取服务，并开始为 Web 主机工作时，事情变得复杂起来。突然间，我开始为可能有不同需求的客户构建服务器——没有一个服务器是相同的。

从这里开始，我开始使用 Kickstart 脚本、PXE 引导服务器、镜像服务器上的 gold master、虚拟机和开始提示正在构建的系统的信息的 bash 脚本。我也从只需要担心维护自己的服务器转变为需要登录数百个不同的物理和虚拟服务器，从属于我工作的公司的服务器到客户机器。

在接下来的几年里，我的单个文本文件迅速变成了一个复杂的笔记、脚本、预编译二进制文件和信息电子表格的集合，如果我诚实地说，这些东西只有我自己能理解。

虽然我已经开始使用 bash 脚本和串联命令来自动化我的日常工作的很多部分，但我发现我的日子仍然充满了手动运行所有这些任务，以及处理客户报告的问题和查询的服务台工作。

我的故事可能是许多人的典型，而使用的操作系统可能被认为是相当古老的。现在，使用 GUI 作为入口并转向命令行，同时保留常用命令的草稿本，是我听说过的一个很常见的过程。

我们将涵盖以下主题：

+   谁在背后支持 Ansible

+   Ansible 与其他工具的区别

+   Ansible 解决的问题

# Ansible 的故事

让我们快速看一下谁写了 Ansible，以及 Ansible 的含义。

# 这个术语

在讨论 Ansible 的起源之前，我们应该快速讨论一下名称的起源。术语 Ansible 是由科幻小说作家乌苏拉·勒·格恩创造的；它首次出现在她 1966 年首次出版的小说《洛坎农的世界》中。在故事的背景下，**Ansible**是一个虚构的设备，能够比光速更快地发送和接收消息。

1974 年，乌苏拉·勒·格恩的小说《被放逐者：一个模棱两可的乌托邦》出版；这本书通过探索（虚构的）数学理论的细节，展示了 Ansible 技术的发展，使得这样的设备成为可能。

这个术语后来被这个类型的其他一些著名作者使用，用来描述能够在星际距离上传递消息的通信设备。

# 这个软件

Ansible 软件最初是由 Michael DeHaan 开发的，他也是《Cobbler》的作者，该软件是在 DeHaan 为红帽公司工作时开发的。

Cobbler 是一个 Linux 安装服务器，允许您在网络中快速部署服务器；它可以帮助进行 DNS、DHCP、软件包更新和分发、虚拟机部署、物理主机的电源管理，以及新部署的服务器（无论是物理的还是虚拟的）交接给配置管理系统。

DeHaan 离开了红帽公司，为 Puppet 等公司工作，这是一个很好的选择，因为 Cobbler 的许多用户使用它来交给 Puppet 服务器管理一旦它们被配置。

离开 Puppet 几年后，DeHaan 在 2012 年 2 月 23 日对 Ansible 项目进行了第一次公开提交。最初的 README 文件给出了一个非常简单的描述，为 Ansible 最终将成为的基础奠定了基础：

"Ansible 是一个超级简单的 Python API，用于通过 SSH 执行'远程任务'。与我共同编写的 Func 一样，它希望避免使用 SSH 并拥有自己的守护程序基础设施，Ansible 希望成为完全不同和更简化，但仍然能够随着时间的推移更加模块化地增长。"

自第一次提交以来，在撰写本文时，已经有 3000 名贡献者在 38 个分支和 195 个发布中进行了超过 35,000 次提交。

2013 年，该项目发展壮大，Ansible, Inc.成立，为依赖该项目管理他们的教练和服务器的 Ansible 用户提供商业支持，无论是物理的、虚拟的还是托管在公共云上的。

Ansible, Inc.的成立，获得了 600 万美元的 A 轮融资，推出了商业版的 Ansible Tower，作为一个基于 Web 的前端，最终用户可以在那里消费基于角色的 Ansible 服务。

然后，在 2015 年 10 月，红帽宣布他们将以 1.5 亿美元收购 Ansible。在宣布中，当时担任红帽管理副总裁的 Joe Fitzgerald 被引述说：

“Ansible 是 IT 自动化和 DevOps 领域的领军者，有助于红帽在创造无摩擦的 IT 目标上迈出重要一步。”

在本书的过程中，您会发现原始 README 文件中的声明和 Red Hat 在收购 Ansible 时的声明仍然成立。

在我们开始动手安装 Ansible 之前，我们应该先了解一些围绕它的核心概念。

# Ansible 与其他工具

如果您比较第一个提交中的设计原则和当前版本，您会注意到虽然有一些增加和调整，但核心原则基本保持不变：

+   **无代理**：一切都应该由 SSH 守护程序、Windows 机器的 WinRM 协议或 API 调用来管理——不应该依赖于自定义代理或需要在目标主机上打开或交互的其他端口

+   **最小化**：您应该能够管理新的远程机器，而无需安装任何新软件，因为每台 Linux 主机通常都会在最小安装的一部分中安装至少 SSH 和 Python

+   **描述性**：您应该能够用机器和人都能读懂的语言描述您的基础架构、堆栈或任务

+   **简单**：设置过程和学习曲线应该简单且直观

+   **易于使用**：这应该是最容易使用的 IT 自动化系统

其中一些原则使 Ansible 与其他工具有很大不同。让我们来看看 Ansible 和 Puppet、Chef 等其他工具之间最基本的区别。

# 声明式与命令式

当我开始使用 Ansible 时，我已经实施了 Puppet 来帮助管理我管理的机器上的堆栈。随着配置变得越来越复杂，Puppet 代码变得非常复杂。这时我开始寻找一些解决我面临问题的替代方案。

Puppet 使用自定义的声明性语言来描述配置。然后，Puppet 将这个配置打包成一个清单，然后运行在每台服务器上的代理程序应用这个清单。

使用声明性语言意味着 Puppet、Chef 和其他配置工具（如 CFEngine）都使用最终一致性的原则运行，这意味着最终，在代理程序运行几次后，您的期望配置将就位。

另一方面，Ansible 是一种命令式语言，这意味着你不仅要定义所需结果的最终状态，并让工具决定如何达到这个状态，还要定义任务执行的顺序，以达到你所定义的状态。

我倾向于使用的例子如下。我们有一个配置，需要将以下状态应用到服务器上：

1.  创建一个名为`Team`的组

1.  创建一个名为`Alice`的用户并将她添加到`Team`组

1.  创建一个名为`Bob`的用户并将他添加到`Team`组

1.  给用户`Alice`提升的特权

这可能看起来很简单；然而，当你使用声明性语言执行这些任务时，你可能会发现，例如，以下情况发生：

+   **运行 1**：任务按以下顺序执行：2、1、3 和 4。这意味着在第一次运行时，由于名为`Team`的组不存在，添加用户`Alice`失败，这意味着`Alice`从未获得提升的特权。然而，组`Team`被添加，用户`Bob`被添加。

+   **运行 2**：同样，任务按照以下顺序执行：2、1、3 和 4。因为在运行 1 期间创建了`Team`组，所以现在创建了用户`Alice`，并且她也被赋予了提升的特权。由于`Team`组和用户`Bob`已经存在，它们保持不变。

+   **运行 3**：任务按照运行 1 和 2 的相同顺序执行；然而，由于已经达到了期望的配置，因此没有进行任何更改。

每次运行都会继续，直到配置或主机本身发生变化，例如，如果`Bob`真的惹恼了`Alice`，她使用她的提升的特权从主机中删除用户`Bob`。当代理下次运行时，`Bob`将被重新创建，因为这仍然是我们期望的配置，不管`Alice`认为`Bob`应该有什么访问权限。

如果我们使用命令式语言运行相同的任务，那么应该发生以下情况：

+   **运行 1**：任务按照我们定义的顺序执行，这意味着首先创建组，然后创建两个用户，最后应用`Alice`的提升特权

+   **运行 2**：同样，任务按照顺序执行，并进行检查以确保我们的期望配置已经就位

正如您所看到的，这两种方式都可以达到我们的最终配置，并且它们也强制执行我们的期望状态。使用声明性语言的工具可以声明依赖关系，这意味着我们可以简单地消除运行任务时遇到的问题。

然而，这个例子只有四个步骤；当您有几百个步骤在公共云平台上启动服务器，然后安装需要几个先决条件的软件时会发生什么？

这是我在开始使用 Ansible 之前发现自己处于的位置。Puppet 在强制执行我期望的最终配置方面做得很好；然而，在达到那里时，我发现自己不得不担心将大量逻辑构建到我的清单中，以达到我期望的状态。

令人讨厌的是，每次成功运行都需要大约 40 分钟才能完成。但由于我遇到了依赖问题，我不得不从头开始处理每次失败和更改，以确保我实际上是在解决问题，而不是因为事情开始变得一致而不得不重新开始——这不是在截止日期时想要的。

# 配置与编排

Ansible 与其他常常被比较的工具之间的另一个关键区别是，这些工具的大部分起源于被设计为部署和监控配置状态的系统。

它们通常需要在每个主机上安装代理，该代理会发现有关其安装主机的一些信息，然后回调到一个中央服务器，基本上说“嗨，我是服务器 XYZ，我可以请你给我配置吗？”然后服务器决定服务器的配置是什么样的，并将其发送给代理，然后代理应用它。通常，这种交换每 15 到 30 分钟发生一次——如果您需要强制执行服务器上的配置，这是很好的。

然而，Ansible 的设计方式使其能够充当编排工具；例如，您可以运行它在 VMware 环境中启动服务器，一旦服务器启动，它就可以连接到您新启动的机器并安装 LAMP 堆栈。然后，它永远不必再次连接到该主机，这意味着我们剩下的只是服务器、LAMP 堆栈，除了可能在文件中添加一些注释以表明 Ansible 添加了一些配置行之外，没有其他东西，但这应该是 Ansible 用于配置主机的唯一迹象。

# 基础设施即代码

在我们完成本章并继续安装 Ansible 之前，让我们快速讨论基础设施即代码，首先通过查看一些实际的代码来了解。以下 bash 脚本使用`yum`软件包管理器安装了几个 RPM 包：

```
#!/bin/sh
LIST_OF_APPS="dstat lsof mailx rsync tree vim-enhanced git whois iptables-services"
yum install -y $LIST_OF_APPS
```

以下是一个 Puppet 类，执行与之前的 bash 脚本相同的任务：

```
class common::apps {
  package{
    [
      'dstat',
      'lsof',
      'mailx',
      'rsync',
      'tree',
      'vim-enhanced',
      'git',
      'whois',
      'iptables-services',
    ]:
    ensure => installed,
  }
}
```

接下来，我们使用 SaltStack 执行相同的任务：

```
common.packages:
  pkg.installed:
    - pkgs:
      - dstat
      - lsof
      - mailx
      - rsync
      - tree
      - vim-enhanced
      - git
      - whois
      - iptables-services
```

最后，我们再次执行相同的任务，这次使用 Ansible：

```
- name: install packages we need
  yum:
    name: "{{ item }}"
    state: "latest"
  with_items:
    - dstat
    - lsof
    - mailx
    - rsync
    - tree
    - vim-enhanced
    - git
    - whois
    - iptables-services
```

即使不详细介绍，您也应该能够了解这三个示例各自在做什么。这三个示例虽然不严格属于基础设施，但都是基础设施即代码的有效示例。

在这里，您以与开发人员管理其应用程序源代码完全相同的方式管理管理基础设施的代码。您使用源代码控制，在一个中心可用的存储库中存储它，与同行合作，分支并使用拉取请求检查您的更改，并在可能的情况下编写和执行单元测试，以确保对基础设施的更改在部署到生产环境之前是成功的和无错误的。这应尽可能自动化。在提到的任务中的任何手动干预都应被视为潜在的故障点，您应该努力自动化任务。

这种基础设施管理方法有一些优势，其中之一是作为系统管理员，您正在使用与开发人员同样的流程和工具，这意味着适用于他们的任何程序也适用于您。这使工作体验更加一致，同时让您接触到以前可能没有接触或使用过的工具。

其次，更重要的是，它允许您分享您的工作。在采用这种方法之前，这种工作似乎对其他人来说是系统管理员专有的黑暗艺术。在公开进行这项工作可以让您的同行审查和评论您的配置，同时也可以让您做同样的事情来审查他们的配置。此外，您可以分享您的工作，以便其他人可以将其中的元素纳入他们自己的项目中。

# 摘要

在完成本章之前，我想结束一下我的个人经历。正如本章其他地方提到的，我从我的脚本和运行簿集合转移到了 Puppet，这很棒，直到我的需求不再局限于管理服务器配置和维护我管理的服务器的状态。

我需要开始在公共云中管理基础设施。当使用 Puppet 时，这个要求很快开始让我感到沮丧。当时，Puppet 对我需要用于基础设施的 API 的覆盖范围不足。我相信现在它的覆盖范围要好得多，但我也发现自己不得不在我的清单中构建太多的逻辑，涉及每个任务执行的顺序。

大约在 2014 年 12 月左右，我决定看看 Ansible。我知道这是因为我写了一篇名为*First Steps With Ansible*的博客文章，从那时起，我想我再也没有回头看过。自那时起，我已经向我的同事和客户介绍了 Ansible，并为 Packt 写了之前的书籍。

在本章中，我们回顾了我个人与 Ansible 以及与之相比的其他工具的历史，并讨论了这些工具之间的区别以及 Ansible 的起源。

在下一章中，我们将介绍如何安装 Ansible 并针对本地虚拟机运行我们的第一个 playbook。

# 进一步阅读

在本章中，我们提到了 Puppet 和 SaltStack：

+   Puppet 是一个运行服务器/代理配置的配置管理工具。它有两种版本——开源版本和由 Puppet 公司支持的企业版本。它是一个声明性系统，与 Ruby 密切相关。有关 Puppet 的更多信息，请参见[`puppet.com/`](https://puppet.com/)。

+   SaltStack 是另一个配置管理工具。它具有极高的可扩展性，虽然与 Ansible 共享设计方法，但它的工作方式类似于 Puppet，采用了服务器/代理的方式。您可以在[`saltstack.com/`](https://saltstack.com/)找到更多关于 SaltStack 的信息。

+   我还提到了我的博客，您可以在[`media-glass.es/`](https://media-glass.es/)找到。
