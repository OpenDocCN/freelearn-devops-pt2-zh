- en: Next Steps with Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步使用Ansible
- en: 'In this chapter, we will discuss how Ansible can be integrated into your day-to-day
    workflows, from continuous integration tools to monitoring tools and troubleshooting.
    We will discuss the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何将Ansible集成到您的日常工作流程中，从持续集成工具到监控工具和故障排除。我们将讨论以下主题：
- en: How to integrate Ansible with services such as Slack
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将Ansible与Slack等服务集成
- en: How you can use Ansible to troubleshoot problems when they occur
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您如何可以使用Ansible来解决问题
- en: Some real-world examples
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些真实世界的例子
- en: Let's dive straight in and look at how we can hook our playbooks into third-party
    services.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接深入研究如何将我们的playbooks连接到第三方服务。
- en: Integrating with third-party services
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与第三方服务集成
- en: Although you may be the one running the playbooks, you may keep a log of your
    playbook run or keep other members of your team or even other departments up to
    date with the results of the playbook run. Ansible ships with several core modules
    that allow you to work with third-party services to provide real-time notifications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可能是运行playbooks的人，但您可能会保留playbook运行的日志，或者让您团队的其他成员，甚至其他部门了解playbook运行的结果。Ansible附带了几个核心模块，允许您与第三方服务一起工作，以提供实时通知。
- en: Slack
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Slack
- en: Slack has very quickly become the go-to choice for team-based collaboration
    services for various departments in IT services. Not only does it support third-party
    applications via its App Directory, but it also has a powerful API that you can
    use to bring your tools into the chat rooms provided by Slack.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Slack已经迅速成为各个IT服务部门团队协作服务的首选选择。它不仅通过其应用程序目录支持第三方应用程序，而且还具有强大的API，您可以使用该API将您的工具带入Slack提供的聊天室。
- en: We are going to look at the example in this section, the full playbook, which
    can be found in the `Chapter17/slack` folder in the GitHub repository. I have
    taken the playbook from [Chapter 9](625a5b00-6e3d-4339-8014-c1885db38f76.xhtml),
    *Building Out a Cloud Network*, where we created a VPC in AWS, and I have adapted
    it to use the `slack` Ansible module.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中查看示例，完整的playbook可以在GitHub存储库的`Chapter17/slack`文件夹中找到。我已经从[第9章](625a5b00-6e3d-4339-8014-c1885db38f76.xhtml)中的playbook中获取了playbook，*构建云网络*，在那里我们在AWS中创建了一个VPC，并且我已经改编它以使用`slack`
    Ansible模块。
- en: Generating a token
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成令牌
- en: Before we can use the Slack module in our Playbook, we need an access token
    to request one login to your Slack workspace; you can sign up for a workspace
    for free at [https://slack.com/](https://slack.com/) if you don't already have
    one.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Playbook中使用Slack模块之前，我们需要一个访问令牌来请求一个登录到您的Slack工作区；如果您还没有工作区，您可以免费注册一个工作区[https://slack.com/](https://slack.com/)。
- en: 'Once you are logged into your workspace, either using the web client or desktop
    application, select the Manage apps option from the Administration menu, as seen
    in the following screenshot:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您登录到您的工作区，无论是使用Web客户端还是桌面应用程序，都可以从管理应用选项中选择管理应用选项，如下截图所示：
- en: '![](assets/e1f3b335-5823-4712-bdea-36fa6db8418b.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e1f3b335-5823-4712-bdea-36fa6db8418b.png)'
- en: This will open your browser and take you to the App Directory for your workspace;
    from here, search for `Incoming WebHooks` and then click on Add Configuration.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开您的浏览器，并将您带到您工作区的应用程序目录；从这里，搜索`传入WebHooks`，然后点击添加配置。
- en: The first part of the configuration is to choose which channel you would like
    the incoming Webhook to post messages to. I selected the general channel—once
    selected, you will be taken to a page that gives you a Webhook URL; make sure
    that you make a note of this URL as we will need it shortly. At the bottom of
    the page, you have the option to customize your Webhook.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的第一部分是选择您希望传入Webhook发布消息的频道。我选择了通用频道——一旦选择，您将被带到一个页面，该页面会给您一个Webhook URL；确保您记下这个URL，因为我们很快就会需要它。在页面底部，您可以选择自定义您的Webhook。
- en: 'In the Integration Settings at the bottom of the page, I entered the following
    information:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面底部的集成设置中，我输入了以下信息：
- en: 'Post to Channel: I left it as #general'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布到频道：我将其留在#general
- en: 'Webhook URL: This is prepopulated for you; you also have the choice of regenerating
    the URL here'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webhook URL：这是为您预填充的；您还可以选择在此重新生成URL
- en: 'Descriptive Label: I entered `Ansible` here'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述性标签：我在这里输入了`Ansible`
- en: 'Customize Name: I entered `Ansible` here as well'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义名称：我也在这里输入了`Ansible`
- en: 'Customize Icon: I left this as it was'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义图标：我将其保留为原样
- en: 'Once the preceding details had been filled in, I clicked on the Save Settings
    button; this left me with a single incoming Webhook:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 填写完前面的细节后，我点击了保存设置按钮；这让我得到了一个传入的Webhook：
- en: '![](assets/76ce0142-b8e1-4210-bfe2-85b7d536d0d8.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/76ce0142-b8e1-4210-bfe2-85b7d536d0d8.png)'
- en: 'As mentioned already, I also made a note of the Webhook URL; for me, it was:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我还记录了Webhook URL；对我来说，它是：
- en: '`https://hooks.slack.com/services/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`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://hooks.slack.com/services/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`'
- en: Now that we have everything, we need to be configured on the Slack side to be
    able to start to send messages to our users using Ansible.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了一切，我们需要在Slack端进行配置，以便开始使用Ansible向我们的用户发送消息。
- en: The Ansible playbook
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible playbook
- en: 'I am only going to cover the updating of the tasks for a single role here,
    and it is the role that creates the VPC. The first change I made was to add a
    few lines to the `group_vars/common.yml` file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我只会在这里介绍单个角色任务的更新，这是创建VPC的角色。我做的第一个更改是在`group_vars/common.yml`文件中添加了几行：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, I added the following three nested variables:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我添加了以下三个嵌套变量：
- en: '`token`: This is taken from the Webhook URL; as you can see, I entered everything
    after `https://hooks.slack.com/services/`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`令牌`：这是从Webhook URL中获取的；如您所见，我输入了`https://hooks.slack.com/services/`后的所有内容'
- en: '`username`: We can override the username through which the updates will be
    posted, as I just kept it as Ansible'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`用户名`：我们可以通过它来覆盖将发布更新的用户名，我只是将其保留为Ansible'
- en: '`icon`: This is the avatar that will be displayed as part of our post'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`图标`：这是我们发布的一部分将显示的头像'
- en: 'If you remember the VPC role from before, you''ll recall that it contained
    a single task that used the `ec2_vpc_net` module to create a VPC. Now, we want
    to introduce Slack notifications, and to be able to provide our users with feedback.
    So, first of all, let''s send a notification to say that we are checking whether
    the VPC exists:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得之前的VPC角色，您会记得它包含一个使用`ec2_vpc_net`模块创建VPC的单个任务。现在，我们想引入Slack通知，并能够向用户提供反馈。因此，首先，让我们发送通知，说我们正在检查VPC是否存在：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see from the preceding task, we are sending a message that, in our
    case, will read `Checking for VPC called ''VPC-Slack''`, along with `token`, `username`,
    and `icon`. The next task in the role is the one from the original role:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的任务中可以看到，我们正在发送一条消息，在我们的情况下，它将读取`Checking for VPC called 'VPC-Slack'`，以及`token`、`username`和`icon`。角色中的下一个任务是原始角色中的任务：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, one of two things would have happened: a VPC called `VPC-Slack` would
    have been created, or Ansible would have gathered information on an already-existing
    VPC called `VPC-Slack`. When we send the message to our users, it should change
    depending upon what Ansible did. The following task sends a message informing
    our users that a new VPC has been created:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可能发生了两种情况：一个名为`VPC-Slack`的VPC已经创建，或者Ansible已经收集了关于名为`VPC-Slack`的现有VPC的信息。当我们向用户发送消息时，它应该根据Ansible的操作而改变。以下任务发送一条消息，通知我们的用户已经创建了一个新的VPC：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that I only run this task when the `vpc_info` variable I registered is
    marked as changed. Also, I pass the ID of the VPC as part of the message. If `vpc_info`
    didn''t register any changes, then the preceding task will be skipped; the following
    task will run instead:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只有在我注册的`vpc_info`变量标记为更改时，我才运行此任务。此外，我将VPC的ID作为消息的一部分传递。如果`vpc_info`没有注册任何更改，那么前面的任务将被跳过；而后面的任务将会运行：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note how I am changing the wording and also how it is only being called when
    there is no change. I went through the rest of the roles, adding tasks to send
    notifications to Slack using the same logic as in the preceding code; as mentioned,
    you can find all the additions in the `Chapter17/slack` folder in the repository.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我如何改变措辞，以及它仅在没有更改时才被调用。我浏览了其他角色，添加了使用与前面代码相同逻辑的任务，向Slack发送通知；如前所述，您可以在存储库的`Chapter17/slack`文件夹中找到所有添加。
- en: Running the playbook
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行playbook
- en: 'When running the playbook, use the following commands:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行playbook时，请使用以下命令：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'I received the following notifications from Slack:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我从Slack收到了以下通知：
- en: '![](assets/0367dde3-92bd-456f-a67c-c06edc828a1e.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0367dde3-92bd-456f-a67c-c06edc828a1e.png)'
- en: 'As you can see, a lot of the messages are talking about services within the
    VPC being created. Rerunning the playbook immediately after returns the following
    results:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，许多消息都是关于在VPC中创建的服务。立即重新运行playbook后，返回以下结果：
- en: '![](assets/b0174ed9-8e7a-4925-928f-f7c13b3d1277.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b0174ed9-8e7a-4925-928f-f7c13b3d1277.png)'
- en: This time, the messages are talking about finding existing services and returning
    the IDs. Slack is just one service. Let's now take a brief look at a few more
    of the services you can interact with from your Ansible playbooks.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，消息是关于查找现有服务并返回ID。Slack只是一个服务。现在让我们简要地看一下您可以从Ansible playbook与之交互的其他一些服务。
- en: Other services
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他服务
- en: Slack is not the only service that Ansible can interact with; here are some
    more that you may want to use in your playbooks.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Slack不是Ansible可以与之交互的唯一服务；以下是您可能希望在playbook中使用的其他一些服务。
- en: Campfire
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Campfire
- en: 'Campfire is a chat service built into Basecamp; you can use this module to
    send updates to your project stakeholders directly from Ansible, for example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Campfire是内置在Basecamp中的聊天服务；您可以使用此模块直接从Ansible向项目利益相关者发送更新，例如：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Cisco Webex Teams (Cisco Spark)
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cisco Webex Teams（Cisco Spark）
- en: 'Cisco Webex Teams, or Cisco Spark as it was formally known, is the collaboration
    service from Cisco that provides your teams with virtual meeting spaces, messages,
    and video calling. Also, it has a rich API that Ansible can be configured to interact
    with:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Cisco Webex Teams，或者正式称为Cisco Spark，是Cisco提供的协作服务，为您的团队提供虚拟会议空间、消息和视频通话。此外，它还具有丰富的API，可以配置Ansible与之交互：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: CA Flowdock
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CA Flowdock
- en: 'CA Flowdock is a messaging service, which has been designed from the ground
    up to integrate with developer-focused services, such as GitHub, Bitbucket, Jira,
    Jenkins, and Ansible:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: CA Flowdock是一个消息服务，从头开始设计，以与面向开发人员的服务集成，如GitHub、Bitbucket、Jira、Jenkins和Ansible：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Hipchat
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hipchat
- en: 'Hipchat is the group-messaging service provided by Atlassian; it has tight
    integration with the rest of the Atlassian family of products:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Hipchat是由Atlassian提供的群组消息服务；它与Atlassian产品系列的其他产品紧密集成：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Mail
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mail
- en: 'This service shouldn''t need any introduction; Ansible can be configured to
    send emails using all sorts of configuration. The following example shows an email
    being sent through an external SMTP server:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这项服务不需要任何介绍；可以配置Ansible使用各种配置发送电子邮件。以下示例显示了通过外部SMTP服务器发送电子邮件：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Mattermost
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mattermost
- en: 'Mattermost is an open source alternative to proprietary services like the ones
    we have covered elsewhere in the list (for example, Slack, Cisco Webex Teams,
    and Hipchat):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Mattermost是专有服务的开源替代品，类似于我们在列表中其他地方介绍的服务（例如Slack、Cisco Webex Teams和Hipchat）：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Say
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Say
- en: 'Most modern computers come with some level of voice synthesis built in; using
    this module, you can have Ansible verbally inform you of the status of your playbook
    run:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代计算机都内置了一定程度的语音合成；使用此模块，您可以让Ansible口头通知您playbook运行的状态：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ServiceNow
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ServiceNow
- en: 'ServiceNow is the enterprise-grade IT service management Software as a service
    product provided by ServiceNow, Inc. Using the `snow_record` module, your playbook
    can open incidents within your ServiceNow installation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceNow是ServiceNow, Inc.提供的企业级IT服务管理软件即服务产品。使用`snow_record`模块，您的playbook可以在ServiceNow安装中打开事件：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Syslog
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Syslog
- en: 'If you ship the log files from your hosts, then you may want to send the results
    of the playbook run to your hosts syslog so that it is shipped to your central
    logging service:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从主机发送日志文件，则可能希望将playbook运行的结果发送到主机syslog，以便将其发送到您的中央日志服务：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Twilio
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Twilio
- en: 'Use your Twilio account to send an SMS message directly from your Ansible playbook,
    as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的Twilio帐户直接从您的Ansible playbook发送短信消息，如下所示：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Summary of third-party services
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方服务摘要
- en: One of the takeaways I hope you get from this book is that automation is great—it
    is not only a real-time saver, but using tools like the ones we covered in the
    previous chapter, Ansible Tower and Ansible AWX, can enable people who are not
    sys-admins or developers to execute their playbooks from a friendly web interface.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您从这本书中得到的一个要点是自动化很棒——它不仅可以节省时间，而且使用我们在上一章中介绍的工具，如Ansible Tower和Ansible AWX，可以让非系统管理员或开发人员从友好的Web界面执行他们的playbook。
- en: The modules we have covered in this section allow you take your automation to
    the next level by not only allowing you to record the results, but to also automatically
    do some housekeeping during your playbook run and have it notify your users itself.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中涵盖的模块不仅允许您记录结果，还可以在播放过程中自动进行一些清理工作，并让它自己通知您的用户，从而使您的自动化水平提升到一个新的高度。
- en: Let's say, for example, you need to deploy a new configuration to your server.
    Your service desk raises a change for you to action the work within your ServiceNow
    installation. Your playbook could be written in such a way that before the change
    is actioned, it uses the `fetch` module to copy the configuration file to your
    Ansible Controller. The playbook could then use the `snow_record` module attach
    a copy of the existing configuration file to the change request, proceed to make
    the changes, and then automatically update the change request with the results.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您需要将新配置部署到服务器。您的服务台为您提出更改，以便您在ServiceNow安装中执行工作。您的playbook可以这样编写，在执行更改之前，它使用`fetch`模块将配置文件复制到您的Ansible
    Controller。然后playbook可以使用`snow_record`模块将现有配置文件的副本附加到更改请求，继续进行更改，然后自动更新更改请求的结果。
- en: 'You can find details on the services mentioned in this part of the chapter
    at the following URLs:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章中提到的服务的以下URL中找到详细信息：
- en: '**Slack**: [https://slack.com/](https://slack.com/)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Slack**：[https://slack.com/](https://slack.com/)'
- en: '**Campfire**: [https://basecamp.com/](https://basecamp.com/)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Campfire**：[https://basecamp.com/](https://basecamp.com/)'
- en: '**Cisco Webex Teams (Cisco Spark)**: [https://www.webex.com/products/teams/](https://www.webex.com/products/teams/)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思科Webex团队（思科Spark）：[https://www.webex.com/products/teams/](https://www.webex.com/products/teams/)
- en: '**CA Flowdock**: [https://www.flowdock.com/](https://www.flowdock.com/)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CA Flowdock**：[https://www.flowdock.com/](https://www.flowdock.com/)'
- en: '**Mattermost**: [https://mattermost.com/](https://mattermost.com/)'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mattermost**：[https://mattermost.com/](https://mattermost.com/)'
- en: '**ServiceNow**: [https://www.servicenow.com/](https://www.servicenow.com/)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ServiceNow**：[https://www.servicenow.com/](https://www.servicenow.com/)'
- en: '**Twilio**: [https://twilio.com/](https://twilio.com/)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Twilio**：[https://twilio.com/](https://twilio.com/)'
- en: The Ansible playbook debugger
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible playbook调试器
- en: 'Ansible has a debugger built in. Let''s take a look at how you can build this
    into your playbook by creating a simple playbook with an error. As we have just
    mentioned it, we are going to write a playbook that uses the `say` module. The
    playbook itself looks as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible内置了调试器。让我们看看如何通过创建一个带有错误的简单playbook将其构建到您的playbook中。正如我们刚才提到的，我们将编写一个使用`say`模块的playbook。playbook本身如下所示：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are two things to point out: the first being the mistake. As you can
    see, we are defining a variable named `message`, but when we come to use it the
    task, I have made a typo and entered `massage` instead. Luckily, as I am developing
    the playbook, I have instructed Ansible to drop to the interactive debugger whenever
    a task fails.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件事需要指出：第一是错误。正如您所看到的，我们正在定义一个名为`message`的变量，但是当我们使用它时，我输错了，输入了`massage`。幸运的是，因为我正在开发playbook，每当任务失败时，我都指示Ansible进入交互式调试器。
- en: Debugging the task
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试任务
- en: 'Let''s run the playbook and see what happens:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行playbook，看看会发生什么：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first problem is that we are not passing a host inventory file, so there
    will be warnings that only the localhost is available; this is fine, as we want
    to run the `say` module only on our Ansible Controller anyway:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是我们没有传递主机清单文件，因此将会收到警告，只有本地主机可用；这没关系，因为我们只想在我们的Ansible Controller上运行`say`模块：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, Ansible runs the play itself; this should result in a fatal error:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Ansible运行play本身；这应该会导致致命错误：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Typically, the playbook run will stop, and you will be returned to your shell;
    however, because we have instructed Ansible to drop into the interactive debugger,
    we now see the following prompt:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，playbook运行将停止，并且您将返回到您的shell；但是，因为我们已经指示Ansible进入交互式调试器，现在我们看到以下提示：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'From here, we can start to look into the problem a little more; for example,
    we can review the error by typing the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们可以更仔细地研究问题；例如，我们可以通过输入以下命令来查看错误：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once you hit the *Enter* key, the results of the failed task will be returned:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您按下*Enter*键，失败任务的结果将返回：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s take a closer look at the variables used in the task by typing the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下内容，让我们更仔细地查看任务中使用的变量：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will return the two arguments we are using in the task:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回我们在任务中使用的两个参数：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s take a look at the variables that are available to the task using
    the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下方式查看任务可用的变量：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You may have noted that we instructed Ansible to execute the setup module as
    part of the playbook run; that is to keep this list of available variables to
    a minimum:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们指示Ansible在playbook运行中执行setup模块；这是为了将可用变量列表保持在最小范围内：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, there is a lot of information there about the environment our
    playbook is being executed on. In the list of variables, you will notice that
    two of them are prefixed with a `u`: they are `voice` and `message`. We can find
    out more about these by running:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从前面的输出中所看到的，关于我们的playbook正在执行的环境有很多信息。在变量列表中，您会注意到其中两个变量以`u`为前缀：它们是`voice`和`message`。我们可以通过运行以下命令来了解更多信息：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will display the contents of the variable:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示变量的内容：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We know that we are passing a misspelt variable to the `msg` argument, so we
    make some changes on the fly and continue the playbook run. To do this, we are
    going to run the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们正在将一个拼写错误的变量传递给`msg`参数，因此我们可以即时进行一些更改并继续playbook运行。为此，我们将运行以下命令：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will update the argument to use the correct variable meaning, so that
    we can rerun the task by running the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更新参数以使用正确的变量意思，这样我们可以通过运行以下命令重新运行任务：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will immediately rerun the task with the correct argument and, with any
    luck, you should hear *The task has completed, and all is well*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将立即使用正确的参数重新运行任务，并且幸运的话，您应该会听到*任务已完成，一切正常*：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see from the preceding output, because we only have a single task,
    the playbook completed. If we had more, then it would carry on from where it left
    off. You can now update your playbook with the correct spelling and proceed with
    the rest of your day.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的输出中所看到的，因为我们只有一个任务，playbook已经完成。如果我们有更多任务，那么它将从离开的地方继续。现在您可以使用正确的拼写更新您的playbook，并继续您的一天。
- en: Also, if we wanted to, we could have typed either `continue` or `quit` to proceed
    or stop respectively.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们愿意，我们可以输入`continue`或`quit`来分别继续或停止。
- en: Summary of the Ansible debugger
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible调试器摘要
- en: The Ansible debugger is an extremely useful option to enable when you are working
    on creating large playbooks—for example, imagine that you have a playbook that
    takes about 20 minutes to run, but there is an error somewhere toward the end,
    say, 15 minutes after you first run the playbook.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当您正在创建大型playbook时，启用Ansible调试器是一个非常有用的选项——例如，想象一下，您有一个大约需要运行20分钟的playbook，但是在结束时出现了一个错误，比如在您第一次运行playbook后的15分钟。
- en: Having Ansible drop into the interactive debugger shell not only means you can
    see exactly what is and isn't defined, but it also means that you don't have to
    blindly make changes to your playbook and then wait another 15 minutes to see
    whether those changes resolved whatever was causing the fatal error.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让Ansible进入交互式调试器shell不仅意味着您可以准确地看到定义和未定义的内容，而且还意味着您不必盲目地对playbook进行更改，然后等待另外15分钟以查看这些更改是否解决了导致致命错误的问题。
- en: Real-world examples
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实世界的例子
- en: 'Before we finish the chapter, and also the book, I thought I would give a few
    examples of how I am using Ansible and interacting with Ansible: the first is
    interacting with Ansible using chat.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章，也结束本书之前，我想给出一些我如何使用Ansible和与Ansible交互的例子：第一个是使用聊天与Ansible交互。
- en: The chat example
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聊天示例
- en: A few months ago, I needed to set up a demo to show automation working—however,
    I needed to be able to show the demo on my laptop or phone, which meant that I
    couldn't assume I had access to the command line.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 几个月前，我需要设置一个演示来展示自动化工作，但是，我需要能够在我的笔记本电脑或手机上展示演示，这意味着我不能假设我可以访问命令行。
- en: 'The demo I came up with ended up using Slack and a few other tools that we
    haven''t covered in this book, namely Hubot and Jenkins; before I go into any
    details, let''s quickly have a look at the output of the demo running:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我想出的演示最终使用了Slack和其他一些我们在这本书中没有涵盖的工具，即Hubot和Jenkins；在我详细介绍之前，让我们快速看一下演示运行的输出：
- en: '![](assets/d7fb0ae5-d86c-4d81-a9b2-b64a66d6dcad.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/d7fb0ae5-d86c-4d81-a9b2-b64a66d6dcad.png)
- en: 'As you can see from the preceding output, I asked the following in a Slack
    channel:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出所示，我在Slack频道中提出了以下问题：
- en: '*@bot give me a linux server*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*@bot给我一个Linux服务器*'
- en: 'This then triggered an Ansible playbook run, which launched an instance in
    AWS and returned information on the instance once the playbook had confirmed that
    the server was available on the network. I also configured it to remove all running
    instances by asking the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后触发了一个Ansible playbook运行，该运行在AWS中启动了一个实例，并在playbook确认服务器在网络上可用后返回实例的信息。我还配置它通过询问以下内容来删除所有正在运行的实例：
- en: '*@bot terminate all servers*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*@bot终止所有服务器*'
- en: 'As you can see, this runs another playbook, and this time, returns an animated
    GIF once the instance has been removed:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这运行了另一个playbook，并且这次，在实例被删除后返回了一个动画GIF：
- en: '![](assets/2171890b-ee00-4138-adee-d95714316cab.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/2171890b-ee00-4138-adee-d95714316cab.png)
- en: So, what did I use for this? As already mentioned, for a start, I used Hubot.
    Hubot is an open source extendable chatbot developed by GitHub. It was configured
    using the `hubot-slack` plugin in my Slack channel, and it listened out for any
    commands it was given.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我用什么做到这一点呢？正如前面提到的，首先，我使用了Hubot。Hubot是GitHub开发的一个开源可扩展的聊天机器人。它是在我的Slack频道中使用`hubot-slack`插件进行配置的，并且它会监听任何给定的命令。
- en: I used the `hubot-alias` plugin to define an alias that translated *@bot give
    me a linux server* into *build awslaunch OS=linux*; this used the`hubot-yardmaster`
    plugin to trigger to a build in my Jenkins installation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`hubot-alias`插件来定义一个别名，将*@bot给我一个Linux服务器*翻译成*build awslaunch OS=linux*；这使用了`hubot-yardmaster`插件来触发我的Jenkins安装中的构建。
- en: Jenkins is an open source automation server, used mostly for continuous integration
    and also continuous delivery—it too has a plugin architecture. Using the Jenkins
    Ansible plugin and also the Jenkins Git  plugin, I was able to pull the playbook
    and roles used to launch the AWS instance to my Jenkins server and then have Jenkins
    run the playbook for me—the playbook itself wasn't too dissimilar from the playbook
    we worked through in [Chapter 9](625a5b00-6e3d-4339-8014-c1885db38f76.xhtml),
    *Building Out a Cloud Network*, and [Chapter 10](56e8175f-d1a8-4b63-ad3f-fe94ff55135e.xhtml),
    *Highly Available Cloud Deployments*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是一个开源的自动化服务器，主要用于持续集成和持续交付，它也有一个插件架构。使用Jenkins Ansible插件和Jenkins Git插件，我能够将用于启动AWS实例的playbook和角色拉到我的Jenkins服务器上，然后让Jenkins为我运行playbook——playbook本身与我们在[第9章](625a5b00-6e3d-4339-8014-c1885db38f76.xhtml)和[第10章](56e8175f-d1a8-4b63-ad3f-fe94ff55135e.xhtml)中讨论的playbook并没有太大不同，分别是*构建云网络*和*高可用云部署*。
- en: The playbook had a little logic built into it that limited the number of instances
    that could be launched, randomized the name of the instance that it was launching,
    and also displayed a random GIF from a list of several options—all of this information,
    along with details of the instance and the AMI, were all passed to the user via
    the Ansible Slack module to give the impression that the playbook was actually
    doing more than it was.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: playbook中内置了一些逻辑，限制了可以启动的实例数量，随机化了要启动的实例的名称，并从几个选项中显示了一个随机的GIF图像——所有这些信息，以及实例和AMI的详细信息，都通过Ansible
    Slack模块传递给用户，给人一种playbook实际上做了更多事情的印象。
- en: In the two preceding examples, the bot user is Hubot, and Jenkins is actually
    the feedback from the playbook run.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两个例子中，机器人用户是Hubot，而Jenkins实际上是playbook运行的反馈。
- en: Automated deployment
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化部署
- en: Another example—I recently worked with several developers who needed a way to
    automatically deploy their code to both their development and staging servers.
    Using a combination of Docker, GitHub, Jenkins, and Ansible AWX, I was able to
    provide the developers with a workflow that was triggered every time they pushed
    code to either the development or staging branches of their repository on GitHub.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子——我最近与几位开发人员合作，他们需要一种自动将代码部署到开发和分级服务器的方法。使用Docker、GitHub、Jenkins和Ansible
    AWX的组合，我能够为开发人员提供一个工作流程，每当他们将代码推送到GitHub存储库的开发或分级分支时都会触发。
- en: To achieve this, I deployed the code on their own Jenkins server, using Ansible
    to deploy Jenkins in a container, and also deployed AWX using Docker on the same
    server. Then, using the **Jenkins GitHub** plugin, I connected the Jenkins projects
    to GitHub to create the Webhooks needed to trigger the build. Then using the **Jenkins
    Ansible Tower** plugin, I had Jenkins trigger a playbook run in AWX.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我在他们自己的Jenkins服务器上部署了代码，使用Ansible在容器中部署了Jenkins，并在同一台服务器上使用Docker部署了AWX。然后，使用**Jenkins
    GitHub**插件，我将Jenkins项目连接到GitHub以创建触发构建所需的Webhooks。然后使用**Jenkins Ansible Tower**插件，我让Jenkins触发AWX中的playbook运行。
- en: I did this because at the moment, AWX does not hook in that easily with GitHub
    Webhooks, whereas **Jenkins** and the **Jenkins GitHub** plugin have a great level
    of compatibility—I imagine with the rate at which AWX is being developed, this
    slight niggle will be ironed out at some point soon.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我这样做是因为目前，AWX与GitHub Webhooks的连接并不那么容易，而**Jenkins**和**Jenkins GitHub**插件具有很高的兼容性——我想随着AWX的开发速度，这个小问题很快就会得到解决。
- en: As AWX allows you to grant role-based access to playbooks, I gave the development
    manager and operations engineers access to run the production playbook, and the
    developers have read-only access so that they can review the results of the playbook
    run.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: AWX允许您根据角色授予playbooks的访问权限，我给了开发经理和运维工程师运行生产playbook的权限，开发人员只有只读权限，以便他们可以查看playbook运行的结果。
- en: This means that the deployment to production was also able to be automated,
    be it that, someone with the correct permissions had to trigger the playbook run
    manually.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着部署到生产环境也能够自动化，只要有正确权限的人手动触发playbook运行。
- en: The level of control which AWX allows us to have of who could trigger deployments,
    fitted it in with our existing deployment strategy which stated that the developers
    should not have access to production systems to deploy code which they had written.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: AWX允许我们控制谁可以触发部署，这与我们现有的部署策略相吻合，该策略规定开发人员不应该有权限部署他们编写的代码到生产系统。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Now we have come to the end of not only the chapter but also our book. I have
    been trying to think of a way I can sum up Ansible, and I have managed to find
    it in a tweet ([https://twitter.com/laserllama/status/976135074117808129](https://twitter.com/laserllama/status/976135074117808129))
    from Ansible creator Michael DeHaan, who, in response to a technical recruiter,
    said the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不仅结束了这一章，也结束了我们的书。我一直在努力想出一个总结Ansible的方法，我在Ansible的创建者Michael DeHaan的一条推特中找到了答案([https://twitter.com/laserllama/status/976135074117808129](https://twitter.com/laserllama/status/976135074117808129))，他在回复一位技术招聘人员时说：
- en: '"Anyone using Ansible for a few months is as good as anyone using Ansible for
    three years. It''s a simple tool on purpose."'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '"使用Ansible几个月的人和使用Ansible三年的人一样好。这是一个故意简单的工具。"'
- en: That perfectly sums up my experience of Ansible and hopefully yours. Once you
    know the basics, it is very easy to quickly move on and start to build more and
    more complex playbooks, which can not only assist with deploying basic code and
    applications, but also with deploying complex cloud and even physical architectures.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这完美地总结了我的Ansible经验，希望也适用于你。一旦掌握了基础知识，就可以很容易地快速进展，开始构建更加复杂的playbooks，这些playbooks不仅可以帮助部署基本的代码和应用程序，还可以帮助部署复杂的云和甚至物理架构。
- en: Being able to not only reuse your own roles but have access to a large collection
    of a community-contributed roles via Ansible Galaxy means you have many examples
    or quick starting points for your next project. So, you can roll your sleeves
    up and get stuck in a lot sooner than maybe you would with other tools. Also,
    if there is something Ansible cannot do, then odds are there is a tool it can
    be integrated with to provide the missing functionality.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅能够重用自己的角色，而且可以通过Ansible Galaxy访问大量社区贡献的角色，意味着你有许多示例或快速起点用于下一个项目。因此，你可以更快地投入工作，比起其他工具可能更快。此外，如果Ansible无法做某事，那么很可能有一个可以集成的工具来提供缺失的功能。
- en: Going back to what we discussed back in [Chapter 1](4648440f-c619-462b-9e31-001dc98210ca.xhtml),
    *An Introduction to Ansible*, being able to define your infrastructure and deployment
    in code in a repeatable and shareable way that encourages others to contribute
    to your playbooks should really be the ultimate aim of why you would start to
    introduce Ansible into your day-to-day workflows. I hope that, through this book,
    you have started to think of day-to-day tasks where Ansible could help you and
    save you time.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们在[第1章](4648440f-c619-462b-9e31-001dc98210ca.xhtml)讨论过的内容，《Ansible简介》，能够以可重复和可共享的方式以代码定义基础架构和部署，鼓励他人贡献到你的playbooks中，这应该是引入Ansible到日常工作流程中的最终目标。我希望通过这本书，你已经开始考虑Ansible可以帮助你节省时间的日常任务。
- en: Further reading
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多阅读材料
- en: 'More information on the tools mentioned in this chapter can be found at the
    following URLs:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提到的工具的更多信息可以在以下网址找到：
- en: '**Hubot**: [https://hubot.github.com](https://hubot.github.com)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hubot**: [https://hubot.github.com](https://hubot.github.com)'
- en: '**Hubot Slack**: [https://github.com/slackapi/hubot-slack](https://github.com/slackapi/hubot-slack)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hubot Slack**: [https://github.com/slackapi/hubot-slack](https://github.com/slackapi/hubot-slack)'
- en: '**Hubot Alias**: [https://github.com/dtaniwaki/hubot-alias](https://github.com/dtaniwaki/hubot-alias)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hubot Alias**: [https://github.com/dtaniwaki/hubot-alias](https://github.com/dtaniwaki/hubot-alias)'
- en: '**Hubot Yardmaster**: [https://github.com/hacklanta/hubot-yardmaster](https://github.com/hacklanta/hubot-yardmaster)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hubot Yardmaster**: [https://github.com/hacklanta/hubot-yardmaster](https://github.com/hacklanta/hubot-yardmaster)'
- en: '**Jenkins Git**: [https://plugins.jenkins.io/git](https://plugins.jenkins.io/git)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins Git**: [https://plugins.jenkins.io/git](https://plugins.jenkins.io/git)'
- en: '**Jenkins Ansible**: [https://plugins.jenkins.io/ansible](https://plugins.jenkins.io/ansible)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins Ansible**: [https://plugins.jenkins.io/ansible](https://plugins.jenkins.io/ansible)'
- en: '**Jenkins GitHub**: [https://plugins.jenkins.io/github](https://plugins.jenkins.io/github)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins GitHub**: [https://plugins.jenkins.io/github](https://plugins.jenkins.io/github)'
- en: '**Jenkins Ansible Tower**: [https://plugins.jenkins.io/ansible-tower](https://plugins.jenkins.io/ansible-tower)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins Ansible Tower**: [https://plugins.jenkins.io/ansible-tower](https://plugins.jenkins.io/ansible-tower)'
