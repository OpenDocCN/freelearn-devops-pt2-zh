# Kubernetes 上的操作应用程序

在本章中，我们将讨论可用于在 Kubernetes 上部署云原生应用程序的资源调配工具。您将学习如何使用最流行的生命周期管理选项在 Kubernetes 上部署 DevOps 工具和 **CI** / **CD** (简称**持续集成** / **持续交付**或**持续部署**)基础架构。您将获得执行第一天和一些第二天操作的技能，例如安装、升级和版本控制部署、排除新应用程序以及在不再需要部署时删除部署。

在本章中，我们将涵盖以下主题:

*   使用 YAML 文件部署工作负载
*   使用自定义部署工作负载
*   使用 Helm 图表部署工作负载
*   使用 Kubernetes 运算符部署和操作应用程序
*   部署和管理詹金斯 X 的生命周期
*   部署和管理 GitLab 的生命周期

# 技术要求

本节中的方法假设您已经按照[第 1 章](01.html)、*中描述的推荐方法之一部署了一个功能性 Kubernetes 集群，构建生产就绪型 Kubernetes 集群*。

Kubernetes 操作工具 kubectl 将用于本节的其余部分，因为它是针对 Kubernetes 集群运行命令的主要命令行界面。如果你使用的是红帽 OpenShift 集群，你可以用`oc`替换`kubectl`，所有命令的功能都是相似的。

# 使用 YAML 文件部署工作负载

在本节中，我们将创建在 Kubernetes 中部署应用程序所需的资源配置。您将学习如何使用**和另一种标记语言** ( **YAML** )文件创建库本内斯清单、部署工作负载和推出新版本。

# 准备好

开始之前，克隆本章中使用的示例的存储库:

```
$ git clone https://github.com/k8sdevopscookbook/src.git
```

确保您已经准备好了一个 Kubernetes 集群，并且配置了 kubectl 来管理集群资源。

# 怎么做…

为了简化流程，本节进一步分为以下几个小节:

*   创建部署
*   验证部署
*   编辑部署
*   回滚部署
*   删除部署

# 创建部署

本食谱将指导您使用清单文件创建一个部署，以保持一组吊舱运行。部署用于声明一个 pod 应该运行多少副本。部署可以放大和缩小；稍后我们将在[第 7 章](07.html)、*扩展和升级* *应用程序*中看到更多关于该主题的内容。

让我们执行以下步骤:

1.  将目录更改为`src/chapter2/yaml/`，该配方的示例文件位于此处:

```
$ cd src/chapter2/yaml/
```

2.  查看部署清单:

```
$ cat deployment-nginx.yaml
apiVersion: apps/v1
kind: deployment
metadata:
 name: nginx-deployment
 labels:
 app: nginx
spec:
 replicas: 2
 selector:
 matchLabels:
 app: nginx
# actual file is longer, shortened to show structure of the file only
```

YAML is white space sensitive. Review the example file to understand the structure of the file. You will see that YAML files do not use tabs instead of a space character.
If in doubt, use a linter for your YAML files. 

3.  通过应用 YAML 清单创建部署:

```
$ kubectl apply -f deployment-nginx.yaml
```

运行上述命令后，将从容器注册表中提取 YAML 清单中提到的容器映像，并在部署清单中定义的 Kubernetes 集群中调度应用程序。现在，您应该能够按照下一个方法验证部署。

# 验证部署

该方法将带您完成验证部署状态的说明，并在需要时进行故障排除。

让我们执行以下步骤:

1.  通过观察部署状态，确认部署状态显示`successfully rolled out`消息:

```
$ kubectl rollout status deployment nginx-deployment
deployment "nginx-deployment" successfully rolled out
```

2.  验证`DESIRED`和`CURRENT`值的数量是否相等，在我们的例子中为`2`:

```
$ kubectl get deployments
NAME             DESIRED CURRENT UP-TO-DATE AVAILABLE AGE
nginx-deployment 2       2       2          2         2m40s
```

3.  最后，还要检查作为部署的一部分部署的复制集(`rs`)和`pods`:

```
$ kubectl get rs,pods
NAME                              DESIRED CURRENT READY AGE
nginx-deployment-5c689d88bb       2       2       2      28m
NAME                              READY STATUS  RESTARTS AGE
nginx-deployment-5c689d88bb-r2pp9 1/1   Running 0        28m
nginx-deployment-5c689d88bb-xsc5f 1/1   Running 0        28m
```

现在，您已经验证了新部署已成功部署并运行。在生产环境中，您还需要编辑、更新和扩展现有应用程序。在下一个方法中，您将学习如何在现有部署上执行这些修改操作。

# 编辑部署

该方法将指导您编辑现有的 Kubernetes 对象，并且您将学习如何在需要时更改部署对象的参数。

让我们执行以下步骤:

1.  编辑部署对象，并将容器映像从映像 nginx 1.7.9 更改为映像 nginx 1.16.0:

```
$ kubectl edit deployment nginx-deployment
```

2.  您可以看到，部署首先进入挂起终止状态，稍后运行以下命令后，卷展栏状态显示一条`successfully rolled out`消息:

```
$ kubectl rollout status deployment nginx-deployment
Waiting for deployment "nginx-deployment" rollout to finish: 1 old replicas are pending termination...
deployment "nginx-deployment"
```

3.  通过创建一个新的副本集并将旧的副本集从`2`缩小到`0`，确认您的部署加速了新的吊舱:

```
$ kubectl get rs
NAME                        DESIRED CURRENT READY AGE
nginx-deployment-5c689d88bb 0       0       0     36m
nginx-deployment-f98cbd66f  2       2       2     46s
```

4.  我们将创建一个变更原因注释。以下命令会将`kubernetes.io/change-cause`参数中定义的描述添加到您当前的部署中:

```
$ kubectl annotate deployment nginx-deployment kubernetes.io/change-cause="image updated to 1.16.0"
```

5.  现在，作为编辑部署的另一种方法，编辑`deployment-nginx.yaml`文件并将副本从`replicas: 2`更改为`replicas: 3`并将`nginx:1.7.9`更改为`image: nginx:1.17.0`:

```
$ nano deployment-nginx.yaml
```

6.  通过将更新后的 YAML 清单应用于您的更改来更新部署。这一步将应用用于部署的图像标签的变化以及我们在*步骤 5* 中增加的副本数量:

```
$ kubectl apply -f deployment-nginx.yaml
```

7.  通过创建新的复制集并缩小旧的单元，确认您的部署加快了新单元的速度:

```
$ kubectl get rs
NAME                        DESIRED CURRENT READY AGE
nginx-deployment-5c689d88bb 0       0       0     56m
nginx-deployment-5d599789c6 3       3       3     15s
nginx-deployment-f98cbd66f  0       0       0     20m
```

8.  通过定义我们使用`kubernetes.io/change-cause`参数进行的更改，创建另一个更改原因注释:

```
$ kubectl annotate deployment nginx-deployment kubernetes.io/change-cause="image updated to 1.17.0 and scaled up to 3 replicas"
```

现在，您已经学习了如何使用复制集编辑、扩展和推出新版本的应用程序。

# 回滚部署

此方法将带您完成通过比较注释和在需要时将部署回滚到旧版本来检查所做更改的说明。

让我们执行以下步骤:

1.  检查部署的详细信息和事件，并记录最近的`ScalingReplicaSet`事件:

```
$ kubectl describe deployments
```

2.  现在，显示部署的部署历史。输出将显示修订以及我们创建的注释:

```
$ kubectl rollout history deployment nginx-deployment
deployment.extensions/nginx-deployment
REVISION CHANGE-CAUSE
1        <none>
2        image updated to 1.16.0
3        image updated to 1.17.0 and scaled up to 3 replicas
```

3.  回滚上一次卷展栏。此命令会将您的部署带到上一个版本，在此配方中，版本 2:

```
$ kubectl rollout undo deployment nginx-deployment
deployment.apps/nginx-deployment rolled back
```

4.  确认部署已回滚到以前的版本:

```
$ kubectl get rs
NAME                        DESIRED CURRENT READY AGE
nginx-deployment-5c689d88bb 0       0       0     69m
nginx-deployment-5d599789c6 0       0       0     12m
nginx-deployment-f98cbd66f  3       3       3     33m
```

Notice that the rollback command only takes the Deployments back to different image version rollouts, and does not undo the other spec changes, such as the number of replicas.

5.  现在，回滚到一个特定的修订。该命令会将您的部署带到使用`--to-revision`参数定义的特定版本:

```
$ kubectl rollout undo deployment nginx-deployment --to-revision=1
```

现在，您已经学习了如何查看部署历史，并在需要时回滚更改。

# 删除部署

Kubernetes 根据资源的可用性在工作节点上调度资源。如果您使用的是 CPU 和内存资源有限的小型集群，您可能会很容易耗尽资源，这将导致无法在工作节点上安排新的部署。因此，除非配方要求中提到，否则在继续下一个配方之前，请务必清理旧的部署。

让我们执行以下步骤来移除`nginx-deployment`:

1.  在进入下一个方案之前，删除部署:

```
$ kubectl delete deployment nginx-deployment
```

前面的命令将立即终止部署，并将应用程序从集群中删除。

# 它是如何工作的...

*创建部署*配方向您展示了如何使用 YAML 清单文件将您的吊舱和副本集的所需状态应用到部署控制器。

在第 2 步中，我们使用了`kubectl apply`命令，这是声明性管理方法的一部分，并进行增量更改，而不是覆盖它们。第一次创建资源意图时，可以使用`kubectl create`命令，这被认为是一种命令式管理方法。

我更喜欢使用`apply`命令，这里允许声明性模式，而不是`create`，因为它更适合创建配置项脚本，并且如果资源已经存在，也不会引发错误。

现在，您已经了解了在 Kubernetes 中运行单个部署的基本步骤，我们可以继续使用 Kustomize、Helm 和 Operator 框架来构建一个更复杂的部署用例集合。

# 请参见

*   YAML 文件的 linter:t1]https://github . com/adriengee/yamlint
*   在线 kubernetes yaml 验证器:[https://kuberaml . com/](https://kubeyaml.com/)
*   阅读更多关于使用配置文件对 Kubernetes 对象进行声明式管理的信息:[https://Kubernetes . io/docs/tasks/manage-Kubernetes-objects/declarative-config/](https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/)
*   创作 Kubernetes 清单指南:[https://github . com/bitnami/charts/blob/master/_ docs/创作-Kubernetes-清单. md](https://github.com/bitnami/charts/blob/master/_docs/authoring-kubernetes-manifests.md)

# 使用自定义部署工作负载

在本节中，我们将向您展示如何从文件中生成资源，以及如何在 Kubernetes 中组合和定制资源集合。您将了解使用 Kustomize 对 Kubernetes 对象的声明性管理。

# 准备好

确保您已经准备好 Kubernetes 集群并且`kubectl`已配置为管理集群资源。

本部分创建的源文件可以在位于[https://GitHub . com/k8 sdevopskokbook/src/tree/master/chapter 2/kustomize](https://github.com/k8sdevopscookbook/src/tree/master/chapter2/kustomize)的我的 GitHub 资源库中找到。建议您按照说明创建和编辑它们，如果遇到问题，只使用存储库中的文件与您的文件进行比较。

# 怎么做…

为了简化流程，本节进一步分为以下几个小节:

*   正在验证 Kubernetes 集群版本
*   从文件生成 Kubernetes 资源
*   为开发和生产部署创建基础

# 正在验证 Kubernetes 集群版本

要让 Kustomize 发挥作用，需要 Kubernetes 集群版本 1.14.0 或更高版本，因为 Kustomize 支持仅包含在 kubectl v.1.14.0 和更高版本中。

1.  列出节点以确认您的 Kubernetes 集群版本，并确保它是 1.14.0 或更高版本:

```
$ kubectl get nodes
 NAME STATUS ROLES AGE VERSION
 ip-172-20-112-25.ec2.internal Ready master 7h19m v1.15.0
 ip-172-20-126-108.ec2.internal Ready node 7h18m v1.15.0
 ip-172-20-51-209.ec2.internal Ready node 7h18m v1.15.0
 ip-172-20-92-89.ec2.internal Ready node 7h19m v1.15.0
```

在上例中，版本显示`v1.15.0`。

# 从文件生成 Kubernetes 资源

让我们学习如何使用 Kustomize 定制我们在上一个食谱中所做的 nginx 展示:

1.  创建一个名为`nginx`的目录:

```
$ mkdir nginx
```

2.  使用`nginx`目录下的 YAML 文件配方，复制您在*部署工作负载中创建的`deployment-nginx.yaml`文件。该文件仍然使用`image: nginx:1.7.9`作为容器图像:*

```
$ cp deployment-nginx.yaml ./nginx/
```

3.  通过指定新的图像版本创建`kustomization.yaml`文件:

```
$ cat <<EOF >./nginx/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
- deployment-nginx.yaml
images:
 - name: nginx
 newName: nginx
 newTag: 1.16.0
commonAnnotations:
 kubernetes.io/change-cause: "Initial deployment with 1.16.0"
EOF
```

4.  通过运行以下命令，检查新版本是否已注入您的部署。在输出中，您将看到`image: nginx:1.16.0`而不是我们之前在`deployment-nginx.yaml`文件中使用的原始图像版本`nginx:1.7.9`:

```
$ kubectl kustomize ./nginx/
```

5.  使用`-k`参数应用自定义部署:

```
$ kubectl apply -k nginx
```

6.  通过指定更新的图像版本创建新的`kustomization.yaml`文件:

```
$ cat <<EOF > nginx/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
 - deployment-nginx.yaml
images:
 - name: nginx
 newName: nginx
 newTag: 1.17.0
commonAnnotations:
 kubernetes.io/change-cause: "image updated to 1.17.0"
EOF
```

7.  使用`-k`参数应用定制部署:

```
$ kubectl apply -k nginx
```

8.  现在，显示部署的部署历史:

```
$ kubectl rollout history deployment nginx-deployment
deployment.extensions/nginx-deployment
REVISION CHANGE-CAUSE
1        Initial deployment with 1.16.0
2        image updated to 1.17.0
```

现在，您已经学习了如何使用 Kustomize 编辑、放大和推出新版本的应用程序。

# 为开发和生产部署创建基础

让我们执行以下步骤来为本地 Docker 映像注册表部署创建一个基础，我们将在本章后面使用它:

1.  创建一个名为`registry`的目录，并在下面创建另一个名为`base`的目录:

```
$ mkdir registry && mkdir registry/base
```

2.  在`registry/base`下，从范例库中下载名为`deployment-registry.yaml`的部署文件:

```
$ cd registry/base/
$ wget https://raw.githubusercontent.com/k8sdevopscookbook/src/master/chapter2/kustomize/registry/base/deployment-registry.yaml
```

3.  查看文件以了解其结构。你会看到这是一份由两个集装箱组成的`Deployment`舱单，集装箱名为`registry`和`registryui`。您将看到注册容器有一个名为`registry-storage`的`volumeMount`，该卷由名为`registry-pvc`的持久卷声明提供:

```
$ cat deployment-registry.yaml
apiVersion: extensions/v1beta1
kind: Deployment
# actual file is longer, shortened to highlight important structure of the file only
 - image: registry:2
#....#
 - name: registry-storage
 mountPath: /var/lib/registry
#....#
 - name: registryui
 image: hyper/docker-registry-web:latest
#....#
 - name: registry-storage
 persistentVolumeClaim:
 claimName: registry-pvc
```

4.  在相同的`registry/base`下，从范例库中下载名为`service-registry.yaml`的服务清单文件:

```
$ wget https://raw.githubusercontent.com/k8sdevopscookbook/src/master/chapter2/kustomize/registry/base/service-registry.yaml
```

5.  查看文件以了解其结构。您将看到它是一个服务清单，在静态端口公开每个节点的 IP 上的服务；在本食谱中，`registry`服务的港口`5000`和`registry-ui`的港口`80`:

```
$ cat <<EOF > registry/base/service-registry.yaml
kind: Service
# actual file is longer, shortened to highlight important structure of the file only
 type: NodePort
 ports:
 - name: registry
 port: 5000
 protocol: TCP 
 nodePort: 30120
 - name: registry-ui
 port: 80
 protocol: TCP
 nodePort: 30220 
#....#
```

6.  创建名为`pvc-registry.yaml`的`PersistentVolumeClaim`清单文件，内容如下:

```
$ cat <<EOF > registry/base/pvc-registry.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
 name: registry-pvc
 labels:
 app: kube-registry-pv-claim
spec:
 accessModes:
 - ReadWriteOnce
 resources:
 requests:
 storage: 10G
EOF
```

At this point, you can deploy the workload using all the resource files under the `registry` directory, by using `kubectl apply -f registry/base`. But every time you need to change a parameter in resources, such as `app` or `label`, you need to edit the files. The whole point of using Kustomize is to take advantage of reusing the files without modifying the source of the files.

7.  最后，创建`kustomization.yaml`文件。以下命令将使用我们之前创建的三个单独的清单文件创建 Kustomize 资源内容:

```
$ cat <<EOF >./registry/base/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
 - deployment-registry.yaml
 - service-registry.yaml
 - pvc-registry.yaml
EOF
```

8.  现在，创建两个用于开发和生产部署的覆盖图。第一个是发展:

```
$ mkdir registry/overlays && mkdir registry/overlays/dev 
$ cat <<EOF >./registry/overlays/dev/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
bases:
 - ../../base
namePrefix: dev-
commonAnnotations:
 note: Hello, I am development!
EOF
```

9.  第二个清单将为生产创建覆盖:

```
$ mkdir registry/overlays/prod
$ cat <<EOF >./registry/overlays/prod/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
bases:
 - ../../base
namePrefix: prod-
commonAnnotations:
 note: Hello, I am production!
EOF
```

10.  检查`dev`和`prod`前缀是否被注入到您的部署中。当您指向`prod`文件夹时，注释会显示`"Hello, I am production!"`:

```
$ kubectl kustomize ./registry/overlays/prod/
# result shortened to highlight the annotation
metadata:
 annotations:
 note: Hello, I am production!
 labels:
 app: kube-registry-pv-claim
 name: prod-registry-pvc
#...#
```

11.  当你指向`dev`文件夹时，注解会显示`"Hello, I am development!"`:

```
$ kubectl kustomize ./dev/
... # removed
metadata:
 annotations:
 note: Hello, I am development!
 labels:
 app: kube-registry-pv-claim
 name: dev-registry-pvc
... # removed
```

12.  现在，部署应用程序的`dev`版本:

```
$ kubectl apply -k ./registry/overlays/dev
```

同样，您可以插入标签、修补映像版本、更改副本数量，以及将资源部署到不同的命名空间。

# 它是如何工作的...

这个方法向您展示了如何使用 Git 管理和实现配置文件的基本版本控制。

在*为开发和生产部署*配方创建基础中，我们在步骤 2 和步骤 6 之间在`base`目录下创建的资源代表应用程序/工作负载的上游存储库，我们在步骤 8 和步骤 10 之间在`overlay`目录下创建的定制是您控制并存储在存储库中的更改。

之后，如果需要查看变体的区别，可以使用`diff`参数，如下所示:

```
$ kubectl diff -k registry/overlays/prod/
```

通过将更改从基础中分离出来，我们能够为多种目的定制无模板的 YAML 文件，保持原始 YAML 文件不变，从而使源代码和更改的版本控制成为可能。

# 请参见

*   恶搞概念概述幻灯片:[https://speakerdeck.com/spesnova/introduction-to-kustomize](https://speakerdeck.com/spesnova/introduction-to-kustomize)
*   Kubernetes 背景白皮书中的声明性应用程序管理–强烈推荐阅读:[https://goo.gl/T66ZcD](https://goo.gl/T66ZcD)
*   Kustomize 中的常用术语:[https://github . com/kubernetes-sigs/Kustomize/blob/master/docs/glossary . MD](https://github.com/kubernetes-sigs/kustomize/blob/master/docs/glossary.md)
*   其他 Kustomize 示例:[https://github . com/kubernetes-sigs/Kustomize/tree/master/examples](https://github.com/kubernetes-sigs/kustomize/tree/master/examples)

# 使用 Helm 图表部署工作负载

在本节中，我们将向您展示如何在 Kubernetes 中使用 Helm 图表。Helm 是 Kubernetes 的包管理器，它帮助开发人员和 SREs 轻松地打包、配置和部署应用程序。

您将学习如何在集群上安装 Helm，并使用 Helm 管理第三方应用程序的生命周期。

# 准备好

确保您已经准备好 Kubernetes 集群并且`kubectl`已配置为管理集群资源。

# 怎么做…

为了简化流程，本节进一步分为以下几个小节:

*   安装 Helm 2.x
*   使用 Helm 图表安装应用程序
*   在 Helm 存储库中搜索应用程序
*   使用 Helm 更新应用程序
*   使用 Helm 回滚应用程序
*   添加新的 Helm 存储库
*   使用 Helm 删除应用程序
*   构建舵图

# 安装 Helm 2.x

让我们执行以下步骤来配置先决条件并安装 Helm:

1.  使用以下命令创建一个`ServiceAccount`:

```
$ cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: ServiceAccount
metadata:
 name: tiller
 namespace: kube-system
EOF
```

2.  使用以下命令创建一个`ClusterRoleBinding`:

```
$ cat <<EOF | kubectl apply -f -
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
 name: tiller
roleRef:
 apiGroup: rbac.authorization.k8s.io
 kind: ClusterRole
 name: cluster-admin
subjects:
 - kind: ServiceAccount
 name: tiller
 namespace: kube-system
EOF
```

3.  下载 Helm 安装脚本。该`install-helm.sh`脚本将检测您系统的架构，并获取最新的正确二进制文件来安装 Helm:

```
$ curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get > install-helm.sh
```

4.  运行脚本安装 Helm。以下命令将安装运行 Helm 所需的两个重要的二进制文件 Helm 和 Tiller:

```
$ chmod u+x install-helm.sh && ./install-helm.sh
```

5.  运行`init`参数，使用我们在步骤 1 *中创建的服务帐户配置 Helm。*参数用于清除和限制赫尔姆历史记录，因为没有此设置，历史记录会无限增长并导致问题:

```
$ helm init --service-account tiller --history-max 200
```

这个过程需要在集群中安装 Helm 服务器端组件 Tiller。

If you get a message complaining that `Tiller is already installed in the cluster.`, you can run the same command by adding the `--upgrade` parameter to the end of the command and force-upgrading the existing version.

6.  通过运行以下命令确认 Helm 版本:

```
$ helm version --short
```

在写这个食谱的时候，Helm 的最新稳定版本是 v2.15.1，下一个版本 Helm 3 还在测试阶段。在接下来的章节和食谱中，我们将基于 Helm 2.x 版本进行指导。

# 使用 Helm 图表安装应用程序

让我们执行以下步骤，从正式的 Helm 存储库位置安装 Helm 图表:

1.  安装图表之前，请始终同步存储库以获取最新内容。否则，您可能会得到旧版本的 Helm 图表:

```
$ helm repo update
```

2.  安装示例图表，在本例中为`stable/mysql`:

```
$ helm install --name my-mysqlrelease stable/mysql
```

同样，您可以从 Helm charts 稳定存储库中安装其他应用程序，或者为自定义图表添加自己的存储库。

每次安装图表时，都会创建一个随机名称的新版本，除非使用`--name`参数指定。现在，列出这些版本:

```
$ helm ls
NAME            REVISION UPDATED                 STATUS   CHART         APP VERSION NAMESPACE
my-mysqlrelease 1        Thu Aug 8 02:30:27 2019 DEPLOYED mysql-1.3.0 5.7.14        default
```

3.  检查版本中的状态，在我们的示例中，`my-mysqlrelease`:

```
$ helm status my-mysqlrelease
```

您将获得所有资源的部署状态和信息。

# 在 Helm 存储库中搜索应用程序

让我们执行以下步骤，从 Helm 图表存储库中搜索您想要在 Kubernetes 上部署的应用程序:

1.  在存储库中搜索图表。以下命令将在您有权访问的 Helm 存储库中查找您的搜索词:

```
$ helm search redis
NAME CHART VER APP VER DESCRIPTION 
stable/prometheus-redis-exporter 3.0.0 1.0.3 Prometheus export
stable/redis 9.0.1 5.0.5 Open source, adva
stable/redis-ha 3.6.2 5.0.5 Highly available 
stable/sensu 0.2.3 0.28 Sensu monitoring 
```

You can find the complete list of workloads in helm/stable and the source of the repository at the following GitHub link: [https://github.com/helm/charts/tree/master/stable ](https://github.com/helm/charts/tree/master/stable)

2.  你的`search`关键词不一定是项目的确切名称。也可以搜索`Storage`、`MQ`或`Database`等关键词:

```
$ helm search storage
NAME                 CHART VERSION APP VERSION DESCRIPTION ...
stable/minio         2.5.4 RELEASE.2019-07-17T22-54-12Z MinIO is a hi
stable/nfs-server-pr 0.3.0 2.2.1-k8s1.12 nfs-server-provisioner is an
stable/openebs       1.0.0 1.0.0 Containerized Storage for Containers
```

默认情况下，您的存储库列表仅限于`helm/stable`位置，但是稍后，在 *A* *添加新的赫尔姆存储库*食谱中，您还将学习如何添加新的存储库，以将您的搜索范围扩展到其他存储库。

# 使用 Helm 升级应用程序

有几种方法可以使用升级。让我们执行以下步骤:

1.  升级版本，在我们的例子中是`my-mysqlrelease`，当有更新的图表版本时:

```
$ helm upgrade my-mysqlrelease stable/mysql
```

2.  将来，您可能会发现特定版本的应用程序在您的环境中更稳定，或者在多个集群中保持安装相同。在这种情况下，您可以使用以下命令用您首选的图表版本更新图表版本:

```
$ helm upgrade my-mysqlrelease stable/mysql --version 1.2.0
```

3.  使用以下命令确认图表版本更改。在第 2 步升级版本后，您应该会看到`mysql --version 1.2.0`:

```
$ helm ls
NAME            REVISION UPDATED                  STATUS   CHART       APP VERSION NAMESPACE
my-mysqlrelease 3        Tue Jul 30 22:44:07 2019 DEPLOYED mysql-1.2.0 5.7.14      default
```

4.  使用以下命令查看修订历史。由于我们最近更新了图表版本，您应该会在历史记录中看到至少两个修订:

```
$ helm history my-mysqlrelease stable/mysql
REV UPDATED             STATUS     CHART       DESCRIPTION
1   Oct 1 22:47:37 2019 SUPERSEDED mysql-1.3.3 Install complete
2   Oct 1 22:57:32 2019 SUPERSEDED mysql-1.3.3 Upgrade complete
3   Oct 1 23:00:44 2019 DEPLOYED   mysql-1.2.0 Upgrade complete
```

5.  通过使用`--set key=value[,key=value]`参数指定参数，使用`helm upgrade`函数更新现有版本的参数。以下命令将使用`--set mysqlRootPassword`参数设置两个 MySQL 密码:

```
$ helm upgrade my-mysqlrelease stable/mysql --version 1.2.0 --set mysqlRootPassword="MyNevvPa55w0rd"
```

6.  确认密码已实际更新。您应该期望获得与您在步骤 4 中设置的相同的密码:

```
$ kubectl get secret --namespace default my-mysqlrelease -o jsonpath="{.data.mysql-root-password}" | base64 --decode; echo
MyNevvPa55w0rd
```

现在，您已经学习了如何使用新参数升级 Helm 版本。

# 使用 Helm 回滚应用程序

让我们执行以下步骤来调用升级，并将您的应用程序状态恢复到以前的版本:

1.  列出您的版本的修订历史，在我们的示例中，`coy-jellyfish`:

```
$ helm history my-mysqlrelease
REV UPDATED                 STATUS     CHART       DESCRIPTION
1   Tue Oct 1 22:47:37 2019 SUPERSEDED mysql-1.3.3 Install complete
2   Tue Oct 1 22:57:32 2019 SUPERSEDED mysql-1.3.3 Upgrade complete
3   Tue Oct 1 23:00:44 2019 SUPERSEDED mysql-1.2.0 Upgrade complete
4   Tue Oct 1 23:07:23 2019 SUPERSEDED mysql-1.3.3 Upgrade complete
5   Tue Oct 1 23:10:39 2019 DEPLOYED   mysql-1.2.0 Upgrade complete
```

2.  假设您需要从上次升级回滚到修订版`4`。回滚到特定版本:

```
$ helm rollback my-mysqlrelease 4
Rollback was a success.
```

3.  修订历史将被更新以反映您的回滚:

```
$ helm history my-mysqlrelease
 REV UPDATED                  STATUS     CHART       DESCRIPTION
...
 5   Tue Jul 30 22:44:07 2019 SUPERSEDED mysql-1.2.0 Upgrade complete
 6   Tue Jul 30 23:11:52 2019 DEPLOYED   mysql-1.3.0 Rollback to 4
```

现在，您已经学习了如何查看发行历史，并在需要时回滚 Helm 发行版。

# 使用 Helm 删除应用程序

让我们执行以下步骤，从 Kubernetes 集群中删除使用 Helm 部署的应用程序:

1.  使用带有`--all`参数的`helm ls`命令列出所有版本，包括删除的版本:

```
helm ls --all
NAME REVISION UPDATED STATUS CHART APP VERSION NAMESPACE
my-mysqlrelease 6 Thu Aug 8 02:34:13 2019 DEPLOYED mysql-1.3.0 5.7.14 default
```

2.  使用`--purge`参数删除版本。以下命令将从集群中完全删除应用程序:

```
helm delete --purge my-mysqlrelease
```

前面的命令将立即终止部署，并从集群中删除 Helm 版本。

# 添加新的 Helm 存储库

默认情况下，Helm 只使用官方的 Helm/stable 存储库进行查找，通常在接下来的章节中，我们将需要使用本食谱中解释的方法添加来自第三方供应商的其他存储库。

让我们执行以下步骤将额外的 Helm 存储库添加到您的源列表中:

1.  检查现有存储库的列表。你应该只看到列表上的`stable`和`local`:

```
$ helm repo list
 NAME   URL
 stable https://kubernetes-charts.storage.googleapis.com
 local  http://127.0.0.1:8879/charts
```

2.  我们需要为存储库服务器配置持久卷和身份验证。使用以下内容创建名为`customhelmrepo.yaml`的文件:

```
cat <<EOF >customhelmrepo.yaml
env:
 open:
 STORAGE: local
persistence:
 enabled: true
 accessMode: ReadWriteOnce
 size: 10Gi
 secret:
 BASIC_AUTH_USER: helmcurator
 BASIC_AUTH_PASS: myhelmpassword
EOF
```

3.  使用永久卷创建存储库服务器:

```
$ helm install --name my-chartmuseum -f customhelmrepo.yaml stable/chartmuseum
```

4.  获取`chartmuseum`的服务 IP。以下命令将返回一个 IP 地址，在我们的示例中为`10.3.0.37`:

```
$ kubectl get svc --namespace default -l "app=chartmuseum" -l \
"release=my-chartmuseum" -o jsonpath="{.items[0].spec.clusterIP}"; echo
10.3.0.37
```

5.  将新的 Helm 存储库添加到您的存储库列表中；在我们的案例中，IP 是`10.3.0.37`:

```
$ helm repo add chartmuseum http://10.3.0.37:8080
```

6.  检查现有存储库的列表:

```
$ helm repo list
NAME        URL
stable      https://kubernetes-charts.storage.googleapis.com
local       http://127.0.0.1:8879/charts
chartmuseum http://10.3.0.37:8080
```

有许多选项可用于托管图表存储库。您可以使用名为 **ChartMuseum** 的开源 Helm 存储库服务器，在 S3 桶、GitHub 页面或经典网络服务器上部署本地存储库。为了简单起见，我们使用 Helm 本身来部署服务器。您可以在*下找到 Helm 图表的替代托管方法，另请参见*部分。

# 构建舵图

让我们执行以下步骤来构建一个定制的 Helm 图表，并将其发布到您的本地`chartmuseum`存储库中:

1.  创建一个名为`mychart`的图表:

```
$ helm create mychart
```

2.  根据自己的喜好编辑图表结构，并测试模板是否存在可能的错误:

```
$ helm lint ./mychart
==> Linting ./mychart
[INFO] Chart.yaml: icon is recommended
1 chart(s) linted, no failures
```

3.  使用`--dry-run`测试您的应用程序:

```
$ helm install ./mychart --debug --dry-run
```

4.构建赫尔姆图表。通过运行以下命令，您将从`mychart`位置生成您的 Helm 存储库的 tarball 包:

```
$ helm package .
```

5.  用您的 Helm 服务器替换 Helm 存储库服务器地址，并使用以下网址上传此 Helm 图表包:

```
$ cd mychart && curl --data-binary "@mychart-0.1.0.tgz" http://10.3.0.37:8080/api/charts
```

现在，您已经学习了如何创建、分解、测试、打包新图表，并将其上传到基于 ChartMuseum 的 Helm 存储库中。

# 它是如何工作的...

这个食谱告诉你如何安装赫尔姆包管理器，并建立你的第一个赫尔姆图表。

当我们在*构建掌舵图*配方中构建掌舵图时，在步骤 1 中，`helm create`命令在`chart`文件夹下创建了几个文件作为模板。您可以从编辑这些文件开始，或者在对结构更加熟悉时从头开始创建它们。

`helm create`命令创建了构建我们的 Helm 图表的模板。内容及其功能解释如下:

```
mychart 
├── Chart.yaml          --> Description of the chart
├── charts              --> Directory for chart dependencies
├── mychart-0.1.0.tgz   --> Packaged chart following the SemVer 2 standard
├── templates           --> Directory for chart templates
│   ├── NOTES.txt       --> Help text displayed to users
│   ├── _helpers.tpl    --> Helpers that you can re-use 
│   ├── deployment.yaml --> Application - example deployment
│   ├── service.yaml    --> Application - example service endpoint
└── values.yaml         --> Default values for a chart
```

在*构建 Helm 图表*方法中，在步骤 3 中，`helm install`与`--dry-run`参数一起使用时，将图表发送到服务器，并仅返回渲染的模板，而不是安装它。这通常用于测试赫尔姆图表。

在同一个配方中，在第 4 步中，`helm package`命令将您的完整图表打包到一个图表档案中，基本上是一个 tarball。

在第 5 步中，我们使用`curl`命令将打包的 tarball 二进制文件发送到我们的 ChartMuseum 服务器，这是一个 HTTP 服务器，因此当它接收到来自`helm`命令的`GET`请求时，它可以为我们的 Helm 图表档案提供服务。

现在您已经学习了如何安装 Helm 图表并在您的本地存储库中创建您的 Helm 图表，您将能够安装下一章中需要的第三方图表，以及在您的 CI/CD 管道中构建您自己的工件。

# 请参见

*   Helm 文档: [https://docs.helm.sh](https://docs.helm.sh)
*   掌舵图的替代托管方法:https://v2.helm.sh/docs/chart_repository/
*   图表模板入门:[https://helm.sh/docs/chart_template_guide/](https://helm.sh/docs/chart_template_guide/)
*   构建`Chart.yaml`文件所需的字段:[https://v2.helm.sh/docs/chart_template_guide/](https://v2.helm.sh/docs/chart_template_guide/)

*   J-Frog 集装箱登记处，一个强大的混合码头和掌舵登记处:[https://jfrog.com/container-registry/](https://jfrog.com/container-registry/)

# 使用 Kubernetes 运算符部署和操作应用程序

Kubernetes 操作符是 Kubernetes 捆绑、部署和管理应用程序的另一种方法。运算符比像 Helm 这样的包管理器复杂一点。操作员帮助删除手动步骤、特定于应用程序的准备和部署后步骤，甚至自动化第二天的操作，例如为用户扩展或升级它们。

例如，应用程序的需求可能会根据其安装的平台进行不同的验证，或者可能需要更改其配置和与外部系统的交互。

在本节中，我们将基于两种不同的运算符框架为流行的有状态应用程序部署两种运算符，并了解它们提供了哪些功能。

# 准备好

确保您已经准备好了一个 Kubernetes 集群，并且配置了 kubectl 来管理集群资源。

# 怎么做…

为了简化流程，本节进一步分为以下几个小节:

*   安装**KUDO**(T2 的简称】Kubernetes 通用声明操作符)和 KUDO kubectl 插件
*   使用 KUDO 安装 Apache Kafka 操作员
*   安装操作员生命周期管理器
*   安装 Zalando PostgreSQL 运算符

# 安装 KUDO 和 KUDO kubectl 插件

在使用 KUDO 操作符安装应用程序之前，您需要安装 KUDO。我们将使用`brew`安装 KUDO，这是一个在 Linux 中使用的包管理器，用于在 Linux 上简单安装二进制文件；因此，如果您还没有安装 brew，您还需要安装:

1.  按照*中的 Helm 说明，使用 Helm 图表*配方部署工作负载，以使 Helm 运行。
2.  使用以下命令安装`brew`:

```
$ sh -c "$(curl -fsSL https://raw.githubusercontent.com/Linuxbrew/install/master/install.sh)"
$ PATH=/home/linuxbrew/.linuxbrew/bin/:$PATH
```

3.  运行以下命令，使用`brew install`安装 KUDO 和`kudo kubectl`插件:

```
$ brew tap kudobuilder/tap && brew install kudo-cli
```

4.  按照以下步骤安装 KUDO:

```
$ kubectl kudo init
```

现在您已经安装了 KUDO 控制器，使用 Kubernetes 操作符测试一些有状态运行的应用程序。

# 使用 KUDO 安装 Apache Kafka 操作员

在*参见*部分中列出了多个卡夫卡运营商，例如 Strimzi、Banzai Cloud、Confluent、krallistic 等。虽然我在这个食谱中没有任何偏好，但是作为一个例子，我们将基于 KUDO 运算符部署 Apache Kafka 运算符。

让我们执行以下步骤:

1.  卡夫卡需要动物园管理员。让我们创建一个动物园管理员集群:

```
$ kubectl kudo install zookeeper --instance=zk
```

2.  使用 KUDO Kafka 运算符创建一个 Kafka 集群:

```
$ kubectl kudo install kafka --instance=kafka
```

3.  通过查询`Operators` CRD 原料药，列出工藤运营商如下。在部署了也有 ZooKeeper 依赖的 Kafka 之后，您应该会看到`kafka`和`zookeeper`操作符:

```
$ kubectl get Operators
NAME      AGE
kafka     9s
zookeeper 17s
```

4.  列出 KUDO 实例:

```
$ kubectl get instances
NAME  AGE
kafka 25s
zk    33s
```

现在，您已经学习了如何使用 KUDO 操作符部署动物园管理员和卡夫卡。

# 安装操作员生命周期管理器

在使用红帽运营商框架运营商安装应用之前，需要安装**运营商生命周期管理器** ( **OLM** )。请注意，默认情况下，OLM 安装在 OpenShift 4.0 和先例中。

1.  安装 OLM。这是我们下一个配方*安装 Zalando PostgreSQL 操作符*所必需的:

```
$ kubectl create -f https://raw.githubusercontent.com/Operator-framework/Operator-lifecycle-manager/master/deploy/upstream/quickstart/crds.yaml
$ kubectl create -f https://raw.githubusercontent.com/Operator-framework/Operator-lifecycle-manager/master/deploy/upstream/quickstart/olm.yaml
```

现在，您已经安装了 OLM，使用一个操作框架来测试一些有状态运行的应用程序。

# 安装扎兰多后置 SQL 运算符

在*中列出了多个 PostgreSQL 操作符，参见*部分，例如 CrunchyDB 和 Zalando。在这个食谱中，作为一个例子，我们将部署 Zalando PostgreSQL 操作符来管理您的 Kubernetes 集群中 PostgreSQL 部署的生命周期。

让我们执行以下步骤，使用操作员中心部署 Zalando PostgreSQL 操作员:

1.  从操作中心安装`postgres-Operator`:

```
$ kubectl create -f https://Operatorhub.io/install/postgres-Operator.yaml
```

2.  验证`postgres-Operator`正在运行:

```
$ kubectl get pods -n Operators
NAME                               READY STATUS  RESTARTS AGE
postgres-Operator-5cd9d99494-5nl5r 1/1   Running 0        3m56s
```

3.  现在，PostgreSQL 操作符已经启动并运行，让我们部署 Postgres 操作符用户界面:

```
$ kubectl apply -f https://raw.githubusercontent.com/k8sdevopscookbook/src/master/chapter2/postgres-Operator/ui/postgres-ui.yaml
```

4.  部署 PostgreSQL。以下命令将创建一个小型双实例 PostgreSQL 集群:

```
$ kubectl create -f https://raw.githubusercontent.com/zalando/postgres-Operator/master/manifests/minimal-postgres-manifest.yaml
```

6.  列出由 Zalando 运算符管理的 PostgreSQL 实例。它将显示一个名为`acid-minimal-cluster`的集群:

```
$ kubectl get postgresql
NAME                 TEAM VERSION PODS VOLUME CPU-REQUEST MEMORY-REQUEST AGE STATUS
acid-minimal-cluster acid 11      2    1Gi                               7s
```

7.  首先获取集群凭据，并使用`psql`交互式 PostgreSQL 终端连接到您的 PostgreSQL，如下所示:

```
$ export PGPASSWORD=$(kubectl get secret postgres.acid-minimal-cluster.credentials -o 'jsonpath={.data.password}' | base64 -d)
$ export PGSSLMODE=require
$ psql -U postgres
```

8.  删除您的 PostgreSQL 群集:

```
$ kubectl delete postgresql acid-minimal-cluster
```

现在，您已经学习了如何简单地使用流行的 Kubernetes Operators 在 Kubernetes 上部署和管理工作负载。您可以稍后应用这些知识来简化您在开发和生产环境中使用的有状态工作负载的生命周期管理。

# 请参见

*   在 Kubernetes Operators at Kubernetes 2018:[https://developers . RedHat . com/blog/2018/12/18/Kubernetes-Operators-in-deep/](https://developers.redhat.com/blog/2018/12/18/kubernetes-operators-in-depth/)
*   按社区划分的库本内特运营商名单:[https://github.com/Operator-framework/awesome-Operators](https://github.com/operator-framework/awesome-operators)
*   使用红帽操作员软件开发工具包构建的库本内特操作员列表:[https://Operatorhub.io/](https://operatorhub.io/)
*   库本内斯通用声明符 ( **工藤**):[https://kudo.dev/](https://kudo.dev/)
*   工藤运营商知识库:[https://github.com/kudobuilder/Operators](https://github.com/kudobuilder/operators)
*   用几行代码编写 Kubernetes 操作符的 Python 框架:[https://github.com/zalando-incubator/kopf](https://github.com/zalando-incubator/kopf)
*   替代卡夫卡运营商列表:
    *   运行在 OpenShift 上的 Apache Kafka 操作员:[http://strimzi.io/](http://strimzi.io/)
    *   KUDO Kafka Operator:[https://github . com/KUDO builder/Operators/tree/master/repository/Kafka](https://github.com/kudobuilder/operators/tree/master/repository/kafka)
    *   库本内斯的另一个卡夫卡式的操作者:https://github.com/banzaicloud/kafka-Operator
*   Istio 操作员:[https://github.com/banzaicloud/istio-Operator](https://github.com/banzaicloud/istio-operator)
*   可选后置 SQL 运算符列表:
    *   脆皮数据后置 SQL 运算符:[https://github.com/CrunchyData/postgres-Operator](https://github.com/CrunchyData/postgres-operator)
    *   Zalando PostgreSQL 运算符:[https://github.com/zalando/postgres-Operator](https://github.com/zalando/postgres-operator)

# 部署和管理詹金斯 X 的生命周期

Jenkins X 是一个开源解决方案，为软件开发人员提供管道自动化、内置 GitOps、CI、自动化测试以及在 Kubernetes 中称为 CI/CD 的 CD。Jenkins X 高度关注使用 Kubernetes 生态系统大规模加速软件交付。

在本节中，我们将重点介绍 Jenkins X 食谱，并在您的云提供商上创建一个具有 CI/CD 功能的 Kubernetes 集群。

# 准备好

在下面的食谱中，您将学习如何创建一个静态的詹金斯服务器来部署具有管道自动化的 Kubernetes 集群和具有 GitOps 升级和预览环境的自动化 CI/CD。

这个食谱需要 kubectl 和 Helm。对于这个食谱，我们将使用 **GKE** (简称**谷歌 Kubernetes 引擎**)，因此也需要安装 gcloud CLI 工具。您还需要创建一个合适的 GitHub 组织和 GitHub 帐户。

# 怎么做...

为了简化流程，本节进一步分为以下几个小节:

*   安装詹金斯 X 命令行界面
*   创建詹金斯 X 库本内特集群
*   验证詹金斯 X 组件
*   切换 Kubernetes 集群
*   验证集群一致性

# 安装詹金斯 X 命令行界面

詹金斯命令行界面`jx`与您首选的云提供商命令行界面一起用于协调库本内特集群的部署。Jenkins X 支持 Azure、AWS、 **GCP** (简称**谷歌云平台**)、IBM 云、Oracle 云、Minikube、Minishift 和 OpenShift 作为部署的提供者。对于这个食谱，我们将使用 GKE。有关其他供应商说明，请参见詹金斯 X 文档。

让我们执行以下步骤来安装詹金斯 X 命令行界面工具:

1.  访问 JX 发布网站([https://github.com/jenkins-x/jx/releases](https://github.com/jenkins-x/jx/releases))并注意最新的发布版本。在撰写本文时，最新版本是 v2.0.905。
2.  使用以下命令更新版本。下载并安装最新版本的詹金斯 X 命令行界面:

```
$ curl -L https://github.com/jenkins-x/jx/releases/download/v2.0.905/jx-linux-amd64.tar.gz | tar xzv 
$ sudo mv jx /usr/local/bin
```

现在您已经安装了詹金斯 X 命令行界面，您可以继续下一个食谱。

# 创建詹金斯 X 库本内特集群

您可能更喜欢其他云供应商或内部部署。对于这个食谱，我们将使用 GKE。有关其他供应商说明，请参见詹金斯 X 文档。

让我们执行以下步骤，使用`jx`创建您的第一个 Jenkins X Kubernetes 集群:

1.  使用带有`gke`参数的`jx`命令，使用 GKE 创建库本内特集群，如下所示:

```
$ jx create cluster gke --skip-login
```

2.  选择您的谷歌云项目；在我们的例子中，`devopscookbook`。
3.  当要求选择谷歌云区域时，选择`us-central1-a`。
4.  选择静态詹金斯服务器和詹金斯文件作为安装类型。
5.  输入您的 GitHub 用户名:

```
Creating a local Git user for GitHub server
? GitHub username:
```

6.  输入您的 GitHub API 令牌。转到 https://github.com/settings/tokens/new?的 GitHub 令牌页面 scopes=repo，read:user，read:org，user:email，write:repo_hook，delete_repo 获取您的 API 令牌:

```
Please click this URL and generate a token
https://github.com/settings/tokens/new?scopes=repo,read:user,read:org,user:email,write:repo_hook,delete_repo
Then COPY the token and enter it following:
? API Token:
```

7.  默认情况下，詹金斯 X 将设置入口规则以使用神奇的 DNS `nip.io`域:

```
? Domain [? for help] (your_IP.nip.io)
```

8.  进入`Yes`进入以下问题:

```
? Do you wish to use GitHub as the pipelines Git server: (Y/n)
```

9.  选择要在其中创建环境存储库的 GitHub 组织；在我们的情况下，`k8devopscookbook`。

10.  当您的部署成功时，您将看到类似以下的消息:

```
Jenkins X installation completed successfully
 ********************************************************
 NOTE: Your admin password is: your_password
 ********************************************************
...
Context "gke_devopscookbook_us-central1-a_slayersunset" modified.
NAME            HOSTS                             ADDRESS PORTS AGE
chartmuseum     chartmuseum.jx.your_IP.nip.io     your_IP 80    7m43s
docker-registry docker-registry.jx.your_IP.nip.io your_IP 80    7m43s
jenkins         jenkins.jx.your_IP.nip.io         your_IP 80    7m43s
nexus           nexus.jx.your_IP.nip.io           your_IP 80    7m43s
```

您也可以在前面的输出中找到您的管理员密码。

# 验证詹金斯 X 组件

让我们执行以下步骤来验证所有 Jenkins X 组件是否按预期运行:

1.  确认所有吊舱都在运行。`jx`命名空间中的所有单元都应该处于运行状态:

```
$ kubectl get pods -n jx
NAME                                          READY STATUS  RESTARTS AGE
jenkins-956c58866-pz5vl                       1/1   Running 0       11m
jenkins-x-chartmuseum-75d45b6d7f-5bckh        1/1   Running 0       11m
jenkins-x-controllerrole-bd4d7b5c6-sdkbg      1/1   Running 0       11m
jenkins-x-controllerteam-7bdd76dfb6-hh6c8     1/1   Running 0       11m
jenkins-x-controllerworkflow-7545997d4b-hlvhm 1/1   Running 0       11m
jenkins-x-docker-registry-6d555974c7-sngm7    1/1   Running 0       11m
jenkins-x-heapster-7777b7d7d8-4xgb2           2/2   Running 0       11m
jenkins-x-nexus-6ccd45c57c-btzjr              1/1   Running 0       11m
maven-brcfq                                   2/2   Running 0       63s
maven-qz0lc                                   2/2   Running 0       3m
maven-vqw9l                                   2/2   Running 0       32s
```

2.  获取我们需要连接的詹金斯 X 服务网址列表。您将看到类似于以下内容的`jenkins`、`chartmuseum`、`docker-registry`和`nexus`网址列表:

```
$ jx get urls
NAME                      URL
jenkins                   http://jenkins.jx.your_IP.nip.io
jenkins-x-chartmuseum     http://chartmuseum.your_IP.nip.io
jenkins-x-docker-registry http://docker-registry.jx.your_IP.nip.io
nexus                     http://nexus.jx.your_IP.nip.io
```

现在，您可以通过访问`jx get urls`命令前面输出的第一个网址来连接到詹金斯用户界面。

# 切换 Kubernetes 集群

让我们执行以下步骤，在您可以使用 Jenkins X 访问的 Kubernetes 集群之间进行切换:

1.  通过列出上下文获得现有的 Kubernetes 集群:

```
$ jx context
```

2.  选择您想要使用的群集。在我们的例子中，我们切换到使用詹金斯 X 创建的`gke_devopscookbook`集群:

```
Change Kubernetes context: [Use arrows to move, space to select, type to filter]
> gke_devopscookbook_us-central1-a_slayersunset
eks_devopscookbook_us-west
openshift_cluster
```

现在您知道如何使用詹金斯命令行界面切换上下文了。

# 验证集群一致性

如果您在现有的 Kubernetes 集群之间切换，建议您在运行管道之前验证集群配置。让我们执行以下步骤:

1.  验证您的集群是否兼容。这些测试通常需要一个小时:

```
jx compliance run
```

2.  检查状态。只有在测试完成后，该命令才会返回`Compliance tests completed`信息:

```
$ jx compliance status
Compliance tests completed.
```

3.  查看结果。如果您的集群符合要求，所有执行的测试结果应显示为`PASSED`:

```
$ jx compliance results
```

现在您知道如何检查集群一致性结果了。

# 它是如何工作的...

创建詹金斯 X 库本内特集群的方法向您展示了如何为管道自动化和自动化配置项/光盘配置库本内特集群。

在*创建 Jenkins X Kubernetes 集群*配方中，在第 1 步中，我们使用 Jenkins X CLI 创建了集群。默认情况下，Jenkins X 使用`n1-standard-2`作为 GKE 上的机器类型，并创建一个最少三个最多五个节点设置的集群。请记住，您也可以使用现有的 Kubernetes 集群，而不是创建一个新的集群。下次运行`create cluster`命令时，大部分设置将被保存和记忆。

Jenkins X 部署了一些服务，包括 Jenkins，一个私有的 Docker 注册中心，一个私有的 Helm 存储库 ChartMuseum，用于管理 Helm 图表的单眼，以及一个名为 **Nexus** 的 Maven 和 npm 存储库。

正如您将在安装后的存储库中发现的，Jenkins X 创建了两个 Git 存储库，一个用于您的暂存环境，一个用于生产环境。Jenkins X 使用 GitOps 方法，通过 Git **拉取请求** ( **PRs** )将代码从一个回购提升到另一个回购。因此，每个回购包含一个詹金斯管道来处理促销。

在*创建 Jenkins X Kubernetes 集群*的方法中，在步骤 7 中，Jenkins X 使用神奇的 DNS 服务，并通过`nip.io`使用服务将您的 GKE 集群的 IP 地址转换为 DNS 可发现的主机名。如果您有自己的域，并且域名系统被配置为指向您的集群，您可以稍后使用`jx upgrade ingress --cluster`命令更新设置。

稍后，在步骤 10 中，您将获得分配给您的管理员用户的默认密码。当您第一次通过此步骤中提供的网址连接到詹金斯用户界面时，系统会要求您更改此密码。

# 还有更多…

了解以下信息也很有用:

*   导入应用程序
*   升级詹金斯 X
*   删除詹金斯 X 库本内特集群

# 导入应用程序

让我们执行以下步骤，将现有应用程序导入到 Jenkins X 环境中:

1.  克隆或使用现有应用程序。作为示例，我们将创建`hello-world`示例的克隆:

```
$ mkdir import && cd import
$ git clone https://github.com/k8sdevopscookbook/hello-world.git
```

2.  从`cloned`目录中删除 Git 文件。这将从目录中删除 Git 历史记录:

```
$ cd hello-world & sudo rm -r .git/
```

3.  在文件夹中运行以下命令，将源代码导入 Jenkins X:

```
$ jx import
```

# 升级詹金斯 X 应用程序

让我们执行以下步骤来升级 Jenkins X 应用程序及其组件:

1.  首先，升级`jx` CLI。如果远程存储库中有新版本，此命令将升级应用程序:

```
$ jx upgrade cli
```

2.  使用最新的命令行界面后，使用以下命令升级平台。如果存在新版本，新的`jx` CLI 命令将升级平台组件:

```
$ jx upgrade platform
```

# 删除詹金斯 X 库本内特集群

删除托管的 Kubernetes 集群可能很棘手，尤其是如果您不是创建它们的人。由于我们使用 GKE 来创建它们，所以使用 gcloud CLI 工具来删除它们会更快。让我们执行以下步骤来删除我们用 Jenkins X 创建的 Kubernetes 集群:

1.  使用云提供商的说明删除 Kubernetes 集群。在我们的例子中，我们使用了 GKE 的食谱。首先，列出集群:

```
$ gcloud container clusters list
NAME LOCATION MASTER_VERSION MASTER_IP MACHINE_TYPE NODE_VERSION NUM_NODES STATUS
clustername us-central1-a 1.12.8-gke.10 your_IP n1-standard-2 1.12.8-gke.10 3 RUNNING
```

2.  从步骤 1 的输出中使用`clustername`删除集群:

```
$ gcloud container clusters delete <clustername>
```

现在，您已经学习了如何使用 Jenkins X 来创建集群。这些知识已经为您准备好了[第 3 章](03.html)、*构建 CI/CD 管道*，在这里您将继续使用环境并学习在 Jenkins X 中将应用程序作为管道导入

# 请参见

*   詹金斯简介:[https://jenkins.io/blog/2018/03/19/introducing-jenkins-x/](https://jenkins.io/blog/2018/03/19/introducing-jenkins-x/)
*   詹金斯 X 存储库和二进制文件:[https://github.com/jenkins-x/jx](https://github.com/jenkins-x/jx)
*   詹金斯 X 教程:[https://jenkins-x.io/tutorials/](https://jenkins-x.io/tutorials/)
*   詹金斯 X 入门说明:[https://jenkins-x.io/getting-started/install-on-cluster/](https://jenkins-x.io/getting-started/install-on-cluster/)
*   Jenkins X CLI 命令以及如何使用它们的说明:[https://jenkins-x.io/commands/jx/](https://jenkins-x.io/commands/jx/)

# 部署和管理 GitLab 的生命周期

GitLab 是一个完整的 DevOps 工具链，在单个应用平台中交付。GitLab 提供了管理、规划、创建、验证、打包、发布、配置、监控和保护应用程序所需的所有必要工具。

在本节中，我们将使用 Helm 图表介绍 GitLab 的部署和生命周期管理。

# 准备好

在下面的食谱中，您将学习如何在现有的 Kubernetes 集群上安装 GitLab，在那里您可以管理整个 DevOps 生命周期。

这个配方需要 kubectl 和 Helm，以及一个现有的 Kubernetes 集群。对于这个配方，我们将使用我们在 [第 1 章](01.html)*中部署在 AWS 上的集群来构建生产就绪的 Kubernetes 集群。*您应该能够在任何 Kubernetes 集群版本 1.11 或更高版本上运行相同的配方，最少需要 6vCPU 和 16 GB 内存。

# 怎么做...

为了简化流程，本节进一步分为以下几个小节:

*   使用 Helm 安装 GitLab
*   连接到 GitLab 仪表板
*   创建第一个 GitLab 用户
*   升级 GitLab
*   正在删除 GitLab

# 使用 Helm 安装 GitLab

对于这个配方，我们将使用亚马逊 EC2 上的 Kubernetes 集群，我们在第 1 章的*下的【构建生产就绪的 Kubernetes 集群】第 3 章【在亚马逊网络服务上配置 Kubernetes 集群】中部署了该集群:*

1.  将 GitLab Helm 图表重新发布到您的本地存储库中:

```
$ helm repo add gitlab https://charts.gitlab.io/
$ helm repo update
```

2.  将以下`externalUrl`替换为您的域名，并在`gitlab`命名空间中使用 Helm 部署 GitLab:

```
$ helm upgrade --install gitlab gitlab/gitlab --namespace gitlab \
--timeout 600 \
--set global.edition=ce \
--set certmanager-issuer.email=youremail@domain.com \
--set global.hosts.domain=yourdomain.com
```

*Using auto-generated self-signed certificates*

`CNAME`

3.  部署可能需要大约 10-15 分钟。确认服务状态并记下`gitlab-gitlab-ce`服务的外部 IP:

```
$ kubectl get svc -n gitlab
```

# 连接到 GitLab 仪表板

让我们执行以下步骤，使用您的网络浏览器获取要连接的 GitLab 服务地址:

1.  获取您的 GitLab 服务的外部地址:

```
$ echo http://$(kubectl get svc --namespace gitlab \
gitlab-nginx-ingress-controller \
-o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
```

2.  在浏览器中打开返回到前面命令的地址。
3.  通过运行以下命令获取 GitLab 创建的默认根密码:

```
$ kubectl get secret gitlab-gitlab-initial-root-password \
-ojsonpath='{.data.password}' | base64 --decode ; echo
```

4.  设置新密码，并使用`root`用户和您的新密码登录。
5.  要使用自定义网址，请在您的域名系统上创建一个`CNAME`记录，该记录带有步骤 1 中使用的外部网址的别名。

# 创建第一个 GitLab 用户

默认情况下，我们使用根帐户来管理 GitLab 部署。所有新用户都需要使用自己的凭据登录 GitLab。

让我们执行以下步骤来创建新用户:

1.  以`root`用户身份登录。
2.  登录 GitLab 仪表板后，您将看到一个类似于下面的欢迎屏幕。在欢迎使用 GitLab 屏幕上单击添加人员:

![](assets/2f1d7b95-2af3-4eea-a76e-6e55c8b819f9.png)

3.  在“新用户”菜单下，至少输入名称、用户名和电子邮件字段，然后单击“创建用户”保存更改。

# 升级 GitLab

GitLab 经常发布带有附加功能的新版本。偶尔，您可能还需要升级以获得错误修复。使用 Helm 升级可以轻松完成升级。让我们执行以下步骤将 GitLab 升级到新版本:

1.  首先，使用`helm get values`命令将当前使用的参数导出到 YAML 文件，如下所示:

```
$ helm get values gitlab > gitlab.yaml
```

2.  升级图表存储库以从远程存储库中获得新版本:

```
$ helm repo update
```

3.  列出可用的图表版本:

```
$ helm search -l gitlab/gitlab
NAME CHART VERSION APP VERSION DESCRIPTION
gitlab/gitlab 2.1.7 12.1.6 Web-based Git-repository manager with wiki and issue-trac...
gitlab/gitlab 2.1.6 12.1.4 Web-based Git-repository manager with wiki and issue-trac...
...
```

4.  对新版本使用相同的参数进行升级:

```
$ helm upgrade gitlab gitlab/gitlab --version 2.1.7 -f gitlab.yaml
```

# 它是如何工作的...

使用 Helm 安装 GitLab 的*方法向您展示了如何为 GitLab 配置所有内置组件和外部依赖项。*

在*使用 Helm* 方法安装 GitLab 的过程中，在第 1 步中，我们确保将官方最新的 GitLab Helm 图表重新发布添加到本地存储库列表中。否则，将使用来自 stable/gitlab repo 的旧版本的 GitLab 图表。

在同一个配方中，在步骤 2 中，我们使用`gitlab`命名空间中的 Helm 图表，使用`--namespace gitlab`参数部署了 GitLab。该命令不仅部署了 GitLab 组件，还部署了 Redis、PostgreSQL、用于数据持久性的 Minio 对象存储、Cert Manager、本地容器注册表和 nginx 入口控制器。

[https://docs.gitla](https://docs.gitlab.com/charts/advanced/)
[b.com/charts/advanced/](https://docs.gitlab.com/charts/advanced/)

默认情况下，GitLab Helm 图表部署企业版的 GitLab。通过使用`--set global.edition=ce`参数，我们将部署切换到免费社区版。

在我们使用 Helm 方法执行*安装 GitLab 中的命令之后，在步骤 2 中，Helm 图表假设我们有一个现有的默认存储类，并且它使用默认存储类来为有状态应用程序创建 PVC 和 PVs。*

# 还有更多…

了解以下信息也很有用:

*   使用您自己的通配符证书
*   使用自动生成的自签名证书
*   启用 GitLab 操作员
*   正在删除 GitLab

# 使用您自己的通配符证书

GitLab 的 Helm chart 安装支持使用 nginx 控制器终止 TLS。当你安装 GitLab 的时候，你有很多选择。为了提高安全性，您可以使用证书管理器和让我们加密，或者选择使用您自己的通配符证书。在本食谱中，我们将解释如何使用您自己的通配符证书选项，如下所示:

1.  将您的证书和密钥作为机密添加到群集:

```
$ kubectl create secret tls mytls --cert=cert.crt --key=key.key
```

2.  使用以下附加参数从 Helm 图表部署 GitLab:

```
$ helm upgrade --install gitlab gitlab/gitlab --namespace gitlab \
--timeout 600 \
--set global.edition=ce \
--version 2.1.6 \
--set certmanager.install=false \
--set global.ingress.configureCertmanager=false \
--set global.ingress.tls.secretName=mytls
```

# 使用自动生成的自签名证书

如果您不能使用自己的通配符证书来生效，并且仍然希望快速启动 GitLab 进行测试或更小的用例，您也可以使用自动生成的自签名证书。在本食谱中，我们将解释如何使用自签名证书，这在“让我们加密”不是选项但仍然需要 SSL 安全性的环境中非常有用:

1.  如果无法从“让我们加密”服务器访问您的域，您可以提供自动生成的自签名通配符证书:

```
$ helm upgrade --install gitlab gitlab/gitlab --namespace gitlab \
--timeout 600 \
--set global.edition=ce \
--version 2.1.6 \
--set certmanager.install=false \
--set global.ingress.configureCertmanager=false \
--set gitlab-runner.install=false
```

2.  检索证书，该证书可以稍后导入到 web 浏览器或系统存储中:

```
$ kubectl get secret gitlab-wildcard-tls-ca -n gitlab \
-ojsonpath='{.data.cfssl_ca}' | base64 --decode > gitlab.mydomain.com.ca.pem
```

# 启用实验室操作员

GitLab 提供了一个实验操作器。该操作员控制升级过程，并帮助执行滚动升级，无需停机。让我们执行以下步骤来运行 GitLab 操作员:

1.  首先，通过使用如下 Helm 参数启用全球操作员，确保 CRD 到位:

```
$ helm upgrade --install gitlab . --set global.Operator.enabled=true \
--set global.Operator.bootstrap=true 
```

2.  使用舵角图部署 GitLab 操作员:

```
$ helm upgrade gitlab . --set global.Operator.enabled=true \
--set global.Operator.bootstrap=false 
```

# 正在删除 GitLab

让我们执行以下步骤来完全删除我们在本节中创建的 GitLab 部署:

1.  使用 Helm 删除现有版本的 GitLab:

```
$ helm delete --purge gitlab
```

2.  您可能还想删除命名空间，以确保没有留下任何内容:

```
$ kubectl delete ns gitlab
```

现在，您已经学习了如何在 Kubernetes 上启动和运行 GitLab。在 *GitLab* 部分的[第 3 章](03.html)、*建筑 CI* / *光盘管道*中将需要这些知识，在这里您将学习如何在 GitLab 中导入应用程序和创建管道。

# 请参见

*   GitLab 云原生 Helm 图表文档:[https://docs.gitlab.com/charts/](https://docs.gitlab.com/charts/)
*   高级配置选项:[https://docs.gitlab.com/charts/advanced/](https://docs.gitlab.com/charts/advanced/)
*   GitLab 操作员:[https://docs.gitlab.com/charts/installation/Operator.html](https://docs.gitlab.com/charts/installation/operator.html)
*   安装 GitLab 社区版的替代方法:[https://about.gitlab.com/install/?version=ce/](https://about.gitlab.com/install/?version=ce/)