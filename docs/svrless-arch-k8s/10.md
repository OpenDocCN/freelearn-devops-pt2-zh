# 附录

关于

包括这一部分是为了帮助学生完成书中的活动。

它包括学生为实现活动目标而要执行的详细步骤。

## 1.无服务器简介

### 活动 1:伦敦自行车积分的推特机器人后端

**解决方案:**

执行以下步骤完成本活动:

1.  Create a **main.go** file for registering function handlers, as in *Exercise 1*.

    该代码是注册函数的应用的入口点，主应用启动:

    ```
    package main
    import (
       "fmt"
       "net/http"
    )
    func main() {
       fmt.Println("Starting the 🚲 finder..")
       http.HandleFunc("/", FindBikes)
       fmt.Println("Function handlers are registered.")
       http.ListenAndServe(":8080", nil)
    }
    ```

2.  Create a **function.go** file for the **FindBikes** function:

    ```
    ...
    func FindBikes(w http.ResponseWriter, r *http.Request) {
       ...

       // Get bike points for the query
       bikePoints, err := httpClient.Get(fmt.Sprintf(TFL_API_URL + "BikePoint/Search?query=" + url2.QueryEscape(query)))
       ...
       // Get available number of bikes
       availableBikeResponse, err := httpClient.Get(TFL_API_URL + "BikePoint/" + bikePoint.ID)

    ...
             if bikeAmount == 0 {
                w.Write([]byte(fmt.Sprintf(RESPONSE_NO_AVAILABLE_BIKE, bikePoint.CommonName, url)))
                return
             } else {
                w.Write([]byte(fmt.Sprintf(DEFAULT_RESPONSE, bikePoint.CommonName, bikeAmount, url)))
                return
             }
    ...
    ```

    #### 注意

    活动所需的文件可在以下链接上找到:https://github . com/trainingyppackt/less-architecture-wit-Kubernetes/tree/master/lesson 01/activity 1。

    在这个文件中，应该实现实际的函数及其助手。**查找自行车**负责从 **TFL 统一应用编程接口**获取自行车点位置的数据，然后获取可用自行车的数量。根据收集到的信息，这个函数返回完整的句子作为推特的回应。

3.  Create a **Dockerfile** for building and packaging the function, as in *Exercise 2*:

    ```
    FROM golang:1.12.5-alpine3.9 AS builder
    ADD . .
    RUN go build *.go
    FROM alpine:3.9
    RUN apk update && apk add ca-certificates && rm -rf /var/cache/apk/*
    RUN update-ca-certificates
    COPY --from=builder /go/function ./bikes
    RUN chmod +x ./bikes
    ENTRYPOINT ["./bikes"]
    ```

    在这个 **Dockerfile** 中，应用构建在第一个容器中，并打包在第二个容器中进行交付。

4.  Build the container image with Docker commands: **docker build . -t find-bikes**.

    应该是这样的:

    ![Figure 1.27: Building the Docker image ](img/C12607_01_27.jpg)

    ###### 图 1.27:构建 Docker 映像

5.  Run the container image as a Docker container and make the ports available on the host system: **docker run -it --rm -p 8080:8080 find-bikes**.

    事情应该如下图所示:

    ![Figure 1.28: Running the Docker container ](img/C12607_01_28.jpg)

    ###### 图 1.28:运行 Docker 容器

6.  Test the function's HTTP endpoint with different queries, such as **Oxford**, **Abbey**, or **Diagon Alley**.

    我们期望从文献中得到伦敦街道的真实反应和想象街道的失败反应:

    ![Figure 1.29: Function responses for different streets ](img/C12607_01_29.jpg)

    ###### 图 1.29:不同街道的功能响应

7.  Press *Ctrl + C* to exit the container:

    ![Figure 1.30: Exiting the container ](img/C12607_01_30.jpg)

###### 图 1.30:退出容器

## 2。云中无服务器简介

### 活动 2:日常备用会议提醒功能

**解决方案**–**松弛设置:**

1.  In the **Slack** workspace, click on your username and select **Customize Slack**, as shown in the following screenshot:

    ![](img/C12607_02_49.jpg)

    ###### 图 2.49:松弛菜单

2.  Click on **Configure apps** in the open window, as shown in the following screenshot:

    ![](img/C12607_02_50.jpg)

    ###### 图 2.50:松弛配置菜单

3.  Click on **Browse the App Directory** to add a new application from the directory, as shown in the following screenshot:

    ![Figure 2.51: Slack management   ](img/C12607_02_51.jpg)

    ###### 图 2.51:松弛管理

4.  Find **Incoming WebHooks** from the search box in **App Directory**, as shown in the following screenshot:

    ![Figure 2.52: App Directory ](img/C12607_02_52.jpg)

    ###### 图 2.52:应用目录

5.  Click on **Add Configuration** for the **Incoming WebHooks** application, as shown in the following screenshot:

    ![Figure 2.53: Incoming Webhooks page ](img/C12607_02_53.jpg)

    ###### 图 2.53:传入网络钩子页面

6.  Fill in the configuration for the incoming webhook by specifying your specific channel name and icon, as shown in the following screenshot:

    ![Figure 2.54: Incoming webhook configuration ](img/C12607_02_54.jpg)

    ###### 图 2.54:传入的网络钩子配置

    复制**网钩网址**，点击**保存设置**，如前面截图所示。

7.  打开我们在步骤 6 中提到的 Slack 工作区和通道。您将看到一条集成消息:

![Figure 2.55: Integration message in Slack ](img/C12607_02_55.jpg)

###### 图 2.55:Slack 中的集成消息

**活动解决方案**

执行以下步骤完成本活动:

1.  Create a new function to call the Slack webhook when the function is invoked.

    在 GCF 中，可以用名称 **StandupReminder** 定义，128 MB 内存，一个 HTTP 触发器。

    该功能可以用任何支持的语言实现，如 **Go 1.11** ，如下图截图所示:

    ![Figure 2.56: Cloud function in Google Cloud Platform ](img/C12607_02_56.jpg)

    ###### 图 2.56:谷歌云平台中的云功能

    要添加的代码如下:

    ```
    package p
    import (
        "bytes"
        "net/http"
    )
    func Reminder(http.ResponseWriter, *http.Request) {
        url := "https://hooks.slack.com/services/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"

        var jsonStr = []byte(`{"text": "Time for a stand-up meeting!"}`)
        req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonStr))

        client := &http.Client{}
        _, err = client.Do(req)
        if err != nil {
            panic(err)
        }
    }
    ```

    #### 注意

    不要忘记从第 6 步开始，为传入的 webhook 配置用 Slack URL 更改 **url** 值。

    你可以在本书 GitHub 资源库的活动解决方案中找到完整的 **function.go** 文件:[https://GitHub . com/trainingypbackt/server less-Architectures-with-Kubernetes/blob/master/lesson 02/activity 2/function . go](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson02/Activity2/function.go)。

2.  Create a scheduler job with the trigger URL of the function and specify the schedule based on your stand-up meeting times.

    调度器可以在谷歌云调度器中定义，名称为 **StartupReminder** 和函数的 URL，如下图截图所示:

    ![Figure 2.57: Cloud scheduler in Google Cloud Platform ](img/C12607_02_57.jpg)

    ###### 图 2.57:谷歌云平台中的云调度器

    按照 **0 9 * * 1-5** 的时间表，提醒将在周一至周五的每一天的 09:00 调用该功能。

3.  Check the Slack channel when the time that was defined with the schedule has arrived for the reminder message.

    对于 **0 9 * * 1-5** 的日程安排，您将在工作日的 09:00 在您选择的 Slack 频道上看到一条消息，如下截图所示:

    ![Figure 2.58: Slack reminder message  ](img/C12607_02_58.jpg)

    ###### 图 2.58:松弛提醒消息

4.  Delete the schedule job and function from the cloud provider, as shown in the following screenshot:

    ![Figure 2.59: Deletion of the scheduler ](img/C12607_02_59.jpg)

###### 图 2.59:删除调度程序

该功能可以这样删除:

![Figure 2.60: Deletion of the function ](img/C12607_02_60.jpg)

###### 图 2.60:删除功能

在本练习中，我们使用函数构建了 Slack 应用的后端。我们首先为传入的 webhook 配置 Slack，然后创建一个函数向 web hook 发送数据。因为我们的函数应该在预定义的时间被调用，所以我们使用云调度服务来调用函数。通过 Slack 中的一条成功的提醒消息，展示了功能与其他云服务和外部服务的集成。

## 3。无服务器框架介绍

### 活动 3:松弛状态的每日天气状态功能

**解决方案-松弛设置**

1.  执行以下步骤来配置松弛时间:
2.  In your Slack workspace, click on your username and select Customize Slack:

    ![Figure 3.44: Slack menu ](img/C12607_03_44.jpg)

    ###### 图 3.44:松弛菜单

3.  Click on Configure apps in the opened window:

    ![Figure 3.45: Slack configuration menu ](img/C12607_03_45.jpg)

    ###### 图 3.45:松弛配置菜单

4.  Click on Browse the App Directory to add a new application from the directory:

    ![Figure 3.46: Slack management ](img/C12607_03_46.jpg)

    ###### 图 3.46:松弛管理

5.  Find Incoming WebHooks from the search box in App Directory:

    ![Figure 3.47: App Directory ](img/C12607_03_47.jpg)

    ###### 图 3.47:应用目录

6.  Click on Set Up for the Incoming WebHooks application:

    ![Figure 3.48: Incoming WebHooks page ](img/C12607_03_48.jpg)

    ###### 图 3.48:传入的网络挂钩页面

7.  Choose a channel for posting joke messages and click on the Add Incoming WebHooks integration:

    ![Figure 3.49: Channel selection  ](img/C12607_03_49.jpg)

    ###### 图 3.49:频道选择

8.  Fill in the configuration for the incoming webhook with your specific channel name and icon:

    ![Figure 3.50: Incoming WebHook configuration ](img/C12607_03_50.jpg)

    ###### 图 3.50:传入的网络钩子配置

    复制网页挂钩网址，然后单击保存设置。

9.  Open your Slack workspace and the channel you configured in Step 6 to check the integration message:

    ![Figure 3.51: Integration message in Slack ](img/C12607_03_51.jpg)

###### 图 3.51:Slack 中的集成消息

**活动解决方案**

1.  执行以下步骤完成本活动:
2.  In your Terminal, start the Serverless Framework development environment:

    ```
    docker run -it --entrypoint=bash onuryilmaz/serverless
    ```

    该命令将以交互模式启动 Docker 容器。在接下来的步骤中，将在这个 Docker 容器中采取操作:

    ![Figure 3.52: Starting a Docker container for serverless  ](img/C12607_03_52.jpg)

    ###### 图 3.52:为无服务器启动 Docker 容器

3.  In your Terminal, create a Serverless Framework application structure in a folder called daily-weather.

    创建一个名为 daily-joker 的文件夹，并将其更改为以下目录:

    ```
    mkdir daily-weather
    cd daily-weather
    ```

    #### 注意

    nano 和 vim 作为文本编辑器安装在无服务器框架开发环境 Docker 容器中。

4.  Create a serverless.yaml file with the following content and replace the value of SLACK_WEBHOOK_URL with the URL you copied from Step 6 of the Slack Setup. Furthermore, update the CITY environment variable with the current office location to get the correct weather information. In addition, you can change the schedule section, which is currently triggering the function every workday at 08:00:

    ```
    service: daily-weather
    provider:
      name: aws
      runtime: nodejs8.10
    functions:
      weather:
        handler: handler.weather
        events:
          - schedule: cron(0 8 ? * 1-5 *)
        environment:
          CITY: Berlin
          SLACK_WEBHOOK_URL: https://hooks.slack.com/services/.../.../...
    ```

    #### 注意

    无服务器. yaml 可在[https://github . com/trainingypbackt/无服务器-architecture-with-Kubernetes/blob/master/lesson 03/activity 3/无服务器. yaml](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson03/Activity3/serverless.yaml) 获得。

5.  Create a package.json file to define the Node.js environment in the daily-weather folder.

    package.json 定义了函数及其依赖关系:

    ```
    {
      "name": "daily-weather",
      "description": "",
      "main": "handler.js",
        "dependencies": {
        "node-fetch": "^2.2.1",
        "slack-node": "0.1.8"
      }
    }
    ```

    #### 注意

    package.json 可在[https://github . com/trainingypbackt/server less-Architectures-with-Kubernetes/blob/master/lesson 03/activity 3/package . JSON](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson03/Activity3/package.json)获得。

6.  Create a handler.js file to implement the actual functionality in the daily-weather folder.

    handler.js 由实际的 Node.js 函数组成:

    ```
    const fetch = require('node-fetch');
    const Slack = require('slack-node');
    module.exports.weather = (event, context, callback) => {
        const webhookUri = process.env.SLACK_WEBHOOK_URL;
        const location = process.env.CITY;
        const slack = new Slack();
        slack.setWebhook(webhookUri);
        weatherURL = "http://wttr.in/" + encodeURIComponent(location) + "?m&&format=1"
        console.log(weatherURL)
        fetch(weatherURL)
            .then(response => response.text())
            .then(data => {
                console.log("======== WEATHER TEXT ========")
                console.error(data);
                console.log("======== WEATHER TEXT ========")
                slack.webhook({
                    text: "Current weather status is " + data
                }, function(err, response) {
                    console.log("======== SLACK SEND STATUS ========")
                    console.error(response.status);
                    return callback(null, {statusCode: 200, body: "ok" });
                    console.log("======== SLACK SEND STATUS ========")
                    if (err) {
                        console.log("======== ERROR ========")
                        console.error(error);
                        console.log("======== ERROR ========")
                        return callback(null, {statusCode: 500, body: JSON.stringify({ error}) });
                    }
                });
            }).catch((error) => {
                console.log("======== ERROR ========")
                console.error(error);
                console.log("======== ERROR ========")
                 return callback(null, {statusCode: 500, body: JSON.stringify({ error}) });
            });
    };
    ```

    #### 注意

    handler.js 可在[https://github . com/trainingypbackt/server less-Architectures-with-Kubernetes/blob/master/lesson 03/activity 3/handler . js](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson03/Activity3/handler.js)获得。

7.  At the end of the file's creation, you will see the following file structure, with three files:

    ```
    ls -l
    ```

    输出应如下所示:

    ![Figure 3.53: Folder structure ](img/C12607_03_53.jpg)

    ###### 图 3.53:文件夹结构

8.  Install the required Node.js dependencies for the serverless application. Run the following command to install the dependencies:

    ```
    npm install -i
    ```

    输出应如下所示:

    ![Figure 3.54: Dependency installation  ](img/C12607_03_54.jpg)

    ###### 图 3.54:依赖项安装

9.  Export the AWS credentials as environment variables. Export the following environment variables and AWS credentials from Exercise xx:

    ```
    export AWS_ACCESS_KEY_ID=AKIASVTPHRZR33BS256U
    export AWS_SECRET_ACCESS_KEY=B***************************R
    ```

    输出应如下所示:

    ![Figure 3.55: AWS Credentials ](img/C12607_03_55.jpg)

    ###### 图 3.55:自动气象站凭证

10.  Deploy the serverless application to AWS using the Serverless Framework. Run the following commands to deploy the function:

    ```
    serverless deploy 
    ```

    这些命令将使无服务器框架将该功能部署到 AWS 中。输出日志从打包服务和为源代码、工件和函数创建 AWS 资源开始。创建完所有资源后，服务信息部分提供了完整堆栈的摘要，如下图所示:

    ![Figure 3.56: Serverless Framework deployment output ](img/C12607_03_56.jpg)

    ###### 图 3.56:无服务器框架部署输出

11.  Check AWS Lambda for the deployed functions in the AWS Console as shown in the following figure:

    ![Figure 3.57: AWS Lambda in the AWS Console ](img/C12607_03_57.jpg)

    ###### 图 3.57: AWS 控制台中的 AWS Lambda

12.  Invoke the function with the Serverless Framework's client tools. Run the following command in your Terminal:

    ```
    serverless invoke --function weather
    ```

    该命令调用部署的函数并输出响应，如下图所示:

    ![Figure 3.58: Function output  ](img/C12607_03_58.jpg)

    ###### 图 3.58:功能输出

    我们可以看到，statusCode 为 200，响应的主体也表示函数已经成功响应。

13.  Check the Slack channel for the posted weather status:

    ![FFigure 3.59: Slack message with weather status ](img/C12607_03_59.jpg)

    ###### 图 3.59:带有天气状态的松弛消息

14.  Return to your Terminal and delete the function with the Serverless Framework. Run the following command in your Terminal:

    ```
    serverless remove
    ```

    该命令将删除已部署的函数及其所有依赖项:

    ![Figure 3.60: Removing the function ](img/C12607_03_60.jpg)

    ###### 图 3.60:删除功能

15.  Exit the Serverless Framework development environment container. Run exit in your Terminal:

    ![Figure 3.61: Exiting the container  ](img/C12607_03_61.jpg)

###### 图 3.61:退出容器

在本练习中，我们使用无服务器框架构建了 Slack 应用的后端。我们首先为传入的 webhook 配置 Slack，然后创建一个无服务器应用将数据发送到 web hook。为了在预定义的时间调用该功能，使用了无服务器框架的配置，而不是特定于云的调度器。由于无服务器框架为云提供商创建了一个抽象，因此我们在本练习中开发的无服务器应用适用于多云部署。

## 4.Kubernetes深空的沙发

### 活动 4:在 Kubernetes 的 MySQL 数据库中收集黄金价格

**解决方案:**

执行以下步骤完成本活动:

1.  Create an application to retrieve the gold price from **CurrencyLayer** and insert it into the MySQL database.

    可以用下面的 main.go 文件在 Go 中实现这个功能:

    ```
    ...
    func main() {
        db, err := sql.Open("mysql",  ...
        ...
        r, err := http.Get(fmt.Sprintf(„http://apilayer.net/api/...
       ...
        stmt, err := db.Prepare("INSERT INTO GoldPrices(price) VALUES(?)")
        ...
        _, err = stmt.Exec(target.Quotes.USDXAU)
        ...
        log.Printf("Successfully inserted the price: %v", target.Quotes.USDXAU)
        ...
    }
    ```

    主要功能从数据库连接开始，然后从**current layer**进行价格检索。然后，它继续创建一条 SQL 语句，并在数据库连接上执行。

    #### 注意

    main.go 可在[https://github . com/trainingypbackt/server less-Architectures-with-Kubernetes/blob/master/lesson 04/activity 4/main . go](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Activity4/main.go)上获得。

2.  Build the application as a Docker container. It is possible to build the application from Step 1 with the following Dockerfile:

    ```
    FROM golang:1.12.5-alpine3.9 AS builder
    RUN apk add --no-cache git
    ADD main.go /go/src/gold-price-to-mysql/main.go
    WORKDIR /go/src/gold-price-to-mysql/
    RUN go get -v
    RUN go build .
    FROM alpine:3.9
    COPY --from=builder /go/src/gold-price-to-mysql/gold-price-to-mysql ./gold-price-to-mysql
    RUN chmod +x ./gold-price-to-mysql
    ENTRYPOINT ["./gold-price-to-mysql"]
    ```

    #### 注意

    Dockerfile 可在[https://github . com/trainingypbackt/server less-architecture-with-Kubernetes/blob/master/lesson 04/activity 4/docker file](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Activity4/Dockerfile)上获得。

3.  Run the following command in your Terminal:

    ```
    docker build -t <USERNAME>/gold-price-to-mysql .
    ```

    该命令将应用构建为 Docker 容器，如下图所示:

    ![Figure 4.26: Docker build ](img/C12607_04_26.jpg)

    ###### 图 4.26: Docker 构建

    #### 注意

    不要忘记将 **<用户名>** 更改为您的码头工人中心用户名。

4.  Push the Docker container to the Docker registry. Run the following command in your Terminal:

    ```
    docker push <USERNAME>/gold-price-to-mysql
    ```

    该命令将容器映像上传到 Docker Hub，如下图所示:

    ![Figure 4.27: Docker push ](img/C12607_04_27.jpg)

    ###### 图 4.27: Docker 推送

    #### 注意

    不要忘记将 **<用户名>** 更改为您的码头工人中心用户名。

5.  Deploy the MySQL database into the Kubernetes cluster. Create a mysql.yaml file with the MySQL StatefulSet definition:

    ```
    apiVersion: apps/v1
    kind: StatefulSet
    metadata:
      name: mysql
    spec:
      selector:
        matchLabels:
          app: mysql
      serviceName: mysql
      replicas: 1
      template:
        metadata:
          labels:
            app: mysql
        spec:
          containers:
          - name: mysql
            image: mysql:5.7
            env:
            - name: MYSQL_ROOT_PASSWORD
              value: "root"
            - name: MYSQL_DATABASE
              value: "db"
            - name: MYSQL_USER
              value: "user"
            - name: MYSQL_PASSWORD
              value: "password"
            ports:
            - name: mysql
              containerPort: 3306
            volumeMounts:
            - name: data
              mountPath: /var/lib/mysql
              subPath: mysql
      volumeClaimTemplates:
      - metadata:
          name: data
        spec:
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 1Gi
    ```

    #### 注意

    mysql.yaml 可在[https://github . com/trainingypbackt/server less-Architectures-with-Kubernetes/blob/master/lesson 04/activity 4/MySQL . YAML](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Activity4/mysql.yaml)上获得。

6.  Deploy the StatefulSet with the following command in your Terminal:

    ```
    kubectl apply -f mysql.yaml
    ```

    该命令将文件提交给 Kubernetes 并创建 mysql StatefulSet，如下图所示:

    ![Figure 4.28: StatefulSet creation ](img/C12607_04_28.jpg)

    ###### 图 4.28:状态集合创建

7.  Deploy a Kubernetes service to expose MySQL database. Create a service.yaml file with the following Kubernetes Service definition:

    ```
    apiVersion: v1
    kind: Service
    metadata:
      name: gold-price-db
    spec:
      selector:
        app: mysql
      ports:
        - protocol: TCP
          port: 3306
          targetPort: 3306
    ```

    #### 注意

    service.yaml 可在[https://github . com/trainingypbackt/server less-Architectures-with-Kubernetes/blob/master/lesson 04/activity 4/service . YAML](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Activity4/service.yaml)获得。

8.  Deploy the service with the following command in your Terminal:

    ```
    kubectl apply -f service.yaml
    ```

    该命令将文件提交给 Kubernetes 并创建 gold-price-db 服务，如下图所示:

    ![Figure 4.29: Service creation ](img/C12607_04_29.jpg)

    ###### 图 4.29:服务创建

9.  Deploy a CronJob to run every minute. Create an insert-gold-price.yaml file with the following Kubernetes CronJob definition:

    ```
    apiVersion: batch/v1beta1
    kind: CronJob
    metadata:
      name: gold-price-to-mysql
    spec:
      schedule: "* * * * *"
      jobTemplate:
        spec:
          template:
            spec:
              restartPolicy: OnFailure
              containers:
              - name: insert
                image: <USERNAME>/gold-price-to-mysql
                env:
                - name: MYSQL_ADDRESS
                  value: "gold-price-db:3306"
                - name: MYSQL_DATABASE
                  value: "db"
                - name: MYSQL_USER
                  value: "user"
                - name: MYSQL_PASSWORD
                  value: "password"
                - name: API_KEY
                  value: "<API-KEY>"
    ```

    #### 注意

    insert-gold-price.yaml 可在[https://github . com/trainingypbackt/server less-architecture-with-Kubernetes/blob/master/lesson 04/activity 4/insert-gold-price . YAML](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson04/Activity4/insert-gold-price.yaml)获得。

    不要忘记将 **<用户名>** 更改为您的 Docker Hub 用户名，并将**T6】API-KEY>**更改为您当前的图层 API 密钥。

10.  Deploy the CronJob with the following command in your Terminal:

    ```
    kubectl apply -f insert-gold-price.yaml
    ```

    该命令将文件提交给 Kubernetes，并创建黄金价格到 mysql 的 CronJob，如下图所示:

    ![Figure 4.30: CronJob creation ](img/C12607_04_30.jpg)

    ###### 图 4.30:创建核心工作

11.  Wait for a couple of minutes and check the instances of CronJob. Check the running pods with the following command in your Terminal:

    ```
    kubectl get pods
    ```

    该命令列出了 pods，您应该会看到两个实例，它们的名称以黄金价格到 mysql 开头，状态为“已完成”，如下图所示:

    ![Figure 4.31: Pod listing ](img/C12607_04_31.jpg)

    ###### 图 4.31: Pod 列表

12.  Connect to the database and check for the entries:

    ```
    kubectl run mysql-client --image=mysql:5.7 -i -t --rm --restart=Never \
    -- mysql -h gold-price-db -u user -ppassword  db -e "SELECT * FROM GoldPrices;"
    ```

    此命令运行 mysql:5.7 映像的临时实例，并运行 SELECT * FROM GoldPrices 命令，如下图所示:

    ![Figure 4.32: Table listing ](img/C12607_04_32.jpg)

    ###### 图 4.32:表格列表

    在 GoldPrices MySQL 表中，每分钟都有收集到的价格数据。它显示 MySQL StatefulSet 已启动并成功运行数据库。此外，CronJob 每分钟都在创建 pods，并且正在成功运行。

13.  Clean the database and automated tasks from Kubernetes. Clean the resources with the following command in your Terminal:

    ```
    kubectl delete -f insert-gold-price.yaml,service.yaml,mysql.yaml
    ```

    您应该会看到下图所示的输出:

    ![Figure 4.33: Resource deletion ](img/C12607_04_33.jpg)

###### 图 4.33:资源删除

在本活动中，我们在 Kubernetes 中创建了一个 MySQL 数据库作为 StatefulSet。Kubernetes 已经创建了所需的卷资源，并附加到 MySQL 容器中。接下来，我们创建并打包了我们的无服务器函数。该功能作为 CronJob 部署到 Kubernetes 集群。Kubernetes 确保该功能每分钟都被安排和运行。在 Kubernetes 中运行函数提供了两个基本优势。第一个是 Kubernetes 集群和资源的重用。换句话说，我们没有使用任何额外的云资源来运行我们的无服务器工作负载。第二个优势是接近数据。由于我们的微服务已经在 Kubernetes 上运行，建议将我们的数据库放在 Kubernetes 中。当无服务器应用也在同一个群集中运行时，操作、管理和排除应用故障会更容易。

## 5.生产就绪库群集

### 活动 5:最小化 GKE 集群中无服务器功能的成本

**解决方案**

1.  Create a new node pool with preemptible servers.

    在您的 GCP 云外壳中运行以下和即将到来的功能:

    ```
    gcloud beta container node-pools create preemptible --preemptible \
    --min-nodes 1 --max-nodes 10  --enable-autoscaling  \
    --cluster serverless --zone us-central1-a 
    ```

    #### 注意

    如果您的集群在另一个区域运行，请更改**区域**参数。

    该函数创建一个名为**的可抢占**的新节点池，该节点池自动缩放最小 1 个节点，最大 10 个节点，如下图所示:

    ![Figure 5.29: Node pool creation ](img/C12607_05_29.jpg)

    ###### 图 5.29:节点池创建

2.  Taint the preemptible servers to run only serverless functions:

    ```
    kubectl taint node -l cloud.google.com/gke-nodepool=preemptible   \
    preemptible="true":NoSchedule
    ```

    该命令将把污点应用到标签为**cloud.google.com/node-pool =可抢占**的所有节点。污点键将是**可抢占的**，值为**真**。该限制的动作为**无调度**，这意味着只有具有匹配容忍度的吊舱才会被调度到这些节点，如下图所示:

    ![Figure 5.30: Tainting the nodes ](img/C12607_05_30.jpg)

    ###### 图 5.30:污染节点

3.  Create a Kubernetes service to reach backend pods:

    ```
    kubectl expose deployment backend --port 80 --target-port=80
    ```

    该命令为端口 **80** 上的部署后端创建一个服务，如下图所示:

    ![Figure 5.31: Exposing the deployment ](img/C12607_05_31.jpg)

    ###### 图 5.31:公开部署

4.  Create a **CronJob** to connect to the backend service every minute. The CronJob definition should have tolerations to run on preemptible servers.

    在名为 **cronjob.yaml** 的文件中创建一个包含以下内容的 **CronJob** 定义:

    ```
    apiVersion: batch/v1beta1
    kind: CronJob
    metadata:
      name: backend-checker
    spec:
      schedule: "*/1 * * * *"
      jobTemplate:
        spec:
          template:
            spec:
              containers:
              - name: checker
                image: appropriate/curl
                args:
                - curl
                - -I
                - backend
              nodeSelector:
                cloud.google.com/gke-nodepool: "preemptible"
              tolerations:
              - key: preemptible
                operator: Equal
                value: "true"
                effect: NoSchedule
              restartPolicy: OnFailure
    ```

    该文件有一个用于每分钟运行 **curl -I 后端**功能的 **CronJob** 定义。**节点选择器**表示调度程序将选择在标签键为**cloud.google.com/gke-nodepool**且值为**可抢占**的节点上运行。然而，由于在可抢占的节点上有污点，容忍也被添加。

    #### 注意

    **cronjob.yaml** 可在 GitHub:[https://GitHub . com/trainingypbackt/无服务器架构-with-Kubernetes/blob/master/lesson 05/activity 5/cron job . YAML](https://github.com/TrainingByPackt/Serverless-Architectures-with-Kubernetes/blob/master/Lesson05/Activity5/cronjob.yaml)上获得。

5.  Deploy the CronJob with the following command:

    ```
    kubectl apply -f cronjob.yaml
    ```

    输出应如下所示:

    ![Figure 5.32: CronJob creation ](img/C12607_05_32.jpg)

    ###### 图 5.32:创建核心工作

6.  Check the node assignments of the **CronJob** functions:

    ```
    kubectl get pods -o wide
    ```

    该命令列出了 pod 及其相应的节点。不出所料，正好有 10 个后端实例运行在**高内存**节点上。此外，还有 3 个运行在**可抢占**节点上的 CronJob 函数实例，如下图所示:

    ![Figure 5.33: Pod listing ](img/C12607_05_33.jpg)

    ###### 图 5.33: Pod 列表

7.  Check the logs of **CronJob** function instances:

    ```
    kubectl logs brand-checker-<ID> 
    ```

    #### 注意

    将 **< ID >** 替换为*步骤 5* 中的豆荚名称。

    该函数的输出显示了**卷曲**连接到 **nginx** 实例的轨迹，如下图所示:

    ![Figure 5.34: curl output ](img/C12607_05_34.jpg)

    ###### 图 5.34:卷曲输出

8.  Clean the backend deployment and serverless functions:

    ```
    kubectl delete deployment/backend cronjob/backend-checker
    ```

    该命令删除**后端**部署和**后端检查器**克隆作业，如下图所示:

    ![Figure 5.35: Cleanup ](img/C12607_05_35.jpg)

    ###### 图 5.35:清理

9.  Remove the Kubernetes cluster if you do not need it anymore:

    ```
    gcloud container clusters delete serverless --zone us-central1-a 
    ```

    #### 注意

    如果您的集群正在另一个区域运行，请更改命令中的**区域**参数。

    该命令从 GKE 删除集群，如下图所示:

    ![Figure 5.36: Cluster removal ](img/C12607_05_36.jpg)

###### 图 5.36:集群移除

在本活动中，我们在一个实时生产集群上承担了管理任务。在 Kubernetes 集群中创建不同类型的节点并运行一组异构节点有助于降低整个集群的成本。此外，自动缩放能够自动满足用户需求，无需人工干预。

应用的自动缩放和迁移是生产集群上最常见的操作任务。这些任务能够以最少的停机时间和成本实现更好的性能。但是，为您的生产环境选择的 Kubernetes 平台也应该满足您日常操作的这些要求。Kubernetes 和云提供商的功能对于安装、监控和操作云中运行的应用至关重要。

## 6.Kubernet 即将推出的无服务器功能

### 活动 6:在无服务器环境中部署容器化应用

**解决方案**

1.  首先，创建一个新目录来存储此活动的文件，并将目录更改为新创建的目录:

    ```
    $ mkdir chapter-06-activity
    $ cd chapter-06-activity
    ```

2.  Create an application that can return the current date and time for the given timezone. We will be using PHP to write this function, but you can choose any language that you're comfortable with. Create an index.php file with the content given in step 1\.

    现在我们需要根据容器运行时契约(https://Cloud . Google . com/Run/docs/reference/contract-contract)为 Google Cloud Run 创建 Docker 映像。使用步骤 2 中的内容创建一个名为 Dockerfile 的新文件。

3.  Once the Dockerfile is ready, we can build the Docker image. Replace **<your-gcp-project-name>** with the ID of your GCP project. Next, use the docker build command to build the Docker image. The **--tag** flag is used to tag the Docker image as per the **[HOSTNAME]/[GCP-PROJECT-ID]/[IMAGE-NAME]:[TAG]** format, as we will be pushing this to **Google Container Registry (GCR)** in the next step:

    ```
    $ export GCP_PROJECT=<your-gcp-project-name>
    $ docker build . --tag gcr.io/${GCP_PROJECT}/clock:v1.0
    ```

    输出应如下所示:

    ![Figure 6.57: Building the Docker image ](img/C12607_06_57.jpg)

    ###### 图 6.57:构建 Docker 映像

4.  Next, we can push the docker image to GCR:

    ```
    $ docker push gcr.io/${GCP_PROJECT}/clock:v1.0
    ```

    输出应如下所示:

    ![Figure 6.58: Pushing the Docker image ](img/C12607_06_58.jpg)

    ###### 图 6.58:推送 Docker 映像

5.  Now we have a Docker image created and pushed to the registry. Now navigate to the GCP console and open the Cloud Run page. Click on the **CREATE SERVICE** button to create a new service with the following information:

    容器映像网址:**gcr.io/<您的-GCP-project-id>/时钟:v1.0**

    部署平台:云运行(完全管理)

    位置:从可用选项中选择您喜欢的任何地区

    服务名称:时钟

    认证:**允许未经认证的调用**

    该页面如下所示:

    ![Figure 6.59: Creating a service ](img/C12607_06_59.jpg)

    ###### 图 6.59:创建服务

6.  Click on the **CREATE** button and you will be navigated to the Service details page:

    ![Figure 6.60: Service details ](img/C12607_06_60.jpg)

    ###### 图 6.60:服务详情

7.  Open the provided URL from the Service details page. For me, this URL is **https://clock-awsve2jaoa-uc.a.run.app/**, but your URL will be different:

    ![Figure 6.61: Timezone error ](img/C12607_06_61.jpg)

    ###### 图 6.61:时区错误

8.  我们收到此错误，因为我们没有提供时区参数。
9.  Let's invoke the URL again with the timezone parameter, **https://clock-awsve2jaoa-uc.a.run.app/?timezone=Europe/London**

    ![Figure 6.62: Output with timezone ](img/C12607_06_62.jpg)

###### 图 6.62:带时区的输出

在本练习中，我们已经在谷歌云运行上成功部署了一个容器化的应用，该应用可以基于提供的**时区**值输出当前日期和时间。

## 7.无库服务器和无库服务器

### 活动 7:用无库发布消息到 Slack

**解决方案-松弛设置**

1.  Visit https://slack.com/create to create a workspace. Enter your email address and click on Create:

    ![Figure 7.77: Creating a new workspace ](img/C12607_07_77.jpg)

    ###### 图 7.77:创建新的工作空间

2.  Now, you will receive a six-digit confirmation code to the email that you entered on the previous page. Enter the received code on the following page:

    ![Figure 7.78: Checking your email ](img/C12607_07_78.jpg)

    ###### 图 7.78:查看你的电子邮件

3.  Add a suitable name here. This will be your workspace name:

    ![Figure 7.79: Adding a workspace name ](img/C12607_07_79.jpg)

    ###### 图 7.79:添加工作空间名称

4.  Add a suitable name here. This will be your Slack channel name:

    ![Figure 7.80: Adding a Slack channel name ](img/C12607_07_80.jpg)

    ###### 图 7.80:添加备用频道名称

    如果您愿意，可以跳过以下部分:

    ![Figure 7.81: Filling in further details or choosing to skip ](img/C12607_07_81.jpg)

    ###### 图 7.81:填写更多细节或选择跳过

5.  Now your Slack channel is ready. Click on **See Your Channel in Slack**, as shown in the following screenshot:

    ![Figure 7.82: Seeing the new Slack channel ](img/C12607_07_82.jpg)

    ###### 图 7.82:查看新的松弛通道

    点击后，我们应该会看到我们的频道如下:

    ![Figure 7.83: Your new Slack channel ](img/C12607_07_83.jpg)

    ###### 图 7.83:您的新松弛通道

6.  Now we are going to add an Incoming Webhook app to our slack. From the left menu, select Add apps under the Apps section:

    ![Figure 7.84: Adding apps under the Apps section ](img/C12607_07_84.jpg)

    ###### 图 7.84:在应用部分下添加应用

7.  Enter **Incoming Webhooks** in the search field and click on **Install** for the Incoming Webhook app:

    ![Figure 7.85: Browsing apps ](img/C12607_07_85.jpg)

    ###### 图 7.85:浏览应用

8.  Click on **Add Configuration**:

    ![Figure 7.86: Adding configuration ](img/C12607_07_86.jpg)

    ###### 图 7.86:添加配置

9.  Click on **Add Incoming WebHooks Integration**:

    ![Figure 7.87: Adding incoming webhooks ](img/C12607_07_87.jpg)

    ###### 图 7.87:添加传入的网络钩子

10.  保存网页挂钩网址。当我们编写 Kube less 函数时，我们将需要这个。
11.  现在，让我们创建函数并部署它。首先，我们需要创建 requirements.txt 文件，它指定了我们需要为函数的运行时安装的依赖项。这些是我们成功运行功能所需的附加模块。我们将使用请求包向 Slack webhook 端点发送 HTTP POST 请求:

    ```
    Requests==2.22.0
    ```

**活动解决方案**

1.  按如下方式创建函数。

    ```
    import json
    import requests
    def main(event, context):
        webhook_url = 'YOUR_INCOMMING_WEBHOOK_URL'
        response = requests.post(
            webhook_url, data=json.dumps(event['data']),
            headers={'Content-Type': 'application/json'}
        )
        if response.status_code == 200:
            return "Your message successfully sent to Slack"
        else:
            return "Error while sending your message to Slack: " + response.get('error')
    ```

2.  Deploy the function:

    ```
    $ kubeless function deploy slack --runtime python3.6 \
                                          --from-file slack.py \
                                          --handler slack.main \
                                          --dependencies requirements.txt
    ```

    部署该函数将产生以下输出:

    ![Figure 7.88: Deploying the function ](img/C12607_07_88.jpg)

    ###### 图 7.88:部署功能

    在部署 slack 函数时，我们将上一步创建的 requirements.txt 文件作为依赖项传递。这将确保 Kubeless 运行时包含函数执行所需的 Python 包。

3.  Invoke the kubeless function:

    ```
    $ kubeless function call slack --data '{"username": "kubeless-bot", "text": "Welcome to Serverless Architectures with Kubeless !!!"}'
    ```

    这将产生以下输出:

    ![Figure 7.89: Invoking the function ](img/C12607_07_89.jpg)

    ###### 图 7.89:调用函数

4.  Go to your Slack workspace and verify that the message was successfully posted to the Slack channel:

    ![Figure 7.90: Verifying whether the message was successfully posted ](img/C12607_07_90.jpg)

###### 图 7.90:验证消息是否成功发布

在本活动中，我们创建了一个 Slack 空间，并创建了一个传入的 webhook。接下来，我们创建并部署了一个无库函数，它可以将消息发布到 Slack 通道。

## 8.ApacheOpen 晶须简介

### 活动 8:通过电子邮件接收每日天气更新

创建开放天气和发送网格帐户的步骤:

1.  Create an **OpenWeather** account at [https://home.openweathermap.org/users/sign_up](https://home.openweathermap.org/users/sign_up):

    ![Figure 8.72: Creating an OpenWeather account ](img/C12607_08_72.jpg)

    ###### 图 8.72:创建一个开放天气账户

2.  Once you have signed up to **OpenWeather**, an API key will be generated automatically for you. Go to the **API keys** tab ([https://home.openweathermap.org/api_keys](https://home.openweathermap.org/api_keys)) and save the API key because this key is required to fetch the data from OpenWeather API:

    ![Figure 8.73: OpenWeather API key ](img/C12607_08_73.jpg)

    ###### 图 8.73:开放天气应用编程接口密钥

3.  Test the **OpenWeather** API using **https://api.openweathermap.org/data/2.5/weather?q=London&appid=<YOUR-API-KEY>** in a web browser. Please note that you need to replace **<YOUR-API-KEY>** with your API Key from step 2:

    #### 注意

    激活应用编程接口密钥可能需要几分钟时间。等待几分钟，如果收到**无效的 API 密钥**，请重试。详情请见[http://openweathermap.org/faq#error401](http://openweathermap.org/faq#error401)。调用网址时出错。

    ![Figure 8.74: Invoking OpenWeather API ](img/C12607_08_74.jpg)

    ###### 图 8.74:调用开放天气应用编程接口

4.  Create a **SendGrid** account at [https://signup.sendgrid.com/](https://signup.sendgrid.com/).

    它应该如下所示:

    ![Figure 8.75: Creating a SendGrid account ](img/C12607_08_75.jpg)

    ###### 图 8.75:创建一个发送网格帐户

5.  Go to **Settings** > **API Keys** and click on the **Create API Key** button:

    ![Figure 8.76: API key page in SendGrid ](img/C12607_08_76.jpg)

    ###### 图 8.76:发送网格中的应用编程接口关键页

6.  Provide a name in the **API Key Name** field, select the **Full Access** radio button, and click on the **Create & View** button to create an API key with full access:

    ![Figure 8.77: Generating an API key in SendGrid ](img/C12607_08_77.jpg)

    ###### 图 8.77:在发送网格中生成应用编程接口密钥

7.  Once the key is generated, copy the API key and save it somewhere safe because you will see this key only once:

    ![Figure 8.78: Generated API key in SendGrid  ](img/C12607_08_78.jpg)

###### 图 8.78:在发送网格中生成的应用编程接口密钥

**活动解决方案**

1.  使用*步骤 3* 中提供的功能代码创建 **get-weather.js** 功能。将**<OPEN _ WEATHER _ API _ KEY>**替换为*步骤 1* 中保存的 API 密钥。
2.  Create the action named **getWeather** with the **get-weather.js** function created in the preceding step and provide the default value of the **cityName** parameter as **London**:

    ```
    $ wsk action create getWeather get-weather.js --param cityName London
    ```

    输出应如下所示:

    ![Figure 8.79: Creating the getWeather action  ](img/C12607_08_79.jpg)

    ###### 图 8.79:创建 getWeather 操作

3.  Verify that the action is working as expected by invoking the action:

    ```
    $ wsk action invoke getWeather --result
    ```

    ![Figure 8.80: Invoking the getWeather action ](img/C12607_08_80.jpg)

    ###### 图 8.80:调用 getWeather 操作

4.  Now we can create the action to send emails (we will be using the API key generated with SendGrid). We will be using the **sendgrid** module for this function. First, we need to create a directory to store the function code and the dependencies:

    ```
    $ mkdir send-email
    $ cd send-email
    ```

    输出应如下所示:

    ![Figure 8.81: Creating the send-mail directory ](img/C12607_08_81.jpg)

    ###### 图 8.81:创建发送邮件目录

5.  Run the **npm init** command by accepting the default parameters:

    ```
    $ npm init
    ```

    输出应如下所示:

    ![Figure 8.82: npm init ](img/C12607_08_82.jpg)

    ###### 图 8.82: npm init

6.  Install the **sendgrid** **npm** package, which is required for the function:

    ```
    $ npm install sendgrid -save
    ```

    输出应如下所示:

    ![Figure 8.83: Adding the sendgrid dependency package ](img/C12607_08_83.jpg)

    ###### 图 8.83:添加 sendgrid 依赖包

7.  使用*步骤 4* 中提供的功能代码创建 **index.js** 文件。将 **<发送 _ 网格 _ 应用编程接口 _ 密钥>** 替换为密钥，该密钥是在创建发送网格帐户时保存的。同样，替换 **< TO_EMAIL >** 接收天气数据，替换 **< FROM_EMAIL >** 用你的邮箱地址发送天气数据。
8.  用所有依赖项压缩代码:

    ```
    $ zip -r send-email.zip *
    ```

9.  Now we can create an action named **sendEmail** using **send-email.zip**:

    ```
    $ wsk action create sendEmail send-email.zip --kind nodejs:default
    ```

    输出应如下所示:

    ![Figure 8.84: Creating the sendEmail action ](img/C12607_08_84.jpg)

    ###### 图 8.84:创建发送电子邮件操作

10.  Verify that the **sendEmail** action is working as expected:

    #### 注意

    请务必检查您的垃圾邮件文件夹，因为电子邮件客户端可能已将其归类为垃圾邮件。

    ```
    $ wsk action invoke sendEmail --param message "Test Message" –result
    ```

    输出应如下所示:

    ![Figure 8.85: Invoking the sendEmail action ](img/C12607_08_85.jpg)

    ###### 图 8.85:调用发送电子邮件操作

11.  使用*步骤 5* 中提供的功能代码创建**格式-天气-数据. js** 功能。
12.  Create the action named **formatWeatherData** with the **format-weather-data.js** function created in the preceding step:

    ```
    $ wsk action create formatWeatherData format-weather-data.js
    ```

    输出应如下所示:

    ![Figure 8.86: Creating the formatWeatherData action ](img/C12607_08_86.jpg)

    ###### 图 8.86:创建格式化天气数据动作

13.  Create a sequence named **weatherMailSender** by combining the **getWeather**, **formatWeatherData**, and **sendEmail** actions:

    ```
    $ wsk action create weatherMailSender --sequence getWeather,formatWeatherData,sendEmail
    ```

    输出应如下所示:

    ![Figure 8.87: Creating the weatherMailSender action sequence ](img/C12607_08_87.jpg)

    ###### 图 8.87:创建天气邮件发送者动作序列

14.  Invoke the **weatherMailSender** sequence:

    ```
    $ wsk action invoke weatherMailSender --result
    ```

    输出应如下所示:

    ![Figure 8.88: Invoking the weatherMailSender action sequence ](img/C12607_08_88.jpg)

    ###### 图 8.88:调用天气邮件发送者动作序列

15.  Check the mail account that you added as **<TO_EMAIL>** (check the spam folder). Check the status of email delivery at [https://app.sendgrid.com/email_activity](https://app.sendgrid.com/email_activity).

    输出应如下所示:

    ![Figure 8.89: Received email from the weatherMailSender action sequence ](img/C12607_08_89.jpg)

    ###### 图 8.89:从天气邮件发送者收到的电子邮件动作序列

16.  最后，我们需要创建触发器和规则来调用每天上午 8 点的序列。首先，我们将创建**天气邮件发送器触发程序**，该程序将在每天上午 8:00:

    ```
    $ wsk trigger create weatherMailSenderCronTrigger \
                                 --feed /whisk.system/alarms/alarm \
                                 --param cron "0 8 * * *" 
    ok: invoked /whisk.system/alarms/alarm with id cf1af9989a7a46a29af9989a7ad6a28c
    {
        "activationId": "cf1af9989a7a46a29af9989a7ad6a28c",
        "annotations": [
            {
                "key": "path",
                "value": "whisk.system/alarms/alarm"
            },
            {
                "key": "waitTime",
                "value": 66
            },
            {
                "key": "kind",
                "value": "nodejs:10"
            },
            {
                "key": "timeout",
                "value": false
            },
            {
                "key": "limits",
                "value": {
                    "concurrency": 1,
                    "logs": 10,
                    "memory": 256,
                    "timeout": 60000
                }
            }
        ],
        "duration": 162,
        "end": 1565457634929,
        "logs": [],
        "name": "alarm",
        "namespace": "sathsara89@gmail.com_dev",
        "publish": false,
        "response": {
            "result": {
                "status": "success"
            },
            "status": "success",
            "success": true
        },
        "start": 1565457634767,
        "subject": "sathsara89@gmail.com",
        "version": "0.0.152"
    }
    ok: created trigger weatherMailSenderCronTrigger
    ```

    触发
17.  Then, we will create a rule named **weatherMailSenderCronRule** to connect the trigger (**weatherMailSenderCronTrigger**) and action (**weatherMailSender**):

    ```
    $ wsk rule create weatherMailSenderCronRule weatherMailSenderCronTrigger weatherMailSender
    ```

    输出应如下所示:

    ![Figure 8.90: Creating weatherMailSenderCronRule ](img/C12607_08_90.jpg)

###### 图 8.90:创建天气邮件发送循环规则

完成上述步骤后，您应该会在每天上午 8 点收到一封电子邮件，发送到指定的电子邮件地址，其中包含所请求城市的天气数据。

## 9.使用 OpenFaaS 实现无服务器

### 活动 9: OpenFaaS 表单处理器

**解决方案**

1.  首先，您需要创建一个发送网格帐户并生成一个应用编程接口密钥。您可以使用在活动*第 08 章，Apacheopen 晶须简介*中创建的相同 API 密钥。请参考*第 08 章“Apache OpenWhisk 简介”*活动中的步骤 4-7，了解如何创建发送网格帐户和生成应用编程接口密钥。
2.  Create an OpenFaaS function named contact-form using the python3 template. This will be the frontend of the contact form:

    ```
    $ faas-cli new contact-form --lang=python3
    ```

    输出应如下所示:

    ![Figure 9.59: Creating the contact-form function ](img/C12607_09_591.jpg)

    ###### 图 9.59:创建联系人表单功能

3.  Create a new directory named html inside the contact-form directory to store the HTML files:

    ```
    $ mkdir contact-form/html
    ```

    输出应如下所示:

    ![Figure 9.60: Creating the HTML folder ](img/C12607_09_601.jpg)

    ###### 图 9.60:创建 HTML 文件夹

4.  使用步骤 2 中提供的代码在联系人表单/html 文件夹中创建 contact-us.html 文件。
5.  更新联系人表单文件夹中的**处理程序. py** Python 文件。该 Python 函数将读取**contact-us.html**文件的内容，并将其作为函数响应返回:

    ```
    import os

    def handle(req):
        current_directory = os.path.dirname(__file__)
        html_file_path = os.path.join(current_directory, 'html', 'contact-us.html')
        with(open(html_file_path, 'r')) as html_file:
            html = html_file.read()

        return html
    ```

6.  更新函数定义( **contact-form.yml** )文件，将 content_type 指定为 **text/html** ，解释如下代码:

    ```
    version: 1.0
    provider:
      name: openfaas
      gateway: http://192.168.99.100:31112
    functions:
      contact-form:
        lang: python3
        handler: ./contact-form
        image: sathsarasa/contact-form:latest
        environment:
          content_type: text/html
    ```

7.  Build, push, and deploy the contact-form function:

    ```
    $  faas-cli up -f contact-form.yml
    ```

    该命令的输出应该如下:

    ```
    [0] > Building contact-form.
    Clearing temporary build folder: ./build/contact-form/
    Preparing ./contact-form/ ./build/contact-form//function
    Building: sathsarasa/contact-form:latest with python3 template. Please wait..
    Sending build context to Docker daemon  14.34kB
    ...
    Successfully built 6c008c91f0bb
    Successfully tagged sathsarasa/contact-form:latest
    Image: sathsarasa/contact-form:latest built.
    [0] < Building contact-form done.
    [0] worker done.
    [0] > Pushing contact-form [sathsarasa/contact-form:latest].
    The push refers to repository [docker.io/sathsarasa/contact-form]
    ...
    latest: digest: sha256:b4f0a4f474af0755b53acb6a1c0ce26e0f91a9a893bb8bfc78501cab267d823e size: 4282
    [0] < Pushing contact-form [sathsarasa/contact-form:latest] done.
    [0] worker done.
    Deploying: contact-form.
    WARNING! Communication is not secure, please consider using HTTPS. Letsencrypt.org offers free SSL/TLS certificates.
    Deployed. 202 Accepted.
    URL: http://192.168.99.100:31112/function/contact-form
    ```

8.  Create the second OpenFaaS function named form-processor using the python3 template. This will be the backend of the contact form:

    ```
    $ faas-cli new form-processor --lang=python3
    ```

    输出应如下所示:

    ![Figure 9.61: Creating the form-processor function ](img/C12607_09_61.jpg)

    ###### 图 9.61:创建表单处理函数

9.  更新表单处理器文件夹中的**处理程序. py** Python 文件。这个 Python 函数执行接收输入到“联系我们”表单中的电子邮件、姓名和消息参数，格式化要发送的电子邮件正文，使用 SendGrid 发送电子邮件，并将电子邮件发送状态作为函数响应返回。
10.  将<send_grid_api_key>替换为步骤 1 中保存的发送网格应用编程接口密钥，将<to_email>替换为接收联系我们表单数据的电子邮件地址:

    ```
         import json
    from sendgrid import SendGridAPIClient
    from sendgrid.helpers.mail import Mail
    def handle(req):

        SENDGRID_API_KEY = '<SEND_GRID_API_KEY>'
        TO_EMAIL = '<TO_EMAIL>'
        EMAIL_SUBJECT = 'New Message from OpenFaaS Contact Form'

        json_req = json.loads(req)
        email = json_req["email"]
        name = json_req["name"]
        message = json_req["message"]
        email_body = '<strong>Name: </strong>' + name + '<br><br> <strong>Email: </strong>' + email + '<br><br> <strong>Message: </strong>' + message

        email_object = Mail(
            from_email= email,
            to_emails=TO_EMAIL,
            subject=EMAIL_SUBJECT,
            html_content=email_body)

        try:
            sg = SendGridAPIClient(SENDGRID_API_KEY)
            response = sg.send(email_object)
            sendingStatus = "Message sent successfully"
        except Exception as e:
            sendingStatus = "Message sending failed"

        return sendingStatus
    ```</to_email></send_grid_api_key> 
11.  在表单处理器函数的表单处理器/requirements.txt 中添加 sendgrid 模块作为依赖项:

    ```
    sendgrid
    ```

12.  在 form-processor.yml 中增加超时(read_timeout、write_timeout 和 exec_timeout)值，如以下代码所示:

    ```
    version: 1.0
    provider:
      name: openfaas
      gateway: http://192.168.99.100:31112
    functions:
      form-processor:
        lang: python3
        handler: ./form-processor
        image: sathsarasa/form-processor:latest
        environment:
          read_timeout: 20
          write_timeout: 20
          exec_timeout: 20
    ```

13.  Build, deploy, and push the form-processor function:

    ```
    $  faas-cli up -f form-processor.yml
    ```

    该命令的输出应该如下:

    ```
    [0] > Building form-processor.
    Clearing temporary build folder: ./build/form-processor/
    Preparing ./form-processor/ ./build/form-processor//function
    Building: sathsarasa/form-processor:latest with python3 template. Please wait..
    Sending build context to Docker daemon  10.24kB
    ...
    Successfully built 128245656019
    Successfully tagged sathsarasa/form-processor:latest
    Image: sathsarasa/form-processor:latest built.
    [0] < Building form-processor done.
    [0] worker done.
    [0] > Pushing form-processor [sathsarasa/form-processor:latest].
    The push refers to repository [docker.io/sathsarasa/form-processor]
    ...
    latest: digest: sha256:c700592a3a7f16875c2895dbfa41bd269631780d9195290141c245bec93a2257 size: 4286
    [0] < Pushing form-processor [sathsarasa/form-processor:latest] done.
    [0] worker done.
    Deploying: form-processor.
    WARNING! Communication is not secure, please consider using HTTPS. Letsencrypt.org offers free SSL/TLS certificates.
    Deployed. 202 Accepted.
    URL: http://192.168.99.100:31112/function/form-processor
    ```

14.  Open the **Contact Us** form by opening the URL in a web browser:

    **http://192 . 168 . 99 . 100:31112/功能/联系人-表单**

    联系人表单应如下所示:

    ![Figure 9.62: Invoking the Contact Us form ](img/C12607_09_62.jpg)

    ###### 图 9.62:调用联系我们表单

15.  Fill in the form and then submit the form, as shown in the following figure:

    ![Figure 9.63: Submitting the contact us form ](img/C12607_09_63.jpg)

    ###### 图 9.63:提交联系我们表单

16.  检查您在步骤 9 中提供的电子邮件帐户 **< TO_EMAIL >** 以验证电子邮件的发送:

![Figure 9.64: Verifying email delivery ](img/C12607_09_64.jpg)

###### 图 9.64:验证电子邮件传递