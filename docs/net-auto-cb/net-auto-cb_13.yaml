- en: Advanced Techniques and Best Practices for Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible的高级技术和最佳实践
- en: In this chapter, we will explore some advanced features and techniques that
    we can use in Ansible, along with some best practices, in order to build clearer
    and more robust Ansible playbooks for network automation. All of these techniques
    can be used with all the code from the previous chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些高级功能和技术，以及一些最佳实践，以便为网络自动化构建更清晰和更健壮的Ansible playbooks。所有这些技术都可以与前几章的所有代码一起使用。
- en: 'The recipes covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的教程如下：
- en: Installing Ansible in a virtual environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚拟环境中安装Ansible
- en: Validating YAML and Ansible playbooks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证YAML和Ansible playbooks
- en: Calculating the execution time for Ansible playbooks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算Ansible playbooks的执行时间
- en: Validating user input using Ansible
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible验证用户输入
- en: Running Ansible in `check` mode
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`check`模式运行Ansible
- en: Controlling parallelism and rolling updates in Ansible
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制Ansible中的并行性和滚动更新
- en: Configuring fact caching in Ansible
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Ansible中的事实缓存
- en: Creating custom Python filters for Ansible
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Ansible创建自定义Python过滤器
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code that we describe in this chapter can be found through this URL: [https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch13_ansible_best_practice](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch13_ansible_best_practice).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中描述的所有代码都可以通过以下URL找到：[https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch13_ansible_best_practice](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch13_ansible_best_practice)。
- en: 'You will need the following for this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下内容：
- en: Ansible machine running CentOS 7
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行CentOS 7的Ansible机器
- en: Ansible 2.9
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 2.9
- en: Python 3.6.8
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.6.8
- en: Installing Ansible in a virtual environment
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在虚拟环境中安装Ansible
- en: In this recipe, we will outline how to install Ansible in a Python virtual environment
    in order to have an isolated and contained environment for developing and running
    our playbooks.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将概述如何在Python虚拟环境中安装Ansible，以便为开发和运行我们的playbooks提供一个隔离和封闭的环境。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Python 3 must be already installed on your Linux machine.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3必须已经安装在您的Linux机器上。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: 'Create a new Python virtual environment called `dev`, and activate it as follows:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`dev`的新Python虚拟环境，并激活它如下：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Install Ansible in this new virtual environment, as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新的虚拟环境中安装Ansible，操作如下：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As outlined in the first chapter of this book, we can install Ansible using
    one of these two methods:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书第一章所述，我们可以使用以下两种方法之一安装Ansible：
- en: Using the package manager on our Linux machine
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的Linux机器上使用软件包管理器
- en: Using the Python PIP package manager
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python PIP软件包管理器
- en: In both these options, we are running Ansible using system-level Python. This
    means that when we install any other packages or scripts required for our automation,
    such as **Amazon Web Services** (**AWS**) or Azure packages, we are installing/upgrading
    these packages on the system level. In some cases, we might install a package
    that conflicts with an existing package on our system, and it might impact other
    scripts. Python virtual environments are mainly built for this use case. The virtual
    environment provides an isolated runtime environment where we install our Python
    packages totally separately from the system-level packages. Thus, we can run different
    versions of the same package (Ansible, for example) in a totally isolated and
    independent manner.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种选项中，我们都是使用系统级Python运行Ansible。这意味着当我们安装任何其他包或脚本（例如**亚马逊网络服务**（**AWS**）或Azure包）时，我们是在系统级别安装/升级这些包。在某些情况下，我们可能安装与系统上现有包冲突的包，这可能会影响其他脚本。Python虚拟环境主要是为这种情况构建的。虚拟环境提供了一个隔离的运行时环境，我们可以在其中完全独立于系统级别包安装我们的Python包。因此，我们可以以完全隔离和独立的方式运行同一包的不同版本（例如Ansible）。
- en: In this recipe, we outline how to create a new Python virtual environment using
    the `venv` Python module. We use the `python` command with the `-m` option to
    invoke the `venv` module, which allows us to create a new virtual environment.
    We use the `venv` Python module to create a new virtual environment called `dev`,
    which will create the `dev` folder to house our new virtual environment.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们概述了如何使用`venv` Python模块创建一个新的Python虚拟环境。我们使用`python`命令和`-m`选项来调用`venv`模块，这允许我们创建一个新的虚拟环境。我们使用`venv`
    Python模块创建一个名为`dev`的新虚拟环境，它将创建`dev`文件夹来容纳我们的新虚拟环境。
- en: 'In order to start using this new virtual environment, we need to activate it.
    We use the `source` command to run the activate script located in the `dev` folder
    (`~/dev/bin/activate`). This script will activate the virtual environment and
    will place us inside this newly created environment. We can verify that our current
    Python executable is located within this new environment and not related to system-level
    Python, as shown in the following code snippet:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始使用这个新的虚拟环境，我们需要激活它。我们使用`source`命令来运行位于`dev`文件夹（`~/dev/bin/activate`）中的激活脚本。这个脚本将激活虚拟环境，并将我们放在这个新创建的环境中。我们可以验证我们当前的Python可执行文件位于这个新环境中，而不是与系统级Python相关联，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once we are inside our virtual environment, we use the `python-pip` command
    in order to install Ansible within our virtual environment. We can verify that
    Ansible is installed and is using our new virtual environment as shown in the
    following code block:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进入虚拟环境，我们使用`python-pip`命令来在虚拟环境中安装Ansible。我们可以验证Ansible已安装并且正在使用我们的新虚拟环境，如下面的代码块所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this stage, we have installed Ansible in this virtual environment. However,
    by default, when Ansible is run, it will try to use the system-level Python located
    in `/usr/bin/python`. In order to override this behavior and force Ansible to
    use our new virtual environment, we need to set a variable for all our hosts to
    use this new virtual environment, which we can do in our inventory file, as shown
    in the following code snippet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经在这个虚拟环境中安装了Ansible。但是，默认情况下，当运行Ansible时，它将尝试使用位于`/usr/bin/python`的系统级Python。为了覆盖这种行为并强制Ansible使用我们的新虚拟环境，我们需要为所有主机设置一个变量以使用这个新虚拟环境，我们可以在清单文件中进行设置，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Validating YAML and Ansible playbooks
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证YAML和Ansible playbooks
- en: In this recipe, we will outline how to validate YAML files and Ansible playbooks
    using the `Yamllint` and `ansible-lint` tools, in order to make sure that our
    YAML documents are valid with the correct syntax, as well as validating our Ansible
    playbooks.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将概述如何使用`Yamllint`和`ansible-lint`工具来验证YAML文件和Ansible playbooks，以确保我们的YAML文档具有正确的语法，并验证我们的Ansible
    playbooks。
- en: Getting ready
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Python and PIP package manager must be already installed on your Linux machine,
    and Ansible must also be installed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python和PIP软件包管理器必须已经安装在您的Linux机器上，并且还必须安装Ansible。
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Install `yamllint`, as shown in the following code snippet:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`yamllint`，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Install `ansible-lint`, as shown in the following code snippet:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`ansible-lint`，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Change to the directory of your Ansible project, as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到您的Ansible项目目录，如下所示：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run `yamllint`, as shown in the following code snippet:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`yamllint`，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run `ansible-lint`, as shown in the following code snippet:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ansible-lint`，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We use YAML documents to declare our network topology and the different parameters
    that we need in order to run our playbooks or generate the configuration for our
    devices. Since we are going to edit these files regularly to update our network
    topology and add new services, we need to ensure that all the changes to these
    files are validated and that the syntax of these files is correct before we import/use
    these files in our playbooks. One of the most used tools to validate YAML files
    is the `Yamllint` program, which reads YAML documents and analyzes them for syntax
    errors and best practice formats, outputting the result of the analysis. We install
    this tool using the PIP package manager.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用YAML文档来声明我们的网络拓扑和我们运行playbooks或生成设备配置所需的不同参数。由于我们将定期编辑这些文件以更新我们的网络拓扑并添加新服务，我们需要确保这些文件的所有更改都经过验证，并且这些文件的语法在我们在playbooks中导入/使用这些文件之前是正确的。验证YAML文件最常用的工具之一是`Yamllint`程序，它读取YAML文档并分析其语法错误和最佳实践格式，输出分析结果。我们使用PIP软件包管理器安装这个工具。
- en: 'In our example, we have a typical Ansible project, with the directory structure
    shown in the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们有一个典型的Ansible项目，目录结构如下截图所示：
- en: '![](assets/7c6ec20a-2d7c-4ff1-93ec-7ebb2fb2489b.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7c6ec20a-2d7c-4ff1-93ec-7ebb2fb2489b.png)'
- en: 'We analyze all the YAML documents in this folder by running `Yamllint`, as
    outlined in the preceding section. The following screenshot outlines the output
    of the `Yamllint` command on the Ansible project folder:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过运行`Yamllint`来分析此文件夹中的所有YAML文档，如前一节所述。下面的截图概述了`Yamllint`命令在Ansible项目文件夹上的输出：
- en: '![](assets/bce85647-9bf4-44d9-97c6-1b49b0229e25.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bce85647-9bf4-44d9-97c6-1b49b0229e25.png)'
- en: The preceding output outlines the problems that the `Yamllint` command found
    in all the YAML files in this folder, and it provides a very clear output regarding
    the problems identified in each file. These problems can be identified as errors
    or warnings, and this affects the return code for the `Yamllint` command.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出概述了`Yamllint`命令在此文件夹中所有YAML文件中发现的问题，并提供了关于每个文件中识别的问题的非常清晰的输出。这些问题可以被标识为错误或警告，这会影响`Yamllint`命令的返回代码。
- en: 'So, in cases where all the problems in the files are designated as a `warning`,
    the return code is `0`, which means that the YAML documents are valid. However,
    they have some minor problems that should be fixed:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在所有文件中的问题都被标识为`warning`的情况下，返回代码是`0`，这意味着YAML文档是有效的。但是，它们有一些小问题需要修复：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If the problems are identified as an `error`, the return code is not `0`, which
    means that the YAML document has a major problem that needs to be fixed:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题被标识为`error`，返回代码不是`0`，这意味着YAML文档有一个需要修复的重大问题：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The return code is critical since it signifies whether the `Yamllint` command
    was successful or not, and this is critical in building **continuous integration/continuous
    deployment** (**CI/CD**) pipelines to automate the provisioning of the infrastructure.
    One of the steps in the pipeline will be to lint all YAML files in order to make
    sure that the files are correct, and if the `Yamllint` command succeeds, it will
    have a return code of `0`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 返回代码至关重要，因为它表示`Yamllint`命令是否成功，这在构建**持续集成/持续部署**（**CI/CD**）流水线以自动化基础设施的配置非常重要。流水线中的一个步骤将是对所有YAML文件进行lint以确保文件正确，如果`Yamllint`命令成功，它将返回代码`0`。
- en: The `Yamllint` command catches all the syntax errors in the YAML documents.
    However, `ansible-lint` provides a more comprehensive check on the `ansible-playbook`
    code specifically and verifies that the playbook adheres to good coding practices.
    It is very useful to run since it can be used to validate the correct style for
    playbooks and Ansible roles, and will prompt for any problem in the playbooks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Yamllint`命令捕获了YAML文档中的所有语法错误。然而，`ansible-lint`提供了对`ansible-playbook`代码的更全面检查，特别是验证playbook是否遵循良好的编码实践。运行它非常有用，因为它可以用来验证playbooks和Ansible角色的正确样式，并会提示playbooks中的任何问题。'
- en: 'When we run the `ansible-lint` command for our playbook, we can see that it
    catches the following error:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为我们的playbook运行`ansible-lint`命令时，我们可以看到它捕获了以下错误：
- en: '![](assets/1aa2d0ae-8d09-4ca6-b21d-32f3c6308b7e.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1aa2d0ae-8d09-4ca6-b21d-32f3c6308b7e.png)'
- en: The output is very descriptive as it outlines that the task at line `7` within
    the playbook doesn't have a name, and this doesn't adhere to Ansible best practices.
    The return code for the command is `2`, and this signals that the command has
    failed. Once we correct this problem, there will be no errors displayed, and the
    return code will be `0`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出非常详细，因为它概述了playbook中第`7`行的任务没有名称，这不符合Ansible最佳实践。命令的返回代码为`2`，这表明命令失败了。一旦我们纠正了这个问题，就不会显示任何错误，并且返回代码将为`0`。
- en: There's more...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Yamllint` program can be customized by including a `yamllint` file within
    the project directory structure that includes the rules that need to be modified.
    So, in our example, when we run the `yamllint` command, we can see that one of
    the problems outlined is that the line length is `> 80` characters, and this is
    an error as per the default rules with which `yamllint` complies:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Yamllint`程序可以通过在项目目录结构中包含一个`yamllint`文件来进行自定义，该文件包括需要修改的规则。因此，在我们的示例中，当我们运行`yamllint`命令时，我们可以看到其中一个问题是行长度超过了`>
    80`个字符，这是一个错误，因为这是`yamllint`遵循的默认规则：'
- en: '![](assets/cb9bdefc-b0a3-4c70-9161-aaab7162bab4.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cb9bdefc-b0a3-4c70-9161-aaab7162bab4.png)'
- en: 'We can modify our file and try to change the length of the lines that `yamllint` is
    complaining about, or we can specify that this should not be a problem and only
    a `warning` should be triggered. We use the latter approach, and we create the
    `.yamllint` file inside our directory and add the following rule:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改我们的文件并尝试更改`yamllint`抱怨的行的长度，或者我们可以指定这不应该是一个问题，只应该触发一个`warning`。我们使用后一种方法，并在我们的目录中创建`.yamllint`文件并添加以下规则：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So, when we run the `yamllint` command again on our folder, we can see that
    all the previous messages for line length have changed to warnings:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们再次在我们的文件夹上运行`yamllint`命令时，我们可以看到所有先前的行长度消息已更改为警告：
- en: '![](assets/623c1a50-140f-42c1-a1a8-c206131166f4.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/623c1a50-140f-42c1-a1a8-c206131166f4.png)'
- en: 'For `ansible-lint`, we can check all the current rules that `ansible-lint`
    consults in order to validate a given playbook or role, using the following commands:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ansible-lint`，我们可以使用以下命令检查`ansible-lint`用于验证给定playbook或角色的所有当前规则：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `-L` option will output all the rules and a short description of each of
    these rules.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`-L`选项将输出所有规则和每个规则的简短描述。'
- en: The `-T` option will output all the rules/tags used by `ansible-lint`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`-T`选项将输出`ansible-lint`使用的所有规则/标签。'
- en: 'We can run our `ansible-lint` command to ignore a specific rule/tag, as shown
    in the following code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行我们的`ansible-lint`命令来忽略特定的规则/标签，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will cause `ansible-lint` to ignore all the rules with the `task` tag;
    this way, we can influence which rules are applied by `ansible-lint` to validate
    our playbooks.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致`ansible-lint`忽略所有带有`task`标签的规则；这样，我们可以影响`ansible-lint`应用于验证我们的playbook的规则。
- en: See also...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: For more information regarding `yamllint`, please use the following URL: [https://yamllint.readthedocs.io/en/stable/](https://yamllint.readthedocs.io/en/stable/).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`yamllint`的更多信息，请使用以下网址：[https://yamllint.readthedocs.io/en/stable/](https://yamllint.readthedocs.io/en/stable/)。
- en: For more information regarding the configuration file used by `yamllint` and
    how to customize it, please use the following URL: [https://yamllint.readthedocs.io/en/stable/configuration.html](https://yamllint.readthedocs.io/en/stable/configuration.html).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`yamllint`使用的配置文件以及如何自定义它的更多信息，请使用以下网址：[https://yamllint.readthedocs.io/en/stable/configuration.html](https://yamllint.readthedocs.io/en/stable/configuration.html)。
- en: For more information regarding `ansible-lint`, please use the following URL: [https://docs.ansible.com/ansible-lint/](https://docs.ansible.com/ansible-lint/).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`ansible-lint`的更多信息，请使用以下网址：[https://docs.ansible.com/ansible-lint/](https://docs.ansible.com/ansible-lint/)。
- en: Calculating the execution time for Ansible playbooks
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算Ansible playbook的执行时间
- en: In this recipe, we will outline how to get the time that various tasks within
    an Ansible playbook take to execute. This can help us understand which specific
    task or role is taking the largest portion of time during a playbook run, and
    can help us to optimize our playbooks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将概述如何获取Ansible playbook中各种任务执行所需的时间。这可以帮助我们了解playbook运行期间哪个特定任务或角色占用了最多的时间，并帮助我们优化我们的playbook。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Update the `ansible.cfg` file to include the following line:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`ansible.cfg`文件以包括以下行：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'List all the tasks in the `ansible-playbook` code for reference:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出`ansible-playbook`代码中的所有任务以供参考：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the Ansible playbook:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Ansible playbook：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Ansible provides multiple callback plugins that we can use in order to add
    new behavior to Ansible when responding to events. One of the most useful callback
    plugins is the `timer` plugin; it provides the capability to measure the execution
    time for the tasks and roles within an Ansible playbook. We can enable this functionality
    by whitelisting these plugins in the `ansible.cfg` file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible提供了多个回调插件，我们可以使用这些插件来在响应事件时向Ansible添加新的行为。其中最有用的回调插件之一是`timer`插件；它提供了测量Ansible
    playbook中任务和角色的执行时间的功能。我们可以通过在`ansible.cfg`文件中将这些插件列入白名单来启用此功能：
- en: '`Timer`: This plugin provides a summary of the execution time for the playbook.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Timer`：此插件提供playbook的执行时间摘要。'
- en: '`Profile_tasks`: This provides us with a summary of the execution time of each
    task within a playbook.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Profile_tasks`：这为我们提供了playbook中每个任务的执行时间摘要。'
- en: '`Profile_roles`: This provides us with a summary of the time taken for each
    role within a playbook.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Profile_roles`：这为我们提供了playbook中每个角色所花费的时间的摘要。'
- en: 'We list all the tasks within a playbook using the `--list-tasks` option in
    order to verify all the tasks that will be executed in our playbook. Here is a
    snippet of the tasks within our sample playbook:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`--list-tasks`选项列出playbook中的所有任务，以验证将在我们的playbook中执行的所有任务。以下是我们示例playbook中的任务片段：
- en: '![](assets/deda2ba3-8d06-4987-a2fb-349f73754ab7.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/deda2ba3-8d06-4987-a2fb-349f73754ab7.png)'
- en: 'We then run the playbook and check the newly added detailed execution summary,
    as outlined in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行playbook并检查新添加的详细执行摘要，如下面的屏幕截图所示：
- en: '![](assets/d74a5f8c-d473-402b-adde-92e8afee5ced.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d74a5f8c-d473-402b-adde-92e8afee5ced.png)'
- en: The first part of the summary outlines the execution time for the role (`generate_config`),
    as well as the different modules, using the `post_task` section (we use only the
    `file` and `assemble` modules in the `post_task` section). The next part of the
    summary outlines the execution time for each task within our playbook (including
    a breakdown for tasks within the role). Finally, we get a summary of the overall
    execution time for our playbook as a whole, in a single line.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要的第一部分概述了角色（`generate_config`）的执行时间，以及使用`post_task`部分的不同模块（我们在`post_task`部分仅使用`file`和`assemble`模块）。摘要的下一部分概述了playbook中每个任务的执行时间（包括角色内的任务的细分）。最后，我们得到了整个playbook的总体执行时间的摘要，以一行显示。
- en: See also...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more information regarding callback plugins, `profile_tasks` and `profile_roles`
    plugins, and the `timer`, please consult the following URLs:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有关回调插件、`profile_tasks`和`profile_roles`插件以及`timer`的更多信息，请参考以下网址：
- en: '[https://docs.ansible.com/ansible/latest/plugins/callback/timer.html](https://docs.ansible.com/ansible/latest/plugins/callback/timer.html)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.ansible.com/ansible/latest/plugins/callback/timer.html](https://docs.ansible.com/ansible/latest/plugins/callback/timer.html)'
- en: '[https://docs.ansible.com/ansible/latest/plugins/callback/profile_tasks.html](https://docs.ansible.com/ansible/latest/plugins/callback/profile_tasks.html)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.ansible.com/ansible/latest/plugins/callback/profile_tasks.html](https://docs.ansible.com/ansible/latest/plugins/callback/profile_tasks.html)'
- en: '[https://docs.ansible.com/ansible/latest/plugins/callback/profile_roles.html](https://docs.ansible.com/ansible/latest/plugins/callback/profile_roles.html)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.ansible.com/ansible/latest/plugins/callback/profile_roles.html](https://docs.ansible.com/ansible/latest/plugins/callback/profile_roles.html)'
- en: Validating user input using Ansible
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible验证用户输入
- en: In this recipe, we will outline how to validate input data using Ansible. We
    rely heavily on the information that we either retrieve from the network or declare
    in `host` or `group` variables, in order to execute different tasks in Ansible
    such as generating configuration or provisioning devices. Before we start to use
    this information, we need to be able to validate the structure and validity of
    this data before further processing our playbooks.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将概述如何使用Ansible验证输入数据。我们在Ansible中非常依赖于从网络中检索或在`host`或`group`变量中声明的信息，以便执行不同的任务，比如生成配置或配置设备。在我们开始使用这些信息之前，我们需要能够在进一步处理playbook之前验证这些数据的结构和有效性。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create an `ACLs` definition in `ACLs.yml`, as shown in the following code block:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ACLs.yml`中创建一个`ACLs`定义，如下面的代码块所示：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a new validation task in the `validate_acl.yml` file, as shown in the
    following code block:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`validate_acl.yml`文件中创建一个新的验证任务，如下面的代码块所示：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a new playbook to create **access control lists** (**ACLs**) and push-to-network
    devices, as shown in the following code block:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的playbook来创建**访问控制列表**（**ACLs**）并推送到网络设备，如下面的代码块所示：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example playbook, we want to push ACL configuration to our infrastructure.
    We generate the configuration using the `template` module, and we push the configuration
    using the `iosxr_config` module. All our ACL definition is declared in the `ACLs.yml`
    file. We would like to validate the input data contained within our `ACLs.yml`
    file since this is the data that we rely on in order to generate our configuration.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例playbook中，我们想要将ACL配置推送到我们的基础设施。我们使用`template`模块生成配置，并使用`iosxr_config`模块推送配置。我们所有的ACL定义都在`ACLs.yml`文件中声明。我们希望验证`ACLs.yml`文件中包含的输入数据，因为这是我们依赖的数据，以便生成我们的配置。
- en: 'We create a `validate_acl.yml` `tasks` file that has multiple tasks to validate
    the structure and the content of the data that we will use to generate our configuration.
    We start by importing our data using the `include_vars` parameter and then we
    define two main tasks to validate our data:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`validate_acl.yml`的`tasks`文件，其中包含多个任务来验证我们将用于生成配置的数据的结构和内容。我们首先使用`include_vars`参数导入我们的数据，然后定义两个主要任务来验证我们的数据：
- en: The first task is validating that the required data structure is present and
    that the data structure is in the correct format that we expect.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个任务是验证所需的数据结构是否存在，并且数据结构是否符合我们期望的正确格式。
- en: The second task is validating the contents of each firewall rule.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个任务是验证每个防火墙规则的内容。
- en: In all these validation tasks, we are using the `assert` module in order to
    test and validate our conditional statements and we can define much more comprehensive
    checking on the input data structure to cover all the possibilities for our data.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些验证任务中，我们使用`assert`模块来测试和验证我们的条件语句，并且我们可以定义更全面的检查输入数据结构，以涵盖数据的所有可能性。
- en: Using this approach, we can validate the validity of our input data and make
    sure that our data is sane in order to be processed by subsequent tasks within
    the playbook.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以验证输入数据的有效性，并确保我们的数据是健全的，以便由playbook中的后续任务进行处理。
- en: Running Ansible in check mode
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在检查模式下运行Ansible
- en: In this recipe, we will outline how to run our Ansible playbooks in dry-run
    mode. This mode is also called `check` mode and, in this mode, Ansible will not
    perform any changes on the remotely managed nodes. We can consider this as a simulation
    run for our playbook that will make us understand which changes will be made by
    Ansible, if we execute the playbook in `check` mode.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将概述如何在Ansible中以干运行模式运行我们的playbook。这种模式也称为`check`模式，在这种模式下，Ansible不会对远程管理的节点进行任何更改。我们可以将其视为对我们的playbook进行模拟运行，以便了解Ansible将进行哪些更改，如果我们以`check`模式执行playbook。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Update our ACL declaration in the `ACLs.yml` file with the new entry, as shown
    in the following code snippet:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ACLs.yml`文件中更新我们的ACL声明，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the `pb_push_acl.yml` provision playbook using `check` mode, as shown in
    the following code snippet:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`check`模式运行`pb_push_acl.yml`配置playbook，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'When we run the playbook using the `check` mode, no changes are done on the
    remote systems, and we can see the output from the playbook run, as shown in the
    following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`check`模式运行playbook时，远程系统不会进行任何更改，我们可以看到playbook运行的输出，如下面的截图所示：
- en: '![](assets/f3506f27-3628-4185-9ee6-5384e691d54c.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f3506f27-3628-4185-9ee6-5384e691d54c.png)'
- en: This output outlines that the configuration file we generate for our ACL will
    be changed (a new rule will be added); however, the provision ACLs task is not
    reporting any change. This is because the configuration file didn't change since
    we are running our playbook in `check` mode, so in this case, this task is still
    using the unmodified configuration file, so no changes will be implemented.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出概述了我们为ACL生成的配置文件将发生更改（将添加新规则）；但是，provision ACLs任务没有报告任何更改。这是因为配置文件没有更改，因为我们是在`check`模式下运行playbook，所以在这种情况下，此任务仍在使用未修改的配置文件，因此不会实施任何更改。
- en: 'We can also check the changes that will occur using the `--diff` flag when
    running the playbook, as shown in the following code snippet:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在运行playbook时使用`--diff`标志来检查将发生的更改，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We obtain the following output when we use the `--diff` flag, and it outlines
    the changes that will take place on our configuration file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`--diff`标志时，我们会得到以下输出，并且它概述了将在我们的配置文件上发生的更改：
- en: '![](assets/fab7de8a-ad06-42f7-b1b6-b2b856261527.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fab7de8a-ad06-42f7-b1b6-b2b856261527.png)'
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can use `check` mode as a switch to run or skip tasks. So, in some cases
    when we are running in `check` mode, we would not like to connect to the device
    and push any configuration on the device, since nothing will be changed. Using
    `check` mode, we can build our playbooks to skip these tasks, as shown in the
    following code block:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`check`模式作为开关来运行或跳过任务。因此，在某些情况下，当我们以`check`模式运行时，我们不希望连接到设备并在设备上推送任何配置，因为不会有任何更改。使用`check`模式，我们可以构建我们的playbook以跳过这些任务，如下面的代码块所示：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In our `tasks`, we added the `when` directive, and we are checking the value
    for the `ansible_check_mode` parameter. This parameter is set to `true` when we
    run our playbook in `check` mode. Thus, on each task, we are checking whether
    the `check` mode is set, and, if so, we will skip these tasks during the playbook
    run. If the playbook is run in normal mode (without `check` mode), these tasks
    will be executed normally.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`tasks`中，我们添加了`when`指令，并且我们正在检查`ansible_check_mode`参数的值。当我们在`check`模式下运行playbook时，此参数设置为`true`。因此，在每个任务中，我们都在检查`check`模式是否设置，如果是，我们将在playbook运行期间跳过这些任务。如果playbook以正常模式运行（不使用`check`模式），这些任务将正常执行。
- en: See also...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: For more information regarding running our playbooks in `check` mode, please
    consult the following URL: [https://docs.ansible.com/ansible/latest/user_guide/playbooks_checkmode.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_checkmode.html).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在`check`模式下运行我们的playbook的更多信息，请参阅以下网址：[https://docs.ansible.com/ansible/latest/user_guide/playbooks_checkmode.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_checkmode.html)。
- en: Controlling parallelism and rolling updates in Ansible
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Ansible中控制并行性和滚动更新
- en: By default, Ansible runs tasks in parallel. In this recipe, we will outline
    how to control the parallel execution of Ansible and how we can modify this default
    behavior. We will also explore the concept of rolling updates and how to utilize
    them in Ansible.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible会并行运行任务。在本教程中，我们将概述如何控制Ansible的并行执行以及如何修改此默认行为。我们还将探讨滚动更新的概念以及如何在Ansible中利用它们。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Update the `ansible.cfg` file to control parallel execution, as shown in the
    following code snippet:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`ansible.cfg`文件以控制并行执行，如下面的代码片段所示：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Update the `pb_push_acl.yml` file to set up rolling updates for the configuration
    push on the network devices, as shown in the following code block:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`pb_push_acl.yml`文件以设置网络设备上配置推送的滚动更新，如下面的代码块所示：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Ansible, by default, works by executing each task across all the devices identified
    in a playbook in parallel. By default, for each task, Ansible will fork five parallel
    threads (called forks) and execute these threads in parallel across five nodes
    in the inventory. Once these tasks finish, it will target the remaining devices
    in the inventory in a batch of five nodes. It performs this on each task executed
    in the playbook. Using the `forks` keyword in the `ansible.cfg` file, we can modify
    the default `fork` value that Ansible is using and control the number of parallel
    nodes that Ansible targets during each task execution. This can speed up our playbook
    execution; however, it requires more resources in terms of memory and CPU power
    on the Ansible control node.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible通过并行在所有在playbook中标识的设备上执行每个任务来工作。默认情况下，对于每个任务，Ansible将分叉五个并行线程（称为forks）并在清单中的五个节点上并行执行这些线程。一旦这些任务完成，它将以五个节点的批次目标剩余的设备清单。它在playbook中执行的每个任务上执行此操作。使用`ansible.cfg`文件中的`forks`关键字，我们可以修改Ansible正在使用的默认`fork`值并控制Ansible在每个任务执行期间目标的并行节点数。这可以加快我们的playbook执行速度；但是，它需要更多的资源，包括内存和CPU功率在Ansible控制节点上。
- en: When using a large number of forks, be advised that any `local_action` steps
    can fork a Python interpreter on your local machine, so you may wish to keep `local_action`
    or `delegated` steps limited in number or in separate plays. For further information,
    see [https://www.ansible.com/blog/ansible-performance-tuning](https://www.ansible.com/blog/ansible-performance-tuning).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用大量的forks时，请注意任何`local_action`步骤可能会在本地机器上分叉Python解释器，因此您可能希望限制`local_action`或`delegated`步骤的数量或在单独的plays中。有关更多信息，请参阅[https://www.ansible.com/blog/ansible-performance-tuning](https://www.ansible.com/blog/ansible-performance-tuning)。
- en: The other option that we can modify to control playbook execution is that, by
    default, Ansible runs each task across all nodes identified in the playbook, and
    it will only step from one task to the other once all the nodes have completed
    the previous task. We might want to modify this behavior in multiple situations,
    such as pushing the configuration to network devices or upgrading network devices.
    We might want to execute a playbook on each node in a serial fashion—this means
    that each node (or group of nodes) is picked up by Ansible and the playbook is
    executed on it; once this batch is finished, another batch is selected, and the
    playbook is run again. This approach allows us to deploy our changes in a rolling
    manner, and if one of our nodes has failed, we can stop the playbook execution.
    This configuration is controlled using the `serial` keyword in the playbook. It
    instructs Ansible to start the play with the number of hosts identified by the
    `serial` option, executes the whole tasks on this batch, then rolls over and selects
    another batch, and executes the complete playbook on that batch, and so on.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改的另一个选项来控制playbook执行是，默认情况下，Ansible在playbook中标识的所有节点上运行每个任务，并且只有在所有节点完成前一个任务后才会从一个任务转到另一个任务。我们可能希望在多种情况下修改这种行为，比如将配置推送到网络设备或升级网络设备。我们可能希望以串行方式在每个节点上执行playbook
    - 这意味着Ansible会选择每个节点（或节点组），并在其上执行playbook；一旦这一批完成，就会选择另一批，并再次运行playbook。这种方法允许我们以滚动方式部署更改，如果我们的某个节点失败，我们可以停止playbook执行。这个配置是使用playbook中的`serial`关键字来控制的。它指示Ansible使用`serial`选项标识的主机数量开始执行play，然后在这一批上执行所有任务，然后转到另一批，并在该批上执行完整的playbook，依此类推。
- en: See also...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: For more information about Ansible forks and rolling updates, please consult
    the following URL: [https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Ansible forks和滚动更新的更多信息，请参考以下网址：[https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html)。
- en: Configuring fact caching in Ansible
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Ansible中配置事实缓存
- en: In this recipe, we will outline how to set up and configure fact caching in
    Ansible. This is an important feature that can help us in optimizing and speeding
    the execution time of our playbooks when we require facts to be collected from
    our infrastructure.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将概述如何在Ansible中设置和配置事实缓存。这是一个重要的功能，可以帮助我们在需要从基础架构收集事实时优化和加快playbook的执行时间。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Update the `ansible.cfg` file to enable fact caching, and set up the required
    folder to store the cache:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`ansible.cfg`文件以启用事实缓存，并设置所需的文件夹来存储缓存：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a new `pb_get_facts.yml` playbook to collect facts from the network
    using different approaches:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`pb_get_facts.yml` playbook，使用不同的方法从网络收集事实：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the new Ansible playbook on a single node from our inventory:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在清单中的单个节点上运行新的Ansible playbook：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Ansible is a powerful tool to collect information about the operational state
    of our infrastructure, and we can use this information in generating configuration,
    building reports, and also to validate the state of our infrastructure. In cases
    where the state of our infrastructure is highly stable, we might not need to collect
    the network facts from our devices during every playbook run. In these cases,
    we might opt to use fact caching in order to speed up the execution of our playbooks.
    We read the facts (network state) of our devices from a stored location on the
    Ansible control node, instead of connecting to the devices and collecting the
    information from the live network.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个强大的工具，可以收集有关基础架构操作状态的信息，并且我们可以使用这些信息来生成配置、构建报告，以及验证基础架构的状态。在基础架构状态非常稳定的情况下，我们可能不需要在每次playbook运行期间从设备收集网络事实。在这些情况下，我们可能选择使用事实缓存来加快playbook的执行。我们从Ansible控制节点上存储的位置读取设备的事实（网络状态），而不是连接到设备并从实时网络中收集信息。
- en: Fact caching is enabled in the `ansible.cfg` file, and in this file, we also
    set the backend type that we will use to store the fact data. There are multiple
    options, ranging from YAML or JSON files to storing this data into `redis` or
    `Memcached` databases. In our example, for simplicity, we will use YAML files
    to store the facts collected from the devices. We also specify the folder location
    to store this information.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ansible.cfg`文件中启用事实缓存，并在该文件中设置我们将用于存储事实数据的后端类型。有多种选项，从YAML或JSON文件到将这些数据存储到`redis`或`Memcached`数据库。在我们的示例中，为了简单起见，我们将使用YAML文件来存储从设备收集的事实。我们还指定了存储此信息的文件夹位置。
- en: 'Once we have performed these steps, we can run our playbook to collect network
    facts. In this sample playbook, we are using different modules (approaches), as
    follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们可以运行我们的playbook来收集网络事实。在这个示例playbook中，我们使用不同的模块（方法），如下：
- en: '`iosxr_facts`: This is a built-in module within Ansible networking modules
    to collect facts from IOS-XR devices (for most networking equipment, there is
    a fact collection module for each vendor supported by Ansible).'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iosxr_facts`：这是Ansible网络模块中的内置模块，用于从IOS-XR设备收集事实（对于大多数受Ansible支持的供应商的网络设备，都有一个针对每个供应商的事实收集模块）。'
- en: '`napalm_get_facts`: This is a custom module from **Network Automation and Programmability
    Abstraction Layer with Multivendor support** (**NAPALM**) that needs to be installed
    to collect facts as well; however, it is not part of the core Ansible modules.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`napalm_get_facts`：这是来自**网络自动化和可编程性抽象层与多供应商支持**（**NAPALM**）的自定义模块，需要安装以收集事实；但它不是核心Ansible模块的一部分。'
- en: '`set_fact`: We use the `set_fact` module to set a custom fact during the playbook
    run, and we use the `cacheable` option to instruct the module to write this new
    cached variable into our cache.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_fact`：我们使用`set_fact`模块在playbook运行期间设置自定义事实，并使用`cacheable`选项指示模块将这个新的缓存变量写入我们的缓存。'
- en: 'Once we run the playbook, we can check that the new folder is created and a
    new YAML file for each node within our inventory is stored in this location. All
    the facts collected by these modules are saved in these YAML files, as shown in
    the following screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行playbook，我们可以检查新文件夹是否创建，并且我们清单中的每个节点都在这个位置存储了一个新的YAML文件。这些模块收集的所有事实都保存在这些YAML文件中，如下面的截图所示：
- en: '![](assets/fd052830-d9c7-4ba5-9da1-dbdba6842272.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fd052830-d9c7-4ba5-9da1-dbdba6842272.png)'
- en: There's more...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Once we have configured fact caching, we can start to use the Ansible variables
    declared in our cache in any other playbook, as shown in the following code example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们配置了事实缓存，我们就可以开始在任何其他playbook中使用我们缓存中声明的Ansible变量，如下面的代码示例所示：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding playbook, we are utilizing the variables collected from the
    cache (`ansible_net_interfaces`, in this example) and running the tasks against
    the devices in the inventory. We need to consider that, by default, the entries
    in the cache are valid only for a specific amount of time, controlled by the timeout
    value for our cache to ensure that any outdated state in our cache will not be
    considered. This value is controlled by the `fact_caching_timeout` option, which
    can be set in the `ansible.cfg` file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的playbook中，我们正在利用从缓存中收集的变量（在本例中为`ansible_net_interfaces`）并对清单中的设备运行任务。我们需要考虑，默认情况下，缓存中的条目仅在特定时间内有效，由我们的缓存的超时值控制，以确保我们的缓存中的任何过时状态不会被考虑。这个值由`fact_caching_timeout`选项控制，可以在`ansible.cfg`文件中设置。
- en: See also...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more information regarding Ansible fact caching, please consult the following
    URLs:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Ansible事实缓存的更多信息，请参考以下网址：
- en: '[https://docs.ansible.com/ansible/latest/plugins/cache.html](https://docs.ansible.com/ansible/latest/plugins/cache.html)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.ansible.com/ansible/latest/plugins/cache.html](https://docs.ansible.com/ansible/latest/plugins/cache.html)'
- en: '[https://docs.ansible.com/ansible/latest/plugins/cache/yaml.html](https://docs.ansible.com/ansible/latest/plugins/cache/yaml.html)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.ansible.com/ansible/latest/plugins/cache/yaml.html](https://docs.ansible.com/ansible/latest/plugins/cache/yaml.html)'
- en: Creating custom Python filters for Ansible
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Ansible创建自定义Python过滤器
- en: Ansible provides a rich set of filters from Jinja2, as well as some additional
    built-in filters to manipulate data; however, in some cases, you may find that
    there is no filter available to satisfy your requirements. In this recipe, we
    will outline how to build custom filters in Python to extend Ansible functionality
    to manipulate data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible提供了丰富的Jinja2过滤器以及一些额外的内置过滤器来操作数据；然而，在某些情况下，您可能会发现没有可用的过滤器来满足您的需求。在这个示例中，我们将概述如何在Python中构建自定义过滤器，以扩展Ansible功能来操作数据。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the project directory (`ch13_ansible_best_practice`), create a new folder, `filter_plugins`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目目录（`ch13_ansible_best_practice`）中，创建一个名为`filter_plugins`的新文件夹。
- en: 'Create a new Python script called `filter.py` under the `filter_plugins` folder,
    with the following content:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`filter_plugins`文件夹下创建一个名为`filter.py`的新的Python脚本，内容如下：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a new Ansible playbook, `pb_test_custom_filter.yml`, with the following
    content:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Ansible playbook，`pb_test_custom_filter.yml`，内容如下：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We can extend the `filter` library provided by Ansible and create a custom filter
    using Python. In order to implement our custom filter, we create a folder called
    `filter_plugins` under our project directory, and we create a Python script with
    any name (we used `filter.py` in our example).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展Ansible提供的`filter`库，并使用Python创建自定义过滤器。为了实现我们的自定义过滤器，我们在项目目录下创建一个名为`filter_plugins`的文件夹，并创建一个Python脚本，可以使用任何名称（在我们的示例中使用了`filter.py`）。
- en: The custom Python filters must be placed in a folder called `filter_plugins`
    in order for Ansible to pick up these filters and process them.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Ansible捕捉并处理这些过滤器，自定义的Python过滤器必须放置在名为`filter_plugins`的文件夹中。
- en: Inside this Python script, we create a Python class called `FilterModule`. Inside
    this class, we declare a function named `filters` that returns a dictionary of
    all our custom filters that we define. We then start to create our filter by declaring
    a function called `acl_state` that takes the `acl_def` variables (which is our
    ACLs' definition that we pass in our playbook). In this example, we are simply
    taking the definition of our ACL state and changing it to uppercase. We then return
    the newly modified ACL definition.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Python脚本中，我们创建了一个名为`FilterModule`的Python类。在这个类中，我们声明了一个名为`filters`的函数，它返回我们定义的所有自定义过滤器的字典。然后，我们开始创建我们的过滤器，声明一个名为`acl_state`的函数，它接受我们在playbook中传递的`acl_def`变量（这是我们ACL的定义）。在这个示例中，我们只是获取我们ACL状态的定义并将其更改为大写。然后我们返回新修改的ACL定义。
- en: We create an Ansible playbook as normal, and we read our ACL definition from
    the `ACLs.yml` file. Then, we create a new task to set a custom fact using the `set_fact`
    module, and we pass our ACLs' data structure to our custom filter that we have
    created (`acl_state`). We save the return value from our custom filter to a new
    variable called `standard_acl`, and we use the `debug` module in the next task
    to output the value of this new variable.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样创建一个Ansible playbook，并从`ACLs.yml`文件中读取我们的ACL定义。然后，我们创建一个新任务，使用`set_fact`模块设置一个自定义事实，并将我们的ACL数据结构传递给我们创建的自定义过滤器（`acl_state`）。我们将自定义过滤器的返回值保存到一个名为`standard_acl`的新变量中，并在下一个任务中使用`debug`模块输出这个新变量的值。
- en: 'The following snippet outlines the new value for our ACL and how the state
    parameter within our ACL definition has changed to uppercase:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段概述了我们ACL的新值以及ACL定义中的状态参数如何更改为大写：
- en: '![](assets/ee611e48-9e8e-41fc-b57f-ef6b5e9bdfd7.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ee611e48-9e8e-41fc-b57f-ef6b5e9bdfd7.png)'
- en: There's more...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We outlined how to pass the variable definition to our custom filter in the
    previous example; however, we can also pass multiple fields to our custom filter
    in order to have more control over the return value of our filter. In order to
    outline this, we will create another custom filter that will take the ACL definition
    along with a field variable, and, based on this field, we will change the value
    of this field in our ACL definition to uppercase. Here is the modified `filter.py` Python
    script:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个示例中概述了如何将变量定义传递给我们的自定义过滤器；然而，我们也可以传递多个字段给我们的自定义过滤器，以便更好地控制过滤器的返回值。为了概述这一点，我们将创建另一个自定义过滤器，它将获取ACL定义以及一个字段变量，并根据这个字段，将ACL定义中的这个字段的值更改为大写。以下是修改后的`filter.py`
    Python脚本：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here is the output of the modified tasks within the playbook, using our new
    custom filter:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是剧本中修改后任务的输出，使用我们的新自定义过滤器：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here is the output for our `final_acl` file after applying the new custom filter:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是应用新自定义过滤器后`final_acl`文件的输出：
- en: '![](assets/cdf03605-e02c-4166-bb13-5738974f3db2.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cdf03605-e02c-4166-bb13-5738974f3db2.png)'
- en: The preceding screenshot shows the output after applying the new custom filter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了应用新自定义过滤器后的输出。
