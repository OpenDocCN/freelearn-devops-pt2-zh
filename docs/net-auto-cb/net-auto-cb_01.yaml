- en: Building Blocks of Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible的构建块
- en: 'Ansible is an enormously popular automation framework that has been used to
    automate IT operations for a long time. It simplifies the management of different
    infrastructure nodes and translates the business logic into well-defined procedures
    in order to implement this business logic. Ansible is written in Python and it
    mainly relies on SSH to communicate with infrastructure nodes to execute instructions
    on them. It started support for networking devices beginning with Ansible 1.9,
    and with Ansible 2.9, its current support for network devices has grown extensively.
    It can interact with network devices using either SSH or via API if the network
    vendors support APIs on their equipment. It also provides multiple advantages,
    including the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个非常受欢迎的自动化框架，长期以来一直被用于自动化IT运营。它简化了不同基础设施节点的管理，并将业务逻辑转化为明确定义的程序，以实现这些业务逻辑。Ansible是用Python编写的，主要依赖SSH与基础设施节点通信以执行指令。它从Ansible
    1.9开始支持网络设备，并且随着Ansible 2.9的到来，它对网络设备的支持已经得到了大幅增强。它可以使用SSH或者如果网络供应商在其设备上支持API的话，还可以通过API与网络设备进行交互。它还提供了多个优势，包括以下内容：
- en: '**An easy learning curve:** Writing Ansible playbooks requires knowledge of
    YAML and Jinja2 templates, which are easy to learn, and its descriptive language
    is easy to understand.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易学习曲线：**编写Ansible Playbooks需要了解YAML和Jinja2模板，这些都很容易学习，其描述性语言易于理解。'
- en: '**Agentless:** It doesn''t require an agent to be installed on the remotely
    managed device in order to control this device.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无需代理：**无需在远程管理设备上安装代理即可控制该设备。'
- en: '**Extensible:** Ansible comes equipped with multiple modules to execute a variety
    of tasks on the managed nodes. It also supports writing custom modules and plugins
    to extend Ansible''s core functionality.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展：**Ansible配备了多个模块，可在受控节点上执行各种任务。它还支持编写自定义模块和插件，以扩展Ansible的核心功能。'
- en: '**Idempotent:** Ansible will not change the state of the device unless it needs
    to in order to change its setting to reach the desired state. Once it is in this
    desired state, running Ansible Playbooks against the device will not alter its
    configurations.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**幂等性：**除非需要改变设置以达到期望的状态，否则Ansible不会改变设备的状态。一旦设备处于期望的状态，运行Ansible Playbooks不会改变其配置。'
- en: 'In this chapter, we will introduce the main components of Ansible and outline
    the different features and options that Ansible supports. The following are the
    main recipes that will be covered:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Ansible的主要组件，并概述Ansible支持的不同功能和选项。以下是将涵盖的主要内容：
- en: Installing Ansible
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Ansible
- en: Building Ansible's inventory
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Ansible的清单
- en: Using Ansible's variables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible的变量
- en: Building Ansible's playbook
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Ansible的Playbook
- en: Using Ansible's conditionals
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible的条件语句
- en: Using Ansible's loops
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible的循环
- en: Securing secrets with Ansible Vault
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible Vault保护秘密
- en: Using Jinja2 with Ansible
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jinja2与Ansible
- en: Using Ansible's filters
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible的过滤器
- en: Using Ansible Tags
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible标签
- en: Customizing Ansible's settings
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制Ansible的设置
- en: Using Ansible Roles
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible角色
- en: The purpose of this chapter is to have a basic understanding of the different
    Ansible components that we will utilize throughout this book in order to interact
    with the networking device. Consequently, all the examples in this chapter are
    not focused on managing networking devices. Instead, we will focus on understanding
    the different components in Ansible in order to use them effectively in the next
    chapters.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是基本了解我们将在本书中利用的不同Ansible组件，以便与网络设备进行交互。因此，本章中的所有示例都不是专注于管理网络设备。相反，我们将专注于理解Ansible中的不同组件，以便在下一章中有效地使用它们。
- en: Technical requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are the requirements for installing Ansible and running all of our Ansible
    playbooks:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是安装Ansible和运行所有Ansible Playbooks的要求：
- en: 'A Linux **Virtual Machine** (**VM**) with either of the following distributions:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有以下发行版之一的Linux **虚拟机**（**VM**）：
- en: Ubuntu 18.04 or higher
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu 18.04或更高版本
- en: CentOS 7.0 or higher
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CentOS 7.0或更高版本
- en: Internet connectivity for the VM
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机的互联网连接
- en: Setting up the Linux machine is outside the scope of this recipe. However, the
    easiest approach to setting up a Linux VM with any OS version is by using *Vagrant *to
    create and set up the Ansible VM.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Linux机器超出了本教程的范围。然而，使用*Vagrant*创建和设置Ansible虚拟机是设置具有任何操作系统版本的Linux虚拟机的最简单方法。
- en: Installing Ansible
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Ansible
- en: The machine on which we install Ansible (this is known as the Ansible control
    machine) should be running on any Linux distribution. In this recipe, we will
    outline how to install Ansible on both an Ubuntu Linux machine or a CentOS machine.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Ansible的机器（称为Ansible控制机）应该运行在任何Linux发行版上。在本教程中，我们将概述如何在Ubuntu Linux机器或CentOS机器上安装Ansible。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To install Ansible, we need a Linux VM using either an Ubuntu 18.04+ OS or CentoS
    7+ OS. Furthermore, this machine needs to have internet access for Ansible to
    be installed on it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Ansible，我们需要使用Ubuntu 18.04+或CentOS 7+操作系统的Linux虚拟机。此外，这台机器需要有互联网访问权限才能安装Ansible。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Ansible is written in Python and all its modules need Python to be installed
    on the Ansible control machine. Our first task is to ensure that Python is installed
    on the Ansible control machine, as outlined in the following steps.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是用Python编写的，所有模块都需要在Ansible控制机上安装Python。我们的第一个任务是确保Python已安装在Ansible控制机上，如下所述。
- en: 'Most Linux distributions have Python installed by default. However, if Python
    is not installed, here are the steps for installing it on Linux:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数Linux发行版默认安装了Python。但是，如果Python未安装，以下是在Linux上安装它的步骤：
- en: 'On an Ubuntu OS, execute the following command:'
  id: totrans-34
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Ubuntu操作系统上，执行以下命令：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On a CentOS OS, execute the following command:'
  id: totrans-36
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CentOS操作系统上，执行以下命令：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After we have validated that Python is installed, we can start to install Ansible:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在验证了Python已安装后，我们可以开始安装Ansible：
- en: 'On an Ubuntu OS, execute the following command:'
  id: totrans-39
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Ubuntu操作系统上，执行以下命令：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On a CentOS OS, execute the following command:'
  id: totrans-41
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CentOS操作系统上，执行以下命令：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works..
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The easiest way to install Ansible is by using the package manager specific
    to our Linux distribution. We just need to make sure that we have enabled the
    required repositories to install the latest version of Ansible. In both Ubuntu
    and CentOS, we need to enable extra repositories that provide the latest version
    for Ansible. In CentOS, we need to install and enable the **Extra Packages for
    Enterprise Linux Repository** (**EPEL ****repo**), which provides extra software
    packages and has the latest Ansible packages for CentOS.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Ansible的最简单方法是使用特定于我们的Linux发行版的软件包管理器。我们只需要确保已启用所需的存储库以安装最新版本的Ansible。在Ubuntu和CentOS中，我们需要启用提供最新版本Ansible的额外存储库。在CentOS中，我们需要安装和启用**企业Linux额外软件包**（**EPEL**）存储库，该存储库提供额外的软件包，并为CentOS提供最新的Ansible软件包。
- en: 'Using this method, we will install Ansible and all the requisite system packages
    needed to run the Ansible modules. In both Ubuntu and CentOS, this method will
    also install Python 2 and run Ansible using Python 2\. We can validate the fact
    that Ansible is installed and which version is used by running the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，我们将安装Ansible和运行Ansible模块所需的所有必需系统软件包。在Ubuntu和CentOS中，此方法还将安装Python 2并使用Python
    2运行Ansible。我们可以通过运行以下命令验证Ansible已安装并使用的版本：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, we can check that Ansible is working as expected by trying to connect
    to the local machine using the `ping` module as shown:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过尝试使用`ping`模块连接到本地机器来检查Ansible是否按预期工作，如下所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using this method, we can see that it has the following issues:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，我们可以看到它存在以下问题：
- en: It uses Python 2 as the execution environment, but we want to use Python 3.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用Python 2作为执行环境，但我们想使用Python 3。
- en: It updates the Python packages installed on the system, which might not be desirable.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它更新了系统上安装的Python软件包，这可能是不可取的。
- en: It doesn't provide us with the granularity needed in order to select which version
    of Ansible to use. Using this method, we will always install the latest version
    of Ansible, which might not be what we need.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不提供我们所需的细粒度，以便选择要使用的Ansible版本。使用此方法，我们将始终安装最新版本的Ansible，这可能不是我们所需要的。
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In order to install Ansible in a Python 3 environment and to have more control
    over the version of Ansible deployed, we are going to use the pip Python program
    to install Ansible as shown here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python 3环境中安装Ansible并对部署的Ansible版本进行更多控制，我们将使用pip Python程序来安装Ansible，如下所示：
- en: 'Install Python 3 if it is not present, as follows:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果尚未安装Python 3，请按以下方式安装：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Install the `python3-pip` package:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装`python3-pip`软件包：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Install Ansible:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Ansible：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can verify that Ansible has been installed successfully, as shown here:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以验证Ansible已成功安装，如下所示：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Installing Ansible using this method ensures that we are using Python 3 as our
    execution environment and allows us to control which version of Ansible to install,
    as outlined in the example shown.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法安装Ansible可确保我们使用Python 3作为执行环境，并允许我们控制要安装的Ansible版本，如所示的示例。
- en: We are going to use this method as our Ansible installation method and all the
    subsequent chapters will be based on this installation procedure.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用此方法作为我们的Ansible安装方法，并且所有后续章节将基于此安装过程。
- en: In [Chapter 13](557deee4-fa1a-4128-a277-dc3a3a85fe05.xhtml), *Advanced Techniques
    and Best Practices for Ansible*, we will outline yet another method for installing
    Ansible using Python virtual environments.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](557deee4-fa1a-4128-a277-dc3a3a85fe05.xhtml)中，*Ansible的高级技术和最佳实践*，我们将概述使用Python虚拟环境安装Ansible的另一种方法。
- en: See also...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more information regarding the installation of Ansible, please check the
    following URL:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有关安装Ansible的更多信息，请查看以下网址：
- en: '[https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html)'
- en: Building Ansible's inventory
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Ansible的清单
- en: After installing Ansible, we need to define Ansible's inventory, which is a
    text file that defines the nodes that Ansible will manage. In this recipe, we
    will outline how to create and structure Ansible's inventory file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完Ansible后，我们需要定义Ansible的清单，这是一个定义Ansible将管理的节点的文本文件。在本教程中，我们将概述如何创建和构造Ansible的清单文件。
- en: Getting ready
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We need to create a folder that will contain all the code that we will outline
    in this chapter. We create a folder called `ch1_ansible`, as shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个包含本章中将概述的所有代码的文件夹。我们创建一个名为`ch1_ansible`的文件夹，如下所示：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to create the inventory file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤创建清单文件：
- en: 'Create a file named `hosts`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`hosts`的文件：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using any text editor, open the file and add the following content:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用任何文本编辑器打开文件并添加以下内容：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Ansible inventory file can have any name. However, as a best practice, we
    will use the name `hosts `to describe the devices in our inventory.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible清单文件可以有任何名称。但是，作为最佳实践，我们将使用名称`hosts`来描述清单中的设备。
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Ansible inventory files define the hosts that will be managed by Ansible
    (in the preceding example, this is `csr1-2` and `mx1-2` ) and how to group these
    devices into custom-defined groups based on different criteria. The groups are
    defined with `[]`. This grouping helps us to define the variables and simplify
    the segregation between the devices and how Ansible interacts with them. How we
    group the devices is based on our use case, so we can group them as per the vendor
    (Juniper and IOS) or function (core and edge).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible清单文件定义了将由Ansible管理的主机（在上面的示例中，这是`csr1-2`和`mx1-2`），以及如何根据不同标准将这些设备分组到自定义定义的组中。组用`[]`定义。这种分组有助于我们定义变量并简化设备之间的分隔以及Ansible与它们的交互。我们如何分组设备是基于我们的用例的，因此我们可以根据供应商（Juniper和IOS）或功能（核心和边缘）对它们进行分组。
- en: 'We can also build hierarchies for the groups using the children, which is outlined
    in the inventory file. The following diagram shows how the hosts are grouped and
    how the group hierarchy is built:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用在清单文件中概述的children为组构建层次结构。以下图显示了主机是如何分组的以及组层次结构是如何构建的：
- en: '![](assets/9f400a5c-801d-4a28-9d42-282a2f058a6d.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9f400a5c-801d-4a28-9d42-282a2f058a6d.png)'
- en: Using Ansible's variables
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible的变量
- en: Ansible stores the information for the nodes that it manages using Ansible variables.
    Ansible variables can be declared in multiple locations. However, in observing
    the best practices for Ansible, we will outline the two main parts where Ansible
    looks for variables for the nodes that are declared in the inventory file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible使用Ansible变量存储其管理的节点的信息。Ansible变量可以在多个位置声明。然而，为了遵循Ansible的最佳实践，我们将概述Ansible寻找用于在清单文件中声明的节点的变量的两个主要部分。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to follow along with this recipe, an Ansible inventory file must be
    already defined as outlined in the previous recipes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按照这个步骤进行，必须已经按照之前的步骤定义了Ansible清单文件。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'In the inventory file, we define hosts and we group the hosts into groups.
    We now define two directories that Ansible searches for group variables and host
    variables:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单文件中，我们定义主机并将主机分组。现在我们定义了Ansible搜索组变量和主机变量的两个目录：
- en: 'Create two folders, `group_vars` and `host_vars`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个文件夹，`group_vars`和`host_vars`：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create `ios.yml` and `junos.yml` files inside `group_vars`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`group_vars`内创建`ios.yml`和`junos.yml`文件：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create `mx1.yml` and `csr1.yml` inside `host_vars`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`host_vars`内创建`mx1.yml`和`csr1.yml`：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Populate variables in all the files, as shown here:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充所有文件中的变量，如下所示：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'We created the following structure of directories and files to host our variables,
    as shown in the following diagram:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了以下目录和文件结构来存储我们的变量，如下图所示：
- en: '![](assets/20d311f1-1f4b-4e27-8624-733306a36a08.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/20d311f1-1f4b-4e27-8624-733306a36a08.png)'
- en: All files inside the `group_vars` directory contain the group variables for
    the groups that we have defined in our inventory and they apply to all the hosts
    within this group. As for the files within `host_vars`, they contain variables
    for each host. Using this structure, we can group variables from multiple hosts
    into a specific group file and variables that are host-specific will be placed
    in a separate file specific to this host.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`group_vars`目录内的所有文件包含我们在清单中定义的组的组变量，并且适用于该组内的所有主机。至于`host_vars`内的文件，它们包含每个主机的变量。使用这种结构，我们可以将多个主机的变量分组到一个特定的组文件中，并且特定于主机的变量将被放在一个特定于该主机的单独文件中。'
- en: There's more...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In addition to `host_vars` and `group_vars`, Ansible supports the definition
    of variables using other techniques, including the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`host_vars`和`group_vars`，Ansible还支持使用其他技术定义变量，包括以下内容：
- en: Using the `vars` keyword within the play to specify multiple variables
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在play中使用`vars`关键字指定多个变量
- en: Using `vars_files` to define variables in a file and having Ansible read these
    variables from this file while running the playbook
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`vars_files`在文件中定义变量，并在运行playbook时让Ansible从该文件中读取这些变量
- en: Specifying variables at the command line using the `--e` option
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--e`选项在命令行指定变量
- en: 'In addition to the user-defined variables that we can specify, Ansible has
    some default variables that it builds dynamically for its inventory. The following
    table captures some of the most frequently used variables:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们可以指定的用户定义变量之外，Ansible还有一些默认变量，它会动态构建用于清单的变量。以下表格捕获了一些最常用的变量：
- en: '| `inventory_hostname` |  The name of the hosts as defined in the inventory
    (for example, `csr1` and `mx1`) |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `inventory_hostname` | 主机在清单中定义的名称（例如，`csr1`和`mx1`）|'
- en: '| ` play_hosts` |  A list of all the hosts included in the play |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `play_hosts` | play中包含的所有主机的列表 |'
- en: '|  `group_names` |  A list of all the groups that a specific host is a part
    of (for example, for `csr1` this will be [edge, Cisco, network]) |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `group_names` | 特定主机所属的所有组的列表（例如，对于`csr1`，这将是[edge，Cisco，network]）|'
- en: Building Ansible's playbook
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Ansible的playbook
- en: An Ansible playbook is the fundamental element in Ansible that declares what
    actions we would like to perform on our managed hosts (specified in the inventory).
    An Ansible playbook is a YAML-formatted file that defines a list of tasks that
    will be executed on our managed devices. In this recipe, we will outline how to
    write an Ansible playbook and how to define the hosts that will be targeted by
    this playbook.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible playbook是Ansible中声明我们想要在我们管理的主机上执行的操作的基本元素。Ansible playbook是一个以YAML格式编写的文件，定义了将在我们管理的设备上执行的任务列表。在这个步骤中，我们将概述如何编写一个Ansible
    playbook以及如何定义将被此playbook定位的主机。
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to follow along with this recipe, an Ansible inventory file must already
    be defined, along with all the group- and host-specific variable files created
    in accordance with previous recipes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按照这个步骤进行，必须已经定义了Ansible清单文件，并根据之前的步骤创建了所有组和主机特定的变量文件。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'Create a new file called `playbook.yml` inside the `ch1_ansible` folder and
    incorporate the following lines in this file:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ch1_ansible`文件夹内创建一个名为`playbook.yml`的新文件，并在此文件中加入以下行：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the playbook as shown here:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤运行playbook：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The Ansible playbook is structured as a list of plays and each play targets
    a specific group of hosts (defined in the inventory file). Each play can have
    one or more tasks to execute against the hosts in this play. Each task runs a
    specific Ansible module that has a number of arguments. The general structure
    of the playbook is outlined in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible playbook是一系列play的列表，每个play针对清单文件中定义的特定主机组。每个play可以有一个或多个任务针对此play中的主机执行。每个任务运行一个特定的Ansible模块，该模块有一些参数。playbook的一般结构如下截图所示：
- en: '![](assets/d47f5627-bbfa-4390-b115-2185f8a471ac.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d47f5627-bbfa-4390-b115-2185f8a471ac.png)'
- en: 'In the preceding playbook, we reference the variables that we defined in the
    previous recipe inside the `{{ }}` brackets. Ansible reads these variables from
    either `group_vars` or `host_vars`, and the module that we used in this playbook
    is the `debug` module, which displays as a custom message specified in the `msg`
    parameter to the Terminal output. The playbook run is shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述playbook中，我们在`{{ }}`括号中引用了我们在前面步骤中定义的变量。Ansible从`group_vars`或`host_vars`中读取这些变量，我们在这个playbook中使用的模块是`debug`模块，它将在终端输出中显示为`msg`参数中指定的自定义消息。playbook运行如下所示：
- en: '![](assets/4b64c49d-83a9-4478-884e-8dc6cbeac062.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4b64c49d-83a9-4478-884e-8dc6cbeac062.png)'
- en: We use the `-i` option in the `ansible-playbook` command in order to point to
    the Ansible inventory file, which we will use as our source to construct our inventory.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`ansible-playbook`命令中使用`-i`选项来指向Ansible清单文件，这将作为我们构建清单的源。
- en: In this playbook, I have used the `all` keyword to specify all the hosts within
    the inventory. This is a well-known group name that Ansible dynamically constructs
    for all hosts within the inventory.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个playbook中，我使用了`all`关键字来指定清单中的所有主机。这是Ansible为清单中的所有主机动态构建的一个众所周知的组名。
- en: Using Ansible's conditionals
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible的条件语句
- en: One of the core features of Ansible is conditional task execution. This provides
    us with the ability to control which tasks to run on a given host based on a condition/test
    that we specify. In this recipe, we will outline how to configure conditional
    task execution.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的核心功能之一是条件任务执行。这为我们提供了根据我们指定的条件/测试来控制在给定主机上运行哪些任务的能力。在这个步骤中，我们将概述如何配置条件任务执行。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to follow along with this recipe, an Ansible inventory file must be
    present and configured as outlined in the previous recipes. Furthermore, the Ansible
    variables for all our hosts should be defined as outlined in the previous recipes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按照这个步骤进行操作，必须存在一个已配置的Ansible清单文件，如前面的步骤所述。此外，所有主机的Ansible变量应该按照前面的步骤所述进行定义。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new playbook called `ansible_cond.yml` inside the `ch1_ansible` folder.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ch1_ansible`文件夹中创建一个名为`ansible_cond.yml`的新playbook。
- en: 'Place the following content in the new playbook as shown here:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照这里所示在新的playbook中加入以下内容：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the playbook as shown here:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照这里所示运行playbook：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Ansible uses the `when` statement to provide conditional execution for the
    tasks. The `when` statement is applied at the task level and if the condition
    in the `when` statement evaluates to `true`, the task is executed for the given
    host. If `false`, the task is skipped for this host. The output as a result of
    running the preceding playbook is shown here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible使用`when`语句为任务提供条件执行。`when`语句应用于任务级别，如果`when`语句中的条件评估为`true`，则任务将针对给定的主机执行。如果为`false`，则该任务将跳过该主机。运行上述playbook的输出如下所示：
- en: '![](assets/3cf93206-e932-47d1-97e3-7869e77fea29.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3cf93206-e932-47d1-97e3-7869e77fea29.png)'
- en: The `when` statement can take a single condition as seen in the first task,
    or can take a list of conditions as seen in the second task. If `when` is a list
    of conditions, all the conditions need to be true in order for the task to be
    executed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`when`语句可以像第一个任务中那样接受一个条件，也可以像第二个任务中那样接受一个条件列表。如果`when`是一个条件列表，所有条件都需要为真才能执行任务。'
- en: In the first task, the `when` statement is enclosed in *""* since the statement
    starts with a string**.** However, in the second statement, we use a normal `when`
    statement with no *""* since the `when` statement starts with a variable name.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个任务中，`when`语句用*""*括起来，因为语句以字符串开头**。然而，在第二个语句中，我们使用了一个普通的`when`语句，没有*""*，因为`when`语句以变量名开头。
- en: See also...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more information regarding Ansible''s conditionals, please check the following
    URL:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Ansible条件语句的更多信息，请查看以下网址：
- en: '[https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_conditionals.html)'
- en: Using Ansible's loops
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible的循环
- en: In some cases, we need to run a task inside an Ansible playbook to loop over
    some data. Ansible's loops allow us to loop over a variable (a dictionary or a
    list) multiple times in order to achieve this behavior. In this recipe, we will
    outline how to use Ansible's loops.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要在Ansible playbook中运行一个任务来循环处理一些数据。Ansible的循环允许我们多次循环遍历一个变量（字典或列表）以实现这种行为。在这个步骤中，我们将概述如何使用Ansible的循环。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to follow along with this recipe, an Ansible inventory file must be
    present and configured, as outlined in the previous recipes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按照这个步骤进行操作，必须存在一个已配置的Ansible清单文件，如前面的步骤所述。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new playbook called `ansible_loops.yml` inside the `ch1_ansible` folder.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ch1_ansible`文件夹中创建一个名为`ansible_loops.yml`的新playbook。
- en: 'Inside the `group_vars/cisco.yml` file, incorporate the following content:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`group_vars/cisco.yml`文件中，加入以下内容：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Inside the `group_vars/juniper.yml` file, incorporate the following content:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`group_vars/juniper.yml`文件中，加入以下内容：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Inside the `ansible_loops.yml` file, incorporate the following content:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ansible_loops.yml`文件中，加入以下内容：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the playbook as shown here:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照这里所示运行playbook：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works..
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的..
- en: 'Ansible supports looping over two main iterable data structures: lists and
    dictionaries. We use the `loops` keyword when we need to iterate over lists (`snmp_servers`
    is a list data structure) and we use `with_dicts` when we loop over a dictionary
    (`users` is a dictionary data structure where the username is the key and the
    passwords are the values). In both cases, we use the `item` keyword to specify
    the value in the current iteration. In the case of `with_dicts`, we get the key
    using `item.key` and we get the value using `item.value`.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible支持对两种主要的可迭代数据结构进行循环：列表和字典。当我们需要对列表进行迭代时（`snmp_servers`是一个列表数据结构），我们使用`loops`关键字，当我们循环遍历字典时（`users`是一个字典数据结构，其中用户名是键，密码是值），我们使用`with_dicts`。在这两种情况下，我们使用`item`关键字来指定当前迭代中的值。在`with_dicts`的情况下，我们使用`item.key`来获取键，使用`item.value`来获取值。
- en: 'The output of the preceding playbook run is shown here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面剧本运行的输出：
- en: '![](assets/4c43a45f-afdd-4601-9a00-4d4bb748f882.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4c43a45f-afdd-4601-9a00-4d4bb748f882.png)'
- en: See also...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more information regarding the different Ansible *looping constructs**, *please
    consult the following URL:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有关不同的Ansible*循环结构*的更多信息，请参考以下网址：
- en: '[https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html)'
- en: Securing secrets with Ansible Vault
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible Vault保护秘密
- en: When we are dealing with sensitive material that we need to reference in our
    Ansible playbooks, such as passwords, we shouldn't save this data in plain text.
    Ansible Vault provides a method to encrypt this data and therefore be safely decrypted
    and accessed while the playbook is running. In this recipe, we will outline how
    to use Ansible Vault in order to secure sensitive information in Ansible.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理需要在Ansible剧本中引用的敏感材料时，比如密码，我们不应该将这些数据保存为纯文本。Ansible Vault提供了一种加密这些数据并在运行剧本时安全解密和访问的方法。在这个示例中，我们将概述如何使用Ansible
    Vault来保护Ansible中的敏感信息。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new file called `decrypt_passwd` as shown:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`decrypt_passwd`的新文件，如下所示：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using `ansible-vault` creates a new file called `secrets`, as shown here:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ansible-vault`创建一个名为`secrets`的新文件，如下所示：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the following variables to this new `secrets` file:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下变量添加到这个新的`secrets`文件中：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a new playbook called `ansible_vault.yml`, as shown here:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ansible_vault.yml`的新剧本，如下所示：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the playbook as shown here:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照这里所示的方式运行剧本：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works..
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的..
- en: 'We use the `ansible-vault` command to create a new file that is encrypted using
    a key specified by `-- vault-id`. We place this key/password in another file (which
    is called `decrypt_passwd` in our example) and we pass this file as an argument
    to `vault-id`. Inside this file, we can place as many variables as we need. Finally,
    we include this file as a variable file in the playbook using `vars_files`. The
    following is the content of the secret file in case we try to read it without
    decryption:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ansible-vault`命令创建一个使用`--vault-id`指定的密钥加密的新文件。我们将这个密钥/密码放在另一个文件中（在我们的示例中称为`decrypt_passwd`），并将此文件作为`vault-id`的参数传递。在这个文件中，我们可以放置尽可能多的变量。最后，我们使用`vars_files`将这个文件作为变量文件包含在剧本中。如果我们尝试在没有解密的情况下读取秘密文件，其内容如下：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In order for Ansible to decrypt this file, we must supply the decryption password
    (stored in a `decrypt_passwd` file in this example) via the `--vault-id` option.
    When we run `ansible-playbook`, we must supply this decryption password, otherwise
    the `ansible-playbook` fails, as shown here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Ansible解密这个文件，我们必须通过`--vault-id`选项提供解密密码（在这个示例中存储在`decrypt_passwd`文件中）。当我们运行`ansible-playbook`时，必须提供这个解密密码，否则`ansible-playbook`会失败，如下所示：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There's more...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In case we don''t want to specify the encryption/decryption password in the
    text file, we can use `--ask-vault-pass` with the `ansible-playbook` command in
    order to input the password while running the playbook, as shown here:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想在文本文件中指定加密/解密密码，我们可以在运行剧本时使用`--ask-vault-pass`和`ansible-playbook`命令一起输入密码，如下所示：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using Jinja2 with Ansible
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jinja2与Ansible
- en: Jinja2 is a powerful templating engine for Python and is supported by Ansible.
    It is also used to generate any text-based files, such as HTML, CSV, or YAML.
    We can utilize Jinja2 with Ansible variables in order to generate custom configuration
    files for network devices. In this recipe, we will outline how to use Jinja2 templates
    with Ansible.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2是Python的一个强大的模板引擎，受到Ansible的支持。它还用于生成任何基于文本的文件，如HTML、CSV或YAML。我们可以利用Ansible变量来使用Jinja2生成网络设备的自定义配置文件。在这个示例中，我们将概述如何在Ansible中使用Jinja2模板。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to follow along with this recipe, an Ansible inventory file must be
    present and configured as outlined in the previous recipes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按照这个示例进行操作，必须存在并按照前面的示例配置好Ansible清单文件。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new file inside the `group_vars` directory called `network.yml`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`group_vars`目录中创建一个名为`network.yml`的新文件：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a new `templates` directory and create a new `ios_basic.j2` file with
    the following content:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`templates`目录，并创建一个名为`ios_basic.j2`的新文件，内容如下：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a new `junos_basic.j2` file within the `templates` directory with the
    following content:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates`目录中创建一个名为`junos_basic.j2`的新文件，内容如下：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a new playbook called `ansible_jinja2.yml` with the following content:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ansible_jinja2.yml`的新剧本，内容如下：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the Ansible playbook as shown here:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照这里所示的方式运行Ansible剧本：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created the `network.yml` file in order to group all the variables that will
    apply to all devices under this group. After that, we create two Jinja2 files,
    one for Cisco IOS devices, and the other for Juniper devices. Inside each Jinja2
    template, we reference the Ansible variables using `{{}}`. We also use the `for`
    loop construct, `{% for server in ntp_servers %} `, supported by the Jinja2 templating
    engine in order to loop over the `ntp_servers` variable (which is a list) to access
    each item within this list.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`network.yml`文件，以便将适用于该组下所有设备的所有变量进行分组。之后，我们创建了两个Jinja2文件，一个用于Cisco IOS设备，另一个用于Juniper设备。在每个Jinja2模板中，我们使用`{{}}`引用Ansible变量。我们还使用Jinja2模板引擎支持的`for`循环构造`{%
    for server in ntp_servers %}`，以循环遍历`ntp_servers`变量（这是一个列表），以访问此列表中的每个项目。
- en: 'Ansible provides the `template` module that takes two parameters:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible提供了`template`模块，它有两个参数：
- en: '`src`: This references the Jinja2 template file.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：这引用了Jinja2模板文件。'
- en: '`dest`: This specifies the output file that will be generated.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dest`：这指定将生成的输出文件。'
- en: In our case, we use the `{{inventory_hostname}}` variable in order to make the
    output configuration file unique for each router in our inventory.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们使用`{{inventory_hostname}}`变量，以使输出配置文件对我们清单中的每个路由器都是唯一的。
- en: 'By default, the `template` modules create the output file on the remotely managed
    nodes. However, this is not possible in our case since the managed devices are
    network nodes. Consequently, we use the `delegate_to: localhost` option in order
    to run this task locally on the Ansible control machine.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，`template`模块在远程管理节点上创建输出文件。但是，在我们的情况下，由于受管设备是网络节点，这是不可能的。因此，我们使用`delegate_to:
    localhost`选项，以便在Ansible控制机上本地运行此任务。'
- en: The first play in the playbook creates the `configs` directory to store the
    configuration files for the network devices. The second play runs the template
    module on Cisco devices, and the third play runs the `template` task on Juniper
    devices.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: playbook中的第一个play创建`configs`目录，用于存储网络设备的配置文件。第二个play在Cisco设备上运行模板模块，第三个play在Juniper设备上运行`template`任务。
- en: 'The following is the configuration file for one of the Cisco devices:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Cisco设备的配置文件：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is the configuration file for one of the Juniper devices:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Juniper设备的配置文件：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See also...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more information regarding the Ansible template module,please consult the
    following URL:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Ansible模板模块的更多信息，请参考以下网址：
- en: '[https://docs.ansible.com/ansible/latest/modules/template_module.html](https://docs.ansible.com/ansible/latest/modules/template_module.html)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.ansible.com/ansible/latest/modules/template_module.html](https://docs.ansible.com/ansible/latest/modules/template_module.html)'
- en: Using Ansible's filters
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible的过滤器
- en: Ansible's filters are mainly derived from Jinja2 filters, and all Ansible filters
    are used to transform and manipulate data (Ansible's variables). In addition to
    Jinja2 filters, Ansible implements its own filters to augment Jinja2 filters,
    while also allowing users to define their own custom filters. In this recipe,
    we will outline how to configure and use Ansible filters to manipulate our input
    data.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的过滤器主要源自Jinja2过滤器，所有Ansible过滤器都用于转换和操作数据（Ansible的变量）。除了Jinja2过滤器外，Ansible还实现了自己的过滤器来增强Jinja2过滤器，同时还允许用户定义自己的自定义过滤器。在本教程中，我们将概述如何配置和使用Ansible过滤器来操作我们的输入数据。
- en: How to do it...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Install `python3-pip` and Python''s `netaddr` library, since we will be using
    the Ansible IP filter, which requires Python''s `netaddr` library:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`python3-pip`和Python的`netaddr`库，因为我们将使用需要Python的`netaddr`库的Ansible IP过滤器：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a new Ansible playbook called `ansible_filters.yml`, as shown here:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ansible_filters.yml`的新Ansible playbook，如下所示：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: First of all, we are using the `blockinfile` module to create a new configuration
    file on the Ansible control machine. This module is very similar to the `template`
    module. However, we can write the Jinja2 expressions directly in the module in
    the `block` option. We define a new variable called `interfaces` using the `vars`
    parameter in the playbook. This variable is a list data structure where each item
    in the list is a dictionary data structure. This nested data structure specifies
    the IP prefix used on each interface.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`blockinfile`模块在Ansible控制机上创建一个新的配置文件。此模块与`template`模块非常相似。但是，我们可以直接在`block`选项中编写Jinja2表达式。我们在playbook中使用`vars`参数定义了一个名为`interfaces`的新变量。此变量是一个列表数据结构，其中列表中的每个项目都是一个字典数据结构。此嵌套数据结构指定了每个接口上使用的IP前缀。
- en: 'In the Jinja2 expressions, we can see that we have used a number of filters
    as shown here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jinja2表达式中，我们可以看到我们使用了一些过滤器，如下所示：
- en: '`{{ hostname | upper}}`: `upper` is a Jinja2 filter that transforms all the
    letters of the input string into uppercase. In this way, we pass the value of
    the hostname variable to this filter and the output will be the uppercase version
    of this value.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{ hostname | upper}}`：`upper`是一个Jinja2过滤器，将输入字符串的所有字母转换为大写。通过这种方式，我们将主机名变量的值传递给此过滤器，输出将是此值的大写版本。'
- en: '`{{intf.prefix | ipv4(1) | ipv4(''address'') }}`: Here, we use the Ansible
    IP address filter twice. `ipv4(1)` takes an input IP prefix and outputs the first
    IP address in this prefix. We then use another IP address filter, `ipv4(''address'')`,
    in order to only get the IP address part of an IP prefix. So in our case, we take
    `10.1.1.0/24` and we output `10.1.1.1` for the first interface.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{intf.prefix | ipv4(1) | ipv4(''address'') }}`：在这里，我们两次使用了Ansible IP地址过滤器。`ipv4(1)`接受输入IP前缀并输出此前缀中的第一个IP地址。然后，我们使用另一个IP地址过滤器`ipv4(''address'')`，以便仅获取IP前缀的IP地址部分。因此，在我们的情况下，我们取`10.1.1.0/24`，我们输出第一个接口的`10.1.1.1`。'
- en: '`{{intf.prefix | ipv4(''netmask'') }}`: Here, we use the Ansible IP address
    filter to get the netmask of the IP address prefix, so in our case, we get the
    `/24` subnet and transform it to `255.255.255.0`.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{intf.prefix | ipv4(''netmask'') }}`：在这里，我们使用Ansible IP地址过滤器来获取IP地址前缀的子网掩码，因此在我们的情况下，我们得到`/24`子网并将其转换为`255.255.255.0`。'
- en: 'The output file for the `csr1` router after this playbook run is shown here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此playbook运行后，`csr1`路由器的输出文件如下所示：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Using Ansible Tags
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible标签
- en: Ansible Tags is a powerful tool that allows us to tag specific tasks within
    a large Ansible playbook and provides us with the flexibility to choose which
    tasks will run within a given playbook based on the tags we specify. In this recipe,
    we will outline how to configure and use Ansible Tags.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible标签是一个强大的工具，允许我们在大型Ansible playbook中为特定任务打标签，并灵活选择基于我们指定的标签在给定playbook中运行哪些任务。在这个示例中，我们将概述如何配置和使用Ansible标签。
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Create a new Ansible playbook called `ansible_tags.yml`, as shown here:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ansible_tags.yml`的新的Ansible playbook，如下所示：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run the playbook as shown here:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下示例运行playbook：
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the playbook again, this time using tags, as shown here:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行playbook，这次使用标签，如下所示：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We can use tags to mark both tasks and plays with a given tag in order to use
    it to control which tasks or plays get executed. This gives us more control when
    developing playbooks to allow us to run the same playbook. However, with each
    run, we can control what we are deploying. In the example playbook in this recipe,
    we have tagged the tasks as OSPF, BGP, or NTP and have applied the `routing` tag
    to both the OSPF and BGP tasks. This allows us to selectively run the tasks within
    our playbook as shown here:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标签来标记具有特定标签的任务和play，以控制执行哪些任务或play。这在开发playbook时给予我们更多的控制，允许我们运行相同的playbook，但每次运行时都可以控制我们部署的内容。在这个示例中的playbook中，我们已经将任务标记为OSPF、BGP或NTP，并将`routing`标签应用到了OSPF和BGP任务。这允许我们有选择性地运行playbook中的任务，如下所示：
- en: 'With no tags specified, this will run all the tasks in the playbook with no
    change in the behavior, as shown in the following screenshot:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有指定标签，这将运行playbook中的所有任务，行为不会改变，如下截图所示：
- en: '![](assets/488df312-f5f4-4335-926b-f8679b6bf419.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/488df312-f5f4-4335-926b-f8679b6bf419.png)'
- en: 'Using the `ospf` tag, we will only run any task marked with this tag, as shown
    here:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ospf`标签，我们将只运行标记有这个标签的任何任务，如下所示：
- en: '![](assets/1c0ed146-98f5-4685-b404-4cf019aea279.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1c0ed146-98f5-4685-b404-4cf019aea279.png)'
- en: 'Using the `routing` tag, we will run all tasks marked with this tag, as shown
    here:'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`routing`标签，我们将运行所有标记有这个标签的任务，如下所示：
- en: '![](assets/6750a066-54c7-4c8d-af67-0d303272f82a.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6750a066-54c7-4c8d-af67-0d303272f82a.png)'
- en: See also...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more information regarding Ansible Tags,please consult the following URL:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Ansible标签的更多信息，请参考以下URL：
- en: '[https://docs.ansible.com/ansible/latest/user_guide/playbooks_tags.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_tags.html)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.ansible.com/ansible/latest/user_guide/playbooks_tags.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_tags.html)'
- en: Customizing Ansible's settings
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义Ansible的设置
- en: Ansible has many setting that can be adjusted and controlled using a configuration
    file called `ansible.cfg`. This file has multiple options that control many aspects
    of Ansible, including how Ansible looks and how it connects to managed devices.
    In this recipe, we will outline how to adjust some of these default settings.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible有许多设置可以通过一个名为`ansible.cfg`的配置文件进行调整和控制。这个文件有多个选项，控制着Ansible的许多方面，包括Ansible的外观和它如何连接到受控设备。在这个示例中，我们将概述如何调整一些默认设置。
- en: How to do it...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Create a new file called `ansible.cfg`, as shown here:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ansible.cfg`的新文件，如下所示：
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'By default, Ansible''s settings are controlled by the `ansible.cfg` file located
    in the `/etc/ansible` directory. This is the default configuration file for Ansible
    that controls how Ansible interacts with managed nodes. We can edit this file
    directly. However, this will impact any playbook that we will use on the Ansible
    control machine, as well as any user on this machine. A more flexible and customized
    option is to include a file named `ansible.cfg` in the project directory and this
    includes all the options that you need to modify from their default parameters.
    In the preceding example, we outline only a small subset of these options, as
    shown here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible的设置由位于`/etc/ansible`目录中的`ansible.cfg`文件控制。这是Ansible的默认配置文件，控制着Ansible与受控节点的交互方式。我们可以直接编辑这个文件。但是，这将影响到我们在Ansible控制机上使用的任何playbook，以及这台机器上的任何用户。一个更灵活和定制的选项是在项目目录中包含一个名为`ansible.cfg`的文件，其中包含了需要从默认参数中修改的所有选项。在上面的示例中，我们只概述了其中的一小部分选项。
- en: '`inventory`***:*** This option modifies the default inventory file that Ansible
    searches in order to find its inventory (by default, this is `/etc/ansible/hosts`).
    We adjust this option in order to let Ansible use our inventory file and stop
    using the `-i` operator to specify our inventory during each playbook run.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inventory`***:*** 这个选项修改了Ansible搜索的默认清单文件，以便找到它的清单（默认情况下，这是`/etc/ansible/hosts`）。我们调整这个选项，让Ansible使用我们的清单文件，并在每次运行playbook时停止使用`-i`操作符来指定我们的清单。'
- en: '`vault_password_file`: This option sets the file that has the secret password
    for encrypting and decrypting `ansible-vault` secrets. This option removes the
    need to run Ansible playbooks with the `--vault-id` operator when using `ansible-vault`-encrypted
    variables.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vault_password_file`：这个选项设置了用于加密和解密`ansible-vault`密码的秘密密码文件。这个选项消除了在使用`ansible-vault`加密变量时需要使用`--vault-id`操作符运行Ansible
    playbook的需要。'
- en: '`gathering = explicit`: By default, Ansible runs a setup module to gather facts
    regarding the managed nodes while the playbook is running. This setup module is
    not compatible with network nodes since this module requires a Python interpreter
    on the managed nodes. By setting fact gathering to `explicit`, we disable this
    default behavior.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gathering = explicit`：默认情况下，Ansible在运行playbook时运行一个设置模块来收集有关受控节点的事实。由于这个设置模块需要受控节点上的Python解释器，因此这个设置模块与网络节点不兼容。通过将事实收集设置为`explicit`，我们禁用了这个默认行为。'
- en: See also...
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more information regarding Ansible''s configuration settings,please consult
    the following URL:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Ansible配置设置的更多信息，请参考以下URL：
- en: '[https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings](https://docs.ansible.com/ansible/latest/reference_appendices/config.html#ansible-configuration-settings)'
- en: Using Ansible Roles
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible角色
- en: Ansible Roles promotes code reusability and provides a simple method for packaging
    Ansible code in a simple way that can be shared and consumed. An Ansible role
    is a collection of all the required Ansible tasks, handlers, and Jinja2 templates
    that are packaged together in a specific structure. A role should be designed
    in order to deliver a specific function/task. In this recipe, we will outline
    how to create an Ansible role and how to use it in our playbooks.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible角色促进了代码的可重用性，并提供了一种简单的方法来打包Ansible代码，以便可以共享和使用。Ansible角色是所有所需的Ansible任务、处理程序和Jinja2模板的集合，它们以特定的结构打包在一起。角色应设计为提供特定的功能/任务。在这个示例中，我们将概述如何创建一个Ansible角色以及如何在我们的playbooks中使用它。
- en: How to do it...
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Inside the `ch1_ansible` folder, create a new folder called `roles` and create
    a new role called `basic_config`, as shown here:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ch1_ansible`文件夹中，创建一个名为`roles`的新文件夹，并创建一个名为`basic_config`的新角色，如下所示：
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Update the `basic_config/vars/main.yml` file with the following variable:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下变量更新`basic_config/vars/main.yml`文件：
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Update the `basic_config/tasks/main.yml` file with the following tasks:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下任务更新`basic_config/tasks/main.yml`文件：
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Inside the `basic_config/templates` folder, create the following structure:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`basic_config/templates`文件夹内，创建以下结构：
- en: '[PRE50]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a new playbook, `pb_ansible_role.yml`, with the following content to
    use our role:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的playbook，`pb_ansible_role.yml`，内容如下以使用我们的角色：
- en: '[PRE51]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works...
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we start by creating the `roles` directory within our main
    folder. By default, when using roles, Ansible will look for roles in the following
    location in this order:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先在主文件夹中创建`roles`目录。默认情况下，使用角色时，Ansible会按照以下顺序在以下位置查找角色：
- en: The `roles` folder within the current working directory
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前工作目录中的`roles`文件夹
- en: '`/etc/ansible/roles`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/ansible/roles`'
- en: 'Consequently, we create the `roles` folder within our current working directory
    (`ch1_ansible`) in order to host all the roles that we will create in this folder.
    We create the role using the `ansible-galaxy` command with the `init` option and
    the role name (`basic_config`), which will create the following role structure
    inside our `roles` folder:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在当前工作目录（`ch1_ansible`）中创建`roles`文件夹，以承载我们将在此文件夹中创建的所有角色。我们使用`ansible-galaxy`命令和`init`选项以及角色名称（`basic_config`）创建角色，这将在`roles`文件夹内创建以下角色结构：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As can be seen from the preceding output, this folder structure is created
    using the `ansible-galaxy` command and this command builds the role in keeping
    with the best practice role layout. Not all these folders need to have a functional
    role that we can use, and the following list outlines the main folders that are
    commonly used:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出可以看出，使用`ansible-galaxy`命令创建了这个文件夹结构，这个命令根据最佳实践角色布局构建了角色。并非所有这些文件夹都需要具有我们可以使用的功能角色，以下列表概述了通常使用的主要文件夹：
- en: 'The `tasks` folder: This contains the `main.yml` file, which lists all the
    tasks that should be executed when we use this role.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasks`文件夹：这包含了`main.yml`文件，列出了在使用此角色时应执行的所有任务。'
- en: 'The `templates` folder: This contains all the Jinja2 templates that we will
    use as part of this role.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates`文件夹：这包含我们将作为此角色一部分使用的所有Jinja2模板。'
- en: 'The `vars` folder: This contains all the variables that we want to define and
    that we will use in our role. The variables inside the `vars` folder have very
    high precedence when evaluating the variables while running the playbook.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vars`文件夹：这包含了我们想要定义并在角色中使用的所有变量。`vars`文件夹中的变量在运行playbook时评估变量时具有非常高的优先级。'
- en: 'The `handlers` folder: This contains the `main.yml` file, which includes all
    the handlers that should run as part of this role.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handlers`文件夹：这包含了`main.yml`文件，其中包含了作为此角色一部分应运行的所有处理程序。'
- en: The role that we created has a single purpose, which is to build the basic configuration
    for our devices. In order to accomplish this task, we need to define some Ansible
    tasks as well as use a number of Jinja2 templates in order to generate the basic
    configuration for the devices. We list all the tasks that we need to run in the
    `tasks/main.yml` file and we include all the necessary Jinja2 templates in the
    `templates` folder. We define any requisite variable that we will use in our role
    in the `vars` folder.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的角色只有一个目的，那就是为我们的设备构建基本配置。为了完成这个任务，我们需要定义一些Ansible任务，并使用一些Jinja2模板来生成设备的基本配置。我们在`tasks/main.yml`文件中列出了所有需要运行的任务，并在`templates`文件夹中包含了所有必要的Jinja2模板。我们在`vars`文件夹中定义了我们将在角色中使用的任何必需变量。
- en: We create a new playbook that will use our new role in order to generate the
    configuration for the devices. We call all the roles that we want to run as part
    of our playbook in the `roles` parameter. In our case, we have a single role that
    we want to run, which is the `basic_config` role.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的playbook，将使用我们的新角色来生成设备的配置。我们在`roles`参数中调用我们想要运行的所有角色作为playbook的一部分。在我们的情况下，我们只想要运行一个角色，即`basic_config`角色。
- en: 'Once we run our playbook, we can see that a new directory called `basic_config`
    is created with the following content:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的playbook后，我们可以看到一个名为`basic_config`的新目录被创建，其中包含以下内容：
- en: '[PRE53]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: See also
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information regarding Ansible Roles,please consult the following URL:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Ansible角色的更多信息，请参阅以下网址：
- en: '[https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html)'
