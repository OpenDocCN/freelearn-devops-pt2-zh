- en: Building Data Center Networks with Arista and Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Arista和Ansible构建数据中心网络
- en: 'In this chapter, we will outline how to automate Arista switches in a typical
    data center environment in a leaf-spine architecture. We will explore how to interact
    with Arista devices using Ansible, and how to deploy **virtual local area networks**
    (**VLANs**) and **virtual extensible LANs** (**VXLANs**) in a **Border Gateway
    Protocol/Ethernet virtual private network** (**BGP/EVPN)** setup on the Arista
    switches using various Ansible modules. We will base our illustration on the following
    sample network diagram of a basic leaf-spine **data center network** (**DCN**):'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将概述如何在典型的数据中心环境中自动化Arista交换机，采用叶脊架构。我们将探讨如何使用Ansible与Arista设备进行交互，以及如何使用各种Ansible模块在Arista交换机上部署**虚拟局域网**（**VLANs**）和**虚拟可扩展局域网**（**VXLANs**），并在Arista交换机上使用**边界网关协议/以太网虚拟专用网络**（**BGP/EVPN**）设置。我们将以以下示例网络图为基础，说明基本叶脊**数据中心网络**（**DCN**）的示例网络图：
- en: '![](assets/c1fb1ade-4c7d-4961-ad9d-24c18b2d42d8.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c1fb1ade-4c7d-4961-ad9d-24c18b2d42d8.png)'
- en: 'The following table outlines the devices in our sample topology and their respective
    management **internet protocols** (**IPs**):'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格概述了我们示例拓扑中的设备及其各自的管理**互联网协议**（**IP**）：
- en: '| **Device** | **Role** | **Vendor** | **Management (MGMT) Port** | **MGMT
    IP** |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| **设备** | **角色** | **供应商** | **管理（MGMT）端口** | **MGMT IP** |'
- en: '| Spine01 | Spine Switch | Arista vEOS 4.20 | Management1 | `172.20.1.35` |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| Spine01 | 脊柱交换机 | Arista vEOS 4.20 | Management1 | `172.20.1.35` |'
- en: '| Spine02 | Spine Switch | Arista vEOS 4.20 | Management1 | `172.20.1.36` |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| Spine02 | 脊柱交换机 | Arista vEOS 4.20 | Management1 | `172.20.1.36` |'
- en: '| Leaf01 | Leaf Switch | Arista vEOS 4.20 | Management1 | `172.20.1.41` |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| Leaf01 | 叶子交换机 | Arista vEOS 4.20 | Management1 | `172.20.1.41` |'
- en: '| Leaf02 | Leaf Switch | Arista vEOS 4.20 | Management1 | `172.20.1.42` |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| Leaf02 | 叶子交换机 | Arista vEOS 4.20 | Management1 | `172.20.1.42` |'
- en: '| Leaf03 | Leaf Switch | Arista vEOS 4.20 | Management1 | `172.20.1.43` |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| Leaf03 | 叶子交换机 | Arista vEOS 4.20 | Management1 | `172.20.1.43` |'
- en: '| Leaf04 | Leaf Switch | Arista vEOS 4.20 | Management1 | `172.20.1.44` |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| Leaf04 | 叶子交换机 | Arista vEOS 4.20 | Management1 | `172.20.1.44` |'
- en: 'The main recipes covered in this chapter are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要配方如下：
- en: Building the Ansible network inventory
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Ansible网络清单
- en: Connecting to and authenticating Arista devices from Ansible
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到并使用Ansible对Arista设备进行身份验证
- en: Enabling **extensible operating system** (**EOS**) **API** (**eAPI**) on Arista
    devices
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Arista设备上启用**可扩展操作系统**（**EOS**）**API**（**eAPI**）
- en: Configuring generic system options on Arista devices
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Arista设备上配置通用系统选项
- en: Configuring interfaces on Arista devices
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Arista设备上配置接口
- en: Configuring the underlay BGP on Arista devices
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Arista设备上配置底层BGP
- en: Configuring the overlay BGP/EVPN on Arista devices
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Arista设备上配置覆盖BGP/EVPN
- en: Deploying the configuration on Arista devices
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Arista设备上部署配置
- en: Configuring VLANs on Arista devices
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Arista设备上配置VLAN
- en: Configuring VXLAN tunnels on Arista devices
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Arista设备上配置VXLAN隧道
- en: Gathering Arista device facts
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集Arista设备信息
- en: Retrieving operational data from Arista devices
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Arista设备检索操作数据
- en: Technical requirements
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for all the recipes in this chapter can be found on the following
    GitHub repo:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有配方的代码可以在以下GitHub存储库中找到：
- en: '[https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch4_arista](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch4_arista).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch4_arista](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch4_arista).'
- en: 'This chapter is based on the following software releases:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于以下软件版本：
- en: Ansible machine running CentOS 7
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行CentOS 7的Ansible机器
- en: Ansible 2.9
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 2.9
- en: Arista **virtualized EOS** (**vEOS**) running EOS 4.20.1F
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arista **虚拟化EOS**（**vEOS**）运行EOS 4.20.1F
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频以查看代码的实际操作：
- en: '[https://bit.ly/3coydTp](https://bit.ly/3coydTp)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/3coydTp](https://bit.ly/3coydTp)'
- en: Building the Ansible network inventory
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Ansible网络清单
- en: In this recipe, we will outline how to build and structure the Ansible inventory
    to describe our sample leaf-spine **direct current** (**DC**) network. The Ansible
    inventory is a pivotal part of Ansible as it outlines and groups devices that
    should be managed by Ansible.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将概述如何构建和组织Ansible清单，以描述我们示例的叶脊**直流**（**DC**）网络。Ansible清单是Ansible的重要组成部分，它描述并分组应由Ansible管理的设备。
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to create a new folder that will host all the files that we will create
    in this chapter. The new folder should be named `ch4_arista`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的文件夹，用于存放本章中将创建的所有文件。新文件夹的名称应为`ch4_arista`。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Inside the new folder (`ch4_arista`), we create a `hosts` file with the following
    content:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹（`ch4_arista`）中，我们创建一个带有以下内容的`hosts`文件：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create an `ansible.cfg` file, as shown in the following code block:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ansible.cfg`文件，如下面的代码块所示：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Defining an Ansible inventory is mandatory, in order to describe and classify
    the devices in our network that should be managed by Ansible. In the Ansible inventory,
    we also specify the IP addresses through which Ansible will communicate with these
    managed devices, using the `ansible_host` parameter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 定义Ansible清单是强制性的，以便描述和分类应由Ansible管理的网络中的设备。在Ansible清单中，我们还通过`ansible_host`参数指定Ansible将与这些受管设备通信的IP地址。
- en: 'We built the Ansible inventory using the `hosts` file and we defined multiple
    groups in order to group the different devices in our topology. These groups are
    as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`hosts`文件构建了Ansible清单，并定义了多个组，以便对我们拓扑中的不同设备进行分组。这些组如下：
- en: We created the `leaf` group, which references all the `leaf` switches in our
    topology.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了`leaf`组，它引用了我们拓扑中的所有`leaf`交换机。
- en: We created the `spine` group, which references all the `spine` switches in our
    topology.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了`spine`组，它引用了我们拓扑中的所有`spine`交换机。
- en: We created the `arista` group, which references both the `leaf` and `spine`
    groups.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了`arista`组，它引用了`leaf`和`spine`两个组。
- en: Finally, we created the `ansible.cfg` file and configured it to point to our
    `hosts` file, to be used as the Ansible inventory file. Further, we disabled the
    `setup` module (by setting `gathering` to `explicit)`, which is not needed when
    running Ansible against network nodes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了`ansible.cfg`文件，并配置它指向我们的`hosts`文件，用作Ansible清单文件。此外，我们禁用了`setup`模块（通过将`gathering`设置为`explicit`），这在针对网络节点运行Ansible时是不需要的。
- en: Connecting to and authenticating Arista devices from Ansible
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Ansible连接和认证Arista设备
- en: In this recipe, we will outline how to connect to Arista devices from Ansible
    via **Secure Shell** (**SSH**) in order to start managing the devices from Ansible.
    We are going to use a username and password to authenticate the Arista devices
    in our topology.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将概述如何通过**安全外壳**（**SSH**）从Ansible连接到Arista设备，以便从Ansible开始管理这些设备。我们将使用用户名和密码来对我们拓扑中的Arista设备进行认证。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to follow along with this recipe, an Ansible inventory file should
    be constructed as per the previous recipe. IP reachability between the Ansible
    control machine and all the devices in the network must also be implemented.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按照这个示例进行操作，应该按照之前的示例构建一个Ansible清单文件。Ansible控制机与网络中所有设备之间的IP可达性也必须得到实现。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Inside the `ch4_arista` folder, create a `group_vars` folder.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ch4_arista`文件夹中创建一个`group_vars`文件夹。
- en: 'Inside the `group_vars` folder, create an `arista.yml` file with the following
    content:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`group_vars`文件夹中，创建一个名为`arista.yml`的文件，包含以下内容：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On the Arista switches, we configure the username and password and enable SSH,
    as shown in the following code block:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Arista交换机上，我们配置了用户名和密码，并启用了SSH，如下所示：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On the Arista switches, configure the management interface with the correct
    IP addresses and place them in the required management **virtual routing and forwarding**
    (**VRF**), as shown here:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Arista交换机上，使用正确的IP地址配置管理接口，并将它们放置在所需的管理**虚拟路由和转发**（**VRF**）中，如下所示：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We specified the username and password that we will configure on all the Arista
    switches in the `arista.yml` file under the `group_vars` directory. This will
    apply these parameters to all the Arista switches in our inventory. On the Arista
    switches, we set up the username and password and enabled SSH, as well as set
    up the correct IP address (the one used in the `ansible_host` parameter in our
    inventory) on the management interface. We configured the management VRF and associated
    the management interface with this VRF.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`group_vars`目录下的`arista.yml`文件中指定了我们将在所有Arista交换机上配置的用户名和密码。这将应用这些参数到我们清单中的所有Arista交换机。在Arista交换机上，我们设置了用户名和密码并启用了SSH，并在管理接口上设置了正确的IP地址（在我们的清单中使用的`ansible_host`参数中使用的IP地址）。我们配置了管理VRF，并将管理接口与此VRF关联起来。
- en: We are specifying the SSH password in plaintext in our Ansible variables. This
    is only for a lab setup; however, for production, we should use the Ansible vault
    to secure any sensitive information, as outlined in the previous chapters.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Ansible变量中以明文指定了SSH密码。这只适用于实验室设置；然而，在生产环境中，我们应该使用Ansible vault来保护任何敏感信息，就像在前面的章节中概述的那样。
- en: 'At this stage, we are using the `network_cli` connection method so as to use
    SSH to connect to the Arista switches. We can verify that the Ansible controller
    can reach and correctly log in to the devices with the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们使用`network_cli`连接方法来使用SSH连接到Arista交换机。我们可以使用以下命令验证Ansible控制器是否能够到达并正确登录到设备：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Enabling eAPI on Arista devices
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Arista设备上启用eAPI
- en: In this recipe, we will outline how to enable eAPI on Arista devices. eAPI is
    a **representational state transfer** (**REST**ful) API on Arista devices, which
    simplifies the management of such devices and provides a consistent and robust
    API to manage them. This task is critical since we will use eAPI in all future
    recipes to manage the Arista device.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将概述如何在Arista设备上启用eAPI。eAPI是Arista设备上的**表述状态传输**（**REST**ful）API，它简化了这些设备的管理，并提供了一个一致且强大的API来管理它们。这个任务非常关键，因为我们将在以后的示例中使用eAPI来管理Arista设备。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As a prerequisite for this recipe, an Ansible inventory file must be present.
    The SSH authentication should also be deployed and working, as per the previous
    recipe.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个示例的先决条件，必须存在一个Ansible清单文件。SSH认证也应该已经部署并且正常工作，就像之前的示例一样。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Create an `all.yml` file inside the `group_vars` folder, with the following
    management VRF data:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`group_vars`文件夹中创建一个名为`all.yml`的文件，其中包含以下管理VRF数据：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a new playbook called `pb_eos_enable_eapi.yml`, as shown in the following
    code block:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pb_eos_enable_eapi.yml`的新playbook，如下所示：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Update the `pb_eos_enable_eapi.yml` playbook with the following task, to enable
    eAPI under the management VRF:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下任务更新`pb_eos_enable_eapi.yml` playbook，以在管理VRF下启用eAPI：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Update the `arista.yml` file inside the `group_vars` folder with the connection
    setting to use eAPI as the connection plugin:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`group_vars`文件夹中更新`arista.yml`文件，设置连接设置以使用eAPI作为连接插件：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In order to start interacting with the Arista devices via eAPI, we need to enable
    it first; thus, we need to SSH into the device initially and enable eAPI. That
    is why, in this recipe, we are using the `network_cli` Ansible connection in order
    to connect with the Arista devices via traditional SSH. Since we are going to
    use eAPI in all interactions with Arista devices in all coming recipes, we enabled `network_cli`
    only under the `vars` parameter on the playbook level, in order to override any
    group- or host-level setting for the `ansible_connection` setting.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始通过eAPI与Arista设备进行交互，我们首先需要启用它；因此，我们需要首先通过SSH登录到设备并启用eAPI。这就是为什么在这个示例中，我们使用`network_cli`
    Ansible连接来通过传统的SSH连接到Arista设备。由于我们将在所有未来的示例中使用eAPI与Arista设备进行交互，我们只在playbook级别的`vars`参数下启用了`network_cli`，以覆盖`ansible_connection`设置的任何组或主机级别的设置。
- en: We created a new playbook called `pb_eos_enable_eapi.yml`, and, in the first
    task, we used the `eos_eapi` module to enable eAPI protocol on the remote Arista
    devices. We specified that we will use the **Hypertext Transfer Protocol Secure**
    (**HTTPS**) and the standard HTTPS port, which is `443`. In the second task, we
    used the `eos_eapi` module in order to enable eAPI only under a specific VRF,
    which is the management VRF that we are using to manage our devices.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`pb_eos_enable_eapi.yml`的新playbook，在第一个任务中，我们使用了`eos_eapi`模块来在远程Arista设备上启用eAPI协议。我们指定将使用**超文本传输安全协议**（**HTTPS**）和标准的HTTPS端口`443`。在第二个任务中，我们使用了`eos_eapi`模块，以在特定的VRF下仅启用eAPI，这是我们用来管理设备的管理VRF。
- en: 'Finally, in order to start managing the Arista devices using eAPI, we modified
    our Ansible connection settings, which we defined in the `group_vars/arista.yml`
    file, and we included the following settings:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了开始使用eAPI管理Arista设备，我们修改了Ansible连接设置，这些设置我们在`group_vars/arista.yml`文件中定义，并包括以下设置：
- en: '`ansible_connection` was set to `httpapi`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_connection`设置为`httpapi`。'
- en: '`ansible_httpapi_use_ssl` was set to `yes` in order to force the use of HTTPS
    and not HTTP.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_httpapi_use_ssl`设置为`yes`，以强制使用HTTPS而不是HTTP。'
- en: '`ansible_httpapi_validate_certs` was set to `no` in order to disable certificate
    validations (since we are using the default certificate on the Arista devices,
    which is not signed by a trusted **certificate authority** (**CA**)).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_httpapi_validate_certs`设置为`no`，以禁用证书验证（因为我们使用的是Arista设备上的默认证书，该证书未经受信任的**证书颁发机构**（**CA**）签名）。'
- en: 'Once we run the playbook, we will see that all the Arista devices are configured
    with eAPI, as shown in the following code block:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行了playbook，我们将看到所有Arista设备都配置了eAPI，如下面的代码块所示：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can validate that we are using the correct connection setting and that Ansible
    is able to communicate with the Arista devices using eAPI with the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令验证我们是否使用了正确的连接设置，并且Ansible能够使用eAPI与Arista设备进行通信：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See also...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: For more information regarding the `eos_eapi` module and the different parameters
    supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/eos_eapi_module.html](https://docs.ansible.com/ansible/latest/modules/eos_eapi_module.html).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`eos_eapi`模块以及该模块支持的不同参数的更多信息，请参考以下网址：[https://docs.ansible.com/ansible/latest/modules/eos_eapi_module.html](https://docs.ansible.com/ansible/latest/modules/eos_eapi_module.html)。
- en: Configuring generic system options on Arista devices
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Arista设备上配置通用系统选项
- en: In this recipe, we will outline how to configure some basic system options such
    as hostname and **Domain Name System** (**DNS**) servers, and provision users
    on Arista devices. We will understand how to set up all these system-level parameters
    using the various Ansible modules, and we will outline the different ways to manage
    these parameters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将概述如何配置一些基本的系统选项，比如主机名和**域名系统**（**DNS**）服务器，并在Arista设备上配置用户。我们将了解如何使用各种Ansible模块设置所有这些系统级参数，并概述管理这些参数的不同方法。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow along with this recipe, it is assumed that an Ansible inventory has
    already been set up and eAPI is enabled on all Arista devices, as per the previous
    recipe.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个示例进行操作，假定已经设置了Ansible清单，并且根据之前的示例在所有Arista设备上启用了eAPI。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Update the `group_vars/all.yml` file with the generic system parameters, as
    shown in the following code block:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`group_vars/all.yml`文件，使用通用系统参数，如下面的代码块所示：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a new playbook, `pb_arista_basic_config.yml`, and add the following
    task to set up the DNS and the hostname:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的playbook，`pb_arista_basic_config.yml`，并添加以下任务来设置DNS和主机名：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Update the `pb_arista_basic_config.yml` playbook with the following task to
    create users on the Arista devices:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`pb_arista_basic_config.yml` playbook，添加以下任务以在Arista设备上创建用户：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Ansible provides different declarative modules in order to manage the different
    resources on the Arista switches. In this recipe, we outlined how to use the `eos_system`
    and the `eos_user` Ansible modules in order to provision basic system attributes
    on the Arista devices. We started by defining the data that we will use under
    the `group_vars/all.yml` file, and we included the DNS and users that we want
    to provision. We created the `pb_arista_basic_config.yml` playbook, which will
    include all the tasks needed in order to set up the basic settings on the Arista
    switches.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible提供了不同的声明性模块，以管理Arista交换机上的不同资源。在这个示例中，我们概述了如何使用`eos_system`和`eos_user`
    Ansible模块来配置Arista设备上的基本系统属性。我们首先在`group_vars/all.yml`文件中定义了要使用的数据，并包括我们想要配置的DNS和用户。我们创建了`pb_arista_basic_config.yml`
    playbook，其中包括了设置Arista交换机上基本设置所需的所有任务。
- en: The first task in the playbook used the `eos_system` Ansible module, which sets
    up the DNS and the hostname on all the Arista devices. The second task used the
    `eos_user` Ansible module to set up the system users on the Arista switches. In
    this last task, we looped over the `users` data structure that we defined in the
    `group_vars/all.yml` file in order to provision each user in this `list` data
    structure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: playbook中的第一个任务使用了`eos_system` Ansible模块，在所有Arista设备上设置了DNS和主机名。第二个任务使用了`eos_user`
    Ansible模块，在Arista交换机上设置了系统用户。在最后一个任务中，我们循环遍历了在`group_vars/all.yml`文件中定义的`users`数据结构，以在这个`list`数据结构中为每个用户进行配置。
- en: 'Once we run the playbook, we can see that the configuration of our Arista switches
    is updated, as shown in the following code block:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行了playbook，我们可以看到Arista交换机的配置已更新，如下面的代码块所示：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There's more...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The declarative Ansible modules that we have outlined in this section provide
    a simple way to configure the basic system-level parameters for Arista devices;
    however, they might not cover all the parameters that we need to set up on an
    Arista switch. In order to have more control and flexibility to configure the
    system-level parameters, we can use Jinja2 templates along with the `template` Ansible
    module to generate the specific system-level configuration needed for our deployment.
    In this section, we will outline this method in order to achieve this goal. This
    will be the method that we will use in subsequent recipes to generate the configuration
    for other configuration sections, which don't have a built-in Ansible module that
    can satisfy all our requirements.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们概述了声明性的Ansible模块，它们提供了一种简单的方法来配置Arista设备的基本系统级参数；但是，它们可能无法涵盖我们需要在Arista交换机上设置的所有参数。为了更多地控制和灵活地配置系统级参数，我们可以使用Jinja2模板以及`template`
    Ansible模块来生成我们部署所需的特定系统级配置。在本节中，我们将概述这种方法以实现这一目标。这将是我们在后续的配方中使用的方法，用于生成其他配置部分的配置，这些部分没有内置的Ansible模块可以满足我们的所有要求。
- en: 'We are going to reuse this method to generate the configuration for our Arista
    devices for different sections such as system, interfaces, and BGP. We are going
    to create an Ansible role in order to include all the Jinja2 templates and tasks
    required to generate the final configuration that we will push to our devices.
    The following procedure outlines the steps needed to create the role, and the
    playbook required to generate the configuration:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用这种方法为Arista设备生成不同部分的配置，例如系统、接口和BGP。我们将创建一个Ansible角色，以包含生成我们将推送到设备的最终配置所需的所有Jinja2模板和任务。以下过程概述了创建角色所需的步骤以及生成配置所需的playbook：
- en: We are going to use the same role structure and tasks that we used in [Chapter
    3](5e423ab2-1c5d-430d-a02d-7838c39c931a.xhtml), *Automating Juniper Devices in
    the Service Providers Using Ansible,* to generate the Juniper devices' configuration.
    The only difference will be in the Jinja2 templates that we will use to generate
    the specific configuration for Arista devices.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与[第3章](5e423ab2-1c5d-430d-a02d-7838c39c931a.xhtml)中使用的相同的角色结构和任务，*使用Ansible自动化服务提供商中的Juniper设备*，来生成Juniper设备的配置。唯一的区别在于我们将使用Jinja2模板来生成Arista设备的特定配置。
- en: 'Create a new `roles` directory and add a new role called `dc_fabirc_config`,
    with the following directory structure:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`roles`目录，并添加一个名为`dc_fabirc_config`的新角色，具有以下目录结构：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `tasks` folder, create a `build_config_dir.yml` file to create the required
    folders to store the configuration that will be generated, as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tasks`文件夹中，创建一个`build_config_dir.yml`文件，以创建所需的文件夹来存储将生成的配置，如下所示：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `templates` folder, create a new folder called `eos`, and within this
    folder, create a new Jinja2 template called `mgmt.j2`, as shown in the following
    code block:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates`文件夹中，创建一个名为`eos`的新文件夹，在该文件夹中创建一个名为`mgmt.j2`的新的Jinja2模板，如下面的代码块所示：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `tasks` folder, create a new YAML file called `build_device_config.yml`
    to create a system configuration, as shown in the following code block:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tasks`文件夹中，创建一个名为`build_device_config.yml`的新的YAML文件，以创建系统配置，如下面的代码块所示：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a `main.yml` file in the `tasks` folder, with the following tasks:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tasks`文件夹中创建一个`main.yml`文件，其中包含以下任务：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a new playbook called `pb_arista_dc_fabric.yml` to generate the configuration
    for all `arista` devices in our inventory:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pb_arista_dc_fabric.yml`的新playbook，以生成清单中所有`arista`设备的配置：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using this method, we created a role called `dc_fabric_config` and we created
    a new Jinja2 template called `mgmt.j2`, which includes the template for `arista`
    system-level configuration. We used the `template` Ansible module in order to
    render the Jinja2 template with the Ansible variables defined under the `group_vars/all.yml`
    file. In order to save the configuration for each device, we created the `configs`
    folder directory, which stores the final configuration for each device.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们创建了一个名为`dc_fabric_config`的角色，并创建了一个名为`mgmt.j2`的新的Jinja2模板，其中包含`arista`系统级配置的模板。我们使用`template`
    Ansible模块来使用在`group_vars/all.yml`文件中定义的Ansible变量渲染Jinja2模板。为了保存每个设备的配置，我们创建了`configs`文件夹目录，用于存储每个设备的最终配置。
- en: Since we are utilizing the Jinja2 approach in order to generate the configuration
    for each section (MGMT, interfaces, BGP, and so on), we will segment each section
    into a separate Jinja2 template and we will generate each section in a separate
    file. We use the `assemble` module in order to group all these different sections
    into a single configuration file, which we will store in the `configs` directory,
    and this is the final and assembled configuration file for each device. We store
    the temporarily assembled sections in a temporary folder for each device, and
    we delete this temporary folder at the end of the playbook run.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在利用Jinja2方法来为每个部分（MGMT、接口、BGP等）生成配置，我们将每个部分分成单独的Jinja2模板，并将每个部分生成到单独的文件中。我们使用`assemble`模块来将所有这些不同的部分组合成单个配置文件，我们将其存储在`configs`目录中，这是每个设备的最终和组装的配置文件。我们将每个设备的临时组装部分存储在临时文件夹中，并在playbook运行结束时删除此临时文件夹。
- en: In this playbook, we use the `delegate_to` localhost in the `import_role` task.
    Since in all the tasks within this role we don't need to connect to the remote
    device, all these tasks should be run on the Ansible control machine so as to
    store the file locally on the Ansible machine. Thus, we use the `delegate_to` localhost
    in order to run all the tasks on the Ansible control machine.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在此playbook中，我们在`import_role`任务中使用`delegate_to` localhost。由于在此角色中的所有任务中我们不需要连接到远程设备，因此所有这些任务应在Ansible控制机上运行，以便将文件存储在Ansible机器上。因此，我们使用`delegate_to`
    localhost来在Ansible控制机上运行所有任务。
- en: 'Once we run the `pb_junos_net_build.yml` playbook, we can see that the following
    configuration files are created inside the `configs` directory and, at this stage,
    it has only the management section of the configuration:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行`pb_junos_net_build.yml` playbook，我们可以看到在`configs`目录中创建了以下配置文件，目前只有配置的管理部分：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can check the configuration generated for one of the devices (`leaf01`,
    for example), as shown in the following code block:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看为其中一个设备（例如`leaf01`）生成的配置，如下面的代码块所示：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At this stage, we have generated the system configuration for all the `arista`
    switches in our inventory; however, we still haven't pushed this configuration
    to the devices. In later recipes, we will outline how to push the configuration
    to the `arista` devices.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经为清单中的所有`arista`交换机生成了系统配置；然而，我们仍然没有将这个配置推送到设备上。在后续的配方中，我们将概述如何将配置推送到`arista`设备。
- en: Configuring interfaces on Arista devices
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Arista设备上配置接口
- en: In this recipe, we will outline how to configure different interface parameters
    on Arista devices, such as the interface description and IP address information.
    We will outline how to use the various Ansible modules to interact with the interfaces
    on Arista devices, and how to set up the interfaces on all the Arista devices
    in our sample network topology.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将概述如何在Arista设备上配置不同的接口参数，比如接口描述和IP地址信息。我们将概述如何使用各种Ansible模块与Arista设备上的接口进行交互，以及如何在样本网络拓扑中的所有Arista设备上设置接口。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are assuming the network inventory is already in place and that eAPI is already
    enabled on Arista switches, as per the previous recipes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设网络清单已经就位，并且在Arista交换机上已经启用了eAPI，就像之前的配方一样。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Add the following content to the `group_vars/all.yml` file, which describes
    the interfaces on our sample DC fabric network:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`group_vars/all.yml`文件中添加以下内容，描述样本DC网络中的接口：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Update the `pb_arista_basic_config.yml` playbook with the following task to
    enable the interfaces and set the description on all the fabric interfaces:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`pb_arista_basic_config.yml` playbook，添加以下任务以启用接口并在所有布线接口上设置描述：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Update the `pb_arista_basic_config.yml` playbook with the following task to
    set up the IPv4 address on all the **point-to-point** (**P2P**) fabric links:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`pb_arista_basic_config.yml` playbook，添加以下任务以在所有**点对点**（**P2P**）布线链路上设置IPv4地址：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We defined all the data for all the interfaces in our sample network topology
    in two main data structures in the `group_vars/all.yml` file. We used the `p2p_ip`
    dictionary to model all the P2P IP addresses in our sample network, and we used
    the `lo_ip` dictionary to specify the loopback IP addresses for our nodes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`group_vars/all.yml`文件中的两个主要数据结构中定义了样本网络拓扑中所有接口的所有数据。我们使用`p2p_ip`字典来模拟样本网络中所有P2P
    IP地址，并使用`lo_ip`字典来指定节点的环回IP地址。
- en: We used the `eos_interface` Ansible module to enable the interfaces and set
    the basic parameters for the interfaces, such as interface description. We looped
    over the `p2p_ip` data structure for each device, and we set the correct parameters
    for each interface on all the devices in our network inventory. We used the `eos_l3_interface`
    Ansible module to set the correct IPv4 address on all the interfaces in our sample
    network topology across all the devices.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`eos_interface` Ansible模块来启用接口并设置接口的基本参数，比如接口描述。我们遍历了每个设备的`p2p_ip`数据结构，并为网络清单中的所有设备上的每个接口设置了正确的参数。我们使用`eos_l3_interface`
    Ansible模块在样本网络拓扑中的所有设备上设置了正确的IPv4地址。
- en: There's more...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多信息...
- en: In case we need to have more control over the interface configuration and to
    set parameters that are not covered by the declarative Ansible modules that we
    have outlined in this section, we can use Jinja2 templates to achieve this goal.
    Using the exact same approach that we outlined in the previous recipe for system
    configuration, we can generate the interface configuration needed for our Juniper
    devices.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要更多地控制接口配置，并设置声明性Ansible模块中未涵盖的参数，我们可以使用Jinja2模板来实现这个目标。使用与前一节中系统配置相同的方法，我们可以为Juniper设备生成所需的接口配置。
- en: 'Using the same Ansible role that we have created in the previous recipe, we
    can extend it to generate the interface configuration for our Arista devices.
    We use the following steps in order to accomplish this task:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前一节中创建的相同Ansible角色，我们可以扩展它以生成Arista设备的接口配置。我们使用以下步骤来完成这项任务：
- en: 'Create a new Jinja2 template file, `intf.js`, in the `templates` folder, with
    the following data:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates`文件夹中创建一个名为`intf.js`的新Jinja2模板文件，内容如下：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Update the `build_device_config.yml` file in the `tasks` directory with the
    new task to generate the interface configuration:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tasks`目录中更新`build_device_config.yml`文件，添加新任务以生成接口配置：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once we run our `pb_arista_dc_fabric.yml` playbook, we will generate the configuration
    for our devices, with the `interface` section updated for `leaf01`, as an example:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们运行`pb_arista_dc_fabric.yml` playbook，我们将为我们的设备生成配置，例如为`leaf01`更新了`interface`部分：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: See also...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: For more information regarding the `eos_interface` module and the different
    parameters supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/eos_interface_module.html](https://docs.ansible.com/ansible/latest/modules/eos_interface_module.html).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`eos_interface`模块以及该模块支持的不同参数的更多信息，请参考以下网址：[https://docs.ansible.com/ansible/latest/modules/eos_interface_module.html](https://docs.ansible.com/ansible/latest/modules/eos_interface_module.html)。
- en: For more information regarding the `eos_l3_interface` module and the different
    parameters supported by this module, please, consult the following URL: [https://docs.ansible.com/ansible/latest/modules/eos_l3_interface_module.html](https://docs.ansible.com/ansible/latest/modules/eos_l3_interface_module.html).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`eos_l3_interface`模块以及此模块支持的不同参数的更多信息，请参阅以下网址：[https://docs.ansible.com/ansible/latest/modules/eos_l3_interface_module.html](https://docs.ansible.com/ansible/latest/modules/eos_l3_interface_module.html)。
- en: Configuring the underlay BGP on Arista devices
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Arista设备上配置底层BGP
- en: 'In this recipe, we will outline how to configure eBGP as the underlay routing
    protocol for our sample leaf/spine DC fabric. We are going to build the eBGP peering
    setup, using the P2P IP address between the leaf switches and spine switches.
    The BGP **autonomous system number** (**ASN**) assignment is as shown in the following
    table:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将概述如何为我们样例叶/脊柱DC结构配置eBGP作为底层路由协议。我们将建立eBGP对等设置，使用叶交换机和脊柱交换机之间的P2P IP地址。BGP自治系统号（ASN）分配如下表所示：
- en: '| **Node** | **BGP ASN** |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '**节点**  **BGP ASN**'
- en: '| Spine01 | 65100 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: 'Spine01  65100 '
- en: '| Spine02 | 65100 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: Spine02  65100
- en: '| Leaf01 | 65001 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: 'Leaf01  65001 '
- en: '| Leaf02 | 65002 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: 'Leaf02  65002 '
- en: '| Leaf03 | 65003 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: 'Leaf03  65003 '
- en: '| Leaf04 | 65004 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: 'Leaf04  65004 '
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we are assuming that the interface and IP address information
    is already configured, as per the previous recipe.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们假设接口和IP地址信息已根据以前的教程进行了配置。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Create a `host_vars` directory and create a folder for each device in our inventory.
    In each folder, create a new YAML file, `underlay_bgp.yml`, with the BGP peering
    details. Here is an example for the `leaf01` device in our inventory:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`host_vars`目录，并为清单中的每个设备创建一个文件夹。在每个文件夹中，创建一个名为`underlay_bgp.yml`的新的YAML文件，其中包含BGP对等详细信息。以下是我们清单中`leaf01`设备的一个示例：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a new Jinja2 file, `underlay_bgp.j2`, in the `templates/eos` directory,
    with the following data. This template is for the `prefix-list` that we will use
    to control BGP advertisement in our DC fabric:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates/eos`目录中创建一个名为`underlay_bgp.j2`的新的Jinja2文件，其中包含以下数据。这个模板是我们将用来控制DC结构中BGP广播的`prefix-list`：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Update the `underlay_bgp.j2` Jinja2 file in the `templates/eos` directory with
    the BGP template, as shown in the following code block:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates/eos`目录中更新`underlay_bgp.j2` Jinja2文件，其中包含以下代码块中显示的BGP模板：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the `build_config.yml` file inside the `tasks` folder, add the following
    task to render the underlay BGP configuration:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tasks`文件夹中的`build_config.yml`文件中，添加以下任务以呈现底层BGP配置：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As per our design, we are going to run eBGP between the leaf and spine nodes,
    and each leaf switch in our topology will have its own BGP ASN. The optimal method
    to describe this setup is to include all this data on a per-host basis, using
    the `host_vars` folder. We created a folder for each node to include all the relevant
    host data under this folder. We created a YAML file to hold the BGP information
    for each device, thus we can easily add a new file if we need to add more host-specific
    data for another protocol:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的设计，我们将在叶和脊柱节点之间运行eBGP，并且我们拓扑中的每个叶交换机都将有自己的BGP ASN。描述这种设置的最佳方法是使用`host_vars`文件夹在每个主机基础上包含所有这些数据。我们为每个节点创建了一个文件夹，以在此文件夹下包含所有相关的主机数据。我们创建了一个YAML文件来保存每个设备的BGP信息，因此如果需要为另一个协议添加更多主机特定数据，我们可以轻松地添加一个新文件：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the `tasks/build_device_config.yml` file, we added a new task that uses the `underlay_bgp.j2` Jinja2
    template to render the Jinja2 template and output the underlay BGP configuration
    section for each device outlined in our Ansible inventory.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tasks/build_device_config.yml`文件中，我们添加了一个新任务，该任务使用`underlay_bgp.j2` Jinja2模板来呈现Jinja2模板，并输出我们Ansible清单中每个设备的底层BGP配置部分。
- en: 'For each device, we generated a `prefix-list` to match all the prefixes that
    will advertise to its eBGP peers, as per the following criteria:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个设备，我们生成了一个`prefix-list`来匹配将广播到其eBGP对等体的所有前缀，具体标准如下：
- en: For spine switches, we advertise all the leaf loopback IP addresses along with
    the spine loopback interface.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于脊柱交换机，我们会广播所有叶回环IP地址以及脊柱回环接口。
- en: For the leaf switches, we advertise only the loopback IP address.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于叶交换机，我们只会广播回环IP地址。
- en: 'The following snippet outlines the BGP configuration generated for the `leaf01`
    device after running the playbook with the new task:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行新任务的playbook后，以下片段概述了`leaf01`设备生成的BGP配置：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Configuring the overlay BGP EVPN on Arista devices
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Arista设备上配置覆盖BGP EVPN
- en: In this recipe, we will outline how to configure the overlay BGP EVPN as the
    control plane for VXLAN tunnels across our leaf-spine DC fabric in our sample
    topology, using Ansible.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个教程中，我们将概述如何使用Ansible在我们的样例拓扑中为VXLAN隧道的叶脊柱DC结构配置覆盖BGP EVPN作为控制平面。 '
- en: Getting ready
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes the P2P IP addresses and loopback interfaces have been configured
    as per previous recipes. Also, the underlay BGP configuration should already be
    generated as per the previous recipe.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程假设P2P IP地址和回环接口已根据以前的教程进行了配置。此外，底层BGP配置应该已经根据以前的教程生成。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Create a new Jinja2 file, `overlay_bgp.j2`, in the `templates/eos` directory,
    with the following data:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates/eos`目录中创建一个名为`overlay_bgp.j2`的新的Jinja2文件，其中包含以下数据：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `build_config.yml` file inside the `tasks` folder, add the following
    highlighted task:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tasks`文件夹中的`build_config.yml`文件中，添加以下突出显示的任务：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we used a similar methodology to how we configured the underlay
    eBGP. We built a Jinja2 template to generate the needed BGP EVPN configuration
    for the Arista devices in our inventory. The following code block shows a sample
    of the BGP EVPN configuration for the `leaf01` switch:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们使用了类似的方法来配置底层eBGP的方法。我们构建了一个Jinja2模板，用于为清单中的Arista设备生成所需的BGP EVPN配置。以下代码块显示了`leaf01`交换机的BGP
    EVPN配置示例：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Deploying the configuration on Arista devices
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Arista设备上部署配置
- en: In this recipe, we will outline how to push the configuration to the Arista
    devices. We will use the configuration that we have generated in the previous
    recipes to provision the devices in our topology. We will learn how to interact
    with the Arista configuration using the suitable Ansible module, in order to correctly
    provision the devices as per the intended network design.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将概述如何将配置推送到Arista设备。我们将使用在之前的教程中生成的配置来为我们的拓扑中的设备进行配置。我们将学习如何使用适当的Ansible模块与Arista配置进行交互，以便根据预期的网络设计正确配置设备。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires eAPI to be enabled on the Arista devices.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程要求在Arista设备上启用eAPI。
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the `pb_arista_dc_fabric.yml` file, add the following task to deploy the
    configuration to the Arista switches:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pb_arista_dc_fabric.yml`文件中，添加以下任务来将配置部署到Arista交换机：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the previous recipes, we generated different sections of the configuration
    for the Arista switches, such as interfaces, and underlay/overlay BGP. We have
    used the `assemble` Ansible module in order to combine the different sections
    of the configuration into a single configuration file that holds all the device
    configurations. In this recipe, we used the `eos_config` module in order to push
    the configuration file to the Arista switch.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的教程中，我们生成了Arista交换机配置的不同部分，比如接口和底层/覆盖BGP。我们使用`assemble` Ansible模块将配置的不同部分组合成一个包含所有设备配置的单个配置文件。在这个教程中，我们使用了`eos_config`模块来将配置文件推送到Arista交换机。
- en: In the `eos_config` module, we used the `src` parameter in order to specify
    the location of the configuration file that we want to load into our devices.
    We used the `replace` directive with the `config` option in order to replace all
    the configuration on the target device with the new configuration that we specified
    in the `src` option. Thus, the configuration on the devices is completely managed
    and controlled by Ansible. This also means that if there is any configuration
    that was implemented outside of our Ansible playbook, the configuration will be
    deleted once we run the playbook and push the new configuration to the devices.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`eos_config`模块中，我们使用了`src`参数来指定我们想要加载到设备中的配置文件的位置。我们使用了`replace`指令和`config`选项来替换目标设备上的所有配置，使用`src`选项中指定的新配置。因此，设备上的配置完全由Ansible管理和控制。这也意味着，如果有任何在Ansible
    playbook之外实施的配置，一旦我们运行playbook并将新配置推送到设备上，该配置将被删除。
- en: Finally, we used the `save_when` parameter and set it to `changed` in order
    to copy the running configuration to the `startup-config` and save the configuration.
    We only perform this action in case the task changed the configuration on the
    device.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`save_when`参数并将其设置为`changed`，以便将运行配置复制到`startup-config`并保存配置。只有在任务改变了设备上的配置时，我们才执行此操作。
- en: See also...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: For more information regarding the `eos_config` module and the different parameters
    supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/eos_config_module.html](https://docs.ansible.com/ansible/latest/modules/eos_config_module.html).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`eos_config`模块和该模块支持的不同参数的更多信息，请参考以下网址：[https://docs.ansible.com/ansible/latest/modules/eos_config_module.html](https://docs.ansible.com/ansible/latest/modules/eos_config_module.html)。
- en: Configuring VLANs on Arista devices
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Arista设备上配置VLAN
- en: 'In this recipe, we will outline how to configure VLANs on Arista switches.
    The VLANs that we will build across our DC fabric are shown in the following table:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将概述如何在Arista交换机上配置VLAN。我们将在数据中心网络中构建的VLAN如下表所示：
- en: '| **Node** | **Interface** | **Interface Type** | **VLANs** |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **节点** | **接口** | **接口类型** | **VLAN** |'
- en: '| Leaf01 | Ethernet1 | Access | 10 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| Leaf01 | 以太网1 | 接入 | 10 |'
- en: '| Leaf02 | Ethernet1 | Access | 20 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| Leaf02 | 以太网1 | 接入 | 20 |'
- en: '| Leaf03 | Ethernet1 | Access | 10 |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| Leaf03 | 以太网1 | 接入 | 10 |'
- en: '| Leaf03 | Ethernet2 | Access | 20 |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| Leaf03 | 以太网2 | 接入 | 20 |'
- en: '| Leaf04 | Ethernet1 | Access | 10 |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| Leaf04 | 以太网1 | 接入 | 10 |'
- en: '| Leaf04 | Ethernet2 | Access | 20 |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| Leaf04 | 以太网2 | 接入 | 20 |'
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is assuming that underlay and overlay BGP configuration is already
    generated, as per the previous recipes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程假设底层和覆盖BGP配置已经按照之前的教程生成。
- en: How to do it...
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new YAML file called `vlan_design.yml` that will hold our VLAN design
    for our DC fabric, as shown in the following code block:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`vlan_design.yml`的新的YAML文件，用于保存我们数据中心网络设备的VLAN设计，如下所示的代码块：
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a new role, `provision_vlans`, in the `roles` folder, with the following
    structure:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`roles`文件夹中创建一个新的角色`provision_vlans`，结构如下：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the `tasks/main.yml` file, include the following task to configure the VLANs
    on our DC fabric:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`tasks/main.yml`文件中，包括以下任务来配置我们数据中心网络中的VLAN：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a new playbook, `pb_deploy_vlans.yml`, that uses the role to order to
    provision VLANs on our DC fabric, as shown in the following code block:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的playbook，`pb_deploy_vlans.yml`，使用该角色来为我们的数据中心网络中的VLAN进行配置，如下所示的代码块：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In order to provision the VLANs on our DC fabric, we modeled and defined our
    VLAN membership in a YAML file called `vlan_design.yml`. This file models all
    the VLANs across all the switches in our fabric in the `vlan_data` dictionary.
    Each key in this dictionary is the device, and the values are a list of dictionaries,
    each corresponding to a single VLAN definition.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的数据中心网络中为VLAN进行配置，我们在一个名为`vlan_design.yml`的YAML文件中对我们的VLAN成员资格进行了建模和定义。该文件对我们网络中所有交换机上的所有VLAN进行了建模，存储在`vlan_data`字典中。该字典中的每个键都是设备，值是一个字典列表，每个字典对应一个单独的VLAN定义。
- en: We created a specific role, `provision_vlans`, to provision VLANs on our fabric, and
    the initial task in this role used the `eos_vlan` Ansible module to provision
    the VLANs. We looped over the `vlan_data` specific to each node and provisioned
    these VLANs.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个特定的角色`provision_vlans`，用于在我们的网络中为VLAN进行配置，该角色中的初始任务使用了`eos_vlan` Ansible模块来配置VLAN。我们循环遍历每个节点特定的`vlan_data`并为这些VLAN进行配置。
- en: We created a `pb_deploy_vlans.yml` playbook that uses this role to deploy the
    VLANs. We read the `vlan_design.yml`  file using the `vars_files` parameter, and
    we imported the `provision_vlans` role using `import_roles`. We used the `when`
    directive in order to only call this role on the devices defined in our VLAN `design`
    file.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`pb_deploy_vlans.yml` playbook，使用这个角色来部署VLAN。我们使用`vars_files`参数读取`vlan_design.yml`文件，并使用`import_roles`导入`provision_vlans`角色。我们使用`when`指令，只在我们VLAN
    `design`文件中定义的设备上调用这个角色。
- en: 'Once we run our playbook, we can see that the VLANs are deployed across our
    fabric as outlined here for `leaf03`, as an example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行我们的playbook，我们可以看到VLAN已经部署到我们的fabric中，例如在`leaf03`中：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: See also...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: For more information regarding the `eos_vlan` module and the different parameters
    supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/eos_vlan_module.html](https://docs.ansible.com/ansible/latest/modules/eos_vlan_module.html).[ ](https://docs.ansible.com/ansible/latest/modules/eos_vlan_module.html)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`eos_vlan`模块以及此模块支持的不同参数的更多信息，请参阅以下网址：[https://docs.ansible.com/ansible/latest/modules/eos_vlan_module.html](https://docs.ansible.com/ansible/latest/modules/eos_vlan_module.html)。
- en: Configuring VXLANs tunnels on Arista devices
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Arista设备上配置VXLAN隧道
- en: 'In this recipe, we will outline how to configure VXLAN tunnels using BGP EVPN
    across our leaf-spine fabric. In an IP fabric similar to our sample topology,
    we need to have VXLAN tunnels in order to transport the L2 VLANs across our fabric.
    The following table outlines the VLAN to the **virtual network identifier** (**VNI**)
    mapping that we will use across our fabric:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将概述如何使用BGP EVPN配置VXLAN隧道，跨我们的叶脉冲fabric。在类似我们示例拓扑的IP fabric中，我们需要有VXLAN隧道来传输L2
    VLANs。以下表格概述了我们将在整个fabric中使用的VLAN到**虚拟网络标识符**（VNI）映射：
- en: '| **VLAN** | **VNI** |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| **VLAN** | **VNI** |'
- en: '| 10 | 1010 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 1010 |'
- en: '| 20 | 1020 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 1020 |'
- en: Getting ready
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is assuming that BGP EVPN is already deployed across our fabric
    and that all the VLANs are provisioned.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方假设BGP EVPN已经部署在我们的fabric中，并且所有VLAN已经配置。
- en: How to do it...
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Update the `vars/main.yml` folder in the `provision_vlans` role with the following
    variable. This will define the directory to store the VXLAN configuration:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`provision_vlans`角色的`vars/main.yml`文件中更新以下变量。这将定义存储VXLAN配置的目录：
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In our `provision_vlans` role, create a `templates` folder. Then, in it, create
    an `eos` folder. After that, create a Jinja2 `vxlan.j2` file with the following
    content:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`provision_vlans`角色中，创建一个`templates`文件夹。然后，在其中创建一个`eos`文件夹。之后，创建一个Jinja2
    `vxlan.j2`文件，内容如下：
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Update the `tasks/main.yml` file in the `provision_vlans` role with the following
    tasks to generate the VXLAN configuration:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`provision_vlans`角色的`tasks/main.yml`文件中更新以下任务，以生成VXLAN配置：
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Update the `tasks/main.yml` file with the following tasks to deploy the VXLAN
    configuration on our DC fabric switches:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下任务更新`tasks/main.yml`文件，以在我们的DC fabric交换机上部署VXLAN配置：
- en: '[PRE48]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the previous recipe, we outlined how to provision VLANs across our DC fabric.
    However, in an IP fabric, we need to have tunneling in order to transport the
    L2 VLANs across the DC fabric. In this recipe, we outlined how to build VXLAN
    tunnels using BGP EVPN in order to transport the L2 VLANs and to finish the VLAN
    provisioning task across our DC fabric.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们概述了如何在DC fabric中部署VLAN。然而，在IP fabric中，我们需要有隧道来传输L2 VLANs。在这个配方中，我们概述了如何使用BGP
    EVPN建立VXLAN隧道，以传输L2 VLANs并完成DC fabric中的VLAN配置任务。
- en: Since the VXLAN tunnels are tightly coupled with the respective VLANs, we included
    the setup of the VXLAN tunnels within our `provision_vlans` role. We used the
    Jinja2 templates and the `template` Ansible module in order to generate the VXLAN
    and BGP configuration needed on each switch to deploy our VXLAN tunnels. We created
    a new folder to house the VXLAN configuration that we will generate for each switch.
    We utilized the `template` Ansible module to render the VLAN data defined in our
    `vlan_design.yml` file with the Jinja2 template to generate the VXLAN configuration
    for each switch.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于VXLAN隧道与相应的VLAN紧密耦合，我们在`provision_vlans`角色中包括了VXLAN隧道的设置。我们使用Jinja2模板和`template`
    Ansible模块来生成每个交换机上所需的VXLAN和BGP配置。我们创建了一个新的文件夹来存放我们将为每个交换机生成的VXLAN配置。我们利用`template`
    Ansible模块，使用Jinja2模板渲染我们在`vlan_design.yml`文件中定义的VLAN数据，以生成每个交换机的VXLAN配置。
- en: 'Once we run our updated playbook, we can see that the new folder is created
    and the configuration for all our switches is generated:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行更新后的playbook，我们可以看到新的文件夹被创建，并且为所有交换机生成了配置：
- en: '[PRE49]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following code block shows a sample configuration for the VXLAN configuration,
    generated for the `leaf01` switch:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块显示了为`leaf01`交换机生成的VXLAN配置的示例配置：
- en: '[PRE50]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Gathering Arista device facts
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集Arista设备事实
- en: In this recipe, we will outline how to retrieve the basis system facts collected
    by Ansible for an Arista device running the Arista EOS software. These basic system
    facts provide us with a basic health check regarding our Arista devices, which
    we can use to validate its operational state.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将概述如何检索由Ansible收集的Arista设备的基本系统事实，运行Arista EOS软件。这些基本系统事实为我们提供了关于Arista设备的基本健康检查，我们可以用来验证其操作状态。
- en: Getting ready
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: eAPI must be enabled on the Arista devices so you can use the Ansible modules
    in this recipe.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arista设备上必须启用eAPI，以便在这个配方中使用Ansible模块。
- en: How to do it...
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new playbook, `pb_arista_facts.yml`, with the following task to collect
    the facts:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的playbook，`pb_arista_facts.yml`，包含以下任务来收集事实：
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Update the `pb_arista_facts.yml` playbook with the following tasks to validate
    the operational state of all our fabric interfaces:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下任务更新`pb_arista_facts.yml` playbook，以验证所有fabric接口的操作状态：
- en: '[PRE52]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Update the playbook with the following task to validate the correct IP address
    assignment for all our fabric interfaces:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新playbook，添加以下任务来验证所有布线接口的正确IP地址分配：
- en: '[PRE53]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Ansible provides a fact-gathering module to collect the basic system properties
    for Arista devices and returns these facts in a consistent and structured data
    structure. We can use the facts collected by this module in order to validate
    the basic properties and operational state of our devices.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible提供了一个收集Arista设备基本系统属性的事实收集模块，并以一致和结构化的数据结构返回这些事实。我们可以使用这个模块收集的事实来验证设备的基本属性和操作状态。
- en: 'In this recipe, we used the `eos_facts` module to collect the device facts
    for all our Arista devices. This module returned the basic facts collected by
    Ansible for each device in multiple variables. The main variable that we are interested
    in is the `ansible_net_interfaces` variable, which holds all the operational state
    of all the interfaces on the device. The following snippet outlines a sample of
    the data stored in this variable:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用`eos_facts`模块来收集所有Arista设备的设备信息。这个模块返回了Ansible为每个设备收集的基本信息，并存储在多个变量中。我们感兴趣的主要变量是`ansible_net_interfaces`变量，它保存了设备上所有接口的操作状态。以下片段概述了存储在这个变量中的数据的样本：
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We used the data retrieved by Ansible and stored in the `ansible_net_interfaces` variable
    in order to validate that all the fabric interfaces are operational and that they
    have the correct IP address assigned as per our design. We used the `assert` module
    in order to perform this validation, and we looped over the `p2p_ip` data structure
    for each device in order to validate the state for only our fabric interfaces.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Ansible检索的数据，并存储在`ansible_net_interfaces`变量中，以验证所有布线接口是否操作，并且它们是否按照我们的设计分配了正确的IP地址。我们使用`assert`模块来执行此验证，并循环遍历每个设备的`p2p_ip`数据结构，以验证只有我们的布线接口的状态。
- en: See also...
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见...
- en: For more information regarding the `eos_facts` module and the different parameters
    supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/eos_facts_module.html](https://docs.ansible.com/ansible/latest/modules/eos_facts_module.html).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`eos_facts`模块和该模块支持的不同参数的更多信息，请参阅以下网址：[https://docs.ansible.com/ansible/latest/modules/eos_facts_module.html](https://docs.ansible.com/ansible/latest/modules/eos_facts_module.html)。
- en: Retrieving operational data from Arista devices
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Arista设备中检索操作数据
- en: In this recipe, we will outline how to execute operational commands on Arista
    devices, and use the output to validate the state of the devices.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将概述如何在Arista设备上执行操作命令，并使用输出来验证设备的状态。
- en: Getting ready
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: eAPI must be enabled on the Arista devices in order to follow along with this
    recipe.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按照这个示例进行操作，Arista设备上必须启用eAPI。
- en: How to do it...
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Create a new playbook called `pb_get_vlans.yml` and populate it to execute
    the `show vlan` command on all leaf switches and store the output in a variable:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pb_get_vlans.yml`的新playbook，并填充它以在所有叶子交换机上执行`show vlan`命令，并将输出存储在一个变量中：
- en: '[PRE55]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Update the `pb_get_vlans.yml` playbook and populate it with the following task
    to compare and validate that correct VLANs are configured on the devices:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`pb_get_vlans.yml` playbook，并填充以下任务来比较和验证设备上配置的正确VLAN：
- en: '[PRE56]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works...
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We executed operational commands on the Arista switches using the `eos_command`
    Ansible module and, in order to return structured output, we used the `json` keyword
    in the command to return the JSON output of the operational command (if supported).
    In this example, we sent the `show vlan` command to get the list of VLANs configured
    on the devices, and we collected the output in the `show_vlan` variable. The following
    snippet outlines the output we get from the devices, which is stored in this variable:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`eos_command` Ansible模块在Arista交换机上执行操作命令，并为了返回结构化输出，我们在命令中使用`json`关键字来返回操作命令的JSON输出（如果支持）。在这个例子中，我们发送了`show
    vlan`命令来获取设备上配置的VLAN列表，并将输出收集在`show_vlan`变量中。以下片段概述了我们从设备中获得的输出，这些输出存储在这个变量中：
- en: '[PRE57]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We used the `assert` module to validate that the VLANs defined within our design
    (in the `vlans_design.yml` file) were all configured and operational for each
    of the switches. We compared the VLANs defined in this file with the output that
    we retrieved from the devices using the `eos_command` module (which is stored
    in the `show_vlan` variable) in order to ensure that each VLAN was active on the
    switches.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`assert`模块来验证我们设计中定义的VLAN（在`vlans_design.yml`文件中）是否都配置并且对每个交换机都是操作状态。我们将在这个文件中定义的VLAN与我们使用`eos_command`模块从设备中检索的输出（存储在`show_vlan`变量中）进行比较，以确保每个VLAN在交换机上都是活动的。
- en: We are using the `string` Jinja2 filter in our `assert` statement since the
    VLANs are defined as integers in our `vlan_design.yml` file. However, the VLANs
    stored in the `show_vlan` variable are strings. Thus, in order for the `assert` statement
    to succeed, we need to make sure that the type is similar.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`assert`语句中使用`string` Jinja2过滤器，因为我们的`vlan_design.yml`文件中定义的VLAN是整数。然而，存储在`show_vlan`变量中的VLAN是字符串。因此，为了使`assert`语句成功，我们需要确保类型是相似的。
- en: See also...
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见...
- en: For more information regarding the `eos_command` module and the different parameters
    supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/eos_command_module.html](https://docs.ansible.com/ansible/latest/modules/eos_command_module.html)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`eos_command`模块和该模块支持的不同参数的更多信息，请参阅以下网址：[https://docs.ansible.com/ansible/latest/modules/eos_command_module.html](https://docs.ansible.com/ansible/latest/modules/eos_command_module.html)。
