- en: Managing Cisco IOS Devices Using Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible管理Cisco IOS设备
- en: 'In this chapter, we will outline how to automate Cisco IOS-based devices using
    Ansible. We will explore the different modules available in Ansible to automate
    configuration and collect network information from Cisco IOS devices. This chapter
    will be based on the following sample network diagram, and we will walk through
    how we can implement this network design using Ansible:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将概述如何使用Ansible自动化Cisco基于IOS的设备。我们将探索Ansible中可用的不同模块，以自动化配置并从Cisco IOS设备收集网络信息。本章将基于以下示例网络图，并将介绍如何使用Ansible实现此网络设计：
- en: '![](assets/06d3ef76-2fe9-43da-98c7-ea99b04fb0c8.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/06d3ef76-2fe9-43da-98c7-ea99b04fb0c8.png)'
- en: 'The following table outlines the management IP addresses on the Cisco nodes,
    which Ansible will use to connect to the devices:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格概述了Cisco节点上的管理IP地址，Ansible将使用这些地址连接到设备：
- en: '| **Device** | **Role** | **Vendor** | **MGMT Port** | **MGMT IP** |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| **设备** | **角色** | **供应商** | **管理端口** | **管理IP** |'
- en: '| `access01` | Access switch | Cisco IOS 15.1 | `Ethernet0/0` | `172.20.1.18`
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| `access01` | 访问交换机 | Cisco IOS 15.1 | `Ethernet0/0` | `172.20.1.18` |'
- en: '| `access02` | Access switch | Cisco IOS 15.1 | `Ethernet0/0` | `172.20.1.19`
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| `access02` | 访问交换机 | Cisco IOS 15.1 | `Ethernet0/0` | `172.20.1.19` |'
- en: '| `core01` | Core switch | Cisco IOS 15.1 | `Ethernet0/0` | `172.20.1.20` |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| `core01` | 核心交换机 | Cisco IOS 15.1 | `Ethernet0/0` | `172.20.1.20` |'
- en: '| `core02` | Core switch | Cisco IOS 15.1 | `Ethernet0/0` | `172.20.1.21` |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| `core02` | 核心交换机 | Cisco IOS 15.1 | `Ethernet0/0` | `172.20.1.21` |'
- en: '| `wan01` | WAN router | Cisco IOS–XE 16.6.1 | `GigabitEthernet1` | `172.20.1.22`
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `wan01` | WAN路由器 | Cisco IOS-XE 16.6.1 | `GigabitEthernet1` | `172.20.1.22`
    |'
- en: '| `wan02` | WAN router | Cisco IOS–XE 16.6.1 | `GigabitEthernet1` | `172.20.1.23`
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `wan02` | WAN路由器 | Cisco IOS-XE 16.6.1 | `GigabitEthernet1` | `172.20.1.23`
    |'
- en: 'The main recipes covered in this chapter are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要配方如下：
- en: Building an Ansible network inventory
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Ansible网络清单
- en: Connecting to Cisco IOS devices
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到Cisco IOS设备
- en: Configuring basic system information
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置基本系统信息
- en: Configuring interfaces on IOS devices
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在IOS设备上配置接口
- en: Configuring L2 VLANS on IOS devices
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在IOS设备上配置L2 VLAN
- en: Configuring trunk and access interfaces
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置干线和访问接口
- en: Configuring interface IP addresses
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置接口IP地址
- en: Configuring OSPF on IOS devices
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在IOS设备上配置OSPF
- en: Collecting IOS device facts
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集IOS设备信息
- en: Validating network reachability on IOS devices
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在IOS设备上验证网络可达性
- en: Retrieving operational data from IOS devices
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从IOS设备检索操作数据
- en: Validating network states with pyATS and Ansible
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pyATS和Ansible验证网络状态
- en: Technical requirements
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be found here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在这里找到：
- en: '[https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch2_ios](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch2_ios)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch2_ios](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch2_ios)'
- en: 'The software releases that this chapter is based on are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于的软件版本如下：
- en: Cisco IOS 15.1
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cisco IOS 15.1
- en: Cisco IOS–XE 16.6.1
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cisco IOS-XE 16.6.1
- en: Ansible 2.9
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 2.9
- en: Python 3.6.8
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.6.8
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：
- en: '[https://bit.ly/34F8xPW](https://bit.ly/34F8xPW)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/34F8xPW](https://bit.ly/34F8xPW)'
- en: Building an Ansible network inventory
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Ansible网络清单
- en: In this recipe, we will outline how to build and structure the Ansible inventory
    to describe the network setup outlined in the previous section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将概述如何构建和组织Ansible清单，以描述前一节中概述的网络设置。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that Ansible is already installed on the control machine.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Ansible已经安装在控制机上。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Create a new directory with the following name: `ch2_ios`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ch2_ios`的新目录。
- en: 'Inside this new folder, create the `hosts` file with the following content:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新文件夹里，创建`hosts`文件，内容如下：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the `Ansible.cfg` file with the following content:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Ansible.cfg`文件，内容如下：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We built the Ansible inventory using the `hosts` file, and we defined multiple
    groups in order to group the different devices in our topology in the following
    manner:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`hosts`文件构建了Ansible清单，并以以下方式定义了多个组，以便对我们拓扑中的不同设备进行分组：
- en: We created the `access` group, which has both access switches (`access01` and
    `access02`) in our topology.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了`access`组，其中包括我们拓扑中的访问交换机（`access01`和`access02`）。
- en: We created the `core` group, which groups all core switches that will act as
    the L3 termination for all the VLANs on the access switches.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了`core`组，将所有作为访问交换机上所有VLAN的L3终止的核心交换机分组在一起。
- en: We created the `wan` group, which groups all our Cisco IOS–XE routes, which
    will act as our wan routers.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了`wan`组，将所有我们的Cisco IOS-XE路由器分组在一起，它们将作为我们的wan路由器。
- en: We created another group called `lan,` which groups both access and core groups.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了另一个名为`lan`的组，将访问组和核心组分组在一起。
- en: We created the `network` group, which groups both `lan` and `wan` groups.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了`network`组，将`lan`和`wan`组分组在一起。
- en: Finally, we created the `Ansible.cfg` file and configured it to point to our
    `hosts` file to be used as an Ansible inventory file. We disabled the setup module,
    which is not required when running Ansible against network nodes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了`Ansible.cfg`文件，并配置它指向我们的`hosts`文件，以用作Ansible清单文件。我们禁用了设置模块，在针对网络节点运行Ansible时不需要它。
- en: Connecting to Cisco IOS devices
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到Cisco IOS设备
- en: In this recipe, we will outline how to connect to Cisco IOS devices from Ansible
    via SSH in order to start managing devices from Ansible.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将概述如何通过SSH从Ansible连接到Cisco IOS设备，以便从Ansible开始管理设备。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to follow along with this recipe, an Ansible inventory file should
    be constructed as per the previous recipe. IP reachability between the Ansible
    control machine and all the devices in the network must be configured.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按照这个配方进行操作，应该按照前面的配方构建一个Ansible清单文件。必须配置Ansible控制机与网络中所有设备之间的IP可达性。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Inside the `ch2_ios` directory, create the `groups_vars` folder.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ch2_ios`目录中，创建`groups_vars`文件夹。
- en: 'Inside the `group_vars` folder, create the `network.yml` file with the following
    content:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`group_vars`文件夹中，创建以下内容的`network.yml`文件：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On all IOS devices, ensure that the following is configured to set up SSH access:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有IOS设备上，确保配置以下内容以设置SSH访问：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Generate SSH keys on the Cisco IOS devices from the config mode, as shown in
    the following code snippet:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从配置模式在Cisco IOS设备上生成SSH密钥，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Update the `Ansible.cfg` file with the following highlighted parameters:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下突出显示的参数更新`Ansible.cfg`文件：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In our sample network, we will use SSH to set up the connection between Ansible
    and our Cisco devices. In this setup, Ansible will use SSH in order to establish
    the connection to our Cisco devices with a view to start managing it. We will
    use username/password authentication in order to authenticate our Ansible control
    node with our Cisco devices.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例网络中，我们将使用SSH来建立Ansible与我们的Cisco设备之间的连接。在这个设置中，Ansible将使用SSH来建立与我们的Cisco设备的连接，以开始对其进行管理。我们将使用用户名/密码身份验证来验证我们的Ansible控制节点与我们的Cisco设备。
- en: 'On the Cisco devices, we must ensure that SSH keys are present in order to
    have a functional SSH server on the Cisco devices. The following code snippet
    outlines the status of the SSH server on the Cisco device prior to generating
    the SSH keys:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cisco设备上，我们必须确保存在SSH密钥，以便在Cisco设备上有一个功能性的SSH服务器。以下代码片段概述了在生成SSH密钥之前Cisco设备上的SSH服务器的状态：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once we create the SSH keys, the SSH server on the Cisco device is operational,
    and is ready to accept an SSH connection from the Ansible control node.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了SSH密钥，Cisco设备上的SSH服务器就可以运行，并准备好接受来自Ansible控制节点的SSH连接。
- en: 'On the Ansible machine, we include all the variables required to establish
    the SSH connection to the managed devices in the `network.yml` file. As per our
    inventory file, the network group includes all the devices within our topology,
    and so all the attributes that we configure in this file will apply to all the
    devices in our inventory. The following is a breakdown of the attributes that
    we included in the file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible机器上，我们在`network.yml`文件中包含了与受管设备建立SSH连接所需的所有变量。根据我们的清单文件，网络组包括拓扑中的所有设备，因此我们在此文件中配置的所有属性将应用于清单中的所有设备。以下是我们在文件中包含的属性的详细信息：
- en: '`Ansible_connection`: This establishes how Ansible connects to the device.
    In this scenario, we set it to `network_cli` to indicate that we will use SSH
    to connect to a network device.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ansible_connection`: 这确定了Ansible如何连接到设备。在这种情况下，我们将其设置为`network_cli`，以指示我们将使用SSH连接到网络设备。'
- en: '`Ansible_network_os`: When using `network_cli` as the connection plugin to
    connect to the network device, we must indicate which network OS Ansible will
    be connecting to, so as to use the correct SSH parameters with the devices. In
    this scenario, we will set it to `ios`, since all the devices in our topology
    are IOS-based devices.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ansible_network_os`: 当使用`network_cli`作为连接插件连接到网络设备时，我们必须指示Ansible将连接到哪个网络OS，以便使用正确的SSH参数与设备连接。在这种情况下，我们将其设置为`ios`，因为我们拓扑中的所有设备都是基于IOS的设备。'
- en: '`Ansible_user`: This parameter specifies the username that Ansible will use
    to establish the SSH session with the network device.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ansible_user`: 此参数指定Ansible将用于与网络设备建立SSH会话的用户名。'
- en: '`Ansible_password`: This parameter specifies the password that Ansible will
    use to establish the SSH session with the network device.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ansible_password`: 此参数指定Ansible将用于与网络设备建立SSH会话的密码。'
- en: '`Ansible_become`: This instructs Ansible to use the `enable` command to enter
    privileged mode when configuring or executing `show` commands on the managed device.
    We set this to `yes` in our context, since we will require privileged mode to
    configure the devices.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ansible_become`: 这指示Ansible在配置或执行受管设备上的`show`命令时，使用`enable`命令进入特权模式。在我们的情况下，我们将其设置为`yes`，因为我们需要特权模式来配置设备。'
- en: '`Ansible_become_password`: This specifies the `enable` password to use in order
    to enter privileged mode on the managed IOS device.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ansible_become_password`: 这指定了用于在受管IOS设备上进入特权模式的`enable`密码。'
- en: '`Ansible_become_method`: This option specifies the method to use in order to
    enter privileged mode. In our scenario, this is the `enable` command on IOS devices.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ansible_become_method`: 此选项指定进入特权模式时要使用的方法。在我们的情况下，这是IOS设备上的`enable`命令。'
- en: In this recipe, I have defined the SSH password and the `enable` passwords as
    plain text just for simplicity; however, this is highly discouraged. We should
    use `Ansible-vault` to secure the passwords, as outlined in the *Ansible Vault*
    recipe in the previous chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我已经以明文形式定义了SSH密码和`enable`密码，仅仅是为了简单起见；然而，这是极不鼓励的。我们应该使用`Ansible-vault`来保护密码，就像在上一章的*Ansible
    Vault*示例中所概述的那样。
- en: On the Cisco devices, we set up the required username and password so that Ansible
    can open an SSH connection to the managed Cisco IOS devices. We also configure
    an `enable` password to be able to enter privileged mode, and to make configuration
    changes. Once we apply all of these configurations to the devices, we are ready
    to set up Ansible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cisco设备上，我们设置了所需的用户名和密码，以便Ansible可以打开SSH连接到受管的Cisco IOS设备。我们还配置了一个`enable`密码，以便能够进入特权模式，并进行配置更改。一旦我们将所有这些配置应用到设备上，我们就准备好设置Ansible了。
- en: 'In any SSH connection, when an SSH client (Ansible control node in our case)
    connects to an SSH server (Cisco devices in our case), the server sends a copy
    of its public key to the client before the client logs in. This is used to establish the
    secure channel between the client and the server, and to authenticate the server
    to the client in order to prevent any man-in-the-middle attacks. So, at the start
    of a new SSH session involving a new device, we see the following prompt:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何SSH连接中，当SSH客户端（在我们的情况下是Ansible控制节点）连接到SSH服务器（在我们的情况下是Cisco设备）时，服务器会在客户端登录之前向客户端发送其公钥的副本。这用于在客户端和服务器之间建立安全通道，并向客户端验证服务器，以防止任何中间人攻击。因此，在涉及新设备的新SSH会话开始时，我们会看到以下提示：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the SSH client initiates the SSH connection to the client, the SSH server
    sends its public key to the client in order to authenticate itself to the client.
    The client searches for the public key in its local known `hosts` files (in the `~/.SSH/known_hosts`
    or `/etc/SSH/SSH_known_hosts` files). In the event that it does not find the public
    key for this machine in its local known `hosts` file, it will prompt the user
    to add this new key to its local database, and this is the prompt that we see
    when we initiate the SSH connection.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当SSH客户端启动SSH连接到客户端时，SSH服务器会向客户端发送其公钥，以便向客户端进行身份验证。客户端在其本地已知的“hosts”文件（在“~/.SSH/known_hosts”或“/etc/SSH/SSH_known_hosts”文件中）中搜索公钥。如果在其本地已知的“hosts”文件中找不到此计算机的公钥，它将提示用户将此新密钥添加到其本地数据库中，这就是我们在启动SSH连接时看到的提示。
- en: In order to simplify the SSH connection setup between the Ansible control node
    and its remotely managed `hosts`, we can disable this host checking. We can do
    this by telling Ansible to ignore host keys and not to add them to the known `hosts`
    files by setting `host_key_checking` to `False` in the `Ansible.cfg` configuration
    file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化Ansible控制节点与其远程管理的“hosts”之间的SSH连接设置，我们可以禁用此主机检查。我们可以通过在“Ansible.cfg”配置文件中将“host_key_checking”设置为“False”来告诉Ansible忽略主机密钥并不将其添加到已知的“hosts”文件中。
- en: Disabling host key checking is not a best practice, and we are only showing
    it as it is a lab setup. In the next section, we will outline an alternative method
    to establish the SSH connection between Ansible and its remote managed devices.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用主机密钥检查不是最佳实践，我们只是将其显示为实验室设置。在下一节中，我们将概述在Ansible和其远程管理设备之间建立SSH连接的另一种方法。
- en: There's more...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we need to verify the identity of the SSH `hosts` that we will connect to,
    and thereby enable `host_key_checking`, we can automate the addition of the SSH
    public key of the remote managed `hosts` to the `~/.SSH/known_hosts` file using
    Ansible. We create a new Ansible playbook that will run on the Ansible control
    machine to connect to the remote devices using the `ssk-keyscan` command. We then
    collect the SSH public keys for the remote machines and add them to the `~/.SSH/known_hosts`
    file. The method is outlined here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要验证我们将连接到的SSH“hosts”的身份，并因此启用“host_key_checking”，我们可以使用Ansible自动将远程管理的“hosts”的SSH公钥添加到“~/.SSH/known_hosts”文件中。我们创建一个新的Ansible
    playbook，将在Ansible控制机器上使用“ssk-keyscan”命令连接到远程设备。然后收集远程机器的SSH公钥并将其添加到“~/.SSH/known_hosts”文件中。该方法在此处概述：
- en: 'Create a new `playbook pb_gather_SSH_keys.yml` file and add the following play:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的“playbook pb_gather_SSH_keys.yml”文件，并添加以下play：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Update the playbook and add another play within the same playbook to save and
    store the SSH public keys for the remote managed nodes:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新playbook并在同一playbook中添加另一个play以保存和存储远程管理节点的SSH公钥：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In our new playbook, we have a play that targets all our managed devices by
    setting the `hosts` parameter to `all`. In this play, we have a single task, which
    we run on the Ansible control node (using the `delegate_to` localhost) to issue
    the `SSH-keyscan` command, which returns the SSH public key for the remote device,
    as shown in the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新playbook中，我们通过将“hosts”参数设置为“all”来针对所有受管设备进行play。在此play中，我们有一个单独的任务，我们在Ansible控制节点上运行（使用“delegate_to”
    localhost）以发出“SSH-keyscan”命令，该命令返回远程设备的SSH公钥，如下所示：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this task, we are using `delegate_to` as being equal to `localhost,` as Ansible
    will try to connect to the remote devices and issue the command on the remote
    device by default. In our case, this is not what we need; we need to issue this
    command from the Ansible control node. So, we use `delegate_to` as being equal
    to `localhost` in order to enforce this behavior.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在此任务中，我们使用“delegate_to”等于“localhost”，因为Ansible将尝试连接到远程设备并默认在远程设备上发出命令。在我们的情况下，这不是我们需要的；我们需要从Ansible控制节点发出此命令。因此，我们使用“delegate_to”等于“localhost”来强制执行此行为。
- en: We run the second play on the Ansible control host by setting `hosts` to `localhost,`
    and we execute tasks to create the known hosts file (if not already present) and
    to populate this file with the data that we captured in the first play using the
    `SSH_keys` variable. We run this playbook on the Ansible control machine to store
    the SSH keys from the remotely managed nodes prior to running any of our playbooks.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将“hosts”设置为“localhost”在Ansible控制主机上运行第二个play，并执行任务以创建已知的主机文件（如果尚未存在），并使用“SSH_keys”变量在此文件中填充我们在第一个play中捕获的数据。我们在Ansible控制机器上运行此playbook，以在运行任何playbook之前存储来自远程管理节点的SSH密钥。
- en: Configuring basic system information
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置基本系统信息
- en: 'In this recipe, we will outline how we can configure basic system parameters
    on Cisco IOS devices, such as setting the hostname, DNS server, and NTP servers.
    Following the network setup that we outlined at the start of this chapter, we
    will configure the following information on all the Cisco IOS devices:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将概述如何在Cisco IOS设备上配置基本系统参数，例如设置主机名、DNS服务器和NTP服务器。根据我们在本章开头概述的网络设置，我们将在所有Cisco
    IOS设备上配置以下信息：
- en: DNS servers 172.20.1.250 and 172.20.1.251
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS服务器172.20.1.250和172.20.1.251
- en: NTP server 172.20.1.17
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NTP服务器172.20.1.17
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: An Ansible inventory file must be present, as well as the configuration for
    Ansible to connect to the Cisco IOS devices via SSH.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 必须存在一个Ansible清单文件，以及通过SSH连接到Cisco IOS设备的Ansible配置。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To the `group_vars/network.yml` file, add the following system parameters:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`group_vars/network.yml`文件中，添加以下系统参数：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a new playbook called `pb_build_network.yml` with the following information:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pb_build_network.yml`的新播放文件，包含以下信息：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `network.yml` file, we define the `name_servers` variable as a list of
    DNS servers, and we also define the `ntp_servers` variable, which defines the
    NTP servers that we want to configure on the IOS devices. Defining these parameters
    in the `network.yml` file applies these variables to all the devices within the
    network group.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`network.yml`文件中，我们将`name_servers`变量定义为DNS服务器列表，并定义`ntp_servers`变量，它定义了我们要在IOS设备上配置的NTP服务器。在`network.yml`文件中定义这些参数将这些变量应用于网络组中的所有设备。
- en: 'We create a playbook and the first play targets all the `hosts` in the `lan`
    group (this includes both access and core devices) and, within this play, we reference
    two tasks:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个播放文件，第一个播放目标是`lan`组中的所有`hosts`（包括访问设备和核心设备），在这个播放中，我们引用了两个任务：
- en: '`ios_system`: This sets the hostname and the DNS servers on the devices.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ios_system`：这在设备上设置主机名和DNS服务器。'
- en: '`ios_ntp`: This configures the NTP on the IOS devices and enables logging for
    NTP events.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ios_ntp`：这在IOS设备上配置NTP并启用NTP事件的日志记录。'
- en: Both these modules are declarative Ansible modules in which we just identify
    the state pertaining to our infrastructure. Ansible converts this declaration
    into the necessary IOS commands. The modules retrieve the configuration of the
    devices and compare the current state with our intended state (to have DNS and
    NTP configured on them) and then, if the current state does not correspond to
    the intended state defined by these modules, Ansible will apply the needed configuration
    to the devices.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个模块都是声明性的Ansible模块，我们只需确定与我们基础设施相关的状态。Ansible将此声明转换为必要的IOS命令。这些模块检索设备的配置，并将当前状态与我们的预期状态进行比较（在它们上配置了DNS和NTP），然后，如果当前状态与这些模块定义的预期状态不符，Ansible将对设备应用所需的配置。
- en: 'When we run these tasks on all the LAN devices, the following configuration
    is pushed to the devices:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在所有LAN设备上运行这些任务时，以下配置将被推送到设备上：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See also...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more information regarding the `ios_system` and `ios_ntp` modules, as well
    as the different parameters supported by these modules, please consult the following
    URLs:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`ios_system`和`ios_ntp`模块以及这些模块支持的不同参数的更多信息，请参考以下网址：
- en: '[https://docs.Ansible.com/Ansible/latest/modules/ios_system_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_system_module.html)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.Ansible.com/Ansible/latest/modules/ios_system_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_system_module.html)'
- en: '[https://docs.Ansible.com/Ansible/latest/modules/ios_ntp_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_ntp_module.html)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.Ansible.com/Ansible/latest/modules/ios_ntp_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_ntp_module.html)'
- en: Configuring interfaces on IOS devices
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在IOS设备上配置接口
- en: In this recipe, we will outline how to configure the basic interface properties
    on Cisco IOS-based devices, such as setting the interface description, the interface
    **maximum transmission unit** (**MTU**), and enabling `interfaces`. We will configure
    all the links within our topology as having a link MTU of 1,500 and to be fully
    duplex.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将概述如何在基于Cisco IOS的设备上配置基本接口属性，例如设置接口描述、接口最大传输单元（MTU）和启用`interfaces`。我们将配置拓扑中的所有链路的链路MTU为1,500，并且设置为全双工。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow along with this recipe, an Ansible inventory is assumed to be already
    set up, as is IP reachability between the Ansible control node with the Cisco
    devices in place.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个示例进行操作，假设已经设置了Ansible清单，并且Ansible控制节点与已经放置的Cisco设备之间具有IP可达性。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the `group_vars/network.yml` file, add the following content to define the
    generic interface parameters:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`group_vars/network.yml`文件中，添加以下内容来定义通用接口参数：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a new file, `lan.yml`, under the `group_vars` folder, with the following
    data to define the `interfaces` on our Cisco devices:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`group_vars`文件夹下创建一个新文件`lan.yml`，包含以下数据来定义我们的Cisco设备上的`interfaces`：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Update the `pb_build_network.yml` playbook file with the following task to
    set up the `interfaces`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`pb_build_network.yml`播放文件，增加以下任务来设置`interfaces`：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we outline how to configure the physical interfaces on IOS devices.
    We first declare the generic parameters (interface duplex and MTU) that apply
    to all the interfaces. These parameters are defined under the `network.yml` file.
    Next, we define all the interface-specific parameters for all our LAN devices
    under the `lan.yml` file to be applied to all devices. All these parameters are
    declared in the `interfaces` dictionary data structure.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们概述了如何在IOS设备上配置物理接口。我们首先声明适用于所有接口的通用参数（接口双工和MTU）。这些参数在`network.yml`文件下定义。接下来，我们在`lan.yml`文件下定义了所有我们的LAN设备的特定接口参数，以应用于所有设备。所有这些参数都在`interfaces`字典数据结构中声明。
- en: We update our playbook with a new task to configure the physical parameters
    for all of our LAN devices in our network. We use the `ios_interface` module to
    provision all the `interface` parameters, and we loop over all the `interfaces`
    in each node using the `interfaces` data structure. We set the state to `up` in
    order to indicate that the `interface` should be present and operational.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新我们的手册，增加了一个新任务，用于配置网络中所有LAN设备的物理参数。我们使用`ios_interface`模块来配置所有`interface`参数，并使用`interfaces`数据结构在每个节点上循环所有`interfaces`。我们将状态设置为`up`，以指示`interface`应该存在并且可操作。
- en: See also...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: For more information regarding the `ios_interface` module, and the different
    parameters supported by these modules, please consult the following URL: [https://docs.Ansible.com/Ansible/latest/modules/ios_interface_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_interface_module.html)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`ios_interface`模块以及这些模块支持的不同参数的更多信息，请参考以下网址：[https://docs.Ansible.com/Ansible/latest/modules/ios_interface_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_interface_module.html)
- en: Configuring L2 VLANs on IOS devices
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在IOS设备上配置L2 VLAN
- en: In this recipe, we will outline how to configure L2 VLANs on Cisco IOS devices,
    as per the network topology discussed in the introduction to this chapter. We
    will outline how to declare VLANs as Ansible variables, and how to use suitable
    Ansible modules to provision these VLANs on the network.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将概述如何根据本章介绍中讨论的网络拓扑在Cisco IOS设备上配置L2 VLAN。我们将概述如何将VLAN声明为Ansible变量，以及如何使用适当的Ansible模块在网络上提供这些VLAN。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be building on the previous recipes discussed in this chapter to continue
    to configure the L2 VLANs on all the LAN devices within our sample topology.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章讨论的先前配方的基础上继续构建，以继续配置样本拓扑中所有LAN设备上的L2 VLAN。
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Update the `group_vars/lan.yml` file with the VLAN definition, as outlined
    in the following code:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新`group_vars/lan.yml`文件中的VLAN定义：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Update the `pb_build.yml` playbook with the following task to provision the
    VLANs:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下任务更新`pb_build.yml` playbook以提供VLAN：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `group_vars/lan.yml` file, we define a `vlans` list data structure that
    holds the VLAN definition that we need to apply to all our core and access switches.
    This variable will be available for all the core and access switches, and Ansible
    will use this variable in order to provision the required VLANs on the remote
    devices.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`group_vars/lan.yml`文件中，我们定义了一个`vlans`列表数据结构，其中包含我们需要应用于所有核心和接入交换机的VLAN定义。此变量将对所有核心和接入交换机可用，并且Ansible将使用此变量来在远程设备上提供所需的VLAN。
- en: We use another declarative module, `ios_vlan`, which takes the VLAN definition
    (its name and the VLAN ID) and configures these VLANs on the remote managed device.
    It pulls the existing configuration from the device and compares it with the list
    of devices that need to be present, while only pushing the delta.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用另一个声明性模块`ios_vlan`，它接受VLAN定义（名称和VLAN ID）并在远程托管设备上配置这些VLAN。它从设备中提取现有配置，并将其与需要存在的设备列表进行比较，仅推送增量。
- en: We use the `loop` construct to go through all the items in the `vlans` list,
    and configure all the respective VLANs on all the devices.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`loop`结构遍历`vlans`列表中的所有项目，并在所有设备上配置所有相应的VLAN。
- en: 'After running this task on the devices, the following is the output from one
    of the access switches:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备上运行此任务后，以下是一个接入交换机的输出：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Configuring trunk and access interfaces
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置干道和接入接口
- en: In this recipe, we will show how to configure access and trunk interfaces on
    Cisco IOS-based devices, and how to map interfaces to an access VLAN, as well
    as how to allow specific VLANs on the trunks.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将展示如何在基于Cisco IOS的设备上配置接入和干道接口，以及如何将接口映射到接入VLAN，以及如何在干道上允许特定的VLAN。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Following our sample topology, we will configure the interfaces on the devices.
    As shown in this table, we are only showing the VLANs for `access01` and `core01`—
    the other devices are exact replicas:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的样本拓扑，我们将配置设备上的接口。如表所示，我们只显示`access01`和`core01`的VLAN - 其他设备是完全相同的副本：
- en: '| **Device** | **Interface** | **Mode** | **VLANs** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **设备** | **接口** | **模式** | **VLANs** |'
- en: '| Core01 | Ethernet0/1 | Trunk | 10,20,100 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| Core01 | Ethernet0/1 | 干道 | 10,20,100 |'
- en: '| Core01 | Ethernet0/2 | Trunk | 10,20,100 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| Core01 | Ethernet0/2 | 干道 | 10,20,100 |'
- en: '| Core01 | Ethernet0/3 | Trunk | 10,20,100,200 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| Core01 | Ethernet0/3 | 干道 | 10,20,100,200 |'
- en: '| Access01 | Ethernet0/1 | Trunk | 10,20,100 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| Access01 | Ethernet0/1 | 干道 | 10,20,100 |'
- en: '| Access01 | Ethernet0/2 | Trunk | 10,20,100 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| Access01 | Ethernet0/2 | 干道 | 10,20,100 |'
- en: '| Access01 | Ethernet0/3 | Access | 10 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| Access01 | Ethernet0/3 | 接入 | 10 |'
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new `core.yml` file under `group_vars` and include the following `core_vlans`
    definition:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`group_vars`下创建一个新的`core.yml`文件，并包括以下`core_vlans`定义：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Update the `pb_build_network.yml` playbook with the following tasks to configure
    all trunk ports:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下任务更新`pb_build_network.yml` playbook以配置所有干道端口：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Update the playbook with the following task to configure all access ports:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下任务更新playbook以配置所有接入端口：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We are using the same data structure in the `lan.yml` file that defines all
    the interfaces within the LAN network and describes their type (access/trunk).
    In the case of access ports, we define which access interface is part of which
    VLAN. We will reference this list data structure to configure the access and trunk
    ports on all the devices within the `lan` group.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`lan.yml`文件中使用相同的数据结构，该数据结构定义了LAN网络中的所有接口并描述其类型（接入/干道）。对于接入端口，我们定义了哪个接入接口属于哪个VLAN。我们将引用此列表数据结构来配置`lan`组中所有设备上的接入和干道端口。
- en: 'The interfaces within our `layer2` network are one of the following two options:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`layer2`网络中的接口有以下两个选项之一：
- en: '**Access**:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**接入**：'
- en: We use `ios_l2_interface` with the `access_vlan` parameter to configure the
    correct access VLAN on the interface.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`ios_l2_interface`和`access_vlan`参数在接口上配置正确的接入VLAN。
- en: We select only the access interfaces for each device using the `selectattr jinja2`
    filter, and we match only one interface with a mode equal to `access`, and we
    loop over this list for each device.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`selectattr jinja2`过滤器仅选择每个设备的接入接口，并且仅匹配模式等于`access`的一个接口，并且我们循环遍历每个设备的此列表。
- en: '**Trunk**:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**干道**：'
- en: We use `ios_l2_interface` with the `trunk_allowed_vlans` parameter to add all
    the VLANs to the trunk ports, on both access and core switches.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`ios_l2_interface`和`trunk_allowed_vlans`参数将所有VLAN添加到干道端口上，包括接入和核心交换机。
- en: 'We create the permitted VLAN list using the Jinja2 `map` and `join` filters
    and we apply this filter to the `vlans` list data structure. This outputs a string
    similar to the following: `10,20,100`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用Jinja2的`map`和`join`过滤器创建允许的VLAN列表，并将此过滤器应用于`vlans`列表数据结构。这将输出类似于以下内容的字符串：`10,20,100`。
- en: We select only the trunk ports using the `selectattr` Jinja2 filter from the
    interface's data structure per node.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`selectattr` Jinja2过滤器从每个节点的接口数据结构中仅选择trunk端口。
- en: We need to configure these trunks as `dot1q` ports; however, this attribute
    is still not enabled on `ios_l2_interface`. Hence, we use another module, `ios_config`,
    to send the required Cisco IOS command to set up the `dot1q` trunks.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要将这些trunk端口配置为`dot1q`端口；但是，`ios_l2_interface`上仍未启用此属性。因此，我们使用另一个模块`ios_config`发送所需的Cisco
    IOS命令来设置`dot1q` trunk。
- en: 'The following output outlines the configuration applied to the `access01` device
    as an example for both access and trunk ports:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出概述了作为示例应用于`access01`设备的配置，用于访问和trunk端口：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: See also...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more information regarding `ios_l2_interface` and the different parameters
    supported by these modules, please consult the following URL:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`ios_l2_interface`和这些模块支持的不同参数的更多信息，请参阅以下网址：
- en: '[https://docs.Ansible.com/Ansible/latest/modules/ios_l2_interface_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_l2_interface_module.html)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.Ansible.com/Ansible/latest/modules/ios_l2_interface_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_l2_interface_module.html)'
- en: Configuring interface IP addresses
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置接口IP地址
- en: 'In this recipe, we will explore how to configure the interface IP address on
    Cisco IOS devices. We will use the sample topology to configure the VLAN interfaces
    on both the core switches. We will outline how to configure VRRP between the core
    switches for all the VLAN interfaces. We will configure the following IP addresses:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将探讨如何在Cisco IOS设备上配置接口IP地址。我们将使用示例拓扑在两个核心交换机上配置VLAN接口。我们将概述如何在核心交换机之间为所有VLAN接口配置VRRP。我们将配置以下IP地址：
- en: '| **Interface** | **Prefix** | **VRRP IP address** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **接口** | **前缀** | **VRRP IP地址** |'
- en: '| VLAN10 | `10.1.10.0/24` | `10.1.10.254` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| VLAN10 | `10.1.10.0/24` | `10.1.10.254` |'
- en: '| VLAN20 | `10.1.20.0/24` | `10.1.20.254` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| VLAN20 | `10.1.20.0/24` | `10.1.20.254` |'
- en: '| VLAN100 | `10.1.100.0/24` | `10.1.100.254` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| VLAN100 | `10.1.100.0/24` | `10.1.100.254` |'
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that the interface and VLANs are configured as per the previous
    recipes in this chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程假定接口和VLAN已根据本章中的先前教程进行了配置。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Update the `group_vars/core.yml` file with following data to define the SVI
    interfaces:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`group_vars/core.yml`文件，使用以下数据定义SVI接口：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create `core01.yml` and `core02.yml` files under the `host_vars` folder and
    add the following content:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`host_vars`文件夹下创建`core01.yml`和`core02.yml`文件，并添加以下内容：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Update the `pb_build_network.yml` playbook with the following tasks to create
    and enable the L3 SVI interfaces:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`pb_build_network.yml` playbook，添加以下任务以创建和启用L3 SVI接口：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Update the playbook with the following task to set up VRRP configuration on
    the SVI interfaces:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新playbook，添加以下任务以在SVI接口上设置VRRP配置：
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this section, we are configuring the IP addresses for the L3 VLAN interfaces
    on the core switches, as well as configuring VRRP on all the L3 VLAN interfaces
    to provide L3 redundancy.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们正在为核心交换机上的L3 VLAN接口配置IP地址，并在所有L3 VLAN接口上配置VRRP以提供L3冗余。
- en: We are using a new list data structure called `svi_interfaces,` which describes
    all the SVI interfaces with L3 IP addresses, and also some added parameters to
    control both the VRRP and OSPF configured on these interfaces. We also set up
    two new variables on each core router, `hst_svi_id` and `hst_vrrp_priority`, which
    we will use in the playbook to control the IP address on each core switch, as
    well as the VRPP priority.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用一个名为`svi_interfaces`的新列表数据结构，它描述了所有带有L3 IP地址的SVI接口，以及一些额外的参数来控制这些接口上配置的VRRP和OSPF。我们还在每个核心路由器上设置了两个新变量，`hst_svi_id`和`hst_vrrp_priority`，我们将在playbook中使用它们来控制每个核心交换机上的IP地址，以及VRPP优先级。
- en: We use the `ios_l3_interface` Ansible module to set the IPv4 addresses on the
    VLAN interfaces. On each core switch, we loop over the `svi_interfaces` data structure,
    and for each VLAN we configure the IPv4 address on the corresponding VLAN interface.
    We determine which IP address is configured on each router using the Ansible `ipaddr`
    filter, along with the `hst_svi_id` parameter `{{item.ipv4 | ipv4(hst_svi_id)}}`
    . So, for example, for VLAN10, we will assign `10.1.10.1/24` for `core01` and
    `10.1.10.2/24` for `core02`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ios_l3_interface` Ansible模块在VLAN接口上设置IPv4地址。在每个核心交换机上，我们循环遍历`svi_interfaces`数据结构，对于每个VLAN，我们在相应的VLAN接口上配置IPv4地址。我们使用Ansible的`ipaddr`过滤器确定每个路由器上配置的IP地址，以及`hst_svi_id`参数`{{item.ipv4
    | ipv4(hst_svi_id)}}`。例如，对于VLAN10，我们将为`core01`分配`10.1.10.1/24`，为`core02`分配`10.1.10.2/24`。
- en: When first creating the VLAN interface on Cisco IOS devices, they are in a state
    of shutdown, so we need to enable them. We use the `ios_interface` module to enable
    the interfaces.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在首次创建Cisco IOS设备上的VLAN接口时，它们处于关闭状态，因此我们需要启用它们。我们使用`ios_interface`模块启用接口。
- en: For the VRRP part, we return to using the `ios_config` module to set up the
    VRRP configuration on all the VLAN interfaces, and we use `hst_vrrp_priority`
    to correctly set up `core01` as the master VRRP for all VLANs.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于VRRP部分，我们将再次使用`ios_config`模块在所有VLAN接口上设置VRRP配置，并使用`hst_vrrp_priority`正确设置`core01`作为所有VLAN的主VRRP。
- en: 'The following is a sample of the configuration that is pushed on the devices
    after running the playbook:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行playbook后，以下是推送到设备上的配置示例：
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: See also...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more information regarding `ios_l3_interface` and the different parameters
    supported by these modules, please consult the following URL:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`ios_l3_interface`和这些模块支持的不同参数的更多信息，请参阅以下网址：
- en: '[https://docs.Ansible.com/Ansible/latest/modules/ios_l3_interface_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_l3_interface_module.html)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.Ansible.com/Ansible/latest/modules/ios_l3_interface_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_l3_interface_module.html)'
- en: Configuring OSPF on IOS devices
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在IOS设备上配置OSPF
- en: In this recipe, we will outline how to configure OSPF on Cisco IOS devices with
    Ansible. Using our sample network topology, we will set up OSPF between core switches
    and WAN routers, as well as advertising the SVI interface via OSPF.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将概述如何使用Ansible在Cisco IOS设备上配置OSPF。使用我们的示例网络拓扑，我们将在核心交换机和WAN路由器之间设置OSPF，并通过OSPF广告SVI接口。
- en: Getting ready
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that all the interfaces are already configured with the
    correct IP addresses and are following the same procedures outlined in previous
    recipes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程假设所有接口已经配置了正确的IP地址，并且遵循了前面教程中概述的相同流程。
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'Update the `group_vars/core.yml` file with the following data to define core
    links between core switches and WAN routers:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下数据更新`group_vars/core.yml`文件，定义核心交换机和WAN路由器之间的核心链路：
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Update the `pb_build_network.yml` playbook with the following tasks to set
    up OSPF:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`pb_build_network.yml`playbook，添加以下任务来设置OSPF：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: We created another dictionary data structure in the `core.yml` file that describes
    the L3 links between the core switches and the WAN routers. We specified whether
    they will run OSPF and what the OSPF metric is on these links.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`core.yml`文件中创建了另一个字典数据结构，描述了核心交换机和WAN路由器之间的L3链路。我们指定它们是否会运行OSPF以及这些链路上的OSPF度量。
- en: Currently, Ansible doesn't provide a declarative module to manage OSPF configuration
    on IOS-based devices. Therefore, we need to push the required configuration using
    the `ios_config` module. We created two separate tasks using `ios_config` in order
    to push the OSPF-related configuration on each device. In the first task, we configured
    the interface-related parameters under each interface, and we looped over both
    the `svi_interface` and `core_l3_interfaces` data structures to enable OSPF on
    all the OSPF-enabled interfaces. We used the Jinja2 `selectattr` filter to select
    all the interfaces that have the OSPF attribute set to `yes`/`true`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Ansible没有提供用于管理基于IOS设备的OSPF配置的声明性模块。因此，我们需要使用`ios_config`模块推送所需的配置。我们使用`ios_config`创建了两个单独的任务，以便在每个设备上推送与OSPF相关的配置。在第一个任务中，我们在每个接口下配置了接口相关的参数，并循环遍历了`svi_interface`和`core_l3_interfaces`数据结构，以在所有OSPF启用的接口上启用OSPF。我们使用Jinja2的`selectattr`过滤器来选择所有具有设置为`yes`/`true`的OSPF属性的接口。
- en: In the last task, we applied the passive interface configuration to all the
    interfaces that have the passive flag enabled on them. We used the Jinja2 `selectattr`
    filter to select only those interfaces with the passive parameter set to `yes`/`true`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个任务中，我们将被动接口配置应用到所有已启用被动标志的接口上。我们使用Jinja2的`selectattr`过滤器来仅选择那些被动参数设置为`yes`/`true`的接口。
- en: Collecting IOS device facts
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集IOS设备信息
- en: In this recipe, we will outline how to collect device facts from Cisco devices
    with Ansible. This information includes the serial number, IOS version, and all
    the interfaces on the devices. Ansible executes several commands on managed IOS
    devices in order to collect this information.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将概述如何使用Ansible从Cisco设备中收集设备信息。这些信息包括序列号、IOS版本以及设备上的所有接口。Ansible在托管的IOS设备上执行多个命令以收集这些信息。
- en: Getting ready
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The Ansible controller must have IP connectivity with the managed network devices,
    and SSH must be enabled on the IOS devices.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible控制器必须与托管网络设备具有IP连接，并且IOS设备上必须启用SSH。
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'Create a new playbook called `pb_collect_facts.yml` in the same `ch2_ios` folder with
    the following information:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与以下信息相同的`ch2_ios`文件夹中创建一个名为`pb_collect_facts.yml`的新playbook：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'We run this new playbook against all nodes within the `core` and `wan` group,
    and we use the `ios_facts` module to collect the information from the managed
    IOS devices. In this recipe, we use the debug module to print out the information
    that was collected from the `ios_facts` module. The following is a subset of the
    information that was discovered:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`core`和`wan`组中的所有节点运行这个新的playbook，并使用`ios_facts`模块从托管的IOS设备中收集信息。在本教程中，我们使用debug模块打印从`ios_facts`模块收集的信息。以下是从`ios_facts`模块中发现的信息的一个子集：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'From the preceding output, we can see some of the main facts that the `ios_facts`
    module has captured from the devices, including the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到`ios_facts`模块从设备中捕获的一些主要信息，包括以下内容：
- en: '`net_all_ipv4_addresses`: This list data structure contains all the IPv4 addresses
    that are configured on all the `interfaces` on the IOS device.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net_all_ipv4_addresses`：这个列表数据结构包含了在IOS设备上所有`接口`上配置的所有IPv4地址。'
- en: '`net_interfaces`: This dictionary data structure captures the status of all
    of the `interfaces` on this device and their operational state, as well as other
    important information, such as a description and their operational state.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net_interfaces`：这个字典数据结构捕获了该设备上所有`接口`的状态和操作状态，以及其他重要信息，比如描述和操作状态。'
- en: '`net_serialnum`: This captures the serial number of the device.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net_serialnum`：这捕获了设备的序列号。'
- en: '`net_version`: This captures the IOS version running on this device.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net_version`：这捕获了设备上运行的IOS版本。'
- en: There's more...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Using the information that is collected from the `ios_facts` module, we can
    generate structured reports for the current state of the network and use these
    reports in further tasks. In this section, we will outline how to modify our playbook
    to build this report.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从`ios_facts`模块收集的信息，我们可以为网络的当前状态生成结构化报告，并在进一步的任务中使用这些报告。在本节中，我们将概述如何修改我们的playbook来构建这个报告。
- en: 'Add a new task to the `pb_collect_facts.yml` playbook, as shown in the following
    code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pb_collect_facts.yml`playbook中添加一个新任务，如下所示：
- en: '[PRE33]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We use the `blockinfile` module to build a YAML file called `facts.yml.` We
    use Jinja2 expressions within the `blockinfile` module to customize and select
    the information we want to capture from the Ansible facts that were captured from
    the `ios_facts` task. When we run the `pb_collect_facts.yml` playbook, we generate
    the `facts.yml` file, which has the following data:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`blockinfile`模块构建一个名为`facts.yml`的YAML文件。我们在`blockinfile`模块中使用Jinja2表达式来自定义和选择我们想要从`ios_facts`任务捕获的Ansible事实中捕获的信息。当我们运行`pb_collect_facts.yml`
    playbook时，我们生成了`facts.yml`文件，其中包含以下数据：
- en: '[PRE34]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: See also...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more information regarding `ios_facts` and the different parameters supported
    by these modules, please consult the following URL:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`ios_facts`和这些模块支持的不同参数的更多信息，请参考以下URL：
- en: '[https://docs.Ansible.com/Ansible/latest/modules/ios_facts_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_facts_module.html)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.Ansible.com/Ansible/latest/modules/ios_facts_module.html](https://docs.Ansible.com/Ansible/latest/modules/ios_facts_module.html)'
- en: Validating network reachability on IOS devices
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证IOS设备的网络可达性
- en: In this recipe, we will outline how to validate network reachability via `ping`
    using Ansible. ICMP allows us to validate proper forwarding across our network.
    Using Ansible to perform this task provides us with a robust tool to validate
    proper traffic forwarding, since we can perform this task from each node simultaneously
    and collect all the results for further inspection.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将概述如何使用Ansible通过`ping`来验证网络可达性。 ICMP允许我们验证网络上的正确转发。使用Ansible执行此任务为我们提供了一个强大的工具来验证正确的流量转发，因为我们可以同时从每个节点执行此任务并收集所有结果以供进一步检查。
- en: Getting ready
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is built based on the network setup that was outlined in the chapter
    introduction, and I am assuming that the network has already been built in accordance
    with all the previous recipes in this chapter.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是基于章节介绍中概述的网络设置构建的，我假设网络已经根据本章中的所有先前示例构建好了。
- en: How to do it...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new playbook called `pb_net_validate.yml` and add the following task
    to store all SVI IP addresses:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pb_net_validate.yml`的新playbook，并添加以下任务以存储所有SVI IP地址：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Update the `pb_net_validate.yml` playbook with the following task to ping all
    the SVI `interfaces`:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`pb_net_validate.yml` playbook，以ping所有SVI `interfaces`的以下任务：
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this playbook, we are using the `ios_ping` module, which logs into each
    node defined in our Ansible inventory, and pings the destination specified by
    the `dest` attribute. In this sample playbook, we would like to validate network
    reachability to a single host within the data, voice, and web VLANs, and we choose
    the tenth host in all these VLANs (just as an example). In order to build all
    the VLAN prefixes we set in the first task, we add a new variable called `all_svi_prefixes`
    and use multiple `jinja2` filters to collect only those prefixes that are running
    VRRP (so as to remove any core VLANs). We get only the IPv4 attributes for these
    SVI `interfaces`. The following are the contents of this new variable after running
    the first task:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个playbook中，我们使用`ios_ping`模块，该模块登录到Ansible清单中定义的每个节点，并ping`dest`属性指定的目的地。在这个示例playbook中，我们想要验证对数据、语音和Web
    VLAN中的单个主机的网络可达性，并选择这些VLAN中的第十个主机（只是一个例子）。为了构建我们在第一个任务中设置的所有VLAN前缀，我们添加一个名为`all_svi_prefixes`的新变量，并使用多个`jinja2`过滤器仅收集运行VRRP的那些前缀（以删除任何核心VLAN）。我们仅获取这些SVI
    `interfaces`的IPv4属性。在运行第一个任务后，以下是此新变量的内容：
- en: '[PRE37]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We supply this new list data structure to the `ios_ping` module and we specify
    that we need to ping the tenth host within each subnet. As long as the ping succeeds,
    the task will succeed. However, if there is a connectivity problem from the router/switch
    to this host, the task will fail. We are using the `ignore_errors` parameter in
    order to ignore any failure that might occur owing to the fact that the host is
    unreachable/down, and to run any subsequent tasks. The following code snippet
    outlines the successful run:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个新的列表数据结构提供给`ios_ping`模块，并指定我们需要在每个子网中ping第十个主机。只要ping成功，任务就会成功。但是，如果从路由器/交换机到此主机存在连接问题，任务将失败。我们使用`ignore_errors`参数来忽略可能由于主机不可达/关闭而发生的任何失败，并运行任何后续任务。以下代码片段概述了成功运行：
- en: '[PRE38]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Retrieving operational data from IOS devices
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从IOS设备检索操作数据
- en: In this recipe, we will outline how to execute operational commands on IOS devices
    and store these outputs to text files for further processing. This allows us to
    capture any operational commands from IOS devices during pre- or post-validation
    after we perform any deployment so that we can compare the results.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将概述如何在IOS设备上执行操作命令，并将这些输出存储到文本文件中以供进一步处理。这允许我们在执行任何部署后的预验证或后验证期间捕获来自IOS设备的任何操作命令，以便我们可以比较结果。
- en: Getting ready
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to follow along with this recipe, an Ansible inventory file should
    be in place and the network should already be set up as per the previous recipes.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按照这个示例进行操作，应该有一个Ansible清单文件，并且网络应该已经按照先前的示例设置好了。
- en: How to do it...
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new playbook called `pb_op_cmds.yml` and populate it with the following
    tasks to create the directory structure to save the output from the devices:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pb_op_cmds.yml`的新playbook，并填充以下任务以创建保存设备输出的目录结构：
- en: '[PRE39]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Update the `pb_op_cmds.yml` playbook and populate it with the following tasks
    to retrieve the running configuration from the devices:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`pb_op_cmds.yml` playbook，并填充以下任务以从设备中检索运行配置：
- en: '[PRE40]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Update the playbook and populate it with the following tasks to retrieve the
    operational commands from the devices and save it:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新playbook并填充以下任务以从设备中检索操作命令并保存它：
- en: '[PRE41]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we are using the `ios_command` module in order to execute operational
    commands on the IOS devices, and saving them to text files. In order to achieve
    this goal, we perform the following steps:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用`ios_command`模块来在IOS设备上执行操作命令，并将它们保存到文本文件中。为了实现这个目标，我们执行以下步骤：
- en: We create the folders that we will store the output to, and we create a folder
    called `configs` to store the running config of all the devices. We also create
    an `op_data` file to store the output of the operational commands that we will
    get from the devices.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建将存储输出的文件夹，并创建一个名为`configs`的文件夹来存储所有设备的运行配置。我们还创建一个`op_data`文件来存储我们将从设备获取的操作命令的输出。
- en: We then execute the `show running` command on all the IOS devices in our inventory
    and we register the output in a new variable called `show_run`.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们在清单中的所有IOS设备上执行`show running`命令，并将输出注册到一个名为`show_run`的新变量中。
- en: We use the copy module to save the output from the previous task to a file for
    each device. The output from the command run is saved in the `stdout` variable.
    As we executed a single command, the `stdout` variable only has a single item
    (`stdout[0]`).
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用复制模块将上一个任务的输出保存到每个设备的文件中。命令运行的输出保存在`stdout`变量中。由于我们执行了单个命令，`stdout`变量只有一个项目（`stdout[0]`）。
- en: 'Once we execute this task, we can see that the `configs` folder is populated
    as shown in the following output:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们执行了这个任务，我们可以看到`configs`文件夹如下所示：
- en: '[PRE42]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For the next part, we create a folder for each node to store the output from
    the multiple `show` commands that we will execute on the IOS devices.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为每个节点创建一个文件夹，以存储我们将在IOS设备上执行的多个`show`命令的输出。
- en: We use the `ios_command` module to execute the `show` commands on the devices,
    and save all the output in a new variable called `op_output.` We use the copy
    execute command, `show ip route`, and we create a file for the output of this
    command with the name `show_ip_route.txt`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ios_command`模块在设备上执行`show`命令，并将所有输出保存在一个名为`op_output`的新变量中。我们使用复制执行命令`show
    ip route`，并创建一个名为`show_ip_route.txt`的文件来保存此命令的输出。
- en: 'After running this task, we can see that this is the current structure of the
    `op_data` folder:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此任务后，我们可以看到`op_data`文件夹的当前结构如下：
- en: '[PRE43]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can check the content of one of the files to confirm that all the data has
    been stored:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查其中一个文件的内容，以确认所有数据都已存储：
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Validating network states with pyATS and Ansible
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pyATS和Ansible验证网络状态
- en: In this recipe, we will outline how to use Ansible and the Cisco pyATS Python
    library to execute and parse operational commands on Cisco devices. Using these
    parsed commands, we can validate various aspects of the network.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将概述如何使用Ansible和Cisco pyATS Python库在Cisco设备上执行和解析操作命令。使用这些解析的命令，我们可以验证网络的各个方面。
- en: Getting ready
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that the network has already been built and configured as
    outlined in all the previous recipes.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例假设网络已经按照之前的所有示例中概述的方式构建和配置。
- en: How to do it...
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Install the Python libraries needed for pyATS:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装pyATS所需的Python库：
- en: '[PRE45]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create the `roles` directory and then create the `requirements.yml` file with
    the following data:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`roles`目录，然后创建带有以下数据的`requirements.yml`文件：
- en: '[PRE46]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Install the `Ansible-pyats` role as shown in the following code:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码安装`Ansible-pyats`角色：
- en: '[PRE47]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Create a new playbook called `pb_validate_pyats.yml` and populate it with the
    following task to collect the `ospf neighbor` from the `wan` devices.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pb_validate_pyats.yml`的新playbook，并填充以下任务以收集`wan`设备的`ospf neighbor`。
- en: '[PRE48]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Update the playbook with the following tasks to extract the data for OSPF peer
    information:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下任务更新playbook以提取OSPF对等体信息的数据：
- en: '[PRE49]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Update the playbook with the following tasks to validate OSPF peers and the
    OSPF peer state:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下任务更新playbook以验证OSPF对等体和OSPF对等状态：
- en: '[PRE50]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we are exploring how to use the `pyATS` framework to perform
    network validation. `pyATS` is an open source Python library developed by Cisco
    as a testing framework for network testing. `Genie` is another Python library
    that provides parsing capabilities for transforming CLI-based output to Python
    data structures that we can consume in our automation scripts. Cisco released
    an Ansible role that uses the pyATS and Genie libraries. Within this role, there
    are multiple modules that we can use in order to build more robust Ansible validation
    playbooks to validate the network state. In order to start working with this role,
    we need to perform the following steps:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将探讨如何使用`pyATS`框架进行网络验证。`pyATS`是由思科开发的用于网络测试的测试框架的开源Python库。`Genie`是另一个Python库，提供了将基于CLI的输出转换为我们可以在自动化脚本中使用的Python数据结构的解析能力。思科发布了一个使用pyATS和Genie库的Ansible角色。在这个角色中，有多个模块可以用来构建更健壮的Ansible验证playbook，以验证网络状态。为了开始使用这个角色，我们需要执行以下步骤：
- en: Install `pyats` and `enie` Python packages using `python-pip`.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`python-pip`安装`pyats`和`enie` Python包。
- en: Install the `Ansible-pyats` role using Ansible-galaxy.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Ansible-galaxy安装`Ansible-pyats`角色。
- en: 'In this recipe, we are using one of the modules within the `Ansible-pyats`
    role, which is `pyats_parse_command`. This module executes an operational command
    on the remote managed device and returns both the CLI output for this command
    and the parsed structured output for this command. The following code snippet
    outlines the structured data returned by this module for `ip ospf neigbor` on
    the `wan01` device:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了`Ansible-pyats`角色中的一个模块，即`pyats_parse_command`。该模块在远程管理设备上执行操作命令，并返回该命令的CLI输出和解析的结构化输出。以下代码片段概述了此模块在`wan01`设备上的`ip
    ospf neigbor`命令返回的结构化数据：
- en: '[PRE51]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We save the data returned by this module to the `ospf_output` variable and we
    use the `set_fact` module to capture the structured data returned by this module,
    before saving it to a new variable – `pyats_ospf_data.` Then, we use the `set_fact`
    module to filter the links defined in `wan_l3_interfaces` to just the ports that
    are enabled for OSPF.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此模块返回的数据保存到`ospf_output`变量中，并使用`set_fact`模块来捕获此模块返回的结构化数据，然后将其保存到一个新变量`pyats_ospf_data`中。然后，我们使用`set_fact`模块来过滤在`wan_l3_interfaces`中定义的链接，只保留为OSPF启用的端口。
- en: Using the structured data returned by `pyats_parse_command`, we can validate
    this data and compare it with our OSPF peer definition using the `assert` module
    so as to validate the correct number of OSPF peers and their states.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pyats_parse_command`返回的结构化数据，我们可以验证这些数据，并使用`assert`模块将其与我们的OSPF对等体定义进行比较，以验证正确的OSPF对等体数量及其状态。
- en: To extract the OSPF peer state, we use the `json_query` filter to filter the
    returned data and provide just the OSPF state for each neighbor.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取OSPF对等体状态，我们使用`json_query`过滤器来过滤返回的数据，并仅提供每个邻居的OSPF状态。
- en: We are setting `Ansible_connection` to `local` on the play level, and setting
    it to `network_cli` on the `pyats_parse_command` task level, since we only need
    to connect to the device in this task. All the other tasks can run locally on
    the Ansible machine.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在play级别将`Ansible_connection`设置为`local`，并在`pyats_parse_command`任务级别将其设置为`network_cli`，因为我们只需要在此任务中连接到设备。所有其他任务可以在Ansible机器上本地运行。
- en: See also...
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: 'For more information regarding the PyATS and Genie libraries and how to use
    them for network testing, please consult the following URL:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PyATS和Genie库以及如何将它们用于网络测试的更多信息，请参考以下网址：
- en: '[https://developer.cisco.com/docs/pyats/#!introduction/pyats-genie](https://developer.cisco.com/docs/pyats/#!introduction/pyats-genie)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.cisco.com/docs/pyats/#!introduction/pyats-genie](https://developer.cisco.com/docs/pyats/#!introduction/pyats-genie)'
- en: 'For more information regarding `json_query` and its syntax, please consult
    the following URLs:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`json_query`及其语法的更多信息，请参考以下网址：
- en: '[https://docs.Ansible.com/Ansible/latest/user_guide/playbooks_filters.html#json-query-filter](https://docs.Ansible.com/Ansible/latest/user_guide/playbooks_filters.html#json-query-filter)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.Ansible.com/Ansible/latest/user_guide/playbooks_filters.html#json-query-filter](https://docs.Ansible.com/Ansible/latest/user_guide/playbooks_filters.html#json-query-filter)'
- en: '[http://jmespath.org/tutorial.html](http://jmespath.org/tutorial.html)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://jmespath.org/tutorial.html](http://jmespath.org/tutorial.html)'
