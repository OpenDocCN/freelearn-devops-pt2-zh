- en: Interacting with Kubernetes Clusters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Kubernetes集群交互
- en: 'As a Kubernetes cluster user or operator, you need to interact with the Kubernetes
    API to manage Kubernetes Objects or debug applications running in the cluster.
    Generally, there are two ways to communicate with the Kubernetes API: you can
    use representational state transfer (RESTful) HTTPS endpoints directly—for example,
    for programmatic access—or you can use kubectl, which is the Kubernetes command-line
    tool (or **command-line interface** (**CLI**)). In general, kubectl wraps RESTful
    API communication and hides the complexity regarding locating and authenticating
    to the Kubernetes API server. Operations such as creating or listing Kubernetes
    Objects and executing into Pod containers are available as neatly organized kubectl
    sub-commands—you can use these commands when performing ad hoc operations on your
    cluster or as a part of **continuous integration/continuous deployment** (**CI/CD**)
    for your applications.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Kubernetes集群的用户或操作员，您需要与Kubernetes API交互，以管理Kubernetes对象或调试在集群中运行的应用程序。一般来说，有两种方式与Kubernetes
    API通信：您可以直接使用表征状态传输（RESTful）HTTPS端点，例如用于编程访问，或者您可以使用kubectl，这是Kubernetes命令行工具（或**命令行接口**（**CLI**））。一般来说，kubectl封装了RESTful
    API通信，并隐藏了有关定位和认证到Kubernetes API服务器的复杂性。创建或列出Kubernetes对象以及执行Pod容器等操作都作为整齐组织的kubectl子命令可用-您可以在对集群执行临时操作时使用这些命令，也可以作为应用程序的**持续集成/持续部署**（**CI/CD**）的一部分使用这些命令。
- en: In this chapter, we will provide you with a better understanding of how to install
    kubectl on a Windows machine and how to manage multiple Kubernetes clusters using
    kubectl. You will also learn the most common and useful kubectl commands for managing
    Kubernetes Objects and debugging containerized applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为您提供如何在Windows机器上安装kubectl以及如何使用kubectl管理多个Kubernetes集群的更好理解。您还将学习管理Kubernetes对象和调试容器化应用程序最常见和有用的kubectl命令。
- en: 'This chapter consists of the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题：
- en: Installing Kubernetes command-line tooling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Kubernetes命令行工具
- en: Accessing Kubernetes clusters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问Kubernetes集群
- en: Working with development clusters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用开发集群
- en: Looking at common kubectl commands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看常见的kubectl命令
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following installed:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，您需要安装以下内容：
- en: Windows 10 Pro, Enterprise, or Education (version 1903 or later, 64-bit)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 10专业版、企业版或教育版（1903版本或更高版本，64位）
- en: Docker Desktop for Windows 2.0.0.3, or later
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 2.0.0.3或更高版本的Docker桌面版
- en: Chocolatey package manager for Windows ([https://chocolatey.org/](https://chocolatey.org/))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows的Chocolatey软件包管理器（[https://chocolatey.org/](https://chocolatey.org/)）
- en: The Azure CLI
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure CLI
- en: Installation of Docker Desktop for Windows and system requirements are covered
    in [Chapter 1](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml)*, Creating Containers*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Windows上Docker桌面版的安装和系统要求，请参阅[第1章](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml)*，*创建容器*。
- en: Using the Chocolatey package manager is not mandatory, but it makes the installation
    process and application version management much easier. The installation process
    is documented here: [https://chocolatey.org/install](https://chocolatey.org/install).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Chocolatey软件包管理器并非强制，但它可以使安装过程和应用程序版本管理更加容易。安装过程在此处有文档记录：[https://chocolatey.org/install](https://chocolatey.org/install)。
- en: For the Azure CLI, you can find detailed installation instructions in [Chapter
    2](43d5e48b-311c-462c-a68e-6a0b5c4224e8.xhtml)*, Managing State in Containers**.*
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Azure CLI，您可以在[第2章](43d5e48b-311c-462c-a68e-6a0b5c4224e8.xhtml)*，*管理容器中的状态**中找到详细的安装说明。
- en: To follow along using **Azure Kubernetes Service** (**AKS**), you will need
    your own Azure account and AKS instance created. If you haven't already created
    the account for previous chapters, you can read more about how to obtain a limited
    free account for personal use here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
    AKS cluster deployment is covered in [Chapter 4](118e3c89-786e-4718-ba67-6c38928e2a42.xhtml),
    *Kubernetes Concepts and Windows Support*. You can also use the PowerShell script
    provided in that chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用**Azure Kubernetes Service**（**AKS**）进行跟随，您将需要自己的Azure帐户和已创建的AKS实例。如果您之前没有为前几章创建帐户，您可以在此处阅读有关如何获取个人使用的有限免费帐户的更多信息：[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)。AKS集群部署在[第4章](118e3c89-786e-4718-ba67-6c38928e2a42.xhtml)中进行了介绍，*Kubernetes概念和Windows支持*。您还可以在该章节中使用提供的PowerShell脚本。
- en: You can download the latest code samples for this chapter from the official
    GitHub repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter06).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从官方GitHub存储库下载本章的最新代码示例：[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter06)。
- en: Installing Kubernetes command-line tooling
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Kubernetes命令行工具
- en: 'Kubectl is available on a variety of operating systems, including Windows.
    If you have experience with using kubectl on Linux, you can expect that the only
    difference will be the installation process—the commands and basic principles
    remain the same. For Windows, you have several options for kubectl installation,
    as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl可在多种操作系统上使用，包括Windows。如果您在Linux上使用kubectl有经验，您可以期望唯一的区别是安装过程，命令和基本原则保持不变。对于Windows，您有几种kubectl安装选项，如下所示：
- en: Download the kubectl binary directly.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接下载kubectl二进制文件。
- en: Use the PowerShell Gallery ([https://www.powershellgallery.com/](https://www.powershellgallery.com/)).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PowerShell Gallery（[https://www.powershellgallery.com/](https://www.powershellgallery.com/)）。
- en: 'Use third-party Windows package managers: Chocolatey ([https://chocolatey.org/](https://chocolatey.org/))
    or Scoop ([https://scoop.sh/](https://scoop.sh/)).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方Windows软件包管理器：Chocolatey（[https://chocolatey.org/](https://chocolatey.org/)）或Scoop（[https://scoop.sh/](https://scoop.sh/)）。
- en: Kubectl can also be installed automatically by Docker Desktop for Windows while
    creating a local development Kubernetes cluster (executable installed in `C:\Program
    Files\Docker\Docker\Resources\bin\kubectl.exe`) or using the Azure CLI when creating
    the AKS cluster instance (using the `az aks install-cli` command, which installs
    kubectl in `~/.azure-kubectl/kubectl.exe`). This may create conflicts with already
    installed kubectl instances in different locations—you can always check which
    kubectl installation is used in PowerShell by using the `(Get-Command kubectl).Path`
    command. Switching to a different kubectl installation requires the `PATH` environment
    to be modified and the desired precedence to be ensured.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建本地开发Kubernetes集群时，Docker Desktop for Windows也可以自动安装kubectl（可执行文件安装在`C:\Program
    Files\Docker\Docker\Resources\bin\kubectl.exe`），或者在创建AKS集群实例时使用Azure CLI（使用`az
    aks install-cli`命令，在`~/.azure-kubectl/kubectl.exe`中安装kubectl）。这可能会与不同位置已安装的kubectl实例产生冲突—您可以始终通过使用`(Get-Command
    kubectl).Path`命令在PowerShell中检查使用哪个kubectl安装。切换到不同的kubectl安装需要修改`PATH`环境并确保所需的优先级。
- en: 'You can find detailed instructions for all installation types in the official
    documentation: [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/).
    We will demonstrate how to install kubectl using Chocolatey, as this is the easiest
    and the most convenient way to install kubectl on Windows. Follow these steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中找到所有安装类型的详细说明：[https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)。我们将演示如何使用Chocolatey安装kubectl，因为这是在Windows上安装kubectl的最简单和最便捷的方式。按照以下步骤进行操作：
- en: If you haven't installed the Chocolatey package manager already, you can find
    the instructions to do so here: [https://chocolatey.org/install](https://chocolatey.org/install).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有安装Chocolatey软件包管理器，您可以在这里找到安装说明：[https://chocolatey.org/install](https://chocolatey.org/install)。
- en: 'Open the PowerShell window as Administrator, and install kubectl using the
    following command:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以管理员身份打开PowerShell窗口，并使用以下命令安装kubectl：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you need to upgrade kubectl to the latest version, use the following command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您需要将kubectl升级到最新版本，请使用以下命令：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Verify that kubectl has been installed, using—for example—the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证kubectl是否已安装，例如使用以下命令：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: According to the Kubernetes version skew support policy, you should use a version
    of kubectl that is within one minor version (older or newer) of kube-apiserver.
    For example, kubectl 1.15 is guaranteed to work with kube-apiserver 1.14, 1.15,
    and 1.16\. It is advised that you use the latest kubectl version for your cluster
    whenever possible.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Kubernetes版本支持策略，您应该使用一个在kube-apiserver的次要版本（较旧或较新）之内的kubectl版本。例如，kubectl
    1.15保证可以与kube-apiserver 1.14、1.15和1.16一起使用。建议您在可能的情况下使用集群的最新kubectl版本。
- en: Please note that the version of kubectl installed from Chocolatey may sometimes
    be older than the latest available stable version. In this case, if you need the
    latest stable version, follow the instructions for downloading the kubectl binary
    directly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过Chocolatey安装的kubectl版本有时可能比最新的稳定版本要旧。在这种情况下，如果您需要最新的稳定版本，请按照直接下载kubectl二进制文件的说明进行操作。
- en: In the next section, we are going to demonstrate how you can organize access
    to multiple Kubernetes clusters.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将演示如何组织访问多个Kubernetes集群。
- en: Accessing Kubernetes clusters
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问Kubernetes集群
- en: By default, kubectl uses the `kubeconfig` file located in `~\.kube\config` (note
    that we call it `kubeconfig`, but the filename is `config`), which on Windows
    machines expands to `C:\Users\<currentUser>\.kube\config`. This YAML configuration
    file contains all the parameters required for kubectl to connect to the Kubernetes
    API for your cluster. This configuration file may be also used by different tools
    than kubectl—for example, *Helm*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，kubectl使用位于`~\.kube\config`的`kubeconfig`文件（请注意我们称其为`kubeconfig`，但文件名为`config`），在Windows机器上会扩展为`C:\Users\<currentUser>\.kube\config`。这个YAML配置文件包含kubectl连接到您集群的Kubernetes
    API所需的所有参数。这个配置文件也可以被除kubectl之外的其他工具使用，例如*Helm*。
- en: You can use the `KUBECONFIG` environment variable or the `--kubeconfig` flag
    for individual commands to force kubectl to use a different `kubeconfig`. For
    the `KUBECONFIG` environment variable, it is possible to specify multiple `kubeconfig` and
    merge them in runtime. You can read more about this feature in the official documentation: [https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#merging-kubeconfig-files](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#merging-kubeconfig-files).
    Please note that, for Windows, you should specify `KUBECONFIG` paths separated
    by a semicolon, contrary to Linux, where you use a colon.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`KUBECONFIG`环境变量或`--kubeconfig`标志来强制kubectl对个别命令使用不同的`kubeconfig`。对于`KUBECONFIG`环境变量，可以在运行时指定多个`kubeconfig`并合并它们。您可以在官方文档中阅读更多关于此功能的信息：[https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#merging-kubeconfig-files](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#merging-kubeconfig-files)。请注意，对于Windows，您应该用分号分隔`KUBECONFIG`路径，而在Linux中，您应该使用冒号。
- en: 'Coordinating access to multiple Kubernetes clusters is organized in `kubeconfig`
    using contexts. Each context contains the following information:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文在`kubeconfig`中协调访问多个Kubernetes集群。每个上下文包含以下信息：
- en: '**Cluster**: The address of the Kubernetes API server.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群**：Kubernetes API服务器的地址。'
- en: '**User**: The name of the user, which maps to user credentials (specified in
    `kubeconfig`).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：用户的名称，映射到用户凭据（在`kubeconfig`中指定）。'
- en: '**Namespace**: Optionally, you can provide the default namespace to use.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间**：可选地，您可以提供要使用的默认命名空间。'
- en: 'If you have been following the previous chapters, where we demonstrated the
    installation of Minikube and the local Kubernetes cluster in Docker Desktop for
    Windows, you have already used contexts that have been automatically added during
    installation of these clusters. When using kubectl, there is always one context
    marked as current. You can see the current context using the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直在关注之前的章节，我们演示了Minikube的安装和Windows Docker桌面上的本地Kubernetes集群的安装，您已经使用了在安装这些集群时自动添加的上下文。在使用kubectl时，始终有一个上下文标记为当前。您可以使用以下命令查看当前上下文：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing all of the available contexts in your `kubeconfig` can be done in the
    following way:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列出`kubeconfig`中所有可用的上下文可以通过以下方式完成：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you would like to switch to a different context, for example, `docker-desktop`,
    execute the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想切换到不同的上下文，例如`docker-desktop`，执行以下命令：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can modify the existing contexts or add your own contexts manually from
    the command line. For example, the following command will add a new context, `docker-desktop-kube-system`,
    which will connect to the `docker-desktop` cluster and use the `kube-system` namespace
    by default:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从命令行手动修改现有上下文或添加自己的上下文。例如，以下命令将添加一个新的上下文`docker-desktop-kube-system`，它将连接到`docker-desktop`集群并默认使用`kube-system`命名空间。
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you switch to the new context and run any command, for example, `kubectl
    get pods`, it will be executed against the `kube-system` namespace.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当您切换到新的上下文并运行任何命令时，例如`kubectl get pods`，它将针对`kube-system`命名空间执行。
- en: At any given time, you can override the current context settings using `--cluster`,
    `--user`, `--namespace`, or even `--context` flags for kubectl commands.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何给定时间，您可以使用kubectl命令的`--cluster`、`--user`、`--namespace`甚至`--context`标志来覆盖当前上下文设置。
- en: 'Typically, when working with managed Kubernetes providers or local development
    tools, the config will be either served as a separate file to download and use
    via the `KUBECONFIG` environment variable, or merged directly into the current
    `kubeconfig` as a new context (this is what the `az aks get-credentials` command
    does, in the case of AKS). If needed, you can perform merging of `kubeconfigs`
    manually, using the following PowerShell command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在使用托管的Kubernetes提供程序或本地开发工具时，配置文件将作为一个单独的文件提供，通过`KUBECONFIG`环境变量进行下载和使用，或者直接合并到当前的`kubeconfig`中作为一个新的上下文（这就是在AKS的情况下`az
    aks get-credentials`命令所做的）。如果需要，您可以使用以下PowerShell命令手动合并`kubeconfigs`：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of this command can be used as a new default `kubeconfig`—you should
    verify if the result is valid before overwriting the default configuration file.
    You can use the following code snippet to overwrite the default `kubeconfig` with
    a merged one:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出可以作为一个新的默认`kubeconfig`使用——在覆盖默认配置文件之前，您应该验证结果是否有效。您可以使用以下代码片段将默认的`kubeconfig`覆盖为合并后的配置：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Remember about the `kubeconfig` merging precedence rules: the value in the
    first file wins if the same key is found in both files.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住`kubeconfig`合并优先规则：如果在两个文件中找到相同的键，则第一个文件中的值将获胜。
- en: Now you know how to manage access to Kubernetes clusters using kubeconfig and
    kubectl contexts, let's focus on strategies for working with development clusters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何使用kubeconfig和kubectl上下文来管理对Kubernetes集群的访问权限，让我们专注于使用开发集群的策略。
- en: Working with development clusters
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用开发集群
- en: Developing applications for Kubernetes introduces some unique challenges that
    are not present for classical development pipelines. The perfect solution would
    be introducing minimal changes to the pipelines and processes, but, unfortunately,
    it is not as simple as that. First of all, you need to maintain a development
    Kubernetes cluster where you deploy, test, and debug your applications. Secondly,
    you have to containerize your applications and deploy them to the dev cluster,
    possibly with more flexibility and access than in a secure production cluster.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为Kubernetes开发应用程序引入了一些在传统开发流水线中不存在的独特挑战。完美的解决方案将是对流水线和流程进行最小的更改，但不幸的是，事情并不像那么简单。首先，您需要维护一个开发Kubernetes集群，用于部署、测试和调试您的应用程序。其次，您必须将应用程序容器化并部署到开发集群，可能比在安全的生产集群中具有更大的灵活性和访问权限。
- en: 'Informally, for Kubernetes applications development, you have four modes (concepts)
    that have been illustrated in the following diagram:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地，对于Kubernetes应用程序开发，您有四种模式（概念），如下图所示：
- en: '![](assets/372af989-6426-492e-9380-3760131cdc5f.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/372af989-6426-492e-9380-3760131cdc5f.png)'
- en: 'Let''s have a look at these four modes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这四种模式：
- en: '**Fully offline**: In a fully offline (local) environment, your development
    environment and Kubernetes cluster are hosted locally on your machine. A good
    example of such a configuration is a Minikube or Docker Desktop for Windows local
    Kubernetes cluster. In both cases, the Kubernetes cluster is hosted in a dedicated
    local **virtual machine** (**VM**). This development workflow requires the building
    of Docker images, pushing them to an image registry (local or remote), and using
    kubectl to deploy the application. You can, of course, leverage the fact that
    the cluster is running locally, and log in to the cluster nodes and debug the
    Pod containers. From a Windows containers'' perspective, this requires running
    a full, hybrid Linux/Windows Kubernetes cluster on Hyper-V VMs. This setup requires
    a local machine that is capable of running at least two VMs: one for the Linux
    master and one for the Windows worker node. We will be deploying a fully functional
    hybrid cluster in [Chapter 7](165c2fcc-4ce8-4dbc-a19c-c7fd427b3379.xhtml), *Deploying
    Hybrid On-Premises Kubernetes Cluster*.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全脱机**：在完全脱机（本地）环境中，您的开发环境和Kubernetes集群托管在本地机器上。这种配置的一个很好的例子是Minikube或Windows本地Kubernetes集群的Docker桌面。在这两种情况下，Kubernetes集群托管在专用的本地虚拟机（VM）中。这种开发工作流程需要构建Docker镜像，将它们推送到镜像注册表（本地或远程），并使用kubectl部署应用程序。当然，您可以利用集群在本地运行的事实，登录到集群节点并调试Pod容器。从Windows容器的角度来看，这需要在Hyper-V
    VM上运行完整的混合Linux/Windows Kubernetes集群。这种设置需要一台能够运行至少两个VM的本地机器：一个用于Linux主节点，一个用于Windows工作节点。我们将在[第7章](165c2fcc-4ce8-4dbc-a19c-c7fd427b3379.xhtml)中部署一个完全功能的混合集群，*部署混合本地Kubernetes集群*。'
- en: The deployment strategies that are presented in the next chapters can be used
    for both development and production clusters. The disadvantage of this approach
    for development is the significant amount of configuration compared to Minikube
    or other fully offline solutions. Unfortunately, at this point, there are no easy
    turnkey solutions for hybrid development clusters—if you need a cluster for development
    as soon as possible, the fully managed AKS is the best option.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章介绍的部署策略可以用于开发和生产集群。这种方法在开发中的缺点是与Minikube或其他完全脱机解决方案相比需要大量配置。不幸的是，目前还没有针对混合开发集群的易用的即插即用解决方案
    - 如果您需要尽快为开发创建集群，完全托管的AKS是最佳选择。
- en: '**Proxied**: When using a proxied environment, your Kubernetes cluster is hosted
    on a remote machine (but it can be also hosted on local VMs!). The development
    environment is still on your local machine, but you have a two-way network proxy
    configured so that you can run and debug your applications as if you were "inside"
    of a Pod in the cluster. In other words, you can simplify your development workflow
    and skip Docker overhead for development and debugging scenarios. This can be
    achieved using tools such as Telepresence ([https://www.telepresence.io/](https://www.telepresence.io/)).
    Unfortunately, Windows is currently supported only through Windows Subsystem for
    Linux, which means that there is no native Windows support.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**：在使用代理环境时，您的Kubernetes集群托管在远程机器上（但也可以托管在本地VM上！）。开发环境仍然在您的本地机器上，但您配置了双向网络代理，以便您可以运行和调试应用程序，就好像您在集群中的Pod内部一样。换句话说，您可以简化开发工作流程，并跳过开发和调试场景的Docker开销。这可以通过使用诸如Telepresence（[https://www.telepresence.io/](https://www.telepresence.io/)）之类的工具来实现。不幸的是，目前仅通过Windows子系统支持Windows，这意味着没有本机Windows支持。'
- en: '**Remote**: The next mode is remote, whereby you develop locally against a
    remote cluster, either hosted in your local data center or as a managed Kubernetes
    offering. This is similar to using a fully offline environment, but you have to
    beware of extra costs of using managed Kubernetes clusters and limited access
    to Kubernetes nodes. For Windows, if you are running AKS, you will not be able
    to log in to the Linux master, but, if you are deploying using AKS engine on bare
    Azure VMs, you can access both the Linux master and the Windows nodes. The advantage
    of this environment type is that you can leverage all cloud integrations for Kubernetes,
    such as LoadBalancer Services or Cloud Volumes. We will be covering AKS engine
    deployment in [Chapter 8](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml), *Deploying
    Hybrid Azure Kubernetes Service Cluster*.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程：下一个模式是远程模式，您可以在本地针对远程集群进行开发，这些集群可以托管在您的本地数据中心或作为托管的Kubernetes提供。这类似于在完全脱机环境中使用，但您必须注意使用托管Kubernetes集群的额外成本以及对Kubernetes节点的有限访问。对于Windows，如果您正在运行AKS，您将无法登录到Linux主节点，但如果您使用裸Azure
    VM上的AKS引擎进行部署，您可以访问Linux主节点和Windows节点。这种环境类型的优势在于您可以利用Kubernetes的所有云集成，例如负载均衡器服务或云卷。我们将在[第8章](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml)中介绍AKS引擎部署，*部署混合Azure
    Kubernetes服务集群*。
- en: '**Fully Online**: In fully online mode, your development environment, together
    with the Kubernetes cluster, is hosted remotely. Good examples of such an approach
    are Eclipse Che ([https://www.eclipse.org/che/docs/](https://www.eclipse.org/che/docs/))
    and Azure Dev Spaces ([https://docs.microsoft.com/en-us/azure/dev-spaces/about](https://docs.microsoft.com/en-us/azure/dev-spaces/about)),
    which fully integrates with Visual Studio Code. Support for Windows nodes is still
    in development at this point and requires manual configuration ([https://docs.microsoft.com/en-us/azure/dev-spaces/how-to/run-dev-spaces-windows-containers](https://docs.microsoft.com/en-us/azure/dev-spaces/how-to/run-dev-spaces-windows-containers)).
    In the future, this is the best candidate for offering a seamless Kubernetes development
    life cycle for Windows containers. We will cover Azure Dev Spaces in [Chapter
    12](028affe7-4a23-4c9b-8a24-9c0671efe5e5.xhtml), *Development Workflow with Kubernetes*.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全在线：在完全在线模式下，您的开发环境与Kubernetes集群一起远程托管。这种方法的良好示例是Eclipse Che ([https://www.eclipse.org/che/docs/](https://www.eclipse.org/che/docs/))和Azure
    Dev Spaces ([https://docs.microsoft.com/en-us/azure/dev-spaces/about](https://docs.microsoft.com/en-us/azure/dev-spaces/about))，它与Visual
    Studio Code完全集成。在这一点上，对Windows节点的支持仍在开发中，并且需要手动配置([https://docs.microsoft.com/en-us/azure/dev-spaces/how-to/run-dev-spaces-windows-containers](https://docs.microsoft.com/en-us/azure/dev-spaces/how-to/run-dev-spaces-windows-containers))。将来，这是为Windows容器提供无缝Kubernetes开发生命周期的最佳选择。我们将在[第12章](028affe7-4a23-4c9b-8a24-9c0671efe5e5.xhtml)中介绍Azure
    Dev Spaces，*Kubernetes开发工作流程*。
- en: There are many tools that can boost your Kubernetes application development
    productivity and reduce the overhead of having "another cluster in the middle
    of everything". For example, for Windows support, you may want to check out Azure
    Draft ([https://draft.sh/](https://draft.sh/)), which simplifies the development
    pipeline using auto-generated Helm charts for your application, or ksync ([https://ksync.github.io/ksync/](https://ksync.github.io/ksync/)),
    which can be used for syncing your local code/binary changes to Pod containers,
    without a need for redeployment.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以提高您的Kubernetes应用程序开发效率，并减少在“一切中间又有一个集群”的开销。例如，对于Windows支持，您可能希望查看Azure
    Draft ([https://draft.sh/](https://draft.sh/))，它可以使用为您的应用程序自动生成的Helm图表简化开发流程，或者ksync
    ([https://ksync.github.io/ksync/](https://ksync.github.io/ksync/))，它可用于将本地代码/二进制更改同步到Pod容器，无需重新部署。
- en: In the next section, we will take a quick look at the most common and useful
    kubectl commands that you should have in your toolbox.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将快速浏览一下您应该掌握的最常见和有用的kubectl命令。
- en: Looking at common kubectl commands
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看常见的kubectl命令
- en: 'Kubectl is a powerful tool that provides most of the functionalities you will
    ever need when interacting with Kubernetes clusters. All of the kubectl commands
    follow the same syntax, as shown in the following code snippet:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl是一个强大的工具，当与Kubernetes集群交互时，它提供了您所需的大部分功能。所有kubectl命令都遵循相同的语法，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`[command]`, `[type]`, `[name]`, and `[flags]` are defined as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`[命令]`、`[类型]`、`[名称]`和`[标志]`的定义如下：'
- en: '`[command]` specifies the operation—for example `get`, `apply`, `delete`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[命令]`指定操作，例如`get`、`apply`、`delete`。'
- en: '`[type]` is the resource type (a detailed list can be found in the documentation:
    [https://kubernetes.io/docs/reference/kubectl/overview/#resource-types](https://kubernetes.io/docs/reference/kubectl/overview/#resource-types)),
    specified in singular, plural, or abbreviated form (case-insensitive)—for example, `service`,
    `services`, `svc`. You can find more information about each resource by using
    the `kubectl explain [type]` command.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[类型]`是资源类型（详细列表可以在文档中找到：[https://kubernetes.io/docs/reference/kubectl/overview/#resource-types](https://kubernetes.io/docs/reference/kubectl/overview/#resource-types)），以单数、复数或缩写形式（不区分大小写）指定，例如，`service`、`services`、`svc`。您可以使用`kubectl
    explain [type]`命令找到有关每个资源的更多信息。'
- en: '`[name]` determines the name of the resource (case-sensitive). If the command
    allows the name to be omitted, the operation will be applied to all resources
    of a given type.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[名称]`确定资源的名称（区分大小写）。如果命令允许省略名称，则操作将应用于给定类型的所有资源。'
- en: '`[flags]` specifies the additional flags, which are either specific for a command
    or global for kubectl—for example, `--namespace kube-system`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[标志]` 指定了额外的标志，这些标志可以是特定于命令的，也可以是全局的kubectl命令，例如，`--namespace kube-system`。'
- en: You can always use `kubectl help` or `kubectl [command] --help` to access comprehensive
    documentation on how each command works and what the available flags are. The
    official reference for kubectl can be found here: [https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随时使用`kubectl help`或`kubectl [command] --help`来访问关于每个命令如何工作以及可用标志的全面文档。kubectl的官方参考资料可以在这里找到：[https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands)。
- en: The terms *resource *and *object *are often used in Kubernetes interchangeably,
    although there are some differences considering Kubernetes internals. Objects
    are Kubernetes system entities (abstract concepts), whereas resources are the
    actual RESTful API resources that provide a representation of objects.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*资源*和*对象*在Kubernetes中经常可以互换使用，尽管在考虑Kubernetes内部时存在一些差异。对象是Kubernetes系统实体（抽象概念），而资源是提供对象表示的实际RESTful
    API资源。
- en: Some of the commands, such as `get` or `create`, allow you to specify the output
    format using the `-o` or `--output` flag. For example, you can use `-o json` to
    force JSON output format, or `-o jsonpath=<template>` to extract information using
    JSONPath templates. This is especially useful when implementing automation based
    on kubectl commands. You can find more information about output types here: [https://kubernetes.io/docs/reference/kubectl/overview/#output-options](https://kubernetes.io/docs/reference/kubectl/overview/#output-options).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一些命令，如 `get` 或 `create`，允许您使用 `-o` 或 `--output` 标志指定输出格式。例如，您可以使用 `-o json`
    强制使用 JSON 输出格式，或者使用 `-o jsonpath=<template>` 使用 JSONPath 模板提取信息。这在基于 kubectl 命令实施自动化时特别有用。您可以在这里找到有关输出类型的更多信息：[https://kubernetes.io/docs/reference/kubectl/overview/#output-options](https://kubernetes.io/docs/reference/kubectl/overview/#output-options)。
- en: For *Bash* and *Zsh*, you can increase your kubectl productivity by using autocompletion([https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion](https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion)).
    For Windows, there is no autocompletion support for PowerShell yet, but, if you
    manage your Kubernetes cluster using Windows Subsystem for Linux, you can install
    Bash autocompletion as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *Bash* 和 *Zsh*，您可以通过使用自动补全（[https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion](https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion)）来提高
    kubectl 的生产力。对于 Windows，PowerShell 尚不支持自动补全，但是，如果您使用 Windows Subsystem for Linux
    管理 Kubernetes 集群，也可以安装 Bash 自动补全。
- en: Creating resources
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建资源
- en: In [Chapter 4](118e3c89-786e-4718-ba67-6c38928e2a42.xhtml), *Kubernetes Concepts
    and Windows Support*, we have explained the ideas behind *imperative* and *declarative*
    resource management in Kubernetes. In short, when using imperative management,
    you rely on commands that create, delete, and replace resources (think of commands
    in a script). On the other hand, in declarative management, you only describe
    the desired state of a resource, and Kubernetes performs all the required actions
    to transform the current state of a resource to the desired one.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](118e3c89-786e-4718-ba67-6c38928e2a42.xhtml)中，*Kubernetes 概念和 Windows
    支持*，我们已经解释了 Kubernetes 中 *命令式* 和 *声明式* 资源管理背后的思想。简而言之，在使用命令式管理时，您依赖于创建、删除和替换资源的命令（可以将其视为脚本中的命令）。另一方面，在声明式管理中，您只描述资源的期望状态，Kubernetes
    将执行所有必需的操作，以将资源的当前状态转换为期望状态。
- en: 'Creating a Kubernetes resource in an imperative way can be done using the `kubectl
    create -f <manifestFile>` command. For the declarative way, you have to use `kubectl
    apply -f <manifestFile>`. Note that you can apply the `-R` flag and process a
    directory *recursively* instead of a single file. Let''s demonstrate this on an
    example Deployment manifest file for Linux nginx Pods, which you can download
    from the GitHub repository for this book: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter06/01_deployment-example/nginx-deployment.yaml](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter06/01_deployment-example/nginx-deployment.yaml).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以命令式方式在 Kubernetes 中创建资源可以使用 `kubectl create -f <manifestFile>` 命令。对于声明式方式，您必须使用
    `kubectl apply -f <manifestFile>`。请注意，您可以应用 `-R` 标志并递归处理目录而不是单个文件。让我们在 Linux nginx
    Pods 的示例部署清单文件上演示这一点，您可以从本书的 GitHub 存储库下载：[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter06/01_deployment-example/nginx-deployment.yaml](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter06/01_deployment-example/nginx-deployment.yaml)。
- en: 'Assuming that you saved the manifest file as `nginx-deployment.yaml` in the
    current directory, use PowerShell to execute the following command to create a `nginx-deployment-example`
    Deployment:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您将清单文件保存为 `nginx-deployment.yaml` 在当前目录中，使用 PowerShell 执行以下命令来创建 `nginx-deployment-example`
    部署：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can use the URL for manifest files directly in kubectl—for example, `kubectl
    create -f https://raw.githubusercontent.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/master/Chapter06/01_deployment-example/nginx-deployment.yaml`.
    Remember to always verify the contents of the manifest file, especially from a
    security perspective, before deploying them to your cluster.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接在kubectl中使用清单文件的URL-例如，`kubectl create -f https://raw.githubusercontent.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/master/Chapter06/01_deployment-example/nginx-deployment.yaml`。在将其部署到集群之前，请始终验证清单文件的内容，特别是从安全角度考虑。
- en: 'You can achieve the same using the `kubectl apply` command, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`kubectl apply`命令来实现相同的效果，如下所示：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At this point, these commands behave in the same way: they just create the
    Deployment. But now, if you modify the `nginx-deployment.yaml` file so that the
    number of replicas is increased to 4, check what happens for the `kubectl create`
    and `kubectl apply` commands:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，这些命令的行为方式相同：它们只是创建Deployment。但是现在，如果您修改`nginx-deployment.yaml`文件，以便将副本的数量增加到4，请检查`kubectl
    create`和`kubectl apply`命令的结果：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating the Deployment imperatively is not possible because it has been already
    created—you would have to replace it. In the case of a declarative `apply` command,
    the change has been accepted, and the existing Deployment has been scaled to 4
    replicas.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于已经创建了Deployment，因此无法通过命令方式创建它-您需要替换它。在声明性的`apply`命令的情况下，更改已被接受，并且现有的Deployment已被扩展为4个副本。
- en: 'For declarative management, kubectl offers the `kubectl diff` command, which
    shows the difference between the current state of resources in the cluster and
    in the manifest file. Note that you need to have the `diff` tool in your `PATH`
    environment variable or use any other file-compare tool—for example, Meld ([http://meldmerge.org/](http://meldmerge.org/))—and
    specify it using the `KUBECTL_EXTERNAL_DIFF` environment variable. Increase the
    number of `replicas` to 5 in `nginx-deployment.yaml`, and check the comparison
    result, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于声明性管理，kubectl提供了`kubectl diff`命令，该命令显示了集群中资源的当前状态与清单文件中资源的差异。请注意，您需要在`PATH`环境变量中拥有`diff`工具，或者使用任何其他文件比较工具-例如Meld
    ([http://meldmerge.org/](http://meldmerge.org/))，并使用`KUBECTL_EXTERNAL_DIFF`环境变量指定它。将`nginx-deployment.yaml`中的`replicas`数量增加到5，并检查比较结果，如下所示：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can immediately see in the following screenshot which properties will be
    affected if you execute `kubectl apply`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以立即在以下截图中看到，如果执行`kubectl apply`，将受到影响的属性：
- en: '![](assets/e2108316-c229-42c4-b292-d6dcfd8a87c4.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e2108316-c229-42c4-b292-d6dcfd8a87c4.png)'
- en: A general rule of thumb is that you should stick to declarative resource management
    whenever possible and leave imperative commands only for development/hacking scenarios.
    For fully declarative management of your Kubernetes applications, consider kubectl
    with Kustomize. You can read more about this approach at: [https://kubernetes.io/docs/tasks/manage-kubernetes-objects/kustomization/](https://kubernetes.io/docs/tasks/manage-kubernetes-objects/kustomization/).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验法则是，尽可能坚持使用声明性资源管理，只将命令留给开发/黑客场景。对于Kubernetes应用程序的完全声明性管理，请考虑使用带有Kustomize的kubectl。您可以在以下链接了解更多关于这种方法的信息：[https://kubernetes.io/docs/tasks/manage-kubernetes-objects/kustomization/](https://kubernetes.io/docs/tasks/manage-kubernetes-objects/kustomization/)。
- en: Deleting resources
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除资源
- en: In order to delete resources, you can use the `kubectl delete [type] [name]`
    command. This is also one of the imperative commands that are still recommended
    to be used in declarative cluster management, as it is more explicit. Using `kubectl
    apply` with the `--prune` flag is more dangerous, as you can accidentally delete
    more resources.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除资源，您可以使用`kubectl delete [type] [name]`命令。这也是仍然建议在声明性集群管理中使用的命令之一，因为它更明确。使用带有`--prune`标志的`kubectl
    apply`更危险，因为您可能会意外删除更多资源。
- en: 'Use the following command to delete the `nginx-deployment-example` Deployment:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令删除`nginx-deployment-example`部署：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can specify the `--all` flag instead of the resource name if you want to
    delete all resources of a given type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想删除给定类型的所有资源，可以使用`--all`标志而不是资源名称。
- en: Describing and listing resources
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述和列出资源
- en: 'The next command that you will often use is `kubectl get [type] [name]`, which
    shows detailed information about resource(s) of a given type. For example, in
    order to list Pods in the default namespace for the current context, execute the
    following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个你经常会使用的命令是`kubectl get [type] [name]`，它显示给定类型的资源的详细信息。例如，为了列出当前上下文中默认命名空间中的Pods，执行以下命令：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can use the `--all-namespaces` or `--namespace=<namespace>` global flags,
    which allow you to show resources from other namespaces, as illustrated in the
    following code snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`--all-namespaces`或`--namespace=<namespace>`全局标志，允许您显示来自其他命名空间的资源，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By default, this command shows limited, predefined columns. You can see more
    details by using the `-o wide` flag, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这个命令显示有限的预定义列。您可以使用`-o wide`标志来查看更多细节，如下所示：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In some cases, you will find it useful to watch resources. The following command
    lists all the Pods and periodically refreshes the view with the latest data:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您会发现观察资源很有用。以下命令列出所有Pods，并定期刷新视图以获取最新数据：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There is also a different command, `kubectl describe`, which can be used for
    showing resource details, as illustrated in the following code snippet:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个不同的命令，`kubectl describe`，它可以用于显示资源的详细信息，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The difference between the `get` and `describe` commands is that `get` shows
    a pure representation of a resource from Kubernetes API, whereas `describe` prepares
    a detailed description, including events, controllers, and other resources.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`和`describe`命令的区别在于，`get`显示来自Kubernetes API的资源的纯表示，而`describe`准备了一个包括事件、控制器和其他资源在内的详细描述。'
- en: '`kubectl get` supports different outputs than tables—for example, `-o json`
    or `-o yaml`, which are good for integrations with other tools or dumping a resource
    state to file, as illustrated in the following code snippet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get`支持不同于表格的输出，例如，`-o json`或`-o yaml`，这对于与其他工具集成或将资源状态转储到文件非常有用，如下面的代码片段所示：'
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you need more processing of the output, you can use JSONPath ([https://github.com/json-path/JsonPath](https://github.com/json-path/JsonPath)),
    which is integrated into kubectl. For example, the following expression will list
    all container images being used in Pods in the cluster:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要对输出进行更多处理，你可以使用JSONPath ([https://github.com/json-path/JsonPath](https://github.com/json-path/JsonPath))，它集成到kubectl中。例如，以下表达式将列出集群中Pods中使用的所有容器镜像：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And lastly, you may find it useful to list all resources from all namespaces
    with just a single command, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可能会发现使用单个命令列出所有命名空间中的所有资源很有用，如下所示：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This should always give you a good overview of what is happening in the cluster!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该总是给你一个集群中正在发生的事情的很好的概述！
- en: Editing resources
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑资源
- en: 'As mentioned earlier in this section, imperative editing of Kubernetes resources
    is generally discouraged. `kubectl edit` is a combination of `kubectl get`, opening
    your favourite text editor, and `kubectl apply` of the modified manifest file,
    as illustrated in the following code block:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节前面提到的，通常不鼓励对 Kubernetes 资源进行命令式编辑。`kubectl edit` 是 `kubectl get`、打开您喜欢的文本编辑器和对修改后的清单文件进行
    `kubectl apply` 的组合，如下面的代码块所示：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: On a Windows machine, this command will open `notepad.exe` (or any other editor,
    if you specify the `EDITOR` or `KUBE_EDITOR` environment variables) with the current
    state of `nginx-deployment-example`. After editing, save the file, close the editor,
    and your changes will be applied.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 机器上，此命令将打开 `notepad.exe`（或任何其他编辑器，如果您指定了 `EDITOR` 或 `KUBE_EDITOR`
    环境变量），显示 `nginx-deployment-example` 的当前状态。编辑后，保存文件，关闭编辑器，您的更改将被应用。
- en: 'Another approach is using patches, which can be used in declarative management.
    `kubectl patch` updates a resource by merging the current resource state and a
    patch that contains only the modified properties. A common use case for patching
    is when you need to enforce a node selector for an existing DaemonSet in hybrid
    Linux/Windows clusters. The following JSON patch can be used for ensuring that
    a DaemonSet such as Flannel or kube-proxy is running only on Linux nodes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用补丁，可以在声明式管理中使用。`kubectl patch` 通过合并当前资源状态和仅包含修改属性的补丁来更新资源。修补的常见用例是在混合
    Linux/Windows 集群中需要强制执行现有 DaemonSet 的节点选择器时。以下 JSON 补丁可用于确保诸如 Flannel 或 kube-proxy
    的 DaemonSet 仅在 Linux 节点上运行：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It is possible to use YAML patches as well, but, unfortunately, due to PowerShell
    escaping rules, we cannot demonstrate this for the `beta.kubernetes.io/os` selector.
    JSON still requires additional preprocessing in PowerShell.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用 YAML 补丁，但不幸的是，由于 PowerShell 转义规则，我们无法为 `beta.kubernetes.io/os` 选择器演示这一点。在
    PowerShell 中，JSON 仍然需要额外的预处理。
- en: 'In order to apply this patch to an `nginx-deployment-example` Deployment, save
    the patch as a `linux-node-selector.json` file and run the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此补丁应用到 `nginx-deployment-example` 部署中，将补丁保存为 `linux-node-selector.json` 文件，并运行以下命令：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can find more about the patching of resources and merge types in the official
    documentation: [https://kubernetes.io/docs/tasks/run-application/update-api-object-kubectl-patch/](https://kubernetes.io/docs/tasks/run-application/update-api-object-kubectl-patch/).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中找到有关资源修补和合并类型的更多信息：[https://kubernetes.io/docs/tasks/run-application/update-api-object-kubectl-patch/](https://kubernetes.io/docs/tasks/run-application/update-api-object-kubectl-patch/)。
- en: Running an ad hoc Pod
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行临时 Pod
- en: 'In debugging scenarios, you may find it useful to run an ad hoc Pod and attach
    to it. You can perform this using the `kubectl run` command—note that this command
    can generate different resources, but all generators apart from the Pod are deprecated.
    The following snippet will create a `busybox-debug` Pod with one `busybox` container,
    and run an interactive Bourne shell session in the container:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试场景中，您可能会发现运行临时 Pod 并附加到它很有用。您可以使用 `kubectl run` 命令执行此操作——请注意，此命令可以生成不同的资源，但除了
    Pod 之外，所有生成器都已被弃用。以下代码段将创建一个带有一个 `busybox` 容器的 `busybox-debug` Pod，并在容器中运行一个交互式
    Bourne shell 会话：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When the shell prompt appears, you can perform actions from inside of the cluster—for
    example, pinging internal IPs. When you exit the shell, the container will be
    automatically removed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当 shell 提示符出现时，您可以在集群内执行操作，例如对内部 IP 进行 ping。退出 shell 后，容器将被自动删除。
- en: You can use a similar approach to create an interactive PowerShell Pod for Windows
    nodes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类似的方法为 Windows 节点创建交互式 PowerShell Pod。
- en: Accessing Pod container logs
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问 Pod 容器日志
- en: 'Container logs provide crucial information when debugging applications running
    on Kubernetes. You can access Pod container logs using the `kubectl logs` command,
    similar to how you would for the Docker CLI, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试在Kubernetes上运行的应用程序时，容器日志提供了关键信息。您可以使用`kubectl logs`命令访问Pod容器日志，类似于您为Docker
    CLI所做的操作，如下所示：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will work if the Pod is running only one container. If the Pod consists
    of more than one container, you need to use the `--container` or the `--all-containers`
    flag.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Pod只运行一个容器，这将起作用。如果Pod由多个容器组成，您需要使用`--container`或`--all-containers`标志。
- en: 'Additionally, you may want to tail `n` last lines of logs (`--tail=n` flag)
    and enable live streaming of logs (`--follow` flag), as illustrated in the following
    code snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可能希望尾随日志的`n`行（`--tail=n`标志）并启用日志的实时流（`--follow`标志），如下面的代码片段所示：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Execcing into a Pod container
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入Pod容器
- en: 'When debugging applications running on Kubernetes, you can `exec` into containers
    running in Pods, just as for bare Docker containers. For example, to list all
    files in the current working directory of the container, use the following `kubectl
    exec` command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试在Kubernetes上运行的应用程序时，您可以像裸Docker容器一样`exec`到运行在Pod中的容器。例如，要列出容器当前工作目录中的所有文件，请使用以下`kubectl
    exec`命令：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It is possible to attach an interactive Terminal and run a Bash session too,
    as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以附加交互式终端并运行Bash会话，如下所示：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For multi-container Pods, you have to use the `--container` flag, or the first
    container in the Pod will be chosen.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多容器Pod，您必须使用`--container`标志，否则将选择Pod中的第一个容器。
- en: Copying Pod container files
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制Pod容器文件
- en: 'Kubectl gives you the possibility to copy files between your machine and Pod
    containers (in both ways), analogously to the Docker CLI. For example, to copy
    the `/var/log/dpkg.log` file from a container running in the `nginx-deployment-example-5997d7d5fb-p9fbn` Pod
    to your current directory, execute the `kubectl cp` command, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl为您提供了在您的计算机和Pod容器之间复制文件的可能性（双向），类似于Docker CLI。例如，要将`/var/log/dpkg.log`文件从运行在`nginx-deployment-example-5997d7d5fb-p9fbn`
    Pod中的容器复制到当前目录，请执行以下`kubectl cp`命令：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In general, if you use a Pod container as a source or destination, you need
    to specify the Pod name and container filesystem path, separated by a colon (`:`).
    As for other commands, if the Pod is running multiple containers, you need to
    use the `--container` flag or the first container will be chosen.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果您将Pod容器用作源或目的地，您需要指定Pod名称和容器文件系统路径，用冒号（`:`）分隔。对于其他命令，如果Pod运行多个容器，您需要使用`--container`标志，否则将选择第一个容器。
- en: Port forwarding and proxying traffic
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端口转发和代理流量
- en: 'Kubectl can act as a simple proxy for accessing your Kubernetes cluster. Use
    port forwarding to Pods if you need to directly communicate from your local machine
    to a given port on the Pod. This is achieved without manually exposing Service
    Objects by using the `kubectl port-forward` command. The command can be used for
    forwarding to an automatically selected Pod based on other Objects selectors—for
    example, Deployment, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl可以充当访问您的Kubernetes集群的简单代理。如果需要直接从本地计算机通信到Pod上的特定端口，可以使用端口转发到Pod。这可以通过使用`kubectl
    port-forward`命令来实现，而无需手动暴露服务对象。该命令可用于将流量转发到基于其他对象选择器自动选择的Pod，例如Deployment，如下所示：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This command will forward all traffic from your local machine port `7000` to
    port `80` for one Pod in an `nginx-deployment-example` Deployment. Navigate to
    `http://localhost:7000` to verify that the default nginx page is accessible. Terminate
    the port-forwarding command when you are done.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将所有流量从本地计算机端口`7000`转发到`nginx-deployment-example` Deployment中一个Pod的端口`80`。转到`http://localhost:7000`以验证默认的nginx页面是否可访问。完成后终止端口转发命令。
- en: 'Additionally, kubectl can provide access to the Kubernetes API server for your
    local machine. Use the `kubectl proxy` command to expose the API at port `8080`,
    as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，kubectl可以为您的本地机器提供访问Kubernetes API服务器的权限。使用`kubectl proxy`命令将API暴露在端口`8080`上，如下所示：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, when you navigate to `http://localhost:8080/api/v1/namespaces/default/pods`
    in your browser, you will see the Pod Objects that are currently running in the
    cluster. Congratulations—you have successfully set up kubectl port forwarding!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您在浏览器中导航到`http://localhost:8080/api/v1/namespaces/default/pods`时，您将看到当前在集群中运行的Pod对象。恭喜您成功设置了kubectl端口转发！
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you have learned how to install and use the Kubernetes command-line
    tool, kubectl. We have covered how to organize accessing multiple Kubernetes clusters
    using kubectl contexts, what are the possible strategies for working with development
    clusters, and how they fit Windows clusters. On top of that, you now know the
    basic kubectl commands and a few techniques that can be used for debugging applications
    running on Kubernetes: running ad hoc Pods, accessing Pod container logs, performing
    exec into a Pod container, and copying files between your local machine and the
    Pod container.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了如何安装和使用Kubernetes命令行工具kubectl。我们已经介绍了如何使用kubectl上下文来组织访问多个Kubernetes集群，以及处理开发集群的可能策略以及它们如何适用于Windows集群。除此之外，您现在还了解了基本的kubectl命令以及一些用于调试在Kubernetes上运行的应用程序的技术：运行临时Pod、访问Pod容器日志、执行Pod容器内部的exec操作，以及在本地机器和Pod容器之间复制文件的几种技巧。
- en: The next chapter will focus on the deployment of hybrid Linux/Windows Kubernetes
    clusters in on-premises scenarios. We will demonstrate how to create a fully functional,
    multi-node cluster on your local machine using Hyper-V VMs.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点介绍在本地场景中部署混合Linux/Windows Kubernetes集群。我们将演示如何使用Hyper-V VM在本地机器上创建一个完全功能的多节点集群。
- en: Questions
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is `kubeconfig`?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubeconfig`是什么？'
- en: How would you set up a custom `kubeconfig` location for kubectl?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何为kubectl设置自定义的`kubeconfig`位置？
- en: What is the role of context in kubectl?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: kubectl中上下文的作用是什么？
- en: What is the difference between `kubectl create` and `kubectl apply` commands?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl create`和`kubectl apply`命令有什么区别？'
- en: What is a kubectl resource patch, and when would you use it?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是kubectl资源补丁，以及何时使用它？
- en: What is the command to show live logs from a Pod container?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Pod容器中显示实时日志的命令是什么？
- en: How would you copy a file between your local machine and a Pod container using
    kubectl?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何使用kubectl在本地机器和Pod容器之间复制文件？
- en: You can find answers to these questions in *Assessments* of this book.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的*评估*部分找到这些问题的答案。
- en: Further reading
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information regarding Kubernetes concepts and the Kubernetes CLI,
    please refer to the following Packt books:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Kubernetes概念和Kubernetes CLI的更多信息，请参阅以下Packt图书：
- en: '*The Complete Kubernetes Guide* ([https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide))'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完整的Kubernetes指南* ([https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide))'
- en: '*Getting Started with Kubernetes – Third Edition* ([https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition))'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始学习Kubernetes-第三版* ([https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition))'
- en: '*Kubernetes for Developers* ([https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers))'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向开发人员的Kubernetes* ([https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers))'
- en: You can also refer to the excellent official Kubernetes documentation ([https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/))
    and the kubectl reference documentation ([https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands)).
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以参考优秀的官方Kubernetes文档（[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)）和kubectl参考文档（[https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands)）。
