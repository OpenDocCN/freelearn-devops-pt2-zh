- en: Deploying Microsoft SQL Server 2019 and a ASP.NET MVC Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署Microsoft SQL Server 2019和ASP.NET MVC应用程序
- en: The previous chapters have given you a Swiss Army knife for deploying and operating
    hybrid Windows/Linux Kubernetes clusters—now, you have all the essential knowledge
    to deploy a real Windows container application to a Kubernetes cluster. This chapter
    will focus on demonstrating how you can approach containerizing and deploying
    a simple voting application written in C# .NET Framework 4.8 and ASP.NET MVC 5,
    with Microsoft SQL Server 2019 used for the persistence layer. The choice of the
    technology stack may seem a legacy one (why not use .NET Core?!) but it is intentional—if
    you are considering using Windows containers in Kubernetes, there is a good chance
    that you need the classic.NET Framework runtime as you are not ready to migrate
    to .NET Core.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的章节为您提供了一个部署和操作混合Windows/Linux Kubernetes集群的瑞士军刀，现在，您已经掌握了部署真实Windows容器应用程序到Kubernetes集群的所有基本知识。本章将重点演示如何处理使用C#
    .NET Framework 4.8和ASP.NET MVC 5编写的简单投票应用程序的容器化和部署，其中Microsoft SQL Server 2019用于持久层。技术栈的选择可能看起来是传统的（为什么不使用.NET
    Core？！），但这是有意为之——如果您正在考虑在Kubernetes中使用Windows容器，那么您很可能需要经典的.NET Framework运行时，因为您还没有准备好迁移到.NET
    Core。
- en: 'The topic of migrating existing applications to Kubernetes is broad and will
    not be fully covered in this book. There are numerous documented best practices
    for this process, but we will focus on a basic approach, mainly to demonstrate
    the Deployment instead of focusing on .NET Framework application implementation
    and migration. The goal of this chapter is to show the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移现有应用程序到Kubernetes的主题是广泛的，本书不会对其进行全面覆盖。有许多关于这一过程的最佳实践文档，但我们将专注于基本方法，主要是为了演示部署而不是专注于.NET
    Framework应用程序的实现和迁移。本章的目标是展示以下内容：
- en: How you can quickly containerize a Windows .NET Framework application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何快速将Windows .NET Framework应用程序容器化
- en: How to inject environment configuration such as SQL connection strings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何注入环境配置，如SQL连接字符串
- en: The recommended approach for container logs on Windows
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows容器日志的推荐方法
- en: How to debug the application remotely
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何远程调试应用程序
- en: 'More precisely, in this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，在本章中，我们将涵盖以下主题：
- en: Creating and publishing an ASP.NET MVC application to Docker Hub
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并发布ASP.NET MVC应用程序到Docker Hub
- en: Preparing the **Azure Kubernetes Service Engine** (**AKS Engine**)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备**Azure Kubernetes服务引擎**（**AKS引擎**）
- en: Deploying a failover Microsoft SQL Server 2019
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署故障转移Microsoft SQL Server 2019
- en: Deploying the ASP.NET MVC application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署ASP.NET MVC应用程序
- en: Accessing the application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问应用程序
- en: Scaling the application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展应用程序
- en: Debugging the application
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试应用程序
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您将需要以下内容：
- en: Windows 10 Pro, Enterprise, or Education (version 1903 or later, 64-bit) installed.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Windows 10专业版、企业版或教育版（1903版或更高版本，64位）。
- en: Microsoft Visual Studio 2019 Community (or any other edition) if you want to
    edit the source code for the application and debug it. **Visual Studio Code**
    (**VS Code**) has limited support for the classic .NET Framework.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Visual Studio 2019社区版（或其他任何版本），如果您想编辑应用程序的源代码并对其进行调试。**Visual Studio
    Code**（**VS Code**）对经典.NET Framework的支持有限。
- en: An Azure account.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure账户。
- en: A Windows/Linux Kubernetes cluster deployed using AKS Engine.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AKS引擎部署的Windows/Linux Kubernetes集群。
- en: To follow along, you will need your own Azure account in order to create Azure
    resources for the Kubernetes cluster. If you haven't already created the account
    for the previous chapters, you can read more about how to obtain a limited free
    account for personal use here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟着做，您需要自己的Azure账户，以便为Kubernetes集群创建Azure资源。如果您之前还没有为前几章创建账户，您可以在这里了解如何获得用于个人使用的有限免费账户：[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)。
- en: Deploying a Kubernetes cluster using AKS Engine has been covered in [Chapter
    8](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml), *Deploying a Hybrid Azure Kubernetes
    Service Engine Cluster*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AKS Engine部署Kubernetes集群已在[第8章](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml)中进行了介绍，*部署混合Azure
    Kubernetes服务引擎集群*。
- en: You can download the latest code samples for this book chapter from the official
    GitHub repository, at [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter10).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从官方GitHub存储库下载本书章节的最新代码示例，网址为：[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter10)。
- en: Creating and publishing an ASP.NET MVC application to Docker Hub
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并发布一个ASP.NET MVC应用程序到Docker Hub
- en: In order to demonstrate the Deployment of a real Windows container application,
    we will create a Docker image for a voting application that is a small C# .NET
    Framework 4.8 web application for creating surveys. The application is implemented
    using the classic ASP.NET MVC 5 stack as it is the most suitable for demonstrating
    how to approach the containerization of a Windows application. Traditional .NET
    Framework applications, especially enterprise, heavily rely on Windows-only functionalities,
    such as **Windows Communication Foundation** (**WCF**). In many cases, you may
    be lucky to easily migrate to .NET Core and use Linux containers for hosting your
    application, but for some parts of the .NET Framework stack, it may never happen,
    even in .NET 5.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示部署一个真实的Windows容器应用程序，我们将为一个投票应用程序创建一个Docker镜像，这是一个用于创建调查的小型C# .NET Framework
    4.8 Web应用程序。该应用程序使用经典的ASP.NET MVC 5堆栈实现，因为它最适合演示如何处理Windows应用程序的容器化。传统的.NET Framework应用程序，特别是企业级应用程序，严重依赖于仅在Windows上可用的功能，比如**Windows
    Communication Foundation**（**WCF**）。在许多情况下，您可能很幸运地轻松迁移到.NET Core，并使用Linux容器来托管您的应用程序，但对于.NET
    Framework堆栈的某些部分，甚至在.NET 5中也可能永远不会发生。
- en: 'There are a few assumptions concerning our voting application, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的投票应用程序，有一些假设，如下：
- en: There is no dependency on Kubernetes or Windows containers in any way. The application
    is unaware of being hosted by a container orchestration system.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本文中没有任何对Kubernetes或Windows容器的依赖。该应用程序不知道自己是由容器编排系统托管的。
- en: '**Entity Framework 6.3** (**EF 6.3**) ([https://docs.microsoft.com/en-us/ef/ef6/](https://docs.microsoft.com/en-us/ef/ef6/))
    with the Code-First approach is used as **object-relational mapping** (**ORM**).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Entity Framework 6.3**（**EF 6.3**）([https://docs.microsoft.com/en-us/ef/ef6/](https://docs.microsoft.com/en-us/ef/ef6/))采用了基于代码的方式作为**对象关系映射**（**ORM**）。'
- en: Microsoft SQL Server is used for voting data storage—this is a common stack
    you see with ASP.NET MVC applications. For local development, we use **Microsoft
    SQL** (**MSSQL**) Server Express LocalDB ([https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb?view=sql-server-ver15](https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb?view=sql-server-ver15)),
    whereas, for the Kubernetes Deployment, we are going to use MSSQL Server 2019
    hosted in Linux containers ([https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15&pivots=cs1-bash](https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15&pivots=cs1-bash)).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft SQL Server 用于投票数据存储-这是您在ASP.NET MVC应用程序中看到的常见堆栈。对于本地开发，我们使用Microsoft
    SQL（MSSQL）Server Express LocalDB（[https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb?view=sql-server-ver15](https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb?view=sql-server-ver15)），而对于Kubernetes部署，我们将使用托管在Linux容器中的MSSQL
    Server 2019（[https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15&pivots=cs1-bash](https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15&pivots=cs1-bash)）。
- en: Serilog ([https://serilog.net/](https://serilog.net/)) has been chosen as the
    logging framework.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Serilog（[https://serilog.net/](https://serilog.net/)）已被选择为日志框架。
- en: Ninject ([https://github.com/ninject/Ninject](https://github.com/ninject/Ninject))
    ties everything together as a dependency injector.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ninject（[https://github.com/ninject/Ninject](https://github.com/ninject/Ninject)）将所有内容绑定为依赖注入器。
- en: We use simple fat controllers that contain all the business logic and the data
    access layer (so there are no repositories or other design patterns). This has
    been chosen specifically to make the application as compact as possible.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用简单的“肥”控制器，其中包含所有业务逻辑和数据访问层（因此没有存储库或其他设计模式）。这是特意选择的，以使应用程序尽可能紧凑。
- en: Most of the views and controllers are based on a standard MVC 5 scaffolding
    for the EF model.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数视图和控制器都基于标准的MVC 5脚手架，用于EF模型。
- en: Usage of view models is limited to places where it is absolutely necessary.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图模型的使用仅限于绝对必要的地方。
- en: You can find the application source code in the official GitHub repository for
    the book, at [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter10/01_voting-application-src](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter10/01_voting-application-src).
    To open the `VotingApplication.sln` solution file, you need Visual Studio 2019\.
    It is also possible to perform a build by just using the `docker build` command,
    as explained in the next subsections. At the end of this section, you will have
    a Docker image for a voting application, ready to be used in Kubernetes. You may
    follow along with the steps or choose to use a ready-made image from Docker Hub,
    available at [https://hub.docker.com/repository/docker/packtpubkubernetesonwindows/voting-application](https://hub.docker.com/repository/docker/packtpubkubernetesonwindows/voting-application).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在该书的官方GitHub存储库中找到应用程序源代码，网址为[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter10/01_voting-application-src](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter10/01_voting-application-src)。要打开`VotingApplication.sln`解决方案文件，您需要Visual
    Studio 2019。也可以通过使用`docker build`命令执行构建，如下一小节所述。在本节结束时，您将拥有一个用于投票应用程序的Docker镜像，准备在Kubernetes中使用。您可以按照步骤进行，或选择使用Docker
    Hub上提供的现成镜像，网址为[https://hub.docker.com/repository/docker/packtpubkubernetesonwindows/voting-application](https://hub.docker.com/repository/docker/packtpubkubernetesonwindows/voting-application)。
- en: Injecting the configuration using environment variables
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用环境变量注入配置
- en: 'When developing a container-friendly application, you need to consider how
    to inject configuration data such as database connection strings. A general rule
    of thumb is that you should not hardcode any addresses, usernames, passwords,
    or connection strings into your code. You should be always able to inject such
    configuration during runtime and, in general, this is also true for non-containerized
    applications. Kubernetes offers you a wide variety of approaches on how to inject
    the runtime configuration, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发容器友好的应用程序时，您需要考虑如何注入配置数据，例如数据库连接字符串。一个经验法则是，您不应该将任何地址、用户名、密码或连接字符串硬编码到您的代码中。您应该始终能够在运行时注入这样的配置，并且一般来说，非容器化应用程序也是如此。Kubernetes为您提供了多种方法来注入运行时配置，如下所示：
- en: Passing arguments to the container commands
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向容器命令传递参数
- en: Defining system environment variables for the container
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为容器定义系统环境变量
- en: Mounting ConfigMaps or Secrets as container volumes
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将ConfigMaps或Secrets挂载为容器卷
- en: Optionally wrapping everything up using PodPresets
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地使用PodPresets封装所有内容
- en: You can read more about all of them in the official documentation ([https://kubernetes.io/docs/tasks/inject-data-application/](https://kubernetes.io/docs/tasks/inject-data-application/)).
    The important takeaway is that all the features integrate with the containerized
    application using standard **operating system** (**OS)**-level primitives such
    as files or environment variables. This means that if you design your application
    well, you can use it without any changes inside or outside of Kubernetes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中了解更多关于它们的信息（[https://kubernetes.io/docs/tasks/inject-data-application/](https://kubernetes.io/docs/tasks/inject-data-application/)）。重要的是，所有这些特性都使用标准的操作系统级原语，如文件或环境变量，与容器化应用程序集成。这意味着，如果您设计得当，您可以在Kubernetes内外不做任何更改地使用它。
- en: We will demonstrate how to use environment variables to inject an MSSQL Server
    connection string to our application. This approach is the simplest one but it
    has a significant limitation—you cannot modify the container's environment variables
    when the container is running. Once you set the variable, it will have the same
    value throughout the whole container life cycle. If you need to be able to modify
    the configuration without restarting the container, you should take a look at
    ConfigMaps (combined with Secrets), which are described in the next chapter: [Chapter
    11](9ad8c38e-6d0d-435b-a46c-82a468f18007.xhtml), *Configuring Applications to
    Use Kubernetes Features*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示如何使用环境变量将MSSQL Server连接字符串注入到我们的应用程序中。这种方法是最简单的，但它有一个重要的限制——当容器正在运行时，您无法修改容器的环境变量。一旦设置了变量，它将在整个容器生命周期内保持相同的值。如果您需要能够在不重新启动容器的情况下修改配置，您应该看一下ConfigMaps（与Secrets结合使用），这在下一章节中描述：[第11章](9ad8c38e-6d0d-435b-a46c-82a468f18007.xhtml)，*配置应用程序以使用Kubernetes功能*。
- en: 'Our voting application uses the `VotingApplicationContextFactory` class for
    creating an EF DbContext for **Model-View-Controller** (**MVC**) controllers.
    Let''s take a look at the `Create()` method of this class (available at [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Factories/VotingApplicationContextFactory.cs](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Factories/VotingApplicationContextFactory.cs)),
    as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的投票应用程序使用`VotingApplicationContextFactory`类来为**Model-View-Controller**（MVC）控制器创建EF
    DbContext。让我们来看看这个类的`Create()`方法（可在[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Factories/VotingApplicationContextFactory.cs](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Factories/VotingApplicationContextFactory.cs)找到）。
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is a common pattern you can use to inject a configuration into
    your application, especially in the Linux world, where relying on environment
    variables is much more common:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以使用的一种常见模式，特别是在Linux世界中，那里更常依赖于环境变量：
- en: Check if your chosen environment variable, `CONNECTIONSTRING_VotingApplication`,
    is defined.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查您选择的环境变量`CONNECTIONSTRING_VotingApplication`是否已定义。
- en: If it is, create an EF DbContext using the overriddenconnection string from
    the variable.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，使用变量中的重写连接字符串创建EF DbContext。
- en: If not, create an EF DbContext using the standard connection string. In this
    case, it will be retrieved from the `Web.config` application file.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有，使用标准连接字符串创建EF DbContext。在这种情况下，它将从`Web.config`应用程序文件中检索。
- en: You can follow this pattern, especially when you are not using custom configuration
    files. This solution gives you a lot of flexibility and you can use it also when
    running an application without a container!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以遵循这种模式，特别是当您不使用自定义配置文件时。这种解决方案为您提供了很大的灵活性，您也可以在不使用容器运行应用程序时使用它！
- en: Another approach would be to inject the whole `Web.config` file as a Kubernetes
    ConfigMap object. We will explore this possibility in the next chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将整个`Web.config`文件作为Kubernetes ConfigMap对象注入。我们将在下一章中探讨这种可能性。
- en: This shows an important principle that you should use when containerizing any
    application—think about the external interfaces of your application (system) and
    how it communicates with the outside world. This is the only way you can influence
    or monitor an application running in a container. Providing and injecting configuration
    is one of the external interfaces for your application. Similarly, logging defines
    an output interface for your application—let's see how you can approach this in
    Windows containers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了一个重要的原则，即在容器化任何应用程序时应该考虑应用程序（系统）的外部接口以及它如何与外部世界通信。这是您可以影响或监视在容器中运行的应用程序的唯一方法。提供和注入配置是您的应用程序的外部接口之一。同样，日志记录为您的应用程序定义了一个输出接口，让我们看看您如何在Windows容器中处理这个问题。
- en: Configuring logging for Windows containers log monitor
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Windows容器配置日志记录日志监视器
- en: 'Kubernetes itself provides simple tools for browsing Pod container logs. Generally,
    you will have to implement a good cluster-level logging solution—for example,
    using the Elasticsearch, Logstash, Kibana stack or using Azure Log Analytics (as
    briefly demonstrated in the previous chapters). The official documentation gives
    a good overview of possible architectures for logging solutions: [https://kubernetes.io/docs/concepts/cluster-administration/logging/](https://kubernetes.io/docs/concepts/cluster-administration/logging/).
    In all cases, you will need to expose the application logs from your container
    to the outside world. From a high-level view, there are three main approaches:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes本身提供了简单的工具来浏览Pod容器日志。通常情况下，您将不得不实现一个良好的集群级日志记录解决方案，例如使用Elasticsearch、Logstash、Kibana堆栈或使用Azure
    Log Analytics（如前几章中简要演示的）。官方文档对日志记录解决方案的可能架构进行了很好的概述：[https://kubernetes.io/docs/concepts/cluster-administration/logging/](https://kubernetes.io/docs/concepts/cluster-administration/logging/)。在所有情况下，您都需要将容器中的应用程序日志暴露给外部世界。从高层次来看，有三种主要方法：
- en: Use a container **standard output** (**stdout**) and **standard error** (**stderr**)
    entry point and let the container runtime handle the logging. This can be later
    consumed using a node-level logging agent (for example, Fluentd, Elastic Beats,
    or Logstash) that forwards the logs to any external logging solution. This works
    especially well if your containerized applications write everything to the console
    output out of the box.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器的标准输出(stdout)和标准错误(stderr)入口点，并让容器运行时处理日志记录。稍后可以使用节点级别的日志代理（例如Fluentd、Elastic
    Beats或Logstash）来转发日志到任何外部日志解决方案。如果您的容器化应用程序默认将所有内容写入控制台输出，这种方法特别有效。
- en: Use an additional sidecar container in your application Pod that gathers the
    logs from the filesystem, event log, or other sources, and exposes it as stdout
    or directly to the external logging solution. This approach is useful if your
    application logs to multiple destinations inside the container.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的应用程序Pod中使用额外的辅助容器，该容器从文件系统、事件日志或其他来源收集日志，并将其公开为stdout或直接传输到外部日志解决方案。如果您的应用程序将日志记录到容器内的多个目的地，这种方法非常有用。
- en: Embed log streaming into the application itself. For example, in a C# application,
    you can use log4net and a dedicated Elasticsearch appender ([https://github.com/ptylenda/log4net.ElasticSearch.Async](https://github.com/ptylenda/log4net.ElasticSearch.Async))
    for streaming logs to your Elasticsearch cluster. This approach is the most limited—it
    creates a tight dependency on an external logging system and may cause an impact
    on performance that cannot be easily separated from the application workload itself.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将日志流嵌入到应用程序本身中。例如，在C#应用程序中，您可以使用log4net和专用的Elasticsearch appender ([https://github.com/ptylenda/log4net.ElasticSearch.Async](https://github.com/ptylenda/log4net.ElasticSearch.Async))
    来将日志流式传输到您的Elasticsearch集群。这种方法的限制最多——它会对外部日志系统产生严重依赖，并且可能会对性能产生影响，这种影响很难与应用程序本身的工作负载分离。
- en: For a Windows application, logging to stdout is not common, especially for older
    applications and when using **Internet Information Services** (**IIS**) for hosting
    your web applications. In most cases, using **Event Tracing for Windows** (**ETW**),
    event logs, or custom log files is more common for Windows. For example, our voting
    application is hosted using IIS. Also, when running in a containerized mode, IIS
    does not provide a functionality to expose the stdout of an application. You have
    to rely on event logs or your own log files. On top of that, IIS itself exposes
    additional application logs in a standard location—`c:\inetpub\logs`—and streams
    its own events to ETW.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows应用程序，将日志记录到stdout并不常见，特别是对于旧应用程序以及在使用Internet Information Services
    (IIS) 托管您的Web应用程序时。在大多数情况下，对于Windows来说，更常见的是使用Event Tracing for Windows (ETW)、事件日志或自定义日志文件。例如，我们的投票应用程序是使用IIS进行托管的。此外，在容器化模式下运行时，IIS不提供公开应用程序的stdout的功能。您必须依赖事件日志或自己的日志文件。除此之外，IIS本身会在标准位置`c:\inetpub\logs`中公开额外的应用程序日志，并将其自己的事件流传输到ETW。
- en: 'You can approach the gathering of logs for a voting application in two ways:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以两种方式处理投票应用程序的日志收集：
- en: Use an additional sidecar container that runs, for example, Elastic Beats or
    Winlogbeat ([https://www.elastic.co/products/beats/winlogbeat](https://www.elastic.co/products/beats/winlogbeat)),
    which gathers all the logs from the application container and exposes it to stdout
    ([https://www.elastic.co/guide/en/beats/filebeat/current/console-output.html](https://www.elastic.co/guide/en/beats/filebeat/current/console-output.html))
    or any other supported output. The logs need to be shared using a volume between
    the containers inside the Pod.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用额外的边车容器运行，例如，Elastic Beats或Winlogbeat（[https://www.elastic.co/products/beats/winlogbeat](https://www.elastic.co/products/beats/winlogbeat)），它收集应用程序容器的所有日志并将其暴露给stdout（[https://www.elastic.co/guide/en/beats/filebeat/current/console-output.html](https://www.elastic.co/guide/en/beats/filebeat/current/console-output.html)）或任何其他支持的输出。日志需要使用Pod内部容器之间的卷进行共享。
- en: 'Extend the container image with Windows containers log monitor, which has been
    recently released ([https://github.com/microsoft/windows-container-tools](https://github.com/microsoft/windows-container-tools)).
    More details regarding the architecture can be found here: [https://techcommunity.microsoft.com/t5/Containers/Windows-Containers-Log-Monitor-Opensource-Release/ba-p/973947](https://techcommunity.microsoft.com/t5/Containers/Windows-Containers-Log-Monitor-Opensource-Release/ba-p/973947)).
    This tool uses a different approach than a sidecar container. In the Docker image,
    instead of directly starting your application, you start `LogMonitor.exe` with
    an appropriate JSON configuration file and pass the command line for starting
    your application as an argument for `LogMonitor.exe`. In other words, `LogMonitor.exe`
    acts as a supervisor for your application process and prints logs to stdout that
    are gathered from different sources based on the configuration file. There are
    plans to further extend this solution to be used in the sidecar container pattern.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展容器镜像与最近发布的Windows容器日志监视器（[https://github.com/microsoft/windows-container-tools](https://github.com/microsoft/windows-container-tools)）。有关架构的更多详细信息可以在这里找到：[https://techcommunity.microsoft.com/t5/Containers/Windows-Containers-Log-Monitor-Opensource-Release/ba-p/973947](https://techcommunity.microsoft.com/t5/Containers/Windows-Containers-Log-Monitor-Opensource-Release/ba-p/973947)。该工具使用的方法与边车容器不同。在Docker镜像中，您不是直接启动应用程序，而是使用适当的JSON配置文件启动`LogMonitor.exe`，并将启动应用程序的命令行作为`LogMonitor.exe`的参数。换句话说，`LogMonitor.exe`充当应用程序进程的监督者，并将根据配置文件从不同来源收集的日志打印到stdout。计划进一步扩展此解决方案以用于边车容器模式。
- en: 'We are going to use log monitor as it is simple to integrate and easy to configure.
    The details of the Dockerfile for the application will be shown in the next subsection.
    Assuming that the command for starting your application (IIS, in this case) is
    `C:\ServiceMonitor.exe w3svc`, the general pattern for using Log Monitor is customizing
    the Dockerfile in the following way:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用日志监视器，因为它易于集成和配置。应用程序的Dockerfile的详细信息将在下一小节中显示。假设启动应用程序（在本例中为IIS）的命令是`C:\ServiceMonitor.exe
    w3svc`，使用Log Monitor的一般模式是以以下方式自定义Dockerfile：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `LogMonitoringConfig.json` file ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/LogMonitorConfig.json](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/LogMonitorConfig.json))
    for our application has the following JSON configuration:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的`LogMonitoringConfig.json`文件（[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/LogMonitorConfig.json](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/LogMonitorConfig.json)）具有以下JSON配置：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This configuration file subscribes log monitor to the `system` log and the `VotingApplication`
    log in the Windows event log, monitors logs in `C:\inetpub\logs`, and collects
    ETW data for IIS. The `VotingApplication` log in the event log contains all the
    logs produced by Serilog in our application. This is configured in the `NinjectWebCommon`
    class ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/App_Start/NinjectWebCommon.cs](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/App_Start/NinjectWebCommon.cs)),
    where we initialize the logger sinks, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置文件订阅日志监视器到`系统`日志和Windows事件日志中的`VotingApplication`日志，监视`C:\inetpub\logs`中的日志，并收集IIS的ETW数据。事件日志中的`VotingApplication`日志包含我们应用程序中由Serilog生成的所有日志。这在`NinjectWebCommon`类中配置（[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/App_Start/NinjectWebCommon.cs](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/App_Start/NinjectWebCommon.cs)），在那里我们初始化了日志记录器的输出，如下所示：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that due to the fact that Windows containers are not running in privileged
    mode, we cannot automatically create the log in an event log (`manageEventSource:
    false`). This has to be done in the Dockerfile at build time.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，由于Windows容器不在特权模式下运行，我们无法自动在事件日志中创建日志（`manageEventSource: false`）。这必须在构建时在Dockerfile中完成。'
- en: With this setup, our voting application will print all our own logs, together
    with the system and IIS, to stdout of the container. This means you can easily
    investigate them using the `docker logs` command (when running a standalone container)
    or the `kubectl logs` command. If you integrate with Azure Log Analytics, your
    logs will be available for querying using Kusto.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个设置，我们的投票应用程序将把我们自己的所有日志，以及系统和IIS的日志一起打印到容器的stdout中。这意味着您可以使用`docker logs`命令（在运行独立容器时）或`kubectl
    logs`命令轻松地对它们进行调查。如果与Azure Log Analytics集成，您的日志将可以使用Kusto进行查询。
- en: Creating a Dockerfile
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Dockerfile
- en: 'The next step is preparing a Dockerfile for our application. You can check
    the official documentation on how to approach building .NET Framework applications
    in a Dockerfile at [https://github.com/microsoft/dotnet-framework-docker/tree/master/samples/dotnetapp](https://github.com/microsoft/dotnet-framework-docker/tree/master/samples/dotnetapp).
    Our Dockerfile has to cover the following steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为我们的应用程序准备一个Dockerfile。您可以查看官方文档，了解如何在Dockerfile中构建.NET Framework应用程序的方法，网址为[https://github.com/microsoft/dotnet-framework-docker/tree/master/samples/dotnetapp](https://github.com/microsoft/dotnet-framework-docker/tree/master/samples/dotnetapp)。我们的Dockerfile必须包括以下步骤：
- en: Restore NuGet packages.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复NuGet软件包。
- en: Build the application, preferably using a publish profile to the local filesystem.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建应用程序，最好使用发布配置文件到本地文件系统。
- en: Copy tools for applying EF migrations (provided by the EF NuGet package).
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制用于应用EF迁移的工具（由EF NuGet软件包提供）。
- en: Create a `VotingApplication` log in the event log.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件日志中创建`VotingApplication`日志。
- en: Copy log monitor binaries and configuration.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制日志监视器二进制文件和配置。
- en: Copy voting application binaries to `C:\inetpub\wwwroot` for IIS hosting.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将投票应用程序二进制文件复制到`C:\inetpub\wwwroot`以进行IIS托管。
- en: 'We need to dwell on the topic of EF migrations a bit more. Applying EF database
    migrations without application downtime and when having multiple replicas of the
    application is a complex task. You need to ensure that the migrations can be rolled
    back and that the database schema is fully compatible with the old and the new
    application versions. In other words, backward-incompatible changes such as renames
    have to be handled specially to make them backward-compatible between the individual
    steps. A skeleton for this process could look as follows—for example, for renaming
    a column for an entity:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更深入地讨论EF迁移的话题。在没有应用程序停机时间并且应用程序有多个副本的情况下应用EF数据库迁移是一个复杂的任务。您需要确保迁移可以回滚，并且数据库架构与旧版本和新版本的应用程序完全兼容。换句话说，不兼容的更改，比如重命名，必须特别处理，以使它们在各个步骤之间具有向后兼容性。这个过程的框架可能如下所示
    - 例如，对于实体的列重命名：
- en: Apply database migration that adds a new column with the new name.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用添加具有新名称的新列的数据库迁移。
- en: Roll out a new version of your application that performs writes to both the
    old and the new column. Reads should be performed using the old column because
    it always has the proper data.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推出一个新版本的应用程序，对旧列和新列进行写入。读取应该使用旧列进行，因为它始终具有正确的数据。
- en: Execute a job that copies data from the old column to the new column.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个从旧列复制数据到新列的作业。
- en: Roll out a new version of your application that reads from the new column.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推出一个新版本的应用程序，从新列中读取。
- en: Roll out a new version of your application that writes to the new column only.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推出一个新版本的应用程序，只写入新列。
- en: Apply database migration, which removes the old column.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用数据库迁移，删除旧列。
- en: As you can see, properly handling database migrations for applications running
    in Kubernetes with no downtime requires strict rules and compatibility/rollback
    testing—we have brought this topic to your attention, but detailed solutions are
    out of the scope of this book. There is a good article by Spring that explains
    the details of how to approach this problem ([https://spring.io/blog/2016/05/31/zero-downtime-deployment-with-a-database](https://spring.io/blog/2016/05/31/zero-downtime-deployment-with-a-database))
    and another article by Weaveworks dedicated for Kubernetes: [https://www.weave.works/blog/how-to-correctly-handle-db-schemas-during-kubernetes-rollouts](https://www.weave.works/blog/how-to-correctly-handle-db-schemas-during-kubernetes-rollouts).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，为在Kubernetes中运行的应用程序正确处理数据库迁移而不中断需要严格的规则和兼容性/回滚测试 - 我们已经将这个话题带到您的注意中，但详细的解决方案不在本书的范围之内。Spring有一篇很好的文章解释了如何解决这个问题（[https://spring.io/blog/2016/05/31/zero-downtime-deployment-with-a-database](https://spring.io/blog/2016/05/31/zero-downtime-deployment-with-a-database)），Weaveworks也有一篇专门针对Kubernetes的文章：[https://www.weave.works/blog/how-to-correctly-handle-db-schemas-during-kubernetes-rollouts](https://www.weave.works/blog/how-to-correctly-handle-db-schemas-during-kubernetes-rollouts)。
- en: For applying migrations, we will use the same Docker image—EF database migrations
    are applied using application assembly and EF command-line tools, which we will
    provide in the image. Then, the migrations (and database seeding) will be run
    using a Kubernetes Job that is suitable for running one-time tasks. In a real-world
    scenario, this should be scheduled as part of your **Continuous Integration/Continuous
    Deployment** (**CI/CD)** process, accompanying the Kubernetes Deployment rollout.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用迁移，我们将使用相同的Docker镜像 - EF数据库迁移是使用应用程序程序集和EF命令行工具应用的，我们将在镜像中提供。然后，迁移（和数据库种子）将使用适合运行一次性任务的Kubernetes作业来运行。在实际情况下，这应该被安排为您的**持续集成/持续部署**（**CI/CD**）过程的一部分，伴随着Kubernetes部署的推出。
- en: 'The voting application contains a Dockerfile named `Dockerfile.production`
    ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Dockerfile.production](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Dockerfile.production))
    that has layers based on what we have just summarized. Let''s analyze it, step
    by step:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 投票应用程序包含一个名为`Dockerfile.production`的Dockerfile（[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Dockerfile.production](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Dockerfile.production)），它的层基于我们刚刚总结的内容。让我们逐步分析它：
- en: 'The Dockerfile defines a multi-stage build, which means that multiple base
    images are used throughout the build process. The first stage is the web application
    build, using a `mcr.microsoft.com/dotnet/framework/sdk` image. This image contains
    all the .NET Framework build tools that are not required for the runtime. The
    code for this is illustrated in the following block:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dockerfile定义了一个多阶段构建，这意味着在整个构建过程中使用了多个基础镜像。第一阶段是Web应用程序构建，使用了一个`mcr.microsoft.com/dotnet/framework/sdk`镜像。这个镜像包含了所有不需要运行时的.NET
    Framework构建工具。其代码如下所示：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The layers are organized in such a way that layer caching during builds is maximized—for
    example, we run `nuget restore` only if certain solution configuration files change.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些层的组织方式使得在构建过程中最大化了层缓存的利用——例如，只有在特定解决方案配置文件更改时才运行`nuget restore`。
- en: 'The build process is performed by a standard `msbuild` command, using a dedicated `DockerPublishProfile.pubxml` publish
    profile that has the following form:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建过程由标准的`msbuild`命令执行，使用了一个名为`DockerPublishProfile.pubxml`的专用发布配置文件，其形式如下：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In principle, it performs a `FileSystem` publish to `obj\Docker\publish`, which
    is later used for creating the final image.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，它执行`FileSystem`发布到`obj\Docker\publish`，这稍后将用于创建最终镜像。
- en: 'Next, we start the second and final build stage based on the `mcr.microsoft.com/dotnet/framework/aspnet`
    image dedicated for runtime scenarios, as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们基于专门用于运行时场景的`mcr.microsoft.com/dotnet/framework/aspnet`镜像开始第二个和最后一个构建阶段，如下所示：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the first step, we perform the copying of EF6 migration command-line tools,
    which are provided with the EF NuGet package. Here, the key is to copy from the
    previous stage, using the `--from=build` argument.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们执行EF6迁移命令行工具的复制，这些工具是通过EF NuGet包提供的。关键在于使用`--from=build`参数从上一个阶段复制。
- en: 'The next step is creating a dedicated log in an event log for our voting application
    (this requirement was mentioned in the previous subsection), as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是为我们的投票应用程序创建一个专用的事件日志（这个要求在前面的小节中提到过），如下所示：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Copy the `LogMonitor` binary and configuration, also overriding the shell command
    for the container, as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`LogMonitor`二进制文件和配置，同时覆盖容器的shell命令，如下所示：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Copy the `build` artifacts from the previous stage to the `C:\inetpub\wwwroot` IIS
    application directory, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前一个阶段的`build`工件复制到`C:\inetpub\wwwroot`的IIS应用程序目录中，如下所示：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And finally, define the default entry point for the image to the `ServiceMonitor.exe`
    starting the IIS service. This is a standard approach that you see in the `mcr.microsoft.com/dotnet/framework/aspnet` base
    image. The only difference is that the whole process tree will run under log monitor
    supervision. The code can be seen in the following snippet:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将镜像的默认入口点定义为启动IIS服务的`ServiceMonitor.exe`。这是一个标准的方法，在`mcr.microsoft.com/dotnet/framework/aspnet`基础镜像中可以看到。唯一的区别是整个进程树将在日志监视器的监督下运行。其代码如下所示：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That's it! The Dockerfile defines the full build process for the ASP.NET MVC
    application—you could optionally extend it with a testing stage whereby you execute
    appropriate tests. Now, let's build the image and push it to the image registry.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！Dockerfile定义了ASP.NET MVC应用程序的完整构建过程——您可以选择性地扩展它，添加一个测试阶段，执行适当的测试。现在，让我们构建镜像并将其推送到镜像注册表。
- en: Building and pushing the Docker image
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和推送Docker镜像
- en: 'The exact details of this process have been covered in [Chapter 3](e00b7610-2513-4513-863f-62a054d8cd98.xhtml), *Working
    with Container Images*. In short, you can use two approaches here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的确切细节已在[第3章](e00b7610-2513-4513-863f-62a054d8cd98.xhtml)中进行了介绍，*使用容器镜像*。简而言之，您可以在这里使用两种方法：
- en: Performing a manual build of the image on your local machine and pushing it
    to the public Docker Hub. Currently, setting an autobuild for a Windows container
    image is not possible on Docker Hub.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地机器上执行镜像的手动构建并将其推送到公共Docker Hub。目前，在Docker Hub上无法为Windows容器镜像设置自动构建。
- en: If you are interested in having automated builds and GitHub hooks integrated
    into your application, you can use **Azure Container Registry** (**ACR**), as
    described in the chapter mentioned previously.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您有兴趣将自动构建和GitHub挂钩集成到您的应用程序中，您可以使用**Azure容器注册表**（**ACR**），如前面提到的章节中所述。
- en: 'For the sake of simplicity, we will perform a manual build and push the image
    to Docker Hub. In a real-world scenario, you should use at least ACR with GitHub
    integration as part of your CI/CD pipeline. Let''s perform the build of the Docker
    image—in the examples, we will use the `packtpubkubernetesonwindows/voting-application`
    image repository name, but if you are following along, you should use your own `<dockerId>/voting-application`
    repository. Perform the following steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将执行手动构建并将镜像推送到Docker Hub。在实际情况下，您应该至少在CI/CD流水线中使用带有GitHub集成的ACR。让我们执行Docker镜像的构建——在示例中，我们将使用`packtpubkubernetesonwindows/voting-application`镜像仓库名称，但如果您在跟随操作，应该使用您自己的`<dockerId>/voting-application`仓库。执行以下步骤：
- en: Open the PowerShell window and navigate to the main `voting-application` source
    directory.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开PowerShell窗口，导航到主`voting-application`源目录。
- en: 'Execute the Docker build using the following command (remember the final dot,
    which specifies the build context directory):'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令执行Docker构建（记住最后的句点，它指定了构建上下文目录）：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Wait for the build to finish, and tag the image accordingly. This is crucial
    for Kubernetes Deployments as we can specify a particular version of the image
    to be rolled out (using the latest version would be ambiguous and is generally
    not recommended). Using semantic versioning, as described in [Chapter 3](e00b7610-2513-4513-863f-62a054d8cd98.xhtml), *Working
    with Container Images*, is advised, and this is illustrated in the following code
    block:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待构建完成，并相应地标记镜像。这对于Kubernetes部署至关重要，因为我们可以指定要推出的镜像的特定版本（使用最新版本会产生歧义，通常不建议使用）。建议使用语义版本控制，如[第3章](e00b7610-2513-4513-863f-62a054d8cd98.xhtml)中所述的*使用容器镜像*，并且在以下代码块中进行了说明：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Push all the tags to the image repository, like this:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有标记推送到镜像仓库，如下所示：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, you can verify if the tags are properly visible in the Docker Hub page—for
    example, [https://hub.docker.com/repository/docker/packtpubkubernetesonwindows/voting-application/tags?page=1](https://hub.docker.com/repository/docker/packtpubkubernetesonwindows/voting-application/tags?page=1).
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以验证Docker Hub页面上的标记是否正确可见，例如，[https://hub.docker.com/repository/docker/packtpubkubernetesonwindows/voting-application/tags?page=1](https://hub.docker.com/repository/docker/packtpubkubernetesonwindows/voting-application/tags?page=1)。
- en: At this point, our Docker image can be used both locally (you need to provide
    a valid connection string to SQL Server using an environment variable) and in
    Kubernetes. Let's begin the preparation of AKS Engine cluster Deployment!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的Docker镜像可以在本地使用（您需要使用环境变量提供有效的连接字符串到SQL Server），也可以在Kubernetes中使用。让我们开始准备AKS
    Engine集群部署！
- en: Preparing the AKS Engine
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备AKS Engine
- en: If you have followed [Chapter 8](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml), *Deploying
    a Hybrid Azure Kubernetes Service Engine Cluster, *and you have created a hybrid
    Windows/Linux Kubernetes cluster using AKS Engine, you are ready to go—you can
    verify in this section if the topology of the cluster is as required. And, if
    you do not have an AKS Engine cluster deployed yet, we will provide a quick way
    to deploy it using a PowerShell script provided in the GitHub repository for the
    book.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经按照[第8章](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml) *部署混合Azure Kubernetes服务引擎集群*创建了一个混合Windows/Linux
    Kubernetes集群，并且已经准备就绪，您可以在本节中验证集群的拓扑是否符合要求。如果您还没有部署AKS Engine集群，我们将在书籍的GitHub存储库中提供一个快速部署的PowerShell脚本。
- en: 'Our voting application can be hosted on the smallest possible hybrid Windows/Linux
    cluster, one Linux master and one Windows node, where the Linux master acts as
    a regular node. However, to fully demonstrate the principles of Deployment, we
    will use a cluster that resembles a production one: one Linux master running in
    **Virtual Machine Scale Sets** (**VMSS**)** High Availability** (**HA**) mode,
    two Linux nodes, and two Windows nodes. We have used this configuration in the
    previous chapter for AKS Engine cluster Deployments. In order to quickly deploy
    an AKS Engine cluster from scratch, you can perform the following steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的投票应用程序可以托管在尽可能小的混合Windows/Linux集群上，一个Linux主节点和一个Windows节点，其中Linux主节点充当常规节点。然而，为了充分演示部署的原则，我们将使用一个类似于生产环境的集群：一个运行在**虚拟机规模集**（**VMSS**）**高可用性**（**HA**）模式下的Linux主节点，两个Linux节点和两个Windows节点。我们在上一章中已经使用了这种配置来部署AKS
    Engine集群。为了快速从头部署AKS Engine集群，您可以执行以下步骤：
- en: Download the following PowerShell script from the book's GitHub repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter08/01_aks-engine/01_CreateAKSEngineClusterWithWindowsNo](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter08/01_aks-engine/01_CreateAKSEngineClusterWithWindowsNodes.ps1)[des.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter08/01_aks-engine/01_CreateAKSEngineClusterWithWindowsNodes.ps1).
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从书籍的GitHub存储库下载以下PowerShell脚本：[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter08/01_aks-engine/01_CreateAKSEngineClusterWithWindowsNodes.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter08/01_aks-engine/01_CreateAKSEngineClusterWithWindowsNodes.ps1)。
- en: 'In the PowerShell window, execute the script with the appropriate parameters,
    as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PowerShell窗口中，使用适当的参数执行脚本，如下所示：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This script deploys the cluster to the West Europe location in Azure using the `aks-engine-windows-resource-group`
    resource group. If there are problems with the AKS Engine Deployment, you can
    always try specifying a different region—for example, `-azureLocation westus`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该脚本将在Azure中使用`aks-engine-windows-resource-group`资源组将集群部署到West Europe位置。如果AKS
    Engine部署出现问题，您可以尝试指定不同的区域，例如`-azureLocation westus`。
- en: 'When the Deployment finishes, you need to ensure that your default kubeconfig
    contains the context for the new cluster. You can quickly merge your kubeconfig
    with one that is generated for the West Europe location by AKS Engine by using
    the following commands (remember to double-check the contents of the `config_new`
    file before overwriting your default config file to avoid any loss):'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当部署完成后，您需要确保您的默认kubeconfig包含新集群的上下文。您可以通过使用以下命令快速合并由AKS Engine为West Europe位置生成的kubeconfig与默认kubeconfig（在覆盖默认配置文件之前，请记得仔细检查`config_new`文件的内容，以避免任何丢失）：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In a new PowerShell window, verify that you are able to access the cluster—for
    example—by running the following command:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的PowerShell窗口中，通过运行以下命令来验证您是否能够访问集群，例如：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Running an AKS Engine cluster of this size can be costly, so you should always
    check the estimated cost for **virtual machine** (**VM**) hosting. If you do not
    need the cluster anymore, you can simply delete it using the `az group delete
    --name aks-engine-windows-resource-group --yes` command, optionally providing
    a `--no-wait` parameter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这种规模的AKS Engine集群可能成本高昂，因此您应该始终检查**虚拟机**（**VM**）托管的预估成本。如果您不再需要该集群，可以使用`az
    group delete --name aks-engine-windows-resource-group --yes`命令来简单地删除它，也可以选择提供`--no-wait`参数。
- en: At this point, you have a cluster ready for running Microsoft SQL Server 2019
    and the voting application, so let's proceed!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您已经准备好运行Microsoft SQL Server 2019和投票应用程序的集群，所以让我们继续！
- en: Deploying a failover Microsoft SQL Server 2019
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署故障转移Microsoft SQL Server 2019
- en: 'From MSSQL Server 2017, it is possible to host it in a Linux Docker container.
    As our application requires MSSQL Server for data persistence, we are going to
    deploy the latest version—MSSQL Server 2019—to our Kubernetes cluster. Currently,
    it is possible to deploy MSSQL Server to Kubernetes in two modes, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从MSSQL Server 2017开始，可以将其托管在Linux Docker容器中。由于我们的应用程序需要MSSQL Server进行数据持久化，因此我们将部署最新版本的MSSQL
    Server 2019到我们的Kubernetes集群中。目前，可以以以下两种模式将MSSQL Server部署到Kubernetes中：
- en: A single-node instance with failover guaranteed by a Kubernetes Deployment and
    an Azure Disk persistent volume.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个单节点实例，故障转移由Kubernetes部署和Azure磁盘持久卷保证。
- en: A multi-node, HA cluster using a dedicated Kubernetes operator ([https://kubernetes.io/docs/concepts/extend-kubernetes/operator/](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/)).
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用专用的Kubernetes操作员（[https://kubernetes.io/docs/concepts/extend-kubernetes/operator/](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/)）的多节点HA集群。
- en: The second mode was announced for preview as of **Community Technology Preview**
    (**CTP**) 2.0 version ([https://cloudblogs.microsoft.com/sqlserver/2018/12/10/availability-groups-on-kubernetes-in-sql-server-2019-preview/](https://cloudblogs.microsoft.com/sqlserver/2018/12/10/availability-groups-on-kubernetes-in-sql-server-2019-preview/))
    but currently, in the **general availability** (**GA**) version, the Docker images
    and Kubernetes manifests are not compatible. If you are interested, you can check
    the official manifest files for this kind of Deployment at [https://github.com/microsoft/sql-server-samples/tree/master/samples/features/high%20availability/Kubernetes/sample-manifest-files](https://github.com/microsoft/sql-server-samples/tree/master/samples/features/high%20availability/Kubernetes/sample-manifest-files).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种模式在**社区技术预览**（**CTP**）2.0版本中作为预览版本发布（[https://cloudblogs.microsoft.com/sqlserver/2018/12/10/availability-groups-on-kubernetes-in-sql-server-2019-preview/](https://cloudblogs.microsoft.com/sqlserver/2018/12/10/availability-groups-on-kubernetes-in-sql-server-2019-preview/)），但目前，在**一般可用性**（**GA**）版本中，Docker镜像和Kubernetes清单不兼容。如果您感兴趣，可以在[https://github.com/microsoft/sql-server-samples/tree/master/samples/features/high%20availability/Kubernetes/sample-manifest-files](https://github.com/microsoft/sql-server-samples/tree/master/samples/features/high%20availability/Kubernetes/sample-manifest-files)上检查此类部署的官方清单文件。
- en: 'For this reason, we are going to deploy SQL Server in the simpler, single-node
    failover mode. To do this, perform the following steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将以更简单的单节点故障转移模式部署SQL Server。要做到这一点，请执行以下步骤：
- en: Open the PowerShell window.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开PowerShell窗口。
- en: 'Create a `dev.yaml` manifest file for a new Kubernetes namespace with the following
    content, and apply it using the `kubectl apply -f .\dev.yaml` command:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新的Kubernetes命名空间创建一个`dev.yaml`清单文件，内容如下，并使用`kubectl apply -f .\dev.yaml`命令应用它：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a  `storage-class.yaml` manifest file for a Kubernetes storage class
    that uses an Azure Disk provisioner, and apply it using the `kubectl apply -f
    .\storage-class.yaml` command, as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为使用Azure Disk provisioner的Kubernetes存储类创建一个`storage-class.yaml`清单文件，并使用`kubectl
    apply -f .\storage-class.yaml`命令应用它，如下所示：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a `pvc.yaml` manifest file that defines a `mssql-data` **Persistent
    Volume Claim** (**PVC**) for the SQL Server instance. This PVC will be used for
    mounting data in `/var/opt/mssql` in the container. Apply the manifest using the  `kubectl
    apply -f .\pvc.yaml` command, as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`pvc.yaml`清单文件，为SQL Server实例定义一个`mssql-data`**持久卷索赔**（**PVC**）。这个PVC将用于在容器中的`/var/opt/mssql`中挂载数据。使用`kubectl
    apply -f .\pvc.yaml`命令应用该清单，如下所示：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Define a Kubernetes `mssql` Secret that contains a **System Administrator**
    (**SA**) user password for SQL Server, using your own, safe password, as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个Kubernetes `mssql` Secret，其中包含SQL Server的**系统管理员**（**SA**）用户密码，使用您自己的安全密码，如下所示：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a `sql-server.yaml` manifest file that defines the Kubernetes Deployment
    for SQL Server, as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`sql-server.yaml`清单文件，为SQL Server定义Kubernetes部署，如下所示：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are a couple of important parts to this manifest file, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单文件有几个重要部分，如下所示：
- en: First, we need an extra`volume-mount-permissions-fix` init container, which
    is required for ensuring that directories, after mounting PVC, have proper access
    permissions for SQL Server—the container will be run before the regular Pod containers
    are created. This is a good example of how init containers are used.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个额外的`volume-mount-permissions-fix`初始化容器，这是为了确保在挂载PVC后，目录对于SQL Server有适当的访问权限——该容器将在常规Pod容器创建之前运行。这是如何使用初始化容器的一个很好的例子。
- en: Secondly, we need to accept the **end-user license agreement** (**EULA**) using
    the `ACCEPT_EULA` environment variable and choose an appropriate SQL Server edition
    using the `MSSQL_PID` environment variable.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，我们需要接受**最终用户许可协议**（**EULA**），使用`ACCEPT_EULA`环境变量，并选择适当的SQL Server版本，使用`MSSQL_PID`环境变量。
- en: We are going to use the Developer edition because our application is hosted
    for development purposes only. You can read more about usage of these variables
    in the documentation for the image, at [https://hub.docker.com/_/microsoft-mssql-server](https://hub.docker.com/_/microsoft-mssql-server).
    Additionally, you need to provide a `MSSQL_SA_PASSWORD` environment variable, which
    contains the SA user password for the instance.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用Developer版本，因为我们的应用仅用于开发目的。您可以在图像的文档中阅读有关这些变量使用的更多信息，网址为[https://hub.docker.com/_/microsoft-mssql-server](https://hub.docker.com/_/microsoft-mssql-server)。此外，您需要提供一个`MSSQL_SA_PASSWORD`环境变量，其中包含实例的SA用户密码。
- en: For this, we are using the value from the `mssql` Secret that we created earlier.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，我们使用了之前创建的`mssql` Secret中的值。
- en: Next, we need to mount the volume provided by the `mssql-data` PVC to the `/var/opt/mssql`
    path.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将`mssql-data` PVC提供的卷挂载到`/var/opt/mssql`路径。
- en: This will provide a failover similar to SQL Server shared disk failover instances.
    And lastly, we have to ensure that `nodeSelector` is set to choose only Linux
    machines.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将提供类似于SQL Server共享磁盘故障转移实例的故障转移。最后，我们必须确保`nodeSelector`设置为仅选择Linux机器。
- en: 'Now, continue the Deployment using the following steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续使用以下步骤进行部署：
- en: Apply the manifest file using the `kubectl apply -f .\sql-server.yaml` command.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl apply -f .\sql-server.yaml`命令应用清单文件。
- en: 'Create a `sql-server-service.yaml` manifest file to create a Kubernetes service
    for your SQL Server instance. Depending on your needs, you can use type `ClusterIP`,
    or, if you expose the SQL Server instance for connections outside from the Kubernetes
    cluster (for example, for **SQL Server Management Studio** (**SSMS**)), you can
    use a `LoadBalancer` type. Apply the manifest file using the `kubectl apply -f
    .\sql-server-service.yaml` command, as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`sql-server-service.yaml`清单文件，为您的SQL Server实例创建一个Kubernetes服务。根据您的需求，您可以使用`ClusterIP`类型，或者，如果您将SQL
    Server实例暴露给Kubernetes集群外的连接（例如，用于**SQL Server Management Studio**（**SSMS**）），您可以使用`LoadBalancer`类型。使用`kubectl
    apply -f .\sql-server-service.yaml`命令应用清单文件，如下所示：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can observe the Pod creation using the following command:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令观察Pod的创建：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At this point, you have an MSSQL Server 2019 instance running in your cluster
    in the `dev` namespace that is accessible using an `mssql-deployment` **Domain
    Name System** (**DNS**) name inside of your cluster. Additionally, if you have
    created a LoadBalancer service, you can verify the instance using SSMS, providing
    the service's external IP address, user SA, and your chosen password.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，在`dev`命名空间中运行着一个MSSQL Server 2019实例，可以在集群内部使用`mssql-deployment`的**域名系统**（**DNS**）名称进行访问。此外，如果您创建了一个LoadBalancer服务，可以使用SSMS验证实例，提供服务的外部IP地址、用户SA和您选择的密码。
- en: We can now proceed to create manifest files for the voting application and deploying
    the application to the cluster.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续创建投票应用程序的清单文件，并将应用程序部署到集群中。
- en: Deploying the ASP.NET MVC application
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署ASP.NET MVC应用程序
- en: 'Finally, it is time for the big show! We will now deploy our voting application
    using a standard Kubernetes Deployment and, in the next section, we will expose
    it to the external users using the LoadBalancer service. First, we need to briefly
    summarize what is required for the proper Deployment of our application, as follow:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是大秀的时刻！我们将使用标准的Kubernetes部署现在部署我们的投票应用程序，并在下一节中使用LoadBalancer服务将其暴露给外部用户。首先，我们需要简要总结我们的应用程序的正确部署所需的内容，如下所示：
- en: A `packtpubkubernetesonwindows/voting-application:1.0.0` Docker image will be
    used for deploying the application. If you have pushed the image to your own image
    repository, you need to change the manifest file accordingly. We specify a `1.0.0`
    tag explicitly as we want to avoid pulling an unexpected container image version.
    You can read more about the best practices for container images in the documentation
    at [https://kubernetes.io/docs/concepts/configuration/overview/#container-images](https://kubernetes.io/docs/concepts/configuration/overview/#container-images).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将使用`packtpubkubernetesonwindows/voting-application:1.0.0` Docker镜像来部署该应用程序。如果您已将图像推送到自己的图像存储库，则需要相应更改清单文件。我们明确指定`1.0.0`标签，因为我们希望避免拉取意外的容器图像版本。您可以在文档中阅读有关容器图像的最佳实践的更多信息[https://kubernetes.io/docs/concepts/configuration/overview/#container-images](https://kubernetes.io/docs/concepts/configuration/overview/#container-images)。
- en: The application requires a `CONNECTIONSTRING_VotingApplication` environment
    variable to be set if we need a custom connection string. In the case of our Deployment,
    the connection string should have the following form: `Data Source=mssql-deployment;Initial
    Catalog=VotingApplication;MultipleActiveResultSets=true;User Id=sa;Password=$(MSSQL_SA_PASSWORD);`,
    where `$(MSSQL_SA_PASSWORD)` will be retrieved from a Kubernetes Secret.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该应用程序需要设置`CONNECTIONSTRING_VotingApplication`环境变量，如果需要自定义连接字符串。在我们的部署情况下，连接字符串应具有以下形式：`Data
    Source=mssql-deployment;Initial Catalog=VotingApplication;MultipleActiveResultSets=true;User
    Id=sa;Password=$(MSSQL_SA_PASSWORD);`，其中`$(MSSQL_SA_PASSWORD)`将从Kubernetes Secret中检索。
- en: Applying the initial database migration is required in order to seed the database
    data. We will do that using a Kubernetes Job—this approach can be generalized
    in your CI/CD pipeline. The migration itself is performed using the `ef6.exe database
    update` command—the image already contains this executable in the `C:/ef6/` directory.
    Please note that in a production environment, you might want to create a separate
    Docker image just for migrations that contains all the required tools. In this
    way, you would keep your application image clean and as small as possible.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用初始数据库迁移是为了填充数据库数据。我们将使用Kubernetes Job来执行这个操作——这种方法可以在您的CI/CD流水线中进行泛化。迁移本身是使用`ef6.exe
    database update`命令执行的——镜像已经包含了这个可执行文件在`C:/ef6/`目录中。请注意，在生产环境中，您可能希望创建一个单独的Docker镜像，专门用于迁移，其中包含所有所需的工具。这样，您可以保持应用程序镜像的干净和尽可能小。
- en: We will not create any dedicated liveness and readiness probes yet as this will
    be demonstrated in the next chapter: [Chapter 11](9ad8c38e-6d0d-435b-a46c-82a468f18007.xhtml), *Configuring
    Applications to Use Kubernetes Features*.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们暂时不会创建专用的活跃性和就绪性探针，这将在下一章节中进行演示：[第11章](9ad8c38e-6d0d-435b-a46c-82a468f18007.xhtml)，*配置应用程序使用Kubernetes功能*。
- en: 'To deploy the voting application, perform the following steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署投票应用程序，请执行以下步骤：
- en: Open the PowerShell window.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开PowerShell窗口。
- en: 'Create a `voting-application.yaml` manifest file for the Kubernetes Deployment
    with the following contents:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`voting-application.yaml`的Kubernetes部署清单文件，内容如下：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s explain the most important parts of this manifest file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这个清单文件中最重要的部分：
- en: We define it as a Deployment with `5` initial replicas—we can scale it as we
    wish, as the frontend application is stateless in our case.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将其定义为一个具有`5`个初始副本的部署——在我们的情况下，前端应用程序是无状态的，因此我们可以根据需要进行扩展。
- en: 'In order to have a simple mechanism for preventing the accessing of Pods for
    which IIS is still initializing, we add `minReadySeconds: 5`. In the next chapter,
    we will configure a proper readiness and liveness probe.'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '为了防止IIS仍在初始化的Pod被访问，我们添加了`minReadySeconds: 5`，以便有一个简单的机制。在下一章中，我们将配置适当的就绪性和活跃性探针。'
- en: We also explicitly set the Deployment update strategy to `RollingUpdate` with
    the maximum number of unavailable Pods to `25%`, allowing us to create up to `25%`
    more Pods than the desired number during rollout (this is controlled by the `maxSurge`
    parameter).
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还明确将部署更新策略设置为`RollingUpdate`，最大不可用Pod数量为`25%`，允许我们在部署过程中创建多达预期数量的`25%`的Pod（这由`maxSurge`参数控制）。
- en: Next, remember to set a proper `nodeSelector` to deploy to Windows nodes only.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，记得设置适当的`nodeSelector`，只部署到Windows节点。
- en: The image is specified to use a particular tag—if you use your own image, update
    this accordingly.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定要使用特定标签的镜像——如果使用自己的镜像，相应地更新它。
- en: In order to create the connection string for the database, we have to first
    retrieve the SA user password from the `mssql` Secret `(6a)` and initialize the
    `MSSQL_SA_PASSWORD` environment variable `(6b)`, which can be used for creating
    the actual connection string stored in the `CONNECTIONSTRING_VotingApplication`
    variable (6c). As demonstrated, you can use existing environment variables to
    initialize new environment variables: `Data Source=mssql-deployment;Initial Catalog=VotingApplication;MultipleActiveResultSets=true;User
    Id=sa;Password=$(MSSQL_SA_PASSWORD);`. This is a common pattern when you want
    to retrieve a value from a Secret and use it for defining another variable.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建数据库的连接字符串，我们必须首先从`mssql` Secret `(6a)`中检索SA用户密码，并初始化`MSSQL_SA_PASSWORD`环境变量`(6b)`，该变量可用于创建存储在`CONNECTIONSTRING_VotingApplication`变量中的实际连接字符串（6c）。正如所示，您可以使用现有环境变量来初始化新的环境变量：`Data
    Source=mssql-deployment;Initial Catalog=VotingApplication;MultipleActiveResultSets=true;User
    Id=sa;Password=$(MSSQL_SA_PASSWORD);`。当您想要从Secret中检索值并用它来定义另一个变量时，这是一种常见的模式。
- en: 'Now, please continue the Deployment using the following steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请按以下步骤继续部署：
- en: 'Apply the manifest file using the `kubectl apply -f .\voting-application.yaml`
    command. Wait for the Pods to start, as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl apply -f .\voting-application.yaml`命令应用清单文件。等待Pod启动，如下所示：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The application has been successfully deployed. Before accessing it, we first
    need to apply the initial database migration—technically, you could access the
    application without seeding the database as the schema would get initialized automatically,
    but there would be no data in the tables at all. To perform the database migration,
    please perform the following steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已成功部署。在访问之前，我们首先需要应用初始数据库迁移——从技术上讲，您可以在不播种数据库的情况下访问应用程序，因为架构将自动初始化，但表中将没有任何数据。要执行数据库迁移，请执行以下步骤：
- en: 'Create a `ef6-update-database.yaml` manifest file for the Kubernetes Job with
    the following content:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Kubernetes Job创建一个名为`ef6-update-database.yaml`的清单文件，内容如下：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The key points here are setting a **time-to-live** (**TTL**) seconds value in
    order to trigger automatic cleanup of Pods created by the Job `(1)` and ensuring
    that the Pods are executed on Windows nodes `(2)`. The last part is setting the
    container image `(3)`. In our case, we use the same as for the application, as
    it contains all the migration tools. The `(4)` command is specific to EF, but
    in general, you have to provide the path to the .NET assembly that contains the
    migrations using the `--assembly` parameter, and a proper connection string, using
    the `--connection-string` parameter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于设置**生存时间**（**TTL**）秒值，以便触发作业创建的Pod的自动清理`(1)`，并确保Pod在Windows节点上执行`(2)`。最后一部分是设置容器镜像`(3)`。在我们的情况下，我们使用与应用程序相同的镜像，因为它包含所有迁移工具。`(4)`命令是特定于EF的，但通常情况下，您必须使用`--assembly`参数提供包含迁移的.NET程序集的路径，并使用`--connection-string`参数提供适当的连接字符串。
- en: Apply the manifest file using the `kubectl apply -f .\ef6-update-database.yaml`
    command.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl apply -f .\ef6-update-database.yaml`命令应用清单文件。
- en: 'Wait for the Job to run to completion, as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待作业运行完成，如下所示：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can check the logs using the standard `kubectl logs` command, but you have
    to provide the `jobs` prefix, as follows:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用标准的`kubectl logs`命令检查日志，但是您必须提供`jobs`前缀，如下所示：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, if anything went wrong—for example, you cannot access the logs (because
    the Pod did not even start) or all Job executions completed with a failure—the
    best way to investigate is describing the Job object and finding the Pods that
    it has created, as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果出现任何问题，例如您无法访问日志（因为Pod甚至没有启动）或所有作业执行都以失败结束，最好的调查方法是描述作业对象并找到它创建的Pod，如下所示：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Using this information, you can describe any Pods that did not start properly,
    or you can even directly describe them using the Job name, like this:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些信息，您可以描述任何未正确启动的Pod，或者甚至可以直接使用作业名称描述它们，如下所示：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our application is ready—we can try accessing it, even if there is no LoadBalancer
    Service for it yet. To do that, we will use the technique described in the previous
    chapters, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已经准备就绪 - 即使尚未为其创建LoadBalancer服务。为此，我们将使用前几章中描述的技术，如下所示：
- en: 'In the PowerShell window, execute the following command to forward all network
    traffic from the localhost port `5000` to port `80` on one of the Pods in the `voting-application` Deployment,
    as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PowerShell窗口中，执行以下命令，将所有网络流量从本地主机端口`5000`转发到`voting-application`部署中一个Pod的端口`80`，如下所示：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Without closing the PowerShell session, open your web browser and navigate
    to `http://localhost:5000`. You should see the following screen:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不关闭PowerShell会话的情况下，打开您的网络浏览器并导航到`http://localhost:5000`。您应该会看到以下屏幕：
- en: '![](assets/c72677f2-25c3-4819-8028-626c9c94f3fb.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c72677f2-25c3-4819-8028-626c9c94f3fb.png)'
- en: Congratulations! You have successfully deployed the voting application—now,
    we can proceed to expose the Deployment using a LoadBalancer service.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功部署了投票应用程序 - 现在，我们可以继续使用LoadBalancer服务公开部署。
- en: Accessing the application
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问应用程序
- en: In this section, we will expose our voting application to external users by
    creating a Kubernetes service of the LoadBalancer type. Services have been covered
    in depth in [Chapter 5](da2ee6af-a754-4fc8-ae62-86d8e68f0bd0.xhtml), *Kubernetes
    Networking*. At the end of this section, anyone who has the external IP of your
    new service will be able to access the application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过创建LoadBalancer类型的Kubernetes服务，向外部用户公开我们的投票应用程序。服务在[第5章](da2ee6af-a754-4fc8-ae62-86d8e68f0bd0.xhtml)中已经进行了深入讨论，*Kubernetes网络*。在本节结束时，任何拥有您的新服务的外部IP的人都将能够访问该应用程序。
- en: 'To create the service, execute the following steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建服务，请执行以下步骤：
- en: Open the PowerShell window.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开PowerShell窗口。
- en: 'Create a `voting-application-service.yaml` manifest file for the Kubernetes
    service with the following content:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Kubernetes服务创建`voting-application-service.yaml`清单文件，内容如下：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the key points are ensuring that the type of service is `LoadBalancer
    (1)` and using the proper port for the service `(2)`. In our case, the port on
    the physical Azure load balancer will be the same as for the application Pods,
    so we do not need to specify the `targetPort` parameter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，关键点是确保服务类型为`LoadBalancer (1)`，并为服务使用正确的端口`(2)`。在我们的情况下，物理Azure负载均衡器上的端口将与应用程序Pod的端口相同，因此我们不需要指定`targetPort`参数。
- en: Apply the manifest file using the `kubectl apply -f .\voting-application-service.yaml`
    command.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl apply -f .\voting-application-service.yaml`命令应用清单文件。
- en: 'Wait for the external IP to be provided for the new service, as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待为新服务提供外部IP，如下所示：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this case, the external IP is `104.42.142.217`. Use your web browser and
    navigate to `http://104.42.142.217`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，外部IP是`104.42.142.217`。使用您的网络浏览器并导航到`http://104.42.142.217`。
- en: 'You can try refreshing the page multiple times and accessing it from different
    browsers. You will see in the page footer that you are served by different Pods.
    If you experience any delays at the beginning, it is caused by IIS starting the
    app pool in a given Pod when accessed for the first time. The code can be seen
    in the following snippet:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以尝试多次刷新页面，并从不同的浏览器访问。您将在页面页脚看到您被不同的Pod提供服务。如果您在开始时遇到任何延迟，那是因为当第一次访问时，IIS启动了给定Pod中的应用程序池。代码可以在以下片段中看到：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The application is now accessible to all external users! Now, we will take a
    look at how you can scale the application.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序对所有外部用户都是可访问的！现在，我们将看看如何扩展应用程序。
- en: Scaling the application
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展应用程序
- en: In our design, the only component that can scale is the ASP.NET MVC frontend.
    SQL Server cannot be scaled as it runs in a single node with automatic failover
    mode. Real scaling of the SQL Server requires the use of **Availability Groups**
    (**AG**) and a dedicated Kubernetes Operator, as mentioned in the earlier sections.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的设计中，唯一可以扩展的组件是ASP.NET MVC前端。SQL Server无法扩展，因为它在单个节点上以自动故障转移模式运行。真正扩展SQL
    Server需要使用**可用性组**（**AG**）和专用的Kubernetes Operator，如前面的部分所述。
- en: 'In the previous chapter, we have shown different declarative and imperative
    methods on how to scale a Deployment. We will now show the safest, declarative
    way of scaling the Deployment. Autoscaling will not be covered as it is described
    in more detail in the next chapter: [Chapter 11](9ad8c38e-6d0d-435b-a46c-82a468f18007.xhtml), *Configuring
    Applications to Use Kubernetes Features*. To scale the frontend Deployment from
    5 replicas to 10, perform the following steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们展示了不同的声明性和命令式方法，介绍了如何扩展部署。现在我们将展示最安全的、声明性的扩展部署的方法。自动扩展将不在此处涵盖，因为它在下一章中有更详细的描述：[第11章](9ad8c38e-6d0d-435b-a46c-82a468f18007.xhtml)，*配置应用程序以使用Kubernetes功能*。要将前端部署从5个副本扩展到10个，请执行以下步骤：
- en: Open the PowerShell window.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开PowerShell窗口。
- en: 'Modify your existing `voting-application.yaml` manifest file to change the
    number of replicas, as follows:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改您现有的`voting-application.yaml`清单文件，更改副本的数量，如下所示：
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Apply the manifest file using the `kubectl apply -f .\voting-application.yaml`
    command.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl apply -f .\voting-application.yaml`命令应用清单文件。
- en: 'Observe the status of the rollout, as illustrated in the following code block:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察滚动的状态，如下面的代码块所示：
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You will eventually see that it never reaches 10 ready replicas! What happened?
    The answer to this is that we have exhausted the CPU reservation limits for our
    two Windows nodes—each node was scheduled with four Pods, reserving `500m` CPU
    per Pod. If you check the specification of the Standard_D2_v3 Azure VM, you will
    see that it has two vCPUs, which means that we have reserved all the resources.
    You can verify this theory by inspecting the Pods that are in `Pending` status,
    as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终您会发现它永远不会达到10个就绪的副本！发生了什么？答案是我们已经耗尽了两个Windows节点的CPU预留限制——每个节点都安排了四个Pod，每个Pod预留了`500m`的CPU。如果您检查Standard_D2_v3
    Azure VM的规格，您会发现它有两个vCPU，这意味着我们已经预留了所有资源。您可以通过检查处于`Pending`状态的Pod来验证这个理论，如下所示：
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Describe one of the Pods that is in a `Pending` state, like this:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述处于`Pending`状态的一个Pod，如下所示：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'What can we do in such a case? Consider the following options:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以做什么？考虑以下选项：
- en: Scale your Kubernetes cluster up by adding more Windows nodes.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加更多的Windows节点来扩展您的Kubernetes集群。
- en: Do not scale the cluster up; decrease the CPU limits for the Deployment.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要扩展集群；减少部署的CPU限制。
- en: Do not scale the cluster up; do not change CPU limits for the Deployment, but
    decrease the CPU requests in order to do an overcommit. You can dive deeper into
    this concept by checking out the official documentation at [https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#how-pods-with-resource-limits-are-run](https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#how-pods-with-resource-limits-are-run).
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要扩展集群；不要更改部署的CPU限制，而是减少CPU请求以进行超额分配。您可以通过查看官方文档深入了解这个概念：[https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#how-pods-with-resource-limits-are-run](https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#how-pods-with-resource-limits-are-run)。
- en: 'In general, to decide what to do, you have to understand the requirements for
    your application and how it behaves under low CPU availability. As a demonstration,
    we will perform an overcommit of CPU resources, as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，为了决定要做什么，您必须了解应用程序的要求以及在低CPU可用性下的行为。作为演示，我们将执行CPU资源的超额分配，如下所示：
- en: Modify the `voting-application-service.yaml` manifest file.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`voting-application-service.yaml`清单文件。
- en: 'Change the requested CPU value to `250m`, leaving the limits value unchanged.
    Please note that we also need to modify `maxUnavailable` to allow a larger number
    of Pods to be unavailable during the rollout. With the previous value of `25%`,
    we would run into a deadlock situation, as already, 2 of 10 Pods are not available.
    The code for this is illustrated in the following block:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将请求的CPU值更改为`250m`，保持限制值不变。请注意，我们还需要修改`maxUnavailable`以允许在部署期间不可用的Pods数量更多。使用先前的`25%`值，我们将遇到死锁情况，因为已经有10个Pod中的2个不可用。此代码如下所示：
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Apply the manifest file using the `kubectl apply -f .\voting-application.yaml` command
    and observe how the Deployment scales to 10 replicas.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl apply -f .\voting-application.yaml`命令应用清单文件，并观察部署如何扩展到10个副本。
- en: Now that you understand how you can scale our voting application, we can move
    to the last section in this chapter, which will show how to debug the application.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了如何扩展我们的投票应用程序，我们可以转到本章的最后一节，展示如何调试应用程序。
- en: Debugging the application
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试应用程序
- en: 'Debugging applications is a broad topic and involves a lot of techniques depending
    on the need—it may involve detailed telemetry, traces, or performance counter
    analysis. From a developer perspective, there is one technique that is especially
    important: working with a code debugger. One of the problems with containerized
    workloads is that they are relatively heavy to debug using standard tools such
    as Visual Studio—the processes are not running locally and you cannot easily attach
    the debugger as if it was a local process. In this section we will show the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 调试应用程序是一个广泛的话题，涉及许多技术，具体取决于需求——可能涉及详细的遥测、跟踪或性能计数器分析。从开发者的角度来看，有一种技术特别重要：与代码调试器一起工作。容器化工作负载的一个问题是，使用诸如Visual
    Studio之类的标准工具进行调试相对较重——进程不在本地运行，您不能像本地进程一样轻松附加调试器。在本节中，我们将展示以下内容：
- en: How to access application logs produced by log monitor
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何访问日志监视器生成的应用程序日志
- en: How to enable Visual Studio remote debugging via `kubectl` port forwarding
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过`kubectl`端口转发启用Visual Studio远程调试
- en: 'Accessing application logs is straightforward as it involves the standard `kubectl
    logs` command. In production scenarios, you would probably use Azure Log Analytics
    or Elasticsearch for browsing logs more efficiently. To access voting application
    logs, execute the following command, which will load logs from all Pods in the
    Deployment:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 访问应用程序日志很简单，因为它涉及标准的`kubectl logs`命令。在生产场景中，您可能会使用Azure Log Analytics或Elasticsearch更有效地浏览日志。要访问投票应用程序日志，请执行以下命令，该命令将从部署中的所有Pod加载日志：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The current logging settings are quite verbose, but you can see all the log
    messages logged by Serilog to the Windows event log—for example, the preceding
    line comes from the `VotingApplicationContextFactory` class ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Factories/VotingApplicationContextFactory.cs#L28](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Factories/VotingApplicationContextFactory.cs#L28)).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的日志设置非常详细，但您可以在Windows事件日志中看到Serilog记录的所有日志消息，例如前面的行来自`VotingApplicationContextFactory`类([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Factories/VotingApplicationContextFactory.cs#L28](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Factories/VotingApplicationContextFactory.cs#L28))。
- en: 'Now, let''s move to the more complicated scenario, which is Visual Studio remote
    debugging via `kubectl` port forwarding. This use case is not documented yet,
    but it involves standard techniques known from non-containerized Deployments.
    We will do the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向更复杂的情景，即通过`kubectl`端口转发进行Visual Studio远程调试。这种用例尚未有文档记录，但它涉及到从非容器化部署中已知的标准技术。我们将执行以下操作：
- en: Create a dedicated Docker image for debugging that has Visual Studio 2019 remote
    tools installed ([https://docs.microsoft.com/en-us/visualstudio/debugger/remote-debugging?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/debugger/remote-debugging?view=vs-2019)).
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为调试创建一个专用的Docker镜像，其中安装了Visual Studio 2019远程工具([https://docs.microsoft.com/en-us/visualstudio/debugger/remote-debugging?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/debugger/remote-debugging?view=vs-2019))。
- en: Push the image to the registry with a special tag.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用特殊标签将镜像推送到注册表。
- en: Modify our Deployment so that it uses the new image—for production scenarios,
    you would rather create a separate Deployment.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改我们的部署，以使用新的镜像——对于生产情景，您可能更愿意创建一个单独的部署。
- en: Copy **program database** (**PDB**) symbol files from the container. We have
    to perform this step as building an application in the container may result in
    a slightly different output assembly and symbols.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从容器中复制**程序数据库**（**PDB**）符号文件。我们必须执行此步骤，因为在容器中构建应用程序可能会导致略有不同的输出程序集和符号。
- en: Use `kubectl` port forwarding capabilities to expose the remote debugger to
    the local development machine.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl`端口转发功能将远程调试器暴露给本地开发机。
- en: Attach Visual Studio to the `w3wp.exe` process using the forwarded remote debugger.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用转发的远程调试器将Visual Studio附加到`w3wp.exe`进程。
- en: Load any missing debugging symbols.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载任何丢失的调试符号。
- en: In our scenario, we are limited to the traditional Visual Studio remote debugger
    because we are running on the classic .NET Framework. For .NET Core, there are
    more approaches, which involve both Visual Studio Enterprise and Visual Studio
    Code. You can read more about Visual Studio Enterprise snapshot debugging for
    .NET Core running on Linux at [https://github.com/Microsoft/vssnapshotdebugger-docker](https://github.com/Microsoft/vssnapshotdebugger-docker),
    and  Visual Studio Code with Azure Dev Spaces at [https://microsoft.github.io/AzureTipsAndTricks/blog/tip228.html](https://microsoft.github.io/AzureTipsAndTricks/blog/tip228.html).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情景中，由于我们正在运行经典的.NET Framework，我们受限于传统的Visual Studio远程调试器。对于.NET Core，有更多的方法，涉及到Visual
    Studio Enterprise和Visual Studio Code。您可以在[https://github.com/Microsoft/vssnapshotdebugger-docker](https://github.com/Microsoft/vssnapshotdebugger-docker)上阅读有关在Linux上运行的.NET
    Core的Visual Studio Enterprise快照调试，以及使用Azure Dev Spaces的Visual Studio Code的更多信息[https://microsoft.github.io/AzureTipsAndTricks/blog/tip228.html](https://microsoft.github.io/AzureTipsAndTricks/blog/tip228.html)。
- en: Let's start by creating our modified Dockerfile for debugging.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建用于调试的修改后的Dockerfile开始。
- en: Creating a debug Dockerfile and publishing a debug image
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个调试Dockerfile并发布一个调试镜像。
- en: 'In order to create a debug Dockerfile, we will use our original `Dockerfile.production`
    file and perform slight modifications. The resulting file is `Dockerfile.debug`
    ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Dockerfile.debug](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Dockerfile.debug)).
    Let''s summarize its contents:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个调试Dockerfile，我们将使用我们的原始`Dockerfile.production`文件并进行轻微修改。 结果文件是`Dockerfile.debug`（[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Dockerfile.debug](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter10/01_voting-application-src/Dockerfile.debug)）。
    让我们总结其内容：
- en: 'The build stage in the Dockerfile looks almost the same—the only difference
    is that we are using a debug configuration for the build. This will ensure that
    we have proper debug assembly generated, together with PDB symbols, as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dockerfile中的构建阶段看起来几乎相同-唯一的区别是我们正在使用调试配置进行构建。 这将确保我们生成了适当的调试程序集，以及PDB符号，如下所示：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the final build stage, we first download and install Visual Studio 2019
    remote tools. We are exposing port `4020` as we are going to host the remote debugger
    using that port, as shown in the following code block:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最终的构建阶段，我们首先下载并安装Visual Studio 2019远程工具。 我们正在公开端口`4020`，因为我们将使用该端口托管远程调试器，如下面的代码块所示：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The rest of the image remains the same except for the `ENTRYPOINT`. We modify
    it so that the remote debugger process (`msvsmon.exe`) is started in the background.
    In principle, it is not a recommended practice to start another process in the
    background in a container, but in our case, we want the quickest way to start
    the remote debugger together with other services. The syntax of this command is
    Powershell-specific, and can be seen in the following code block:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图像的其余部分保持不变，除了`ENTRYPOINT`。 我们修改它，以便远程调试器进程（`msvsmon.exe`）在后台启动。 原则上，在容器中在后台启动另一个进程并不是一种推荐的做法，但在我们的情况下，我们希望以最快的方式启动远程调试器以及其他服务。
    此命令的语法是特定于Powershell的，并且可以在以下代码块中看到：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With the debug Dockerfile ready, we can create the image and push it to the
    Docker Hub. Please perform the following steps:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 调试Dockerfile准备就绪后，我们可以创建图像并将其推送到Docker Hub。 请执行以下步骤：
- en: 'We are going to use a convention that debug images will have a `-debug` postfix
    in the tag—for example, for a production tag 1.0.0, we will use a debug tag `1.0.0-debug`.
    Another alternative would be creating a new dedicated image repository for debug
    images. To build the image, execute the following command in the root of the voting
    application source (use your own image repository name accordingly):'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一种约定，即调试图像的标记将在标记中带有“-debug”后缀-例如，对于生产标记1.0.0，我们将使用调试标记`1.0.0-debug`。 另一种选择是为调试图像创建一个新的专用图像存储库。
    要构建图像，请在投票应用程序源的根目录中执行以下命令（相应地使用您自己的图像存储库名称）：
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When the build finishes, push the new image to Docker Hub, as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建完成后，将新图像推送到Docker Hub，如下所示：
- en: '[PRE45]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With the image pushed, we are ready to roll out a debug Deployment of our application.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图像推送后，我们准备推出应用程序的调试部署。
- en: Updating the Kubernetes Deployment
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新Kubernetes部署
- en: 'As mentioned earlier, for simplicity, we will reuse the same Kubernetes Deployment
    and service to enable debugging. We need to make the following modifications to
    our original `voting-application.yaml` manifest file:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为了简单起见，我们将重用相同的Kubernetes部署和服务以启用调试。 我们需要对原始`voting-application.yaml`清单文件进行以下修改：
- en: '[PRE46]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Modifying the number of replicas to `1` ensures that when debugging, we have
    only one Pod to which the traffic is redirected. This means that we can easily
    break on any action performed in the **user interface** (**UI**) using the debugger.
    On top of that, we have to update the image to our new `packtpubkubernetesonwindows/voting-application:1.0.0-debug`
    tag and set `imagePullPolicy` to `Always` to make introducing changes easier.
    For example, if you find a bug and want to quickly redeploy the image and reattach,
    you build the image with the same tag, push it, and manually delete the currently
    running Pod in the Deployment. This will recreate the Pod and thanks to the `Always`
    policy, the image will be pulled again.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 将副本的数量修改为`1`，确保在调试时，我们只有一个Pod接收流量。这意味着我们可以轻松地使用调试器在**用户界面**（UI）中断任何操作。除此之外，我们还需要将镜像更新为我们的新`packtpubkubernetesonwindows/voting-application:1.0.0-debug`标签，并将`imagePullPolicy`设置为`Always`，以便更轻松地引入更改。例如，如果您发现了一个错误并希望快速重新部署镜像并重新连接，您可以使用相同的标签构建镜像，推送它，并手动删除部署中当前运行的Pod。这将重新创建Pod，并且由于`Always`策略，镜像将再次被拉取。
- en: Now, apply the manifest file using the `kubectl apply -f .\voting-application.yaml`
    command. Our setup is ready to attach the Visual Studio debugger.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`kubectl apply -f .\voting-application.yaml`命令应用清单文件。我们的设置已经准备好连接Visual
    Studio调试器。
- en: Attaching the Visual Studio remote debugger
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接Visual Studio远程调试器
- en: 'The cherry on top is attaching your Visual Studio 2019 to the IIS app pool
    process using a remote debugger running inside the container. This process is
    not fully automated (but could be scripted), and it is possible to further unify
    PDB symbols between the container image and your local development machine. To
    attach the debugger, execute the following steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是使用远程调试器将您的Visual Studio 2019连接到运行在容器内部的IIS应用程序池进程。这个过程并不是完全自动化的（但可以脚本化），并且可以进一步统一容器镜像和本地开发机器之间的PDB符号。要连接调试器，请执行以下步骤：
- en: Open the PowerShell window.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开PowerShell窗口。
- en: 'Determine the name of your application Pod using the following standard command:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下标准命令确定您的应用程序Pod的名称：
- en: '[PRE47]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Use the `kubectl cp` command to copy the `VotingApplication.pdb` file to your
    current directory, as follows:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl cp`命令将`VotingApplication.pdb`文件复制到当前目录，具体如下：
- en: '[PRE48]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Alternatively, you can perform this locally using Docker by creating a temporary
    container and copying the file using the following commands:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您可以在本地使用Docker执行此操作，通过创建临时容器并使用以下命令复制文件：
- en: '[PRE49]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Use the `kubectl port-forward` command to forward all traffic from your local
    `5000` port to port `4020` in your Pod—this is where the Visual Studio remote
    debugger is exposed—as follows:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl port-forward`命令将所有流量从本地的`5000`端口转发到Pod中的`4020`端口，这是Visual Studio远程调试器暴露的地方，具体如下：
- en: '[PRE50]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, you are ready to attach Visual Studio 2019 to the remote debugger. Open
    `VotingApplication.sln` in Visual Studio, and navigate to Debug > Attach to Process...:,
    as shown in the following screenshot:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您已经准备好将Visual Studio 2019连接到远程调试器。在Visual Studio中打开`VotingApplication.sln`，并导航到调试
    > 附加到进程...，如下截图所示：
- en: '![](assets/1dae82b3-48ba-4d1a-bc72-456bf4ed43ed.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1dae82b3-48ba-4d1a-bc72-456bf4ed43ed.png)'
- en: 'In the dialog, set Connection type as Remote (no authentication), set Connection
    target to the forwarded port `localhost:5000`, select Show processes from all
    users, and click the Refresh button, as shown in the following screenshot:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框中，将连接类型设置为远程（无身份验证），将连接目标设置为转发端口`localhost:5000`，选择显示所有用户的进程，并单击刷新按钮，如下截图所示：
- en: '![](assets/6d9f7929-e738-4a6b-bf3b-7420926c5eee.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6d9f7929-e738-4a6b-bf3b-7420926c5eee.png)'
- en: 'You should see the list of all processes running in the container. If, at this
    point, you have encountered connection problems, you can execute into the container
    in Kubernetes and check if the `msvsmon.exe` process is still running. If it is
    not, you can recreate the container or start the process manually using the same
    command as in the Dockerfile, like this:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到容器中运行的所有进程列表。如果在这一点上遇到连接问题，您可以在Kubernetes中执行进入容器，并检查`msvsmon.exe`进程是否仍在运行。如果没有，您可以重新创建容器或使用与Dockerfile中相同的命令手动启动进程，就像这样：
- en: '[PRE51]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, navigate in the browser to the external IP of the service. We need to ensure
    that the IIS app pool process (`w3wp.exe`) is started.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在浏览器中导航到服务的外部IP。我们需要确保IIS应用程序池进程（`w3wp.exe`）已启动。
- en: 'In the Attach to Process dialog, refresh the list of processes, find the `w3wp.exe`
    process, and click the Attach button, as shown in the following screenshot:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“附加到进程”对话框中，刷新进程列表，找到`w3wp.exe`进程，并单击“附加”按钮，如下截图所示：
- en: '![](assets/8cbca376-ce7f-4fb1-924d-b04e0a128064.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8cbca376-ce7f-4fb1-924d-b04e0a128064.png)'
- en: 'The debugger is attached, but it may have missing symbols. You can verify this
    by placing a breakpoint anywhere in the code, as shown in the following screenshot:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试器已附加，但可能缺少符号。您可以通过在代码的任何位置设置断点来验证这一点，如下截图所示：
- en: '![](assets/3d43baaf-6ab5-4925-a0c1-ddc793ca773f.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3d43baaf-6ab5-4925-a0c1-ddc793ca773f.png)'
- en: 'If this is the case, to load custom PDB symbols, navigate to Debug > Windows
    > Modules, find the `VotingApplication.dll` assembly, right-click, and choose
    Load Symbols, as shown in the following screenshot:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这种情况，要加载自定义PDB符号，请导航到调试 > 窗口 > 模块，找到`VotingApplication.dll`程序集，右键单击，然后选择“加载符号”，如下截图所示：
- en: '![](assets/d43f60c1-ee89-4bf6-bb04-ad9bd99dd386.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d43f60c1-ee89-4bf6-bb04-ad9bd99dd386.png)'
- en: Navigate to the directory where you have copied the `VotingApplication.pdb`
    file. The symbols will be loaded automatically and the breakpoint will become
    hittable.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到您复制了`VotingApplication.pdb`文件的目录。符号将自动加载，断点将变得可触发。
- en: In the web browser, perform the action that should cause the breakpoint to be
    hit.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web浏览器中，执行应该触发断点的操作。
- en: 'Now, depending on your connection speed, Visual Studio may freeze for a bit
    of time (even a couple of minutes) until the debugger fully attaches. But, after
    this initial hiccup, the debugging experience should be satisfying, and is shown
    in the following screenshot:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，根据您的连接速度，Visual Studio可能会在调试器完全附加之前冻结一段时间（甚至几分钟）。但是，经过这一最初的小问题后，调试体验应该是令人满意的，如下截图所示：
- en: '![](assets/21f54b4c-d886-45ed-850a-a8cf42c10cb5.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/21f54b4c-d886-45ed-850a-a8cf42c10cb5.png)'
- en: Congratulations—you have successfully attached a debugger remotely to a process
    running inside a Kubernetes Pod!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜——您已成功远程附加调试器到运行在Kubernetes Pod内的进程！
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned how to deploy an ASP.NET MVC application to
    a Kubernetes cluster, together with a containerized Microsoft SQL Server 2019\.
    We have shown how to approach making an existing .NET Framework application cloud-ready
    and how to create robust Dockerfiles for such applications. Next, we have prepared
    an AKS Engine cluster Deployment for our voting application and deployed Microsoft
    SQL Server 2019 in single-node failover mode, backed by Azure Disk. The application
    was deployed to the cluster using a Kubernetes Deployment and we have used a Kubernetes
    Job in order to apply EF database migrations. After that, you have learned a bit
    more about scaling the Kubernetes Deployments and overcommitting of computing
    resources. And finally, you had a deep dive into debugging .NET Framework applications
    running inside Kubernetes Pods using Visual Studio 2019's remote debugger via
    `kubectl` port forwarding.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了如何将ASP.NET MVC应用程序部署到Kubernetes集群，以及如何将容器化的Microsoft SQL Server 2019部署到其中。我们展示了如何使现有的.NET
    Framework应用程序适合云环境，以及如何为这些应用程序创建健壮的Dockerfile。接下来，我们为我们的投票应用程序准备了一个AKS Engine集群部署，并以单节点故障转移模式部署了由Azure
    Disk支持的Microsoft SQL Server 2019。该应用程序是使用Kubernetes部署部署到集群中的，并且我们使用了Kubernetes
    Job来应用EF数据库迁移。之后，您将了解有关扩展Kubernetes部署和计算资源超额分配的更多信息。最后，您将深入了解如何通过`kubectl`端口转发使用Visual
    Studio 2019的远程调试器来调试在Kubernetes Pod中运行的.NET Framework应用程序。
- en: The next chapter will focus on more advanced Kubernetes features—we will extend
    our voting application to fully utilize the power of Kubernetes.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点介绍更高级的Kubernetes功能-我们将扩展我们的投票应用程序，充分利用Kubernetes的功能。
- en: Questions
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the possible ways to inject configuration to an application running
    in a Kubernetes Pod?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kubernetes Pod中运行应用程序注入配置的可能方式有哪些？
- en: What is the purpose of the Windows container log monitor provided by Microsoft?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微软提供的Windows容器日志监视器的目的是什么？
- en: Why is migrating database schema for replicated applications a challenging task?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么对于复制的应用程序迁移数据库架构是一项具有挑战性的任务？
- en: Why are we using a persistent volume backed by Azure Disk for Microsoft SQL
    Server data?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们要使用由Azure Disk支持的持久卷来存储Microsoft SQL Server数据？
- en: How can you apply EF database migration to an application running in Kubernetes?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将EF数据库迁移应用到在Kubernetes中运行的应用程序？
- en: What is CPU/memory resource overcommitting in Kubernetes?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes中的CPU/内存资源超额分配是什么？
- en: Why do you need `kubectl` port forwarding in order to connect to a Visual Studio
    remote debugger in a container?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么您需要使用`kubectl`端口转发才能连接到容器中的Visual Studio远程调试器？
- en: You can find answers to these questions in the *Assessment* of this book.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的*评估*部分找到这些问题的答案。
- en: Further reading
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about Kubernetes applications management, please refer
    to the following Packt books:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Kubernetes应用程序管理的更多信息，请参考以下Packt图书：
- en: '*The Complete Kubernetes Guide* ([https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide)).'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完整的Kubernetes指南* ([https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide)).'
- en: '*Getting Started with Kubernetes - Third Edition* ([https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition)).'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始使用Kubernetes-第三版* ([https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition)).'
- en: '*Kubernetes for Developers* ([https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers)).'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向开发人员的Kubernetes* ([https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers)).'
- en: 'For alternative approaches to debugging applications running in Kubernetes
    clusters (for example, Telepresence), you can read the following articles:'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于在Kubernetes集群中运行的应用程序的替代调试方法（例如Telepresence），您可以阅读以下文章：
- en: '[https://kubernetes.io/docs/tasks/debug-application-cluster/local-debugging/](https://kubernetes.io/docs/tasks/debug-application-cluster/local-debugging/).'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/tasks/debug-application-cluster/local-debugging/](https://kubernetes.io/docs/tasks/debug-application-cluster/local-debugging/).'
- en: '[https://www.telepresence.io/tutorials/kubernetes](https://www.telepresence.io/tutorials/kubernetes).'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.telepresence.io/tutorials/kubernetes](https://www.telepresence.io/tutorials/kubernetes).'
