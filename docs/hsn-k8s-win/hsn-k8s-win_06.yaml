- en: Kubernetes Concepts and Windows Support
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes概念和Windows支持
- en: In the previous chapters, we focused on containerization and Docker support
    on the Windows platform. These concepts were mainly limited to single-machine
    scenarios, where the application requires only one container host. For production-grade
    distributed container systems, you have to consider different aspects, such as
    scalability, high availability, and load balancing, and this always requires orchestrating
    containers running on multiple hosts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们专注于Windows平台上的容器化和Docker支持。这些概念主要局限于单机场景，即应用程序只需要一个容器主机。对于生产级分布式容器系统，您必须考虑不同的方面，如可伸缩性、高可用性和负载平衡，这总是需要对运行在多个主机上的容器进行编排。
- en: '**Container** **orchestration** is a way of managing the container life cycle
    in large, dynamic environments – it ranges from provisioning and deploying containers
    to managing networks, providing redundancy and high-availability of containers,
    automatically scaling up and down container instances, automated health checks,
    and telemetry gathering. Solving the problem of container orchestration is non-trivial
    – this is why **Kubernetes** (k8s for short, where 8 denotes the number of omitted
    characters) was born.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 容器编排是在大型动态环境中管理容器生命周期的一种方式，从提供和部署容器到管理网络、提供容器的冗余和高可用性、自动扩展和缩减容器实例、自动健康检查和遥测收集。解决容器编排问题并不是一件简单的事情，这就是为什么Kubernetes（简称k8s，其中8代表省略的字符数）诞生的原因。
- en: The story of Kubernetes dates back to the early 2000s and the Borg system, which
    was developed internally by Google for managing and scheduling jobs at a large
    scale. Subsequently, in the early 2010s, the Omega cluster management system was
    developed at Google as a clean-slate rewrite of Borg. While Omega was still used
    internally by Google only, in 2014, Kubernetes was announced as an open source
    container orchestration solution that takes its roots from both Borg and Omega.
    In July 2015, when the 1.0 version of Kubernetes was released, Google partnered
    with the Linux Foundation to form the **Cloud Native Computing Foundation** (**CNCF**).
    This foundation aims at empowering organizations so that they can build and run
    scalable applications in modern, dynamic environments such as public, private,
    and hybrid clouds. Four years later, in April 2019, Kubernetes 1.14 was released,
    which delivered production-level support for Windows nodes and Windows containers.
    This chapter is all about the current state of Kubernetes with regard to Windows!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的故事可以追溯到21世纪初的Borg系统，这是谷歌内部开发的用于大规模管理和调度作业的系统。随后，在2010年代初，谷歌开发了Omega集群管理系统，作为对Borg的全新重写。虽然Omega仍然只在谷歌内部使用，但在2014年，Kubernetes作为开源容器编排解决方案宣布推出，它的根源来自Borg和Omega。2015年7月，Kubernetes的1.0版本发布时，谷歌与Linux基金会合作成立了云原生计算基金会（CNCF）。该基金会旨在赋予组织能力，使它们能够在公共、私有和混合云等现代动态环境中构建和运行可扩展的应用程序。四年后的2019年4月，发布了Kubernetes
    1.14版本，为Windows节点和Windows容器提供了生产级支持。本章主要讨论Kubernetes在Windows方面的当前状态！
- en: '**Cloud-native application** is a commonly used term in container orchestration
    for applications that leverage containerization, cloud computing frameworks, and
    the loose coupling of components (microservices). But it doesn''t necessarily
    mean that cloud-native applications must run in a cloud – they adhere to a set
    of principles that make them easy to be hosted on-premises or in the public/private
    cloud. If you are interested in learning more about CNCF, please refer to the
    official web page: [https://www.cncf.io/](https://www.cncf.io/).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**云原生应用**是容器编排中常用的术语，用于指代利用容器化、云计算框架和组件的松耦合（微服务）的应用程序。但这并不一定意味着云原生应用必须在云中运行
    - 它们遵循一组原则，使它们易于在本地或公共/私有云中托管。如果您对了解更多关于CNCF感兴趣，请参考官方网页：[https://www.cncf.io/](https://www.cncf.io/)。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Kubernetes high-level architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes高级架构
- en: Kubernetes objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes对象
- en: Windows and Kubernetes ecosystem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows和Kubernetes生态系统
- en: Kubernetes limitations on Windows
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows上的Kubernetes限制
- en: Creating your own development cluster from scratch
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始创建您自己的开发集群
- en: Production cluster deployment strategies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产集群部署策略
- en: Managed Kubernetes providers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管的Kubernetes提供程序
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，您将需要以下内容：
- en: Windows 10 Pro, Enterprise, or Education (version 1903 or later, 64-bit) installed
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装Windows 10 Pro、企业版或教育版（1903版或更高版本，64位）
- en: Docker Desktop for Windows 2.0.0.3 or later installed
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装Docker Desktop for Windows 2.0.0.3或更高版本
- en: The Chocolatey package manager for Windows installed ([https://chocolatey.org/](https://chocolatey.org/))
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装的Windows Chocolatey软件包管理器（[https://chocolatey.org/](https://chocolatey.org/)）
- en: Azure CLI installed
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装Azure CLI
- en: How to install Docker Desktop for Windows and its system requirements was covered
    in [Chapter 1](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml)*, Creating Containers*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如何安装Docker Desktop for Windows及其系统要求已在[第1章](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml)*，Creating
    Containers*中介绍过。
- en: Using the Chocolatey package manager is not mandatory, but it makes installation
    and application version management much easier. The installation process is documented
    here: [https://chocolatey.org/install](https://chocolatey.org/install).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Chocolatey软件包管理器并非强制，但它可以使安装和应用程序版本管理变得更加容易。安装过程在此处有文档记录：[https://chocolatey.org/install](https://chocolatey.org/install)。
- en: For Azure CLI, you can find detailed installation instructions in [Chapter 2](43d5e48b-311c-462c-a68e-6a0b5c4224e8.xhtml)*, Managing
    State in Containers**.*
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Azure CLI，您可以在[第2章](43d5e48b-311c-462c-a68e-6a0b5c4224e8.xhtml)*，*Managing
    State in Containers**中找到详细的安装说明。
- en: To learn about managed Kubernetes providers, you will need your own Azure account
    in order to create an AKS instance with Windows nodes. If you haven't already
    created an account for the previous chapters in this book, you can read more about
    how to obtain a limited free account for personal use here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解托管的Kubernetes提供程序，您将需要自己的Azure帐户，以便创建具有Windows节点的AKS实例。如果您之前没有为本书的前几章创建帐户，您可以在此处阅读有关如何获取个人使用的有限免费帐户的更多信息：[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)。
- en: You can download the latest code samples for this chapter from this book's official
    GitHub repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter04).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本书的官方GitHub存储库下载本章的最新代码示例：[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter04)。
- en: Kubernetes high-level architecture
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes高级架构
- en: In this and the next section, we will focus on the Kubernetes high-level architecture
    and its core components. If you are already familiar with Kubernetes in general
    but you would like to know more regarding Kubernetes support for Windows, you
    can skip to the *Windows and Kubernetes ecosystem* section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节和下一节中，我们将重点关注Kubernetes的高级架构及其核心组件。如果您已经对Kubernetes有一般了解，但想了解更多关于Kubernetes对Windows的支持，您可以跳到*Windows和Kubernetes生态系统*部分。
- en: What is Kubernetes?
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes是什么？
- en: 'In general, Kubernetes can be seen as the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，Kubernetes可以被看作是以下内容：
- en: A container (microservices) orchestration system
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器（微服务）编排系统
- en: A cluster management system for running distributed applications
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于运行分布式应用程序的集群管理系统
- en: 'As a container orchestrator, Kubernetes solves common challenges that arise
    when deploying containerized, cloud-native applications at scale. This includes
    the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个容器编排器，Kubernetes解决了在大规模部署容器化的云原生应用时出现的常见挑战。这包括以下内容：
- en: Provisioning and deploying containers on multiple container hosts (nodes)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个容器主机（节点）上进行容器的配置和部署
- en: Service discovery and load balancing network traffic
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现和负载均衡网络流量
- en: Automatically scaling container instances up and down
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动扩展容器实例的规模
- en: Automated rollouts and rollbacks of new container image versions
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化部署和回滚新的容器镜像版本
- en: Automatic, optimal bin-packing of containers with regard to resources such as
    CPU or memory
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动的、最佳的容器资源（如CPU或内存）装箱
- en: Application monitoring, telemetry gathering, and health checks
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序监控、遥测收集和健康检查
- en: Orchestrating and abstracting storage (local, on-premises, or the cloud)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编排和抽象存储（本地、本地部署或云端）
- en: At the same time, Kubernetes can also be described as a cluster management system –
    the master (or multiple masters, in highly available deployments) is responsible
    for effectively coordinating multiple worker nodes that handle the actual container
    workloads. These workloads are not limited to Docker containers only – Kubernetes
    uses the **Container Runtime Interface** (**CRI**) on worker nodes to abstract
    container runtimes. Eventually, cluster clients (for example, DevOps engineers)
    can manage the cluster using the RESTful API that's been exposed by the master.
    Cluster management is performed using a declarative model, which makes Kubernetes
    very powerful – you describe the desired state and Kubernetes does all the heavy
    lifting in order to transform thecurrent state of the cluster into the desired
    state.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，Kubernetes也可以被描述为一个集群管理系统 - 主节点（或在高可用部署中的多个主节点）负责有效地协调处理实际容器工作负载的多个工作节点。这些工作负载不仅限于Docker容器
    - Kubernetes在工作节点上使用容器运行时接口（CRI）来抽象容器运行时。最终，集群客户端（例如DevOps工程师）可以使用主节点暴露的RESTful
    API来管理集群。集群管理使用声明式模型进行，这使得Kubernetes非常强大 - 您描述所需的状态，Kubernetes会为了将集群的当前状态转换为所需的状态而进行所有繁重的工作。
- en: Imperative cluster management by using ad hoc commands is also possible but
    it is generally discouraged for production environments. The operations are performed
    directly on a live cluster and there is no history of previous configurations.
    In this book, we will use the declarative object configuration technique whenever
    possible. For a more detailed discussion regarding Kubernetes cluster management
    techniques, please refer to the official documentation: [https://kubernetes.io/docs/concepts/overview/working-with-objects/object-management/](https://kubernetes.io/docs/concepts/overview/working-with-objects/object-management/).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用临时命令进行命令式集群管理也是可能的，但通常不建议用于生产环境。操作是直接在活动集群上执行的，并且没有先前配置的历史记录。在本书中，我们将尽可能使用声明性对象配置技术。有关Kubernetes集群管理技术的更详细讨论，请参阅官方文档：[https://kubernetes.io/docs/concepts/overview/working-with-objects/object-management/](https://kubernetes.io/docs/concepts/overview/working-with-objects/object-management/)。
- en: 'The high-level architecture for Kubernetes can be seen in the following diagram.
    We''ll go through each component in the next few paragraphs:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的高级架构可以在以下图表中看到。我们将在接下来的几段中逐个介绍每个组件：
- en: '![](assets/b69c82e9-b93c-440a-97ba-5e639a928a3e.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b69c82e9-b93c-440a-97ba-5e639a928a3e.png)'
- en: Let's begin by focusing on the role of Kubernetes master, also known as the control
    plane.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先关注Kubernetes主节点，也称为控制平面的角色。
- en: Kubernetes master – control plane
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes主节点-控制平面
- en: In the Kubernetes cluster, the master (control plane) consists of a set of components
    that are responsible for global decisions regarding the cluster, such as scheduling
    and deploying application instances to worker nodes, as well as managing cluster
    events. Additionally, the master exposes an API for communication for both worker
    nodes and managing clients.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes集群中，主节点（控制平面）由一组负责全局决策的组件组成，例如将应用实例调度和部署到工作节点，以及管理集群事件。此外，主节点为工作节点和管理客户端之间的通信公开了API。
- en: Master components are not restricted to running on a dedicated host; it is also possible
    to have them running on worker nodes. The master node can act as a worker node,
    just like any node in a Kubernetes cluster. However, in general, these are not
    recommended due to reliability reasons – what's more, for production environments,
    you should consider running a highly available Kubernetes setup, which requires
    multiple master nodes running components redundantly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 主要组件不限于在专用主机上运行；它也可以在工作节点上运行。主节点可以像Kubernetes集群中的任何节点一样充当工作节点。但是，一般来说，由于可靠性原因，不建议这样做-而且对于生产环境，您应该考虑运行高可用性的Kubernetes设置，这需要多个主节点运行组件冗余。
- en: One of the most significant limitations of running Kubernetes master services
    is that they have to be hosted on a Linux machine. It is not possible to have
    a Windows machine with master components, which means that even if you are planning
    to run Windows containers only, you still need Linux machine(s) as a master. Currently,
    there are no plans for the implementation of Windows-only Kubernetes clusters,
    although this may change as the development of the Windows Subsystem for Linux
    2 progresses.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Kubernetes主服务的最显著限制之一是它们必须托管在Linux机器上。不可能在Windows机器上拥有主组件，这意味着即使您计划仅运行Windows容器，您仍然需要Linux机器作为主机。目前，尚无计划实施仅限Windows的Kubernetes集群，尽管随着Windows子系统的开发进展，情况可能会发生变化。
- en: We will briefly go through the components that compose the master. Let's begin
    by taking a look at the Kubernetes API Server (or `kube-apiserver`, which is the
    binary name of this component).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要介绍组成主节点的组件。让我们首先看一下Kubernetes API服务器（或`kube-apiserver`，这是该组件的二进制名称）。
- en: kube-apiserver
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kube-apiserver
- en: 'The **Kubernetes API Server** (**kube-apiserver**) is the central component
    in the Kubernetes control plane and acts as a gateway for all interactions between
    clients and cluster components. Its main responsibilities are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes API服务器**（**kube-apiserver**）是Kubernetes控制平面中的核心组件，充当客户端和集群组件之间所有交互的网关。其主要职责如下：'
- en: Exposing cluster APIs that have been implemented as a set of RESTful endpoints
    over HTTPS. The API is used by clients managing the cluster as well as by internal
    Kubernetes components. All the resources in the Kubernetes cluster are abstracted
    as Kubernetes API objects.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公开作为一组通过HTTPS的RESTful端点实现的集群API。API由管理集群的客户端以及内部Kubernetes组件使用。Kubernetes集群中的所有资源都被抽象为Kubernetes
    API对象。
- en: Persisting cluster state in the `etcd` cluster – each action performed by a
    client or state update reported by a cluster component has to go through the API
    Server and be persisted in the cluster store.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`etcd`集群中持久化集群状态 - 客户端执行的每个操作或集群组件报告的状态更新都必须通过API服务器并持久化存储在集群中。
- en: Authentication and authorization of users and service accounts.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户和服务账户的认证和授权。
- en: Validation of requests.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求的验证。
- en: Providing the *watch* API to inform subscribers (for example, other cluster
    components) about changes in the cluster state using incremental notification
    feeds. The watch API is the key concept that makes Kubernetes highly extensible
    and distributed in nature.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供*watch* API以通知订阅者（例如其他集群组件）有关集群状态变化的增量通知源。观察API是使Kubernetes高度可扩展和分布式的关键概念。
- en: In highly available Kubernetes deployments, `kube-apiserver` is hosted on multiple
    master nodes, behind a dedicated load balancer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在高可用的Kubernetes部署中，`kube-apiserver`托管在多个主节点上，位于专用负载均衡器后面。
- en: etcd cluster
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: etcd集群
- en: To persist the cluster state, Kubernetes uses `etcd` – a distributed, reliable
    key-value store that utilizes the Raft distributed consensus algorithm in order
    to provide sequential consistency. The `etcd` cluster is the most important part
    of the control plane – this is the source of truth for the whole cluster, both
    for the current state and the desired state of the cluster.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了持久化集群状态，Kubernetes使用`etcd` - 一个分布式、可靠的键值存储，利用Raft分布式一致性算法来提供顺序一致性。`etcd`集群是控制平面中最重要的部分
    - 这是整个集群的真相来源，无论是当前状态还是集群的期望状态。
- en: Generally, single-node `etcd` clusters are only recommended for testing purposes.
    For production scenarios, you should always consider running at least a five-member
    cluster (with an odd number of members) in order to provide sufficient fault tolerance.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，仅建议用于测试目的的单节点`etcd`集群。对于生产场景，您应该始终考虑至少运行一个由五个成员组成的集群（成员数为奇数），以提供足够的容错能力。
- en: 'When choosing an `etcd` cluster deployment topology, you can consider either
    a stacked etcd topology or an external etcd topology. A stacked etcd topology
    consists of one etcd member per Kubernetes master instance, whereas an external
    etcd topology utilizes an etcd cluster deployed separately from Kubernetes and
    is available via a load balancer. You can find out more about these topologies
    in the official documentation: [https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/ha-topology/](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/ha-topology/).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择`etcd`集群部署拓扑时，可以考虑堆叠的etcd拓扑或外部的etcd拓扑。堆叠的etcd拓扑由每个Kubernetes主节点实例的一个etcd成员组成，而外部的etcd拓扑则利用了一个独立于Kubernetes部署的etcd集群，并通过负载均衡器可用。您可以在官方文档中了解更多关于这些拓扑的信息：[https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/ha-topology/](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/ha-topology/)。
- en: The *watch* protocol that's exposed by `etcd` is also a core functionality for
    the watch API in Kubernetes, which is provided by `kube-apiserver` for other components.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`etcd`公开的*watch*协议也是Kubernetes中watch API的核心功能，由`kube-apiserver`为其他组件提供。'
- en: kube-scheduler
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kube-scheduler
- en: The main responsibility of the **Kubernetes Scheduler** (**kube-scheduler**)
    component is scheduling container workloads (Kubernetes Pods) and assigning them
    to healthy worker nodes that fulfill the criteria required for running a particular
    workload.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes Scheduler**（**kube-scheduler**）组件的主要责任是调度容器工作负载（Kubernetes Pods）并将它们分配给满足运行特定工作负载所需条件的健康工作节点。'
- en: A **Pod** is a group of one or more containers with a shared network and storage
    and is the smallest Deployment unit in the Kubernetes system. We will cover this
    Kubernetes object in the next section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Pod是Kubernetes系统中最小的部署单元，是一个或多个具有共享网络和存储的容器组。我们将在下一节中介绍这个Kubernetes对象。
- en: 'Scheduling is performed in two phases:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 调度分为两个阶段：
- en: Filtering
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤
- en: Scoring
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评分
- en: In the filtering phase, `kube-scheduler` determines the set of nodes that are
    capable of running a given Pod. This includes checking the actual state of nodes
    and verifying any resource requirements specified by the Pod definition. At this
    point, if there are no nodes that can run a given Pod, the Pod cannot be scheduled
    and remains pending. Next, in the scoring step, the scheduler assigns scores for
    each node based on a set of policies. Then, the Pod is assigned by the scheduler
    to the node with the highest score.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在过滤阶段，`kube-scheduler`确定能够运行给定Pod的节点集。这包括检查节点的实际状态，并验证Pod定义中指定的任何资源要求。在这一点上，如果没有节点可以运行给定的Pod，那么Pod将无法调度并保持挂起状态。接下来，在评分步骤中，调度程序根据一组策略为每个节点分配分数。然后，调度程序将Pod分配给具有最高分数的节点。
- en: You can read more about available policies in the official documentation: [https://kubernetes.io/docs/concepts/scheduling/kube-scheduler/#kube-scheduler-implementation](https://kubernetes.io/docs/concepts/scheduling/kube-scheduler/#kube-scheduler-implementation).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中了解更多有关可用策略的信息：[https://kubernetes.io/docs/concepts/scheduling/kube-scheduler/#kube-scheduler-implementation](https://kubernetes.io/docs/concepts/scheduling/kube-scheduler/#kube-scheduler-implementation)。
- en: Kubernetes design offers a great deal of extensibility and possibility to replace
    components. Kube-scheduler is one of the components that's used to demonstrate
    this principle. Even if its internal business logic is complex (all efficient
    scheduling heuristics are rather complex...), the scheduler only needs to watch
    for *unassigned* Pods, determine the best node for them, and inform the API Server
    about the assignment. You can check out an example implementation of a custom
    scheduler here: [https://banzaicloud.com/blog/k8s-custom-scheduler/](https://banzaicloud.com/blog/k8s-custom-scheduler/).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes设计提供了很大的可扩展性和替换组件的可能性。Kube-scheduler是用来演示这一原则的组件之一。即使其内部业务逻辑很复杂（所有高效的调度启发式算法都相当复杂...），调度程序只需要监视*未分配*的Pod，确定最适合它们的节点，并通知API服务器进行分配。您可以在这里查看自定义调度程序的示例实现：[https://banzaicloud.com/blog/k8s-custom-scheduler/](https://banzaicloud.com/blog/k8s-custom-scheduler/)。
- en: Now, let's take a look at `kube-controller-manager`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看`kube-controller-manager`。
- en: kube-controller-manager
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kube-controller-manager
- en: The **Kubernetes Controller Manager** (**kube-controller-manager**) is a component
    that is responsible for running core reconciliation and control loops in the cluster.
    The Controller Manager consists of a set of separate, specialized controllers
    that act independently. The main aim of controllers is to observe the *current*
    and the *desired* cluster state that's exposed by API Server and command changes
    that attempt to transform the *current* state to the *desired* one.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes Controller Manager**（**kube-controller-manager**）是负责在集群中运行核心协调和控制循环的组件。控制器管理器由一组独立的专门控制器组成。控制器的主要目的是观察API服务器公开的*当前*和*期望*集群状态，并命令试图将*当前*状态转换为*期望*状态的变化。'
- en: 'The most important controllers that are shipped in `kube-controller-manager`
    binary are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`kube-controller-manager`二进制文件中提供的最重要的控制器如下：'
- en: '**Node** **Controller (formally named nodelifecycle)**: This observes the status
    of the node and reacts when it is unavailable.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node Controller（以前称为nodelifecycle）**：观察节点的状态，并在节点不可用时做出反应。'
- en: '**ReplicaSet Controller (replicaset)**: This is responsible for ensuring that
    the correct number of Pods for each ReplicaSet API object is running.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ReplicaSet Controller（replicaset）**：负责确保每个ReplicaSet API对象运行正确数量的Pod。'
- en: '**Deployment Controller (deployment)**: This is responsible for managing associated
    ReplicaSet API objects and performing rollouts and rollbacks.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Deployment Controller（deployment）**：负责管理关联的ReplicaSet API对象并执行部署和回滚。'
- en: '**Endpoints Controller (endpoint)**: This manages Endpoint API objects.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Endpoints Controller（endpoint）**：管理Endpoint API对象。'
- en: '**Service Account Controller (serviceaccount) and Token Controller (serviceaccount-token)**:
    This is responsible for creating default accounts and access tokens for new namespaces.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Service Account Controller（serviceaccount）和Token Controller（serviceaccount-token）**：负责为新命名空间创建默认帐户和访问令牌。'
- en: You can think of kube-controller-manager as a Kubernetes brain that ensures
    that the *current* state of the cluster moves toward the *desired* cluster state.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将kube-controller-manager视为确保集群的*当前*状态朝向*期望*集群状态移动的Kubernetes大脑。
- en: cloud-controller-manager
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cloud-controller-manager
- en: Originally a part of `kube-controller-manager`, the **Kubernetes Cloud Controller
    Manager** (**cloud-controller-manager**) provides cloud-specific control loops.
    The reason for the separation of Cloud Controller Manager is to allow for the
    easier evolution of cloud-specific connectors (providers) code, which in most
    cases, is released at different cadences than the core Kubernetes code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最初是`kube-controller-manager`的一部分，**Kubernetes Cloud Controller Manager**（**cloud-controller-manager**）提供特定于云的控制循环。分离云控制器管理器的原因是为了更容易地发展特定于云的连接器（提供商）代码，这些代码在大多数情况下以不同的节奏发布。
- en: As of Kubernetes 1.17, cloud-controller-manager is still in its beta stage.
    You can check the current status of the feature in the official documentation: [https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller](https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 截至Kubernetes 1.17，cloud-controller-manager仍处于测试阶段。您可以在官方文档中检查该功能的当前状态：[https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller](https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller)。
- en: 'When enabling cloud-controller-manager, the cloud-specific control loops in
    kube-controller-manager must be disabled. Then, the following controllers will
    depend on the cloud provider''s implementation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 启用云控制器管理器时，必须禁用kube-controller-manager中的特定于云的控制循环。然后，以下控制器将依赖于云提供商的实现：
- en: '**Node Controller**: The provider is used for determining a node''s status
    and detecting if the node was deleted.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node Controller**：用于确定节点的状态并检测节点是否已删除。'
- en: '**Route Controller**: Requires the provider for setting up network routing.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由控制器：需要提供者来设置网络路由。
- en: '**Service Controller**: Manages load balancers via the provider.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务控制器：通过提供者管理负载均衡器。
- en: 'V**olume Controller**: Manages storage volumes using the provider.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷控制器：使用提供者管理存储卷。
- en: The list of external cloud providers offered as a part of Kubernetes constantly
    evolves and can be checked in the official documentation ([https://kubernetes.io/docs/concepts/cluster-administration/cloud-providers/](https://kubernetes.io/docs/concepts/cluster-administration/cloud-providers/))
    and on Kubernetes' organization GitHub page ([https://github.com/kubernetes?q=cloud-provider-&type=&language=](https://github.com/kubernetes?q=cloud-provider-&type=&language=)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Kubernetes的一部分提供的外部云提供者的列表不断发展，并且可以在官方文档（[https://kubernetes.io/docs/concepts/cluster-administration/cloud-providers/](https://kubernetes.io/docs/concepts/cluster-administration/cloud-providers/)）和Kubernetes的组织GitHub页面（[https://github.com/kubernetes?q=cloud-provider-&type=&language=](https://github.com/kubernetes?q=cloud-provider-&type=&language=)）上进行检查。
- en: Kubernetes nodes – data plane
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes节点 - 数据平面
- en: In the Kubernetes cluster, the data plane consists of nodes (formerly known
    as *minions*) that are responsible for running container workloads scheduled by
    the master. Nodes can be physical bare-metal machines or virtual machines, which
    gives flexibility when designing a cluster.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes集群中，数据平面由负责运行主控安排的容器工作负载的节点（以前称为*minions*）组成。节点可以是物理裸金属机器或虚拟机器，这在设计集群时提供了灵活性。
- en: 'The following diagram summarizes the architecture and components that compose
    Kubernetes nodes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了组成Kubernetes节点的架构和组件：
- en: '![](assets/d035407d-e290-4389-a794-5f072d975582.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d035407d-e290-4389-a794-5f072d975582.png)'
- en: In terms of Windows support, all node components can run both on Windows and
    Linux machines. This means that Windows Kubernetes nodes are visible to the master
    in the same way as Linux nodes and from this perspective, they only differ by
    the type of containers that they can support.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows支持方面，所有节点组件都可以在Windows和Linux机器上运行。这意味着Windows Kubernetes节点在与Linux节点相同的方式下对主控可见，并且从这个角度来看，它们只在它们可以支持的容器类型上有所不同。
- en: 'The main components of Kubernetes nodes are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes节点的主要组件如下：
- en: '**kubelet**: The main Kubernetes agent, which ensures that container workloads
    (Pods) are executed on the node.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubelet：主要的Kubernetes代理，负责确保容器工作负载（Pods）在节点上执行。
- en: '**Container runtime**: The software that''s responsible for managing containers.
    It''s abstracted by the **Container Runtime Interface** (**CRI**).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器运行时：负责管理容器的软件。它由容器运行时接口（CRI）抽象出来。
- en: '**kube-proxy**: The network proxy that''s responsible for managing the local
    node network.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kube-proxy：负责管理本地节点网络的网络代理。
- en: Let's take a look at `kubelet` first.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来看看`kubelet`。
- en: kubelet
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kubelet
- en: 'Running on every node in the cluster, `kubelet` is a service that''s responsible
    for ensuring that container workloads (Pods) that have been assigned by the control
    plane are executed. Additionally, it is also responsible for the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群中的每个节点上运行，`kubelet`是一个负责确保控制平面分配的容器工作负载（Pods）得到执行的服务。此外，它还负责以下工作：
- en: Reporting node and Pods statuses to the API Server
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告节点和Pods状态给API服务器
- en: Reporting resource utilization
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告资源利用情况
- en: Performing the node registration process (when joining a new node to the cluster)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行节点注册过程（加入新节点到集群时）
- en: Executing liveness and readiness Probes (health checks) and reporting their
    status to the API Server
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行活跃性和就绪性探针（健康检查）并将其状态报告给API服务器
- en: To perform actual container-related operations, kubelet uses a container runtime.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为执行实际的与容器相关的操作，kubelet使用容器运行时。
- en: Container runtime
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器运行时
- en: Kubelet is not directly coupled with Docker – in fact, as we mentioned in the
    introduction to this section, Docker is not the only **container runtime** that
    Kubernetes supports. To perform container-related tasks, for example, pulling
    an image or creating a new container, kubelet utilizes the **Container Runtime
    Interface** (**CRI**), which is a plugin interface that abstracts all common container
    operations for different runtimes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Kubelet并不直接与Docker耦合 - 实际上，正如我们在本节介绍中提到的，Docker并不是Kubernetes支持的唯一**容器运行时**。为了执行与容器相关的任务，例如拉取镜像或创建新容器，kubelet利用**容器运行时接口**（CRI），这是一个为不同运行时抽象所有常见容器操作的插件接口。
- en: The actual definition of the Container Runtime Interface is a protobuf API specification,
    which can be found in the official repository: [https://github.com/kubernetes/cri-api/](https://github.com/kubernetes/cri-api/).
    Any container runtime that implements this specification can be used to execute
    container workloads in Kubernetes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时接口的实际定义是一个protobuf API规范，可以在官方存储库中找到：[https://github.com/kubernetes/cri-api/](https://github.com/kubernetes/cri-api/)。任何实现此规范的容器运行时都可以用于在Kubernetes中执行容器工作负载。
- en: 'Currently, there are numerous container runtimes that can be used with Kubernetes
    on Linux. The most popular are as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在Linux上可以与Kubernetes一起使用的容器运行时有很多。最流行的如下：
- en: '**Docker**: The *traditional* Docker runtime, abstracted by `dockershim`, which
    is the CRI implementation for `kubelet`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：由`dockershim`抽象出的*传统* Docker运行时，这是`kubelet`的CRI实现。'
- en: '**CRI-containerd**: In short, `containerd` is a component of Docker that is
    responsible for the management of containers. Currently, CRI-containerd is the
    recommended runtime for Kubernetes on Linux. For more information, please visit [https://containerd.io/](https://containerd.io/).'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CRI-containerd**：简而言之，`containerd`是Docker的一个组件，负责容器的管理。目前，CRI-containerd是Linux上Kubernetes的推荐运行时。更多信息，请访问[https://containerd.io/](https://containerd.io/)。'
- en: '**CRI-O**: The container runtime implementation dedicated to CRI that follows
    the **Open Containers Initiative** (**OCI**) specification. For more information,
    please visit [https://cri-o.io/](https://cri-o.io/).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CRI-O**：专门用于CRI的容器运行时实现，遵循**Open Containers Initiative**（OCI）规范。更多信息，请访问[https://cri-o.io/](https://cri-o.io/)。'
- en: '**gVisor**: The OCI-compatible sandbox runtime for containers that''s integrated
    with Docker and containerd. For more information, please visit [https://gvisor.dev/](https://gvisor.dev/).'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gVisor**：与Docker和containerd集成的符合OCI标准的容器沙箱运行时。更多信息，请访问[https://gvisor.dev/](https://gvisor.dev/)。'
- en: 'The difference between dockershim and CRI-containerd can be seen in the following
    diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: dockershim和CRI-containerd之间的区别可以在下图中看到：
- en: '![](assets/319c91e3-e62c-451e-90f5-5d6929202701.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/319c91e3-e62c-451e-90f5-5d6929202701.png)'
- en: The CRI-containerd runtime offers a much simpler architecture with less communication
    between daemons and processes, thereby eliminating the traditional Docker Engine.
    This solution aims at providing a *stripped down* Docker runtime that exposes
    the crucial components for Kubernetes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: CRI-containerd运行时提供了一个更简单的架构，守护程序和进程之间的通信更少，从而消除了传统的Docker引擎。这个解决方案旨在提供一个裁剪版的Docker运行时，暴露出关键的组件供Kubernetes使用。
- en: If you are interested in getting a more historical context regarding Docker
    and containerd separation, you can read the following article: [http://alexander.holbreich.org/docker-components-explained/](http://alexander.holbreich.org/docker-components-explained/).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对Docker和containerd分离的历史背景感兴趣，可以阅读以下文章：[http://alexander.holbreich.org/docker-components-explained/](http://alexander.holbreich.org/docker-components-explained/)。
- en: For Windows, the list is much shorter, and currently includes Docker (Enterprise
    Edition 18.09+, also abstracted by dockershim) and incoming support for CRI-containerd.
    This is expected to be available when a stable version of containerd, 1.3, is
    released and *runhcs shim* is fully supported. This will also come with new support
    for Hyper-V isolation for containers, which is currently (as of Kubernetes 1.17)
    implemented without CRI-containerd as a limited experimental feature.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，支持的列表要短得多，目前包括 Docker（企业版 18.09+，也由 dockershim 抽象）和即将支持的 CRI-containerd。预计当
    containerd 1.3 的稳定版本发布并且 *runhcs shim* 得到全面支持时，这将可用。这还将带来对容器的 Hyper-V 隔离的新支持，目前（截至
    Kubernetes 1.17）作为有限的实验性功能实现，没有使用 CRI-containerd。
- en: kube-proxy
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kube-proxy
- en: In the Kubernetes cluster, networking rules and routes on nodes are managed
    by kube-proxy,which runs on every node. These rules allow communication between
    Pods and external clients to Pods and are a vital part of the Service API Object.
    On the Linux platform, kube-proxy configures rules using iptables (most commonly),
    whereas on the Windows platform, the **Host Networking Service** (**HNS**) is
    used.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 集群中，节点上的网络规则和路由由运行在每个节点上的 kube-proxy 管理。这些规则允许 Pod 与外部客户端之间进行通信，并且是
    Service API 对象的重要组成部分。在 Linux 平台上，kube-proxy 使用 iptables 配置规则（最常见），而在 Windows
    平台上，使用 **Host Networking Service** (**HNS**)。
- en: We will cover Kubernetes networking in more detail in the next chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章更详细地介绍 Kubernetes 网络。
- en: DNS
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS
- en: An internal DNS server is optional and can be installed as an add-on, but it
    is highly recommended in standard deployments as it simplifies service discovery
    and networking. Currently, the default DNS server used by Kubernetes is CoreDNS
    ([https://coredns.io/](https://coredns.io/)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 内部 DNS 服务器是可选的，并且可以作为附加组件安装，但在标准部署中强烈建议使用，因为它简化了服务发现和网络。目前，Kubernetes 使用的默认
    DNS 服务器是 CoreDNS（[https://coredns.io/](https://coredns.io/)）。
- en: Kubernetes automatically adds an internal static IP address of the DNS server
    to the domain name resolution configuration for each container. This means that
    processes running in Pods can communicate with Services and Pods running in the
    cluster just by knowing their domain name, which will be resolved to the actual
    internal IP address. The concept of Kubernetes Service objects will be covered
    in the next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 会自动为每个容器的域名解析配置添加一个内部静态 IP 地址的 DNS 服务器。这意味着在 Pod 中运行的进程可以通过知道它们的域名与集群中运行的服务和
    Pod 进行通信，这些域名将解析为实际的内部 IP 地址。Kubernetes Service 对象的概念将在下一节中介绍。
- en: Now, let's take a look at the most commonly used Kubernetes objects.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下最常用的 Kubernetes 对象。
- en: Kubernetes objects
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 对象
- en: Setting up a Kubernetes cluster with Windows nodes is complex and will be covered
    later in this book, and the principles will be demonstrated on Linux examples.
    From a Kubernetes API Server perspective, Windows and Linux nodes operate in almost
    the same way.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分将介绍在 Windows 节点上设置 Kubernetes 集群的复杂性，并且将在 Linux 示例上演示原则。从 Kubernetes
    API 服务器的角度来看，Windows 和 Linux 节点的操作方式几乎相同。
- en: In the Kubernetes cluster, the cluster state is managed by the kube-apiserver
    component and is persisted in the `etcd` cluster. The state is abstracted and
    modeled as a set of Kubernetes objects – these entities describe what containerized
    applications should be run, how they should be scheduled, and are the policies
    concerning restarting or scaling them. If there is anything you would like to
    achieve in your Kubernetes cluster, then you have to create or update Kubernetes
    objects. This type of model is called a **declarative model** – you declare your intent
    and Kubernetes is responsible for changing the current state of the cluster to
    the desired (intended) one. The declarative model and the idea of maintaining
    the desired state is what makes Kubernetes so powerful and easy to use.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes集群中，集群状态由kube-apiserver组件管理，并持久存储在`etcd`集群中。状态被抽象和建模为一组Kubernetes对象
    - 这些实体描述了应该运行什么容器化应用程序，它们应该如何被调度，以及关于重新启动或扩展它们的策略。如果您想在Kubernetes集群中实现任何目标，那么您必须创建或更新Kubernetes对象。这种模型称为**声明性模型**
    - 您声明您的意图，Kubernetes负责将集群的当前状态更改为期望的（预期的）状态。声明性模型和保持期望状态的理念是使Kubernetes如此强大和易于使用的原因。
- en: In this book, we will follow the convention from the official documentation,
    where objects are capitalized; for example, Pod or Service.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将遵循官方文档的惯例，其中对象是大写的；例如，Pod或Service。
- en: 'The anatomy of each Kubernetes Object is exactly the same; it has two fields:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Kubernetes对象的解剖结构完全相同；它有两个字段：
- en: '**Spec**: This defines the *desired state* of the Object. This is where you
    define your requirements when creating or updating an Object.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spec**：这定义了对象的*期望状态*。这是您在创建或更新对象时定义要求的地方。'
- en: '**Status**: This is provided by Kubernetes and describes the *current state*
    of the Object.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Status**：这是由Kubernetes提供的，并描述了对象的*当前状态*。'
- en: Working with Kubernetes objects always requires using the Kubernetes API. Most
    commonly, you will manage Kubernetes objects using the **command-line interface**
    (**CLI**) for Kubernetes, which comes as a `kubectl` binary. It is also possible
    to interact with the Kubernetes API directly using client libraries.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 始终需要使用Kubernetes API来处理Kubernetes对象。最常见的情况是使用Kubernetes的**命令行接口**（CLI）来管理Kubernetes对象，该接口以`kubectl`二进制文件的形式提供。还可以使用客户端库直接与Kubernetes
    API进行交互。
- en: The installation of `kubectl` and examples of its usage will be covered in [Chapter
    6](791e78c0-f625-4232-9907-36e25ec2767d.xhtml), *Interacting with Kubernetes Clusters*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`的安装和其用法示例将在[第6章](791e78c0-f625-4232-9907-36e25ec2767d.xhtml)中进行介绍，*与Kubernetes集群交互*。'
- en: 'Now, let''s take a quick look at how an example Kubernetes Object is structured.
    When interacting directly with the Kubernetes API, objects must be specified in
    JSON format. However, `kubectl` allows us to use YAML manifest files, which are
    translated into JSON when you perform operations. Using YAML manifest files is
    generally recommended and you can expect most of the examples that you find in
    the documentation to follow this convention. As an example, we will use a definition
    of a Pod that consists of a single nginx web server Linux container, stored in
    a file called `nginx.yaml`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速看一下示例Kubernetes对象的结构。当直接与Kubernetes API交互时，对象必须以JSON格式指定。然而，`kubectl`允许我们使用YAML清单文件，在执行操作时将其转换为JSON。通常建议使用YAML清单文件，并且您可以期望在文档中找到的大多数示例都遵循这个惯例。例如，我们将使用一个包含单个nginx
    web服务器Linux容器定义的Pod的定义，存储在名为`nginx.yaml`的文件中。
- en: '[PRE0]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The required parts in the manifest file are as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 清单文件中的必需部分如下：
- en: '`apiVersion`: The version of the Kubernetes API being used for this Object.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiVersion`：用于此对象的Kubernetes API的版本。'
- en: '`kind`: The type of Kubernetes Object. In this case, this is `Pod`.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`：Kubernetes对象的类型。在这种情况下，这是`Pod`。'
- en: '`metadata`: Additional metadata for the Object.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`：对象的附加元数据。'
- en: '`spec`: The Object Spec. In the example specification, the nginx container
    uses the `nginx:1.17` Docker image and exposes port `80`. The Spec is different
    for every Kubernetes Object and has to follow the API documentation. For example,
    for Pod, you can find the API reference here: [https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.17/#podspec-v1-core](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.17/#podspec-v1-core).'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec`：对象规范。在示例规范中，nginx容器使用`nginx:1.17` Docker镜像并暴露端口`80`。每个Kubernetes对象的规范都不同，并且必须遵循API文档。例如，对于Pod，您可以在这里找到API参考：[https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.17/#podspec-v1-core](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.17/#podspec-v1-core)。'
- en: 'Creating the Pod is now as simple as running the following `kubectl apply`
    command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建Pod就像运行以下`kubectl apply`命令一样简单：
- en: '[PRE1]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you would like to try out this command without a local Kubernetes cluster,
    we recommend using one for Kubernetes playground; for example, [https://www.katacoda.com/courses/kubernetes/playground](https://www.katacoda.com/courses/kubernetes/playground):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想尝试此命令而没有本地Kubernetes集群，我们建议使用Kubernetes playground中的一个；例如，[https://www.katacoda.com/courses/kubernetes/playground](https://www.katacoda.com/courses/kubernetes/playground)：
- en: 'In the master window, run the following `kubectl` command, which will apply
    a manifest file hosted on GitHub:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主窗口中运行以下`kubectl`命令，它将应用托管在GitHub上的清单文件：
- en: '[PRE2]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After a few seconds, the Pod will be created and its `STATUS` should be `Running`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，Pod将被创建，其`STATUS`应为`Running`：
- en: '[PRE3]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use the `curl` command in the master window to get the Pod''s IP (in this case, `10.40.0.1`)
    to verify that the container is indeed running. You should see the raw contents
    of the default nginx web page:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主窗口中使用`curl`命令获取Pod的IP（在本例中为`10.40.0.1`）以验证容器是否确实在运行。您应该看到默认nginx网页的原始内容：
- en: '[PRE4]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`kubectl` currently offers two declarative approaches for managing Kubernetes
    objects: manifest files and kustomization files. Using the kustomize approach
    is much more powerful as it organizes manifest files and configuration generation
    in a predictable structure. You can learn more about kustomize here: [https://github.com/kubernetes-sigs/kustomize/tree/master/docs](https://github.com/kubernetes-sigs/kustomize/tree/master/docs).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`目前提供了两种声明性方法来管理Kubernetes对象：清单文件和kustomization文件。使用kustomize方法更加强大，因为它以可预测的结构组织清单文件和配置生成。您可以在这里了解更多关于kustomize的信息：[https://github.com/kubernetes-sigs/kustomize/tree/master/docs](https://github.com/kubernetes-sigs/kustomize/tree/master/docs)。'
- en: Now, let's take a closer look at the Pod API Object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看一下Pod API对象。
- en: Pods
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pods
- en: 'Kubernetes uses Pods as its basic, atomic unit for Deployment and scaling,
    and represents processes running in the cluster – an analogy from Microsoft Hyper-V
    would be a single virtual machine that you deploy as an atomic unit in your Hyper-V
    cluster. A Kubernetes Pod consists of one or more containers that share kernel
    namespaces, IPC, network stack (you address them by the same cluster IP and they
    can communicate via localhost), and storage. To understand Pods, it is good to
    know the origin of the name: in the English language, a pod is a group of whales,
    and Docker uses a whale for its logo – think of a whale as a Docker container!'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用Pod作为部署和扩展的基本原子单位，并代表集群中运行的进程 - 从Microsoft Hyper-V的类比来说，就像是在Hyper-V集群中部署的单个虚拟机。Kubernetes
    Pod由一个或多个共享内核命名空间、IPC、网络堆栈（您可以通过相同的集群IP地址对其进行寻址，并且它们可以通过localhost进行通信）和存储的容器组成。要理解Pod，了解名称的起源是很有帮助的：在英语中，pod是一群鲸鱼，而Docker使用鲸鱼作为其标志
    - 将鲸鱼想象成Docker容器！
- en: 'In their simplest form, you can create single-container Pods – this is what
    we did in the introduction to this section when demonstrating nginx Pod creation.
    For some scenarios, you may need multiple-container Pods, where the main container
    is accompanied by additional containers that serve multiple purposes. Let''s take
    a look at a few of these:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，你可以创建单容器Pod - 这就是我们在本节介绍中演示nginx Pod创建时所做的。对于某些情况，你可能需要多容器Pod，其中主容器伴随着其他容器，用于多种目的。让我们来看看其中一些：
- en: '**Sidecar** **containers**, which can perform various *helper* operations,
    such as log collection, data synchronization for the main container, and so on.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**辅助** **容器**，可以执行各种*辅助*操作，比如日志收集，为主容器进行数据同步等。'
- en: '**Adapter** **containers**, which can normalize output or monitor the data
    of the main container so that it can be used by other services.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适配器** **容器**，可以规范输出或监视主容器的数据，以便其他服务可以使用。'
- en: '**Ambassador** **containers**, which proxy the communication of the main container
    with the outside world.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大使** **容器**，代理主容器与外部世界的通信。'
- en: '**Init** **containers**, which are specialized containers that run before application
    containers in the Pod. For example, they may set up the environment, which isn''t
    performed in the main container image.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化** **容器**，这些是在Pod中的应用容器之前运行的专门容器。例如，它们可以设置环境，这在主容器镜像中没有执行。'
- en: 'Technically, even single-container Pods contain an extra infra container, which
    is often a pause image. It acts as a *parent* container for all containers in
    the pod and enables kernel namespaces sharing. If you are interested in more details
    regarding infra containers, please refer to this article: [https://www.ianlewis.org/en/almighty-pause-container](https://www.ianlewis.org/en/almighty-pause-container).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，即使是单容器Pod也包含一个额外的基础设施容器，通常是一个暂停镜像。它充当了Pod中所有容器的*父*容器，并启用了内核命名空间共享。如果你对基础设施容器的更多细节感兴趣，请参考这篇文章：[https://www.ianlewis.org/en/almighty-pause-container](https://www.ianlewis.org/en/almighty-pause-container)。
- en: 'The concept of a Pod can be seen in the following diagram:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Pod的概念可以在以下图表中看到：
- en: '![](assets/bb6c0115-edb1-429f-ac9c-f3614a78d1c9.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bb6c0115-edb1-429f-ac9c-f3614a78d1c9.png)'
- en: 'There are a couple of considerations that you should keep in mind when using
    Pods:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Pod时，有一些考虑事项需要牢记在心：
- en: Pod's containers always run on one node and once a Pod is created, it is always
    bound to one node.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod的容器始终在一个节点上运行，一旦Pod被创建，它就始终绑定到一个节点上。
- en: You scale your application by adding more Pods, not by adding more containers
    inside the same Pod.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过增加更多的Pod来扩展你的应用，而不是在同一个Pod中增加更多的容器。
- en: A Pod is considered *ready* and able to serve requests when *all* its containers
    are ready. The status of a container is determined by Probes, for example, liveness
    and readiness Probes, which can be defined in the Spec.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod被认为是*就绪*并且能够响应请求时，*所有*它的容器都是就绪的。容器的状态由探针来确定，例如存活和就绪探针，这些可以在规范中定义。
- en: Pods are ephemeral. They are created, they die, and new ones are recreated in
    their place (if needed).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod是短暂的。它们被创建，它们死亡，如果需要的话，新的Pod会被重新创建。
- en: When a Pod is recreated, it receives a new cluster IP. This means that your
    application design should never rely on static IP assignments and assume that
    the Pod may even be recreated on a different node.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Pod被重新创建时，它会获得一个新的集群IP。这意味着你的应用设计不应该依赖静态IP分配，并且假设Pod甚至可能在不同的节点上重新创建。
- en: You will rarely create bare Pods independently, as we did in the introduction
    to the section. In most cases, they are managed through Deployments.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你很少会像我们在本节介绍中那样独立创建裸Pod。在大多数情况下，它们是通过部署进行管理的。
- en: Pods have a finite life cycle and if the containers inside crash or exit, they
    may not be automatically recreated, depending on the restart policy. To maintain
    a desired number of Pods with a certain Spec and metadata in the cluster, you
    need `ReplicaSet` objects.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Pod具有有限的生命周期，如果容器内部崩溃或退出，根据重启策略，它们可能不会自动重新创建。为了在集群中保持一定数量的具有特定Spec和元数据的Pod，您需要`ReplicaSet`对象。
- en: ReplicaSets
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 副本集
- en: Kubernetes builds many powerful concepts on top of Pods, which makes container
    management easy and predictable. The simplest one is the `ReplicaSet`API Object (the
    successor of ReplicationController), which aims at maintaining a fixed number
    of healthy Pods (replicas) to fulfill certain conditions. In other words, if you
    say *I want three nginx Pods running in my cluster*, ReplicaSet does that for
    you. If a Pod is destroyed, `ReplicaSet` will automatically create a new Pod replica
    to restore the desired state.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes在Pod的基础上构建了许多强大的概念，使容器管理变得简单和可预测。最简单的概念是`ReplicaSet`API对象（ReplicationController的后继者），其目的是维护一定数量的健康Pod（副本）以满足特定条件。换句话说，如果您说“我希望在我的集群中运行三个nginx
    Pod”，ReplicaSet会为您完成。如果一个Pod被销毁，`ReplicaSet`将自动创建一个新的Pod副本以恢复所需状态。
- en: 'Let''s look at an example ReplicaSet manifest `nginx-replicaset.yaml` file
    that creates three replicas of the nginx Pod:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例ReplicaSet清单`nginx-replicaset.yaml`文件，创建三个nginx Pod的副本：
- en: '[PRE5]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are three main components of the `ReplicaSet` Spec:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReplicaSet` Spec有三个主要组件：'
- en: '`replicas`: Defines the number of Pod replicas that should run using the given
    `template` and matching `selector`. Pods may be created or deleted in order to
    maintain the required number.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replicas`：定义应使用给定的`template`和匹配的`selector`运行的Pod副本的数量。为了保持所需的数量，可能会创建或删除Pod。'
- en: '`selector`: A label selector, which defines how to identify Pods that the ReplicaSet
    will acquire. Note that this may have a consequence of acquiring existing bare
    Pods by `ReplicaSet`!'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selector`：标签选择器，定义了如何识别ReplicaSet将获取的Pod。请注意，这可能会导致`ReplicaSet`获取现有的裸Pod！'
- en: '`template`: Defines the template for Pod creation. Labels used in metadata
    must positively match the `selector`.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`：定义Pod创建的模板。元数据中使用的标签必须与`selector`正向匹配。'
- en: 'You can apply the `ReplicaSet` manifest in a similar manner to how we applied
    a Pod in the Katacoda playground:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以类似的方式应用`ReplicaSet`清单，就像我们在Katacoda游乐场中应用Pod一样：
- en: '[PRE6]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can observe how three Pod replicas are created using the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令观察如何创建三个Pod副本：
- en: '[PRE7]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'ReplicaSets mark the newly created or acquired Pods by assigning themselves
    to the `.metadata.ownerReferences` property of the Pod (if you are curious, you
    can check by using the `kubectl get pod <podId> -o yaml` command). This means
    that if you create exactly the same ReplicaSet, with exactly the same selectors
    but with a different name, for example, `nginx-replicaset-example2`, they will
    not *steal* Pods from each other. However, if you have already created bare Pods
    with matching labels, such as `environment: test`, the ReplicaSet will acquire
    them and may even delete the Pods if the number of replicas is too high!'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'ReplicaSets通过将新创建或获取的Pod分配给Pod的`.metadata.ownerReferences`属性来标记它们自己（如果您感兴趣，可以使用`kubectl
    get pod <podId> -o yaml`命令进行检查）。这意味着，如果您创建完全相同的ReplicaSet，具有完全相同的选择器但名称不同，例如`nginx-replicaset-example2`，它们不会*窃取*彼此的Pod。但是，如果您已经创建了具有匹配标签的裸Pod，例如`environment:
    test`，ReplicaSet将获取它们，甚至可能删除Pod，如果副本的数量太高！'
- en: If you really need to create a single Pod in Kubernetes cluster, it is a much
    better idea to use a `ReplicaSet` with the `replicas` field set to 1, which will
    act as a container *supervisor*. In this manner, you will prevent the creation
    of bare Pods without owners that are tied to the original node only.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的需要在Kubernetes集群中创建单个Pod，最好使用`ReplicaSet`，将`replicas`字段设置为1，这将充当容器的*监督者*。通过这种方式，您将防止创建没有所有者且仅与原始节点绑定的裸Pods。
- en: 'This can be seen in the following diagram:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在以下图表中看到：
- en: '![](assets/4a6bf410-9102-4124-9fc9-1ac27d4ef670.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4a6bf410-9102-4124-9fc9-1ac27d4ef670.png)'
- en: 'Usually, you don''t create ReplicaSets on your own as they are not capable
    of performing rolling updates or rolling back to earlier versions easily. To facilitate
    such scenarios, Kubernetes provides objects built on top of ReplicaSets: Deployment
    and StatefulSet. Let''s take a look at Deployment first.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您不会自行创建ReplicaSets，因为它们无法轻松执行滚动更新或回滚到早期版本。为了促进这种情况，Kubernetes提供了建立在ReplicaSets之上的对象：部署和StatefulSet。让我们先看一下部署。
- en: Deployments
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署
- en: 'At this point, you already know the purpose of Pods and ReplicaSets. Deployments
    are Kubernetes objects that provide declarative updates for Pods and ReplicaSets.
    You can declaratively perform operations such as the following by using them:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您已经知道了Pods和ReplicaSets的目的。部署是Kubernetes对象，为Pods和ReplicaSets提供声明性更新。您可以使用它们来声明性地执行以下操作：
- en: Perform a *rollout* of a new ReplicaSet.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行新的ReplicaSet的*滚动*。
- en: Change the Pod template and perform a controlled rollout. The old ReplicaSet
    will be gradually scaled down, whereas the new ReplicaSet will scale up at the
    same rate.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改Pod模板并执行受控滚动。旧的ReplicaSet将逐渐缩减，而新的ReplicaSet将以相同的速度扩展。
- en: Perform a *rollback* to an earlier version of the Deployment.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行*回滚*到部署的早期版本。
- en: Scale the ReplicaSet up or down.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展ReplicaSet的规模。
- en: 'The relationship of Deployment to ReplicaSets and Pods can be seen in the following
    diagram:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 部署与ReplicaSets和Pods的关系可以在以下图表中看到：
- en: '![](assets/553efa0f-59d7-44b6-94eb-5a837aaf5785.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/553efa0f-59d7-44b6-94eb-5a837aaf5785.png)'
- en: You should **avoid** managing ReplicaSets created by a Deployment on your own.
    If you need to make any changes to the ReplicaSet, perform the changes on the
    owning Deployment Object.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该**避免**自行管理由部署创建的ReplicaSets。如果需要对ReplicaSet进行任何更改，请在拥有的部署对象上执行更改。
- en: Note that the issue of the *accidental* acquisition of Pods by ReplicaSets managed
    by Deployments does not exist. The reason for this is that Pods and ReplicaSets
    use a special, automatically generated label called `pod-template-hash` that guarantees
    the uniqueness of the selection.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由部署管理的ReplicaSets的*意外*获取Pods的问题不存在。原因是Pods和ReplicaSets使用一个特殊的、自动生成的标签，称为`pod-template-hash`，确保选择的唯一性。
- en: 'Let''s take a look at an example Deployment manifest in the `nginx-deployment.yaml`
    file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们看一个示例部署清单，在`nginx-deployment.yaml`文件中： '
- en: '[PRE8]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, the basic structure is almost identical to `ReplicaSet`, but
    there are significant differences in how Deployment behaves when you perform a
    declarative update. Let''s quickly demonstrate this in the playground:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，基本结构与`ReplicaSet`几乎相同，但在执行声明性更新时，部署的行为有显著的差异。让我们在示例中快速演示一下：
- en: 'Create manually the Deployment manifest file or download it using the `wget`
    command:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动创建部署清单文件，或使用`wget`命令下载它：
- en: '[PRE9]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Apply the Deployment manifest file using the following command:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令应用部署清单文件：
- en: '[PRE10]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `--record` flag adds a metadata annotation of `kubernetes.io/change-cause` to
    API objects that were created or modified by the preceding command. This feature
    allows you to easily track changes in your cluster.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`--record`标志将`kubernetes.io/change-cause`的元数据注释添加到之前命令创建或修改的API对象中。此功能允许您轻松跟踪集群中的更改。'
- en: Wait for the Deployment to fully roll out (you can observe the number of ready
    Pods in your deployment using `kubectl get deployment -w`).
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待部署完全完成（您可以使用`kubectl get deployment -w`观察部署中就绪的Pod数量）。
- en: Now, change the Pod Spec in the template in the YAML manifest; for example,
    change `.spec.template.spec.containers[0].image` to `nginx:1.**16**` and apply
    the Deployment manifest again.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在YAML清单中的模板中更改Pod规范；例如，将`.spec.template.spec.containers[0].image`更改为`nginx:1.**16**`，然后再次应用部署清单。
- en: 'Immediately after that, observe how the rollout progresses using the following
    command:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，使用以下命令观察部署的进展：
- en: '[PRE11]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Spec of Deployment is much richer than ReplicaSet. You can check the official
    documentation for more details: [https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#writing-a-deployment-spec](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#writing-a-deployment-spec).
    The official documentation contains multiple use cases of Deployments, all of
    which are described in detail: [https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#use-case](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#use-case).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 部署的规范比ReplicaSet丰富得多。您可以查看官方文档以获取更多详细信息：[https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#writing-a-deployment-spec](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#writing-a-deployment-spec)。官方文档包含了部署的多个用例，所有这些用例都有详细描述：[https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#use-case](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#use-case)。
- en: As you can see, the declarative update to the Deployment template definition
    caused a smooth rollout of new Pod replicas. The old ReplicaSet was scaled down
    and, simultaneously, a new ReplicaSet, with a new Pod template, was created and
    gradually scaled up. You can now try performing the same operation with an `image`
    update for an existing bare ReplicaSet and you will see that... actually, nothing
    happens. This is because ReplicaSet only uses a Pod template to create new Pods.
    Existing Pods will not be updated or removed by such a change.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，对部署模板定义的声明性更新导致新Pod副本的平稳部署。旧的ReplicaSet被缩减，同时，一个新的具有新Pod模板的ReplicaSet被创建并逐渐扩展。现在，您可以尝试对现有的裸ReplicaSet执行相同的操作进行`image`更新，然后您会发现...实际上，什么都没有发生。这是因为ReplicaSet只使用Pod模板来创建新的Pod。现有的Pod不会因此更改而被更新或删除。
- en: A rollout is only triggered when the `.spec.template` for Deployment is changed.
    Other changes to the Deployment manifest will not trigger a rollout.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当对部署的`.spec.template`进行更改时，才会触发部署。对部署清单的其他更改不会触发部署。
- en: 'Next, let''s take a look at a concept similar to Deployments: StatefulSets.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一个与部署类似的概念：StatefulSets。
- en: StatefulSets
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StatefulSets
- en: 'Deployments are usually used to deploy stateless components of your application.
    For stateful components, Kubernetes provides another API Object named `StatefulSet`.
    The principle of this operation is very similar to Deployment – it manages ReplicaSets
    and Pods in a declarative way and provides smooth rollouts and rollbacks. However,
    there are some key differences:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 部署通常用于部署应用程序的无状态组件。对于有状态的组件，Kubernetes提供了另一个名为`StatefulSet`的API对象。这种操作的原则与部署非常相似-它以声明方式管理ReplicaSets和Pod，并提供平稳的部署和回滚。然而，也有一些关键区别：
- en: StatefulSets ensure a deterministic (sticky) ID of Pods, which consists of `<statefulSetName>-<ordinal>`.
    For Deployments, you would have a random ID consisting of `<deploymentName>-<randomHash>`.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: StatefulSets确保Pod具有确定性（粘性）ID，由`<statefulSetName>-<ordinal>`组成。对于部署，您将具有由`<deploymentName>-<randomHash>`组成的随机ID。
- en: For StatefulSets, the Pods are started and terminated in a specific, predictable
    order while scaling the ReplicaSet.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于StatefulSets，Pod将按特定的可预测顺序启动和终止，同时扩展ReplicaSet。
- en: In terms of storage, Kubernetes creates PersistentVolumeClaims based on `volumeClaimTemplates`
    of the StatefulSet Object for each Pod in the StatefulSet and always attaches
    this to the Pod with the same ID. For Deployments, if you choose to use `volumeClaimTemplates`,
    Kubernetes will create a single PersistentVolumeClaim and attach the same to all
    the Pods in the Deployment.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存储方面，Kubernetes基于StatefulSet对象的`volumeClaimTemplates`为StatefulSet中的每个Pod创建PersistentVolumeClaims，并始终将其附加到具有相同ID的Pod。对于部署，如果选择使用`volumeClaimTemplates`，Kubernetes将创建一个单一的PersistentVolumeClaim，并将其附加到部署中的所有Pod。
- en: You need to create a headless Service Object that is responsible for managing
    the deterministic network identity (DNS names) for Pods. The Headless Service
    allows us to return all Pod IPs behind the Service as DNS A records instead of
    a single DNS A record with a Service Cluster IP.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要创建一个负责管理Pod的确定性网络标识（DNS名称）的无头Service对象。无头Service允许我们将所有Pod IP作为DNS A记录返回到Service后面，而不是使用Service
    Cluster IP返回单个DNS A记录。
- en: StatefulSets use a similar Spec to Deployments – you can find out more regarding
    StatefulSets by looking at the official documentation: [https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSets使用与部署类似的Spec-您可以通过查看官方文档了解有关StatefulSets的更多信息：[https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/)。
- en: DaemonSets
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DaemonSets
- en: 'A DaemonSet is another controller-backed Object that is similar to a ReplicaSet
    but aims at running *exactly one* templated Pod replica per node in the cluster
    (optionally matching selectors). The most common use cases for running a DaemonSet
    are as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: DaemonSet是另一个由控制器支持的对象，类似于ReplicaSet，但旨在在集群中的每个节点上运行*确切一个*模板化的Pod副本（可选匹配选择器）。运行DaemonSet的最常见用例如下：
- en: Managing monitoring telemetry for a given cluster node, for example, running
    Prometheus Node Exporter
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理给定集群节点的监控遥测，例如运行Prometheus Node Exporter
- en: Running a log collection daemon on each node, for example, `fluentd` or `logstash`
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个节点上运行日志收集守护程序，例如`fluentd`或`logstash`
- en: Running troubleshooting Pods, for example, node-problem-detector ([https://github.com/kubernetes/node-problem-detector](https://github.com/kubernetes/node-problem-detector))
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行故障排除Pod，例如node-problem-detector（[https://github.com/kubernetes/node-problem-detector](https://github.com/kubernetes/node-problem-detector)）
- en: 'One of the DaemonSets that may run on your cluster out of the box is `kube-proxy`.
    In a standard cluster deployment performed by kubeadm, `kube-proxy` is distributed
    to nodes as a DaemonSet. You can also verify this on your Katacoda playground:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的集群中可能会默认运行的DaemonSets之一是`kube-proxy`。在由kubeadm执行的标准集群部署中，`kube-proxy`作为DaemonSet分发到节点。您还可以在Katacoda
    playground上验证这一点：
- en: '[PRE12]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you would like to find out more about DaemonSets, please refer to the official
    documentation: [https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/](https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关DaemonSets的更多信息，请参阅官方文档：[https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/](https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/)。
- en: Services
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: Pods that are created by ReplicaSets or Deployments have a finite life cycle.
    At some point, you can expect them to be terminated and new Pod replicas with new
    IP addresses will be created in their place. So, what if you have a Deployment
    running web server Pods that need to communicate with Pods that have been created
    as a part of another Deployment, for example, backend Pods?  Web server Pods cannot
    assume anything about IP addresses or the DNS names of backend Pods, as they may
    change over time. This issue is resolved with Service API objects, which provide
    reliable networking for a set of Pods.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由 ReplicaSets 或 Deployments 创建的 Pods 具有有限的生命周期。在某个时候，您可以期望它们被终止，并且将创建新的 Pod
    副本，具有新的 IP 地址。因此，如果您有一个运行 web 服务器 Pods 的 Deployment，需要与作为另一个 Deployment 一部分创建的
    Pods 进行通信，例如后端 Pods，那么该怎么办呢？Web 服务器 Pods 不能假设任何关于后端 Pods 的 IP 地址或 DNS 名称的信息，因为它们可能随时间而改变。这个问题通过
    Service API 对象得到解决，它为一组 Pods 提供可靠的网络连接。
- en: In general, Services target a set of Pods, and this is determined by label selectors.
    The most common scenario is exposing a Service for an existing Deployment by using
    exactly the same label selector. The Service is responsible for providing a reliable
    DNS name and IP address, as well as for monitoring selector results and updating
    the associated Endpoint Object with the current IP addresses of matching Pods.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Services 针对一组 Pods，这是由标签选择器确定的。最常见的情况是通过使用完全相同的标签选择器为现有 Deployment 公开一个 Service。Service
    负责提供可靠的 DNS 名称和 IP 地址，以及监视选择器结果并更新相关的 Endpoint 对象，其中包含匹配 Pods 的当前 IP 地址。
- en: For internal clients (Pods in the cluster), the communication to Pods behind
    a service is transparent – they use the Cluster IP or DNS name of the Service
    and the traffic is routed to one of the destination Pods. Routing capabilities
    are provided by kube-proxy, but it is important to know that the traffic is not
    routed through any master components – kube-proxy implements routing at the operating
    system kernel level and directly routes this to an appropriate Pod's IP address.
    In its simplest form, the destination Pod will be chosen randomly, but with **IP
    Virtual Server** (**IPVS**) proxy mode, you can have more complex strategies,
    such as least connection or shortest expected delay.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内部客户端（集群中的 Pods），到 Service 后面的 Pods 的通信是透明的 - 他们使用 Service 的 Cluster IP 或
    DNS 名称，流量被路由到其中一个目标 Pods。路由能力由 kube-proxy 提供，但重要的是要知道流量不会通过任何主组件 - kube-proxy
    在操作系统内核级别实现路由，并直接将其路由到适当的 Pod 的 IP 地址。在其最简单的形式中，目标 Pod 将被随机选择，但使用 **IP Virtual
    Server** (**IPVS**) 代理模式，您可以有更复杂的策略，例如最少连接或最短预期延迟。
- en: Services can also expose Pods to external traffic.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Services 也可以将 Pods 暴露给外部流量。
- en: 'The principle of how Service works can be seen in the following diagram:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Service 的工作原理可以在以下图表中看到：
- en: '![](assets/3dcc1fc0-c4d7-4a3c-a0b0-898653ac3af3.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3dcc1fc0-c4d7-4a3c-a0b0-898653ac3af3.png)'
- en: 'Let''s expose an example service for our nginx Deployment:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的 nginx Deployment 公开一个示例 Service：
- en: 'If you don''t have a running Deployment on the Katacoda playground, you can
    create one using the following command:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在 Katacoda 游乐场上没有正在运行的 Deployment，可以使用以下命令创建一个：
- en: '[PRE13]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Expose the Service for a deployment using the following `kubectl expose` command:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下 `kubectl expose` 命令为一个 Deployment 公开 Service：
- en: '[PRE14]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This command is *imperative* and should be avoided in favor of the *declarative*
    manifest. This command is equivalent to applying the following Service manifest:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个命令是*命令式*的，应该避免使用，而应该使用*声明式*的清单。这个命令相当于应用以下 Service 清单：
- en: '[PRE15]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, after the Service has been exposed, create an interactive `busybox` Pod
    and start the Bourne shell process:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 Service 被公开后，创建一个交互式的 `busybox` Pod，并启动 Bourne shell 进程：
- en: '[PRE16]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When the container shell prompt appears, download the default web page served
    by nginx Pods while using the `nginx-deployment-example` Service name as the DNS
    name:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当容器外壳提示出现时，使用`nginx-deployment-example`服务名称作为DNS名称下载由nginx Pods提供的默认网页：
- en: '[PRE17]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can also use a **Fully Qualified Domain Name** (**FQDN**), which is in the
    following form: `<serviceName>.<namespaceName>.svc.<clusterDomain>`. In this case,
    it is `nginx-deployment-example.default.svc.cluster.local`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用**完全限定域名**（**FQDN**），其格式如下：`<serviceName>.<namespaceName>.svc.<clusterDomain>`。在这种情况下，它是`nginx-deployment-example.default.svc.cluster.local`。
- en: Next, let's take a quick look at objects that provide storage in Kubernetes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们快速看一下在Kubernetes中提供存储的对象。
- en: Storage-related objects
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与存储相关的对象
- en: In this book, we will cover Kubernetes storage only when needed as it is a broad
    and complex topic – in fact, storage and managing the stateful components of any
    cluster is often the hardest challenge to solve. If you are interested in details
    regarding storage in Kubernetes, please refer to the official documentation: [https://kubernetes.io/docs/concepts/storage/](https://kubernetes.io/docs/concepts/storage/).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们只在需要时涵盖Kubernetes存储，因为这是一个广泛且复杂的主题-事实上，存储和管理任何集群的有状态组件通常是最难解决的挑战。如果您对Kubernetes中的存储细节感兴趣，请参考官方文档：[https://kubernetes.io/docs/concepts/storage/](https://kubernetes.io/docs/concepts/storage/)。
- en: In Docker, we use volumes to provide persistence either on local disk or remote/cloud
    storage using volume plugins. Docker volumes have a life cycle that's independent
    of the containers that consume them. In Kubernetes, there is a similar concept
    of a Volume, which is tightly coupled with a Pod and has the same life cycle as
    the Pod. The most important aspect of Volumes in Kubernetes is that they support
    multiple backing storage providers (types) –– this is abstracted by Volume Plugins
    and, more recently, the **Container Storage Interface** (**CSI**), which is an
    interface for out-of-tree Volume Plugins that are developed independently from
    Kubernetes core. You can, for example, mount an Amazon Web Services EBS volume
    or Microsoft Azure Files SMB Share as a Volume for your Pod – the full list of
    Volume types is available here: [https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes](https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker中，我们使用卷来提供持久性，可以是本地磁盘，也可以是远程/云存储，使用卷插件。 Docker卷有一个独立于消耗它们的容器的生命周期。在Kubernetes中，有一个类似的概念，叫做Volume，它与Pod紧密耦合，并且与Pod具有相同的生命周期。在Kubernetes中，Volume的最重要的方面是它们支持多个后备存储提供者（类型）-这是由Volume插件和最近的**容器存储接口**（**CSI**）抽象出来的，这是一个用于独立于Kubernetes核心开发的外部Volume插件的接口。例如，您可以将Amazon
    Web Services EBS卷或Microsoft Azure Files SMB共享挂载为Pod的Volume-完整的Volume类型列表在这里：[https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes](https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes)。
- en: One of the Volume types is **PersistentVolumeClaim **(**PVC**)**,** which aims
    at decoupling Pods from the actual storage. PersistentVolumeClaim is an API Object
    that models a request for the storage of a specific type, class, or size – think
    of saying *I would like 10 GB of read/write-once SSD storage*. To fulfill such
    a request, a **PersistentVolume **(**PV**) API Object is required, which is a
    piece of storage that has been provisioned by the cluster's automation process.
    PersistentVolume types are also implemented as plugins, in a similar manner to
    Volumes.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Volume类型之一是**PersistentVolumeClaim**（**PVC**），它旨在将Pod与实际存储解耦。PersistentVolumeClaim是一个API对象，用于模拟对特定类型、类或大小存储的请求-可以将其视为说“我想要10GB的读/写一次SSD存储”。为了满足这样的请求，需要一个**PersistentVolume**（**PV**）API对象，这是集群自动化过程提供的一部分存储。PersistentVolume类型也以类似于Volume的插件方式实现。
- en: Now, the whole process of provisioning PersistentVolumes can be dynamic – it
    requires creating a **StorageClass** (**SC**) API Object and using it when defining
    PVCs. When creating a new StorageClass, you provide a **provisioner** (or plugin)
    with specific parameters, and each PVC using the given SC will automatically create
    a PV using the selected provisioner.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，持久卷的整个配置过程可以是动态的 - 它需要创建一个StorageClass（SC）API对象，并在定义PVC时使用它。创建新的StorageClass时，您提供一个具有特定参数的供应商（或插件），并且使用给定SC的每个PVC将自动创建一个PV。
- en: 'These dependencies can be seen in the following diagram:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这些依赖关系可以在以下图表中看到：
- en: '![](assets/5c8b7508-c114-417d-a7ef-9954cccadf71.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5c8b7508-c114-417d-a7ef-9954cccadf71.png)'
- en: 'When you would like to deploy a Pod with a PersistentVolume mounted, the sequence
    of events would be as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要部署一个挂载了PersistentVolume的Pod时，事件的顺序将如下：
- en: Create a StorageClass with a desired provisioner.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有所需供应商的StorageClass。
- en: Create a PersistentVolumeClaim that uses the SC.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用SC的PersistentVolumeClaim。
- en: PersistentVolume is dynamically provisioned.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PersistentVolume是动态配置的。
- en: When creating a Pod, mount the PVC as a Volume.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建Pod时，将PVC挂载为一个Volume。
- en: The idea of dynamically provisioned PersistentVolumes is complemented by the
    concept of StatefulSets. StatefulSets define volumeClaimTemplates, which can be
    used for the dynamic creation of the PersistentVolumeClaims of a given StorageClass.
    By doing this, the whole process of storage provisioning is fully dynamic – you
    just create a StatefulSet and the underlying storage objects are managed by the
    StatefulSet controller. You can find more details and examples here: [https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-storage](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-storage).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 动态配置的PersistentVolumes的概念得到了StatefulSets的补充。StatefulSets定义了volumeClaimTemplates，可以用于动态创建给定StorageClass的PersistentVolumeClaims。通过这样做，整个存储配置过程是完全动态的
    - 您只需创建一个StatefulSet，底层存储对象就由StatefulSet控制器管理。您可以在这里找到更多详细信息和示例：[https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-storage](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-storage)。
- en: Such storage architecture in Kubernetes ensures the portability of workloads,
    which means that you can easily move your Deployments and PersistentVolumeClaims
    to a different cluster. All you need to do is provide a StorageClass that fulfills
    the requirements of PVC. No modifications need to be made to the StatefulSet or
    PVC.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的这种存储架构确保了工作负载的可移植性，这意味着您可以轻松地将部署和PersistentVolumeClaims移动到不同的集群。您所需要做的就是提供一个满足PVC要求的StorageClass。无需对StatefulSet或PVC进行修改。
- en: The Windows and Kubernetes ecosystem
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows和Kubernetes生态系统
- en: Initially, Kubernetes was a Linux-centric solution – this was a result of the
    fact that mainstream containerization also originates from the Linux platform.
    In 2014, Microsoft and Windows were soon to join the containerization world –
    Microsoft announced support for Docker Engine in the upcoming release of Windows
    Server 2016\. Kubernetes **Special Interest Group** (**SIG**) Windows was started
    in March 2016 and in January 2018, Kubernetes 1.9 provided beta support for Windows
    Server Containers. This support eventually matured to production level in April
    2019 when Kubernetes 1.14 was released.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Kubernetes是一个以Linux为中心的解决方案 - 这是因为主流的容器化也起源于Linux平台。2014年，微软和Windows很快就加入了容器化世界
    - 微软宣布将在即将发布的Windows Server 2016中支持Docker Engine。Windows的Kubernetes特别兴趣小组（SIG）于2016年3月启动，2018年1月，Kubernetes
    1.9为Windows Server容器提供了beta支持。这种支持最终在2019年4月Kubernetes 1.14发布时成熟到生产级别。
- en: Why is Windows support for Kubernetes so important? Windows dominates in enterprise
    workloads and with Kubernetes being the de facto standard in container orchestration,
    support for Windows brings the possibility of migrating the vast majority of enterprise
    software to containers. Developers and system operators can now leverage the same
    tools and pipelines to deploy both Windows and Linux workloads, scale them in
    a similar way, and monitor them efficiently. From a business perspective, container
    adoption for Windows means better operational costs and better hardware utilization
    than plain VMs.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么Windows对Kubernetes的支持如此重要？Windows在企业工作负载中占据主导地位，而Kubernetes作为容器编排的事实标准，对Windows的支持带来了将绝大多数企业软件迁移到容器的可能性。开发人员和系统运营商现在可以利用相同的工具和流水线来部署Windows和Linux工作负载，以类似的方式扩展它们，并有效地监视它们。从商业角度来看，Windows的容器采用意味着比普通虚拟机更好的运营成本和更好的硬件利用率。
- en: 'Windows containers support in Kubernetes is constantly evolving and more and
    more limitations are being replaced by new features. There are two key points
    that you need to remember in general:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的Windows容器支持不断发展，越来越多的限制正在被新功能取代。总的来说，有两个关键点需要记住：
- en: Currently, Windows machines can only join the cluster as nodes. There is no
    possibility and no plans for running master components on Windows. Clusters that
    run both Linux and Windows nodes are known as being hybrid or heterogeneous.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，Windows机器只能作为节点加入集群。没有可能性，也没有计划在Windows上运行主控组件。同时运行Linux和Windows节点的集群被称为混合或异构。
- en: You will need the latest stable version of Kubernetes and the latest (or almost
    latest) version of the Windows Server operating system to enjoy the full support
    that's on offer. For example, for Kubernetes 1.17, you need Windows Server 1809
    (Semi-Annual Channel release) or Windows Server 2019 (the same release but coming
    from the Long-Term Servicing Channel), although the latest Windows Server, 1903,
    is also supported.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要最新稳定版本的Kubernetes和最新（或几乎最新）版本的Windows Server操作系统才能享受到提供的全面支持。例如，对于Kubernetes
    1.17，您需要Windows Server 1809（半年频道发布）或Windows Server 2019（来自长期服务频道的相同发布），尽管最新的Windows
    Server 1903也受支持。
- en: 'Currently, the amount of documentation regarding Windows support for Kubernetes
    is limited but growing. The best resources out there are as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，关于Kubernetes对Windows的支持的文档数量有限，但正在增长。最好的资源如下：
- en: Official Kubernetes documentation: [https://kubernetes.io/docs/setup/production-environment/windows/intro-windows-in-kubernetes/](https://kubernetes.io/docs/setup/production-environment/windows/intro-windows-in-kubernetes/).
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方Kubernetes文档：[https://kubernetes.io/docs/setup/production-environment/windows/intro-windows-in-kubernetes/](https://kubernetes.io/docs/setup/production-environment/windows/intro-windows-in-kubernetes/)。
- en: Official Windows containerization and Kubernetes support documentation: [https://docs.microsoft.com/en-us/virtualization/windowscontainers/kubernetes/getting-started-kubernetes-windows](https://docs.microsoft.com/en-us/virtualization/windowscontainers/kubernetes/getting-started-kubernetes-windows).
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方Windows容器化和Kubernetes支持文档：[https://docs.microsoft.com/en-us/virtualization/windowscontainers/kubernetes/getting-started-kubernetes-windows](https://docs.microsoft.com/en-us/virtualization/windowscontainers/kubernetes/getting-started-kubernetes-windows)。
- en: Azure Kubernetes Engine How-Tos for Windows: [https://docs.microsoft.com/en-us/azure/aks/windows-container-cli](https://docs.microsoft.com/en-us/azure/aks/windows-container-cli).
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Kubernetes Engine Windows操作指南：[https://docs.microsoft.com/en-us/azure/aks/windows-container-cli](https://docs.microsoft.com/en-us/azure/aks/windows-container-cli)。
- en: SIG-Windows meeting notes and recordings: [https://github.com/kubernetes/community/tree/master/sig-windows](https://github.com/kubernetes/community/tree/master/sig-windows).
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SIG-Windows会议记录和录音：[https://github.com/kubernetes/community/tree/master/sig-windows](https://github.com/kubernetes/community/tree/master/sig-windows)。
- en: Kubernetes release notes and changelogs (look for SIG-Windows or Windows-related
    points): [https://github.com/kubernetes/kubernetes/releases](https://github.com/kubernetes/kubernetes/releases).
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes发布说明和更改日志（查找SIG-Windows或与Windows相关的内容）：[https://github.com/kubernetes/kubernetes/releases](https://github.com/kubernetes/kubernetes/releases)。
- en: Kubernetes Community Forums for Windows discussion: [https://discuss.kubernetes.io/c/general-discussions/windows](https://discuss.kubernetes.io/c/general-discussions/windows).
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes社区论坛上有关Windows讨论的链接：[https://discuss.kubernetes.io/c/general-discussions/windows](https://discuss.kubernetes.io/c/general-discussions/windows)。
- en: Slack channel for SIG-Windows (you can really find a lot of help here if you
    run into problems!): [https://kubernetes.slack.com/messages/sig-windows](https://kubernetes.slack.com/messages/sig-windows).
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SIG-Windows的Slack频道（如果遇到问题，你可以在这里找到很多帮助）：[https://kubernetes.slack.com/messages/sig-windows](https://kubernetes.slack.com/messages/sig-windows)。
- en: Let's take a look at the current state of Windows support for Kubernetes and
    the limitations as of version 1.17.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下Kubernetes对Windows的支持的当前状态以及截至1.17版本的限制。
- en: Kubernetes limitations on Windows
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows上的Kubernetes限制
- en: 'Windows Server containers support comes with a set of limitations that constantly
    change as each new version of Kubernetes is released and new releases of Windows
    Server arrive. Generally, from a Kubernetes API Server and kubelet perspective,
    in heterogeneous (hybrid) Linux/Windows Kubernetes clusters, the containers on
    Windows behave almost the same as Linux containers. However, there are some key
    differences in the details. First, let''s take a look at some high-level, major
    limitations:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Server容器支持存在一系列限制，随着每个新版本的Kubernetes发布和Windows Server的新版本的到来，这些限制不断变化。一般来说，从Kubernetes
    API服务器和kubelet的角度来看，在异构（混合）Linux/Windows Kubernetes集群中，Windows上的容器的行为几乎与Linux容器相同。但是，细节上存在一些关键的差异。首先，让我们来看一些高层次的主要限制：
- en: Windows machines can only join the cluster as worker nodes. There is no possibility
    and no plans for running master components on Windows.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows机器只能作为worker节点加入集群。在Windows上运行master组件的可能性和计划都不存在。
- en: Windows Server 1809 or 2019 is the minimal requirement for the OS on worker
    nodes. You cannot use Windows 10 machines as nodes.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Worker节点的操作系统的最低要求是Windows Server 1809或2019。不能使用Windows 10机器作为节点。
- en: Docker Enterprise Edition (Basic) 18.09 or later is required as the container
    runtime. Enterprise Edition is available at no extra cost for the Windows Server
    operating system.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要Docker Enterprise Edition（基本版）18.09或更高版本作为容器运行时。企业版对Windows Server操作系统免费提供。
- en: The Windows Server operating system is subject to licensing ([https://www.microsoft.com/en-us/cloud-platform/windows-server-pricing](https://www.microsoft.com/en-us/cloud-platform/windows-server-pricing)).
    Windows Container images are subject to the Microsoft Software Supplemental License
    ([https://docs.microsoft.com/en-us/virtualization/windowscontainers/images-eula](https://docs.microsoft.com/en-us/virtualization/windowscontainers/images-eula)).
    For development and evaluation purposes, you can also use the Evaluations Center: [https://www.microsoft.com/en-us/evalcenter/evaluate-windows-server-2019](https://www.microsoft.com/en-us/evalcenter/evaluate-windows-server-2019).
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows Server操作系统需要许可证（[https://www.microsoft.com/en-us/cloud-platform/windows-server-pricing](https://www.microsoft.com/en-us/cloud-platform/windows-server-pricing)）。Windows容器镜像需要遵守微软软件补充许可证（[https://docs.microsoft.com/en-us/virtualization/windowscontainers/images-eula](https://docs.microsoft.com/en-us/virtualization/windowscontainers/images-eula)）。对于开发和评估目的，你也可以使用评估中心：[https://www.microsoft.com/en-us/evalcenter/evaluate-windows-server-2019](https://www.microsoft.com/en-us/evalcenter/evaluate-windows-server-2019)。
- en: Hyper-V isolation for Windows Server containers running on Kubernetes is in
    its experimental phase (alpha) and the current design will be deprecated in favor
    of the containerd implementation of the runtime. Until that time comes, the compatibility
    rules for process-isolated containers apply – you have to run containers with
    a base OS image that matches the host OS version. You can find more details in
    [Chapter 1](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml), *Creating Containers*.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行在 Kubernetes 上的 Windows Server 容器的 Hyper-V 隔离处于实验阶段（alpha），当前的设计将被 containerd
    实现的运行时所取代。在那之前，进程隔离容器的兼容性规则适用 - 你必须使用与主机操作系统版本匹配的基本操作系统镜像运行容器。你可以在 [第 1 章](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml)
    *创建容器* 中找到更多细节。
- en: '**Linux Containers on Windows** (**LCOW**) is not supported.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows 上的 Linux 容器**（LCOW）不受支持。'
- en: 'Probably the most relevant to you is as follows: setting up a local Kubernetes
    development environment for hybrid Linux/Windows clusters is complex and currently,
    no standard solutions, such as Minikube or Docker Desktop for Windows, support
    such a configuration. This means you either need an on-premises, multi-node cluster
    or managed cloud offering to develop and evaluate your scenarios.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对你来说可能最相关的是：为混合 Linux/Windows 集群设置本地 Kubernetes 开发环境非常复杂，目前没有标准解决方案，比如 Minikube
    或 Windows 的 Docker Desktop，支持这样的配置。这意味着你需要一个本地的多节点集群或托管的云服务来开发和评估你的场景。
- en: The Windows nodes join process is not automated as much as it is for Linux nodes. Kubeadm
    will soon support the process of joining Windows nodes, but until then, you have
    to do this manually (with some help from Powershell scripting).
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 节点的加入过程不像 Linux 节点那样自动化。Kubeadm 很快将支持加入 Windows 节点的过程，但在那之前，你必须手动进行（借助一些
    Powershell 脚本的帮助）。
- en: 'For container workload/compute, some of the limitations are as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于容器工作负载/计算，一些限制如下：
- en: Privileged containers are not supported on Windows nodes. This may pose some
    other limitations, such as running CSI plugins that must run in privileged mode.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 节点不支持特权容器。这可能会带来其他一些限制，比如运行必须以特权模式运行的 CSI 插件。
- en: Windows does not have an out of memory process killer and currently, the Pods
    cannot be limited in terms of memory that's used. This is true for process-isolated
    containers but once containerd Hyper-V isolation is available on Kubernetes, a
    limit can be enforced.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 没有内存进程杀手，目前 Pods 无法在内存使用方面受到限制。这对于进程隔离的容器是真实的，但一旦容器化 Hyper-V 隔离在 Kubernetes
    上可用，就可以强制执行限制。
- en: You need to specify proper node selectors to prevent, for example, Linux DaemonSets
    from trying to run on Windows nodes. This is technically not a limitation, but
    you should be aware that you need to control these selectors for your deployments.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要指定适当的节点选择器，以防止例如 Linux DaemonSets 尝试在 Windows 节点上运行。这在技术上不是一个限制，但你应该意识到你需要控制这些选择器来部署你的应用。
- en: 'For networking, some of the limitations are as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 关于网络，一些限制如下：
- en: Network management for Windows nodes is more complex and Windows container networking
    is similar to VM networking.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 节点的网络管理更加复杂，Windows 容器网络类似于 VM 网络。
- en: Fewer network plugins (CNI) are supported on Windows. You need to choose a solution
    that works for both Linux and Windows nodes in your cluster, for example, Flannel
    with a host-gw backend.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 上支持的网络插件（CNI）较少。你需要选择一个适用于集群中的 Linux 和 Windows 节点的解决方案，例如带有 host-gw
    后端的 Flannel。
- en: L2bridge, l2tunnel, or overlay networks do not support IPv6 stack.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: L2bridge、l2tunnel 或覆盖网络不支持 IPv6 栈。
- en: Kube-proxy for Windows does not support IPVS and advanced load balancing policies.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 的 Kube-proxy 不支持 IPVS 和高级负载均衡策略。
- en: Accessing the NodePort Service from the node running the Pod fails.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从运行 Pod 的节点访问 NodePort 服务会失败。
- en: Ingress Controllers can run on Windows, but only if they support Windows containers;
    for example, *ingress-nginx*.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ingress Controllers可以在Windows上运行，但只有在它们支持Windows容器的情况下；例如，*ingress-nginx*。
- en: Pinging external network hosts from inside the cluster with ICMP packets is
    not supported. In other words, don't be surprised when you are testing connectivity
    from Pods to the outside world with ping. You can use `curl` or Powershell `Invoke-WebRequest`
    instead.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从集群内部使用ICMP数据包对外部网络主机进行ping不受支持。换句话说，当您使用ping测试从Pod到外部世界的连接时，不要感到惊讶。您可以使用`curl`或Powershell
    `Invoke-WebRequest`代替。
- en: 'For storage, some of the limitations are as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于存储，一些限制如下：
- en: Expanding mounted volumes is not possible.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法扩展已挂载的卷。
- en: Secrets that are mounted to Pods are written in clear-text using node storage.
    This may pose security risks and you will need to take additional actions to secure
    the cluster.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载到Pod的Secrets是使用节点存储以明文写入的。这可能存在安全风险，您需要采取额外的措施来保护集群。
- en: 'Windows nodes only support the following volume types:'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows节点仅支持以下卷类型：
- en: FlexVolume (SMB, iSCSI)
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FlexVolume（SMB，iSCSI）
- en: azureDisk
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: azureDisk
- en: azureFile
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: azureFile
- en: gcePersistentDisk
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gcePersistentDisk
- en: awsElasticBlockStore (since 1.16)
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: awsElasticBlockStore（自1.16版起）
- en: vsphereVolume (since 1.16)
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: vsphereVolume（自1.16版起）
- en: The following limitations concern Kubernetes 1.17\. Since the list of supported
    functionalities and current limitations changes, we advise that you check the
    official documentation for more up to date details: [https://kubernetes.io/docs/setup/production-environment/windows/intro-windows-in-kubernetes/#supported-functionality-and-limitations](https://kubernetes.io/docs/setup/production-environment/windows/intro-windows-in-kubernetes/#supported-functionality-and-limitations).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下限制涉及Kubernetes 1.17版。由于支持的功能和当前限制的列表会发生变化，我们建议您查看官方文档以获取更多最新详细信息：[https://kubernetes.io/docs/setup/production-environment/windows/intro-windows-in-kubernetes/#supported-functionality-and-limitations](https://kubernetes.io/docs/setup/production-environment/windows/intro-windows-in-kubernetes/#supported-functionality-and-limitations)。
- en: Even if there is no support for local development clusters with Windows nodes,
    we'll still take a look at them; it is very likely that support for Windows workloads
    will be available in the near future.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有对Windows节点的本地开发集群的支持，我们仍然会对它们进行研究；很可能在不久的将来会支持Windows工作负载。
- en: Creating your own development cluster from scratch
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头开始创建自己的开发集群
- en: In this section, you will learn how to set up a local Kubernetes cluster for
    development and learning on the Windows operating system. We will be using minikube,
    which is the official, recommended toolset, and Docker Desktop for Windows Kubernetes
    clusters. Please note that the current tooling for local clusters *does not* support
    Windows containers as it requires a multi-node setup with Linux master and Windows
    Server nodes. So, in other words, these tools allow you to develop Kubernetes
    applications running in Linux containers on your Windows machine. Basically, they
    provide an optimized Linux VM that hosts a one-node Kubernetes cluster.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何在Windows操作系统上设置本地Kubernetes集群进行开发和学习。我们将使用minikube，这是官方推荐的工具集，以及Docker
    Desktop用于Windows Kubernetes集群。请注意，当前的本地集群工具*不*支持Windows容器，因为它需要使用Linux主节点和Windows
    Server节点进行多节点设置。换句话说，这些工具允许您在Windows计算机上开发运行在Linux容器中的Kubernetes应用程序。基本上，它们提供了一个优化的Linux虚拟机，用于托管一个节点的Kubernetes集群。
- en: If you wish to experiment, you can use Katacoda Kubernetes playground ([https://www.katacoda.com/courses/kubernetes/playground](https://www.katacoda.com/courses/kubernetes/playground)),
    which was used to demonstrate Kubernetes objects in this chapter, or Play with
    Kubernetes ([https://labs.play-with-k8s.com/](https://labs.play-with-k8s.com/)),
    which is provided by Docker, Inc.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望进行实验，可以使用Katacoda Kubernetes playground（[https://www.katacoda.com/courses/kubernetes/playground](https://www.katacoda.com/courses/kubernetes/playground)），该平台用于演示本章中的Kubernetes对象，或者使用由Docker,
    Inc.提供的Play with Kubernetes（[https://labs.play-with-k8s.com/](https://labs.play-with-k8s.com/)）。
- en: minikube
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: minikube
- en: '**Minikube** is available on Windows, Linux, and macOS and aims at providing
    a stable environment for local development with Kubernetes. The key requirement
    on Windows is that a VM hypervisor needs to be installed. For Docker Desktop for
    Windows and Windows containers, we already use Hyper-V, so this will be our choice
    here. If you haven''t enabled Hyper-V yet, please either follow the instructions
    for installing Docker Desktop for Windows in [Chapter 1](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml),
    *Creating Containers*, or follow the official documentation: [https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v).'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**Minikube**可用于Windows、Linux和macOS，并旨在为Kubernetes的本地开发提供稳定的环境。在Windows上的关键要求是需要安装VM虚拟化程序。对于Docker
    Desktop for Windows和Windows容器，我们已经使用了Hyper-V，因此这将是我们的选择。如果您尚未启用Hyper-V，请按照[第1章](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml)中安装Docker
    Desktop for Windows的说明，*创建容器*，或者按照官方文档：[https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v)。'
- en: 'To install minikube, you need to perform the following steps:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装minikube，您需要执行以下步骤：
- en: If you don't have a Hyper-V virtual external network switch, create one by opening
    Hyper-V Manager from the Start menu and clicking Virtual Switch Manager... from
    the Actions tab.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您没有Hyper-V虚拟外部网络交换机，请通过从开始菜单打开Hyper-V管理器并从操作选项卡中单击Virtual Switch Manager...来创建一个。
- en: Select External and click Create Virtual Switch.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择External并单击Create Virtual Switch。
- en: 'Use External Switch as the name of the virtual switch and choose the network
    adapter that you will use to connect to the internet; for example, your Wi-Fi
    adapter:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用External Switch作为虚拟交换机的名称，并选择要用于连接到互联网的网络适配器；例如，您的Wi-Fi适配器：
- en: '![](assets/862cdc2b-1458-4961-980c-26cb2ed45ea9.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/862cdc2b-1458-4961-980c-26cb2ed45ea9.png)'
- en: Click OK to accept the changes.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击确定以接受更改。
- en: 'Install kubectl (Kubernetes CLI) using the *Chocolatey*package manager. Execute
    the following command as an Administrator in a Powershell window:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Chocolatey*软件包管理器安装kubectl（Kubernetes CLI）。在Powershell窗口中以管理员身份执行以下命令：
- en: '[PRE18]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Install minikube using Chocolatey, also as an Administrator:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Chocolatey安装minikube，也作为管理员：
- en: '[PRE19]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Set Hyper-V as the default virtualization driver for minikube:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Hyper-V设置为minikube的默认虚拟化驱动程序：
- en: '[PRE20]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Set your virtual external switch to minikube by default:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的虚拟外部交换机默认设置为minikube：
- en: '[PRE21]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Start minikube. This may take a few minutes as the VM has to be set up and
    the Kubernetes node needs to be initialized:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动minikube。这可能需要几分钟，因为需要设置VM并初始化Kubernetes节点：
- en: '[PRE22]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you need to debug issues on the actual minikube VM (for example, connection
    problems), you can use the `minikube ssh` command or connect to the terminal directly
    from Hyper-V manager. The login username is `docker` and the password is `tcuser`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在实际的minikube VM上调试问题（例如连接问题），您可以使用`minikube ssh`命令或直接从Hyper-V管理器连接到终端。登录用户名是`docker`，密码是`tcuser`。
- en: 'Verify that the installation was successful by running the `kubectl` command,
    which will be configured to connect to the minikube cluster. You should see a
    variety of Pods running in the `kube-system` namespace:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`kubectl`命令来验证安装是否成功，该命令将配置为连接到minikube集群。你应该看到`kube-system`命名空间中运行着各种Pod：
- en: '[PRE23]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can use any of the example Kubernetes objects that we used in this chapter
    or just create your own:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用本章中使用的任何示例Kubernetes对象，或者创建你自己的对象：
- en: '[PRE24]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Eventually, you can try using the Kubernetes Dashboard in your web browser.
    To initialize and open the dashboard, run the following command:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，你可以尝试在web浏览器中使用Kubernetes仪表板。要初始化并打开仪表板，运行以下命令：
- en: '[PRE25]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, we will take a look at another approach to local development that uses
    Docker Desktop for Windows.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看另一种使用Windows Docker桌面版进行本地开发的方法。
- en: Docker Desktop for Windows
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows下的Docker桌面版
- en: For Windows users, using Docker Desktop for Windows and its built-in local Kubernetes
    cluster is the easiest approach. It is also recommended if you are working in
    environments that require a proxy to connect to the internet as the setup is seamless
    and easier compared to minikube.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows用户来说，使用Docker桌面版和其内置的本地Kubernetes集群是最简单的方法。如果你在需要代理连接到互联网的环境中工作，建议使用这种方法，因为与minikube相比，设置是无缝的且更容易。
- en: 'If you haven''t installed Docker Desktop for Windows yet, you should follow
    the instructions in [Chapter 1](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml), *Creating
    Containers*. To enable the local Kubernetes cluster, you need to follow these
    steps:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装Windows Docker桌面版，你应该按照[第1章](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml)
    *创建容器*中的说明进行操作。要启用本地Kubernetes集群，你需要按照以下步骤进行：
- en: Ensure that you are running in Linux containers mode. DockerDesktopVM will be
    responsible for hosting the Kubernetes cluster. To do that, open the tray icon
    for Docker Desktop for Windows and click Switch to Linux containers....
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你正在Linux容器模式下运行。DockerDesktopVM将负责托管Kubernetes集群。为此，打开Windows Docker桌面版的托盘图标，然后点击切换到Linux容器....
- en: When the operation is finished, open Settings from the tray icon.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作完成后，从托盘图标中打开设置。
- en: Open the Kubernetes section.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Kubernetes部分。
- en: Check the Enable Kubernetes checkbox and click Apply.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选启用Kubernetes复选框，然后点击应用。
- en: The setup process will take a few minutes to complete .
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置过程将需要几分钟来完成。
- en: 'If you have set up minikube, you need to **switch context** to kubectl. From
    the command line, run the following command:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经设置了minikube，你需要**切换上下文**到kubectl。从命令行中运行以下命令：
- en: '[PRE26]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Alternatively, you can also switch the context from Docker Desktop from the
    Windows tray:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，你也可以从Windows托盘中切换Docker桌面版的上下文：
- en: '![](assets/68b696e6-7b41-48ac-84a1-1a88a2695862.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/68b696e6-7b41-48ac-84a1-1a88a2695862.png)'
- en: You will learn more about the kubectl configuration and its contexts in [Chapter
    6](791e78c0-f625-4232-9907-36e25ec2767d.xhtml), *Interacting with Kubernetes Clusters*.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在[第6章](791e78c0-f625-4232-9907-36e25ec2767d.xhtml) *与Kubernetes集群交互*中了解更多有关kubectl配置及其上下文的信息。
- en: 'Now, you can start hacking with your local Kubernetes cluster. Let''s deploy
    the Kubernetes Dashboard:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以开始使用本地Kubernetes集群进行开发。让我们部署Kubernetes仪表板：
- en: '[PRE27]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Wait until all the Pods are Running:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待所有的Pod都处于运行状态：
- en: '[PRE28]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Get the default service account token. Copy the `token:` value from the command''s
    output:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取默认服务账户令牌。从命令输出中复制`token:`的值：
- en: '[PRE29]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Enable the kubectl proxy for the cluster. This process should be running while
    you are accessing the dashboard:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为集群启用kubectl代理。在访问仪表板时，这个过程应该在运行中：
- en: '[PRE30]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Navigate to [http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/overview?namespace=kube-system](http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/overview?namespace=kube-system).
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到[http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/overview?namespace=kube-system](http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/overview?namespace=kube-system)。
- en: Select Token, paste your default token, and Sign In.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择令牌，粘贴您的默认令牌，然后登录。
- en: Alternative strategies for setting up a local development Kubernetes cluster with
    Windows containers support involve the automated setup of VMs on your local machine
    using, for example, vagrant. You can explore some of the small projects on GitHub
    that use this approach, but you should expect them to be outdated and no longer
    supported.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Windows容器支持设置本地开发Kubernetes集群的替代策略涉及在本地机器上使用自动设置的VM，例如vagrant。您可以探索GitHub上使用此方法的一些小项目，但您应该期望它们已过时且不再受支持。
- en: In the next section, we will provide a short overview of the production cluster
    deployment strategies that we can perform for Kubernetes clusters, especially
    with Windows nodes.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将简要概述我们可以为Kubernetes集群执行的生产集群部署策略，特别是带有Windows节点的情况。
- en: Production cluster deployment strategies
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产集群部署策略
- en: 'The deployment of production-level clusters and even the development of clusters
    with Windows nodes requires a very different approach. There are three important
    questions that determine your options for the deployment of Kubernetes clusters:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 生产级别集群的部署甚至带有Windows节点的集群的开发需要非常不同的方法。有三个重要问题决定了您部署Kubernetes集群的选项：
- en: Are you deploying the cluster in the cloud or using on-premises bare metal or
    virtual machines?
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您是在云中部署集群还是使用本地裸机或虚拟机？
- en: Do you need **high availability** (**HA**) set up?
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要**高可用性**（**HA**）设置吗？
- en: Do you need Windows containers support?
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要Windows容器支持吗？
- en: Let's summarize the most popular deployment tools currently available.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结目前最流行的部署工具。
- en: kubeadm
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kubeadm
- en: 'The first one is **kubeadm** ([https://github.com/kubernetes/kubeadm](https://github.com/kubernetes/kubeadm)),
    which is a command-line tool focused on getting a minimum viable, secure cluster
    up and running in a user-friendly way. One of the aspects of kubeadm is that it
    is a tool that is scoped only to a given machine and Kubernetes API communication,
    so, in general, it is intended to be a building block for other automation tools
    that manage the cluster as a whole. Its principle is simple: use the `kubeadm
    init` command on master node(s) and `kubeadm join` on worker nodes. The features
    of kubeadm can be summarized as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是**kubeadm** ([https://github.com/kubernetes/kubeadm](https://github.com/kubernetes/kubeadm))，这是一个命令行工具，专注于以用户友好的方式启动并运行最小可行的安全集群。kubeadm的一个方面是，它是一个仅限于给定机器和Kubernetes
    API通信的工具，因此，一般来说，它旨在成为管理整个集群的其他自动化工具的构建块。其原则很简单：在主节点上使用`kubeadm init`命令，在工作节点上使用`kubeadm
    join`。kubeadm的特性可以总结如下：
- en: You can deploy clusters in on-premises environments and cloud environments.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在本地环境和云环境中部署集群。
- en: Highly available clusters are supported but as of version 1.17, this feature
    is still in its beta stage.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高可用集群得到支持，但截至1.17版本，此功能仍处于测试阶段。
- en: Official Windows support is currently planned for version 1.18\. The current
    version of kubeadm is a good base for starting a hybrid Kubernetes cluster. First,
    you bootstrap master node(s) and (optionally) Linux worker nodes and continue
    with the scripts currently provided by Microsoft for joining Windows nodes ([https://github.com/microsoft/SDN](https://github.com/microsoft/SDN))
    or previewing versions of scripts in the sig-windows-tools GitHub repository ([https://github.com/kubernetes-sigs/sig-windows-tools](https://github.com/kubernetes-sigs/sig-windows-tools)).
    We will be using this approach in [Chapter 7](165c2fcc-4ce8-4dbc-a19c-c7fd427b3379.xhtml),
    *Deploying Hybrid On-Premises Kubernetes Cluster*.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前计划在版本1.18上提供官方的Windows支持。当前版本的kubeadm是启动混合Kubernetes集群的良好基础。首先，您可以引导主节点和（可选）Linux工作节点，然后继续使用微软提供的用于加入Windows节点的脚本（[https://github.com/microsoft/SDN](https://github.com/microsoft/SDN)）或在sig-windows-tools
    GitHub存储库中预览脚本的版本（[https://github.com/kubernetes-sigs/sig-windows-tools](https://github.com/kubernetes-sigs/sig-windows-tools)）。我们将在第7章《部署混合本地Kubernetes集群》中使用这种方法。
- en: If you are planning to automate how your Kubernetes cluster is provisioned,
    for example, using Ansible, kubeadm is a good starting point as it provides a
    good degree of flexibility and easy configuration.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划自动化Kubernetes集群的部署方式，例如使用Ansible，kubeadm是一个很好的起点，因为它提供了很大程度的灵活性和易配置性。
- en: kops
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kops
- en: 'The next option is using **Kubernetes Operations** (**kops**, [https://github.com/kubernetes/kops](https://github.com/kubernetes/kops)),
    which uses kubeadm internally. Kops aims to manage whole Kubernetes clusters in
    cloud environments – you can think of it as *kubectl for clusters*. Its main features
    are as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个选项是使用**Kubernetes Operations**（**kops**，[https://github.com/kubernetes/kops](https://github.com/kubernetes/kops)），它在内部使用kubeadm。Kops旨在管理云环境中的整个Kubernetes集群-您可以将其视为*用于集群的kubectl*。其主要特点如下：
- en: Deployment of clusters on Amazon Web Services (officially supported), Google
    Compute Engine, and OpenStack (both in their beta stages). On-premises deployments
    are not supported unless you are running your own deployment of OpenStack. VMware
    vSphere support is in its alpha stage.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Amazon Web Services（官方支持）、Google Compute Engine和OpenStack（它们都处于测试阶段）上部署集群。除非您正在运行自己的OpenStack部署，否则不支持本地部署。VMware
    vSphere支持处于alpha阶段。
- en: Production-level support for HA clusters.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对HA集群的生产级支持。
- en: Windows nodes are not supported.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持Windows节点。
- en: In this book, we will not focus on kops due to its lack of support for Windows.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们不会关注kops，因为它不支持Windows。
- en: kubespray
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kubespray
- en: '**Kubespray** ([https://github.com/kubernetes-sigs/kubespray](https://github.com/kubernetes-sigs/kubespray))
    is a composition of configurable Ansible playbooks that run kubeadm in order to
    bootstrap fully-functional, production-ready Kubernetes clusters. The main difference
    between kubespray and kops is that kops is more tightly integrated with cloud
    providers, whereas kubespray is aimed at multiple platforms, including bare-metal
    deployments. Its features can be summarized as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubespray**（[https://github.com/kubernetes-sigs/kubespray](https://github.com/kubernetes-sigs/kubespray)）是一组可配置的Ansible
    playbooks，运行kubeadm以引导完全功能的、可用于生产的Kubernetes集群。kubespray和kops的主要区别在于，kops与云提供商更紧密集成，而kubespray旨在支持多个平台，包括裸金属部署。其特点可以总结如下：'
- en: Support for installing Kubernetes clusters for multiple cloud providers and
    bare-metal machines.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持为多个云提供商和裸金属机器安装Kubernetes集群。
- en: Production-level support for HA clusters.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对HA集群的生产级支持。
- en: Windows nodes are currently not supported, but with incoming kubeadm support
    for Windows nodes, kubespray is the best candidate to extend its support.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前不支持Windows节点，但随着kubeadm对Windows节点的支持，kubespray是最佳候选来扩展其支持。
- en: As kubespray does not support Windows nodes at this point, we will not focus
    on it in this book.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 由于kubespray目前不支持Windows节点，我们在本书中不会重点介绍它。
- en: AKS Engine
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AKS引擎
- en: '**AKS Engine** ([https://github.com/Azure/aks-engine](https://github.com/Azure/aks-engine))
    is an official, open source tool for provisioning self-managed Kubernetes clusters
    on Azure. It aims at generating **Azure Resource Manager** (**ARM**) templates
    that bootstrap Azure VMs and set up the cluster.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**AKS引擎**（[https://github.com/Azure/aks-engine](https://github.com/Azure/aks-engine)）是一个官方的开源工具，用于在Azure上提供自管理的Kubernetes集群。它旨在生成**Azure资源管理器**（**ARM**）模板，引导Azure虚拟机并设置集群。'
- en: AKS Engine should not be confused with **Azure Kubernetes Service** (**AKS**),
    which is a fully-managed Kubernetes cluster offering by Azure. AKS Engine is used
    by AKS internally, though.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 不应将AKS引擎与**Azure Kubernetes服务**（**AKS**）混淆，后者是Azure提供的完全托管的Kubernetes集群服务。AKS引擎在内部由AKS使用。
- en: 'Its features can be summarized as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 其特点可以总结如下：
- en: Available only for Azure; other platforms are not supported.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅适用于Azure；不支持其他平台。
- en: High availability is implemented through Azure VMSS ([https://kubernetes.io/blog/2018/10/08/support-for-azure-vmss-cluster-autoscaler-and-user-assigned-identity/](https://kubernetes.io/blog/2018/10/08/support-for-azure-vmss-cluster-autoscaler-and-user-assigned-identity/)).
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高可用性是通过Azure VMSS实现的（[https://kubernetes.io/blog/2018/10/08/support-for-azure-vmss-cluster-autoscaler-and-user-assigned-identity/](https://kubernetes.io/blog/2018/10/08/support-for-azure-vmss-cluster-autoscaler-and-user-assigned-identity/)）。
- en: Good Windows support – the official test suites are validated on AKS Engine
    configuration. We'll use this approach in [Chapter 8](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml),  *Deploying
    a Hybrid Azure Kubernetes Engine Service Cluster*.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的Windows支持-官方测试套件在AKS引擎配置上得到验证。我们将在[第8章](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml)中使用这种方法，*部署混合Azure
    Kubernetes引擎服务集群*。
- en: However, please note that AKS Engine offers experimental features that are not
    available as managed AKS offerings yet. This means that this approach may not
    always be suitable for running production workloads, depending on which AKS Engine
    features you use.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，AKS引擎提供了一些实验性功能，这些功能目前作为托管的AKS服务还不可用。这意味着，根据您使用的AKS引擎功能，这种方法可能并不总是适合运行生产工作负载。
- en: Managed Kubernetes providers
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管的Kubernetes提供商
- en: 'As the popularity of Kubernetes constantly grows, there are multiple, **fully-managed**
    Kubernetes offerings being provided by different cloud providers and companies
    specializing in Kubernetes. You can find a long, but not complete, list of Kubernetes
    providers (not only managed) at [https://kubernetes.io/docs/setup/#production-environment](https://kubernetes.io/docs/setup/#production-environment).
    In this section, we will summarize the managed offerings of the tier-1 cloud service
    providers and what they offer in terms of Windows support, namely the following:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Kubernetes的不断普及，不同的云提供商和专门从事Kubernetes的公司提供了多个**完全托管**的Kubernetes服务。您可以在[https://kubernetes.io/docs/setup/#production-environment](https://kubernetes.io/docs/setup/#production-environment)找到一个长长的但不完整的Kubernetes提供商列表（不仅仅是托管）。在本节中，我们将总结一级云服务提供商的托管服务以及它们在Windows支持方面提供的服务，即以下内容：
- en: 'Microsoft Azure: **Azure Kubernetes Service **(**AKS**)'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软Azure：**Azure Kubernetes服务**（**AKS**）
- en: 'Google Cloud Platform: **Google Kubernetes Engine** (**GKE**)'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌云平台：**谷歌Kubernetes引擎**（**GKE**）
- en: Amazon Web Services: **Elastic Kubernetes Service** (**EKS**)
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊网络服务：**弹性Kubernetes服务**（**EKS**）
- en: For** managed** Kubernetes providers, the key principle is that you are not
    responsible for managing the control plane, the data plane, and the underlying
    cluster infrastructure. From your perspective, you get a ready cluster of a given
    size (that may scale on demand) with high availability and the appropriate SLAs
    in place. You just need to deploy your workload! An alternative, less managed
    approach is the **turnkey cloud solution**, where you manage the control plane,
    data plane, and upgrades yourself, but the infrastructure is managed by the cloud
    provider. A good example of such a solution is the **AKS Engine** running on top
    of Azure VMs.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 对于托管的Kubernetes提供商，关键原则是您不负责管理控制平面、数据平面和基础集群基础设施。从您的角度来看，您会得到一个已准备好的集群（可能会根据需求进行扩展），具有高可用性和适当的SLA。您只需要部署您的工作负载！另一种较少托管的方法是**即插即用的云解决方案**，在这种情况下，您自己管理控制平面、数据平面和升级，但基础设施由云提供商管理。这种解决方案的一个很好的例子是在Azure
    VM上运行的**AKS Engine**。
- en: All of these cloud providers have Windows containers support in their managed
    Kubernetes offerings and for all them, this feature is currently in preview. You
    can expect limited support for the feature and limited backward compatibility.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些云提供商在其托管的Kubernetes提供中都支持Windows容器，并且对于所有这些提供商，此功能目前处于预览阶段。您可以期待对该功能的有限支持和有限的向后兼容性。
- en: Azure Kubernetes Service introduced Windows nodes support in May 2019 and is
    the most mature offering for Windows Containers, with good support in its documentation
    ([https://docs.microsoft.com/en-us/azure/aks/windows-container-cli](https://docs.microsoft.com/en-us/azure/aks/windows-container-cli)).
    This offering is built on top of the AKS Engine internally, so you can expect
    similar features to be available there. You can monitor the official roadmap for
    incoming Windows support features by going to [https://github.com/Azure/AKS/projects/1](https://github.com/Azure/AKS/projects/1).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 2019年5月，Azure Kubernetes服务引入了对Windows节点的支持，并且是Windows容器的最成熟的提供者，其文档中有很好的支持（[https://docs.microsoft.com/en-us/azure/aks/windows-container-cli](https://docs.microsoft.com/en-us/azure/aks/windows-container-cli)）。这个提供是在AKS
    Engine内部构建的，因此您可以期待类似的功能也可以在那里使用。您可以通过访问[https://github.com/Azure/AKS/projects/1](https://github.com/Azure/AKS/projects/1)来监视即将到来的Windows支持功能的官方路线图。
- en: Google Kubernetes Engine announced support for Windows Containers in their Rapid
    release channel in May 2019\. Currently, there is limited information available
    about this alpha feature – for Google Cloud Platform, the most common and well-validated
    use case is deploying Kubernetes for Windows directly to Google Compute Engine
    VMs.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: Google Kubernetes引擎在2019年5月宣布在其Rapid发布通道中支持Windows容器。目前，关于这个alpha功能的信息有限-对于Google云平台来说，部署Kubernetes用于Windows直接到Google
    Compute Engine VMs是最常见和经过验证的用例。
- en: 'Amazon Elastic Kubernetes Service announced preview support for Windows Containers
    in March 2019\. You can find more details about Windows Containers support in
    EKS in the official documentation: [https://docs.aws.amazon.com/eks/latest/userguide/windows-support.html](https://docs.aws.amazon.com/eks/latest/userguide/windows-support.html)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 2019年3月，亚马逊弹性Kubernetes服务宣布支持Windows容器的预览。您可以在官方文档中找到有关EKS中Windows容器支持的更多详细信息：[https://docs.aws.amazon.com/eks/latest/userguide/windows-support.html](https://docs.aws.amazon.com/eks/latest/userguide/windows-support.html)
- en: Creating AKS cluster with Windows nodes
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建带有Windows节点的AKS集群
- en: To complete this walkthrough, you need an Azure account and Azure CLI installed
    on your machine. You can find more details in [Chapter 2](43d5e48b-311c-462c-a68e-6a0b5c4224e8.xhtml)*, Managing
    State in Containers*.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个演练，您需要一个Azure账户和在您的机器上安装Azure CLI。您可以在[第2章](43d5e48b-311c-462c-a68e-6a0b5c4224e8.xhtml)中找到更多详细信息，即*在容器中管理状态*。
- en: The following steps are also available as a Powershell script in the official
    GitHub repository for this book: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter04/05_CreateAKSWithWindowsNodes.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter04/05_CreateAKSWithWindowsNodes.ps1).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤也可以在本书的官方GitHub存储库中作为Powershell脚本使用：[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter04/05_CreateAKSWithWindowsNodes.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter04/05_CreateAKSWithWindowsNodes.ps1)。
- en: 'Let''s begin by enabling the preview features for AKS:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始启用AKS的预览功能：
- en: 'Install the `aks-preview` extension using the Azure CLI from Powershell:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Azure CLI从Powershell安装`aks-preview`扩展：
- en: '[PRE31]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Update the `aks-preview` extension to its latest available version:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`aks-preview`扩展更新到最新可用版本：
- en: '[PRE32]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Register the `WindowsPreview` feature flag for your subscription to enable
    multiple node pools. A separate node pool is required for Windows nodes. Note
    that this operation should be performed on test or development subscriptions as
    any cluster that is created after enabling this flag will use this feature:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的订阅注册`WindowsPreview`功能标志，以启用多个节点池。Windows节点需要单独的节点池。请注意，此操作应在测试或开发订阅上执行，因为在启用此标志后创建的任何集群都将使用此功能：
- en: '[PRE33]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This operation will take a few minutes. You have to wait until the `Status`
    of the feature is `Registered` to be able to continue. To check the current `Status`,
    run the following command:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此操作将需要几分钟时间。您必须等到功能的“状态”为“已注册”才能继续。要检查当前的“状态”，运行以下命令：
- en: '[PRE34]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When the feature is registered, execute the following command to propagate
    the change:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当功能注册后，执行以下命令来传播更改：
- en: '[PRE35]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, wait until the provider finishes the registration and switches status
    to `Registered`. You can monitor the status using the following command:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，等待提供程序完成注册并将状态切换为“已注册”。您可以使用以下命令监视状态：
- en: '[PRE36]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The actual cost of AKS is determined by the number and size of the Azure VMs
    that host the cluster. You can find the predicted costs of running an AKS cluster
    here: [https://azure.microsoft.com/en-in/pricing/details/kubernetes-service/](https://azure.microsoft.com/en-in/pricing/details/kubernetes-service/).
    It is advised that you delete the cluster if you are not planning to use it after
    this walkthrough to avoid extra costs.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: AKS的实际成本取决于托管集群的Azure VM的数量和大小。您可以在这里找到运行AKS集群的预测成本：[https://azure.microsoft.com/en-in/pricing/details/kubernetes-service/](https://azure.microsoft.com/en-in/pricing/details/kubernetes-service/)。建议如果您在完成本教程后不打算使用集群，则删除集群以避免额外费用。
- en: 'With the preview feature enabled, you can continue creating the actual AKS
    cluster with Windows nodes. The available versions of Kubernetes depend on the
    location where you create the cluster. In this walkthrough, we suggest using the `westeurope`
    Azure location. Follow these steps to create the cluster:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 启用预览功能后，您可以继续创建具有Windows节点的实际AKS集群。Kubernetes的可用版本取决于您创建集群的位置。在本教程中，我们建议使用`westeurope`
    Azure位置。按照以下步骤创建集群：
- en: 'Create a dedicated resource group for your AKS cluster, for example, `aks-windows-resource-group`:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的AKS集群创建一个专用资源组，例如`aks-windows-resource-group`：
- en: '[PRE37]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Get the list of available Kubernetes versions in a given location:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取给定位置的可用Kubernetes版本列表：
- en: '[PRE38]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Choose the desired one. It is advised that you use the latest one; for example, `1.15.3`.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所需的版本。建议使用最新版本；例如，`1.15.3`。
- en: 'Create an `aks-windows-cluster` AKS instance using the selected version and
    provide the desired Windows username and password (choose a secure one!). The
    following command will create a two-node pool of Linux nodes running in VMSS high-availability
    mode:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所选版本创建一个`aks-windows-cluster` AKS实例，并提供所需的Windows用户名和密码（选择一个安全的！）。以下命令将创建一个运行在VMSS高可用性模式下的Linux节点的两节点池：
- en: '[PRE39]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After a few minutes, when the AKS cluster is ready, add a Windows **node pool**
    named `w1pool` to the cluster – this operation will take a few minutes. There
    is a limit of six characters for the Windows node pool name:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几分钟后，当AKS集群准备就绪时，将一个名为`w1pool`的Windows节点池添加到集群 - 此操作将需要几分钟。Windows节点池名称的字符限制为六个：
- en: '[PRE40]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you do not have `kubectl` installed already, install it using the Azure
    CLI:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尚未安装`kubectl`，请使用Azure CLI进行安装：
- en: '[PRE41]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Get the cluster credentials for `kubectl`. The following command will add a
    new context for `kubectl` and switch to it:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`kubectl`的集群凭据。以下命令将为`kubectl`添加一个新的上下文并切换到它：
- en: '[PRE42]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Verify that the cluster has been deployed successfully! Run any `kubectl` command:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证集群是否已成功部署！运行任何`kubectl`命令：
- en: '[PRE43]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, you can start hacking with your first Kubernetes cluster with Windows
    nodes! For example, create a sample Deployment that runs three replicas of the
    official ASP.NET sample in Windows containers, exposed behind a Service of the
    LoadBalancer type:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以开始使用具有Windows节点的第一个Kubernetes集群进行编程！例如，创建一个示例部署，其中在Windows容器中运行官方ASP.NET示例的三个副本，这些副本位于LoadBalancer类型的服务后面：
- en: '[PRE44]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The container creation process may take up to 10 minutes as the Windows base
    image needs to be pulled first. Wait for the external load balancer IP to be available:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器创建过程可能需要长达10分钟，因为需要首先拉取Windows基础映像。等待外部负载均衡器IP可用：
- en: '[PRE45]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Navigate to the address in a web browser to check if your application is running
    properly:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web浏览器中导航到地址以检查您的应用程序是否正常运行：
- en: '![](assets/f891c6ea-8446-4bd7-b801-4f7362947187.png)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f891c6ea-8446-4bd7-b801-4f7362947187.png)'
- en: To delete the AKS cluster, use the `az group delete --name aks-windows-resource-group --yes
    --no-wait` command.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除AKS集群，请使用`az group delete --name aks-windows-resource-group --yes --no-wait`命令。
- en: Congratulations! You have successfully created your first, fully-managed Kubernetes
    cluster with Windows nodes. In the next few chapters, we will look at different
    approaches for creating Kubernetes clusters with Windows containers support.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功创建了您的第一个完全托管的具有Windows节点的Kubernetes集群。在接下来的几章中，我们将探讨使用不同方法创建支持Windows容器的Kubernetes集群。
- en: Summary
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about the key theory behind Kubernetes – its high-level
    architecture and the most commonly used Kubernetes API objects. On top of that,
    we summarized how Kubernetes currently fits into the Windows ecosystem and the
    current limitations in Windows support. Next, you learned how to set up your own
    Kubernetes development environment for Linux containers using the recommended
    tools, such as minikube and Docker Desktop for Windows, as well as the possible
    production cluster deployment strategies available. Finally, we reviewed the managed
    Kubernetes offerings that support Windows containers and performed a successful
    deployment of Azure Kubernetes Service cluster with the Windows node pool!
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了Kubernetes背后的关键理论 - 其高级架构和最常用的Kubernetes API对象。除此之外，我们总结了Kubernetes目前如何适应Windows生态系统以及Windows支持中的当前限制。接下来，您将学习如何使用推荐工具（如minikube和Docker
    Desktop for Windows）为Linux容器设置自己的Kubernetes开发环境，以及可用的可能的生产集群部署策略。最后，我们回顾了支持Windows容器的托管Kubernetes产品，并成功部署了带有Windows节点池的Azure
    Kubernetes Service集群！
- en: The next chapter will bring you more knowledge regarding Kubernetes architecture
    – Kubernetes networking in general and in the Windows ecosystem. This will be
    the last chapter that focuses on the theory of Kubernetes and its working principles.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将为您带来更多关于Kubernetes架构的知识-一般情况下以及在Windows生态系统中的Kubernetes网络。这将是最后一章，重点关注Kubernetes的理论和工作原理。
- en: Questions
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between the control plane and the data plane in Kubernetes?
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes中控制平面和数据平面之间有什么区别？
- en: How does the declarative model and the concept of desired state work and what
    are its benefits?
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明模型和期望状态的概念是如何工作的，它的好处是什么？
- en: What is the difference between a container and a Pod?
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器和Pod之间有什么区别？
- en: What is the purpose of the Deployment API Object?
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署API对象的目的是什么？
- en: What are the key limitations of Kubernetes support on Windows?
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes在Windows上的主要限制是什么？
- en: What is minikube and when should you use it?
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: minikube是什么，何时应该使用它？
- en: What is the difference between AKS and AKS Engine?
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AKS和AKS Engine之间有什么区别？
- en: You can find answers to these questions in the *Assessments*section of this
    book.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的*评估*部分找到这些问题的答案。
- en: Further reading
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information regarding Kubernetes concepts, please refer to the following
    PacktPub books:'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Kubernetes概念的更多信息，请参考以下PacktPub图书：
- en: '*The Complete Kubernetes Guide* ([https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide))'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完整的Kubernetes指南* ([https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide))'
- en: '*Getting Started with Kubernetes – Third Edition* ([https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition))'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始使用Kubernetes-第三版* ([https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition))'
- en: '*Kubernetes for Developers* ([https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers))'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向开发人员的Kubernetes* ([https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers))'
- en: 'You can also refer to the excellent official Kubernetes documentation ([https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)),
    which is always the most up to date source of knowledge about Kubernetes in general.
    For Windows-specific scenarios, the official Microsoft Virtualization documentation
    is recommended: [https://docs.microsoft.com/en-us/virtualization/windowscontainers/kubernetes/getting-started-kubernetes-windows](https://docs.microsoft.com/en-us/virtualization/windowscontainers/kubernetes/getting-started-kubernetes-windows).'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以参考优秀的官方Kubernetes文档([https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/))，这始终是关于Kubernetes的最新知识来源。对于特定于Windows的场景，建议参考官方的Microsoft虚拟化文档：[https://docs.microsoft.com/en-us/virtualization/windowscontainers/kubernetes/getting-started-kubernetes-windows](https://docs.microsoft.com/en-us/virtualization/windowscontainers/kubernetes/getting-started-kubernetes-windows)。
