- en: Managing State in Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中管理状态
- en: Managing the state of an application is one of the key aspects when architecting
    any software solution, regardless of whether it is a monolith desktop application
    or a complex, distributed system hosted in a cloud environment. Even if most of
    your services in the system are stateless, some part of your system will be stateful,
    for example, a cloud-hosted NoSQL database or a dedicated service you have implemented
    yourself. And if you are aiming at good scalability for your design, you have
    to ensure that the storage for your stateful services scales appropriately. In
    these terms, services or applications hosted in Docker containers are no different
    – you need to manage the state, especially if you want the data to be persisted
    on container restarts or failures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 管理应用程序的状态是架构任何软件解决方案时的关键方面之一，无论是单体桌面应用程序还是托管在云环境中的复杂分布式系统。即使系统中的大多数服务都是无状态的，系统的某些部分将是有状态的，例如，托管在云中的NoSQL数据库或您自己实现的专用服务。如果您希望设计具有良好可扩展性，您必须确保有状态服务的存储能够适当扩展。在这些方面，托管在Docker容器中的服务或应用程序并无二致-您需要管理状态，特别是如果您希望数据在容器重新启动或失败时得以持久化。
- en: In this chapter, we will provide you with a better understanding of how state
    can be persisted in Docker containers running on Windows and how these concepts
    relate to data persistence in Kubernetes applications. You will learn about the
    concepts of *volumes* and *bind mounts* and how they can be used in order to share
    state between containers and the container host.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为您提供更好地理解如何在运行在Windows上的Docker容器中持久化状态以及这些概念与Kubernetes应用程序中数据持久性的关系。您将了解*volumes*和*bind
    mounts*的概念以及它们如何用于在容器和容器主机之间共享状态。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Mounting local volumes for stateful applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载本地卷以用于有状态的应用程序
- en: Using remote/cloud storage for container storage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用远程/云存储进行容器存储
- en: Running clustered solutions inside containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器内运行集群解决方案
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您将需要以下内容：
- en: Windows 10 Pro, Enterprise, or Education (version 1903 or later, 64-bit) installed
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装Windows 10 Pro、企业版或教育版（版本1903或更高版本，64位）
- en: Docker Desktop for Windows 2.0.0.3 or later installed
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装Docker Desktop for Windows 2.0.0.3或更高版本
- en: The installation of Docker Desktop for Windows and its detailed requirements
    were covered in [Chapter 1](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml)*, Creating
    Containers*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Desktop for Windows的安装及其详细要求在[第1章](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml)*，创建容器*中已经涵盖。
- en: 'You will also need your own Azure account. You can read more about how to obtain
    a limited free account for personal use here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要自己的Azure帐户。您可以在此处阅读有关如何获取个人使用的有限免费帐户的更多信息：[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)。
- en: 'You can download the latest code samples for this chapter from this book''s
    official GitHub repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter02).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从本书的官方GitHub存储库下载本章的最新代码示例：[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter02)。
- en: Mounting local volumes for stateful applications
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂载本地卷以用于有状态的应用程序
- en: To understand native Docker storage options for stateful applications, we have
    to take a look at how the layer filesystem is organized. The main role of this
    filesystem service is to provide a single virtual logical filesystem for each
    container based on Docker images.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有状态应用程序的本机Docker存储选项，我们必须看一下层文件系统的组织方式。这个文件系统服务的主要作用是为每个基于Docker镜像的容器提供一个单一的虚拟逻辑文件系统。
- en: 'Docker images consist of a series of read-only layers, where each layer corresponds
    to one instruction in a Dockerfile. Let''s take a look at the following Dockerfile
    from the previous chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像由一系列只读层组成，其中每个层对应于Dockerfile中的一个指令。让我们来看看上一章中的以下Dockerfile：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When building a Docker image, (*almost*) each instruction creates a new layer
    that contains only a set of differences in the filesystem that a given command
    has introduced. In this case, we have the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Docker镜像时，(*几乎*)每个指令都会创建一个新的层，其中包含给定命令引入的文件系统中的一组差异。在这种情况下，我们有以下内容：
- en: '`FROM mcr.microsoft.com/windows/servercore/iis:windowsservercore-1903`: This
    instruction defines the base layer (or a set of layers) from the base image.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM mcr.microsoft.com/windows/servercore/iis:windowsservercore-1903`：这个指令定义了基础层（或一组层）来自基础镜像。'
- en: '`RUN powershell -NoProfile -Command Remove-Item -Recurse C:\inetpub\wwwroot\*`:
    The layer that''s created by this instruction will reflect the deletion of contents
    in the `C:\inetpub\wwwroot\` directory from the original base image.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN powershell -NoProfile -Command Remove-Item -Recurse C:\inetpub\wwwroot\*`：这个指令创建的层将反映从原始基础镜像中删除`C:\inetpub\wwwroot\`目录中内容。'
- en: '`WORKDIR /inetpub/wwwroot`: Even though this instruction is not causing any
    filesystem changes, it will still create **no operation** (**nop**) layer to persist
    this information.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR /inetpub/wwwroot`：即使这个指令不会引起任何文件系统的更改，它仍然会创建**无操作**（**nop**）层来保留这些信息。'
- en: '`COPY index.html .`: This final instruction creates a layer that consists of
    `index.html` in the `C:\inetpub\wwwroot\` directory.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY index.html .`：这个最后的指令创建了一个层，其中包含`C:\inetpub\wwwroot\`目录中的`index.html`。'
- en: 'If you have an existing Docker image, you can inspect the layers yourself using
    the `docker history` command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有现有的Docker镜像，可以使用`docker history`命令自己检查层：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For example, for the image resulting from the preceding Dockerfile, you can
    expect the following output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于前面的Dockerfile生成的图像，您可以期望以下输出：
- en: '![](assets/b0a4b0a1-5d0b-467a-8027-c23e7a0b972d.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b0a4b0a1-5d0b-467a-8027-c23e7a0b972d.png)'
- en: The bottom five layers come from the `mcr.microsoft.com/windows/servercore/iis:windowsservercore-1903`
    base image, whereas the top three layers are a result of the instructions we described
    previously.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的五个层来自`mcr.microsoft.com/windows/servercore/iis:windowsservercore-1903`基础镜像，而顶部的三个层是我们之前描述的指令的结果。
- en: 'When a new container is created, the filesystem for it is created, which consists
    of read-only image layers and a writeable top layer, also called a container layer.
    For the container, the layers are transparent and processes "see" it as a regular
    filesystem – on the Windows system, this is guaranteed by the *Windows Container
    Isolation File System* service*.* Any changes that are made to the container filesystem
    by the processes inside it are persisted in the writeable layer. This concept
    can be seen in the following diagram:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新的容器时，为其创建文件系统，其中包括只读的镜像层和一个可写的顶层，也称为容器层。对于容器，这些层是透明的，进程“看到”它就像是一个常规的文件系统
    - 在Windows系统上，这是由*Windows容器隔离文件系统*服务*保证的。容器内部的进程对容器文件系统所做的任何更改都会在可写层中持久保存。这个概念可以在以下图表中看到：
- en: '![](assets/eb1cb350-5f48-4da0-9990-574cc1f58aae.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/eb1cb350-5f48-4da0-9990-574cc1f58aae.png)'
- en: Now that we know the principles of the layer filesystem in Docker, we can focus
    on *volumes* and *bind mounts*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了Docker中层文件系统的原则，我们可以专注于*卷*和*绑定挂载*。
- en: Volumes and bind mount
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卷和绑定挂载
- en: 'At this point, it may seem that having a writeable container layer for each
    container is enough to provide state persistence for your application. Data is
    persisted, even if you stop and restart the same container afterward. Unfortunately,
    you would easily discover that containers and their writeable layers are tightly
    coupled and that you cannot easily share data between different containers or
    even new instances of the same image. A simple scenario where this becomes apparent
    is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，似乎为每个容器都有一个可写的容器层就足以为应用程序提供状态持久性。即使您停止并重新启动同一个容器，数据也会被持久化。不幸的是，您会很容易发现容器及其可写层是紧密耦合的，您无法轻松地在不同的容器之间甚至同一图像的新实例之间共享数据。一个简单的情景是：
- en: Build a container image based on your current Dockerfile.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于当前的Dockerfile构建一个容器镜像。
- en: Start a new container based on this build.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于此构建启动一个新的容器。
- en: Introduce some modifications to the writeable container layer; for example,
    a process inside the container modifies a file that stores data for the application.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对可写容器层进行一些修改；例如，容器内的一个进程修改了存储应用程序数据的文件。
- en: Now, you would like to create a new version of your image by modifying the Dockerfile
    with additional instructions. At the same time, you want to recreate the container
    and reuse the data in the file that has already been modified in the container's
    writable layer.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您想通过修改Dockerfile并添加额外的指令来创建图像的新版本。与此同时，您希望重新创建容器，并重用已经在容器的可写层中修改过的文件中的数据。
- en: 'You will realize that after recreating the container with the new image version,
    all of the changes that you made to the file using the application state will
    be gone. Apart from this, using the container layer to store data has more disadvantages:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您会意识到，使用新的图像版本重新创建容器后，您使用应用程序状态对文件所做的所有更改都将消失。除此之外，使用容器层来存储数据还有更多的缺点：
- en: The writeable layer is coupled with the container host, which means it isn't
    possible to easily move the data to a different host.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可写层与容器主机紧密耦合，这意味着无法轻松地将数据移动到不同的主机。
- en: Layer filesystems provide worse performance than direct access to the host filesystem.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层文件系统的性能比直接访问主机文件系统差。
- en: You cannot share the writeable layer between different containers.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能在不同的容器之间共享可写层。
- en: A general rule of thumb is to avoid storing data in a writeable container layer,
    especially for I/O-intensive applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验法则是要避免将数据存储在可写的容器层中，特别是对于I/O密集型应用程序。
- en: 'Docker provides two solutions for persistent storage that can be mounted into
    a container: volume and bind mounts. In both cases, the data is exposed as a directory
    in the container filesystem and will be persisted, even if the container is stopped
    and deleted. In terms of performance, both volumes and bind mounts access the
    host''s filesystem directly, which means there is no layer filesystem overhead.
    It is also possible to share data between multiple containers using these Docker
    features.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供了两种持久存储的解决方案，可以挂载到容器中：卷和绑定挂载。在这两种情况下，数据都会暴露为容器文件系统中的一个目录，并且即使容器停止和删除，数据也会被持久化。在性能方面，卷和绑定挂载都直接访问主机的文件系统，这意味着没有层文件系统的开销。还可以使用这些Docker功能在多个容器之间共享数据。
- en: Bind mounts provide a simple functionality of mounting any *file *or *directory*
    from the container host to a given container. This means that a bind mount will
    act as a shared file or directory between the host and a container. In general,
    it is not recommended to use bind mounts as they are harder to manage than volumes,
    but there are certain use cases when bind mounts are useful, especially on the
    Windows platform, where volume support is limited.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定挂载提供了一个简单的功能，可以将容器主机中的任何*文件*或*目录*挂载到给定的容器中。这意味着绑定挂载将充当主机和容器之间共享的文件或目录。一般来说，不建议使用绑定挂载，因为它们比卷更难管理，但在某些情况下，绑定挂载是有用的，特别是在Windows平台上，卷支持有限。
- en: Bind mounts allow you to share any files from the container host. This means
    that if you mount sensitive directories such as `C:\Windows\` to an untrusted
    container, you risk a security breach.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定挂载允许您共享容器主机中的任何文件。这意味着，如果您将敏感目录（例如`C:\Windows\`）挂载到一个不受信任的容器中，您就会面临安全漏洞的风险。
- en: Volumes provide similar functionality to bind mounts but they are fully managed
    by Docker, which means you don't have to worry about physical paths in the container's
    host filesystem. You can create *anonymous* or *named* volumes and then mount
    them into containers. Any data in the volume will not be deleted unless you explicitly
    delete the volume using Docker. A very common use case for volumes is providing
    persistent storage for containers that are running a database instance – when
    the container is recreated, it will use the same volume that contains the data
    that was written by the previous container instance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 卷提供了与绑定挂载类似的功能，但它们由Docker完全管理，这意味着您不必担心容器主机文件系统中的物理路径。您可以创建*匿名*或*命名*卷，然后将它们挂载到容器中。除非您明确使用Docker删除卷，否则卷中的任何数据都不会被删除。卷的一个非常常见的用例是为运行数据库实例的容器提供持久存储
    - 当容器被重新创建时，它将使用包含前一个容器实例写入的数据的相同卷。
- en: The basic functionality of volumes is that they provide storage in the container
    host filesystem. It is also possible to use *volume drivers *(*plugins*), which
    use volume abstraction to access remote cloud storage or network shares. Note
    that, currently, on the Windows platform, there is limited support for volume
    plugins and most of them can only be used on the Linux OS. More on the available
    plugins can be found at [https://docs.docker.com/engine/extend/legacy_plugins/#volume-plugins](https://docs.docker.com/engine/extend/legacy_plugins/#volume-plugins).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 卷的基本功能是在容器主机文件系统中提供存储。还可以使用*卷驱动程序*（*插件*），它们使用卷抽象来访问远程云存储或网络共享。请注意，目前在Windows平台上，对卷插件的支持有限，大多数插件只能在Linux操作系统上使用。有关可用插件的更多信息，请访问[https://docs.docker.com/engine/extend/legacy_plugins/#volume-plugins](https://docs.docker.com/engine/extend/legacy_plugins/#volume-plugins)。
- en: Now, let's take a look at how to perform basic operations on Docker volumes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在Docker卷上执行基本操作。
- en: Creating and mounting volumes
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和挂载卷
- en: 'Creating a new volume can be performed explicitly using the `docker volume
    create` command. It is also possible to create named and anonymous volumes automatically
    when the container starts. To manually create a Docker named volume, follow these
    steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`docker volume create`命令显式地创建新卷。还可以在容器启动时自动创建命名卷和匿名卷。要手动创建Docker命名卷，请按照以下步骤进行操作：
- en: 'Execute the following command:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After creation, you can inspect the details of the volume using the `docker
    volume inspect` command:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建后，可以使用`docker volume inspect`命令检查卷的详细信息：
- en: '![](assets/570e760b-4ffa-4ecf-a854-d552cfbab98c.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/570e760b-4ffa-4ecf-a854-d552cfbab98c.png)'
- en: As you can see, the volume data is stored as a regular directory in the host
    filesystem when using the default *local* driver.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用默认的*local*驱动程序时，卷数据存储为主机文件系统中的常规目录。
- en: 'To mount a volume to a container, you have to use the `--mount` or `--volume`
    (short parameter: `-v`) parameters for the `docker run` command. Originally, `--volume`
    was used for stand-alone containers, whereas `--mount` was used for swarm containers,
    but starting with Docker 17.06, `--mount` can also be used for standalone containers
    and is the recommended practice as it provides more robust options. More about
    these flags can be found in the official documentation: [https://docs.docker.com/storage/volumes/#choose-the--v-or---mount-flag](https://docs.docker.com/storage/volumes/#choose-the--v-or---mount-flag).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要将卷挂载到容器中，您必须使用`docker run`命令的`--mount`或`--volume`（简称参数：`-v`）参数。最初，`--volume`用于独立容器，而`--mount`用于集群容器，但从Docker
    17.06开始，`--mount`也可以用于独立容器，并且是推荐的做法，因为它提供了更强大的选项。有关这些标志的更多信息可以在官方文档中找到：[https://docs.docker.com/storage/volumes/#choose-the--v-or---mount-flag](https://docs.docker.com/storage/volumes/#choose-the--v-or---mount-flag)。
- en: 'Follow these steps to learn how to mount a volume:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何挂载卷：
- en: 'Assuming that you would like to mount `test-named-volume` from the previous
    example in a new PowerShell container under the `C:\Data` directory, you have
    to specify the `--mount` parameter, as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您想要在新的PowerShell容器中将`test-named-volume`从上一个示例挂载到`C:\Data`目录下，您必须指定`--mount`参数，如下所示：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Omitting the `source=<volumeName>` parameter will cause the creation of an *anonymous*
    volume that can be accessed using the volume ID later. Bear in mind that if you
    run a container with the `--rm` option, anonymous volumes will be automatically
    deleted when the container is exited.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 省略`source=<volumeName>`参数将导致创建一个*匿名*卷，稍后可以使用卷ID访问。请记住，如果您使用`--rm`选项运行容器，匿名卷将在容器退出时自动删除。
- en: 'After the container has started and the terminal has been attached, try creating
    a simple file in the directory where a volume has been mounted:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器启动并且终端已附加后，请尝试在已挂载卷的目录中创建一个简单的文件：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, exit the container (which will cause it to stop and be automatically removed
    due to the `--rm` flag) and inspect the volume directory on the host:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，退出容器（这将导致容器停止并由于`--rm`标志而自动删除），并在主机上检查卷目录：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To demonstrate that the named volume can be easily mounted in another container,
    let''s create a new container based on the `mcr.microsoft.com/windows/servercore:1903`
    image and with a volume mount target that''s different from the one in the previous
    example:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了证明命名卷可以轻松地挂载到另一个容器中，让我们基于`mcr.microsoft.com/windows/servercore:1903`镜像创建一个新的容器，并且挂载目标与上一个示例中的不同：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you inspect the volume directory in the container, you will notice that
    the `test.txt` file is present and contains the expected content:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您检查容器中的卷目录，您会注意到`test.txt`文件存在并包含预期的内容：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It is also possible to use the `VOLUME` command in a Dockerfile in order to
    force the automatic creation of a volume on container start, even if the `--mount`
    parameter was not provided for the `docker run` command. This is useful if you
    would like to explicitly inform others of where state data is stored by your application
    and also when you need to ensure that the layer filesystem is not introducing
    additional overhead. You can find an example of the `VOLUME` command''s usage
    in the following Dockerfile in the repository for this book: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile#L44](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile#L44).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在Dockerfile中使用`VOLUME`命令，以便在容器启动时强制自动创建卷，即使未为`docker run`命令提供`--mount`参数。如果您希望明确告知其他人应用程序的状态数据存储在何处，以及需要确保层文件系统不会引入额外的开销，这将非常有用。您可以在本书存储库中的以下Dockerfile中找到`VOLUME`命令的用法示例：[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile#L44](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile#L44)。
- en: In the next subsection, we'll take a quick look at how to remove volumes using
    the Docker CLI.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将快速了解如何使用Docker CLI删除卷。
- en: Removing volumes
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除卷
- en: 'To remove existing named or anonymous volumes using the `docker volume rm`
    command, they cannot be used in any container (even stopped ones). The standard
    procedure would be as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`docker volume rm`命令删除现有的命名或匿名卷，它们不能在任何容器中使用（即使是停止的容器）。标准流程如下：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For anonymous volumes, if you use the `--rm` flag for the `docker run` command,
    the container will be removed on exit, along with its anonymous volumes. This
    flag should be used depending on the scenario – in most cases, it is useful for
    testing and development purposes to make cleanup easier.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于匿名卷，如果在`docker run`命令中使用`--rm`标志，容器将在退出时被删除，连同其匿名卷。这个标志应根据情况使用——在大多数情况下，它对于测试和开发目的很有用，以便更轻松地进行清理。
- en: 'During development, you may occasionally need to perform a full cleanup of
    all of the volumes on your Docker host, for example, if you need to free disk
    space. The Docker CLI provides a dedicated command that will remove any volumes
    that are not used in any container:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，您可能偶尔需要对Docker主机上的所有卷进行全面清理，例如，如果您需要释放磁盘空间。Docker CLI提供了一个专用命令，将删除任何未在任何容器中使用的卷：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we will take a look at bind mounts and how they differ from volumes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下绑定挂载及其与卷的区别。
- en: Mounting a local container host directory using bind mounts
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用绑定挂载挂载本地容器主机目录
- en: 'Bind mounts are the simplest form of persistent storage that is shared between
    the container and the host machine. In this way, you can mount any existing directory
    from the host filesystem in the container. It is also possible to "overwrite"
    an existing directory in the container with host directory contents, which may
    be useful in some scenarios. In general, volumes are the recommended storage solution,
    but there are a few cases where bind mounts can be useful:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定挂载是容器和主机机器之间共享的最简单的持久存储形式。通过这种方式，您可以在容器中挂载主机文件系统中的任何现有目录。还可以使用主机目录内容“覆盖”容器中的现有目录，这在某些情况下可能很有用。一般来说，卷是推荐的存储解决方案，但有一些情况下绑定挂载可能会有用：
- en: Sharing configuration between the host and the container. A common use case
    may be DNS configuration or the `hosts` file.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主机和容器之间共享配置。一个常见的用例可能是DNS配置或`hosts`文件。
- en: In development scenarios, sharing build artifacts that were created on the host
    so that they can be consumed inside the container.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发场景中，共享在主机上创建的构建产物，以便它们可以在容器内使用。
- en: On Windows, mounting SMB file shares as directories in the container.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 上，将 SMB 文件共享挂载为容器中的目录。
- en: Volumes can be seen as an *evolution* of bind mounts. They are fully managed
    by Docker, without tight coupling to the container host filesystem being visible
    to the user.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 卷可以被视为绑定挂载的 *演进*。它们由 Docker 完全管理，用户看不到与容器主机文件系统的紧密耦合。
- en: 'Creating a bind mount for a container requires the `docker run` command to
    be specified with an additional parameter, `type=bind`, for the `--mount` flag.
    In this example, we will mount the host''s `C:\Users` directory as `C:\HostUsers`
    in the container:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为容器创建绑定挂载需要在 `docker run` 命令中指定一个额外的参数 `type=bind`，用于 `--mount` 标志。在这个例子中，我们将主机的
    `C:\Users` 目录挂载为容器中的 `C:\HostUsers`：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can verify that any changes performed to `C:\HostUsers` will also be visible
    on the host machine in `C:\Users`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以验证对 `C:\HostUsers` 所做的任何更改也会在主机机器的 `C:\Users` 中可见。
- en: 'Windows-specific features and the limitations of bind mounts can be found in
    the official documentation from Microsoft: [https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/container-storage#bind-mounts](https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/container-storage#bind-mounts).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Windows 特定功能和绑定挂载的限制，请参阅 Microsoft 的官方文档：[https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/container-storage#bind-mounts](https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/container-storage#bind-mounts)。
- en: In the next section, we are going to learn how to leverage bind mounts in order
    to use remote or cloud storage in Windows containers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何利用绑定挂载来在 Windows 容器中使用远程或云存储。
- en: Using remote/cloud storage for container storage
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用远程/云存储作为容器存储
- en: 'Storing data locally in a container host filesystem is not suitable for use
    cases that require high-availability, failover, and ease of data backup. In order
    to provide storage abstraction, Docker provides volume drivers (plugins), which
    can be used to manage volumes that are hosted on remote machines or in cloud services.
    Unfortunately, at the time of writing this book, Windows containers running on-premises
    do not support the volume plugins that are currently available on Linux OS. This
    leaves us with three choices when it comes to using cloud storage in Windows containers:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器主机文件系统中存储数据不适用于需要高可用性、故障转移和数据备份便捷性的用例。为了提供存储抽象，Docker 提供了卷驱动程序（插件），可用于管理托管在远程机器或云服务中的卷。不幸的是，在撰写本书时，运行在本地的
    Windows 容器不支持当前在 Linux OS 上可用的卷插件。这使我们在使用 Windows 容器中的云存储时有三种选择：
- en: Use Docker for Azure and the Cloudstor volume plugin, which is a partially managed
    solution for running Docker in *swarm* mode on Azure VMs. In this book, we will
    not cover Docker for Azure as this solution is separate from Kubernetes, including
    Azure offerings for managed Kubernetes. If you are interested in more details
    about this service, please refer to [https://docs.docker.com/docker-for-azure/persistent-data-volumes/](https://docs.docker.com/docker-for-azure/persistent-data-volumes/).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker for Azure 和 Cloudstor 卷插件，这是在 Azure VM 上以 *swarm* 模式运行 Docker 的部分托管解决方案。在本书中，我们不会涵盖
    Docker for Azure，因为这个解决方案与 Kubernetes 分开，包括 Azure 提供的托管 Kubernetes 的服务。如果您对此服务的更多细节感兴趣，请参阅
    [https://docs.docker.com/docker-for-azure/persistent-data-volumes/](https://docs.docker.com/docker-for-azure/persistent-data-volumes/)。
- en: Use cloud storage directly in application code using cloud service provider
    SDKs. This is the most obvious solution, but it requires embedding storage management
    into your application code.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序代码中直接使用云存储，使用云服务提供商的SDK。这是最明显的解决方案，但它需要将存储管理嵌入到应用程序代码中。
- en: Use bind mounts and **Server Message Block** (**SMB**) global mappings in order
    to mount Azure Files, which is a fully managed cloud file share that can be accessed
    via the SMB protocol.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用绑定挂载和**服务器消息块**（**SMB**）全局映射来挂载Azure Files，这是一个完全托管的云文件共享，可以通过SMB协议访问。
- en: 'Soon, we will demonstrate how to leverage the last option: SMB global mappings
    for Azure Files. But first, we have to install the Azure CLI in order to manage
    Azure resources.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们将演示如何利用最后一个选项：Azure Files的SMB全局映射。但首先，我们必须安装Azure CLI以管理Azure资源。
- en: Installing the Azure CLI and Azure PowerShell module
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Azure CLI和Azure PowerShell模块
- en: 'In order to manage Azure resources efficiently from the command line, it is
    recommended to use the official Azure CLI. The official installation notes can
    be found at [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?view=azure-cli-latest).
    Let''s get started:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从命令行高效地管理Azure资源，建议使用官方的Azure CLI。官方安装说明可以在[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-windows?view=azure-cli-latest)找到。让我们开始吧：
- en: 'Installing the Azure CLI from PowerShell requires running the following commands
    as an Administrator:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从PowerShell安装Azure CLI需要以管理员身份运行以下命令：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After installing the Azure CLI, you need to restart your PowerShell window.
    Next, log in to your Azure account:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Azure CLI后，您需要重新启动PowerShell窗口。接下来，登录到您的Azure帐户：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding command will open your default browser and instruct you to log
    in to your Azure account.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将打开您的默认浏览器，并指示您登录到您的Azure帐户。
- en: 'Now, run the following command to verify that you have been logged in properly:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行以下命令来验证您已经正确登录：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should be able to see your subscription details, similar to this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够看到您的订阅详细信息，类似于这样：
- en: '![](assets/ad13b529-964b-49e8-8597-de51cc5f9edb.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ad13b529-964b-49e8-8597-de51cc5f9edb.png)'
- en: On top of that, we need to install the Azure PowerShell module since some operations
    are not available in the Azure CLI.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们还需要安装Azure PowerShell模块，因为一些操作在Azure CLI中不可用。
- en: 'Installation for the currently logged-in user can be performed using the following
    command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用以下命令为当前登录的用户安装：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The official installation steps can be found here: [https://docs.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-2.5.0#install-the-azure-powershell-module-1](https://docs.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-2.5.0#install-the-azure-powershell-module-1).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 官方安装步骤可以在这里找到：[https://docs.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-2.5.0#install-the-azure-powershell-module-1](https://docs.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-2.5.0#install-the-azure-powershell-module-1)。
- en: 'If you run into problems while importing the newly installed module, you''ll
    also need to set a PowerShell execution policy to `RemoteSigned` as an Administrator:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在导入新安装的模块时遇到问题，您还需要以管理员身份设置PowerShell执行策略为`RemoteSigned`：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Logging in to Azure using the PowerShell module has to be done separately from
    the Azure CLI and can be performed using the following command:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用PowerShell模块登录到Azure必须与Azure CLI分开进行，并可以使用以下命令执行：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At this point, you should be able to manage your resources using the Azure CLI
    and the Azure PowerShell module, without opening the Azure Portal website! Let's
    take a look at how to create an Azure Files SMB share.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该能够使用Azure CLI和Azure PowerShell模块来管理您的资源，而无需打开Azure门户网站！让我们看看如何创建Azure
    Files SMB共享。
- en: Creating Azure Files SMB share
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Azure Files SMB共享
- en: 'Assuming that you are following along with these examples on a fresh Azure
    subscription, let''s create an Azure Resource Group and Azure Storage Account
    first:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在使用全新的Azure订阅进行这些示例演练，让我们首先创建一个Azure资源组和Azure存储帐户：
- en: 'In a PowerShell window, execute the following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PowerShell窗口中，执行以下代码：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can choose a location that is the most suitable for you (in order to show
    a list of available locations, run `az account list-locations`). In this example,
    we are using the `westeurope` Azure location.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择最适合您的位置（为了显示可用位置的列表，请运行`az account list-locations`）。在这个例子中，我们使用`westeurope`
    Azure位置。
- en: 'You can also use the PowerShell script in this book''s GitHub repository to
    do this: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/01_CreateAzureFilesSMBShare.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/01_CreateAzureFilesSMBShare.ps1).
    Remember to run this script as an Administrator since global mappings for SMB
    share must be added from a privileged account.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用本书的GitHub存储库中的PowerShell脚本来执行此操作：[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/01_CreateAzureFilesSMBShare.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/01_CreateAzureFilesSMBShare.ps1)。请记住以管理员身份运行此脚本，因为必须从特权帐户添加SMB共享的全局映射。
- en: 'After the successful creation of an Azure Resource Group, continue by creating
    an Azure Storage Account:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功创建Azure资源组后，继续创建Azure存储帐户：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding command will create a `general-purpose v2` storage account with
    `read-access geo-redundant` storage called `dockerstorageaccount` in `docker-storage-resource-group`.
    This operation can take up to a few minutes to complete.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在`docker-storage-resource-group`中创建一个名为`dockerstorageaccount`的`general-purpose
    v2`存储帐户，其中包含`read-access geo-redundant`存储。此操作可能需要几分钟才能完成。
- en: 'Next, you have to create the actual Azure Files SMB share. First, create a
    connection string for your Azure Storage Account and store it as a variable in
    PowerShell:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您必须创建实际的Azure Files SMB共享。首先，为您的Azure存储帐户创建连接字符串，并将其存储为PowerShell中的变量：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Remember to keep the connection string safe as it can be used to manage your
    storage account!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住保护好连接字符串，因为它可以用来管理您的存储帐户！
- en: 'Using the connection string stored in the `$azureStorageAccountConnString`
    variable, create the share:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用存储在`$azureStorageAccountConnString`变量中的连接字符串，创建共享：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will create a share called `docker-bind-mount-share` with a quota limit
    of 2 GB, which we will now use in our Docker container.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`docker-bind-mount-share`的共享，配额限制为2GB，我们将在Docker容器中使用它。
- en: Mounting Azure Files SMB share in a container
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中挂载Azure Files SMB共享
- en: 'In order to mount the new Azure Files SMB share as a bind mount in a container,
    we will leverage the *SMB Global Mapping* feature that was introduced in Window
    Server 1709\. Global mappings have been introduced specifically for this purpose,
    that is, mounting SMB shares on the host so that they''re visible to containers.
    Let''s get started:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将新的Azure Files SMB共享作为容器中的绑定挂载，我们将利用在Window Server 1709中引入的*SMB全局映射*功能。全局映射是专门为此目的而引入的，即在主机上挂载SMB共享，以便它们对容器可见。让我们开始吧：
- en: First, ensure that you are logged in so that you can execute Azure PowerShell
    (using the `Connect-AzAccount` command).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先确保您已登录，以便可以执行Azure PowerShell（使用`Connect-AzAccount`命令）。
- en: 'Next, let''s define a few variables that will be used in the commands we''ll
    execute soon:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义一些变量，这些变量将在我们即将执行的命令中使用：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The names being used here are exactly the same as the ones we used in the previous
    subsection while creating the Azure Files SMB share.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的名称与我们在上一小节中创建Azure Files SMB共享时使用的名称完全相同。
- en: 'The next step is to define the `$storageAccount` and `$storageAccountKeys`
    variables:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是定义`$storageAccount`和`$storageAccountKeys`变量：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These variables will be used for the retrieval of file share details and credentials
    for access, both of which are needed for SMB Global Mapping.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量将用于检索文件共享详细信息和访问凭据，这两者都是SMB全局映射所需的。
- en: 'Now, *optionally*, you can persist your share credentials in Windows Credential
    Manager using the `cmdkey` command:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，*可选地*，您可以使用`cmdkey`命令将共享凭据持久保存在Windows凭据管理器中：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will also need details regarding Azure Files SMB share, so let''s define
    a new variable called `$fileShare`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要关于Azure Files SMB共享的详细信息，因此让我们定义一个名为`$fileShare`的新变量：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'At this point, you can also check if the file share details have been retrieved
    successfully. By doing this, you will be able to detect if, for example, `$fileShareName`
    contains the wrong share name:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，您还可以检查文件共享详细信息是否已成功检索。通过这样做，您将能够检测出例如`$fileShareName`是否包含了错误的共享名称：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last step, before creating an SMB Global Mapping, is to define a credentials
    object, which will be used for mapping creation:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建SMB全局映射之前的最后一步是定义一个凭据对象，该对象将用于映射创建：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we can use the `New-SmbGlobalMapping` command in order to create the
    mapping for Azure Files SMB share:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`New-SmbGlobalMapping`命令来为Azure Files SMB共享创建映射：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you need to remove SMB Global Mapping, you can do so using the `Remove-SmbGlobalMapping`
    command.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要删除SMB全局映射，可以使用`Remove-SmbGlobalMapping`命令来执行。
- en: The preceding command will mount your Azure Files SMB share persistently as
    the `G:` drive. You can use this path later for bind mounts for Docker containers.
    Now, you can test if your mapping works correctly by moving some test files to
    the `G:` drive using Windows Explorer.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将持久地将Azure Files SMB共享挂载为`G:`驱动器。您可以稍后使用此路径进行Docker容器的绑定挂载。现在，您可以通过使用Windows资源管理器将一些测试文件移动到`G:`驱动器来测试您的映射是否正常工作。
- en: 'The principle of using bind mount for a globally mapped SMB share can be used
    for any SMB-compatible server, such as the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绑定挂载进行全局映射的SMB共享的原则可以用于任何兼容SMB的服务器，例如以下服务器：
- en: A traditional file server hosted in your local network
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的本地网络中托管的传统文件服务器
- en: A third-party implementation of the SMB protocol,such as NAS appliances
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SMB协议的第三方实现，例如NAS设备
- en: A traditional SAN or **Scale-out File Server** (**SoFS**) on top of **Storage
    Spaces Direct** (**S2D**)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于存储空间直通（S2D）的传统SAN或**分布式文件服务器**（**SoFS**）
- en: Globally mapped SMB shares, when used as bind mounts, are transparently visible
    for the containers as regular directories in the local filesystem. All of the
    "heavy lifting" is performed by the container host, which is responsible for managing
    the SMB share connection.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为绑定挂载使用时，全局映射的SMB共享对容器来说是透明可见的，就像本地文件系统中的常规目录一样。所有的“繁重工作”都是由容器主机执行的，它负责管理SMB共享连接。
- en: 'Let''s demonstrate this feature by creating a simple PowerShell process-isolated
    container:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个简单的PowerShell进程隔离容器来演示这个功能：
- en: 'First, create a directory called `G:\ContainerData` in the SMB share for our
    demonstration container:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在我们的演示容器的SMB共享中创建一个名为`G:\ContainerData`的目录：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we can run the container by providing the new directory in the Azure Files
    SMB share as a bind mount with `C:\Data` as the target:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过将Azure Files SMB共享中的新目录作为绑定挂载并将`C:\Data`作为目标来运行容器：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this, we can easily prove that our solution works and that the container
    state files are indeed stored in Azure Cloud!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以轻松证明我们的解决方案有效，并且容器状态文件确实存储在Azure Cloud中！
- en: 'In the running container, create a file that contains data. For example, get
    a list of the currently running processes and store it as a `processes.txt` file:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行的容器中，创建一个包含数据的文件。例如，获取当前运行的进程列表，并将其存储为`processes.txt`文件：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, log in to Azure Portal (`https://portal.azure.com/`) and do the following:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，登录到Azure门户（`https://portal.azure.com/`）并执行以下操作：
- en: Navigate to Storage accounts from the main menu.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单导航到存储账户。
- en: Open the dockerstorageaccount account.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开dockerstorageaccount账户。
- en: In the storage account menu, open Files under the File service group.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在存储账户菜单中，打开文件服务组下的文件。
- en: Open the docker-bind-mount-share file share from the list.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中打开docker-bind-mount-share文件共享。
- en: 'You will see a familiar directory structure. Navigate into the ContainerData
    directory to see that the `processes.txt` file is indeed there and contains the
    data that was stored in the container:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个熟悉的目录结构。进入ContainerData目录，看到`processes.txt`文件确实存在，并包含在容器中存储的数据：
- en: '![](assets/5fa27a7f-8af4-4b69-ac32-1837119a24db.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5fa27a7f-8af4-4b69-ac32-1837119a24db.png)'
- en: 'In Kubernetes, a similar procedure can be performed in a managed way using
    *volumes* (not to be confused with Docker volumes). We will focus on this in [Chapter
    11](9ad8c38e-6d0d-435b-a46c-82a468f18007.xhtml), *Configuring Applications to
    Use Kubernetes Features*. You can also refer to the official documentation: [https://kubernetes.io/docs/concepts/storage/](https://kubernetes.io/docs/concepts/storage/).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，可以使用*volumes*（不要与Docker卷混淆）以受控方式执行类似的过程。我们将在[第11章](9ad8c38e-6d0d-435b-a46c-82a468f18007.xhtml)中重点介绍这一点，*配置应用程序以使用Kubernetes功能*。您也可以参考官方文档：[https://kubernetes.io/docs/concepts/storage/](https://kubernetes.io/docs/concepts/storage/)。
- en: Please note that this scenario can also be achieved with a regular SMB File
    Server hosted in your local network, which may be a suitable solution if you use
    them in your infrastructure already.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种情况也可以通过在本地网络中托管常规SMB文件服务器来实现，如果您已经在基础架构中使用它们，这可能是一个合适的解决方案。
- en: Congratulations! You have successfully created a Windows container that uses
    Azure Cloud storage to persist container state. In the next section, we will learn
    how to run MongoDB inside Windows containers as an example of a multi-container
    solution.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功创建了一个使用Azure Cloud存储来持久保存容器状态的Windows容器。在下一节中，我们将学习如何在Windows容器中运行MongoDB，作为多容器解决方案的示例。
- en: Running clustered solutions inside containers
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器内运行集群解决方案
- en: MongoDB is a free and open source cross-platform, document-oriented database
    program that can run in cluster mode (using shards and ReplicaSets). In this example,
    we will run a three-node MongoDB ReplicaSet as that is much easier to configure
    than a full sharded cluster and is sufficient to demonstrate the principle of
    storing container state data persistently.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一个免费的开源跨平台、面向文档的数据库程序，可以在集群模式下运行（使用分片和副本集）。在这个例子中，我们将运行一个三节点的MongoDB副本集，因为这比完整的分片集群更容易配置，并且足以演示持久存储容器状态数据的原理。
- en: 'If you would like to learn more about MongoDB and advanced sharded cluster
    components, please refer to the official documentation: [https://docs.mongodb.com/manual/core/sharded-cluster-components/](https://docs.mongodb.com/manual/core/sharded-cluster-components/).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于MongoDB和高级分片集群组件的信息，请参考官方文档：[https://docs.mongodb.com/manual/core/sharded-cluster-components/](https://docs.mongodb.com/manual/core/sharded-cluster-components/)。
- en: 'Our MongoDB ReplicaSet architecture will look as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的MongoDB副本集架构将如下所示：
- en: '![](assets/e4ed078e-6bb7-4908-9eb9-bb8a33c4d258.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e4ed078e-6bb7-4908-9eb9-bb8a33c4d258.png)'
- en: 'The primary node is responsible for managing all write operations, and there
    can only be one primary in a ReplicaSet. The secondary nodes are only replicating
    the primary''s *oplog* and apply the data operations so that their datasets reflect
    the dataset of the primary. The main benefits of such a MongoDB deployment are
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 主节点负责管理所有写操作，在ReplicaSet中只能有一个主节点。次要节点只复制主节点的*oplog*并应用数据操作，以便它们的数据集反映主节点的数据集。这种MongoDB部署的主要好处如下：
- en: '**Automatic failover**: If the primary becomes unavailable, the rest of the
    secondary nodes will perform new leader election and resume cluster functionality.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动故障转移**：如果主节点不可用，其余次要节点将执行新的领导者选举并恢复集群功能。'
- en: '**Possibility to use secondaries to read data**: You can specify read preference
    so that clients offload the primary for read operations. However, you have to
    take note of the fact that asynchronous replication may result in secondaries
    being slightly off-sync with the primary node.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可以使用次要节点读取数据**：您可以指定读取偏好，以便客户端将主节点的读取操作卸载。但是，您必须注意异步复制可能导致次要节点与主节点略有不同步。'
- en: Now, let's create our MongoDB ReplicaSet!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的MongoDB ReplicaSet！
- en: Creating a MongoDB ReplicaSet
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MongoDB ReplicaSet
- en: 'Follow these steps to create the ReplicaSet:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建ReplicaSet：
- en: 'First, let''s create a Docker network called `mongo-cluster` for the new cluster
    using the `docker network create` command:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用`docker network create`命令为新集群创建一个名为`mongo-cluster`的Docker网络：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you would like to learn more about Docker networks, please refer to the
    official documentation: [https://docs.docker.com/network/](https://docs.docker.com/network/).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关Docker网络的更多信息，请参考官方文档：[https://docs.docker.com/network/](https://docs.docker.com/network/)。
- en: For Windows-specific documentation, please go to [https://docs.microsoft.com/en-us/virtualization/windowscontainers/container-networking/network-drivers-topologies](https://docs.microsoft.com/en-us/virtualization/windowscontainers/container-networking/network-drivers-topologies).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有关特定于Windows的文档，请访问[https://docs.microsoft.com/en-us/virtualization/windowscontainers/container-networking/network-drivers-topologies](https://docs.microsoft.com/en-us/virtualization/windowscontainers/container-networking/network-drivers-topologies)。
- en: We will use Azure Files SMB share (globally mapped to the `G:` drive), which
    we created in the previous section, in order to store MongoDB's state using bind
    mounts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Azure Files SMB共享（全局映射到`G:`驱动器），这是我们在上一节中创建的，以便使用绑定挂载存储MongoDB的状态。
- en: 'We need to create new directories in our SMB share, two for each MongoDB node:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在我们的SMB共享中创建新的目录，每个MongoDB节点需要两个：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Currently, the official MongoDB image for Windows only exists in Windows Server
    Core 1803, which means we would have to use Hyper-V isolation to run such containers
    on Windows 1903\. This means that we can''t leverage SMB Global Mappings, so we
    need to create our own MongoDB image based on Windows Server Core 1903\. This
    will make it possible for us to use process isolation. The image we are going
    to build is based on the official MongoDB image for the 4.2.0 RC8 version, which
    can be found here: [https://github.com/docker-library/mongo/blob/a3a213fd2b4b2c26c71408761534fc7eaafe517f/4.2-rc/windows/windowsservercore-1803/Dockerfile](https://github.com/docker-library/mongo/blob/a3a213fd2b4b2c26c71408761534fc7eaafe517f/4.2-rc/windows/windowsservercore-1803/Dockerfile).
    To perform the build, follow these steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Windows的官方MongoDB镜像仅存在于Windows Server Core 1803中，这意味着我们必须使用Hyper-V隔离在Windows
    1903上运行这些容器。这意味着我们无法利用SMB全局映射，因此我们需要基于Windows Server Core 1903创建自己的MongoDB镜像。这将使我们能够使用进程隔离。我们要构建的镜像是基于4.2.0
    RC8版本的官方MongoDB镜像，可以在这里找到：[https://github.com/docker-library/mongo/blob/a3a213fd2b4b2c26c71408761534fc7eaafe517f/4.2-rc/windows/windowsservercore-1803/Dockerfile](https://github.com/docker-library/mongo/blob/a3a213fd2b4b2c26c71408761534fc7eaafe517f/4.2-rc/windows/windowsservercore-1803/Dockerfile)。要执行构建，请按照以下步骤进行：
- en: 'Download the Dockerfile from this book''s GitHub repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile).'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本书的GitHub存储库下载Dockerfile：[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile)。
- en: In PowerShell, navigate to the location where you downloaded the Dockerfile
    (using a new, separate directory is recommended).
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PowerShell中，导航到您下载Dockerfile的位置（建议使用新的、单独的目录）。
- en: 'Execute the `docker build` command in order to create a custom MongoDB image
    named `mongo-1903` in your local image registry:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`docker build`命令，以在本地镜像注册表中创建一个名为`mongo-1903`的自定义MongoDB镜像：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The build process will take a few minutes as MongoDB has to be downloaded and
    installed in the build container.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程将需要几分钟，因为MongoDB必须在构建容器中下载和安装。
- en: 'This image also exposes the MongoDB data as volumes under `C:\data\db` and
    `C:\data\configdb` inside the container ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile#L44](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile#L44)).
    Taking all of these into account, let''s create our first MongoDB process-isolated
    container named `mongo-node1`, which will be running in the background (using
    the `-d` option):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 该镜像还将MongoDB数据公开为容器内的`C:\data\db`和`C:\data\configdb`卷（[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile#L44](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/03_MongoDB_1903/Dockerfile#L44)）。考虑到所有这些，让我们创建我们的第一个MongoDB进程隔离容器，命名为`mongo-node1`，它将在后台运行（使用`-d`选项）：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When running this container, we are providing a custom command to run the container
    process, that is, `mongod --bind_ip_all --replSet replSet0`. The `--bind_ip_all`
    argument instructs MongoDB to bind to all the network interfaces that are available
    in the container. For our use case, the `--replSet replSet0` argument ensures
    that the daemon runs in ReplicaSet mode, expecting to be in a ReplicaSet named
    `replSet0`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此容器时，我们提供了一个自定义命令来运行容器进程，即`mongod --bind_ip_all --replSet replSet0`。`--bind_ip_all`参数指示MongoDB绑定到容器中可用的所有网络接口。对于我们的用例，`--replSet
    replSet0`参数确保守护程序以ReplicaSet模式运行，期望在名为`replSet0`的ReplicaSet中。
- en: 'After the successful creation of the first node, repeat this process for the
    next two nodes, changing their name and volume mount points appropriately:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 成功创建第一个节点后，重复此过程用于下两个节点，适当更改它们的名称和卷挂载点：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After the creation process has finished, you can verify that the containers
    are running properly using the `docker ps` command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建过程完成后，您可以使用 `docker ps` 命令验证容器是否正常运行：
- en: '![](assets/6516dce2-6200-447b-ab62-59d2da30d6fd.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6516dce2-6200-447b-ab62-59d2da30d6fd.png)'
- en: 'The preceding steps have also been provided as a PowerShell script in this
    book''s GitHub repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/02_InitializeMongoDBReplicaSet.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/02_InitializeMongoDBReplicaset.ps1).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤也已经作为 PowerShell 脚本提供在本书的 GitHub 仓库中：[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/02_InitializeMongoDBReplicaset.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter02/02_InitializeMongoDBReplicaset.ps1)。
- en: 'The next stage is to configure the ReplicaSet. We will do this using the mongo
    shell. Follow these steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的阶段是配置 ReplicaSet。我们将使用 mongo shell 来完成这个过程。按照以下步骤进行：
- en: 'Create an instance of the mongo shell. If you''re already running a MongoDB
    container (for example,`mongo-node1`), the easiest way to do this is to `exec`
    into an existing container and run the`mongo` process:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 mongo shell 实例。如果您已经运行了一个 MongoDB 容器（例如，`mongo-node1`），最简单的方法是 `exec` 进入现有容器并运行
    `mongo` 进程：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After a few seconds, you should see the mongo shell console prompt, `>`. You
    can initialize the ReplicaSet using the `rs.initiate()` method:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，您应该会看到 mongo shell 控制台提示符 `>`。您可以使用 `rs.initiate()` 方法初始化 ReplicaSet：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding command creates a ReplicaSet called `replSet0` using our three
    nodes. These can be identified by their DNS names in the `mongo-cluster` Docker
    network.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令使用我们的三个节点在 `mongo-cluster` Docker 网络中创建了一个名为 `replSet0` 的 ReplicaSet。这些节点可以通过它们在
    `mongo-cluster` Docker 网络中的 DNS 名称进行识别。
- en: 'For more details regarding the initialization of ReplicaSets, please refer
    to the official documentation: [https://docs.mongodb.com/manual/reference/method/rs.initiate/](https://docs.mongodb.com/manual/reference/method/rs.initiate/).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有关初始化 ReplicaSets 的更多详细信息，请参考官方文档：[https://docs.mongodb.com/manual/reference/method/rs.initiate/](https://docs.mongodb.com/manual/reference/method/rs.initiate/)。
- en: 'You can also verify the state of initialization using the `rs.status()` command
    in the mongo shell. After a short time, when the ReplicaSet is fully initialized,
    in the command JSON output, you should be able to see the ReplicaSet in one node
    with `"stateStr": "PRIMARY"` and two other nodes with `"stateStr": "SECONDARY"`
    in the command''s output.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '您还可以使用 mongo shell 中的 `rs.status()` 命令来验证初始化状态。在一段时间后，当 ReplicaSet 完全初始化时，在命令的
    JSON 输出中，您应该能够看到一个节点中的 ReplicaSet 的 `"stateStr": "PRIMARY"`，以及另外两个节点中的 `"stateStr":
    "SECONDARY"`。'
- en: In the next subsection, we will quickly verify our ReplicaSet by generating
    test data and reading it in another container.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将通过在另一个容器中生成测试数据并读取它来快速验证我们的 ReplicaSet。
- en: Writing and reading test data
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写和读取测试数据
- en: 'Follow these steps to write and read test data:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤编写和读取测试数据：
- en: 'First, in the mongo shell for the ReplicaSet primary node (as a prompt, you
    will see `replSet0:PRIMARY>` ), let''s add 1,000 sample documents in the `demo`
    collection:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 ReplicaSet 主节点的 mongo shell 中（提示符为 `replSet0:PRIMARY>` ），让我们在 `demo` 集合中添加
    1,000 个示例文档：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can quickly verify the inserted documents by using the `find()` method
    on the `demo` collection:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用 `demo` 集合上的 `find()` 方法快速验证插入的文档：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, we will create a minimalistic .NET Core 3.0 console application running
    in a Docker container. This will connect to the ReplicaSet running in our Docker
    container, query our `demo` collection, and write a value of `exampleValue` for
    each document to standard output.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个在Docker容器中运行的最小化.NET Core 3.0控制台应用程序。这将连接到运行在我们的Docker容器中的ReplicaSet，查询我们的`demo`集合，并将每个文档的`exampleValue`值写入标准输出。
- en: 'You can find the source code and Dockerfile for this in this book''s GitHub
    repository: [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter02/04_MongoDB_dotnet](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter02/04_MongoDB_dotnet).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub存储库中找到此源代码和Dockerfile：[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter02/04_MongoDB_dotnet](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter02/04_MongoDB_dotnet)。
- en: If, during the execution of this scenario, you experience any instability issues
    with MongoDB, consider upgrading the `mongo-1903` Dockerfile to the latest MongoDB
    version.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行此场景时，您遇到任何与MongoDB的不稳定问题，请考虑将`mongo-1903` Dockerfile升级到最新的MongoDB版本。
- en: 'To read our test data, we need to build the application Docker image and create
    a container that''s running in the `mongo-cluster` network. Perform the following
    steps to do so:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取我们的测试数据，我们需要构建应用程序Docker镜像，并创建一个在`mongo-cluster`网络中运行的容器。执行以下步骤：
- en: Clone the repository and navigate to the `Chapter02/04_MongoDB_dotnet` directory
    in PowerShell.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆存储库并在PowerShell中导航到`Chapter02/04_MongoDB_dotnet`目录。
- en: 'Execute `docker build` in the current directory in order to create the `mongo-dotnet-sample`
    Docker image:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前目录中执行`docker build`以创建`mongo-dotnet-sample` Docker镜像：
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run the sample container. This needs to be connected to the `mongo-cluster`
    network:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例容器。这需要连接到`mongo-cluster`网络：
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the output, you should see an increasing sequence of numbers, which is the
    values of `exampleValue` in our test documents:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，您应该看到一个递增的数字序列，这是我们测试文档中`exampleValue`的值：
- en: '![](assets/83cccc9f-2049-48f4-98ff-0f8405a01987.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/83cccc9f-2049-48f4-98ff-0f8405a01987.png)'
- en: 'If you are curious, you can check what the SMB share contains on Azure Portal
    ([https://portal.azure.com/](https://portal.azure.com/)):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您感兴趣，可以在Azure门户上检查SMB共享包含什么内容（[https://portal.azure.com/](https://portal.azure.com/)）：
- en: '![](assets/cc802dbb-7896-4eb4-bf0a-120893c9cce9.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cc802dbb-7896-4eb4-bf0a-120893c9cce9.png)'
- en: Congratulations! You have successfully created and tested a MongoDB ReplicaSet
    running in a Windows container with Azure Files SMB share being used as a bind
    mount for storing data. Let's quickly summarize what we have learned in this chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功创建并测试了在Windows容器中运行的MongoDB ReplicaSet，并使用Azure Files SMB共享作为绑定挂载来存储数据。让我们快速总结一下本章学到的内容。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned the key aspects of Docker storage on Windows:
    using volumes and bind mounts. With the help of Azure, you successfully set up
    your Azure Files SMB share, which can be used to store container state data using
    SMB global mappings. Last but not least, you wrapped all this up by setting up
    your own three-node MongoDB ReplicaSet backed by Azure Cloud storage and verified
    your setup!'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了Windows上Docker存储的关键方面：使用卷和绑定挂载。在Azure的帮助下，您成功设置了Azure Files SMB共享，可以使用SMB全局映射来存储容器状态数据。最后，您通过设置自己的由Azure云存储支持的三节点MongoDB
    ReplicaSet来总结了所有这些，并验证了您的设置！
- en: The next chapter will be the last one to focus purely on Docker on the Windows
    platform. You can expect to learn about the fundamentals of how to work with Docker
    images and how to use them in your application development life cycle. After that,
    we will be ready to begin our journey with Kubernetes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将是最后一章专注于Windows平台上的Docker。您可以期待学习如何使用Docker镜像以及如何在应用程序开发生命周期中使用它们的基础知识。之后，我们将准备开始我们的Kubernetes之旅。
- en: Questions
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the container layer in the Docker storage architecture?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker存储架构中的容器层是什么？
- en: What is the difference between volumes and bind mounts?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卷和绑定挂载之间有什么区别？
- en: Why is storing container state data in the container layer not recommended?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么不建议将容器状态数据存储在容器层中？
- en: How can you mount Azure Files SMB share transparently in a container?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在容器中透明地挂载Azure Files SMB共享？
- en: Can you use bind mounts in containers that run in Hyper-V isolation?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行在Hyper-V隔离中的容器中可以使用绑定挂载吗？
- en: What command removes all unused volumes on the container host?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么命令可以删除容器主机上的所有未使用卷？
- en: What are volume drivers (plugins)?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是卷驱动程序（插件）？
- en: You can find the answers to these questions in the *Assessments *section of
    this book.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的*评估*部分找到这些问题的答案。
- en: Further reading
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information concerning managing state and volumes in Docker (not only
    on Windows), please refer to the following Packt book:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关在Docker中管理状态和卷的更多信息（不仅限于Windows），请参考以下Packt图书：
- en: '*Learn Docker – Fundamentals of Docker 18.x* ([https://www.packtpub.com/networking-and-servers/learn-docker-fundamentals-docker-18x](https://www.packtpub.com/networking-and-servers/learn-docker-fundamentals-docker-18x)).'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习Docker- Docker 18.x基础* ([https://www.packtpub.com/networking-and-servers/learn-docker-fundamentals-docker-18x](https://www.packtpub.com/networking-and-servers/learn-docker-fundamentals-docker-18x))。'
- en: 'You can also refer to the official Docker documentation, which gives a good
    overview of possible storage options for Docker itself: [https://docs.docker.com/storage/](https://docs.docker.com/storage/).'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以参考官方的Docker文档，其中对Docker本身的可能存储选项进行了很好的概述：[https://docs.docker.com/storage/](https://docs.docker.com/storage/)。
