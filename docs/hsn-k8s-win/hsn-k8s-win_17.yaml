- en: Securing Kubernetes Clusters and Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护Kubernetes集群和应用程序
- en: The topic of security deserves special attention—Kubernetes is a huge and complex
    system where security is not obvious and potential **attack vectors** are not
    immediately visible. Thinking about security in Kubernetes is even more important
    if you consider the powerful operations that this system can perform and how deeply
    it integrates with the operating system internals. Just to shed some light on
    how things may go south if you overlook configuration details, take a look at
    an article on how Tesla got cryptojacked because of a *public*, *unauthenticated*
    endpoint for Kubernetes Dashboard ([https://blog.heptio.com/on-securing-the-kubernetes-dashboard-16b09b1b7aca](https://blog.heptio.com/on-securing-the-kubernetes-dashboard-16b09b1b7aca)).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性这个话题值得特别关注——Kubernetes是一个庞大而复杂的系统，在这个系统中安全性并不明显，潜在的攻击向量也不会立即显现。如果考虑到这个系统可以执行的强大操作以及它与操作系统内部的深度集成，那么在Kubernetes中考虑安全性就更加重要了。只是为了让您了解，如果您忽视了配置细节，事情可能会变得很糟糕，可以看一下有关特斯拉因为Kubernetes
    Dashboard的*公共*、*未经身份验证*端点而被加密挖矿的文章[https://blog.heptio.com/on-securing-the-kubernetes-dashboard-16b09b1b7aca](https://blog.heptio.com/on-securing-the-kubernetes-dashboard-16b09b1b7aca)。
- en: In this chapter, we are going to provide you with the general best practices
    for securing Kubernetes clusters, including the Windows workloads perspective.
    Windows nodes have some limitations—for example, mounting secrets in clear text
    directly from the node storage only (not memory)—but they also are more secure
    than Linux nodes in different ways.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为您提供保护Kubernetes集群的一般最佳实践，包括Windows工作负载的视角。Windows节点有一些限制——例如，只能直接从节点存储（而不是内存）中以明文形式挂载密钥，但它们在不同方面也比Linux节点更安全。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Securing Kubernetes clusters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护Kubernetes集群
- en: Securing the container runtime on Windows
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护Windows上的容器运行时
- en: Deploying secure applications using network policies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网络策略部署安全应用程序
- en: Kubernetes secrets on Windows machines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows机器上的Kubernetes密钥
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您将需要以下内容：
- en: Windows 10 Pro, Enterprise, or Education (version 1903 or later, 64-bit) installed
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装的Windows 10 Pro、企业版或教育版（1903版本或更高版本，64位）
- en: Azure account
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure账户
- en: Windows/Linux Kubernetes cluster deployed using AKS Engine
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AKS Engine部署的Windows/Linux Kubernetes集群
- en: To follow along, you will need your own Azure account in order to create Azure
    resources for the Kubernetes cluster. If you haven't already created the account
    in the previous chapters, you can read more about how to obtain a limited free
    account for personal use at [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟着做，您需要自己的Azure账户，以便为Kubernetes集群创建Azure资源。如果您之前没有在前几章创建过账户，您可以阅读更多关于如何获取个人使用的有限免费账户的信息[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)。
- en: Deploying a Kubernetes cluster using AKS Engine has been covered in [Chapter
    8](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml), *Deploying a Hybrid Azure Kubernetes
    Service Engine Cluster*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AKS Engine部署Kubernetes集群已在[第8章](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml)中介绍过，*部署混合Azure
    Kubernetes服务引擎集群*。
- en: You can download the latest code samples for this book chapter from the official
    GitHub repository at [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter13).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从官方GitHub存储库下载本书章节的最新代码示例[https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter13)。
- en: Securing Kubernetes clusters
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护Kubernetes集群
- en: In this section, we will give some general guidance on how to secure Kubernetes
    clusters. Additionally, we are going to explore the topic of API user authentication in
    AKS Engine clusters using **Azure Active Directory **(**AAD**) integration. The
    list of best practices provided in this chapter is not exhaustive, so please always
    review the latest official documentation to ensure that you follow the recommendations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提供一些关于如何保护Kubernetes集群的一般指导。此外，我们将探讨在AKS Engine集群中使用Azure Active Directory（AAD）集成进行API用户身份验证的主题。本章提供的最佳实践清单并不详尽，因此请始终查阅最新的官方文档，以确保您遵循建议。
- en: Now, let's go through the list of general recommendations in the following subsections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐个讨论以下各小节中的一般建议清单。
- en: Using built-in RBAC for authorization
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置RBAC进行授权
- en: We have covered the **role-based access control** (**RBAC**) provided by Kubernetes
    for API authorization in [Chapter 11](9ad8c38e-6d0d-435b-a46c-82a468f18007.xhtml), *Configuring
    Applications to Use Kubernetes Features*. This mechanism allows you to configure
    fine-grained sets of permissions and assign them to users, groups, and service
    accounts. In this way, as a cluster administrator, you can control how cluster
    users (internal and external) interact with the API server, which API resources
    they can access, and which actions they can perform. At the same time, you should
    use namespaces to create the first boundary between resources. This also makes
    applying RBAC policies easier.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第11章](9ad8c38e-6d0d-435b-a46c-82a468f18007.xhtml)中介绍了Kubernetes提供的基于角色的访问控制（RBAC）用于API授权。这种机制允许您配置细粒度的权限集，并将其分配给用户、组和服务帐户。通过这种方式，作为集群管理员，您可以控制集群用户（内部和外部）与API服务器的交互方式，他们可以访问哪些API资源以及可以执行哪些操作。同时，您应该使用命名空间来创建资源之间的第一个边界。这也使得应用RBAC策略更加容易。
- en: For RBAC, use the principle of least privilege and prefer assigning RoleBindings
    to groups instead of individual users to reduce management overhead. If you use
    an external authentication provider, you can easily integrate with groups provided
    by the provider. When bootstrapping the cluster, it is recommended that you use
    the Node and RBAC authorizers together (use the `--authorization-mode=Node,RBAC`
    parameter for the API server), in combination with the **NodeRestriction** admission
    plugin. This is the default way that AKS Engine initializes your cluster.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于RBAC，使用最小特权原则，并倾向于将RoleBindings分配给组，而不是单个用户，以减少管理开销。如果使用外部身份验证提供者，您可以轻松地与提供者提供的组集成。在引导集群时，建议您同时使用Node和RBAC授权器（对API服务器使用`--authorization-mode=Node,RBAC`参数），结合NodeRestriction准入插件。这是AKS
    Engine初始化集群的默认方式。
- en: Using an external authentication provider
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部身份验证提供者
- en: All API calls must be authenticated. This is true for both external (normal)
    users as well as members of the internal Kubernetes infrastructure—for example,
    kubelet. In the case of the infrastructure, such users generally use ServiceAccounts
    with tokens or X509 client certificates, which are created when bootstrapping
    the cluster. Kubernetes itself does not provide the means for managing normal external
    users who access the cluster; this should be delegated to an external authentication
    provider that can integrate with Kubernetes—for example, via an authenticating
    proxy.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有API调用都必须经过身份验证。这对外部（普通）用户以及内部Kubernetes基础设施的成员（例如kubelet）都是如此。在基础设施的情况下，这些用户通常使用带有令牌或X509客户端证书的ServiceAccounts，这些证书是在引导集群时创建的。Kubernetes本身不提供管理访问集群的普通外部用户的手段；这应该委托给一个可以与Kubernetes集成的外部身份验证提供者，例如通过认证代理。
- en: You should choose an authentication mechanism that fits your organization and
    follows the common access patterns for the users. For example, if you are running
    AKS Engine, it is likely that you are already using Azure Active Directory to
    manage users and roles in your Azure subscription. On top of that, you should
    consider using groups to make RBAC policy management easier and more integrated
    with AAD.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您应选择适合您的组织并遵循用户的常见访问模式的身份验证机制。例如，如果您正在运行AKS引擎，很可能已经在Azure订阅中使用Azure Active Directory来管理用户和角色。除此之外，您应考虑使用组来使RBAC策略管理更加简单，并与AAD更加集成。
- en: Apart from AAD, authenticating proxies and authentication webhooks give you
    the possibility to integrate with different protocols, such as LDAP, SAML, or
    Kerberos.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了AAD之外，认证代理和认证webhook还可以让您有可能与不同的协议集成，例如LDAP、SAML或Kerberos。
- en: At the end of this section, we will demonstrate how to enable AAD integration
    for your AKS Engine cluster.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我们将演示如何为您的AKS引擎集群启用AAD集成。
- en: Bootstrapping the cluster using kubeadm
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用kubeadm引导集群
- en: If you are deploying the cluster manually, use **kubeadm**, which can bootstrap
    the cluster securely. It can generate a **self-signed CA** to set up identities
    for all components in the cluster, generate **tokens **for joining new nodes (TLS
    bootstrapping), and offer **certificate management **capabilities ([https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/](https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/)).
    Initializing a **secure** Kubernetes cluster is the top design priority for kubeadm
    ([https://github.com/kubernetes/kubeadm/blob/master/docs/design/design_v1.10.md](https://github.com/kubernetes/kubeadm/blob/master/docs/design/design_v1.10.md)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您手动部署集群，请使用kubeadm，它可以安全地引导集群。它可以生成一个自签名的CA来为集群中的所有组件设置身份，生成用于加入新节点的令牌（TLS引导），并提供证书管理功能([https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/](https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/))。初始化一个安全的Kubernetes集群是kubeadm的首要设计重点([https://github.com/kubernetes/kubeadm/blob/master/docs/design/design_v1.10.md](https://github.com/kubernetes/kubeadm/blob/master/docs/design/design_v1.10.md))。
- en: Disabling public API access
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用公共API访问
- en: For production scenarios, using proper user authentication with RBAC authorization
    for the Kubernetes API may not be enough (from a security perspective) if the
    API is publicly accessible. To reduce the attack vector for your Kubernetes API,
    consider *disabling* public API access, as well as not exposing any Kubernetes
    nodes directly to the internet. This will, of course, require you to use a **VPN**
    or a **jumpbox host** to access the API, but it is definitely more secure.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产场景，仅使用RBAC授权进行Kubernetes API的适当用户身份验证可能不足够（从安全角度来看），如果API是公开访问的。为了减少Kubernetes
    API的攻击向量，考虑*禁用*公共API访问，以及不直接将任何Kubernetes节点暴露给互联网。当然，这将需要您使用VPN或jumpbox主机来访问API，但这绝对更安全。
- en: AKS Engine can configure this for you by a simple change to the cluster apimodel.
    You can read more about disabling public API access in the official documentation
    at [https://github.com/Azure/aks-engine/blob/master/docs/topics/features.md#private-cluster](https://github.com/Azure/aks-engine/blob/master/docs/topics/features.md#private-cluster).
    Alternatively, you may consider hardening the **NAT inbound rules** for master
    VMs, restricting the range of IPs that are allowed to connect to the machine via
    HTTPS and SSH.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: AKS引擎可以通过对集群apimodel进行简单更改来为您配置此功能。您可以在官方文档中阅读有关禁用公共API访问的更多信息[https://github.com/Azure/aks-engine/blob/master/docs/topics/features.md#private-cluster](https://github.com/Azure/aks-engine/blob/master/docs/topics/features.md#private-cluster)。或者，您可以考虑加固主VM的NAT入站规则，限制允许通过HTTPS和SSH连接到机器的IP范围。
- en: Disabling the public Dashboard
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用公共仪表板
- en: Similar to the Kubernetes API, you should disable the publicly accessible Kubernetes
    Dashboard. In common installations, the Dashboard may be exposed as a LoadBalancer
    service; in the worst case, this will be on a ServiceAccount with a `cluster-admin` role.
    The recommended practice is to never expose Kubernetes Dashboard using a LoadBalancer
    service, and to always use `kubectl proxy` to access the page.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与Kubernetes API类似，您应该禁用公开访问的Kubernetes仪表板。在常见的安装中，仪表板可能会暴露为一个LoadBalancer服务；在最坏的情况下，这将是一个具有`cluster-admin`角色的ServiceAccount。推荐的做法是永远不要使用LoadBalancer服务公开Kubernetes仪表板，并始终使用`kubectl
    proxy`来访问页面。
- en: Additionally, the ServiceAccount for Kubernetes Dashboard should have the **least
    privileges **that are enough for your use cases. You will most likely never use
    Kubernetes Dashboard for creating or editing deployments in production, so why
    would you need write access for such sensitive API resources?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Kubernetes仪表板的ServiceAccount应具有足够满足您用例的**最低权限**。您很可能永远不会在生产环境中使用Kubernetes仪表板来创建或编辑部署，那么为什么您需要对这些敏感的API资源具有写访问权限呢？
- en: Running containers in nonprivileged mode
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以非特权模式运行容器
- en: In Kubernetes, it is possible to specify whether a pod is privileged or not.
    Privileged pods may have containers that are running in privileged mode—this essentially
    means that the container has access to all devices on the host, which is similar
    to what processes running with root (or administrative) privileges on the host
    would have.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，可以指定一个pod是否具有特权。特权pod可能包含以特权模式运行的容器，这基本上意味着容器可以访问主机上的所有设备，这与在主机上以root（或管理员）权限运行的进程具有类似的权限。
- en: It is a good practice to ensure that your pod containers are running in nonprivileged
    mode in the operating system; this follows the principle of least privilege. Additionally,
    you should consider using the PodSecurityPolicy admission controllerto enforce
    a set of rules that a pod must fulfill to be scheduled. An example restrictive
    policy can be found at [https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/restricted-psp.yaml](https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/restricted-psp.yaml).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的pod容器在操作系统中以非特权模式运行是一个良好的做法；这遵循了最小权限原则。此外，您应该考虑使用PodSecurityPolicy admission
    controller来强制执行一组规则，一个pod必须满足才能被调度。一个示例的限制性策略可以在[https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/restricted-psp.yaml](https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/restricted-psp.yaml)找到。
- en: Please note that in the case of Windows containers, running privileged containers
    is not supported. Additionally, for Windows workloads, consider using **Group-Managed
    Service Accounts** (**gMSAs**, [https://kubernetes.io/docs/tasks/configure-pod-container/configure-gmsa/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-gmsa/)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Windows容器的情况下，不支持运行特权容器。此外，对于Windows工作负载，请考虑使用**组管理服务帐户**（gMSAs，[https://kubernetes.io/docs/tasks/configure-pod-container/configure-gmsa/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-gmsa/)）。
- en: Encrypting data at rest
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密数据的静态存储
- en: '**Encrypting data at rest** is considered a general good practice (and sometimes
    a law-enforced requirement) for all systems. In Kubernetes, you need to ensure
    that **etcd cluster **data is encrypted. This will provide an extra layer of security
    for your API resources and secrets that would otherwise be kept in etcd in unencrypted
    form. Encrypting secrets at rest is covered as a separate topic in the official
    Kubernetes documentation at [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在静止状态下加密被认为是一种普遍的良好做法（有时是法律强制要求）对于所有系统。在Kubernetes中，您需要确保etcd集群数据被加密。这将为您的API资源和秘密提供额外的安全层，否则这些信息将以未加密的形式保存在etcd中。在官方Kubernetes文档中，有关在静止状态下加密秘密的内容被单独讨论。
- en: 'For secrets, you should always use late binding by injecting the secrets to
    pods as volumes or environment variables. Note that injecting secrets as environment
    variables is less secure on Linux; when you have root privileges, you can enumerate
    all environment variables for a process from `/proc/<pid>/environ`. On Windows
    nodes, the issue is even more complex: you can still access environment variables
    for processes, but volumes cannot currently use the in-memory filesystem. This
    means that secrets are then stored directly on the node disk storage. This means
    that you should consider encrypting your Windows node storage to minimize the
    exposure of credentials. We will take a look at this issue in the next sections.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于秘密，您应该始终使用延迟绑定，通过将秘密注入到pod中作为卷或环境变量。请注意，在Linux上将秘密注入为环境变量是不太安全的；当您拥有root权限时，您可以从`/proc/<pid>/environ`枚举出一个进程的所有环境变量。在Windows节点上，问题甚至更加复杂：您仍然可以访问进程的环境变量，但卷目前无法使用内存文件系统。这意味着秘密随后直接存储在节点磁盘上。这意味着您应该考虑加密您的Windows节点存储，以最小化凭据的暴露。我们将在接下来的章节中讨论这个问题。
- en: Using network policies
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网络策略
- en: Network policies act as a firewall between your pods, allowing you to control
    network access into and out of your containerized applications. In a Kubernetes
    cluster, there are no limitations in network communication between pods by default—basically,
    all-to-all traffic is possible. It is a good practice to use a permissive network
    policy model that, by default, denies all traffic and allows connections only
    if a dedicated network policy has been defined.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 网络策略充当您的pod之间的防火墙，允许您控制容器化应用程序的网络访问。在Kubernetes集群中，默认情况下，pod之间没有网络通信的限制——基本上，所有的流量都是可能的。使用一种宽松的网络策略模型是一种良好的做法，它默认拒绝所有流量，并只允许连接，如果已经定义了专用的网络策略。
- en: You can read more about network providers that support network policies that
    are available on AKS Engine in the official documentation at [https://github.com/Azure/aks-engine/tree/master/examples/networkpolicy](https://github.com/Azure/aks-engine/tree/master/examples/networkpolicy).
    Please take note that currently Windows pods are not supported by these providers,
    apart from the Enterprise version of Calico that is provided as a part of the
    Tigera Essentials subscription service ([https://www.tigera.io/media/pr-calico-for-windows](https://www.tigera.io/media/pr-calico-for-windows)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中阅读更多关于支持AKS Engine上网络策略的网络提供商的信息。请注意，目前这些提供商不支持Windows pod，除了Tigera
    Essentials订阅服务的企业版本提供的Calico（https://www.tigera.io/media/pr-calico-for-windows）。
- en: Securing the image supply chain and scan images
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护镜像供应链和扫描镜像
- en: In [Chapter 3](e00b7610-2513-4513-863f-62a054d8cd98.xhtml), *Working with Container
    Images*, we described how you can sign and verify your Docker images using **Docker
    Content Trust** (**DCT**). You should definitely consider using this approach
    for your Docker image pipelines in production. Additionally, consider incorporating
    open source tools, such as **Anchore** ([https://github.com/anchore/anchore-engine](https://github.com/anchore/anchore-engine))
    and **Clair** ([https://github.com/quay/clair](https://github.com/quay/clair)),
    which can help you identify common vulnerabilities and exposures (**CVEs**) and
    mitigate them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](e00b7610-2513-4513-863f-62a054d8cd98.xhtml)中，*使用容器镜像*，我们描述了如何使用**Docker
    Content Trust**（**DCT**）对Docker镜像进行签名和验证。您应该在生产中考虑使用这种方法来进行Docker镜像流水线。此外，考虑整合开源工具，如**Anchore**（[https://github.com/anchore/anchore-engine](https://github.com/anchore/anchore-engine)）和**Clair**（[https://github.com/quay/clair](https://github.com/quay/clair)），这些工具可以帮助您识别常见的漏洞和曝光（**CVEs**）并加以缓解。
- en: Rotating infrastructure credentials and certificates
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转基础设施凭据和证书
- en: In general, the shorter the validity time of a credential or a token, the harder
    it will be for the attacker to make any use of such a credential. Use this principle
    to set short lifetimes for certificates and tokens that are used in your cluster
    and implement **automated rotation **whenever possible. This can become your secret
    weapon when you detect that you are under attack;  if you can effectively rotate
    certificates, you can simply rotate them on demand and make any intercepted credentials
    useless.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，凭据或令牌的有效期越短，攻击者利用这种凭据的难度就越大。利用这一原则为在您的集群中使用的证书和令牌设置较短的生命周期，并在可能的情况下实施**自动轮换**。当您发现自己受到攻击时，这可以成为您的秘密武器；如果您能有效地轮换证书，您可以随时轮换它们，并使任何被截获的凭据无效。
- en: For AKS and AKS Engine, consider using integration with **Azure Key Vault**,
    which makes your secret and certificate management and rotation much easier. You
    can read more in the official documentation at [https://github.com/Azure/kubernetes-keyvault-flexvol](https://github.com/Azure/kubernetes-keyvault-flexvol).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AKS和AKS Engine，考虑使用与**Azure Key Vault**集成，这将使您的秘密和证书管理和轮换变得更加容易。您可以在官方文档中阅读更多信息，网址为[https://github.com/Azure/kubernetes-keyvault-flexvol](https://github.com/Azure/kubernetes-keyvault-flexvol)。
- en: Additionally, consider integrating an authentication provider for issuing user
    tokens with a short expiration time. You can use this approach for providing **just-in-time
    privileged access management**, which can drastically limit the amount of time
    that a user has *God-mode*access to the resources.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，考虑集成一个认证提供者，用于发放具有短期有效期的用户令牌。您可以使用这种方法来提供**及时特权访问管理**，这可以大大限制用户拥有资源的*上帝模式*访问的时间。
- en: Enabling audit logging
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用审计日志
- en: '**Audit logs** should always be available in production clusters. This will
    make it possible to set up monitoring and alerting for access anomalies and unexpected
    API calls. The earlier you detect any forbidden API responses, the greater the
    chance that you will react in time and prevent the attacker from gaining access
    to the cluster. You can read more about Kubernetes auditing in the official documentation
    at [https://kubernetes.io/docs/tasks/debug-application-cluster/audit/](https://kubernetes.io/docs/tasks/debug-application-cluster/audit/).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**审计日志**应始终在生产集群中可用。这将使监视和警报设置对访问异常和意外API调用进行监控成为可能。您越早发现任何禁止的API响应，就越有可能及时做出反应，防止攻击者获取对集群的访问权限。您可以在官方文档中阅读有关Kubernetes审计的更多信息，网址为[https://kubernetes.io/docs/tasks/debug-application-cluster/audit/](https://kubernetes.io/docs/tasks/debug-application-cluster/audit/)。'
- en: Make sure you go through the official Kubernetes guide for securing a cluster
    when you set up a production cluster. You can find more details at [https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/](https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置生产集群时，请确保阅读官方Kubernetes指南以保护集群。您可以在[https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/](https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/)找到更多详细信息。
- en: Now, after we have gone through the most important security best practices for
    Kubernetes clusters, we will take a look at how to enable **Azure Active Directory**
    (**AAD**) for client authentication in an AKS Engine cluster.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们已经了解了Kubernetes集群的最重要的安全最佳实践之后，我们将看看如何在AKS Engine集群中启用**Azure Active Directory**（AAD）进行客户端身份验证。
- en: Integrating AAD with AKS Engine
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成AAD与AKS Engine
- en: AKS Engine can be easily integrated with AAD in order to provide Kubernetes
    API client authentication. Together with AAD **groups**, this approach can be
    used for creating RoleBindings and ClusterRoleBindings for user groups that are
    mapped to AAD groups.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: AKS Engine可以轻松与AAD集成，以提供Kubernetes API客户端身份验证。与AAD **组**一起，这种方法可以用于为映射到AAD组的用户组创建RoleBindings和ClusterRoleBindings。
- en: Let's see how you can create an AKS Engine cluster with AAD integration and
    create an AAD group for cluster admins. This approach can be extended to manage
    multiple AAD groups that can have different bindings in RBAC.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个具有AAD集成的AKS Engine集群，并为集群管理员创建一个AAD组。这种方法可以扩展到管理多个具有不同RBAC绑定的AAD组。
- en: Adding AAD integration to an existing AKS Engine cluster is not supported. Therefore,
    you need to make this decision at cluster deployment time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持将AAD集成添加到现有的AKS Engine集群。因此，您需要在集群部署时做出这个决定。
- en: 'The steps for configuring AAD applications for a server and client, as well
    as the creation of the admin AAD group, have been provided as a Powershell script at [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter13/01_AksEngineCreateAadProfile.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter13/01_AksEngineCreateAadProfile.ps1) for
    your convenience. You can use the script or go through the following steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为服务器和客户端配置AAD应用程序的步骤，以及创建管理员AAD组的步骤，已经作为Powershell脚本提供，方便您使用。您可以使用该脚本或按照以下步骤操作：
- en: 'Open the PowerShell window and define the `$dnsPrefix` variable with a globally
    unique DNS prefix, which you will later use for AKS Engine deployment—for example:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开PowerShell窗口，并使用全局唯一的DNS前缀定义`$dnsPrefix`变量，稍后将用于AKS Engine部署，例如：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create an AAD server application that will represent the Kubernetes API server
    and store the `appId` for further use as a `$serverApplicationId` variable:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将代表Kubernetes API服务器的AAD服务器应用程序，并将`appId`存储以供进一步使用作为`$serverApplicationId`变量：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Update group membership claims for this application:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新此应用程序的组成员资格声明：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a **service principal **that will be used for Azure platform authentication:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将用于Azure平台身份验证的**服务主体**：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Get the **secret** for the service principal and store it for further use as
    a `$serverApplicationSecret` variable:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取服务主体的**密钥**并将其存储以供进一步使用作为`$serverApplicationSecret`变量：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, add permissions for the server application to read directory data and sign
    in and read the user profiles:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为服务器应用程序添加权限以读取目录数据、登录和读取用户配置文件：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Grant the permissions:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授予权限：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next steps will be similar, but will apply to an AAD **client application** that
    represents kubectl. Create the application and store the `appId` for further use
    as a `$clientApplicationId` variable:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的步骤将类似，但将适用于代表kubectl的AAD **客户端应用程序**。创建该应用程序并将`appId`存储为`$clientApplicationId`变量以供进一步使用：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Depending on your AAD tenant configuration, you may require additional permissions
    to create the service principal. You can read more in the official documentation
    at [https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal#required-permissions](https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal#required-permissions).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的AAD租户配置，您可能需要额外的权限来创建服务主体。您可以在官方文档中阅读更多内容[https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal#required-permissions](https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal#required-permissions)。
- en: 'Create the service principal for the application:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为应用程序创建服务主体：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Determine the OAuth2 ID for the server application and store it as `$oauth2PermissionId`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定服务器应用程序的OAuth2 ID并将其存储为`$oauth2PermissionId`：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use the OAuth2 ID to allow the authentication flow between the client and server
    application:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用OAuth2 ID允许客户端和服务器应用程序之间的身份验证流程：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create an AAD group named `AksEngineAdmins` for AKS Engine administrators and
    store its ID as a `$adminGroupId` variable:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为AKS Engine管理员创建名为`AksEngineAdmins`的AAD组，并将其ID存储为`$adminGroupId`变量：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We would like to add the current user to this group. First, let''s retrieve
    the `objectId` for the user and store it as a `$currentUserObjectId` variable:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要将当前用户添加到这个组。首先，让我们检索用户的`objectId`并将其存储为`$currentUserObjectId`变量：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the user to the AKS Engine administrators group:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户添加到AKS Engine管理员组：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Determine the AAD Tenant ID for your current subscription and store it as a `$tenantId`
    variable:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定当前订阅的AAD租户ID并将其存储为`$tenantId`变量：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Print the JSON object based on the previous variables that will be used in
    the AKS Engine apimodel:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于前面的变量打印JSON对象，该对象将在AKS Engine apimodel中使用：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have everything we need to deploy AKS Engine with AAD integration. To do
    this, we will use a PowerShell script in almost exactly the same way that we used
    it in previous chapters ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter13/02_aks-engine-aad/CreateAKSEngineClusterWithWindowsNodes.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter13/02_aks-engine-aad/CreateAKSEngineClusterWithWindowsNodes.ps1)),
    together with the apimodel template ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter13/02_aks-engine-aad/kubernetes-windows-template.json](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter13/02_aks-engine-aad/kubernetes-windows-template.json)).
    To perform AKS Engine deployment, go through the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好部署带有AAD集成的AKS Engine。为此，我们将使用一个PowerShell脚本，几乎与我们在之前章节中使用的方式完全相同([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter13/02_aks-engine-aad/CreateAKSEngineClusterWithWindowsNodes.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter13/02_aks-engine-aad/CreateAKSEngineClusterWithWindowsNodes.ps1))，以及apimodel模板([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter13/02_aks-engine-aad/kubernetes-windows-template.json](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter13/02_aks-engine-aad/kubernetes-windows-template.json))。执行AKS
    Engine部署，按照以下步骤进行：
- en: Download both the PowerShell script and the apimodel template.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载PowerShell脚本和apimodel模板。
- en: Open the PowerShell window in the location of the files.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件位置打开PowerShell窗口。
- en: In the `kubernetes-windows-template.json` file, replace `aadProfile` with your
    own values from the previous paragraph.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`kubernetes-windows-template.json`文件中，用前面段落中的自己的值替换`aadProfile`。
- en: 'Execute the script with appropriate parameters:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的参数执行脚本：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After a few minutes, the script will execute the `kubectl get pods` command
    and you will be prompted to *authenticate* in the web browser:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几分钟后，脚本将执行`kubectl get pods`命令，并提示您在Web浏览器中进行*身份验证*：
- en: '![](assets/f8a01372-d9c8-4987-9a74-d659c938ff65.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f8a01372-d9c8-4987-9a74-d659c938ff65.png)'
- en: Navigate to the URL, provide the code, and log in. After that, you will be authenticated
    successfully in the Kubernetes API server and be able to use kubectl.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到URL，提供代码并登录。之后，您将成功在Kubernetes API服务器中进行身份验证，并能够使用kubectl。
- en: 'To check the definition of the ClusterRoleBinding, which allows you access,
    execute the following command:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查允许您访问的ClusterRoleBinding的定义，请执行以下命令：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Depending on your needs, you can now configure more AAD groups, create roles
    and provide appropriate RoleBindings for them. In the next section, we will take
    a look at how you can ensure that the Windows container runtime is running securely.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的需求，您现在可以配置更多的AAD组，创建角色并为它们提供适当的RoleBindings。在下一节中，我们将看看如何确保Windows容器运行时安全运行。
- en: Securing container runtime in Windows
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows中保护容器运行时
- en: When it comes to securing container runtime, Windows containers are a bit different
    than Linux containers. For Windows containers, the operating system uses a `Job`
    object (not to be confused with Kubernetes `Job` object!) **per container** with
    a system namespace filter for all processes running in a given container. This
    provides a logical isolation from the host machine that cannot be disabled. You
    can read more about the Windows container architecture in [Chapter 1](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml), *Creating
    Containers.*
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在保护容器运行时方面，Windows容器与Linux容器有些不同。对于Windows容器，操作系统使用一个“Job”对象（不要与Kubernetes的“Job”对象混淆！）每个容器一个，具有用于在给定容器中运行的所有进程的系统命名空间过滤器。这提供了与主机机器的逻辑隔离，无法禁用。您可以在[第1章](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml)中阅读有关Windows容器架构的更多信息，*创建容器*。
- en: This fact has a consequence: **privileged** containers are not available in
    Windows, though they are available in Linux. Additionally, with the incoming support
    for Hyper-V containers in Kubernetes, you will be able to secure the container
    runtime even more and enforce better isolation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这一事实有一个后果：在Windows中，**特权**容器不可用，尽管在Linux中可用。此外，随着Kubernetes对Hyper-V容器的支持即将到来，您将能够进一步保护容器运行时并强制执行更好的隔离。
- en: 'For Linux containers**,** you would consider using `securityContext` for a
    pod in order to run as a **nonprivileged** user (with an ID different from `0`):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux容器，您可以考虑在Pod中使用`securityContext`以作为**非特权**用户运行（其ID与`0`不同）：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Additionally, you can enforce **PodSecurityPolicies**, which are verified by
    the admission controller before scheduling a pod. In this way, as an example,
    you can ensure that no pods in a given namespace are running in privileged mode.
    You have to use RBAC to properly configure policy access.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以强制执行PodSecurityPolicies，在调度Pod之前由准入控制器进行验证。通过这种方式，例如，您可以确保给定命名空间中没有以特权模式运行的Pod。您必须使用RBAC来正确配置策略访问。
- en: AKS Engine comes by default with the PodSecurityPolicy admission controller
    enabled and **privileged** and **restricted** policies available.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: AKS Engine默认启用了PodSecurityPolicy准入控制器，并提供了特权和受限策略。
- en: 'For Windows containers, the standard `securityContext` will not work as it
    is meant to be used for Linux containers. Windows containers have a dedicated
    object inside `securityContext` named `windowsOptions`, which can enable some
    Windows-specific features that are currently still in the **alpha** state:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows容器，标准的`securityContext`不适用，因为它是用于Linux容器的。Windows容器在`securityContext`内部有一个专门的对象，名为`windowsOptions`，它可以启用一些目前仍处于**alpha**状态的Windows特定功能：
- en: Configuring running pod containers with a different user name ([https://kubernetes.io/docs/tasks/configure-pod-container/configure-runasusername/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-runasusername/)).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的用户名配置正在运行的Pod容器（[https://kubernetes.io/docs/tasks/configure-pod-container/configure-runasusername/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-runasusername/)）。
- en: Configuring Group-Managed Service Accounts (gMSA) for pod containers ([https://kubernetes.io/docs/tasks/configure-pod-container/configure-gmsa/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-gmsa/)).
    The gMSA is a specific type of Active Directory account that provides automatic
    password management, simplified service principal name management, and the ability
    to delegate the management to other administrators on multiple servers. Azure
    Active Directory comes with support for gMSA ([https://docs.microsoft.com/en-us/azure/active-directory-domain-services/create-gmsa](https://docs.microsoft.com/en-us/azure/active-directory-domain-services/create-gmsa)).
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Pod容器配置组管理的服务帐户（gMSA）（[https://kubernetes.io/docs/tasks/configure-pod-container/configure-gmsa/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-gmsa/)）。gMSA是一种特定类型的Active
    Directory帐户，提供自动密码管理、简化的服务主体名称管理，并且可以将管理委托给多个服务器上的其他管理员。Azure Active Directory支持gMSA（[https://docs.microsoft.com/en-us/azure/active-directory-domain-services/create-gmsa](https://docs.microsoft.com/en-us/azure/active-directory-domain-services/create-gmsa)）。
- en: In the next section, you will learn more about network policies and how they
    can be used to deploy more secure applications on Kubernetes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将了解更多关于网络策略以及它们如何用于在Kubernetes上部署更安全的应用程序。
- en: Deploying secure applications using network policies
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网络策略部署安全应用程序
- en: In Kubernetes, you can provide better granularity for your application deployments
    in terms of network isolation using network policies. Represented by `NetworkPolicy`
    objects, they define how groups of pods can communicate with each other and network
    endpoints in general—think of them as a basic firewall for enforcing network segmentation
    at layer 3 of the OSI model. Of course, they are not a substitution for advanced
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，您可以使用网络策略为应用程序部署提供更好的网络隔离粒度。它们由`NetworkPolicy`对象表示，定义了一组Pod如何相互通信以及一般网络端点——可以将它们视为OSI模型第3层的网络分割的基本防火墙。当然，它们并不是高级防火墙的替代品。
- en: The `NetworkPolicy` object uses label selectors in order to identify the pods
    that they are attached to. Similarly, label selectors and IP CIDRs are used for
    defining ingress and egress rule targets for these pods. A given network policy
    is used only if it has a label selector that matches a given pod. If there are
    no network policies matching a given Pod, it can accept any traffic.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetworkPolicy`对象使用标签选择器来识别它们附加到的Pod。同样，标签选择器和IP CIDR用于为这些Pod定义入口和出口规则的目标。只有当网络策略具有与给定Pod匹配的标签选择器时，才会使用给定的网络策略。如果没有与给定Pod匹配的网络策略，它可以接受任何流量。'
- en: Network policy support
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络策略支持
- en: 'In order to use network policies, you need to use one of the **network providers**
    (used for installing the pod network, as described in [Chapter 5](da2ee6af-a754-4fc8-ae62-86d8e68f0bd0.xhtml),
    *Kubernetes Networking*) that supports network policies. The most popular are
    as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用网络策略，您需要使用一个支持网络策略的**网络提供商**（用于安装Pod网络，如[第5章](da2ee6af-a754-4fc8-ae62-86d8e68f0bd0.xhtml)中所述，*Kubernetes网络*）。最受欢迎的有以下几种：
- en: Calico ([https://www.projectcalico.org/](https://www.projectcalico.org/))
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Calico ([https://www.projectcalico.org/](https://www.projectcalico.org/))
- en: Cilium ([https://cilium.io/](https://cilium.io/))
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cilium ([https://cilium.io/](https://cilium.io/))
- en: Kube-router ([https://www.kube-router.io/](https://www.kube-router.io/))
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kube-router ([https://www.kube-router.io/](https://www.kube-router.io/))
- en: Romana ([https://romana.io/](https://romana.io/))
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Romana ([https://romana.io/](https://romana.io/))
- en: Weave Net ([https://www.weave.works/docs/net/latest/overview/](https://www.weave.works/docs/net/latest/overview/))
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Weave Net ([https://www.weave.works/docs/net/latest/overview/](https://www.weave.works/docs/net/latest/overview/))
- en: Unfortunately, there are *no* network providers that currently support Windows
    nodes, which means you can only use network policies in Linux clusters. The only
    network provider that has announced incoming support for Windows nodes and network
    policies is the enterprise version of Calico, provided as a part of the **Tigera
    Essentials** subscription service ([https://www.tigera.io/media/pr-calico-for-windows](https://www.tigera.io/media/pr-calico-for-windows)).
    You can currently try this offering, including Windows node support, in a private
    preview version. Please note that if you are using AKS or AKS Engine, you are
    limited to Calico or Cilium, working together with **A****zure** or **kubenet**
    network CNI plugins.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，目前没有*任何*支持Windows节点的网络提供商，这意味着您只能在Linux集群中使用网络策略。唯一宣布即将支持Windows节点和网络策略的网络提供商是Calico的企业版本，作为**Tigera
    Essentials**订阅服务的一部分提供（[https://www.tigera.io/media/pr-calico-for-windows](https://www.tigera.io/media/pr-calico-for-windows)）。您目前可以在私人预览版本中尝试此服务，包括Windows节点支持。请注意，如果您使用AKS或AKS
    Engine，则仅限于与**Azure**或**kubenet**网络CNI插件一起使用Calico或Cilium。
- en: For more details regarding AKS Engine configuration for network policy support,
    please refer to the official documentation at [https://github.com/Azure/aks-engine/tree/master/examples/networkpolicy](https://github.com/Azure/aks-engine/tree/master/examples/networkpolicy).
    Additionally, for managed AKS, you may consider using an **advanced networking**
    feature that allows you to configure your own VNet, define Azure network security
    groups, and provide automatic connectivity of your pods to the VNet—you can read
    more in the official documentation at [https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni](https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni.).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有关AKS Engine配置网络策略支持的更多详细信息，请参阅官方文档[https://github.com/Azure/aks-engine/tree/master/examples/networkpolicy](https://github.com/Azure/aks-engine/tree/master/examples/networkpolicy)。此外，对于托管的AKS，您可以考虑使用**高级网络**功能，允许您配置自己的VNet，定义Azure网络安全组，并提供将您的Pod连接到VNet的自动连接功能-您可以在官方文档中阅读更多[https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni](https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni)。
- en: Let's see how you could use network policies to enforce pod isolation in your
    clusters.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用网络策略来强制执行集群中的Pod隔离。
- en: Configuring network policy
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置网络策略
- en: From a security perspective, network policies are important because, by default,
    Kubernetes allows **all-to-all** communication in the cluster. Namespaces only
    provide a simple isolation that still allows pods to communicate with each other
    by IP address. In larger clusters or in multitenant scenarios, you have to provide
    better network isolation. Even though Windows nodes do not yet support network
    policies (but eventually they ***will*** be supported), we feel that it is important
    to make you aware of how you can approach network segmentation using native Kubernetes
    constructs.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全的角度来看，网络策略很重要，因为默认情况下，Kubernetes允许集群中的**所有对所有**通信。命名空间只提供了简单的隔离，仍然允许pod通过IP地址相互通信。在较大的集群或多租户场景中，你必须提供更好的网络隔离。尽管Windows节点目前还不支持网络策略（但最终***将***支持），我们认为让你了解如何使用原生Kubernetes构建来实现网络分割是很重要的。
- en: 'If you have an AKS Engine Linux cluster with a Calico network on an Azure CNI
    plugin, you can follow along and configure the network policies for your pods.
    Deployment of AKS Engine with such a configuration requires a simple change to
    the cluster apimodel, namely by adding the following property in `properties.orchestratorProfile`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个使用Calico网络的AKS Engine Linux集群，并且使用Azure CNI插件，你可以跟着配置你的pod的网络策略。使用这样的配置部署AKS
    Engine只需要对集群apimodel进行简单的更改，即在`properties.orchestratorProfile`中添加以下属性：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we will create a network policy that *blocks all ingress* traffic to all
    pods in the `default` namespace. This is the opposite of what you have in the
    cluster by default—the pods in the namespace will be not able to communicate with
    each other unless you specifically allow it. After that, we will deploy a simple
    Nginx web server behind a LoadBalancer service and try to communicate internally
    from a different pod in the cluster and externally from the Azure load balancer.
    Then we will create a network policy that will act as a **whitelisting rule**
    just for TCP port 80 for the web server. Please go through the following steps
    to create the default deny-all rule and deploy the Nginx web server:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个网络策略，*阻止所有*进入`default`命名空间中所有pod的流量。这与集群默认情况相反——命名空间中的pod将无法相互通信，除非你明确允许。之后，我们将部署一个简单的Nginx
    web服务器，后面是一个负载均衡器服务，并尝试从集群中的不同pod内部和Azure负载均衡器外部进行通信。然后，我们将创建一个网络策略，作为**白名单规则**，只针对web服务器的TCP端口80。请按照以下步骤创建默认拒绝所有规则并部署Nginx
    web服务器：
- en: 'Create a `default-deny-all-ingress.yaml` manifest file for the `NetworkPolicy` object
    that denies all ingress traffic to pods in the `default` namespace:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`NetworkPolicy`对象在`default`命名空间中拒绝所有进入流量创建一个名为`default-deny-all-ingress.yaml`的清单文件：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is achieved by using an empty `podSelector`, which will select all pods.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用空的`podSelector`来实现的，它将选择所有的pod。
- en: Apply the manifest file using the `kubectl apply -f .\default-deny-all-ingress.yaml`
    command.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl apply -f .\default-deny-all-ingress.yaml`命令应用清单文件。
- en: 'You can use the following command for any network policy if you want to better
    understand what its effect is:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想更好地理解任何网络策略的影响，可以使用以下命令：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a simple manifest file named `nginx-deployment.yaml` for Nginx deployment:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Nginx部署创建一个名为`nginx-deployment.yaml`的简单清单文件：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Apply the manifest file using the `kubectl apply -f .\nginx-deployment.yaml`
    command.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl apply -f .\nginx-deployment.yaml`命令应用清单文件。
- en: 'Create a `nginx-service.yaml` manifest file for the LoadBalancer service for
    the deployment:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为部署的负载均衡器服务创建一个名为`nginx-service.yaml`的清单文件：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Apply the manifest file using the `kubectl apply -f .\nginx-service.yaml` command.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl apply -f .\nginx-service.yaml`命令应用清单文件。
- en: Be careful when defining very restrictive egress rules. With deny-all egress
    rules, you will block access to the Kubernetes DNS service for the pods.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义非常严格的出口规则时要小心。使用拒绝所有出口规则，您将阻止pod访问Kubernetes DNS服务。
- en: 'With our Nginx web server deployed and the default rule for denying all ingress
    traffic to pods in the `default` namespace, we can test the connection to the
    web server:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过部署我们的Nginx web服务器和在`default`命名空间中拒绝所有入口流量到pod的默认规则，我们可以测试与web服务器的连接。
- en: Wait for the external IP of the service to appear using `kubectl get svc -w`
    and open the address in a web browser.You will see that the connection hangs and
    eventually times out, as expected.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待服务的外部IP出现，使用`kubectl get svc -w`命令，并在网络浏览器中打开该地址。您会看到连接挂起并最终超时，这是预期的。
- en: 'Let''s check this using an ad-hoc pod running in the same namespace. Create
    a `busybox` pod in the interactive mode, running a Bourne shell:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用交互模式中运行Bourne shell的`busybox` pod来检查这一点：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the shell session in the pod, try getting the web page hosted by Nginx.
    You can use both the service DNS name and the IP of one of the pods. In both cases
    it will fail:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在pod中的shell会话中，尝试获取Nginx托管的网页。您可以使用服务的DNS名称和其中一个pod的IP。在这两种情况下都会失败：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let''s create a network policy that allows ingress traffic to Nginx pods
    on TCP port `80`. After that, you will be able to communicate from both pods in
    the cluster, as well as from the Azure load balancer. To configure the policy,
    go through the following steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个网络策略，允许TCP端口`80`上的入口流量到Nginx pod。之后，您将能够从集群中的两个pod以及Azure负载均衡器进行通信。要配置策略，请按照以下步骤进行：
- en: Leave the `busybox` interactive session running and open a new PowerShell window.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让`busybox`交互会话保持运行，并打开一个新的PowerShell窗口。
- en: 'Create a `default-nginx-allow-ingress.yaml` manifest file that allows ingress
    traffic on TCP port `80` to all pods with label `app=nginx` from all sources:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`default-nginx-allow-ingress.yaml`的清单文件，允许TCP端口`80`上的入口流量到所有带有标签`app=nginx`的pod，来自所有来源：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Apply the manifest file using the `kubectl apply -f .\default-nginx-allow-ingress.yaml`
    command.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl apply -f .\default-nginx-allow-ingress.yaml`命令应用清单文件。
- en: In your web browser, navigate again to the external IP for the service. Now,
    you should be able to reach the web page without any problems!
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中，再次导航到服务的外部IP。现在，您应该能够毫无问题地访问网页！
- en: Similarly, try the same in the `busybox` pod container using `wget`. You will
    also be able to reach the web page.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，在`busybox` pod容器中使用`wget`尝试相同的操作。您也将能够访问网页。
- en: As an exercise, to prove that port filtering works properly, you can modify
    the network policy to use a different port or run Nginx on a TCP port different
    than `80`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为练习，为了证明端口过滤正常工作，您可以修改网络策略以使用不同的端口，或者在TCP端口上运行不同于`80`的Nginx。
- en: Congratulations! You have successfully used network policies to configure permissive
    networking rules in your Kubernetes cluster. It is a good practice to start with
    a *permissive *network policy model where you *deny all ingress* traffic to your
    pods (sometimes also all egress traffic from the pods) and allow the connections
    by specific network policies. Please note that, for this, you should organize
    the network policies in a predictable manner, using naming conventions. This will
    make the management of your networking rules much easier.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功使用网络策略在Kubernetes集群中配置了宽松的网络规则。从*permissive*网络策略模型开始是一个很好的做法，您可以拒绝所有入口流量到您的pod（有时也是所有出口流量从pod），并通过特定的网络策略允许连接。请注意，为此，您应该以可预测的方式组织网络策略，使用命名约定。这将使您的网络规则管理变得更加容易。
- en: In the next section, we will explore how you should handle Kubernetes secrets
    on Windows machines.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将探讨如何在Windows机器上处理Kubernetes secrets。
- en: Kubernetes secrets on Windows machines
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows机器上的Kubernetes secrets
- en: In [Chapter 4](118e3c89-786e-4718-ba67-6c38928e2a42.xhtml), *Kubernetes Concepts
    and Windows Support*, we mentioned that one of Windows's node support limitations
    is that Kubernetes secrets that are mounted to pods as volumes are written in
    *clear-text* on node disk storage (not RAM memory). The reason for this is that
    Windows currently does not support mounting in-memory filesystems to pod containers.
    This may pose security risks, and needs additional actions to secure the cluster.
    At the same time, mounting secrets as environment variables has its own security
    risks—you can enumerate environment variables for processes if you have access
    to the system. Until it is possible to mount secrets as volumes from in-memory
    filesystems, there is no completely secure solution for injecting secrets for
    Windows containers apart from using third-party providers, such as Azure Key Vault.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](118e3c89-786e-4718-ba67-6c38928e2a42.xhtml)中，*Kubernetes概念和Windows支持*，我们提到Windows节点支持的限制之一是，挂载到pod的Kubernetes
    secrets作为卷写入节点磁盘存储（而不是RAM内存）时是明文。原因是Windows目前不支持将内存文件系统挂载到pod容器。这可能带来安全风险，并需要额外的操作来保护集群。同时，将secrets作为环境变量挂载也有其自己的安全风险——如果有系统访问权限，可以枚举进程的环境变量。在可以从内存文件系统挂载secrets作为卷之前，除了使用Azure
    Key Vault等第三方提供者，没有完全安全的解决方案来为Windows容器注入secrets。
- en: Encryption of secrets *at rest* in a Kubernetes etcd cluster is a different
    and important topic that is covered in the official documentation at [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes etcd集群中*at rest*加密secrets是一个不同且重要的主题，在官方文档中有介绍：[https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)。
- en: 'Let''s perform a small experiment to better understand the issue and any possible
    implications. You will need your AKS Engine cluster with Windows nodes that we
    used in the previous chapters. Please go through the following steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一个小实验，以更好地理解问题和可能的影响。您将需要在前几章中使用的带有Windows节点的AKS引擎集群。请按照以下步骤进行：
- en: 'Open the PowerShell window and create a `secret-example.yaml` manifest file
    that contains the username `admin` and password `Password123` encoded in Base64:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开PowerShell窗口，并创建一个包含用户名`admin`和密码`Password123`的Base64编码的`secret-example.yaml`清单文件：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Apply the manifest file using the `kubectl apply -f .\secret-example.yaml` command.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl apply -f .\secret-example.yaml`命令应用清单文件。
- en: 'Create the `windows-example-deployment.yaml` manifest file for the deployment
    of the sample ASP.NET application running on Windows with a `secret-example` 
    secret mounted in the `C:\SecretExample` directory on the pod:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`windows-example-deployment.yaml`清单文件，用于部署在Windows上运行的示例ASP.NET应用程序，并在pod的`C:\SecretExample`目录中挂载`secret-example`
    secret：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Apply the manifest file using the `kubectl apply -f .\windows-example-deployment.yaml` command.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl apply -f .\windows-example-deployment.yaml`命令应用清单文件。
- en: Determine which Windows node is running the pod using the `kubectl get pods
    -o wide` command. In our case, it is `2972k8s011`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl get pods -o wide`命令确定运行pod的Windows节点。在我们的情况下，是`2972k8s011`。
- en: Follow the instructions from [Chapter 8](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml), *Deploying
    Hybrid Azure Kubernetes Service Engine Cluster* in the subsection *Connecting
    to virtual machines* in order to create a remote desktop connection to node `2972k8s011`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请按照[第8章](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml)中的*部署混合Azure Kubernetes服务引擎集群*的子章节*连接到虚拟机*中的说明，创建到节点`2972k8s011`的远程桌面连接。
- en: 'When a command-line prompt initializes, use the `docker ps` command to identify
    the ID of the Docker container that runs our application. Next, run the `docker
    inspect -f {{.Mounts}} <containerID>` command to get the *physical* location of
    the Docker volume data on the *host''s* disk storage:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当命令行提示初始化时，使用`docker ps`命令来识别运行我们应用程序的Docker容器的ID。接下来，运行`docker inspect -f {{.Mounts}}
    <containerID>`命令来获取Docker卷数据在*主机*磁盘存储上的*物理*位置：
- en: '![](assets/80d43a8d-4ef0-4490-9a21-8abc4d804b13.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/80d43a8d-4ef0-4490-9a21-8abc4d804b13.png)'
- en: 'Now, simply use this path, check the directory contents, and use the `type
    <filePath>` command to reveal the contents of the file that maps to the `password`
    key in our secret object:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只需使用这个路径，检查目录内容，并使用`type <filePath>`命令来显示与我们秘密对象中`password`键对应的文件的内容：
- en: '![](assets/cfb041d5-5118-4ffd-ab46-4b8bbee2bd2a.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cfb041d5-5118-4ffd-ab46-4b8bbee2bd2a.png)'
- en: As you can see, we have retrieved the `Password123` value without any problems.
    On a Linux system that uses an in-memory *tmpfs* filesystem for mounting volumes
    into secrets, it wouldn't be that easy!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已经毫无问题地检索到了`Password123`的值。在使用内存中的*tmpfs*文件系统将卷挂载到秘密中的Linux系统上，这并不容易！
- en: 'This current design has an obvious security issue: whoever manages to access
    the node disk storage data can get your secrets (currently used) in *plain-text*.
    This concerns not only the access to the machine itself (physical or remote) but
    also the *backups* of your disks that store Docker volumes.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种当前设计存在明显的安全问题：任何能够访问节点磁盘存储数据的人都可以获取您的秘密（当前使用的）*明文*。这不仅涉及到对机器本身（物理或远程）的访问，还涉及到存储Docker卷的磁盘的*备份*。
- en: To mitigate this issue, at least to some extent, you should use *disk encryption*
    for the Windows node disks. In an on-premises scenario, you can consider using
    BitLocker, which has native support on the Windows server operating system; you
    can find more details in the official documentation at [https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-how-to-deploy-on-windows-server](https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-how-to-deploy-on-windows-server).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在一定程度上缓解这个问题，您应该为Windows节点磁盘使用*磁盘加密*。在内部部署的场景中，您可以考虑使用BitLocker，在Windows服务器操作系统上有原生支持；您可以在官方文档中找到更多详细信息[https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-how-to-deploy-on-windows-server](https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-how-to-deploy-on-windows-server)。
- en: For Azure deployments, the good news is that Azure VM disks are always *encrypted
    at rest in Azure data centers*. If your scenario requires you to provide encryption
    at VM-operating-system level, then this feature is not supported yet for managed
    AKS ([https://github.com/Azure/AKS/issues/629](https://github.com/Azure/AKS/issues/629)),
    and, in the case of AKS Engine, the node VMs are created by default without encryption
    (you cannot control them in the cluster apimodel), but you can enable it manually
    yourself. You can read more about scenarios for Windows VM encryption in the official
    documentation at [https://docs.microsoft.com/en-us/azure/virtual-machines/windows/disk-encryption-windows](https://docs.microsoft.com/en-us/azure/virtual-machines/windows/disk-encryption-windows).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Azure部署来说，好消息是Azure VM磁盘始终在Azure数据中心*静态加密*。如果您的场景要求您在VM操作系统级别提供加密，那么对于托管的AKS来说，这个功能目前还不支持（[https://github.com/Azure/AKS/issues/629](https://github.com/Azure/AKS/issues/629)），而对于AKS
    Engine，节点VM默认情况下是没有加密的（您无法在集群apimodel中控制它们），但您可以手动启用它。您可以在官方文档中阅读有关Windows VM加密方案的更多信息[https://docs.microsoft.com/en-us/azure/virtual-machines/windows/disk-encryption-windows](https://docs.microsoft.com/en-us/azure/virtual-machines/windows/disk-encryption-windows)。
- en: 'To demonstrate how you can encrypt the Windows node disks manually, let''s
    turn on encryption for one of the nodes in our cluster, `2972k8s011`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何手动加密Windows节点磁盘，让我们为我们集群中的一个节点`2972k8s011`打开加密：
- en: 'Open the PowerShell window and create an Azure key vault named `AksEngineEncryptionVault`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开PowerShell窗口并创建一个名为`AksEngineEncryptionVault`的Azure密钥保管库：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Enable the usage of the key vault for disk encryption for Azure VMs:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用密钥保管库用于Azure VM的磁盘加密：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Enable encryption of the `2972k8s011` node for `All` disks mounted to the VM:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`All`挂载到VM的`2972k8s011`节点启用磁盘加密：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When the encryption process is finished, check the current status of the encryption
    feature:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密过程完成后，检查加密功能的当前状态：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This process would have to be repeated for all Windows nodes in the cluster
    and repeated whenever you scale your cluster.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程必须重复进行，对集群中的所有Windows节点进行重复，并且在扩展集群时也必须重复进行。
- en: Congratulations! You have successfully encrypted a Windows node disk in order
    to increase Kubernetes secret security.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功加密了Windows节点磁盘，以增加Kubernetes密钥安全性。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has focused on Kubernetes security in general. We have provided
    you with 11 recommendations and best practices for securing your Kubernetes cluster,
    from using RBAC and integrating an external authentication provider, such as Azure
    Active Directory, to disabling public access for the Kubernetes API and Dashboard
    and enabling audit logging. We demonstrated how to make your RBAC management and
    authentication easier on AKS Engine clusters using Azure Active Directory integration.
    Next, we discussed how to secure container runtime in Kubernetes and the role
    of network policies (which are not supported on Windows nodes yet).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要关注了Kubernetes安全性。我们为您提供了11条保护Kubernetes集群的建议和最佳实践，从使用RBAC和集成外部身份验证提供程序，如Azure
    Active Directory，到禁用Kubernetes API和仪表板的公共访问以及启用审计日志记录。我们演示了如何在AKS Engine集群上使用Azure
    Active Directory集成来简化RBAC管理和身份验证。接下来，我们讨论了如何在Kubernetes中保护容器运行时以及网络策略的作用（目前尚不支持在Windows节点上）。
- en: And lastly, you learned the differences between the injection of Kubernetes
    secrets on Linux and Windows machines and saw that, with the current design, accessing
    secrets on Windows machines is easier and can cause security problems. To mitigate
    this, we showed you how you can encrypt disks for Azure VMs that are used as Windows
    nodes in your cluster.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您了解了在Linux和Windows机器上注入Kubernetes密钥的区别，并且看到了，根据当前设计，访问Windows机器上的密钥更容易，可能会导致安全问题。为了缓解这一问题，我们向您展示了如何为在集群中用作Windows节点的Azure
    VM加密磁盘。
- en: In the next chapter, we will focus on how to approach the monitoring of Kubernetes
    clusters, especially Windows nodes and .NET applications running on Windows nodes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重点讨论如何监视Kubernetes集群，特别是运行在Windows节点上的.NET应用程序。
- en: Questions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why should you use an external authentication provider in Kubernetes, such as
    AAD?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么应该在Kubernetes中使用外部身份验证提供程序，比如AAD？
- en: Why is disabling public access to Kubernetes Dashboard important?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用对Kubernetes仪表板的公共访问为什么重要？
- en: What is the reason for recommending the encryption of etcd data storage at rest?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么建议对etcd数据存储进行加密？
- en: Can you run privileged containers on Windows machines?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在Windows机器上运行特权容器吗？
- en: What are network policies in Kubernetes and what are the prerequisites to have
    them enabled?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes中的网络策略是什么，启用它们的先决条件是什么？
- en: What is the main difference between Linux and Windows nodes when it comes to
    mounting secrets as volumes?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux和Windows节点在挂载密钥作为卷时的主要区别是什么？
- en: Why is injecting secrets as environment variables considered less safe than
    using volumes, especially on Linux nodes?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么将密钥作为环境变量注入被认为比在Linux节点上使用卷不安全？
- en: You can find answers to these questions in *Assessments* of this book.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的*评估*中找到这些问题的答案。
- en: Further reading
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about Kubernetes security, please refer to the following
    PacktPub books:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Kubernetes安全性的更多信息，请参考以下PacktPub图书：
- en: '*The Com**plete Kubernetes Guide* ([https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide)).'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*The Complete Kubernetes Guide*（[https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide)）。'
- en: '*Getting Started with Kubernetes - Third Edition* ([https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition)).'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes入门-第三版（[https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition)）。
- en: '*Kubernetes fo**r Developers* ([https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers)).'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kubernetes for Developers*（[https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers)）。'
