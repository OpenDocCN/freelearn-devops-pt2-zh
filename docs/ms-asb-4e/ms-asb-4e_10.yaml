- en: '*Chapter 8*: Composing Reusable Ansible Content with Roles'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：使用角色组合可重用的Ansible内容'
- en: For many projects, a simple, single **Ansible** playbook may suffice. As time
    goes on and projects grow, additional playbooks and variable files are added,
    and task files may be split. Other projects within an organization may want to
    reuse some of the content, and either the projects get added to the directory
    tree or the desired content may get copied across multiple projects. As the complexity
    and size of the scenario grow, something more than a loosely organized handful
    of playbooks, task files, and variable files is highly desired. Creating such
    a hierarchy can be daunting and may explain why many Ansible implementations start
    off simple and only become more organized once the scattered files become unwieldy
    and a hassle to maintain. Making the migration can be difficult and may require
    rewriting significant portions of playbooks, which can further delay reorganization
    efforts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多项目，一个简单的、单一的**Ansible**剧本可能就足够了。随着时间的推移和项目的增长，会添加额外的剧本和变量文件，并且任务文件可能会被拆分。组织内的其他项目可能希望重用一些内容，要么将项目添加到目录树中，要么将所需内容复制到多个项目中。随着场景的复杂性和规模的增长，远不止一个松散组织的一小部分剧本、任务文件和变量文件是非常需要的。创建这样的层次结构可能是令人生畏的，这也可以解释为什么许多Ansible实现一开始都很简单，只有在分散的文件变得难以控制和难以维护时才变得更加有组织。迁移可能很困难，并且可能需要重写剧本的重要部分，这可能会进一步延迟重新组织的努力。
- en: 'In this chapter, we will cover best practices for composable, reusable, and
    well-organized content within Ansible. The lessons learned in this chapter will
    help developers design Ansible content that grows well with the project, avoiding
    the need for difficult redesign work later. The following is an outline of what
    we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍在Ansible中组合、可重用和组织良好的最佳实践。本章中学到的经验将帮助开发人员设计能够与项目良好增长的Ansible内容，避免以后需要进行困难的重新设计工作。以下是我们将要涵盖的内容大纲：
- en: Task, handler, variable, and playbook inclusion concepts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务、处理程序、变量和剧本包含概念
- en: Roles (structures, defaults, and dependencies)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色（结构、默认值和依赖项）
- en: Designing top-level playbooks to utilize roles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计顶层剧本以利用角色
- en: Sharing roles across projects (dependencies via Galaxy; Git-like repositories)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目之间共享角色（通过Galaxy进行依赖项；类似Git的存储库）
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples presented in this chapter, you will need a Linux machine
    running **Ansible 4.3** or newer. Almost any flavor of Linux should do—for those
    interested in specifics, all the code presented in this chapter was tested on
    **Ubuntu Server 20.04 Long-Term Support** (**LTS**) unless stated otherwise, and
    on Ansible 4.3\.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照本章中提供的示例，您需要一台运行**Ansible 4.3**或更新版本的Linux机器。几乎任何Linux版本都可以——对于那些对具体情况感兴趣的人，本章中提供的所有代码都是在**Ubuntu
    Server 20.04长期支持版**（**LTS**）上测试的，除非另有说明，并且在Ansible 4.3上也进行了测试。
- en: 'The example code that accompanies this chapter can be downloaded from GitHub
    at this link: [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter08).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章附带的示例代码可以从GitHub的以下链接下载：[https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter08)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3E0mmIX](https://bit.ly/3E0mmIX).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际操作：[https://bit.ly/3E0mmIX](https://bit.ly/3E0mmIX)。
- en: Task, handler, variable, and playbook inclusion concepts
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务、处理程序、变量和剧本包含概念
- en: The first step to understanding how to efficiently organize an Ansible project
    structure is to master the concept of including files. The act of including files
    allows content to be defined in a topic-specific file that can be included in
    other files one or more times within a project. This inclusion feature supports the
    concept of **Don't Repeat Yourself** (**DRY**).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何高效组织Ansible项目结构的第一步是掌握包含文件的概念。包含文件的行为允许在一个专题文件中定义内容，并在项目中的一个或多个文件中包含这些内容。这种包含功能支持**不要重复自己**（**DRY**）的概念。
- en: Including tasks
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包括任务
- en: Task files are **YAML Ain't Markup Language** (**YAML**) files that define one
    or more tasks. These tasks are not directly tied to any particular play or playbook;
    they exist purely as a list of tasks. These files can be referenced by **playbooks**
    or other task files by way of the `include` operator. Now, you might expect the
    `include` operator to be a keyword of Ansible in its own right—however, this is
    not the case; it is actually a module just like `ansible.builtin.debug`. For conciseness,
    we will refer to it in this chapter as the `include` operator, but when we say
    this, your code will actually contain the **Fully Qualified Collection Name**
    (**FQCN**—see [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047), *Migrating
    from Earlier Ansible Versions*), which is `ansible.builtin.include`. You'll see
    this in action very shortly, so don't worry—this will all make sense soon! This
    operator takes a path to a task file, and as we learned in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The System
    Architecture and Design of Ansible*, the path can be relative to the file referencing
    it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 任务文件是**YAML Ain't Markup Language**（**YAML**）文件，用于定义一个或多个任务。这些任务与任何特定的游戏或剧本没有直接联系；它们纯粹存在作为任务列表。这些文件可以通过`include`运算符被**剧本**或其他任务文件引用。现在，您可能期望`include`运算符是Ansible自己的关键字——然而，事实并非如此；它实际上是一个模块，就像`ansible.builtin.debug`一样。为了简洁起见，我们在本章中将其称为`include`运算符，但当我们说这个时候，您的代码实际上将包含**Fully
    Qualified Collection Name**（**FQCN**—参见[*第2章*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047)，*从早期Ansible版本迁移*），即`ansible.builtin.include`。您很快就会看到它的作用，所以不用担心——这一切很快就会讲得通！这个运算符接受一个任务文件的路径，正如我们在[*第1章*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015)中学到的那样，*Ansible的系统架构和设计*，路径可以是相对于引用它的文件的。
- en: 'To demonstrate how to use the `include` operator to include tasks, let''s create
    a simple play that includes a task file with some debug tasks within it. First,
    let''s write our playbook file, which we''ll call `includer.yaml`, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用`include`运算符来包含任务，让我们创建一个简单的play，其中包含一个带有一些调试任务的任务文件。首先，让我们编写我们的playbook文件，我们将其命名为`includer.yaml`，如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we''ll create a `more-tasks.yaml` file you can see referenced in the
    `include` statement. This should be created in the same directory that holds `includer.yaml`.
    The code is illustrated in the following snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`more-tasks.yaml`文件，你可以在`include`语句中看到它的引用。这应该在保存`includer.yaml`的同一目录中创建。代码如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we can execute our playbook with the following command to observe the
    output:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令执行我们的playbook以观察输出：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If all goes well, you should see output similar to this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该看到类似于这样的输出：
- en: '![Figure 8.1 – Executing an Ansible playbook that includes a separate task
    file'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 - 执行包含单独任务文件的Ansible playbook'
- en: '](Images/B17462_08_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_01.jpg)'
- en: Figure 8.1 – Executing an Ansible playbook that includes a separate task file
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 - 执行包含单独任务文件的Ansible playbook
- en: 'We can clearly see our tasks from the `include` file execution. Because the `include` operator
    was used within the play''s `tasks` section, the included tasks were executed
    within that play. In fact, if we were to add a task to the play after the `include` operator,
    as illustrated in the following code snippet, we would see that the order of execution
    follows as if all the tasks from the included file existed at the spot the `include` operator
    was used:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到我们的`include`文件执行的任务。因为`include`运算符是在play的`tasks`部分中使用的，所以包含的任务在该play中执行。实际上，如果我们在`include`运算符之后向play添加一个任务，如下面的代码片段所示，我们会看到执行顺序遵循包含文件的所有任务存在的位置：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we run our modified playbook using the same command as before, we will see
    the task order we expect, as the following screenshot demonstrates:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用与之前相同的命令运行我们修改后的playbook，我们将看到我们期望的任务顺序，如下面的截图所示：
- en: '![Figure 8.2 – Demonstrating the order of task execution in a playbook that
    uses the include operator'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 - 演示使用include运算符的playbook中任务执行顺序'
- en: '](Images/B17462_08_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_02.jpg)'
- en: Figure 8.2 – Demonstrating the order of task execution in a playbook that uses
    the include operator
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 - 演示使用include运算符的playbook中任务执行顺序
- en: By breaking these tasks into their own file, we could include them multiple
    times or in multiple playbooks. If we ever have to alter one of the tasks, we only have
    to alter a single file, no matter how many places this file gets referenced.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些任务拆分成它们自己的文件，我们可以多次包含它们或在多个playbook中包含它们。如果我们需要修改其中一个任务，我们只需要修改一个文件，无论这个文件被引用了多少次。
- en: Passing variable values to included tasks
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将变量值传递给包含的任务
- en: Sometimes, we want to split out a set of tasks but have those tasks act slightly differently
    depending on the variable data. The `include` operator allows us to define and
    override variable data at the time of inclusion. The scope of the definition is
    only within the included task file (and any other files that file may itself include).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想要拆分一组任务，但这些任务的行为可能会根据变量数据略有不同。`include`运算符允许我们在包含时定义和覆盖变量数据。定义的范围仅限于包含的任务文件（以及该文件可能包含的任何其他文件）。
- en: 'To illustrate this capability, let''s create a new scenario in which we need
    to touch a couple of files, each in their own directory path. Instead of writing
    two file tasks for each file (one to create a directory and another to touch the
    file), we''ll create a task file with each task that will use variable names in
    the tasks. Then, we''ll include the task file twice, each time passing different
    data in. First, we''ll do this with the `files.yaml` task file, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这种能力，让我们创建一个新的场景，我们需要触摸两个文件，每个文件都在自己的目录路径中。我们将创建一个任务文件，其中包含每个任务的变量名称。然后，我们将两次包含任务文件，每次传递不同的数据。首先，我们将使用`files.yaml`任务文件，如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we''ll modify our `includer.yaml` playbook to include the task file we''ve
    just created, passing along variable data for the `path` and `file` variables,
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改我们的`includer.yaml` playbook，包含我们刚刚创建的任务文件，并传递`path`和`file`变量的变量数据，如下所示：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Important Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Variable definitions provided when including files can either be in the inline
    format of `key=value` or in the illustrated YAML format of `key: value` inside
    a `vars` hash.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '在包含文件时提供的变量定义可以是`key=value`的内联格式，也可以是`key: value`的YAML格式，位于`vars`哈希内。'
- en: 'When we run this playbook, we''ll see four tasks get executed: the two tasks
    from within the included `files.yaml` file twice. The second set should result
    in only one change as the path is the same for both sets, and should be created
    the first time the task is executed. Run the playbook with added verbosity so
    that we can see a little more about what''s going on under the hood, by using
    the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个playbook时，我们将看到四个任务被执行：两个任务来自包含的`files.yaml`文件，每个任务执行两次。第二组应该只有一个更改，因为两组的路径相同，并且应该在执行任务时创建。通过使用以下命令添加详细信息来运行playbook，以便我们可以更多地了解底层发生了什么：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output from running this playbook should look something like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此playbook的输出应该类似于这样：
- en: '![Figure 8.3 – Running a playbook where a task file is included twice with
    different variable data'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 - 运行一个包含两个不同变量数据的任务文件的playbook'
- en: '](Images/B17462_08_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_03.jpg)'
- en: Figure 8.3 – Running a playbook where a task file is included twice with different
    variable data
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 - 运行一个包含两个不同变量数据的任务文件的playbook
- en: As can be seen here, the code to create a leading path and a file is being reused,
    just with different values each time, making our code really efficient to maintain.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这里所看到的，用于创建前导路径和文件的代码被重复使用，每次只是使用不同的值，使我们的代码非常高效易于维护。
- en: Passing complex data to included tasks
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将复杂数据传递给包含的任务
- en: 'When wanting to pass complex data to included tasks, such as a list or hash,
    an alternative syntax can be used when including the file. Let''s repeat the previous
    scenario, only this time instead of including the task file twice, we''ll include
    it once and pass a hash of the paths and files in. First, we''ll recreate the `files.yaml` file,
    as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当想要向包含的任务传递复杂数据，比如列表或哈希时，可以在包含文件时使用另一种语法。让我们重复上一个场景，只是这次不是两次包含任务文件，而是一次包含并传递路径和文件的哈希。首先，我们将重新创建`files.yaml`文件，如下所示：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we''ll alter our `includer.yaml` playbook to provide the file''s hash
    in a single `ansible.builtin.include` statement, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修改我们的`includer.yaml` playbook，以提供文件的哈希值在单个`ansible.builtin.include`语句中，如下所示：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we run this new playbook and task file as before, we should see a similar
    but slightly different output, the end result of which is the `/tmp/foo` directory
    already in place and the two `herp` and `derp` files being created as empty files
    (touched) within, as the following screenshot shows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像以前一样运行这个新的playbook和任务文件，我们应该会看到一个类似但略有不同的输出，最终结果是`/tmp/foo`目录已经存在，并且两个`herp`和`derp`文件被创建为空文件（被触摸）在其中，如下面的截图所示：
- en: '![Figure 8.4 – Passing complex data to an included task file in an Ansible
    play'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 - 将复杂数据传递给Ansible play中包含的任务文件'
- en: '](Images/B17462_08_04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_04.jpg)'
- en: Figure 8.4 – Passing complex data to an included task file in an Ansible play
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 - 将复杂数据传递给Ansible play中包含的任务文件
- en: Using this manner of passing in a hash of data allows the growth of a set of
    things created without having to grow the number of `include` statements in the
    main playbook.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式传递数据的哈希允许创建一组事物，而无需在主playbook中增加`include`语句的数量。
- en: Conditional task includes
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件任务包括
- en: Similar to passing data into included files, conditionals can also be passed
    into included files. This is accomplished by attaching a `when` statement to the `include` operator.
    This conditional does not cause Ansible to evaluate the test to determine whether
    the file should be included; rather, it instructs Ansible to add the conditional
    to each and every task within the included file (and any other files the said
    file may include).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于将数据传递给包含的文件，条件也可以传递给包含的文件。这是通过将`when`语句附加到`include`运算符来实现的。这个条件并不会导致Ansible评估测试以确定是否应该包含文件；相反，它指示Ansible将条件添加到包含文件中的每个任务以及该文件可能包含的任何其他文件中。
- en: Important Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is not possible to conditionally include a file. Files will always be included;
    however, a task condition can be applied to every task within.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能有条件地包含一个文件。文件将始终被包含；但是，可以对`include`层次结构中的每个任务应用任务条件。
- en: 'Let''s demonstrate this by modifying our first example that includes simple
    debug statements. We''ll add a conditional and pass along some data for the conditional
    to use. First, let''s modify the `includer.yaml` playbook, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过修改包含简单调试语句的第一个示例来演示这一点。我们将添加一个条件并传递一些数据供条件使用。首先，让我们修改`includer.yaml` playbook，如下所示：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, let''s modify `more-tasks.yaml` to loop over the `a_list` variable in
    each task, like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们修改`more-tasks.yaml`，在每个任务中循环`a_list`变量，如下所示：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s run the playbook with the same command as before and see our new
    output, which should look like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用与之前相同的命令运行playbook，并查看我们的新输出，应该是这样的：
- en: '![Figure 8.5 – Applying conditionals to all tasks in an included file'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 - 将条件应用于包含文件中的所有任务'
- en: '](Images/B17462_08_05.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_05.jpg)'
- en: Figure 8.5 – Applying conditionals to all tasks in an included file
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 - 将条件应用于包含文件中的所有任务
- en: We can see a skipped iteration per task, the iteration where `item` was evaluated
    to a `false` Boolean. It's important to remember that all hosts will evaluate
    all included tasks. There is no way to influence Ansible to not include a file
    for a subset of hosts. At most, a conditional can be applied to every task within
    an `include` hierarchy so that included tasks may be skipped. One method to include
    tasks based on host facts is to utilize the `ansible.builtin.group_by` action
    plugin to create dynamic groups based on host facts. Then, you can give the groups
    their own plays to include specific tasks. This is an exercise left up to you.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到每个任务的跳过迭代，其中`item`被评估为`false`布尔值。重要的是要记住，所有主机都将评估所有包含的任务。没有办法影响Ansible不为一部分主机包含文件。最多，可以对`include`层次结构中的每个任务应用条件，以便可以跳过包含的任务。根据主机事实包含任务的一种方法是利用`ansible.builtin.group_by`动作插件根据主机事实创建动态组。然后，您可以为这些组提供自己的play以包含特定的任务。这是留给您的一个练习。
- en: Tagging included tasks
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对包含的任务进行标记
- en: When including task files, it is possible to tag all tasks within the file.
    The `tags` key is used to define one or more tags to apply to all tasks within
    the `include` hierarchy. The ability to tag at `include` time can keep the task
    file itself unopinionated about how the tasks should be tagged and can allow for
    a set of tasks to be included multiple times but with different data and tags
    passed along.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含任务文件时，可以对文件中的所有任务进行标记。`tags`关键字用于定义要应用于`include`层次结构中所有任务的一个或多个标记。在`include`时进行标记的能力可以使任务文件本身不对任务应该如何标记持有意见，并且可以允许一组任务被多次包含，但传递不同的数据和标记。
- en: Important Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Tags can be defined at the `include` statement or at the play itself to cover
    all includes (and other tasks) in a given play.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`include`语句或play本身中定义标记，以覆盖给定play中所有包含（和其他任务）。
- en: 'Let''s create a simple demonstration to illustrate how tags can be used. We''ll
    start by editing our `includer.yaml` file to create a playbook that includes a
    task file twice, each with a different tag name and different variable data. The
    code is illustrated in the following snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的演示来说明标记如何使用。我们将首先编辑我们的`includer.yaml`文件，创建一个包含任务文件的playbook，每个任务文件都有不同的标记名称和不同的变量数据。代码如下所示：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we''ll update `more-tasks.yaml` to do something with the data being provided,
    as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更新`more-tasks.yaml`以处理提供的数据，如下所示：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we run this playbook without selecting tags, we''ll see this task run twice,
    as the following screenshot shows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在不选择标记的情况下运行这个playbook，我们将看到这个任务运行两次，如下的屏幕截图所示：
- en: '![Figure 8.6 – Running a playbook with tagged include tasks, but without any
    tag-based filtering enabled'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6 - 运行带有标记的包含任务的playbook，但没有启用任何基于标记的过滤'
- en: '](Images/B17462_08_06.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_06.jpg)'
- en: Figure 8.6 – Running a playbook with tagged include tasks, but without any tag-based
    filtering enabled
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 - 运行带有标记的包含任务的playbook，但没有启用任何基于标记的过滤
- en: 'Now, we can select which tag to run—say, the second tag—by altering our `ansible-playbook` arguments,
    as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过修改我们的`ansible-playbook`参数来选择要运行的标记，比如第二个标记，如下所示：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this instance, we should see only that occurrence of the included task being
    run, as the following screenshot shows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们应该只看到被包含任务的发生，如下的屏幕截图所示：
- en: '![Figure 8.7 – Running a playbook with tagged include tasks, only running tasks
    tagged "second"'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 - 运行带有标记的包含任务的playbook，只运行标记为"second"的任务'
- en: '](Images/B17462_08_07.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_07.jpg)'
- en: Figure 8.7 – Running a playbook with tagged include tasks, only running tasks
    tagged "second"
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 - 运行带有标记的包含任务的playbook，只运行标记为"second"的任务
- en: Our example used the `--tags` command-line argument to indicate which tagged
    tasks to run. A different argument, `--skip-tags`, allows expressing the opposite—or
    in other words, which tagged tasks not to run.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例使用`--tags`命令行参数来指示要运行的标记任务。另一个参数`--skip-tags`允许表示相反的意思，或者换句话说，不要运行哪些标记的任务。
- en: Task inclusions with loops
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环中的任务包含
- en: 'Task inclusions can be combined with loops as well. When adding a `loop` instance
    to a task inclusion (or a `with_` loop if using a version of Ansible earlier than
    2.5), the tasks inside the file will be executed with the `item` variable, which
    holds the place of the current loop''s value. The entire `include` file will be
    executed repeatedly until the loop runs out of items. Let''s update our example
    play to demonstrate this, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 任务包含也可以与循环结合使用。当向任务包含添加一个`loop`实例（或者如果使用早于2.5版本的Ansible，则使用`with_`循环），文件内的任务将使用`item`变量执行，该变量保存当前循环值的位置。整个`include`文件将重复执行，直到循环用完项目。让我们更新我们的示例play来演示这一点，如下所示：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We also need to update our `more-tasks.yaml` file to make use of the loop `item`
    variable, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新我们的`more-tasks.yaml`文件，以使用循环`item`变量，如下所示：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When executed with increased verbosity, we can tell that tasks `1` and `2` are
    executed a single time for each `item` variable in the loop, as the following
    screenshot shows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当以增加的详细程度执行时，我们可以看到任务`1`和`2`针对循环中的每个`item`变量执行一次，如下的屏幕截图所示：
- en: '![Figure 8.8 – Running an included task file in a loop'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8 - 在循环中运行包含的任务文件'
- en: '](Images/B17462_08_08.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_08.jpg)'
- en: Figure 8.8 – Running an included task file in a loop
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 - 在循环中运行包含的任务文件
- en: 'Looping on **inclusion** is a powerful concept, but it does introduce one problem.
    What if there were tasks inside the included file that have their own loops? There
    will be a collision of the `item` variable, creating unexpected outcomes. For
    this reason, the `loop_control` feature was added to Ansible in version 2.1\.
    Among other things, this feature provides a method to name the variable used for the loop,
    instead of the default of `item`. Using this, we can distinguish between the `item` instance
    that comes outside the inclusion from any `item` variables used inside the `include`
    statement. To demonstrate this, we''ll add a `loop_var` loop control to our outer `include`
    statement, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**包含**循环是一个强大的概念，但它确实引入了一个问题。如果包含的文件中有其自己循环的任务，会产生`item`变量的冲突，导致意外的结果。因此，在Ansible的2.1版本中添加了`loop_control`功能。除其他功能外，此功能提供了一种方法来命名用于循环的变量，而不是默认的`item`。使用这个功能，我们可以区分`include`语句外部的`item`实例和`include`语句内部使用的任何`item`变量。为了演示这一点，我们将在我们的外部`include`语句中添加一个`loop_var`循环控制，如下所示：'
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Inside `more-tasks.yaml`, we''ll have a task with its own loop, making use
    of `include_item` and the local `item` variable, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`more-tasks.yaml`中，我们将有一个带有自己循环的任务，使用`include_item`和本地的`item`变量，如下所示：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When executed, we see that `task 1` is executed twice per inclusion loop and
    that the two `loop` variables are used, as the following screenshot shows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，我们看到每次包含循环都会执行`任务1`两次，并且使用了两个`loop`变量，如下的屏幕截图所示：
- en: '![Figure 8.9 – Running a nested loop within an included task file, avoiding
    loop variable name collision'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9 - 在包含的任务文件中运行嵌套循环，避免循环变量名称冲突'
- en: '](Images/B17462_08_09.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_09.jpg)'
- en: Figure 8.9 – Running a nested loop within an included task file, avoiding loop
    variable name collision
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 - 在包含的任务文件中运行嵌套循环，避免循环变量名称冲突
- en: Other loop controls exist as well, such as `label`, which will define what is
    shown on the screen in the task output for the `item` value (useful for preventing large data
    structures from cluttering the screen), and `pause`, providing the ability to
    pause for a defined number of seconds between each loop.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他循环控制，比如`label`，它将定义在任务输出中显示在屏幕上的`item`值（用于防止大型数据结构在屏幕上混乱），以及`pause`，提供在每个循环之间暂停一定秒数的能力。
- en: Including handlers
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包括处理程序
- en: '**Handlers** are essentially tasks. They''re a set of potential tasks triggered
    by way of notifications from other tasks. As such, handler tasks can be included
    just as regular tasks can. The `include` operator is legal within the `handlers` block.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理程序**本质上是任务。它们是由其他任务的通知触发的一组潜在任务。因此，处理程序任务可以像常规任务一样被包含。`include`运算符在`handlers`块内是合法的。'
- en: Unlike with task inclusions, variable data cannot be passed along when including
    `handler` tasks. However, it is possible to attach a conditional to a `handler`
    inclusion, to apply the conditional to every `handler` task within the file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与任务包含不同，当包含`handler`任务时，无法传递变量数据。但是，可以将条件附加到`handler`包含中，以将条件应用于文件中的每个`handler`任务。
- en: 'Let''s create an example to demonstrate this. First, we''ll create a playbook
    that has a task that will always change, and that includes a `handler` task file
    and attaches a conditional to that inclusion. The code is illustrated in the following
    snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个示例来演示这一点。首先，我们将创建一个总是会改变的任务的playbook，并包含一个`handler`任务文件，并将条件附加到该包含中。代码如下所示：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Important Note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When evaluating a variable that may be defined outside a playbook, it's best
    to use the `bool` filter to ensure that strings are properly converted to their
    Boolean meaning.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估可能在playbook外定义的变量时，最好使用`bool`过滤器来确保字符串被正确转换为它们的布尔含义。
- en: 'Next, we''ll create a `handlers.yaml` file to define our `handler` task, as
    follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`handlers.yaml`文件来定义我们的`handler`任务，如下所示：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we execute this playbook without providing any further data, we should see
    our `handler` task trigger, as the following screenshot shows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在不提供任何进一步数据的情况下执行这个playbook，我们应该看到我们的`handler`任务被触发，如下面的截图所示：
- en: '![Figure 8.10 – Using the include operator to run a handler from a task file'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10 - 使用包含运算符从任务文件运行处理程序'
- en: '](Images/B17462_08_10.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_10.jpg)'
- en: Figure 8.10 – Using the include operator to run a handler from a task file
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 - 使用包含运算符从任务文件运行处理程序
- en: 'Now, let''s run the playbook again; this time, we''ll define `foo` as `extra-var` (overriding
    every other instance of it) and set it to `false` in our `ansible-playbook` execution
    arguments, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次运行playbook；这次，我们将在`ansible-playbook`执行参数中将`foo`定义为`extra-var`（覆盖每个其他实例），并将其设置为`false`，如下所示：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This time, the output will look somewhat different, as the following screenshot
    shows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，输出将看起来有些不同，如下面的截图所示：
- en: '![Figure 8.11 – Running the same play but this time forcing the foo conditional
    variable to false'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11 - 运行相同的play，但这次强制foo条件变量为false'
- en: '](Images/B17462_08_11.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_11.jpg)'
- en: Figure 8.11 – Running the same play but this time forcing the foo conditional
    variable to false
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 - 运行相同的play，但这次强制foo条件变量为false
- en: As `foo` evaluates to `false`, our included handler gets skipped in this run
    of the playbook.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`foo`评估为`false`，所以在这次运行playbook时我们的包含处理程序被跳过了。
- en: Including variables
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含变量
- en: '**Variable** data can also be separated into loadable files. This allows for
    the sharing of variables across multiple plays or playbooks or the inclusion of
    variable data that lives outside the project directory (such as secret data).
    Variable files are simple **YAML-formatted** files providing keys and values.
    Unlike task inclusion files, variable inclusion files cannot include more files.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量**数据也可以分开成可加载的文件。这允许在多个play或playbook之间共享变量，或者包含项目目录之外的变量数据（如秘密数据）。变量文件是简单的**YAML格式**文件，提供键和值。与任务包含文件不同，变量包含文件不能包含更多文件。'
- en: 'Variables can be included in three different ways: via `vars_files`, via `include_vars`,
    or via `--extra-vars` (`-e`).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以通过三种不同的方式包含：通过`vars_files`，通过`include_vars`，或通过`--extra-vars`(`-e`)。
- en: vars_files
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: vars_files
- en: The `vars_files` key is a play directive. It defines a list of files to read
    from to load variable data. These files are read and parsed at the time the playbook
    itself is parsed. Just as with including tasks and handlers, the path is relative
    to the file referencing the file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`vars_files`键是一个play指令。它定义了要从中读取变量数据的文件列表。这些文件在解析playbook本身时被读取和解析。与包含任务和处理程序一样，路径是相对于引用文件的文件的。'
- en: 'Here is an example play that loads variables from a file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个从文件加载变量的示例play：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we need to create a `variables.yaml` file in the same directory as our
    playbook, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在与我们的playbook相同的目录中创建一个`variables.yaml`文件，如下所示：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running the playbook with our usual command will show that the `varname` variable
    value is properly sourced from the `variables.yaml` file, as the following screenshot
    shows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们通常的命令运行playbook将显示`varname`变量值正确地从`variables.yaml`文件中获取，如下面的截图所示：
- en: '![Figure 8.12 – Including variables in a play using the vars_files directive'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12 - 使用vars_files指令在play中包含变量'
- en: '](Images/B17462_08_12.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_12.jpg)'
- en: Figure 8.12 – Including variables in a play using the vars_files directive
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 - 使用vars_files指令在play中包含变量
- en: This is, of course, a very simple example, but it clearly demonstrates the ease
    of importing variables from a separate file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个非常简单的例子，但它清楚地演示了从单独文件导入变量的简易性。
- en: Dynamic vars_files inclusion
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态vars_files包含
- en: 'In certain scenarios, it may be desirable to parameterize the variable files
    to be loaded. It is possible to do this by using a variable as part of the filename;
    however, the variable must have a value defined at the time the playbook is parsed,
    just as when using variables in task names. Let''s update our example play to
    load a variable file based on the data provided at execution time, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，希望参数化要加载的变量文件。可以通过使用变量作为文件名的一部分来实现这一点；然而，变量必须在解析playbook时有一个定义的值，就像在任务名称中使用变量时一样。让我们根据执行时提供的数据更新我们的示例play，以加载基于数据提供的变量文件，如下所示：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, when we execute the playbook, we''ll provide the value for `varfile` with
    the `-e` argument, using a command like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们执行playbook时，我们将使用类似以下命令的`-e`参数为`varfile`提供值：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output should look like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.13 – Dynamically loading a variables.yaml file at playbook runtime'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.13 - 在playbook运行时动态加载variables.yaml文件'
- en: '](Images/B17462_08_13.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_13.jpg)'
- en: Figure 8.13 – Dynamically loading a variables.yaml file at playbook runtime
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 - 在playbook运行时动态加载variables.yaml文件
- en: In addition to the variable value needing to be defined at execution time, the
    file to be loaded must also exist at execution time. This rule applies even if
    the file is generated by the Ansible playbook itself. Let's suppose that an Ansible
    playbook consists of four plays. The first play generates a YAML variable file.
    Then, further down, the fourth play references this file in a `vars_file` directive.
    Although it might initially appear as though this would work, the file does not
    exist at the point of execution (that is, when `ansible-playbook` is first run),
    and hence an error will be reported.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了需要在执行时定义变量值之外，要加载的文件也必须在执行时存在。即使文件是由Ansible playbook自己生成的，这条规则也适用。假设一个Ansible
    playbook由四个play组成。第一个play生成一个YAML变量文件。然后，在更下面，第四个play在`vars_file`指令中引用这个文件。尽管最初看起来这似乎会起作用，但是文件在执行时（即首次运行`ansible-playbook`时）并不存在，因此会报告错误。
- en: include_vars
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: include_vars
- en: A second method to include variable data from files is via the `include_vars` module.
    This module will load variables as a `task` action and will be done for each host.
    Unlike most modules, this module is executed locally on the Ansible host; therefore,
    all paths are still relative to the play file itself. Because the variable loading
    is done as a task, the evaluation of variables in the filename happens when the
    task is executed. Variable data in the filename can be host-specific and defined
    in a preceding task. Additionally, the file itself does not have to exist at execution
    time; it can be generated by a preceding task as well. This is a very powerful
    and flexible concept that can lead to very dynamic playbooks if used properly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 包含从文件中加载变量数据的第二种方法是通过`include_vars`模块。该模块将变量作为`task`操作加载，并将为每个主机执行。与大多数模块不同，此模块在Ansible主机上本地执行；因此，所有路径仍然相对于play文件本身。由于变量加载是作为任务执行的，因此在执行任务时会评估文件名中的变量。文件名中的变量数据可以是特定于主机的，并在前面的任务中定义。此外，文件本身在执行时不必存在；它也可以由前面的任务生成。如果使用正确，这是一个非常强大和灵活的概念，可以导致非常动态的playbook。
- en: 'Before getting ahead of ourselves, let''s demonstrate simple usage of `include_vars` by
    modifying our existing play to load the variable file as a task, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们通过修改现有的play来演示`include_vars`的简单用法，将变量文件加载为一个任务，如下所示：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Execution of the playbook remains the same as in the previous example, where
    we specified the value for the `varfile` variable as an extra variable. Our output
    differs only slightly from previous iterations, as the following screenshot shows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例一样，playbook的执行与之前的示例中保持一致，我们将`varfile`变量的值指定为额外变量。我们的输出与以前的迭代略有不同，如下面的截图所示：
- en: '![Figure 8.14 – Running a playbook utilizing the include_vars statement'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.14 - 运行使用include_vars语句的playbook'
- en: '](Images/B17462_08_14.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_14.jpg)'
- en: Figure 8.14 – Running a playbook utilizing the include_vars statement
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 - 运行使用include_vars语句的playbook
- en: Just as with other tasks, looping can be done to load more than one file in
    a single task. This is particularly effective when using the special `with_first_found` loop
    to iterate through a list of increasingly more generic filenames until a file
    is found to be loaded.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他任务一样，可以循环执行以在单个任务中加载多个文件。当使用特殊的`with_first_found`循环通过一系列越来越通用的文件名迭代直到找到要加载的文件时，这是特别有效的。
- en: 'Let''s demonstrate this by changing our play to use gathered host facts to
    try to load a variable file specific to the distribution, specific to the distribution
    family, or, finally, a default file, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过更改我们的play来演示这一点，使用收集的主机事实来尝试加载特定于分发的变量文件，特定于分发系列，或者最后是默认文件，如下所示：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The execution should look very similar to previous runs, only this time we''ll
    see a fact-gathering task, and we will not pass along extra variable data in the
    execution. The output should look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 执行应该看起来与以前的运行非常相似，只是这次我们将看到一个收集事实的任务，并且在执行中不会传递额外的变量数据。输出应该如下所示：
- en: '![Figure 8.15 – Dynamically including the first valid variables file found
    in an Ansible play'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15 - 动态包含在Ansible play中找到的第一个有效变量文件'
- en: '](Images/B17462_08_15.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_15.jpg)'
- en: Figure 8.15 – Dynamically including the first valid variables file found in
    an Ansible play
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 - 动态包含在Ansible play中找到的第一个有效变量文件
- en: We can also see from the output which file was found to load. In this case, `variables.yaml` was
    loaded, as the other two files did not exist. This practice is commonly used to
    load variables that are operating system-specific to the host in question. Variables
    for a variety of operating systems can be written out to appropriately named files.
    By utilizing the `ansible_distribution` variable, which is populated by fact-gathering,
    variable files that use `ansible_distribution` values as part of their name can
    be loaded by way of a `with_first_found` argument. A default set of variables
    can be provided in a file that does not use any variable data as a failsafe, as
    we did here in our `variables.yaml` file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从输出中看到找到要加载的文件。在这种情况下，`variables.yaml`被加载，因为其他两个文件不存在。这种做法通常用于加载特定于主机的操作系统的变量。可以将各种操作系统的变量写入适当命名的文件中。通过使用由收集事实填充的`ansible_distribution`变量，可以通过`with_first_found`参数加载使用`ansible_distribution`值作为其名称一部分的变量文件。可以在一个不使用任何变量数据的文件中提供一组默认变量作为备用，就像我们在`variables.yaml`文件中所做的那样。
- en: extra-vars
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: extra-vars
- en: 'The final method to load variable data from a file is to reference a file path
    with the `--extra-vars` (or `-e`) argument to `ansible-playbook`. Normally, this
    argument expects a set of `key=value` data; however, if a file path is provided
    and prefixed with the `@` symbol, Ansible will read the entire file to load variable
    data. Let''s alter one of our earlier examples, where we used `-e`, and instead
    of defining a variable directly on the command line, we''ll include the variable
    file we''ve already written out, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中加载变量数据的最终方法是使用`--extra-vars`（或`-e`）参数引用文件路径到`ansible-playbook`。通常，此参数期望一组`key=value`数据；但是，如果提供了文件路径并以`@`符号为前缀，Ansible将读取整个文件以加载变量数据。让我们修改我们之前的一个示例，其中我们使用了`-e`，而不是直接在命令行上定义变量，我们将包含我们已经编写的变量文件，如下所示：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When we provide a path after the `@` symbol, the path is relative to the current
    working directory, regardless of where the playbook itself lives. Let''s execute
    our playbook and provide a path to `variables.yaml`, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`@`符号后提供路径时，该路径是相对于当前工作目录的，而不管playbook本身位于何处。让我们执行我们的playbook并提供`variables.yaml`的路径，如下所示：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output should look like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.16 – Including a variables.yaml file through the extra variables
    command-line parameter'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.16 - 通过额外的变量命令行参数包含variables.yaml文件'
- en: '](Images/B17462_08_16.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_16.jpg)'
- en: Figure 8.16 – Including a variables.yaml file through the extra variables command-line
    parameter
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 - 通过额外的变量命令行参数包含variables.yaml文件
- en: Here, we can see that once again our `variables.yaml` file was included successfully,
    but, as you can see from the previous code, it is not even mentioned in the playbook
    itself—we were able to load it in its entirety through the `-e` flag.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的`variables.yaml`文件再次成功包含，但是，正如您从前面的代码中看到的那样，它甚至没有在playbook中提到 -
    我们能够通过`-e`标志完全加载它。
- en: Important Note
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When including a variable file with the `--extra-vars` argument, the file must
    exist at `ansible-playbook` execution time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--extra-vars`参数包含变量文件时，文件必须在`ansible-playbook`执行时存在。
- en: Variable inclusion is incredibly powerful in Ansible—but what about playbooks
    themselves? Here, things are a bit different, and as the chapter progresses, we
    will look at how to make effective use of reusable tasks and playbook code, thus
    encouraging good programming practices with Ansible.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible中，变量包含非常强大 - 但是playbooks本身呢？在这里，情况有所不同，随着本章的进行，我们将看到如何有效地重用任务和playbook代码，从而鼓励使用Ansible进行良好的编程实践。
- en: Including playbooks
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含playbooks
- en: Playbook files can include other whole playbook files. This construct can be
    useful to tie together a few independent playbooks into a larger, more comprehensive
    playbook. Playbook inclusion is a bit more primitive than task inclusion. You
    cannot perform variable substitution when including a playbook, you cannot apply
    conditionals, and you cannot apply tags, either. The playbook files to be included
    must exist at the time of execution as well.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Playbook文件可以包含其他整个playbook文件。这种结构对于将几个独立的playbook绑定成一个更大、更全面的playbook非常有用。Playbook包含比任务包含更为原始。在包含playbook时，您不能执行变量替换，也不能应用条件，也不能应用标签。要包含的playbook文件必须在执行时存在。
- en: 'Prior to Ansible 2.4, playbook inclusion was achieved using the `include` keyword—however,
    this was removed in Ansible 2.8, and so it should not be used. Instead, you should
    now use `ansible.builtin.import_playbook`. This is a play-level directive—it cannot
    be used as a task. However, it is very easy to use. Let''s define a simple example
    to demonstrate this. First, let''s create a playbook that will be included, called `includeme.yaml`.
    Here''s the code to do this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible 2.4之前，可以使用`include`关键字来实现playbook包含 - 但是在Ansible 2.8中已将其删除，因此不应使用。相反，现在应该使用`ansible.builtin.import_playbook`。这是一个play级别的指令
    - 不能用作任务。但是，它非常容易使用。让我们定义一个简单的示例来演示这一点。首先，让我们创建一个将被包含的playbook，名为`includeme.yaml`。以下是要执行此操作的代码：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you will no doubt recognize by now, this is a complete standalone playbook
    and we could run it in isolation using the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您现在无疑已经认识到的那样，这是一个完整的独立playbook，我们可以使用以下命令单独运行它：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A successful run will produce output like that shown here:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 成功运行将产生如下所示的输出：
- en: '![Figure 8.17 – Running our playbook to be included first as a standalone playbook'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17 - 首先作为独立playbook运行我们的playbook'
- en: '](Images/B17462_08_17.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_17.jpg)'
- en: Figure 8.17 – Running our playbook to be included first as a standalone playbook
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 - 首先作为独立playbook运行我们的playbook
- en: 'However, we can also import this into another playbook. Modify the original
    `includer.yaml` playbook so that it looks like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们也可以将其导入到另一个playbook中。修改原始的`includer.yaml` playbook，使其如下所示：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We then run it using this command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下命令运行它：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can see that both debug messages are displayed, and the imported playbook
    is run after the initial task, which is the sequence we defined in the original
    playbook. The following screenshot shows this in action:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到两条调试消息都显示出来，并且导入的playbook在初始任务之后运行，这是我们在原始playbook中定义的顺序。以下截图显示了这一点：
- en: '![Figure 8.18 – Running a playbook that includes a second playbook'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.18 - 运行包含第二个playbook的playbook'
- en: '](Images/B17462_08_18.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_18.jpg)'
- en: Figure 8.18 – Running a playbook that includes a second playbook
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18 - 运行包含第二个playbook的playbook
- en: In this way, it is very easy to reuse whole playbooks without needing to restructure
    them into the format of roles, task files, or otherwise. Note, however, that this
    feature is subject to active development in Ansible, so it is recommended that
    you always refer to the documentation to ensure you can achieve the results you
    are looking for.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，非常容易地重用整个playbooks，而无需将它们重构为角色、任务文件或其他格式。但是，请注意，此功能正在积极开发中，因此建议您始终参考文档，以确保您可以实现所需的结果。
- en: Roles (structures, defaults, and dependencies)
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色（结构、默认值和依赖关系）
- en: With a functional understanding of the inclusion of variables, tasks, handlers,
    and playbooks, we can move on to the more advanced topic of **roles**. Roles bring
    together these different facets of Ansible code creation to provide a fully independent
    collection of variables, tasks, files, templates, and modules that can be reused
    over again in different playbooks. Although not limited as such by design, it
    is normal practice for each role to be typically limited to a particular purpose
    or desired end result, with all the necessary steps to reach that result either
    within the role itself or through dependencies (in other words, further roles
    that themselves are specified as dependencies of a role). It is important to note
    that roles are not playbooks, and there is no way to directly execute a role.
    Roles have no settings for which host(s) the role will apply to. Top-level playbooks
    are the glue that binds the hosts from your inventory to roles that should be
    applied to those hosts. As we saw in [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047),
    *Migrating from Earlier Ansible Versions*, roles can also be part of Ansible collections.
    As we have already looked at the structure of collections in this earlier chapter,
    in this section we will focus in greater depth on how to construct the roles themselves.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对变量、任务、处理程序和剧本的包含的功能理解，我们可以进一步学习**角色**的更高级主题。角色将Ansible代码创建的不同方面结合在一起，提供了一套完全独立的变量、任务、文件、模板和模块的集合，可以在不同的剧本中重复使用。尽管设计上并不受限制，但通常每个角色通常被限制在特定的目的或期望的最终结果上，所有必要的步骤要么在角色本身内，要么通过依赖项（换句话说，进一步的角色本身被指定为角色的依赖项）中。重要的是要注意，角色不是剧本，也没有直接执行角色的方法。角色没有设置适用于哪些主机的设置。顶层剧本是将清单中的主机与应该应用于这些主机的角色绑定在一起的粘合剂。正如我们在[*第2章*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047)中所看到的，*从早期Ansible版本迁移*，角色也可以是Ansible集合的一部分。由于我们已经在早期章节中看过集合的结构，因此在本节中，我们将更深入地关注如何构建角色本身。
- en: Role structure
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色结构
- en: '**Roles** have a structured layout on the **filesystem**. This structure exists
    to provide automation around including tasks, handlers, variables, modules, and
    role dependencies. The structure also allows for the easy reference of files and
    templates from anywhere within the role.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**角色**在**文件系统**上有一个结构化的布局。这个结构存在是为了自动包含任务、处理程序、变量、模块和角色依赖关系。该结构还允许轻松地从角色内的任何位置引用文件和模板。'
- en: In [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047), *Migrating
    from Earlier Ansible Versions*, we look at how to reference roles from collections.
    They do not have to be used as part of a collection, however, and assuming you
    are working with roles outside of this context, they all live in a subdirectory
    of a playbook directory structure below the `roles/` directory. This is, of course,
    configurable by way of the `roles_path` general configuration key, but let's stick
    to the defaults. Each role is itself a directory tree. The role name is the directory
    name within `roles/`. Each role can have a number of subdirectories with special
    meanings that are processed when a role is applied to a set of hosts.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047)中，*从早期Ansible版本迁移*，我们将看看如何从集合中引用角色。但是，它们不一定要作为集合的一部分使用，假设您在这种情况之外使用角色，它们都位于`roles/`目录下的剧本目录结构的子目录中。当然，这可以通过`roles_path`通用配置键进行配置，但让我们坚持使用默认值。每个角色本身都是一个目录树。角色名称是`roles/`目录中的目录名称。每个角色可以有许多具有特殊含义的子目录，在将角色应用于一组主机时会进行处理。
- en: A role may contain all these elements or as few as just one of them. Missing
    elements are simply ignored. Some roles exist just to provide common handlers
    across a project. Other roles exist as a single dependency point that in turn
    just depends on numerous other roles.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一个角色可以包含所有这些元素，也可以只包含其中的一个。缺少的元素将被简单地忽略。有些角色只是为项目提供通用处理程序。其他角色存在作为单个依赖点，反过来又依赖于许多其他角色。
- en: Tasks
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务
- en: The task file is the core part of a role, and if `roles/<role_name>/tasks/main.yaml` exists,
    then all the tasks within this file (and indeed any other files it includes) will
    be loaded in the play and executed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 任务文件是角色的核心部分，如果`roles/<role_name>/tasks/main.yaml`存在，那么该文件中的所有任务（以及它包含的任何其他文件）将被加载到播放中并执行。
- en: Handlers
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理程序
- en: Similar to tasks, handlers are automatically loaded from `roles/<role_name>/handlers/main.yaml`,
    if the file exists. These handlers can be referenced by any task within the role,
    or by any tasks within any other role that lists this role as a dependency.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与任务类似，如果存在`roles/<role_name>/handlers/main.yaml`文件，则处理程序将自动从中加载。这些处理程序可以被角色内的任何任务引用，或者被列出该角色为依赖项的任何其他角色内的任务引用。
- en: Variables
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: There are two types of variables that can be defined in a role. There are role
    variables, loaded from `roles/<role_name>/vars/main.yaml`, and there are role
    defaults, loaded from `roles/<role_name>/defaults/main.yaml`. The difference between
    `vars` and `defaults` has to do with precedence order. Refer to [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The System
    Architecture and Design of Ansible,* for a detailed description of the order.
    **Role defaults** are the lowest-order variables. Literally any other definition
    of a variable will take precedence over a role default. Role defaults can be thought
    of as placeholders for actual data, a reference of which variables a developer
    may be interested in defining with site-specific values. **Role variables**, on
    the other hand, have a higher order of precedence. Role variables can be overridden,
    but they are generally used when the same dataset is referenced more than once
    within a role. If the dataset is to be redefined with site-local values, then
    the variable should be listed in the role defaults rather than the role variables.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 角色中可以定义两种类型的变量。有角色变量，从`roles/<role_name>/vars/main.yaml`加载，还有角色默认值，从`roles/<role_name>/defaults/main.yaml`加载。`vars`和`defaults`之间的区别在于优先顺序。有关顺序的详细描述，请参阅[*第1章*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015)，*Ansible
    的系统架构和设计*。**角色默认值**是最低优先级的变量。实际上，任何其他变量的定义都将优先于角色默认值。角色默认值可以被视为实际数据的占位符，开发人员可能有兴趣使用站点特定值来定义哪些变量。另一方面，**角色变量**具有更高的优先级。角色变量可以被覆盖，但通常在角色内多次引用相同数据集时使用。如果要使用站点本地值重新定义数据集，则应该将变量列在角色默认值而不是角色变量中。
- en: Modules and plugins
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块和插件
- en: A role can include custom modules as well as plugins. While we are in the transitionary
    phase to Ansible 4.0 and beyond, this is still supported, but you will no doubt
    have noticed that collections can also include custom **modules** and **plugins**.
    At the current time, where you place your modules and plugins will depend upon
    the target version of Ansible you are writing your role for. If you wish to maintain
    backward compatibility with the 2.x releases, then you should place modules and
    plugins into your role directory structure, as described here. If you only want
    compatibility with Ansible releases 3.0 and later, you could consider placing
    them in a collection instead. Note, however, that with the move to collections,
    your plugins and modules are less likely to be accepted into the `ansible-core`
    package, unless they provide what is considered core functionality.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个角色可以包括自定义模块和插件。虽然我们正在过渡到 Ansible 4.0 及更高版本的阶段，但这仍然受支持，但您无疑已经注意到集合也可以包括自定义**模块**和**插件**。在当前时期，您放置模块和插件的位置将取决于您为其编写角色的目标
    Ansible 版本。如果您希望与 2.x 版本保持向后兼容性，那么您应该将模块和插件放入角色目录结构中，如此处所述。如果您只希望与 Ansible 3.0
    及更高版本兼容，您可以考虑将它们放入集合中。然而，请注意，随着转向集合，您的插件和模块不太可能被接受到`ansible-core`包中，除非它们提供被认为是核心功能。
- en: Modules (if present in a role) are loaded from `roles/<role_name>/library/` and
    can be utilized by any task in the role, or indeed by any later role in the play.
    It is important to note that modules provided in this path will override any other
    copies of the same module name, and once again it is important to reference modules
    using FQCNs wherever possible to avoid any unexpected results.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: （如果在角色中存在）模块从`roles/<role_name>/library/`加载，并且可以被角色中的任何任务或者后续的角色使用。重要的是要注意，此路径中提供的模块将覆盖同名模块的任何其他副本，因此尽可能使用
    FQCNs 引用模块以避免任何意外结果。
- en: 'Plugins will automatically be loaded if found inside of a role, in one of the
    following subdirectories:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在角色的一个以下子目录中找到插件，插件将自动加载：
- en: '`action_plugins`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action_plugins`'
- en: '`lookup_plugins`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lookup_plugins`'
- en: '`callback_plugins`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback_plugins`'
- en: '`connection_plugins`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connection_plugins`'
- en: '`filter_plugins`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter_plugins`'
- en: '`strategy_plugins`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strategy_plugins`'
- en: '`cache_plugins`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache_plugins`'
- en: '`test_plugins`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_plugins`'
- en: '`shell_plugins`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shell_plugins`'
- en: Dependencies
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖
- en: Roles can express a **dependency** upon another role. It is a common practice
    for sets of roles to all depend on a common role for tasks, handlers, modules,
    and so on. Those roles may depend upon only having to be defined once. When Ansible
    processes a role for a set of hosts, it first looks for dependencies listed in `roles/<role_name>/meta/main.yaml`.
    Should any be defined, then those roles will be processed immediately and the
    tasks contained in those roles will be executed (after checking for any dependencies
    also listed within them). This process carries on until all dependencies have
    been established and loaded (and tasks executed where present) before Ansible
    results to starting on the initial role tasks. Remember—dependencies are always
    executed before the role itself. We will describe role dependencies in more depth
    later in this chapter.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 角色可以表达对另一个角色的**依赖**。一组角色通常都依赖于一个常见的角色，用于任务、处理程序、模块等。这些角色可能只依赖于一次定义。当 Ansible
    处理一组主机的角色时，它首先查找`roles/<role_name>/meta/main.yaml`中列出的依赖关系。如果有任何定义，那么这些角色将立即被处理，并且这些角色中包含的任务将被执行（在检查其中列出的任何依赖关系之后）。这个过程会一直持续，直到所有依赖关系都被建立和加载（并在存在的情况下执行任务），然后
    Ansible 开始执行初始角色任务。请记住——依赖关系总是在角色本身之前执行。我们将在本章后面更深入地描述角色依赖关系。
- en: Files and templates
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件和模板
- en: Task and handler modules can reference files using only relative paths within
    `roles/<role_name>/files/`. The filename can be provided without any prefix (although
    this is allowed if you wish) and will be sourced from `roles/<role_name>/files/<relative_directory>/<file_name>`.
    Modules such as `ansible.builtin.template`, `ansible.builtin.copy`, and `ansible.builtin.script`
    are three typical ones that you will see many examples of, taking advantage of
    this useful feature.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 任务和处理程序模块只能在`roles/<role_name>/files/`中使用相对路径引用文件。文件名可以提供没有任何前缀（尽管如果您愿意，这是允许的），并且将从`roles/<role_name>/files/<relative_directory>/<file_name>`获取。诸如`ansible.builtin.template`、`ansible.builtin.copy`和`ansible.builtin.script`之类的模块是您将看到许多利用这一有用功能的示例的典型模块。
- en: 'Similarly, templates used by the `ansible.builtin.template` module can be referenced
    relatively within `roles/<role_name>/templates/`. The following code sample uses
    a relative path to load the `derp.j2` template from the full `roles/<role_name>/templates/herp/derp.j2` path:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`ansible.builtin.template`模块使用的模板可以在`roles/<role_name>/templates/`中相对引用。以下代码示例使用相对路径从完整路径`roles/<role_name>/templates/herp/derp.j2`加载`derp.j2`模板：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this way, it is easy to organize files within the standard role directory
    structure and still access them easily from within the role without having to
    type in long and complex paths. Later in this chapter, we'll introduce you to
    the `ansible-galaxy role init` command, which will help you build skeleton directory
    structures for new roles with even greater ease—see the *Role sharing* section
    for more details.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，可以轻松地在标准角色目录结构中组织文件，并且仍然可以轻松地从角色内部访问它们，而无需输入长而复杂的路径。在本章后面，我们将向您介绍`ansible-galaxy
    role init`命令，该命令将帮助您更轻松地为新角色构建骨架目录结构-有关更多详细信息，请参见*角色共享*部分。
- en: Putting it all together
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有内容放在一起
- en: 'To illustrate what a full role structure might look like, here is an example
    role by the name of `demo`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明完整的角色结构可能是什么样子，这里有一个名为`demo`的示例角色：
- en: '[PRE34]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When creating a role, not every directory or file is required. Only files that
    exist will be processed. Thus, our example of a role does not require or use handlers;
    the entire `handlers` part of the tree could simply be left out.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 创建角色时，并不是每个目录或文件都是必需的。只有存在的文件才会被处理。因此，我们的角色示例不需要或使用处理程序；整个树的`handlers`部分可以简单地被省略。
- en: Role dependencies
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色依赖
- en: 'As stated before, roles can depend on other roles. These relationships are
    called dependencies and they are described in a role''s `meta/main.yaml` file.
    This file expects a top-level data hash with a key of `dependencies`; the data
    within is a list of roles. You can see an illustration of this in the following
    code snippet:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '如前所述，角色可以依赖于其他角色。这些关系称为依赖关系，并且它们在角色的`meta/main.yaml`文件中描述。该文件期望具有`dependencies`键的顶级数据哈希；其中的数据是角色列表。您可以在以下代码片段中看到这一点的说明： '
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, Ansible will fully process the `common` role first (and any
    dependencies it may express) before continuing with the `apache` role and then
    finally starting on the role's tasks.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Ansible将在继续`apache`角色并最终开始角色任务之前，首先完全处理`common`角色（及其可能表达的任何依赖关系）。
- en: 'Dependencies can be referenced by name without any prefix if they exist within
    the same directory structure or live within the configured `roles_path` configuration
    key. Otherwise, full paths can be used to locate roles, as illustrated here:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果依赖项存在于相同的目录结构中或位于配置的`roles_path`配置键中，则可以通过名称引用依赖项而无需任何前缀。否则，可以使用完整路径来定位角色，如下所示：
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When expressing a dependency, it is possible to pass along data to the dependency.
    The data can be variables, tags, or even conditionals.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达依赖关系时，可以将数据传递给依赖项。数据可以是变量、标签，甚至是条件。
- en: Role dependency variables
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 角色依赖变量
- en: 'Variables that are passed along when listing a dependency will override values
    for matching variables defined in `defaults/main.yaml` or `vars/main.yaml`. This
    can be useful for using a common role, such as an `apache` role, as a dependency
    while providing site-specific data, such as which ports to open in the firewall
    or which `apache` modules to enable. Variables are expressed as additional keys
    to the role listing. Thus, continuing our hypothetical example, consider that
    we need to pass some variables to both the `common` and `apache` role dependencies
    we discussed, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在列出依赖项时传递的变量将覆盖`defaults/main.yaml`或`vars/main.yaml`中定义的匹配变量的值。这对于使用常见角色（例如`apache`角色）作为依赖项并提供特定于站点的数据（例如在防火墙中打开哪些端口或启用哪些`apache`模块）非常有用。变量表示为角色列表的附加键。因此，继续我们的假设示例，考虑到我们需要将一些变量传递给我们讨论的`common`和`apache`角色依赖项，如下所示：
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When providing dependency variable data, two names are reserved and should not
    be used as role variables: `tags` and `when`. The former is used to pass tag data
    into a role, and the latter is used to pass a conditional into a role.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供依赖变量数据时，有两个名称被保留，不应该用作角色变量：`tags`和`when`。前者用于将标签数据传递到角色中，后者用于将条件传递到角色中。
- en: Tags
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签
- en: 'Tags can be applied to all the tasks found within a dependency role. This functions
    much in the same way as tags being applied to included task files, as described
    earlier in this chapter. The syntax is simple: the `tags` key can be a single
    item or a list. To demonstrate, let''s further expand our theoretical example
    by adding some tags, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 标签可以应用于依赖角色中找到的所有任务。这与标签应用于包含的任务文件的方式相同，如本章前面所述。语法很简单：`tags`键可以是单个项目或列表。为了演示，让我们通过添加一些标签来进一步扩展我们的理论示例，如下所示：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As with adding tags to the included task files, all the tasks found within a
    dependency (and any dependency within that hierarchy) will gain the provided tags.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 与向包含的任务文件添加标签一样，所有在依赖中找到的任务（以及该层次结构中的任何依赖）都将获得提供的标签。
- en: Role dependency conditionals
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 角色依赖条件
- en: 'While it is not possible to prevent the processing of a dependency role with
    a conditional, it is possible to skip all the tasks within a dependency role hierarchy
    by applying a conditional to a dependency. This mirrors the functionality of task
    inclusion with conditionals as well. The `when` key is used to express the conditional.
    Once again, we''ll grow our example by adding a dependency to demonstrate the
    syntax, as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不可能通过条件来阻止依赖角色的处理，但可以通过将条件应用到依赖项来跳过依赖角色层次结构中的所有任务。这也反映了使用条件的任务包含的功能。`when`关键字用于表达条件。我们将再次通过添加一个依赖项来扩展我们的示例，以演示语法，如下所示：
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, the `apache` role will always be processed, but tasks within
    the role will only run when the `backend_server` variable contains the `apache` string.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`apache`角色将始终被处理，但角色内的任务只有在`backend_server`变量包含`apache`字符串时才会运行。
- en: Role application
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色应用
- en: Roles are not plays. They do not possess any opinions about which hosts the
    role tasks should run on, which connection methods to use, whether to operate
    serially, or any other play behaviors described in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The System
    Architecture and Design of Ansible*. Roles must be applied inside a play within
    a playbook, where all these opinions can be expressed.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 角色不是剧本。它们不会对角色任务应该在哪些主机上运行、使用哪种连接方法、是否按顺序操作或者在[*第1章*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015)中描述的任何其他剧本行为方面持有任何意见。角色必须在剧本中的一个剧本中应用，所有这些意见都可以在其中表达。
- en: To apply a role within a play, the `roles` operator is used. This operator expects
    a list of roles to apply to the hosts in the play. Much like describing role dependencies,
    when describing roles to apply, data can be passed along, such as variables, tags,
    and conditionals. The syntax is exactly the same.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放中应用角色时，使用`roles`操作符。该操作符期望应用到播放中的主机的角色列表。与描述角色依赖关系类似，当描述要应用的角色时，可以传递数据，例如变量、标签和条件。语法完全相同。
- en: 'To demonstrate applying roles within a play, let''s create a simple role and
    apply it to a simple playbook. First, let''s build a role named `simple`, which
    will have a single `debug` task in `roles/simple/tasks/main.yaml` that prints
    the value of a role default variable defined in `roles/simple/defaults/main.yaml`.
    First, let''s create a task file (in the `tasks/` subdirectory), as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示在播放中应用角色，让我们创建一个简单的角色并将其应用到一个简单的剧本中。首先，让我们构建一个名为`simple`的角色，它将在`roles/simple/tasks/main.yaml`中具有一个单独的`debug`任务，打印在`roles/simple/defaults/main.yaml`中定义的角色默认变量的值。首先，让我们创建一个任务文件（在`tasks/`子目录中），如下所示：
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we''ll write our default file with a single variable, `derp`, like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写我们的默认文件，其中包含一个变量`derp`，如下所示：
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To execute this role, we''ll write a playbook with a single play to apply the
    role. We''ll call our playbook `roleplay.yaml`, and it''ll live at the same directory
    level as the `roles/` directory. The code is illustrated in the following snippet:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此角色，我们将编写一个播放以应用该角色。我们将称我们的剧本为`roleplay.yaml`，它将与`roles/`目录处于相同的目录级别。代码如下所示：
- en: '[PRE42]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Important Note
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If no data is provided with the role, an alternative syntax that just lists
    the roles to apply can be used, instead of the hash. However, for consistency,
    I feel it's best to always use the same syntax within a project.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有为角色提供数据，可以使用另一种语法，只列出要应用的角色，而不是哈希。但为了保持一致，我觉得最好在项目中始终使用相同的语法。
- en: 'We''ll reuse our `mastery-hosts` inventory from earlier chapters and execute
    the playbook in the normal manner (we don''t need any added verbosity here), by
    running the following command:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用之前章节中的`mastery-hosts`清单，并以正常方式执行这本手册（这里我们不需要任何额外的冗长），通过运行以下命令：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output should look something like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '![Figure 8.19 – Running our simple role from a playbook using the default role
    variable data'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19 - 从剧本中运行我们的简单角色，使用默认角色变量数据'
- en: '](Images/B17462_08_19.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_19.jpg)'
- en: Figure 8.19 – Running our simple role from a playbook using the default role
    variable data
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 - 从剧本中运行我们的简单角色，使用默认角色变量数据
- en: 'Thanks to the magic of roles, the `derp` variable value was automatically loaded
    from the role defaults. Of course, we can override the default value when applying
    the role. Let''s modify our playbook and supply a new value for `derp`, as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 由于角色的魔力，`derp`变量值会自动从角色默认值中加载。当应用角色时，当然可以覆盖默认值。让我们修改我们的剧本，并为`derp`提供一个新值，如下所示：
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This time, when we execute (using the same command as used previously), we''ll
    see `newval` as the value for `derp`, as shown in the following screenshot:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我们执行（使用与之前相同的命令），我们将看到`newval`作为`derp`的值，如下截图所示：
- en: '![Figure 8.20 – Running the same role but this time overriding the default
    variable data at the play level'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.20 - 从剧本中运行相同的角色，但这次在播放级别覆盖默认变量数据'
- en: '](Images/B17462_08_20.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_20.jpg)'
- en: Figure 8.20 – Running the same role but this time overriding the default variable
    data at the play level
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20 - 运行相同的角色，但这次在播放级别覆盖默认变量数据
- en: 'Multiple roles can be applied within a single play. The `roles:` key expects
    a list value. Just add more roles to apply more roles, as shown here (this next
    example is theoretical and is left as an exercise for you):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在一个播放中应用多个角色。`roles:`关键字期望一个列表值。只需添加更多角色以应用更多角色，如下所示（下一个示例是理论的，留给你作为练习）：
- en: '[PRE45]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This playbook will load a total of four roles—`simple`, `second_role`, `third_role`,
    and `another_role`—and each will be executed in the sequence in which they are
    listed.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这本手册将加载四个角色——`simple`、`second_role`、`third_role`和`another_role`——并且每个角色将按照它们列出的顺序执行。
- en: Mixing roles and tasks
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合角色和任务
- en: Plays that use roles are not limited to just roles. These plays can have tasks of
    their own, as well as two other blocks of tasks: `pre_tasks` and `post_tasks`
    blocks. In a break to the task execution order we have looked at throughout this
    book, the order in which these tasks are executed is not dependent upon which
    order these sections are listed in the play itself; instead, there is a strict
    order to block execution within a play. See [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The System
    Architecture and Design of Ansible,* for details on the playbook order of operations.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用角色的play不仅限于角色。这些play可以有自己的任务，以及两个其他任务块：`pre_tasks`和`post_tasks`块。与本书中一直关注的任务执行顺序不同，这些任务的执行顺序不取决于这些部分在play中列出的顺序，而是在play内部块执行中有严格的顺序。有关playbook操作顺序的详细信息，请参见[*第1章*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015)，*Ansible的系统架构和设计*。
- en: '**Handlers** for a play are flushed at multiple points. If there is a `pre_tasks` block,
    handlers are flushed after all `pre_tasks` blocks are executed. Then, the roles and tasks blocks
    are executed (roles first, then tasks, regardless of the order they are written
    in the playbook), after which the handlers will be flushed again. Finally, if
    a `post_tasks` block exists, the handlers will be flushed once again after all
    `post_tasks` blocks have executed. Of course, handlers can be flushed at any time
    with the `meta: flush_handlers` call. Let''s expand on our `roleplay.yaml` file
    to demonstrate all the different times at which handlers can be triggered, as
    follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'play的处理程序在多个点被刷新。如果有`pre_tasks`块，则在执行所有`pre_tasks`块后刷新处理程序。然后执行角色和任务块（首先是角色，然后是任务，不管它们在playbook中的书写顺序如何），之后处理程序将再次被刷新。最后，如果存在`post_tasks`块，则在执行所有`post_tasks`块后再次刷新处理程序。当然，可以随时使用`meta:
    flush_handlers`调用刷新处理程序。让我们扩展我们的`roleplay.yaml`文件，以演示处理程序可以被触发的所有不同时间，如下所示：'
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We''ll also modify our simple role''s tasks to notify the `say hi` handler
    as well, as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将修改我们简单角色的任务，以通知`say hi`处理程序，如下所示：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Important Note
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: This only works because the `say hi` handler has been defined in the play that
    is calling the `simple` role. If the handler is not defined, an error will occur.
    It's best practice to only notify handlers that exist within the same role or
    any role marked as a dependency.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅在调用`simple`角色的play中定义了`say hi`处理程序才有效。如果处理程序未定义，将会出现错误。最佳实践是只通知存在于相同角色或任何标记为依赖项的角色中的处理程序。
- en: 'Running our playbook again using the same command as in the previous examples
    should result in the `say hi` handler being called a total of three times: once
    for `pre_tasks` blocks, once for roles and tasks, and once for `post_tasks` blocks,
    as the following screenshot demonstrates:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行我们的playbook，使用与之前示例中相同的命令，应该会导致`say hi`处理程序被调用三次：一次用于`pre_tasks`块，一次用于角色和任务，一次用于`post_tasks`块，如下面的屏幕截图所示：
- en: '![Figure 8.21 – Running a playbook to demonstrate mixing roles and tasks, and
    handler execution'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21 - 运行playbook以演示混合角色和任务以及处理程序执行'
- en: '](Images/B17462_08_21.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_21.jpg)'
- en: Figure 8.21 – Running a playbook to demonstrate mixing roles and tasks, and
    handler execution
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 - 运行playbook以演示混合角色和任务以及处理程序执行
- en: While the order in which `pre_tasks`, `roles`, `tasks`, and `post_tasks` blocks
    are written into a play does not impact the order in which those sections are
    executed, it's best practice to write them in the order in which they will be
    executed. This is a visual cue to help remember the order and to avoid confusion
    when reading the playbook later.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`pre_tasks`、`roles`、`tasks`和`post_tasks`块的书写顺序不会影响这些部分执行的顺序，但最佳实践是按照它们将被执行的顺序进行书写。这是一个视觉提示，有助于记住顺序，并在以后阅读playbook时避免混淆。'
- en: Role includes and imports
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 角色包含和导入
- en: With Ansible version 2.2, a new `ansible.builtin.include_role` action plugin
    was made available as a technical preview. Then, in **Ansible version 2.4**, this
    concept was further developed by the addition of the `ansible.builtin.import_role` plugin.
    We will refer to these plugins without their FQCNs for conciseness.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible 2.2版本中，新的`ansible.builtin.include_role`动作插件作为技术预览可用。然后，在**Ansible 2.4**版本中，通过添加`ansible.builtin.import_role`插件进一步开发了这个概念。为了简洁起见，我们将不使用它们的FQCNs来引用这些插件。
- en: These plugins are used in a task to include and execute an entire role directly
    from a task. The difference between the two is subtle but important—the `include_role` plugin
    is considered dynamic, meaning the code is processed during runtime when the task
    referencing it is encountered.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这些插件用于在任务中包含和执行整个角色。两者之间的区别微妙但重要——`include_role`插件被认为是动态的，这意味着在遇到引用它的任务时，代码会在运行时进行处理。
- en: The `import_role` plugin, on the other hand, is considered static, meaning all
    imports are preprocessed at the time the playbook is initially parsed. This has
    various impacts on their use in playbooks—for example, `import_role` cannot be
    used in loops, while `include_role` can.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`import_role`插件被认为是静态的，这意味着所有导入都在解析playbook时进行预处理。这对于在playbooks中的使用有各种影响，例如，`import_role`不能在循环中使用，而`include_role`可以。
- en: Important Note
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Full details of the trade-offs between importing and including can be found
    in the official Ansible documentation here: [https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有关导入和包含之间权衡的详细信息可以在官方Ansible文档中找到：[https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.html)。
- en: In the previous edition of this book, these plugins were considered a technical
    preview—however, they are now part of the `ansible.builtin` collection and so
    can now be considered stable and used for your code as you see fit.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的上一版中，这些插件被视为技术预览，但现在它们已经成为`ansible.builtin`集合的一部分，因此现在可以认为它们是稳定的，并且可以根据需要用于您的代码。
- en: Role sharing
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色共享
- en: One of the advantages of using roles is the ability to share a role across plays,
    playbooks, entire project spaces, and even across organizations. Roles are designed
    to be self-contained (or to clearly reference dependent roles) so that they can
    exist outside of a project space where the playbook that applies the role lives.
    Roles can be installed in shared paths on an Ansible host, or they can be distributed
    via source control.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用角色的一个优势是能够在不同的play、playbook、整个项目空间甚至不同的组织之间共享角色。角色被设计为自包含的（或者清楚地引用依赖角色），以便它们可以存在于应用角色的playbook所在的项目空间之外。角色可以安装在Ansible主机上的共享路径上，也可以通过源代码控制进行分发。
- en: Ansible Galaxy
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ansible Galaxy
- en: '**Ansible Galaxy** ([https://galaxy.ansible.com/](https://galaxy.ansible.com/)),
    as we discussed in [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047),
    *Migrating from Earlier Ansible Versions*, is a community hub for finding and
    sharing Ansible roles and collections. Anybody can visit the website to browse
    these and reviews; plus, users who create a login can provide reviews of the roles
    they''ve tested. Roles from Galaxy can be downloaded using the `ansible-galaxy` utility
    provided with Ansible.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ansible Galaxy**（[https://galaxy.ansible.com/](https://galaxy.ansible.com/)），正如我们在[*第2章*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047)中讨论的那样，*从早期的Ansible版本迁移*，是一个用于查找和共享Ansible角色和集合的社区中心。任何人都可以访问该网站浏览这些角色和评论；此外，创建登录的用户可以对他们测试过的角色进行评论。可以使用`ansible-galaxy`工具提供的实用程序下载Galaxy中的角色。'
- en: 'The `ansible-galaxy` utility can connect to and install roles from the Ansible
    Galaxy website. This utility will default to installing roles into `/etc/ansible/roles`.
    If `roles_path` is configured or if a runtime path is provided with the `--roles-path`
    (or `-p`) option, the roles will be installed there instead. If any roles have
    been installed to the `roles_path` option or the provided path, `ansible-galaxy`
    can list those and show information about those as well. To demonstrate the usage
    of `ansible-galaxy`, let''s use it to install a role for installing and managing
    Docker on Ubuntu from Ansible Galaxy into the `roles` directory we''ve been working
    with. Installing roles from Ansible Galaxy requires `username.rolename`, as multiple
    users may have uploaded roles with the same name. To work through an example,
    we will use the `docker_ubuntu` role from the `angstwad` user, as shown in the
    following screenshot:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible-galaxy`实用程序可以连接到Ansible Galaxy网站并安装角色。该实用程序默认将角色安装到`/etc/ansible/roles`中。如果配置了`roles_path`，或者使用`--roles-path`（或`-p`）选项提供了运行时路径，角色将安装到那里。如果已经将角色安装到`roles_path`选项或提供的路径中，`ansible-galaxy`也可以列出这些角色并显示有关这些角色的信息。为了演示`ansible-galaxy`的用法，让我们使用它将一个用于在Ubuntu上安装和管理Docker的角色从Ansible
    Galaxy安装到我们一直在使用的`roles`目录中。从Ansible Galaxy安装角色需要`username.rolename`，因为多个用户可能上传了具有相同名称的角色。为了演示，我们将使用`angstwad`用户的`docker_ubuntu`角色，如下面的截图所示：'
- en: '![Figure 8.22 – Locating an example community-contributed role on Ansible Galaxy'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22 - 在Ansible Galaxy上找到一个示例社区贡献的角色'
- en: '](Images/B17462_08_22.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_22.jpg)'
- en: Figure 8.22 – Locating an example community-contributed role on Ansible Galaxy
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 - 在Ansible Galaxy上找到一个示例社区贡献的角色
- en: 'We can now make use of this role by referencing `angstwad.docker_ubuntu` in
    a play or another role''s dependencies block. However, let''s get started by demonstrating
    how we can install this in our current working directory. We''ll first off create
    a `roles/` directory, and then install the aforementioned role into this directory
    with the following commands:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过在play或其他角色的依赖块中引用`angstwad.docker_ubuntu`来使用这个角色。然而，让我们首先演示如何在当前工作目录中安装这个角色。我们首先创建一个`roles/`目录，然后使用以下命令将上述角色安装到这个目录中：
- en: '[PRE48]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once we''ve installed our example role, we can query it (and any other roles
    that might exist in the `roles/` directory) using the following command:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了示例角色，我们可以使用以下命令查询它（以及可能存在于`roles/`目录中的任何其他角色）：
- en: '[PRE49]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can also query information about the role such as the description, creator,
    version, and so on locally using the following command:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用以下命令在本地查询有关角色的描述、创建者、版本等信息：
- en: '[PRE50]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following screenshot gives an idea of the kind of output you can expect
    from the two preceding commands:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图给出了你可以从前面两个命令中期望的输出类型：
- en: '![Figure 8.23 – Querying installed roles with the ansible-galaxy command'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.23 - 使用ansible-galaxy命令查询已安装的角色'
- en: '](Images/B17462_08_23.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_23.jpg)'
- en: Figure 8.23 – Querying installed roles with the ansible-galaxy command
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 - 使用ansible-galaxy命令查询已安装的角色
- en: 'The output has been truncated to save space in the book, and there is much
    more useful information if you scroll through the output. Some of the data being
    displayed by the `info` command lives within the role itself, in the `meta/main.yml` file.
    Previously, we''ve only seen dependency information in this file, and it may not
    have made much sense to name the directory `meta`, but now we see that other metadata
    lives in this file as well, as the following screenshot shows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 输出已经被截断以节省书中的空间，如果你浏览输出，会发现更多有用的信息。`info`命令显示的一些数据存在于角色本身，在`meta/main.yml`文件中。以前，我们只在这个文件中看到了依赖信息，也许给目录命名为`meta`并没有太多意义，但现在我们看到这个文件中还有其他元数据，如下面的截图所示：
- en: '![Figure 8.24 – An example of the metadata that can be placed in the meta/main.yml
    file of a role'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.24 - 可以放置在角色的meta/main.yml文件中的元数据的示例'
- en: '](Images/B17462_08_24.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_24.jpg)'
- en: Figure 8.24 – An example of the metadata that can be placed in the meta/main.yml
    file of a role
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24 - 可以放置在角色的meta/main.yml文件中的元数据的示例
- en: The `ansible-galaxy` tool can also help with the creation of new roles. The `role
    init` method will create a skeleton directory tree for the role, as well as populating the `meta/main.yml` file
    with placeholders for Galaxy-related data.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible-galaxy`工具还可以帮助创建新的角色。`role init`方法将为角色创建一个骨架目录树，并在`meta/main.yml`文件中填充与Galaxy相关数据的占位符。'
- en: 'Let''s demonstrate this capability by creating a new role in our working directory
    named `autogen`, using this command:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用这个命令在我们的工作目录中创建一个名为`autogen`的新角色来演示这种能力：
- en: '[PRE51]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you examine the directory structure this command creates, you will see all
    the directories and placeholder files needed to create a brand-new role, as the
    following screenshot illustrates:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查这个命令创建的目录结构，你会看到创建全新角色所需的所有目录和占位符文件，如下面的截图所示：
- en: '![Figure 8.25 – Creating a skeletal empty role using the ansible-galaxy tool'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.25 - 使用ansible-galaxy工具创建一个空的骨架角色'
- en: '](Images/B17462_08_25.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_08_25.jpg)'
- en: Figure 8.25 – Creating a skeletal empty role using the ansible-galaxy tool
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25 - 使用ansible-galaxy工具创建一个空的骨架角色
- en: 'Note that where we have used the `-p` switch in the past for specifying the
    local `roles/` directory, we have to use the `--init-path` switch instead with
    the `init` command. For roles that are not suitable for Ansible Galaxy, such as
    roles dealing with in-house systems, `ansible-galaxy` can install directly from
    a Git **Uniform Resource Locator** (**URL**). Instead of just providing a role
    name to the `install` method, a full Git URL with an optional version can be provided.
    For example, if we wanted to install the `foowhiz` role from our internal Git
    server, we could simply run the following command:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在过去用于指定本地`roles/`目录的`-p`开关，现在必须改用`init`命令的`--init-path`开关。对于不适合Ansible Galaxy的角色，例如处理内部系统的角色，`ansible-galaxy`可以直接从Git
    **Uniform Resource Locator** (**URL**)安装。不仅可以提供一个角色名称给`install`方法，还可以提供一个带有可选版本的完整Git
    URL。例如，如果我们想要从内部Git服务器安装`foowhiz`角色，我们可以简单地运行以下命令：
- en: '[PRE52]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Without version information, the `master` branch will be used. Without name
    data, the name will be determined from the URL itself. To provide a version, append
    a comma and the version string that Git can understand, such as a tag or branch
    name—for example, `v1`, as illustrated here:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 没有版本信息时，将使用`master`分支。没有名称数据时，名称将根据URL本身确定。要提供版本，请附加一个逗号和Git可以理解的版本字符串，例如标签或分支名称，例如`v1`，如下所示：
- en: '[PRE53]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'A name for the role can be added with another comma followed by the `name`
    string, as illustrated in the following code snippet. If you need to supply a
    name but do not wish to supply a version, an empty slot is still required for
    the version:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在另一个逗号后面添加一个角色名称，如下面的代码片段所示。如果需要提供名称但不希望提供版本，则仍然需要为版本留出一个空位：
- en: '[PRE54]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Roles can also be installed directly from tarballs as well, by providing a URL
    to the tarball in lieu of a full Git URL or a role name to fetch from Ansible
    Galaxy.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 角色也可以直接从tarballs安装，只需提供tarball的URL，而不是完整的Git URL或要从Ansible Galaxy获取的角色名称。
- en: 'When you need to install many roles for a project, it''s possible to define
    multiple roles to download and install in a YAML-formatted file that ends with `.yaml` (or `.yml`).
    The format of this file allows you to specify multiple roles from multiple sources
    and retain the ability to specify versions and role names. In addition, the source
    control method can be listed (currently, only `git` and `hg` are supported). You
    can see an example of this in the following code snippet:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要为一个项目安装许多角色时，可以在以`.yaml`（或`.yml`）结尾的YAML格式文件中定义要下载和安装的多个角色。该文件的格式允许你从多个来源指定多个角色，并保留指定版本和角色名称的能力。此外，还可以列出源代码控制方法（目前仅支持`git`和`hg`）。你可以在以下代码片段中看到一个例子：
- en: '[PRE55]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To install all the roles within a file, use the `--roles-file` (`-r`) option
    with the `role install` method, as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装文件中的所有角色，请使用`role install`方法的`--roles-file`（`-r`）选项，如下所示：
- en: '[PRE56]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this manner, it is very easy to gather all your role dependencies prior to
    running your playbooks, and whether the roles you need are publicly available
    on Ansible Galaxy or held in your own internal source control management system,
    this simple step can greatly speed along playbook deployment while supporting
    code reuse.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，非常容易在运行playbooks之前收集所有角色的依赖关系，无论你需要的角色是在Ansible Galaxy上公开可用，还是保存在你自己的内部源代码管理系统中，这一简单步骤都可以大大加快playbook的部署速度，同时支持代码重用。
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Ansible provides the capability to divide content logically into separate files.
    This capability helps project developers not repeat the same code over and over
    again. Roles within Ansible take this capability a step further and wrap some
    magic around the paths to the content. Roles are tunable, reusable, portable,
    and shareable blocks of functionality. Ansible Galaxy exists as a community hub
    for developers to find, rate, and share roles as well as collections. The `ansible-galaxy` command-line
    tool provides a method to interact with the Ansible Galaxy site or other role-sharing
    mechanisms. These capabilities and tools help with the organization and utilization
    of common code.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible提供了将内容逻辑地分成单独文件的能力。这种能力帮助项目开发人员不再重复相同的代码。Ansible中的角色进一步利用了这种能力，并在内容的路径周围包装了一些魔法。角色是可调整的、可重用的、可移植的和可共享的功能块。Ansible
    Galaxy作为开发人员的社区中心存在，可以在其中找到、评价和共享角色和集合。`ansible-galaxy`命令行工具提供了一种与Ansible Galaxy站点或其他角色共享机制进行交互的方法。这些能力和工具有助于组织和利用常见代码。
- en: In this chapter, you learned all about inclusion concepts relating to tasks,
    handlers, variables, and even entire playbooks. Then, you expanded on this knowledge
    by learning about roles—their structure, setting default variable values, and
    handling role dependencies. You then proceeded to learn about designing playbooks
    to utilize roles effectively and applying options such as tags that roles otherwise
    lack. Finally, you learned about sharing roles across projects using repositories
    such as Git and Ansible Galaxy.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了与任务、处理程序、变量甚至整个playbooks相关的包含概念。然后，您通过学习角色的结构、设置默认变量值和处理角色依赖关系来扩展了这些知识。然后，您继续学习了设计playbooks以有效利用角色，并应用了角色缺乏的标签等选项。最后，您学习了如何使用Git和Ansible
    Galaxy等存储库在项目之间共享角色。
- en: In the next chapter, we'll cover useful and effective troubleshooting techniques
    to help you when your Ansible deployments run into trouble.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍有用且有效的故障排除技术，以帮助您在Ansible部署遇到问题时解决问题。
- en: Questions
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which Ansible module can be used to run tasks from a separate external task
    file when a playbook is run?
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行playbook时，可以使用哪个Ansible模块来运行来自单独外部任务文件的任务？
- en: a) `ansible.builtin.import`
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: a) `ansible.builtin.import`
- en: b) `ansible.builtin.include`
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: b) `ansible.builtin.include`
- en: c) `ansible.builtin.tasks_file`
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: c) `ansible.builtin.tasks_file`
- en: d) `ansible.builtin.with_tasks`
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: d) `ansible.builtin.with_tasks`
- en: 'Variable data can be passed to an external task file when it is called:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量数据可以在调用外部任务文件时传递：
- en: a) True
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: a) True
- en: b) False
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: b) False
- en: 'The default name of the variable containing the current loop value is:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含当前循环值的变量的默认名称是：
- en: a) `i`
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: a) `i`
- en: b) `loop_var`
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: b) `loop_var`
- en: c) `loop_value`
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: c) `loop_value`
- en: d) `item`
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: d) `item`
- en: When looping over external task files, it is important to consider setting which
    special variable to prevent loop variable name collisions?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环外部任务文件时，重要的是考虑设置哪个特殊变量以防止循环变量名称冲突？
- en: a) `loop_name`
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: a) `loop_name`
- en: b) `loop_item`
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: b) `loop_item`
- en: c) `loop_var`
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: c) `loop_var`
- en: d) `item`
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: d) `item`
- en: 'Handlers are generally run:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理程序通常运行：
- en: a) Once, at the end of the play
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: a) 一次，在剧终
- en: b) Once each, at the end of the `pre_tasks`, `roles/tasks`, and `post_tasks`
    sections of the play
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: b) 每次，在`pre_tasks`，`roles/tasks`和`post_tasks`部分的最后
- en: c) Once each, at the end of the `pre_tasks`, `roles/tasks`, and `post_tasks`
    sections of the play and only when notified
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: c) 每次，在`pre_tasks`，`roles/tasks`和`post_tasks`部分的最后，只有在通知时
- en: d) Once each, at the end of the `pre_tasks`, `roles/tasks`, and `post_tasks`
    sections of the play and only when imported
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: d) 每次，在`pre_tasks`，`roles/tasks`和`post_tasks`部分的最后，只有在导入时
- en: 'Ansible can load variables from the following external sources:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible可以从以下外部来源加载变量：
- en: a) Static `vars_files` inclusion
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: a) 静态`vars_files`包含
- en: b) Dynamic `vars_files` inclusion
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: b) 动态`vars_files`包含
- en: c) Through the `include_vars` statement
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: c) 通过`include_vars`语句
- en: d) Through the `extra-vars` command-line parameter
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: d) 通过`extra-vars`命令行参数
- en: e) All of the above
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: e) 以上所有
- en: 'Roles obtain their name from the role directory name (for example, `roles/testrole1`
    has the name `testrole1`):'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 角色从角色目录名称中获取其名称（例如，`roles/testrole1`的名称为`testrole1`）：
- en: a) True
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: a) True
- en: b) False
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: b) False
- en: 'If a role is missing the `tasks/main.yml` file, Ansible will:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个角色缺少`tasks/main.yml`文件，Ansible将会：
- en: a) Abort the play with an error
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: a) 用错误中止播放
- en: b) Skip the role entirely
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: b) 完全跳过角色
- en: c) Still reference any other valid parts of the role, including metadata, default
    variables, and handlers
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: c) 仍然引用角色的任何其他有效部分，包括元数据，默认变量和处理程序
- en: d) Display a warning
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: d) 显示警告
- en: 'Roles can have dependencies on other roles:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 角色可以依赖于其他角色：
- en: a) True
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: a) True
- en: b) False
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: b) False
- en: 'When you specify a tag for a role, Ansible''s behavior is to:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您为角色指定标签时，Ansible的行为是：
- en: a) Apply the tag to the entire role
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: a) 将标签应用于整个角色
- en: b) Apply the tag to each task within the role
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: b) 将标签应用于角色内的每个任务
- en: c) Skip the role entirely
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: c) 完全跳过角色
- en: d) Only execute tasks from a role with the same tag
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: d) 仅执行具有相同标签的角色的任务
