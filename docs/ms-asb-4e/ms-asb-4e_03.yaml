- en: '*Chapter 2*: Migrating from Earlier Ansible Versions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：从早期的Ansible版本迁移'
- en: As **Ansible** has grown over the years, certain headaches have presented themselves
    to the team that develops and manages the Ansible code base. In many ways, these
    headaches have been the price of Ansible's own growth and success, and have resulted
    in a need to structure the code a little differently. Indeed, anyone with a little
    prior experience of Ansible from versions before 2.10 will have noticed that our
    example code presented in this book looks a little different, along with a new
    term, **Collections**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着**Ansible**多年来的发展，某些问题已经出现在开发和管理Ansible代码库的团队面前。在许多方面，这些问题是Ansible自身增长和成功的代价，并且导致需要以稍微不同的方式构建代码。事实上，任何有一点之前版本Ansible经验的人都会注意到，我们在本书中提供的示例代码看起来有些不同，还有一个新术语**集合**。
- en: In this chapter, we will explain these changes in detail, along with how they
    came about. We will then take you through some practical examples so you can see
    how these changes work in the real world, before finally teaching you how to migrate
    any existing or legacy playbooks you might have to Ansible 4.3 and beyond.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细解释这些变化以及它们是如何产生的。然后，我们将通过一些实际示例带您了解这些变化在现实世界中是如何工作的，最后教会您如何将您可能拥有的任何现有或旧版playbook迁移到Ansible
    4.3及更高版本。
- en: 'Specifically, in this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，我们将涵盖以下主题：
- en: Changes in Ansible 4.3
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 4.3的变化
- en: Upgrading from earlier Ansible installations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从早期的Ansible安装升级
- en: Installing Ansible from scratch
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始安装Ansible
- en: What are Ansible Collections?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Ansible集合？
- en: Installing additional modules with `ansible-galaxy`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ansible-galaxy`安装额外的模块
- en: How to port legacy playbooks to Ansible 4.3 (a primer)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将旧版playbook迁移到Ansible 4.3（入门）
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the examples presented in this chapter, you will need a Linux machine
    running **Ansible 4.3** or newer. Almost any flavor of Linux should do. For those
    interested in specifics, all the code presented in this chapter was tested on
    **Ubuntu Server 20.04 LTS** unless stated otherwise, and on **Ansible 4.3**. The
    example code that accompanies this chapter can be downloaded from GitHub at this
    URL: [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter02).
    We will make use of a module that we develop in [*Chapter 10*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183),
    *Extending Ansible*, to show you how to build your own collection, so it is worthwhile
    making sure you have a copy of the accompanying code for this book.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照本章中提供的示例，您需要一台运行**Ansible 4.3**或更新版本的Linux机器。几乎任何Linux发行版都可以。对于那些感兴趣的人，本章中提供的所有代码都是在**Ubuntu
    Server 20.04 LTS**上测试的，除非另有说明，并且在**Ansible 4.3**上测试。本章附带的示例代码可以从GitHub的以下网址下载：[https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter02)。我们将使用我们在[*第10章*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183)中开发的模块，*扩展Ansible*，来向您展示如何构建自己的集合，因此确保您有本书附带代码的副本是值得的。
- en: 'Check out the following video to view the Code in Action: [https://bit.ly/3DYi0Co](https://bit.ly/3DYi0Co)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码实际操作：[https://bit.ly/3DYi0Co](https://bit.ly/3DYi0Co)
- en: Changes in Ansible 4.3
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 4.3的变化
- en: While we touched on this topic in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015),
    *The* *System Architecture and Design of Ansible*, it is important that we look
    in greater depth at these changes to help you fully understand how Ansible 4.3
    differs from prior releases. This will help you greatly in writing good playbooks
    and maintaining and upgrading your Ansible infrastructure – it is an essential
    step to mastery of Ansible 4.3!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在[*第1章*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015)中提到了这个话题，*Ansible的系统架构和设计*，但重要的是我们更深入地了解这些变化，以帮助您充分理解Ansible
    4.3与之前版本的不同之处。这将帮助您大大提高编写良好playbook的能力，并维护和升级您的Ansible基础设施——这是掌握Ansible 4.3的必要步骤！
- en: First off, a little history. As we discussed in the preceding chapter, Ansible
    possesses a number of strengths in its design that have led to its rapid growth
    and uptake. Many of these strengths, such as its agentless design and easy-to-read
    YAML code, remain the same. Indeed, if you read the change logs for Ansible releases
    since 2.9, you will observe that there have been few changes of note to the core
    Ansible functionality since that release—rather, all the development effort has
    gone into another area.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，稍微了解一下历史。正如我们在前一章中讨论的那样，Ansible在设计上具有许多优点，这些优点导致了其迅速增长和接受。其中许多优点，比如无代理设计和易于阅读的YAML代码，仍然保持不变。事实上，如果您阅读自2.9版本以来的Ansible发布的更改日志，您会发现自那个版本以来，核心Ansible功能几乎没有什么值得注意的变化，而所有的开发工作都集中在另一个领域。
- en: Ansible's modules were undoubtedly one of its greatest strengths, and the fact
    that anyone, from individual contributors to hardware vendors and cloud providers,
    could submit their own modules meant that by the time of the 2.9 release, Ansible
    contained literally thousands of modules for every conceivable purpose.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，Ansible的模块是其最大的优势之一，任何人，从个人贡献者到硬件供应商和云提供商，都可以提交自己的模块，这意味着到2.9版本时，Ansible包含了成千上万个用于各种用途的模块。
- en: This in itself became something of a headache for those managing the project.
    Let's say that a module had a bug in it that needed to be fixed, or someone added
    a great new feature to an existing one that was likely to be popular. The Ansible
    release itself contained all the modules—in short, they were tightly coupled to
    the release of Ansible itself. This meant that in order for a new module to get
    released, a whole new version of Ansible had to be released to the community.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身对于管理项目的人来说成了一个头疼的问题。比如说一个模块出现了bug需要修复，或者有人给现有的模块添加了一个很棒的新功能，可能会很受欢迎。Ansible发布本身包含了所有的模块，简而言之，它们与Ansible本身的发布紧密耦合。这意味着为了发布一个新模块，必须发布一个全新版本的Ansible给社区。
- en: Combine that with issues and pull requests from hundreds of module developers,
    and those managing the core Ansible code base had a real headache on their hands.
    It was clear that while these modules were a massive part of Ansible's success,
    they were also responsible for causing issues in release cycles and management
    of the code base. What was needed was a way to decouple the modules (or at least
    the bulk of them) from the releases of the Ansible engine—the core Ansible runtimes
    that we ran in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015),
    *The* *System Architecture and Design of Ansible*, of this book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 结合数百个模块开发人员的问题和拉取请求，管理核心Ansible代码库的人确实头疼不已。很明显，虽然这些模块是Ansible成功的重要组成部分，但它们也负责在发布周期和代码库管理中引起问题。需要的是一种将模块（或至少是大部分模块）与Ansible引擎的发布解耦的方法——我们在本书的[*第1章*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015)中运行的核心Ansible运行时的系统架构和设计。
- en: Thus, **Ansible Content Collections** (or just Collections for short) were born.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**Ansible内容集合**（或简称集合）诞生了。
- en: Ansible Content Collections
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible内容集合
- en: While we will look in greater depth at these shortly, the important concept
    of note is that Collections are a package format for Ansible content, which for
    the sake of this discussion means all those thousands of modules. By distributing
    modules, especially those coded and maintained by third parties, using Collections,
    the Ansible team has effectively removed the coupling between the releases of
    the core Ansible product and the modules that make it so valuable to so many.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们很快会更深入地研究这些内容，但需要注意的重要概念是，集合是Ansible内容的一种包格式，对于本讨论来说，这意味着所有那些成千上万的模块。通过使用集合分发模块，特别是那些由第三方编写和维护的模块，Ansible团队有效地消除了核心Ansible产品的发布与使其对许多人如此有价值的模块之间的耦合。
- en: This of course leads to another nuance—when you installed, say, **Ansible 2.9.1**,
    you were installing a given version of the Ansible binaries and other core code,
    and all the modules that were submitted and approved for inclusion at that time.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装了，比如**Ansible 2.9.1**，你实际上安装了一个给定版本的Ansible二进制文件和其他核心代码，以及那个时候提交和批准包含的所有模块。
- en: 'Now, when we talk about installing Ansible 4.3, what we actually mean is this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们谈论安装Ansible 4.3时，我们实际上指的是：
- en: Ansible 4.3.0 is now a package that contains (at the time of writing) 85 Collections
    of modules, plugins, and other important functionality that will get as many people
    as possible started on their Ansible journey before they need to install further
    Collections. It is, in short, a *getting started* pack of Collections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 4.3.0现在是一个包，其中包含（在撰写本文时）85个模块、插件和其他重要功能的集合，这将让尽可能多的人在他们需要安装更多集合之前开始他们的Ansible之旅。简而言之，这是一个*入门*集合包。
- en: What is important here is that Ansible 4.3.0 does *not* contain any actual automation
    runtimes. If you were to install Ansible 4.3.0 in isolation, you would not actually
    be able to run Ansible! Fortunately, doing this is not possible, and Ansible 4.3.0
    has a dependency on a package currently called **ansible-core**. This package
    contains the Ansible language runtimes, and a small number of the core plugins
    and modules, such as `ansible.builtin.debug`, which we used frequently in the
    examples in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The*
    *System Architecture and Design of Ansible*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是，Ansible 4.3.0 *不*包含任何实际的自动化运行时。如果你孤立地安装了Ansible 4.3.0，你实际上无法运行Ansible！幸运的是，这是不可能的，Ansible
    4.3.0依赖于一个当前称为**ansible-core**的包。这个包包含了Ansible语言运行时，以及一小部分核心插件和模块，比如`ansible.builtin.debug`，我们在[*第1章*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015)中的示例中经常使用的。*Ansible*
    *的系统架构和设计*。
- en: Each release of the Ansible package will have dependencies on specific versions
    of ansible-core, such that it will always pair itself up with the right automation
    engine. For example, Ansible 4.3.0 depends upon ansible-core >= 2.11 and < 2.12.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Ansible包的发布都会依赖于特定版本的ansible-core，以便它始终与正确的自动化引擎配对。例如，Ansible 4.3.0依赖于ansible-core
    >= 2.11 and < 2.12。
- en: 'Ansible has switched to semantic versioning for the Ansible package itself,
    starting with the 3.0.0 release. For anyone who hasn''t come across semantic versioning
    yet, it can be explained quite simply as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible已经开始使用语义化版本控制来管理Ansible包本身，从3.0.0版本开始。对于还没有接触过语义化版本控制的人来说，可以简单地解释如下：
- en: 'Ansible 4.3.0: This is the first semantic versioned release of a new Ansible
    package.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 4.3.0：这是一个新的Ansible包的第一个语义化版本发布。
- en: 'Ansible 4.0.1: This (and all releases where the rightmost digit changes) will
    contain only backward-compatible bug fixes.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 4.0.1：这个版本（以及所有右边数字变化的所有版本）将只包含向后兼容的错误修复。
- en: 'Ansible 4.1.0: This (and all releases where the middle digit changes) will
    contain backward-compatible new features, and possibly also bug fixes.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 4.1.0：这个版本（以及所有中间数字变化的所有版本）将包含向后兼容的新功能，可能还包括错误修复。
- en: 'Ansible 5.0.0: This will contain changes that break backward compatibility
    and is known as a major release.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 5.0.0：这将包含破坏向后兼容性的更改，被称为主要发布。
- en: The ansible-core package is not adopting semantic versioning, so it is anticipated
    that Ansible 5.0.0 will have a dependency on ansible-core >= 2.12\. Note that
    this release of ansible-core, not being under semantic versioning, could contain
    changes that break backward compatibility, and so it is important on our journey
    to mastery to be aware of these nuances in how Ansible is now versioned.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ansible-core包不采用语义化版本控制，因此预计Ansible 5.0.0将依赖于ansible-core >= 2.12。请注意，这个ansible-core的发布，不受语义化版本控制，可能包含破坏向后兼容性的更改，因此在我们掌握的过程中，了解Ansible现在的版本化方式的这些细微差别是很重要的。
- en: Important note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Finally, note that the ansible-core package was renamed from ansible-base in
    the 2.11 release, so if you see references to ansible-base please know it is simply
    the old name for the ansible-core package.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，ansible-core 包在 2.11 版本中从 ansible-base 更名，因此如果您看到对 ansible-base 的引用，请知道它只是
    ansible-core 包的旧名称。
- en: All these changes have been planned and executed over a significant period of
    time. While their implementation has been designed to make the journey for existing
    Ansible users as smooth as possible, there are implications that need to be addressed,
    starting with how you actually install and upgrade Ansible, and we will look at
    exactly that in the next section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些变化都是经过长时间计划和执行的。虽然它们的实施旨在尽可能顺利地为现有的 Ansible 用户提供服务，但需要解决一些问题，首先是您实际上如何安装和升级
    Ansible，我们将在下一节中详细讨论。
- en: Upgrading from earlier Ansible installations
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从早期的 Ansible 安装升级
- en: 'The splitting of Ansible into two packages, one of which is dependent on the
    other, has created some headaches for package maintainers. Whereas packages were
    readily available for CentOS and RHEL, there are no current packages of Ansible
    4.3.0 or ansible-core 2.11.1\. A quick look inside the EPEL packages directory
    for CentOS/RHEL 8 shows that the latest RPM available for Ansible is version 2.9.18\.
    The official Ansible installation guide goes further:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Ansible 拆分为两个相互依赖的包给包维护者带来了一些麻烦。虽然 CentOS 和 RHEL 的包很容易获得，但目前没有 Ansible 4.3.0
    或 ansible-core 2.11.1 的当前包。快速查看 CentOS/RHEL 8 的 EPEL 包目录，最新的 Ansible RPM 版本是 2.9.18。官方的
    Ansible 安装指南进一步说明：
- en: '*Since Ansible 2.10 for RHEL is not available at this time, continue to use
    Ansible 2.9*.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Ansible 2.10 for RHEL 目前不可用，继续使用 Ansible 2.9。
- en: This will change in due course as package maintainers work out the pros and
    cons of the various upgrade paths and packaging technologies, but at the time
    of writing, there is a very clear expectation on your upgrade path if you want
    to get started with Ansible 4.3.0 now, and the easiest way to get your hands on
    this latest and greatest release is to install it using the Python packaging technology,
    **pip**. However, it is not so much an upgrade we're performing, as an uninstallation
    followed by a re-installation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 随着包维护者研究各种升级路径和打包技术的利弊，这种情况将随着时间的推移而发生变化，但在撰写本文时，如果您想立即开始使用 Ansible 4.3.0，最简单的方法是使用
    Python 打包技术 **pip** 进行安装。然而，我们所做的并不是升级，而是卸载后重新安装。
- en: Uninstalling Ansible 3.0 or older
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卸载 Ansible 3.0 或更早版本
- en: The radical changes in Ansible package structure mean that if you have Ansible
    3.0 or earlier (including any of the 2.x releases) installed on your control node,
    sadly you cannot just upgrade your Ansible installation. Rather, you need to remove
    your existing Ansible installation before you install the later version.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 包结构的根本变化意味着，如果您的控制节点上安装了 Ansible 3.0 或更早版本（包括任何 2.x 版本），很遗憾，您不能只是升级您的
    Ansible 安装。相反，您需要在安装后删除现有的 Ansible 安装。
- en: Tip
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: As with removing any software, you should make sure you take a backup of your
    important files, especially central Ansible configuration files and inventories,
    in case they get removed during the removal process.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与卸载任何软件一样，您应该确保备份重要文件，特别是中央 Ansible 配置文件和清单，以防它们在卸载过程中被删除。
- en: 'The method for removing your package will depend upon your installation. For
    example, if you have Ansible 2.9.18 installed on CentOS 8 through an RPM, you
    can remove it with the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 删除软件包的方法取决于您的安装方式。例如，如果您在 CentOS 8 上通过 RPM 安装了 Ansible 2.9.18，可以使用以下命令删除它：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Similarly, on Ubuntu you can run the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在 Ubuntu 上可以运行以下命令：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you installed Ansible using `pip` previously, you can remove it with the
    following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前使用 `pip` 安装了 Ansible，可以使用以下命令删除它：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In short, it doesn't matter how you installed Ansible 3.0 (or earlier) on your
    control node. Even if you installed it with `pip`, and you are going to install
    the new version with pip, you must first uninstall the old version before doing
    anything else.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，您如何在控制节点上安装 Ansible 3.0（或更早版本）并不重要。即使您使用 `pip` 安装了它，并且您将使用 pip 安装新版本，您在做任何其他操作之前必须先卸载旧版本。
- en: When newer Ansible versions become available, it is advisable to check the documentation
    to see whether an uninstall is still required as part of the upgrade. For example,
    it was necessary to uninstall Ansible 3.0 before installing Ansible 4.3, partly
    due to the renaming of the ansible-base package to ansible-core.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当有新的 Ansible 版本可用时，建议查看文档，看看升级是否仍然需要卸载。例如，安装 Ansible 4.3 之前需要卸载 Ansible 3.0，部分原因是
    ansible-base 包更名为 ansible-core。
- en: Once you have removed your earlier version of Ansible, you are now ready to
    proceed with installing the new version on your control node, which we will cover
    in the next section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您删除了早期版本的 Ansible，您现在可以继续在控制节点上安装新版本，我们将在下一节中介绍。
- en: Installing Ansible from scratch
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头安装 Ansible
- en: 'As discussed in the preceding section, Ansible 4.3 is largely packaged and
    distributed using a Python package manager called **pip**. This is likely to change
    in due course, but at the time of writing, the key installation method you will
    need to use is to install via pip. Now, it''s fair to say that most modern Linux
    distributions already come with Python and pip pre-installed. If for any reason
    you get stuck and need to install it, the process is well documented on the official
    website here: [https://pip.pypa.io/en/stable/installing/](https://pip.pypa.io/en/stable/installing/).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所讨论的，Ansible 4.3 主要是使用一个名为 **pip** 的 Python 包管理器进行打包和分发的。这可能会随着时间的推移而发生变化，但在撰写本文时，您需要使用的主要安装方法是通过
    pip 进行安装。现在，可以说大多数现代 Linux 发行版已经预装了 Python 和 pip。如果因为任何原因你卡住需要安装它，这个过程在官方网站上有详细说明：[https://pip.pypa.io/en/stable/installing/](https://pip.pypa.io/en/stable/installing/)。
- en: 'Once you have pip installed, the process of installing Ansible is as simple
    as running this command, and the beauty is, the command is the same on all operating
    systems (though note that on some operating systems, your `pip` command might
    be called `pip3` to differentiate between the Python 2.7 and Python 3 releases
    that may coexist):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装了pip，安装Ansible的过程就像运行这个命令一样简单，而且美妙的是，这个命令在所有操作系统上都是相同的（尽管请注意，在某些操作系统上，您的`pip`命令可能被称为`pip3`，以区分可能共存的Python
    2.7和Python 3版本）：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are, of course, a few variations on this command. For example, the command
    as we have given it will install the latest version of Ansible available for all
    users on the system.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个命令有一些变化。例如，我们给出的命令将为系统上的所有用户安装可用的最新版本的Ansible。
- en: 'If you want to test or stick to a specific version (perhaps for testing or
    qualification purposes), you could force pip to install a specific version with
    the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想测试或坚持使用特定版本（也许是为了测试或资格认证目的），您可以使用以下命令强制pip安装特定版本：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This second command will ensure that Ansible 4.3.0 is installed for all users
    on your system, regardless of which is the latest release. We can go further too;
    to install Ansible but only for your user account, you can run the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这第二个命令将确保在您的系统上为所有用户安装Ansible 4.3.0，而不管哪个是最新版本。我们还可以进一步进行;要安装Ansible但仅适用于您的用户帐户，您可以运行以下命令：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'One particularly handy trick is that when you start working with pip, you can
    use Python virtual environments to sandbox specific versions of Python modules.
    For example, you could create one virtual environment for Ansible 2.9 as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别方便的技巧是，当您开始使用pip时，您可以使用Python虚拟环境来隔离特定版本的Python模块。例如，您可以创建一个用于Ansible 2.9的虚拟环境如下：
- en: 'Create the virtual environment in a suitable directory using the following
    command:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在适当的目录中创建虚拟环境：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will create a new virtual environment in the directory where you run the
    command, with the environment (and directory containing it) being called `ansible-2.9`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在运行命令的目录中创建一个新的虚拟环境，环境（及包含它的目录）将被称为`ansible-2.9`。
- en: 'Activate the virtual environment as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活虚拟环境如下：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now you are ready to install Ansible 2.9\. To install the latest version of
    Ansible 2.9, we will need to tell `pip` to install a version greater than (or
    equal to) 2.9, but less than 2.10, otherwise it would simply install Ansible 4.3:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经准备安装Ansible 2.9。要安装Ansible 2.9的最新版本，我们需要告诉`pip`安装大于（或等于）2.9但小于2.10的版本，否则它将只安装Ansible
    4.3：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if you check your Ansible version, you should find that you are running
    the latest minor version of 2.9:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果您检查您的Ansible版本，您应该会发现您正在运行2.9的最新次要版本：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The downside to using virtual environments is that you need to remember to
    run the `source` command from *step 2* every time you log into your Ansible control
    machine. However, the upside is that you could repeat the preceding process with
    Ansible 4.3 in a separate virtual environment as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟环境的缺点是您需要记住每次登录到Ansible控制机时运行*步骤2*中的`source`命令。但好处是您可以在一个单独的虚拟环境中重复上述过程，如下所示，使用Ansible
    4.3：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The great thing about this is that you can now switch between the two versions
    of Ansible at will, simply by issuing the appropriate source command for the appropriate
    environment and then running Ansible in the usual way. This could be especially
    useful if you are in the process of migrating code from Ansible 2.9 to 4.3, or
    have some legacy code that won't yet work and you still need it before you have
    time to make the required changes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是，您现在可以随意在两个版本的Ansible之间切换，只需发出适当环境的适当源命令，然后以通常的方式运行Ansible。如果您正在从Ansible
    2.9迁移到4.3的过程中，或者有一些尚未能正常工作但您仍然需要的旧代码，这可能特别有用，直到您有时间进行必要的更改。
- en: 'Finally, if you want to upgrade your new installation of Ansible, you simply
    need to issue the appropriate `pip` command depending on your install method.
    For example, if you installed Ansible for all users, you would issue the following
    command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您想要升级您的新安装的Ansible，您只需要根据您的安装方法发出适当的`pip`命令。例如，如果您为所有用户安装了Ansible，您将发出以下命令：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you had installed it only for your user account, the command would be similar:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只为您的用户帐户安装了它，命令将类似：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now if you are working in a virtual environment, you must remember to activate
    the environment first. Once this is done, you can upgrade in the same way as before:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您正在虚拟环境中工作，您必须记住先激活环境。一旦完成，您可以像以前一样升级：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that the preceding example will upgrade whatever is installed in the Ansible
    2.9 environment to the very latest version, which right now is 4.0\. Also, a point
    to be noted is that, as discussed in the preceding section, *Upgrading from earlier
    Ansible installations*, this will break the install. To upgrade to the latest
    minor version, remember that you can specify version criteria just as we did when
    installing Ansible in this environment:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的示例将把安装在Ansible 2.9环境中的任何内容升级到最新版本，目前是4.0。另外，需要注意的一点是，正如在前面的部分*从早期的Ansible安装升级*中讨论的那样，这将破坏安装。要升级到最新的次要版本，记住您可以像在此环境中安装Ansible时那样指定版本标准：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can of course apply the version constraints to any of the other examples
    too. Their use is not limited in any way to a virtual environment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也可以将版本约束应用于任何其他示例。它们的使用方式不仅限于虚拟环境。
- en: Hopefully, by now you should have a pretty good idea of how to install Ansible
    4.3, either from scratch, or to upgrade from an earlier installation. With this
    done, it's time we took a look at **Ansible Collections** as they are the driver
    behind all these changes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到目前为止，您应该已经对如何安装Ansible 4.3有了相当好的了解，无论是从头开始，还是从早期安装升级。完成这些工作后，是时候我们来看看**Ansible集合**了，因为它们是所有这些变化的驱动力。
- en: What are Ansible Collections?
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Ansible集合？
- en: Ansible Collections represent a major departure from the traditional monolithic
    approach to Ansible releases, where over 3,600 modules were being released along
    with the Ansible executables at one point. This, as you can imagine, was making
    Ansible releases unmanageable, and also meant that end users had to wait for an
    entirely new release of Ansible to receive a feature update or bug fix to a single
    module—obviously a very inefficient approach.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible集合代表了与Ansible发布的传统的单片式方法的重大分歧，在某一时刻，与Ansible可执行文件一起发布了超过3600个模块。可以想象，这使得Ansible发布变得难以管理，并且意味着最终用户必须等待完全新的Ansible发布才能获得对单个模块的功能更新或错误修复——显然这是一种非常低效的方法。
- en: 'Thus, Ansible Collections were born, and their premise is quite simple: they
    are a mechanism for building, distributing, and consuming multiple different types
    of Ansible content. When you first migrate from Ansible 2.9 or earlier, your experience
    with Ansible Collections will come in the form of modules. As we discussed earlier
    in this chapter, what we call Ansible 4.3 is actually a package comprising around
    85 collections…it does not contain the Ansible executables at all! Each of these
    collections contains a number of different modules, some maintained by the community,
    some maintained by specific vendors. Ansible 4.3 depends upon ansible-core 2.11.x,
    and this package contains the Ansible executables and the core `ansible.builtin`
    modules only (such as `debug`, `file`, and `copy`).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Ansible集合诞生了，它们的前提非常简单：它们是一种用于构建、分发和消费多种不同类型的Ansible内容的机制。当您首次从Ansible 2.9或更早版本迁移时，您对Ansible集合的体验将以模块的形式呈现。正如我们在本章前面讨论的那样，我们所说的Ansible
    4.3实际上是一个包，包含大约85个集合……它根本不包含Ansible可执行文件！这些集合中的每一个都包含许多不同的模块，有些由社区维护，有些由特定供应商维护。Ansible
    4.3依赖于ansible-core 2.11.x，该软件包包含了Ansible可执行文件和核心的`ansible.builtin`模块（如`debug`、`file`和`copy`）。
- en: 'Let''s take a look in more detail at the anatomy of a collection so that we
    can understand more fully how they work. Each collection has a name comprising
    two parts: the namespace and the collection name.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下集合的结构，以便更充分地理解它们的工作方式。每个集合都有一个由两部分组成的名称：命名空间和集合名称。
- en: For example, the `ansible.builtin` collection has a namespace of `ansible` and
    a collection name of `builtin`. Similarly, in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015),
    *The* *System Architecture and Design of Ansible*, we installed a collection called
    `amazon.aws`. Here, `amazon` is the namespace and `aws` is the collection name.
    All namespaces must be unique, but collection names can be the same within a namespace
    (thus you could theoretically have `ansible.builtin` and `amazon.builtin`).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`ansible.builtin`集合的命名空间是`ansible`，集合名称是`builtin`。同样，在*第1章*，*Ansible的系统架构和设计*中，我们安装了一个名为`amazon.aws`的集合。在这里，`amazon`是命名空间，`aws`是集合名称。所有命名空间必须是唯一的，但集合名称可以在命名空间内相同（因此您理论上可以有`ansible.builtin`和`amazon.builtin`）。
- en: Although you can work with collections in a number of ways, including simply
    building and installing them locally all from your own machine, or directly from
    a Git repository, the central home for collections is **Ansible Galaxy**, and
    it is here that you will find all the collections included with the Ansible 4.3
    package, along with many more. The Ansible Galaxy website is accessible at [https://galaxy.ansible.com](https://galaxy.ansible.com)
    and there is a command-line tool (which we saw in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015),
    *The* *System Architecture and Design of Ansible*) called `ansible-galaxy` that
    can be used to interact with this website (for example, to install collections).
    We will use this tool quite extensively throughout the rest of this chapter, so
    you will get a chance to get better acquainted with it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以以多种方式使用集合，包括简单地在本地构建和安装它们，或直接从Git存储库中构建和安装它们，但集合的中心位置是Ansible Galaxy，您将在这里找到所有包含在Ansible
    4.3软件包中的集合，以及更多其他集合。Ansible Galaxy网站可在[https://galaxy.ansible.com](https://galaxy.ansible.com)访问，并且有一个命令行工具（我们在第1章中看到过，*Ansible的系统架构和设计*）称为`ansible-galaxy`，可用于与该网站交互（例如，安装集合）。我们将在本章的其余部分广泛使用此工具，因此您将有机会更加熟悉它。
- en: 'You can freely create your own account on Ansible Galaxy by logging in with
    your GitHub credentials, and when you do, your namespace is automatically created
    to be the same as your GitHub username. You can learn more about Ansible Galaxy
    namespaces here: [https://galaxy.ansible.com/docs/contributing/namespaces.html](https://galaxy.ansible.com/docs/contributing/namespaces.html).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用GitHub凭据登录Ansible Galaxy自由创建自己的帐户，当您这样做时，您的命名空间将自动创建为与您的GitHub用户名相同。您可以在这里了解更多关于Ansible
    Galaxy命名空间的信息：[https://galaxy.ansible.com/docs/contributing/namespaces.html](https://galaxy.ansible.com/docs/contributing/namespaces.html)。
- en: Now that you have an understanding of how Ansible Collection names are created,
    let's take a deeper look at how Collections are put together and how they work.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了Ansible集合名称是如何创建的，让我们更深入地了解一下集合是如何组合和工作的。
- en: The anatomy of an Ansible collection
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible集合的结构
- en: The easiest way to understand how a collection works under the hood is to build
    a simple one for ourselves, so let's get started on that. As with all aspects
    of Ansible, the developers have produced a system in collections that is powerful
    yet easy to work with, and if you already have prior experience of working with
    Ansible roles you will find collections work in a similar way. If you haven't,
    however, don't worry; we'll teach you all you need to know here.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 理解集合在幕后如何工作的最简单方法是为自己构建一个简单的集合，所以让我们开始吧。与Ansible的所有方面一样，开发人员已经为集合制定了一个强大而易于使用的系统，如果您已经有使用Ansible角色的经验，您会发现集合的工作方式类似。然而，如果您没有，不用担心；我们将在这里教会您所需了解的一切。
- en: 'A collection comprises a series of directories, each with a special name and
    each intended to hold a specific type of content. Any of these directories can
    be empty; you don''t have to include all types of content in a collection. In
    fact, there is only one mandatory file in a collection! Ansible even provides
    a tool to help you build an empty collection to get started with. Let''s use this
    now to create a new empty collection to learn with by running the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 集合由一系列目录组成，每个目录都有一个特殊的名称，旨在容纳特定类型的内容。这些目录中的任何一个都可以是空的；您不必在集合中包含所有类型的内容。实际上，集合中只有一个强制性文件！Ansible
    甚至提供了一个工具来帮助您构建一个空的集合，以便开始使用。让我们现在使用它来创建一个新的空集合，以便学习，通过运行以下命令：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When you run this, you should see that it creates a directory tree as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此命令时，您应该看到它创建了以下目录树：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can see from the preceding directory tree that this command created a top-level
    directory using our `masterybook` namespace, and then a subdirectory with the
    collection name of `demo`. It then created two files and three directories.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从前面的目录树中看到，此命令使用我们的 `masterybook` 命名空间创建了一个顶级目录，然后创建了一个名为 `demo` 的集合子目录。然后创建了两个文件和三个目录。
- en: 'The purpose of these is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 其目的如下：
- en: '`README.md`: This is the README file for the collection and should provide
    helpful information to anyone who is looking at the module code for the first
    time.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README.md`：这是集合的 README 文件，应为第一次查看模块代码的任何人提供有用的信息。'
- en: '`docs`: This directory is used to store general documentation for the collection.
    All documentation should be in Markdown format and should not be placed in any
    subfolders. Modules and plugins should still have their documentation embedded
    using Python docstrings, which we will learn more about in [*Chapter 10*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183),
    *Extending Ansible*.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docs`：此目录用于存储集合的一般文档。所有文档都应采用 Markdown 格式，并且不应放在任何子文件夹中。模块和插件仍应使用 Python 文档字符串嵌入其文档，我们将在[*第
    10 章*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183)中学习更多关于此的内容，*扩展 Ansible*。'
- en: '`galaxy.yml`: This is the only mandatory file in the collection structure and
    contains all the information necessary to build the collection, including version
    information, author details, license information, and so on. The file created
    by the command run previously is a complete template with comments to explain
    each parameter, so you should find it easy to go through it and complete it to
    your requirements.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`galaxy.yml`：这是集合结构中唯一强制性的文件，包含构建集合所需的所有信息，包括版本信息、作者详细信息、许可信息等。之前运行的命令创建的文件是一个完整的模板，其中包含注释以解释每个参数，因此您应该发现很容易浏览并根据您的要求完成它。'
- en: '`plugins`: This directory should contain all the Ansible plugins that you develop.
    Modules should also be included in separate modules/subdirectories, which you
    will need to create under the plugins folder. We will learn about creating plugins
    and modules for Ansible in [*Chapter 10*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183),
    *Extending Ansible*.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plugins`：此目录应包含您开发的所有 Ansible 插件。模块也应包含在单独的模块/子目录中，您需要在插件文件夹下创建。我们将在[*第 10
    章*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183)中学习有关为 Ansible 创建插件和模块的内容，*扩展
    Ansible*。'
- en: '`roles`: Before Ansible 3.0, Ansible Galaxy existed only to distribute roles:
    reusable sets of Ansible code that can readily be distributed and used elsewhere
    to solve common automation challenges. We will learn all about roles in [*Chapter
    8*](B17462_08_Final_JC_ePub.xhtml#_idTextAnchor156), *Composing Reusable Ansible
    Content with Roles*, so don''t worry for now if you haven''t come across them
    yet. Roles can still be distributed using Ansible Galaxy but can also be included
    in collections, which in time will probably become the norm.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`roles`：在 Ansible 3.0 之前，Ansible Galaxy 只用于分发角色：可重复使用的 Ansible 代码集，可以轻松地分发和在其他地方使用以解决常见的自动化挑战。我们将在[*第
    8 章*](B17462_08_Final_JC_ePub.xhtml#_idTextAnchor156)中学习有关角色的所有内容，*使用角色组合可重复使用的
    Ansible 内容*，所以如果您还没有遇到它们，现在不用担心。角色仍然可以使用 Ansible Galaxy 进行分发，但也可以包含在集合中，这在未来可能会成为常态。'
- en: 'In addition to this, collections can also contain the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，集合还可以包含以下内容：
- en: '`tests`: This directory is used to store files related to testing Ansible Collections
    prior to release, and to be included in the top-level Ansible package, collections
    must pass the Ansible test process. You don''t need to do this to use your own
    collection internally, but if you want it included in the main Ansible package
    you will have to complete this part of the development process. More details are
    available here: [https://docs.ansible.com/ansible/latest/dev_guide/developing_collections.html#testing-collections](https://docs.ansible.com/ansible/latest/dev_guide/developing_collections.html#testing-collections).'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests`：此目录用于存储与发布之前测试 Ansible 集合相关的文件，并且要包含在顶层 Ansible 包中，集合必须通过 Ansible 测试流程。您不需要在内部使用自己的集合时执行此操作，但是如果您希望将其包含在主要
    Ansible 包中，您将需要完成开发过程的这一部分。更多详细信息请参阅：[https://docs.ansible.com/ansible/latest/dev_guide/developing_collections.html#testing-collections](https://docs.ansible.com/ansible/latest/dev_guide/developing_collections.html#testing-collections)。'
- en: '`meta/runtime.yml`: This file and directory is used to specify important metadata
    about the collection, such as the version of the ansible-core package required,
    and various namespace routing and redirection stanzas to assist with the migration
    from Ansible 2.9 and earlier (where there were no namespaces) to Ansible 4.3 and
    beyond.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`meta/runtime.yml`：此文件和目录用于指定有关集合的重要元数据，例如所需 ansible-core 包的版本，以及各种命名空间路由和重定向段，以帮助从
    Ansible 2.9 及更早版本（其中没有命名空间）迁移到 Ansible 4.3 及更高版本。'
- en: '`playbooks`: This directory will be supported in future versions of Ansible
    to include playbooks with the collection, though the official documentation on
    this is not complete at the time of writing.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playbooks`：此目录将在将来的 Ansible 版本中得到支持，以包含与集合一起使用的 playbooks，尽管在撰写本文时，官方文档尚不完整。'
- en: 'Now that you''ve created and understood the collection directory structure,
    let''s add our own module to it. When we''ve done this, we''ll package it up and
    then install it on our system and use it in a playbook: a complete end-to-end
    test of how collections work. We''ll borrow the module code for this from [*Chapter
    10*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183), *Extending Ansible*, so
    don''t worry about understanding this code in depth at this stage as it is fully
    explained there. The full code listing is several pages long so we won''t repeat
    it in the book here. Download the code accompanying this book or refer to the
    code listings in [*Chapter 10*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183),
    *Extending Ansible*, to obtain the `remote_copy.py` module code. It is included
    in the `Chapter10/example08/library` directory of the example code accompanying
    this book.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建并理解了集合目录结构，让我们向其中添加我们自己的模块。完成后，我们将对其进行打包，然后安装到我们的系统上，并在playbook中使用它：这是对集合工作原理的完整端到端测试。我们将从《第10章》《扩展Ansible》中借用模块代码，所以在这个阶段不用担心深入理解这段代码，因为它在那里有完整的解释。完整的代码清单有好几页长，所以我们不会在这本书中重复它。下载本书附带的代码或参考《第10章》《扩展Ansible》中的代码清单，获取`remote_copy.py`模块代码。它包含在本书附带的示例代码的`Chapter10/example08/library`目录中。
- en: Create a `modules/` subdirectory inside the `plugins/` directory, and add the
    `remote_copy.py` code there.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`plugins/`目录中创建一个`modules/`子目录，并在其中添加`remote_copy.py`代码。
- en: When you have reviewed the information in `galaxy.yml`, feel free to add your
    own name and other details in there, and you're done! That's all there is to creating
    your first collection. It really is beautifully simple, a set of files in a well-ordered
    directory structure.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查看了`galaxy.yml`中的信息后，可以随意在其中添加您自己的姓名和其他细节，然后就完成了！这就是创建您的第一个集合的全部内容。它真的非常简单，一组文件放在一个井然有序的目录结构中。
- en: Tip
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Ansible Collections are expected to follow semantic versioning, as discussed
    earlier in this chapter, so be sure to adopt this when you create and build your
    own modules.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面讨论的那样，预期Ansible集合遵循语义化版本控制，因此在创建和构建自己的模块时，请务必采用这一点。
- en: 'Your completed module directory structure should look something like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您完成的模块目录结构应该是这样的：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When all the files are in place, it''s time to build your collection. This
    is very simple, and is done by changing up to the same collection top-level directory
    (the one where `galaxy.yml` resides) and running this command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有文件就位后，就该构建您的集合了。这非常简单，只需切换到与`galaxy.yml`所在的同一集合顶级目录，并运行以下命令：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This creates a tarball containing your collection files, which you can now use
    as you wish! You could publish this straight away to Ansible Galaxy, but first,
    let's test it locally to see if it works.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个tarball，其中包含您的集合文件，您现在可以根据需要使用它！您可以立即将其发布到Ansible Galaxy，但首先，让我们在本地测试一下看看它是否有效。
- en: By default, Ansible stores collections locally in your home directory, under
    `~/.ansible/collections`. However, as we are testing a collection we just built,
    let's alter the behavior of Ansible slightly and install it in a local directory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible将集合存储在您的家目录下的`~/.ansible/collections`中。然而，由于我们正在测试刚刚构建的集合，让我们稍微改变一下Ansible的行为，并将其安装在本地目录中。
- en: 'To try this out, create a new empty directory for a simple test playbook to
    reside in, and then create a directory called `collections` for us to install
    our newly created collection in:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个，为一个简单的测试playbook创建一个新的空目录，然后创建一个名为`collections`的目录，用于安装我们新创建的集合：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'By default, Ansible won''t know to look in this directory for collections,
    so we must override its default configuration to tell it to look in here. Within
    your directory, create a new `ansible.cfg` file (this file is always read if present
    and overrides the settings in any central configuration file, for example, `/etc/ansible/ansible.cfg`).
    This file should contain the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible不会知道要在这个目录中查找集合，因此我们必须覆盖其默认配置，告诉它在这里查找。在您的目录中，创建一个新的`ansible.cfg`文件（如果存在，该文件始终被读取并覆盖任何中央配置文件中的设置，例如`/etc/ansible/ansible.cfg`）。该文件应包含以下内容：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This configuration directive tells Ansible to look in the collections subdirectory
    within our current directory before checking the default locations on the system.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置指令告诉Ansible在检查系统上的默认位置之前，先在当前目录下的collections子目录中查找。
- en: 'Now you''re ready to install the collection we built earlier. Assuming you
    built this in your home directory, the command to do this is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好安装之前构建的集合了。假设您是在家目录中构建的，那么安装它的命令如下：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you explore your local `collections` directory, you should find it now contains
    the collection you created earlier, plus a couple of extra files created during
    the build process.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您探索本地的`collections`目录，您应该会发现它现在包含了您之前创建的集合，以及在构建过程中创建的一些额外文件。
- en: 'Finally, let''s create a simple playbook to make use of our module. As a spoiler
    to [*Chapter 10*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183), *Extending
    Ansible*, this module performs a simple file copy on the system Ansible is controlling,
    so let''s create a test file in a publicly writeable directory such as `/tmp`,
    and put our module to work creating a copy. Consider the following playbook code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个简单的playbook来使用我们的模块。作为《第10章》《扩展Ansible》的一个预告，这个模块在Ansible控制的系统上执行一个简单的文件复制，所以让我们在一个公共可写目录（例如`/tmp`）中创建一个测试文件，并让我们的模块开始复制。考虑以下playbook代码：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have two tasks in our playbook here. One uses the file module from the `ansible.builtin`
    collection to create an empty file for our module to copy. The second task uses
    our new module, referencing it with the fully qualified collection name, to copy
    the file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的playbook中有两个任务。一个使用`ansible.builtin`集合中的文件模块来创建一个空文件，供我们的模块复制。第二个任务使用我们的新模块，使用完全限定的集合名称来引用它，来复制文件。
- en: 'You can run this playbook code in the normal manner. For example, to run it
    against your local machine, run this command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以正常方式运行这个playbook代码。例如，要对本地机器运行它，运行以下命令：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note the comma after the `localhost` inventory item. This tells Ansible we
    are listing inventory hosts on the command line rather than having to create a
    local inventory file—a handy little shortcut when you''re testing code! If all
    goes according to plan, your playbook run should look as shown in *Figure 2.1*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`localhost`清单项后的逗号。这告诉Ansible我们在命令行上列出清单主机，而不必创建本地清单文件-当你测试代码时，这是一个很方便的小技巧！如果一切顺利，你的playbook运行应该如*图2.1*所示。
- en: '![Figure 2.1 – The output from running our example playbook against our demo
    collection'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1-运行示例playbook对我们的演示集合的输出'
- en: '](Images/B17462_02_01.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_02_01.jpg)'
- en: Figure 2.1 – The output from running our example playbook against our demo collection
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1-运行示例playbook对我们的演示集合的输出
- en: Congratulations, you have just created, built, and run your first Ansible collection!
    Collections are often more complex than this, of course, and may contain many
    modules, plugins, and even roles and other artifacts, as outlined earlier. However,
    to get started, this is all you need to know.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你刚刚创建、构建并运行了你的第一个Ansible集合！当然，集合通常比这更复杂，并且可能包含许多模块、插件，甚至角色和其他工件，正如前面所述。但是，要开始，这就是你需要知道的全部。
- en: 'Your final step when you are happy with your collection may very well be to
    publish it to Ansible Galaxy. Assuming you have already logged in to Ansible Galaxy
    and created your namespace, you simply need to navigate to your profile preferences
    page and click the **Show API Key** button, as shown in *Figure 2.2*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对你的集合满意时，你最后的一步很可能是将其发布到Ansible Galaxy。假设你已经登录到Ansible Galaxy并创建了你的命名空间，你只需要导航到你的个人资料首选项页面，然后点击**显示API密钥**按钮，如*图2.2*所示：
- en: '![Figure 2.2 – Obtaining your API key from Ansible Galaxy'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2-从Ansible Galaxy获取你的API密钥'
- en: '](Images/B17462_02_02.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_02_02.jpg)'
- en: Figure 2.2 – Obtaining your API key from Ansible Galaxy
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2-从Ansible Galaxy获取你的API密钥
- en: 'You can then feed this API key into the `ansible-galaxy` command-line tool
    to publish your collection. For example, to publish our collection from this chapter,
    you could run the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将这个API密钥输入到`ansible-galaxy`命令行工具中，以发布你的集合。例如，要发布本章的集合，你可以运行以下命令：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That concludes our look at collections and how they are built and used. As we
    mentioned, there are several ways to install collections, and indeed, Ansible
    modules are now distributed across a variety of collections. In the next section,
    we will take a look at ways to locate the module you require, and how to install
    and reference collections from within your automation code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对集合及其构建和使用的介绍。正如我们提到的，有几种安装集合的方法，而且现在Ansible模块已经分布在各种集合中。在下一节中，我们将看看如何找到你需要的模块，以及如何在你的自动化代码中安装和引用集合。
- en: Installing additional modules with ansible-galaxy
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ansible-galaxy安装额外模块
- en: Most of the time when you work with collections, you won't be building them
    yourself. There are already 780 available on Ansible Galaxy at the time of writing
    and, there will probably be many more by the time you read this book. Nonetheless,
    it is the author's personal belief that we all learn better when we can get our
    hands dirty, and thus, developing our own, albeit simple, collection was a great
    way for us to look at how they are put together and how they are referenced.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用集合时，大部分时间你不会自己构建它们。在撰写本书时，Ansible Galaxy上已经有780个可用的集合，而在你阅读本书时可能会有更多。尽管如此，作者个人认为，当我们能亲自动手时，我们学得更好，因此，开发我们自己的，尽管简单，集合是我们研究它们是如何组合和引用的绝佳方式。
- en: However, let's focus now on finding and then working with pre-existing collections
    on Ansible, as this is where your focus is likely to be most of the time. As we
    have already mentioned, the Ansible 4.3 package includes a set of collections
    for you to begin your automation journey with, along with the `ansible.builtin`
    collection included with the ansible-core package.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在让我们专注于查找并使用Ansible上已有的集合，因为这很可能是你大部分时间的关注点。正如我们已经提到的，Ansible 4.3包括一组集合，让你开始自动化之旅，以及与ansible-core包一起包含的`ansible.builtin`集合。
- en: 'If you want to see which collections got installed when you installed Ansible
    4.3 on your system, simply run the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看在你的系统上安装Ansible 4.3时安装了哪些集合，只需运行以下命令：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will return a list of all the installed collections in the format `<namespace>.<collection>`,
    along with their version numbers. Remember that collections are now independent
    of the Ansible version you install, so you can upgrade them without upgrading
    your entire Ansible installation. We will look at this shortly. The full list
    of collections installed as part of Ansible can also be found here: [https://docs.ansible.com/ansible/latest/collections/index.html](https://docs.ansible.com/ansible/latest/collections/index.html).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个格式为`<namespace>.<collection>`的所有已安装集合的列表，以及它们的版本号。请记住，集合现在与你安装的Ansible版本无关，因此你可以升级它们而不必升级整个Ansible安装。我们很快将会看到这一点。作为Ansible的一部分安装的所有集合的完整列表也可以在这里找到：[https://docs.ansible.com/ansible/latest/collections/index.html](https://docs.ansible.com/ansible/latest/collections/index.html)。
- en: 'When you come to need a module for a specific purpose, it is worth noting that
    collections are normally named to give you clues about what they contain. For
    example, suppose you want to perform some cloud provisioning in Amazon Web Services
    with Ansible; a quick glance at the collections index reveals two likely candidates:
    the `amazon.aws` collection and the `community.aws` one. Similarly, if you want
    to automate the functionality of a Cisco IOS switch, the `cisco.ios` collection
    looks like a good place to start. You can explore the modules present in each
    collection on the Ansible documentation website, or explore the modules in a collection
    by making use of the `ansible-doc` command. For example, to list all the modules
    contained in the `cisco.ios` collection, you could run the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要特定目的的模块时，值得注意的是，集合通常以名称命名，以便为您提供有关其包含内容的线索。例如，假设您想要使用Ansible在亚马逊网络服务中执行一些云配置;
    快速浏览集合索引会发现两个可能的候选项：`amazon.aws`集合和`community.aws`集合。同样，如果您想要自动化Cisco IOS交换机的功能，`cisco.ios`集合看起来是一个很好的起点。您可以在Ansible文档网站上探索每个集合中的模块，或者通过使用`ansible-doc`命令来探索集合中的模块。例如，要列出`cisco.ios`集合中包含的所有模块，您可以运行以下命令：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `community.*` packages aim to provide the same functionality that was present
    in Ansible 2.9, naturally with newer versions of modules and plugins, thus helping
    you to port playbooks from earlier Ansible versions without too much pain.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`community.*`包旨在提供与Ansible 2.9中存在的相同功能，自然而然地具有更新的模块和插件版本，从而帮助您在不太痛苦的情况下将playbook从早期的Ansible版本移植过来。'
- en: Of course, if you can't find what you need in the Ansible 4.3 package, you can
    simply head over to the Ansible Galaxy website to find many more.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您在Ansible 4.3包中找不到所需的内容，您可以简单地转到Ansible Galaxy网站找到更多内容。
- en: 'Once you have established which collections you are going to need for your
    playbook development, it''s time to install them. We have already seen in the
    previous section that we can install a collection directly from a local file on
    disk. In [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The*
    *System Architecture and Design of Ansible*, we ran the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了您在playbook开发中需要的集合，就是安装它们的时候了。我们已经在前一节中看到，我们可以直接从磁盘上的本地文件安装集合。在[*第1章*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015)，*Ansible的系统架构和设计*中，我们运行了以下命令：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This installed the latest version of the `amazon.aws` collection directly from
    Ansible Galaxy. The eagle-eyed among you might be thinking, "hold on, `amazon.aws`
    is already included as part of the Ansible 4.3 package." Indeed, it is. However,
    the decoupled nature of Ansible and its collections means we are free to install
    and upgrade collection versions without having to upgrade Ansible. Indeed, when
    we ran the preceding command, it installed the latest version of `amazon.aws`
    inside the users local collections path (`~/.ansible/collections`) as this is
    the default. Note that this is different to the behavior observed when we tested
    our own collection earlier in this chapter, as we specifically created an Ansible
    configuration file specifying a different collections path.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这安装了最新版本的`amazon.aws`集合直接从Ansible Galaxy。你们中的鹰眼可能会想，“等等，`amazon.aws`已经作为Ansible
    4.3包的一部分包含在内了。”的确是这样。然而，Ansible及其集合的解耦特性意味着我们可以自由安装和升级集合版本，而无需升级Ansible。的确，当我们运行前面的命令时，它将最新版本的`amazon.aws`安装在用户本地集合路径（`~/.ansible/collections`）内，因为这是默认设置。请注意，这与我们在本章前面测试自己的集合时观察到的行为不同，因为我们专门创建了一个Ansible配置文件，指定了不同的集合路径。
- en: 'We find out what happened by running another collection list using the `ansible-galaxy`
    command, only this time we will only filter on the `amazon.aws` collection:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`ansible-galaxy`命令运行另一个集合列表，我们可以找出发生了什么，只是这一次我们只会过滤`amazon.aws`集合：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output will be something like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于这样：
- en: '![Figure 2.3 – Listing multiple versions of an installed collection'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 - 列出已安装集合的多个版本'
- en: '](Images/B17462_02_03.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_02_03.jpg)'
- en: Figure 2.3 – Listing multiple versions of an installed collection
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 - 列出已安装集合的多个版本
- en: Here, we can see that the `1.3.0` version of this collection was installed alongside
    our Ansible installation itself, but that the later `1.4.0` version is installed
    in my home directory's `.ansible/collections` folder, the latter taking precedence
    when a playbook references it and is run from my user account. Note that playbooks
    run from other user accounts on this system would only see the version `1.3.0`
    collection as this is installed system wide, and they would not normally be referencing
    the folder in my home directory.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这个集合的`1.3.0`版本是与我们的Ansible安装一起安装的，但稍后的`1.4.0`版本安装在我家目录的`.ansible/collections`文件夹中，在playbook引用它并从我的用户帐户运行时，后者优先。请注意，从此系统上的其他用户帐户运行的playbook只会看到`1.3.0`版本的集合，因为这是系统范围内安装的，它们通常不会引用我家目录中的文件夹。
- en: 'As you might expect, you can specify the version of a collection you want when
    you install it. If I had wanted to install the latest development version of the
    `amazon.aws` collection, I could have installed it locally using the following
    command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的，您可以在安装集合时指定您想要的版本。如果我想要安装`amazon.aws`集合的最新开发版本，我可以使用以下命令在本地安装它：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `--force` option is required as `ansible-galaxy` won't overwrite a release
    version of a collection with a development version unless you force it to—a sensible
    safety precaution!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`--force`选项是必需的，因为`ansible-galaxy`不会覆盖发布版本的集合与开发版本，除非您强制它这样做-这是一个明智的安全预防措施！'
- en: 'As well as installing collections from local files and from Ansible Galaxy,
    you can also install them directly from a Git repository. For example, to install
    the latest commit on the `stable` branch of a hypothetical GitHub repository,
    you could run the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从本地文件和Ansible Galaxy安装集合外，您还可以直接从Git存储库安装它们。例如，要安装假设的GitHub存储库的`stable`分支上的最新提交，您可以运行以下命令：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There are many possible permutations here, including accessing private Git repositories
    and even local ones.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有许多可能的排列组合，包括访问私有Git存储库甚至本地存储库。
- en: All of these are perfectly valid ways to install collections. However, imagine
    you require ten different collections for your playbook to run successfully. The
    last thing you want to do is to have to run ten different `ansible-galaxy` commands
    every time you deploy the automation code somewhere new! Plus, this could very
    easily get out of hand, with different collection versions on different hosts.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是安装集合的完全有效的方式。然而，想象一下，您的playbook需要十个不同的集合才能成功运行。您最不想做的事情就是每次在新的地方部署自动化代码时都要运行十个不同的`ansible-galaxy`命令！而且，这很容易失控，不同的主机上可能有不同的集合版本。
- en: Thankfully, Ansible has your back here too, and the `requirements.yml` file
    (which was present in earlier versions of Ansible and used to install roles from
    Ansible Galaxy before collections became a reality) can be used to specify a set
    of collections to install.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Ansible在这方面也为您着想，`requirements.yml`文件（在较早版本的Ansible中存在，并在集合成为现实之前用于从Ansible
    Galaxy安装角色）可以用于指定要安装的一组集合。
- en: 'As an example, consider the following `requirements.yml` file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下`requirements.yml`文件：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This file describes a requirement for two collections. The namespace for both
    is `geerlingguy`, and the collections are called `k8s` and `php_roles`. The `k8s`
    collection will have the latest stable version installed, whereas only version
    `1.0.0` of the `php_roles` collection will be installed regardless of the latest
    release version.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件描述了对两个集合的要求。两者的命名空间都是`geerlingguy`，集合分别称为`k8s`和`php_roles`。`k8s`集合将安装最新的稳定版本，而`php_roles`集合只会安装`1.0.0`版本，而不管最新发布版本是什么。
- en: 'To install all the requirements specified in `requirements.yml`, simply run
    the following command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`requirements.yml`中指定的所有要求，只需运行以下命令：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output of the command should look something like *Figure 2.4*:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出应该类似于*图2.4*：
- en: '![Figure 2.4 – Installing collections using a requirements.yml file'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 - 使用requirements.yml文件安装集合'
- en: '](Images/B17462_02_04.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_02_04.jpg)'
- en: Figure 2.4 – Installing collections using a requirements.yml file
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 - 使用requirements.yml文件安装集合
- en: As you can see from this output, both collections that we specified in the `requirements.yml`
    file have been installed at the appropriate versions. This is a very simple and
    powerful way to capture the collection requirements for your playbooks, and to
    have them all installed in one go, while retaining the correct versions where
    this is required.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 从此输出中可以看出，我们在`requirements.yml`文件中指定的两个集合都已安装到了适当的版本。这是捕获playbook的集合要求的一种非常简单而强大的方式，并且可以一次性安装它们所有，同时保留需要的正确版本。
- en: At this stage, you should have a robust understanding of the big changes in
    Ansible 4.3, especially collections, how to find the right ones for your automation
    needs, and how to install them (and even how to create your own if you need to!).
    In the final part of this chapter, we will provide a brief primer on how to port
    your playbooks to Ansible 4.3 from version 2.9 and earlier.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，您应该对Ansible 4.3中的重大变化有一个牢固的理解，特别是集合，如何找到适合您自动化需求的正确集合以及如何安装它们（甚至如何创建自己的集合如果需要）。在本章的最后部分，我们将简要介绍如何将您的playbook从2.9版本及更早版本迁移到Ansible
    4.3。
- en: How to port legacy playbooks to Ansible 4.3 (a primer)
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何将传统playbook迁移到Ansible 4.3（入门）
- en: No two Ansible playbooks (or roles or templates for that matter) are alike,
    and they vary in complexity from the simple to the intricate and complex. However,
    they are all important to their authors and users, and with all the major changes
    that were made in the transition from Ansible 2.9 through to 4.0, this book would
    not be complete without a primer on how to port your code to the newer Ansible
    versions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 没有两个Ansible playbook（或角色或模板）是相同的，它们的复杂程度从简单到复杂各不相同。然而，它们对于其作者和用户来说都很重要，随着从Ansible
    2.9到4.0的主要变化，本书没有一个关于如何将您的代码迁移到更新的Ansible版本的入门就不完整。
- en: 'Before we get too deep into this subject, let''s look at an example. In the
    first ever edition of this book, written in 2015 about Ansible version 1.9, an
    example appeared that renders a **Jinja2** template using a small Ansible playbook.
    We will still learn about an updated version of this code in [*Chapter 6*](B17462_06_Final_JC_ePub.xhtml#_idTextAnchor123),
    *Unlocking the Power of Jinja2 Templates*, of this book, but for now let''s look
    at the original code. The template, called `demo.j2`, looks like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究这个主题之前，让我们来看一个例子。在2015年关于Ansible 1.9版本的第一版书中，出现了一个示例，使用一个小的Ansible playbook渲染了一个**Jinja2**模板。我们将在本书的[*第6章*](B17462_06_Final_JC_ePub.xhtml#_idTextAnchor123)中学习关于这段代码的更新版本，*解锁Jinja2模板的力量*，但现在让我们看看原始代码。名为`demo.j2`的模板如下：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The playbook that renders this template looks like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染此模板的playbook如下所示：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is the exact same code that appeared in the first edition of this book,
    and as it was written for Ansible 1.9 and so much has changed in the transition
    to 4.3, you could be forgiven for thinking that this code would never run on Ansible
    4.3\. However, let''s do exactly that. We''ll run this code with the following
    command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一版书中出现的完全相同的代码，它是为Ansible 1.9编写的，所以在过渡到4.3时发生了很多变化，你可能会原谅认为这段代码永远不会在Ansible
    4.3上运行。然而，让我们确切地做到这一点。我们将使用以下命令运行此代码：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output from this command, run on Ansible 4.3 with ansible-core 2.11.1,
    looks like *Figure 2.5*:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible 4.3上运行此命令的输出，使用ansible-core 2.11.1，看起来像*图2.5*：
- en: '![Figure 2.5 – Running an example playbook from the first edition of this book
    on Ansible 4.3'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 - 在Ansible 4.3上运行本书第一版的示例playbook'
- en: '](Images/B17462_02_05.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_02_05.jpg)'
- en: Figure 2.5 – Running an example playbook from the first edition of this book
    on Ansible 4.3
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 - 在Ansible 4.3上运行本书第一版的示例playbook
- en: 'You would be forgiven for asking. why does this work, and why all the detail
    about collections when code that was first written for Ansible 1.9 still works
    in 4.3 without modification? Ansible 4.3 was coded specifically to provide users
    with the least painful path possible, and it is even stated in the porting guide
    for Ansible 2.10:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您问为什么这样做，以及为什么要详细介绍集合，当最初为Ansible 1.9编写的代码在4.3中不经修改仍然有效时，您将得到原谅。Ansible 4.3是专门编码的，以为用户提供尽可能少痛苦的路径，甚至在Ansible
    2.10的迁移指南中都明确指出：
- en: '*Your playbooks should continue to work without any changes*.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*您的playbook应该继续工作，无需任何更改*。'
- en: This will hold true as long as the module names remain unique. However, there
    is nothing to stop module name clashes any more—they only need to be unique within
    their own collection now. So, for example, we used the `pause` module in the preceding
    playbook, which has a **fully qualified collection name** (**FQCN**) of `ansible.builtin.pause`
    in Ansible 4.3\. The preceding code worked because there was no other module called
    `pause` within our collections. However, consider the `masterybook.demo` collection
    we created earlier in this chapter. There is nothing to stop us from creating
    our own module called `pause` in here that does something completely different.
    How would Ansible know which module to choose?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 只要模块名称保持唯一，这一点就会成立。然而，现在没有任何阻止模块名称冲突的东西——它们现在只需要在自己的集合中保持唯一。因此，例如，我们在前面的playbook中使用了`pause`模块，在Ansible
    4.3中它的**完全限定集合名称**（**FQCN**）是`ansible.builtin.pause`。前面的代码之所以有效是因为我们的集合中没有其他叫做`pause`的模块。然而，请考虑我们在本章前面创建的`masterybook.demo`集合。没有任何阻止我们在这里创建一个叫做`pause`的自己的模块，它做一些完全不同的事情。Ansible怎么知道选择哪个模块呢？
- en: The answer comes from inside Ansible itself, which has been coded to search
    all of the collections that form part of the Ansible 4.3 package; thus, a reference
    to `pause` resolves to `ansible.builtin.pause`. It will never resolve to `masterybook.demo.pause`
    (assuming we created that module) and so we would need to use the FQCN if we wanted
    to use our hypothetical module in a task.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 答案来自Ansible本身，它已经编码以搜索构成Ansible 4.3包的所有集合；因此，对`pause`的引用解析为`ansible.builtin.pause`。它永远不会解析为`masterybook.demo.pause`（假设我们创建了该模块），因此如果我们想在任务中使用我们的假设模块，我们需要使用FQCN。
- en: The recommendation from Ansible on this topic is to always use the FQCNs in
    your code to make sure that you never receive unexpected results from a module
    name clash. However, what if you wanted to avoid a lot of typing in a set of tasks?
    For example, typing `masterybook.demo.remote_copy` is a lot of typing if you have
    to do it repetitively.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible在这个话题上的建议是始终在您的代码中使用FQCN，以确保您从模块名称冲突中永远不会收到意外的结果。但是，如果您想要避免在一组任务中输入大量内容怎么办？例如，如果您不得不重复输入`masterybook.demo.remote_copy`，那就太多输入了。
- en: 'The answer comes in the form of a new `collections:` key defined at the play
    level in your playbook. When we tested our newly built collection earlier in this
    chapter, we used the FCQN to reference it. However, that same playbook could have
    been written as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 答案以playbook中在play级别定义的新`collections:`关键字的形式呈现。当我们在本章前面测试我们新构建的集合时，我们使用了FCQN来引用它。然而，同样的playbook也可以写成以下形式：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note the presence of the `collections:` key up at the play level. This in essence
    creates an ordered *search path* for references that are not specified by FQCNs.
    Thus, we have instructed our play to search the `masterybook.demo` namespace for
    modules, roles, and plugins before searching the included namespaces, such as
    `ansible.builtin`. Indeed, you can change the module reference on the `ensure
    foo` task from `ansible.builtin.file` to `file`, and the play will still work
    as intended. The collections directive does not overwrite these internal namespace
    search paths, it simply prepends namespaces to it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`collections:`关键字在play级别上的存在。这本质上为未通过FQCN指定的引用创建了一个有序的*搜索路径*。因此，我们已经指示我们的play在搜索包含的命名空间之前，搜索`masterybook.demo`命名空间的模块、角色和插件。实际上，您可以将`ensure
    foo`任务中的模块引用从`ansible.builtin.file`更改为`file`，play仍将按预期工作。`collections`指令不会覆盖这些内部命名空间搜索路径，它只是在其前面添加命名空间。
- en: 'Of note though, is that when you start working with roles (which we will cover
    later in this book), the collections search path specified in the play does not
    get inherited by the roles, so they will all need to have this defined manually.
    You can define the collections search paths for a role by creating a `meta/main.yml`
    file within your role, which could contain, for example, the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当您开始使用角色（我们将在本书后面介绍），play中指定的集合搜索路径不会被角色继承，因此它们都需要手动定义。您可以通过在角色中创建一个`meta/main.yml`文件来为角色定义集合搜索路径，该文件可以包含例如以下内容：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In addition, it is important to mention that these collection search paths do
    not affect items such as lookups, filters or tests that you might include in your
    collection. For example, if we included a lookup in our collection, it would need
    to be referenced using the FQCN regardless of whether the `collections` key appears
    in the play or role. Finally, note that you must always install your collections
    as demonstrated earlier in this chapter. Including the `collections` keyword in
    your code does not cause Ansible to automatically install or download the collections;
    it is simply a search path for them.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重要的是要提到，这些集合搜索路径不会影响您可能在集合中包含的查找、过滤器或测试等项目。例如，如果我们在我们的集合中包含了一个查找，无论`play`或`role`中是否出现`collections`关键字，都需要使用FQCN来引用它。最后，请注意，您必须始终像本章前面演示的那样安装您的集合。在您的代码中包含`collections`关键字并不会导致Ansible自动安装或下载这些集合；它只是它们的搜索路径。
- en: On balance, you will probably find it easier to work with FQCNs throughout your
    code, but the important lesson from this part of the section is that while it
    is best practice to use FQCNs throughout your code, it is by no means mandatory
    at this time, and if you are upgrading to Ansible 4.3, you don't have to go through
    every single playbook you ever wrote and update all the references to modules,
    plugins, and so on. You can do this over time, but it is advisable to do it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，您可能会发现在整个代码中使用FQCN会更容易，但本节的重要教训是，虽然在您的代码中使用FQCN是最佳实践，但目前并不是强制的，如果您正在升级到Ansible
    4.3，您不必逐个更新您曾经编写的所有剧本中对模块、插件等的引用。您可以随时进行这样的操作，但最好是这样做。
- en: Of course, if we review all the changes that have happened in Ansible since
    even the 2.7 release, which the third edition of this book was based on, there
    are many. However, they will only affect certain playbooks as they relate to the
    specific behavior of certain play aspects, or to the way some modules work. Indeed,
    some modules get deprecated and removed as newer releases of Ansible are produced,
    and new ones get added.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们回顾自2.7版发布以来发生的所有Ansible变化，这本书的第三版就是基于这个版本，那么变化是很多的。然而，它们只会影响特定剧本，因为它们涉及特定剧本方面的特定行为，或者某些模块的工作方式。的确，一些模块会因为较新的Ansible版本的发布而被弃用和移除，新的模块会被添加进来。
- en: 'Whenever you are looking to upgrade your Ansible installation, it is advisable
    to review the porting guides that are produced by Ansible for each release since
    2.0\. They can be found here: [https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.html](https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.html).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您想要升级您的Ansible安装时，建议您查看Ansible为每个版本发布的移植指南。它们可以在这里找到：[https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.html](https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.html)。
- en: As for the example we started this chapter off with, you may very well find
    that your code needs no modifications at all. However, it is always best to plan
    your upgrade rather than simply hope for the best, only to hit some unexpected
    behavior that breaks your automation code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 至于我们在本章开始时提到的例子，您可能会发现您的代码根本不需要任何修改。然而，最好是计划升级，而不是简单地希望一切顺利，只是碰到一些意外行为，破坏了您的自动化代码。
- en: It is hoped that this section on playbook porting has shown you how to handle
    the introduction of collections in your playbooks, and given you some pointers
    about where to look for guidance when you upgrade Ansible.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 希望本章关于剧本移植的部分已经向您展示了如何处理在您的剧本中引入集合，并为您提供了一些指引，指出您在升级Ansible时应该寻求指导的地方。
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Since the last release of this book, there have been many changes to Ansible,
    but the most notable (which is expected to impact everyone reading this book)
    is the introduction of collections to manage modules, roles, plugins, and more,
    and decoupling them from the core release of Ansible. Probably the most noticeable
    change to Ansible code is in the introduction of FQCNs and the need to install
    collections if they are not part of the Ansible 4.3 package.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 自本书上次发布以来，Ansible已经发生了许多变化，但最显著的变化（预计会影响到阅读本书的每个人）是引入集合来管理模块、角色、插件等，并将它们与Ansible的核心版本分离。对Ansible代码最明显的变化可能是引入FQCNs以及需要安装集合（如果它们不是Ansible
    4.3包的一部分）。
- en: In this chapter, you learned about the reasons for the introduction of collections
    in Ansible, and how they impact everything from your playbook code to the way
    you install, maintain, and upgrade Ansible itself. You learned that collections
    are easy to build from scratch, and even how to build your own, before looking
    at ways to install and manage collections for your playbook. Finally, you learned
    the fundamentals of porting your Ansible code from earlier releases.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了在Ansible中引入集合的原因，以及它们如何影响从您的剧本代码到您安装、维护和升级Ansible本身的一切。您了解到集合很容易从头开始构建，甚至了解了如何构建自己的集合，然后看看如何为您的剧本安装和管理集合。最后，您学会了将您的Ansible代码从早期版本移植的基础知识。
- en: In the next chapter, you will learn how to secure secret data while working
    with Ansible.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何在使用Ansible时保护秘密数据。
- en: Questions
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Collections can contain:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集合可以包含：
- en: a) Roles
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: a) 角色
- en: b) Modules
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: b) 模块
- en: c) Plugins
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: c) 插件
- en: d) All of the above
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: d) 以上所有
- en: Collections mean that Ansible Module versioning is independent of the version
    of the Ansible engine.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集合意味着Ansible模块的版本与Ansible引擎的版本无关。
- en: a) True
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: a) 真
- en: b) False
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: b) 假
- en: 'The Ansible 4.3 package:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible 4.3包括：
- en: a) includes the Ansible automation engine.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: a) 包括Ansible自动化引擎。
- en: b) has a dependency on the Ansible automation engine.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: b) 依赖于Ansible自动化引擎。
- en: c) bears no relation to the Ansible automation engine.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: c) 与Ansible自动化引擎毫无关系。
- en: It is possible to upgrade directly from Ansible 2.9 to Ansible 4.3.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以直接从Ansible 2.9升级到Ansible 4.3。
- en: a) True
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: a) 真
- en: b) False
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: b) 假
- en: In Ansible 4.3, module names are guaranteed to be unique between different namespaces.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Ansible 4.3中，模块名称在不同的命名空间之间是唯一的。
- en: a) True
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: a) 真
- en: b) False
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: b) 假
- en: To ensure that you always access the correct module you intend, you should start
    using which of the following now in your tasks?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保您始终访问您打算的正确模块，您现在应该开始在您的任务中使用以下哪个？
- en: a) Fully Qualified Domain Names
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: a) 完全合格的域名
- en: b) Short form module names
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: b) 简短的模块名称
- en: c) Fully Qualified Collection Names
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: c) 完全合格的集合名称
- en: d) None of the above
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: d) 以上都不是
- en: Which file can be used to list all the required Collections from Ansible Galaxy,
    ensuring they can easily be installed when needed?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个文件可以用来列出从Ansible Galaxy获取的所有所需集合，以确保在需要时可以轻松安装它们？
- en: a) `site.yml`
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: a) `site.yml`
- en: b) `ansible.cfg`
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: b) `ansible.cfg`
- en: c) `collections.yml`
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: c) `collections.yml`
- en: d) `requirements.yml`
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: d) `requirements.yml`
- en: 'When you create an account on Ansible Galaxy for the purposes of contributing
    your own Collections, your namespace is:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您在Ansible Galaxy上创建帐户以贡献您自己的集合时，您的命名空间是：
- en: a) randomly generated.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: a) 随机生成的。
- en: b) chosen by you.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: b) 由您选择。
- en: c) automatically generated based on your GitHub user ID.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: c) 根据你的GitHub用户ID自动生成。
- en: Collections are stored in which common file format?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集合存储在哪种常见的文件格式中？
- en: a) `.tar.gz`
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: a) `.tar.gz`
- en: b) `.zip`
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: b) `.zip`
- en: c) `.rar`
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: c) `.rar`
- en: d) `.rpm`
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: d) `.rpm`
- en: How could you list all the Collections installed with your Ansible package?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何列出安装在你的Ansible包中的所有集合？
- en: a) `ansible --list-collections`
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: a) `ansible --list-collections`
- en: b) `ansible-doc -l`
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: b) `ansible-doc -l`
- en: c) `ansible-galaxy --list-collections`
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: c) `ansible-galaxy --list-collections`
- en: d) `ansible-galaxy collections list`
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: d) `ansible-galaxy collections list`
