- en: '*Chapter 3*: Protecting Your Secrets with Ansible'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：使用Ansible保护您的机密'
- en: Secrets are meant to stay secret. Whether they are login credentials to a cloud
    service or passwords to database resources, they are secret for a reason. Should
    they fall into the wrong hands, they can be used to discover trade secrets, customers'
    private data, create infrastructure for nefarious purposes, or worse. All of this
    could cost you and your organization a lot of time, money, and headaches! When
    the second edition of this book was published, it was only possible to encrypt
    your sensitive data in external vault files, and all data had to exist entirely
    in either an encrypted or unencrypted form. It was also only possible to use one
    single Vault password per playbook run, meaning it was not possible to segregate
    your secret data and use different passwords for items of different sensitivities.
    All that has now changed, with multiple Vault passwords permissible at playbook
    runtime, as well as the possibility of embedding encrypted strings in otherwise
    plain **YAML Ain't Markup Language** (**YAML**) files.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 机密信息是要保密的。无论是云服务的登录凭据还是数据库资源的密码，它们之所以是机密，是有原因的。如果它们落入错误的手中，它们可以被用来发现商业机密、客户的私人数据、为恶意目的创建基础设施，甚至更糟。所有这些都可能会给您和您的组织带来大量的时间、金钱和头疼！在第二版这本书出版时，只能够将敏感数据加密在外部保险柜文件中，并且所有数据必须完全以加密或未加密的形式存在。每次运行playbook时只能使用一个单一的Vault密码，这意味着无法将您的机密数据分隔开，并为不同敏感性的项目使用不同的密码。现在一切都已经改变，playbook运行时允许使用多个Vault密码，以及在否则普通的**YAML
    Ain't Markup Language**（**YAML**）文件中嵌入加密字符串的可能性。
- en: 'In this chapter, we will describe how to take advantage of these new features,
    and thus keep your secrets safe with Ansible, by covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述如何利用这些新功能，并通过以下主题保持您的机密安全使用Ansible：
- en: Encrypting data at rest
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密数据在静止状态下
- en: Creating and editing encrypted files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和编辑加密文件
- en: Executing `ansible-playbook` with encrypted files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加密文件执行`ansible-playbook`
- en: Mixing encrypted data with plain YAML
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将加密数据与普通YAML混合
- en: Protecting secrets while operating
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在操作时保护机密
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the examples presented in this chapter, you will need a Linux machine
    running **Ansible 4.3** or newer. Almost any flavor of Linux should do—for those
    interested in specifics, all the code presented in this chapter was tested on
    Ubuntu Server 20.04 **Long Term Support** (**LTS**), unless stated otherwise,
    and on Ansible 4.3\. The example code that accompanies this chapter can be downloaded
    from GitHub at this **Uniform Resource Locator** (**URL**): [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter03).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章节中提供的示例，您需要一台运行**Ansible 4.3**或更新版本的Linux机器。几乎任何Linux版本都可以使用——对于那些对细节感兴趣的人，本章中提供的所有代码都是在Ubuntu
    Server 20.04 **长期支持版**（**LTS**）上测试的，除非另有说明，并且在Ansible 4.3上测试。本章附带的示例代码可以从GitHub上下载，**统一资源定位符**（**URL**）为：[https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter03)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2Z4xB42](https://bit.ly/2Z4xB42)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[https://bit.ly/2Z4xB42](https://bit.ly/2Z4xB42)
- en: Encrypting data at rest
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密数据在静止状态下
- en: As a configuration management system or an orchestration engine, Ansible has
    great power. To wield that power, it is necessary to entrust secret data to Ansible.
    An automation system that prompts the operator for passwords at each connection
    is not very efficient —indeed, it's hardly fully automated if you have to sit
    there and type in passwords over and over! To maximize the power of Ansible, secret
    data must be written to a file that Ansible can read and from which it can utilize
    the data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 作为配置管理系统或编排引擎，Ansible具有强大的功能。为了发挥这种力量，有必要将机密数据委托给Ansible。一个每次连接都提示操作员输入密码的自动化系统并不高效——事实上，如果您不得不坐在那里一遍又一遍地输入密码，它几乎不是完全自动化的！为了最大限度地发挥Ansible的功能，机密数据必须被写入一个文件，Ansible可以读取并从中利用数据。
- en: This creates a risk, though! Your secrets are sitting there on your filesystem
    in plaintext. This is a physical as well as a digital risk. Physically, the computer
    could be taken from you and pored over for secret data. Digitally, any malicious
    software that can break the boundaries set upon it is capable of reading any data
    to which your user account has access. If you utilize a source control system,
    the infrastructure that houses the repository is just as much at risk.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做存在风险！您的机密信息以明文形式存储在文件系统中。这是一种物理风险，也是一种数字风险。从物理上讲，计算机可能被夺走，并且被仔细检查以获取机密数据。从数字上讲，任何能够突破其限制的恶意软件都能够读取您的用户帐户可以访问的任何数据。如果您使用源代码控制系统，那么存储库所在的基础设施同样面临风险。
- en: Thankfully, Ansible provides a facility to protect your data at rest. That facility
    is **Vault**. This facility allows for the encryption of text files so that they
    are stored at rest in an encrypted format. Without the key or a significant amount
    of computing power, the data is indecipherable, yet can still be used within Ansible
    plays as easily as unencrypted data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Ansible提供了一种保护数据在静止状态下的方法。这种方法就是**Vault**。这种方法允许对文本文件进行加密，以便它们以加密格式存储在静止状态下。没有密钥或大量的计算能力，数据是无法被破译的，但仍然可以在Ansible
    plays中像未加密数据一样轻松使用。
- en: 'The key lessons to learn when dealing with encrypting data at rest include
    the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据加密时需要学习的关键课程包括以下内容：
- en: Valid encryption targets
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效的加密目标
- en: Securing differing data with multiple passwords and vault **identifiers** (**IDs**)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个密码和保险柜**标识符**（**ID**）保护不同的数据
- en: Creating new encrypted files
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的加密文件
- en: Encrypting existing unencrypted files
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密现有的未加密文件
- en: Editing encrypted files
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑加密文件
- en: Changing the encryption password on files
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改文件的加密密码
- en: Decrypting encrypted files
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密加密文件
- en: Encrypting data inline in an otherwise unencrypted YAML file (for example, a
    playbook)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在未加密的YAML文件中内联加密数据（例如，一个playbook）
- en: Running `ansible-playbook` while referencing encrypted files
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在引用加密文件时运行`ansible-playbook`
- en: Vault IDs and passwords
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vault ID和密码
- en: Before the release of **Ansible 2.4**, it was only possible to use one Vault
    password at a time. While you could have multiple secrets for multiple purposes
    stored in several locations, only one password could be used. This was obviously
    fine for smaller environments, but as the adoption of Ansible has grown, so has
    the requirement for better and more flexible security options. For example, we
    have already discussed the potential for Ansible to manage both a development
    and production environment through the use of groups in the inventory. It is realistic
    to expect that these environments would have different security credentials. Similarly,
    you would expect core network devices to have different credentials from servers.
    In fact, it is a good security practice to do so.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Ansible 2.4**发布之前，一次只能使用一个Vault密码。虽然你可以在多个位置存储多个目的的多个密码，但只能使用一个密码。这对于较小的环境显然是可以接受的，但随着Ansible的采用增加，对更好和更灵活的安全选项的需求也在增加。例如，我们已经讨论过Ansible可以通过清单中的组来管理开发和生产环境。可以预期这些环境将具有不同的安全凭据。同样，你期望核心网络设备具有不同的凭据。事实上，这是一个很好的安全实践。
- en: Given this, it seems unreasonable to then protect any secrets under a single
    master password using Vault. Ansible 2.4 introduced the concept of Vault IDs as
    a solution, and while at present, the old single password commands are all still
    valid, it is recommended to use Vault IDs when working with Ansible on the command
    line. Each Vault ID must have one single password associated with it, but multiple
    secrets can share the same ID.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，使用Vault仅用一个主密码保护任何秘密似乎是不合理的。Ansible 2.4引入了Vault ID的概念作为解决方案，虽然目前旧的单密码命令仍然有效，但建议在命令行上使用Vault
    ID。每个Vault ID必须有一个与之关联的单个密码，但多个秘密可以共享相同的ID。
- en: 'Ansible Vault passwords can come from one of the following three sources:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Vault密码可以来自以下三个来源之一：
- en: A user-entered string, which Ansible will prompt for when it is required
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入的字符串，当需要时Ansible会提示输入
- en: A flat text file containing the Vault password in plain unencrypted text (obviously,
    it is vital this file is kept secure!)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含Vault密码的纯文本文件（显然，这个文件必须保持安全！）
- en: An executable that fetches the password (for example, from a credential management
    system) and outputs it on a single line for Ansible to read
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可执行文件，用于获取密码（例如，从凭证管理系统）并将其输出为Ansible读取的单行
- en: 'The syntax for each of these three options is broadly similar. If you only
    have one vault credential and hence aren''t using IDs (although you could if you
    wanted to, and this is strongly recommended as you might later wish to add a second
    vault ID), you would, therefore, enter the following line of code to run a playbook
    and prompt for the Vault password:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个选项的语法大致相似。如果你只有一个Vault凭证，因此不使用ID（尽管如果你愿意的话，你也可以使用ID，这是强烈推荐的，因为你可能以后希望添加第二个Vault
    ID），那么你将输入以下代码行来运行一个playbook并提示输入Vault密码：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you want to obtain the Vault password from a text file, you would run the
    following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从文本文件中获取Vault密码，你将运行以下命令：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, if you are using an executable script, you would run the following
    command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你使用可执行脚本，你将运行以下命令：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you are working with IDs, simply add the ID in front of the password source,
    followed by the `@` character—if the ID for your vault is `prod`, for example,
    the three preceding examples become the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用ID，只需在密码来源前面添加ID，然后加上`@`字符——例如，如果你的vault的ID是`prod`，那么前面的三个例子变成了以下内容：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Multiple combinations of these can be combined into one command, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以组合成一个命令，如下所示：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will use the `vault-id` command-line options throughout the rest of this
    chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的其余部分中使用`vault-id`命令行选项。
- en: Things Vault can encrypt
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vault可以加密的内容
- en: 'The Vault feature can be used to encrypt any **structured data** used by Ansible.
    This can either be almost any YAML (or **JavaScript Object Notation** (**JSON**))
    file that Ansible uses during its operation or even a single variable within an
    otherwise unencrypted YAML file, such as a playbook or role. Examples of encrypted
    files that Ansible can work with include the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Vault功能可用于加密Ansible使用的任何**结构化数据**。这可以是Ansible在操作过程中使用的几乎任何YAML（或**JavaScript对象表示**（**JSON**））文件，甚至是一个未加密的YAML文件中的单个变量，例如playbook或角色。Ansible可以处理的加密文件的示例包括以下内容：
- en: '`group_vars/` files'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group_vars/`文件'
- en: '`host_vars/` files'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host_vars/`文件'
- en: '`include_vars` targets'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include_vars`目标'
- en: '`vars_files` targets'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vars_files`目标'
- en: '`--extra-vars` targets'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--extra-vars`目标'
- en: Role variables
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色变量
- en: Role defaults
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色默认值
- en: Task files
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务文件
- en: Handler files
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理程序文件
- en: Source files for the `copy` module (these are an exception in this list—they
    don't have to be YAML-formatted)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy`模块的源文件（这些是列表中的一个例外——它们不必是YAML格式的）'
- en: If a file can be expressed in YAML and read by Ansible, or if a file is to be
    transported with the `copy` module, it is a valid file for encryption in Vault.
    Because the entire file will be unreadable at rest, care should be taken to not
    be overzealous in picking which files to encrypt. Any source control operations
    with the files will be done with the encrypted content, making it very difficult
    to peer-review.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个文件可以用YAML表示并且可以被Ansible读取，或者如果一个文件要用`copy`模块传输，那么它就是Vault中加密的有效文件。因为整个文件在休息时都是不可读的，所以在选择要加密的文件时应该小心谨慎。对文件的任何源控制操作都将使用加密内容进行，这将使对文件进行审查变得非常困难。
- en: As a best practice, the smallest possible amount of data should be encrypted,
    which may even mean moving some variables into a file all by themselves. It is
    for this reason that Ansible 2.3 added the `encrypt_string` feature to `ansible-vault`,
    allowing for individual secrets to be placed inline with otherwise unencrypted
    YAML, saving the user from encrypting the entire file. We will cover this later
    in the chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，应该尽可能少地加密数据，这甚至可能意味着将一些变量单独移到一个文件中。正是出于这个原因，Ansible 2.3添加了`encrypt_string`功能到`ansible-vault`，允许将单独的秘密内联放置在否则未加密的YAML中，从而使用户无需加密整个文件。我们将在本章后面介绍这个功能。
- en: Creating and editing encrypted files
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和编辑加密文件
- en: 'To create new files, Ansible provides a program called `ansible-vault`. This
    program is used to create and interact with Vault-encrypted files. The subcommand
    to create encrypted files is `create`, and you can see the options available under
    this subcommand by running the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新文件，Ansible提供了一个名为`ansible-vault`的程序。该程序用于创建和与Vault加密文件交互。创建加密文件的子命令是`create`，您可以通过运行以下命令查看此子命令下可用的选项：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of this command is shown in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出如下截图所示：
- en: '![Figure 3.1 – The options available when creating an Ansible Vault instance'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 - 创建Ansible Vault实例时可用的选项'
- en: '](Images/B17462_03_01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_01.jpg)'
- en: Figure 3.1 – The options available when creating an Ansible Vault instance
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - 创建Ansible Vault实例时可用的选项
- en: To create a new file, you'll need to know two things ahead of time. The first
    is the password `ansible-vault` will be using to encrypt the file, and the second
    is the filename itself. Once provided with this information, `ansible-vault` will
    launch a text editor (as defined in the `EDITOR` environment variable—this defaults
    to `vi` or `vim` in many cases). Once you save the file and exit the editor, `ansible-vault`
    will use the supplied password as a key to encrypt the file with the `AES256`
    cipher.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新文件，您需要提前知道两件事。第一是`ansible-vault`将用于加密文件的密码，第二是文件名本身。提供了这些信息后，`ansible-vault`将启动一个文本编辑器（如在`EDITOR`环境变量中定义的那样
    - 在许多情况下默认为`vi`或`vim`）。保存文件并退出编辑器后，`ansible-vault`将使用提供的密码作为`AES256`密码对文件进行加密。
- en: Let's walk through a few examples of creating encrypted files. First, we'll
    create one and be prompted for a password, then we will provide a `password` file,
    and lastly, we'll create an executable to deliver the password.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个示例来创建加密文件。首先，我们将创建一个并在提示输入密码时进行操作，然后我们将提供一个`password`文件，最后，我们将创建一个可执行文件来提供密码。
- en: Password prompt
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码提示
- en: 'Getting `ansible-vault` to request a password from the user at runtime is the
    easiest way to get started with vault creation, so let''s go through a simple
    example and create a vault containing a variable we want to encrypt. Run the following
    command to create a new vault, and to be prompted for the password:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让`ansible-vault`在运行时从用户那里请求密码是开始创建vault的最简单方法，因此让我们通过一个简单的示例来创建一个包含我们想要加密的变量的vault。运行以下命令创建一个新的vault，并在提示输入密码时：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output should look something like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于这样：
- en: '![Figure 3.2 – Creating a new Ansible Vault instance while being prompted for
    the password'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 - 在提示输入密码时创建一个新的Ansible Vault实例'
- en: '](Images/B17462_03_02.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_02.jpg)'
- en: Figure 3.2 – Creating a new Ansible Vault instance while being prompted for
    the password
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - 在提示输入密码时创建一个新的Ansible Vault实例
- en: 'Once the passphrase is entered, our editor opens and we''re able to put content
    into the file, as shown in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输入密码后，我们的编辑器将打开，我们可以将内容放入文件中，如下截图所示：
- en: '![Figure 3.3 – Adding content to the new Ansible Vault instance using the vim
    editor'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 - 使用vim编辑器向新的Ansible Vault实例添加内容'
- en: '](Images/B17462_03_03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_03.jpg)'
- en: Figure 3.3 – Adding content to the new Ansible Vault instance using the vim
    editor
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 - 使用vim编辑器向新的Ansible Vault实例添加内容
- en: On my system, the configured editor is **Vim**. Your system may be different,
    and you may wish to set your preferred editor as the value for the `EDITOR` environment
    variable if you are not happy with the default selection.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统上，配置的编辑器是**Vim**。您的系统可能不同，如果您对默认选择不满意，可以将您喜欢的编辑器设置为`EDITOR`环境变量的值。
- en: 'Now, we save the file. If we try to read the content using the following command,
    we''ll see that they are in fact encrypted:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们保存文件。如果我们尝试使用以下命令读取内容，我们会发现它们实际上是加密的：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There is just a small header hint for Ansible to use later, as shown in the
    following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个小的头部提示，供Ansible稍后使用，如下截图所示：
- en: '![Figure 3.4 – Showing the content of our new Ansible Vault instance, which
    are encrypted at rest'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 - 显示我们的新Ansible Vault实例的内容，这些内容在静止状态下是加密的'
- en: '](Images/B17462_03_04.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_04.jpg)'
- en: Figure 3.4 – Showing the content of our new Ansible Vault instance, which are
    encrypted at rest
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 - 显示我们的新Ansible Vault实例的内容，这些内容在静止状态下是加密的
- en: As you can see from the headers, `AES256` is used for vault encryption, meaning
    that as long as you use a good password when creating your vault, your data is
    very secure.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从标题中可以看出，`AES256`用于vault加密，这意味着只要您在创建vault时使用了一个好密码，您的数据就非常安全。
- en: Password file
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码文件
- en: 'To use `ansible-vault` with a password file, you first need to create such
    a file. Simply echoing a password into a file can do this. Once complete, you
    can now reference this file when calling `ansible-vault` to create another encrypted
    file. Try this out by running the following commands:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用带有密码文件的`ansible-vault`，您首先需要创建这样一个文件。只需将密码回显到文件中即可。完成后，您现在可以在调用`ansible-vault`创建另一个加密文件时引用此文件。通过运行以下命令来尝试：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This should look something like the output shown in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该看起来像以下截图所示的输出：
- en: '![Figure 3.5 – Creating an Ansible Vault instance using a password file'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 - 使用密码文件创建Ansible Vault实例'
- en: '](Images/B17462_03_05.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_05.jpg)'
- en: Figure 3.5 – Creating an Ansible Vault instance using a password file
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 - 使用密码文件创建Ansible Vault实例
- en: When you run the preceding commands, you will note that you are not prompted
    for a password—this time, the password for the vault is the `my long password`
    string, which has been read from the content of `password_file`. The default editor
    will open, and data can be written just like before after this point, though.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行上述命令时，你会注意到你没有被要求输入密码 - 这次，保险库的密码是`my long password`字符串，它已经从`password_file`的内容中读取。默认编辑器将打开，此时可以像以前一样写入数据。
- en: Password script
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码脚本
- en: 'This last example uses a password script. This is useful for designing a system
    where a password can be stored in a central system for storing credentials and
    shared with contributors to the playbook tree. Each contributor could have their
    own password for the shared credentials store, where the Vault password would
    be retrieved from. Our example will be far more straightforward: just a simple
    output to `STDOUT` with a password. This file will be saved as `password.sh`.
    Create this file now with the following content:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子使用了一个密码脚本。这对于设计一个系统很有用，其中密码可以存储在一个中央系统中，用于存储凭据并与playbook树的贡献者共享。每个贡献者可以有自己的密码用于共享凭据存储，从中检索Vault密码。我们的例子将会简单得多：只是一个简单的输出到`STDOUT`，带有一个密码。这个文件将保存为`password.sh`。现在使用以下内容创建这个文件：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For Ansible to use this script, it must be marked as executable—run the following
    command against it so that it is:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Ansible使用这个脚本，它必须被标记为可执行 - 对它运行以下命令以使其成为可执行文件：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, you can create a new vault secured with the `a long password` as output
    by our simple script, by running the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过运行以下命令创建一个使用`a long password`作为输出的新保险库，这是我们简单脚本的输出：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output from this process should look something like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的输出应该看起来像这样：
- en: '![Figure 3.6 – Creating an Ansible Vault instance using a simple password script'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 - 使用简单密码脚本创建Ansible Vault实例'
- en: '](Images/B17462_03_06.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_06.jpg)'
- en: Figure 3.6 – Creating an Ansible Vault instance using a simple password script
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 - 使用简单密码脚本创建Ansible Vault实例
- en: 'Try this for yourself and see how it works—you should find that `ansible-vault`
    creates a vault with the `a long password` password, as written to `STDOUT` by
    the script. You could even try editing using the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 自己尝试一下，看看它是如何工作的 - 你应该发现`ansible-vault`创建了一个使用`a long password`密码的保险库，正如脚本写入`STDOUT`的那样。你甚至可以尝试使用以下命令进行编辑：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You should now see enter `a long password` when prompted—and you can now edit
    the vault successfully!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示时，现在你应该输入`a long password` - 然后你就可以成功编辑保险库了！
- en: Encrypting existing files
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密现有文件
- en: 'The previous examples all dealt with creating new encrypted files using the
    `create` subcommand. But what if we want to take an established file and encrypt
    it? A subcommand exists for this as well. It is named `encrypt`, and you can see
    the options for this subcommand by running the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子都涉及使用`create`子命令创建新的加密文件。但是如果我们想要获取一个已建立的文件并对其进行加密呢？也存在一个子命令来实现这一点。它被命名为`encrypt`，您可以通过运行以下命令查看此子命令的选项：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output will look similar to that shown in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于下面截图中显示的内容：
- en: '![Figure 3.7 – The options available for the Ansible Vault encrypt subcommand'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 - Ansible Vault encrypt子命令的可用选项'
- en: '](Images/B17462_03_07.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_07.jpg)'
- en: Figure 3.7 – The options available for the Ansible Vault encrypt subcommand
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 - Ansible Vault encrypt子命令的可用选项
- en: As with `create`, `encrypt` expects a `password` (or password file or executable)
    and the path to a file to be encrypted. Once the appropriate password is received,
    an editor opens up, this time with our original content in plaintext already visible
    to us.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与`create`一样，`encrypt`需要一个`password`（或密码文件或可执行文件）和要加密的文件的路径。一旦接收到适当的密码，编辑器就会打开，这次我们的原始内容以明文的形式已经对我们可见。
- en: Note that the file to be encrypted must already exist.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要加密的文件必须已经存在。
- en: 'Let''s demonstrate this by encrypting an existing file we have from [*Chapter
    1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The System Architecture
    and Design of Ansible*, called `Chapter01/example09/a_vars_file.yaml`. Copy this
    file to a convenient location and then encrypt it with the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过加密我们从[*第1章*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015)中得到的现有文件来演示一下，*Ansible的系统架构和设计*，名为`Chapter01/example09/a_vars_file.yaml`。将此文件复制到一个方便的位置，然后使用以下命令对其进行加密：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of this process should look something like that shown in the following
    screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的输出应该类似于下面截图中显示的内容：
- en: '![Figure 3.8 – Encrypting an existing variables file with Ansible Vault'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 - 使用Ansible Vault加密现有变量文件'
- en: '](Images/B17462_03_08.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_08.jpg)'
- en: Figure 3.8 – Encrypting an existing variables file with Ansible Vault
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 - 使用Ansible Vault加密现有变量文件
- en: In this example, we can see the file content before and after the call to `encrypt`,
    whereafter the content are indeed encrypted. Unlike the `create` subcommand, `encrypt`
    can operate on multiple files, making it easy to protect all the important data
    in one action. Simply list all the files to be encrypted, separated by spaces.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以在调用`encrypt`之前和之后看到文件内容，在此之后内容确实被加密了。与`create`子命令不同，`encrypt`可以操作多个文件，轻松地在一个操作中保护所有重要数据。只需列出要加密的所有文件，用空格分隔。
- en: Attempting to encrypt already encrypted files will result in an error.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试加密已加密的文件将导致错误。
- en: Editing encrypted files
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑加密文件
- en: 'Once a file has been encrypted with `ansible-vault`, it cannot be directly
    edited. Opening the file in an editor would result in the encrypted data being
    shown. Making any changes to the file would damage the file, and Ansible would
    be unable to read the content correctly. We need a subcommand that will first
    decrypt the content of a file, allow us to edit those content, and then encrypt
    the new content before saving it back to the file. Such a subcommand exists in
    `edit`, and you can see the options available to you for this subcommand by running
    the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被`ansible-vault`加密，就不能直接编辑。在编辑器中打开文件会显示加密数据。对文件进行任何更改都会损坏文件，Ansible将无法正确读取内容。我们需要一个子命令，首先解密文件的内容，允许我们编辑这些内容，然后在保存回文件之前加密新内容。这样的子命令存在于`edit`中，您可以通过运行以下命令查看此子命令的可用选项：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output should look similar to that shown in the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来类似于以下截图所示的内容：
- en: '![Figure 3.9 – The options available for the edit subcommand of Ansible Vault'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9 – Ansible Vault编辑子命令的可用选项'
- en: '](Images/B17462_03_09.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_09.jpg)'
- en: Figure 3.9 – The options available for the edit subcommand of Ansible Vault
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – Ansible Vault编辑子命令的可用选项
- en: 'As we''ve already seen, our editor will open with our content in plaintext
    visible to us. All of our familiar `vault-id` options are back, as before, as
    well as the file(s) to edit. As such, we can now edit the file we just encrypted
    using the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，我们的编辑器将以明文打开，我们可以看到我们的内容。所有我们熟悉的`vault-id`选项都回来了，以及要编辑的文件。因此，我们现在可以使用以下命令编辑刚刚加密的文件：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice that `ansible-vault` opens our editor with a temporary file as the file
    path. When you save and exit the editor, the temporary file gets written, and
    then `ansible-vault` will encrypt it and move it to replace the original file.
    The following screenshot shows the unencrypted content of our previously encrypted
    vault available for editing:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ansible-vault`使用临时文件作为文件路径打开我们的编辑器。当您保存并退出编辑器时，临时文件将被写入，然后`ansible-vault`将对其进行加密并将其移动以替换原始文件。以下截图显示了我们以前加密的vault的未加密内容可供编辑：
- en: '![Figure 3.10 – Editing our previously encrypted Ansible Vault'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10 – 编辑我们以前加密的Ansible Vault'
- en: '](Images/B17462_03_10.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_10.jpg)'
- en: Figure 3.10 – Editing our previously encrypted Ansible Vault
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 编辑我们以前加密的Ansible Vault
- en: The temporary file you can see in the editor window (`…/tmp6ancaxcu.yaml`) will
    be removed once the file is successfully encrypted by `ansible-vault`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在编辑器窗口中看到的临时文件（`…/tmp6ancaxcu.yaml`）将在`ansible-vault`成功加密文件后被删除。
- en: Password rotation on encrypted files
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密文件的密码轮换
- en: 'Over time, as contributors come and go, it is a good idea to rotate the password
    used to encrypt your secrets. Encryption is only as good as the protection of
    the password. `ansible-vault` provides a `rekey` subcommand that allows us to
    change the password, and you can explore the options available with this subcommand
    by running the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 随着贡献者的进出，定期更改用于加密您的机密的密码是一个好主意。加密的安全性取决于密码的保护程度。`ansible-vault`提供了一个`rekey`子命令，允许我们更改密码，您可以通过运行以下命令探索此子命令的可用选项：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output should look similar to that shown in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来类似于以下截图所示的内容：
- en: '![Figure 3.11 – The options available with the Ansible Vault rekey subcommand'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11 – Ansible Vault重新生成子命令的可用选项'
- en: '](Images/B17462_03_11.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_11.jpg)'
- en: Figure 3.11 – The options available with the Ansible Vault rekey subcommand
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – Ansible Vault重新生成子命令的可用选项
- en: 'The `rekey` subcommand operates much like the `edit` subcommand. It takes in
    an optional password, file, or executable, and one or more files to rekey. You
    then need to use the `--new-vault-id` parameter to define a new password (and
    ID if required), which again can be through a prompt, file, or executable. Let''s
    rekey our `a_vars_file.yaml` file in the following example, and change the ID
    to `dev` by running the following command—for now, we''ll prompt for the new password,
    though we know we can obtain the original password using our password script:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`rekey`子命令的操作方式与`edit`子命令类似。它接受一个可选的密码、文件或可执行文件，以及一个或多个要重新生成的文件。然后，您需要使用`--new-vault-id`参数来定义一个新密码（如果需要，还可以定义ID），同样可以通过提示、文件或可执行文件来定义。让我们通过以下命令重新生成我们的`a_vars_file.yaml`文件，并将ID更改为`dev`，暂时我们将提示输入新密码，尽管我们知道我们可以使用我们的密码脚本获取原始密码：'
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output should look like that shown in the following screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来类似于以下截图所示的内容：
- en: '![Figure 3.12 – Rekeying an existing Ansible Vault and changing the ID at the
    same time'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12 – 重新生成现有的Ansible Vault并同时更改ID'
- en: '](Images/B17462_03_12.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_12.jpg)'
- en: Figure 3.12 – Rekeying an existing Ansible Vault and changing the ID at the
    same time
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 重新生成现有的Ansible Vault并同时更改ID
- en: Remember that all the encrypted files **with the same ID** need to have a matching
    password (or key). Be sure to rekey all the files with the same ID at the same
    time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有具有**相同ID**的加密文件都需要具有匹配的密码（或密钥）。确保同时重新生成具有相同ID的所有文件。
- en: Decrypting encrypted files
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解密加密文件
- en: 'If at some point, the need to encrypt data files goes away, `ansible-vault`
    provides a subcommand that can be used to remove encryption for one or more encrypted
    files. This subcommand is (surprisingly) named `decrypt`, and you can view the
    options for this subcommand by running the following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在某个时候，不再需要加密数据文件，`ansible-vault`提供了一个子命令，可用于删除一个或多个加密文件的加密。这个子命令（令人惊讶地）被命名为`decrypt`，您可以通过运行以下命令查看此子命令的选项：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output should look similar to that shown in the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来类似于以下截图所示的内容：
- en: '![Figure 3.13 – The options available using the decrypt subcommand of Ansible
    Vault'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13 – Ansible Vault解密子命令的可用选项'
- en: '](Images/B17462_03_13.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_13.jpg)'
- en: Figure 3.13 – The options available using the decrypt subcommand of Ansible
    Vault
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – Ansible Vault解密子命令的可用选项
- en: 'Once again, we have our familiar `--vault-id` options, and then one or more
    file paths to decrypt. Let''s decrypt the file we rekeyed just now, by running
    the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们有我们熟悉的`--vault-id`选项，然后是一个或多个要解密的文件路径。让我们通过运行以下命令解密我们刚刚重新生成的文件：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If successful, your decryption process should look something like that shown
    in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，你的解密过程应该看起来像以下截图所示：
- en: '![Figure 3.14 – Decrypting an existing vault'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.14–解密现有保险库'
- en: '](Images/B17462_03_14.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_14.jpg)'
- en: Figure 3.14 – Decrypting an existing vault
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14–解密现有保险库
- en: In the next section, we will see how to execute `ansible-playbook` when referencing
    encrypted files.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何在引用加密文件时执行`ansible-playbook`。
- en: Executing ansible-playbook with encrypted files
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加密文件执行ansible-playbook
- en: To make use of our encrypted content, we first need to be able to inform `ansible-playbook`
    of how to access any encrypted data it might encounter. Unlike `ansible-vault`,
    which exists solely to deal with file encryption or decryption, `ansible-playbook`
    is more general-purpose, and it will not assume it is dealing with encrypted data
    by default. Fortunately, all of our familiar `--vault-id` parameters from the
    previous examples work just the same in `ansible-playbook` as they do in `ansible-vault`.
    Ansible will hold the provided passwords and IDs in memory for the duration of
    the playbook execution.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们的加密内容，我们首先需要告诉`ansible-playbook`如何访问它可能遇到的任何加密数据。与`ansible-vault`不同，后者仅用于处理文件加密或解密，`ansible-playbook`更通用，它不会默认假设它正在处理加密数据。幸运的是，我们在之前示例中熟悉的所有`--vault-id`参数在`ansible-playbook`中的工作方式与在`ansible-vault`中的工作方式完全相同。Ansible将在playbook执行期间将提供的密码和ID保存在内存中。
- en: 'Let''s now create a simple playbook named `show_me.yaml` that will print out
    the value of the variable inside of `a_vars_file.yaml`, which we encrypted in
    a previous example, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个名为`show_me.yaml`的简单playbook，它将打印出我们在之前示例中加密的`a_vars_file.yaml`中变量的值，如下所示：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s run the playbook and see what happens. Note how we use the `--vault-id`
    parameter in exactly the same way as we did with `ansible-vault`; continuity is
    maintained between the two tools, so you are able to apply everything you learned
    earlier in the chapter about using `--vault-id`. If you didn''t already complete
    this step earlier, encrypt your variables file with the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行playbook并看看会发生什么。注意我们如何以与`ansible-vault`完全相同的方式使用`--vault-id`参数；两个工具之间保持连续性，因此你可以应用你在本章早些时候学到的关于使用`--vault-id`的一切。如果你之前没有完成这一步，请使用以下命令加密你的变量文件：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this done, now run the playbook with the following command—note the presence
    of the `--vault-id` parameter, similar to before:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，现在使用以下命令运行playbook—注意`--vault-id`参数的存在，与之前类似：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When you have completed this, your output should look something like that shown
    in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你的输出应该看起来像以下截图所示：
- en: '![Figure 3.15 – Running a simple playbook including an encrypted Ansible Vault
    instance'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.15–运行包含加密的Ansible Vault实例的简单playbook'
- en: '](Images/B17462_03_15.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_15.jpg)'
- en: Figure 3.15 – Running a simple playbook including an encrypted Ansible Vault
    instance
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15–运行包含加密的Ansible Vault实例的简单playbook
- en: As you can see, the playbook runs successfully and prints out the unencrypted
    value of the variable, even though the source variable file we included was an
    encrypted Ansible Vault instance. Naturally, you wouldn't print a secret value
    to the terminal in a real playbook run, but this demonstrates how easy it is to
    access data from a vault.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，playbook成功运行并打印出变量的未加密值，即使我们包含的源变量文件是一个加密的Ansible Vault实例。当然，在真正的playbook运行中，你不会将秘密值打印到终端上，但这演示了从保险库中访问数据有多么容易。
- en: In all our examples so far, we have created vaults as external entities—files
    that live outside of the playbooks themselves. However, it is possible to add
    encrypted vault data to an otherwise unencrypted playbook, which reduces the number
    of files we need to track and edit. Let's have a look at how this is achieved
    in the next section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的所有示例中，我们已经创建了作为外部实体的保险库—这些文件存在于playbook之外。然而，将加密的保险库数据添加到一个否则未加密的playbook中是可能的，这样可以减少我们需要跟踪和编辑的文件数量。让我们看看在下一节中如何实现这一点。
- en: Mixing encrypted data with plain YAML
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合加密数据与普通YAML
- en: 'Before the release of Ansible 2.3, secure data had to be encrypted in a separate
    file. For the reasons we discussed earlier, it is desirable to encrypt as little
    data as possible. This is now possible (and also saves a need for too many individual
    files as part of a playbook) through the use of the `encrypt_string` subcommand
    of `ansible-vault`, which produces an encrypted string that can be placed into
    an Ansible YAML file. Let''s start with the following basic playbook as an example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布Ansible 2.3之前，安全数据必须加密在一个单独的文件中。出于我们之前讨论的原因，希望尽可能少地加密数据。现在通过`ansible-vault`的`encrypt_string`子命令可以实现这一点（并且还可以节省作为playbook一部分的太多个别文件的需要），它会生成一个加密字符串，可以放入Ansible
    YAML文件中。让我们以以下基本playbook作为示例：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can run this code (insecure though it is!) with the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令运行这段代码（尽管不安全！）：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When this playbook runs, the output should look similar to that shown in the
    following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个playbook运行时，输出应该类似于以下截图所示：
- en: '![Figure 3.16 – Running an unencrypted playbook containing sensitive data'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.16–运行包含敏感数据的未加密playbook'
- en: '](Images/B17462_03_16.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_16.jpg)'
- en: Figure 3.16 – Running an unencrypted playbook containing sensitive data
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16–运行包含敏感数据的未加密playbook
- en: 'Now, it obviously isn''t clever to leave a secure password in plaintext like
    this. So, rather than leave it like this, we will encrypt it using the `encrypt_string`
    subcommand of `ansible-vault`. If you want to see the options available to you
    when running this subcommand, you can execute the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，显然不能像这样留下一个安全密码的明文。因此，我们将使用`ansible-vault`的`encrypt_string`子命令对其进行加密。如果您想查看运行此子命令时可用的选项，可以执行以下命令：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of this command should look similar to that shown in the following
    screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出应该与下面截图中显示的类似：
- en: '![Figure 3.17 – The options available for the encrypt_string subcommand of
    Ansible Vault'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.17 – Ansible Vault的encrypt_string子命令的可用选项'
- en: '](Images/B17462_03_17.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_17.jpg)'
- en: Figure 3.17 – The options available for the encrypt_string subcommand of Ansible
    Vault
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 – Ansible Vault的encrypt_string子命令的可用选项
- en: 'So, if we wanted to create an encrypted block of text for our `my_secret` variable
    with the `secure_password` encrypted string, using the `test` Vault ID and the
    `password.sh` script we created earlier for the password, we would run the following
    commands:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想要为我们的`my_secret`变量使用`test` Vault ID和我们之前为密码创建的`password.sh`脚本，创建一个加密的文本块，我们将运行以下命令：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of these commands will give you the encrypted string to include
    in your existing playbook, and an example is shown in the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令的输出将为您提供要包含在现有playbook中的加密字符串，下面的截图中显示了一个示例：
- en: '![Figure 3.18 – Encrypting a variable to a secure string using Ansible Vault'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.18 – 使用Ansible Vault将变量加密为安全字符串'
- en: '](Images/B17462_03_18.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_18.jpg)'
- en: Figure 3.18 – Encrypting a variable to a secure string using Ansible Vault
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 – 使用Ansible Vault将变量加密为安全字符串
- en: 'We can now copy and paste that output into our playbook, ensuring our variable
    is no longer human-readable, as demonstrated in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将该输出复制粘贴到我们的playbook中，确保我们的变量不再是人类可读的，就像下面的截图中演示的那样：
- en: '![Figure 3.19 – Replacing the unencrypted variable with the encrypted string
    data in our existing playbook'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.19 – 在现有的playbook中用加密字符串数据替换未加密的变量'
- en: '](Images/B17462_03_19.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_19.jpg)'
- en: Figure 3.19 – Replacing the unencrypted variable with the encrypted string data
    in our existing playbook
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 – 在现有的playbook中用加密字符串数据替换未加密的变量
- en: 'Even though we have now embedded an Ansible Vault encrypted variable directly
    inside our playbook, we can run this playbook using the appropriate `--vault-id`
    just like we did before—the following command will be used here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在直接在我们的playbook中嵌入了一个Ansible Vault加密的变量，但我们可以像以前一样使用适当的`--vault-id`运行此playbook—下面的命令将在这里使用：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You will observe the playbook running and see that the information can be accessed
    just as any other vault data can, and your output should look like that shown
    in the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您将观察到playbook正在运行，并且可以访问信息，就像任何其他vault数据一样，并且您的输出应该与下面的截图中显示的类似：
- en: '![Figure 3.20 – Running an Ansible playbook containing an encrypted string'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.20 – 运行包含加密字符串的Ansible playbook'
- en: '](Images/B17462_03_20.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_20.jpg)'
- en: Figure 3.20 – Running an Ansible playbook containing an encrypted string
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 – 运行包含加密字符串的Ansible playbook
- en: You can see that the playbook runs exactly as it did the first time we tested
    it when all the data was open for the world to see! Now, however, we have successfully
    mixed our encrypted data with an otherwise unencrypted YAML playbook, all without
    a need to create a separate Vault file.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，当所有数据对世界都是公开的时，playbook的运行方式与我们第一次测试时完全相同！然而，现在，我们已经成功地将加密数据与一个否则未加密的YAML
    playbook混合在一起，而无需创建单独的Vault文件。
- en: In the next section, we will delve deeper into some of the operational aspects
    of running playbooks in conjunction with Ansible Vault.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更深入地探讨与Ansible Vault一起运行playbook的一些操作方面。
- en: Protecting secrets while operating
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在操作时保护秘密
- en: In the previous section of this chapter, we covered how to protect your secrets
    at rest on the filesystem. However, that is not the only concern when operating
    Ansible with secrets. That secret data is going to be used in tasks as module
    arguments, loop inputs, or any number of other things. This may cause the data
    to be transmitted to remote hosts, logged to local or remote log files, or even
    displayed onscreen. This section of the chapter will discuss strategies for protecting
    your secrets during operation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前一节中，我们讨论了如何在文件系统上保护您的秘密。然而，这并不是在操作Ansible与秘密时唯一关注的问题。这些秘密数据将用于任务作为模块参数、循环输入或任何其他事情。这可能导致数据传输到远程主机，记录到本地或远程日志文件，甚至显示在屏幕上。本章的这一部分将讨论在操作过程中保护您的秘密的策略。
- en: Secrets transmitted to remote hosts
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输到远程主机的秘密
- en: As we learned in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015),
    *The System Architecture and Design of Ansible*, Ansible combines module code
    and arguments and writes this out to a temporary directory on the remote host.
    This means your secret data is transferred over the wire *and* written to the
    remote filesystem. Unless you are using a connection plugin other than **Secure
    Shell** (**SSH**) or **Secure Sockets Layer** (**SSL**)-encrypted **Windows Remote
    Management** (**WinRM**), the data over the wire is already encrypted, preventing
    your secrets from being discovered by simple snooping. If you are using a connection
    plugin other than SSH, be aware of whether or not data is encrypted while in transit.
    Using any connection method that is not encrypted is strongly discouraged.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第1章*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015)中所学到的，*Ansible的系统架构和设计*，Ansible将模块代码和参数组合起来，并将其写入远程主机上的临时目录。这意味着您的秘密数据通过网络传输，并写入远程文件系统。除非您使用的是**安全外壳**（**SSH**）或**安全套接字层**（**SSL**）加密的**Windows远程管理**（**WinRM**）之外的连接插件，否则通过网络传输的数据已经加密，防止您的秘密被简单窥视发现。如果您使用的是除SSH之外的连接插件，请注意数据在传输时是否加密。强烈建议使用任何未加密的连接方法。
- en: Once the data is transmitted, Ansible may write this data out in clear form
    to the filesystem. This can happen if pipelining (which we learned about in [*Chapter
    1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The System Architecture
    and Design of Ansible*) is not in use, or if Ansible has been instructed to leave
    remote files in place via the `ANSIBLE_KEEP_REMOTE_FILES` environment variable.
    Without pipelining, Ansible will write out the module code, plus arguments, into
    a temporary directory that is to be deleted immediately after execution. Should
    there be a loss of connectivity between writing out the file and executing it,
    the file will be left on the remote filesystem until manually removed. If Ansible
    is explicitly instructed to keep remote files in place, then even if pipelining
    is enabled, Ansible will write and leave a remote file in place. Care should be
    taken with these options when dealing with highly sensitive secrets, even though
    typically, only the user Ansible authenticates with on the remote host (or becomes
    via privilege escalation) should have access to the leftover file. Simply deleting
    anything in the `~/.ansible/tmp/` path for the remote user will suffice to clean
    secrets.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据传输完成，Ansible 可能会以明文形式将这些数据写入文件系统。如果不使用流水线传输（我们在[*第1章*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015)中了解过，*Ansible的系统架构和设计*），或者如果已经指示Ansible通过`ANSIBLE_KEEP_REMOTE_FILES`环境变量保留远程文件，就会发生这种情况。没有流水线传输，Ansible
    将模块代码和参数写入一个临时目录，该目录将在执行后立即删除。如果在写出文件和执行之间失去连接，文件将保留在远程文件系统上，直到手动删除。如果明确指示Ansible保留远程文件，即使启用了流水线传输，Ansible
    也会写入并保留远程文件。在处理高度敏感机密信息时，应谨慎使用这些选项，尽管通常情况下，只有Ansible在远程主机上进行身份验证的用户（或通过特权升级成为的用户）应该可以访问剩余的文件。简单地删除远程用户的`~/.ansible/tmp/`路径中的任何内容就足以清除机密信息。
- en: Secrets logged to remote or local files
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录到远程或本地文件的机密信息
- en: When Ansible operates on a host, it will attempt to log the action to `syslog`
    (if verbosity level 3 or more is used). If this action is being done by a user
    with appropriate rights, it will cause a message to appear in the `syslog` file
    of the host. This message includes the module name and the arguments passed along
    to that command, which could include your secrets. To prevent this from happening,
    a play-and-task key exists, called `no_log`. Setting `no_log` to `true` will prevent
    Ansible from logging the action to `syslog`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当Ansible 在主机上运行时，它将尝试将操作记录到`syslog`（如果使用了冗长度级别3或更高）。如果这个操作是由具有适当权限的用户执行的，它将导致在主机的`syslog`文件中出现一条消息。此消息包括模块名称和传递给该命令的参数，其中可能包括您的机密信息。为了防止这种情况发生，存在一个名为`no_log`的操作和任务键。将`no_log`设置为`true`将阻止Ansible将操作记录到`syslog`。
- en: Ansible can also be instructed to log its actions locally. This is controlled
    either through `log_path` in the Ansible config file or through an environment
    variable called `ANSIBLE_LOG_PATH`. By default, logging is off and Ansible will
    only log to `STDOUT`. Turning logging on in the `config` file causes Ansible to
    log its activities to the file defined in the `logpath` `config` setting.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 还可以被指示在本地记录其操作。这可以通过Ansible配置文件中的`log_path`或通过名为`ANSIBLE_LOG_PATH`的环境变量来控制。默认情况下，日志记录是关闭的，Ansible
    只会记录到`STDOUT`。在`config`文件中打开日志记录会导致Ansible将其活动记录到`logpath` `config`设置中定义的文件中。
- en: 'Alternatively, setting the `ANSIBLE_LOG_PATH` variable to a path that can be
    written to by the user running `ansible-playbook` will also cause Ansible to log
    actions to this path. The verbosity of this logging matches that of the verbosity
    shown onscreen. By default, no variables or return details are displayed onscreen.
    With a verbosity level of 1 (`-v`), return data is displayed onscreen (and potentially
    in the local log file). With verbosity turned up to level 3 (`-vvv`), the input
    parameters may also be displayed. Since this can include secrets, the `no_log`
    setting applies to the onscreen display as well. Let''s take our previous example
    of displaying an encrypted secret and add a `no_log` key to the task to prevent
    showing its value, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，将`ANSIBLE_LOG_PATH`变量设置为可以被运行`ansible-playbook`的用户写入的路径，也会导致Ansible将操作记录到该路径。此日志的冗长度与屏幕显示的冗长度相匹配。默认情况下，屏幕上不显示任何变量或返回细节。在冗长度级别为1（`-v`）时，返回数据将显示在屏幕上（可能也会显示在本地日志文件中）。将冗长度调到级别3（`-vvv`）时，输入参数也可能会显示。由于这可能包括机密信息，因此`no_log`设置也适用于屏幕显示。让我们以前面显示加密机密信息的示例，并在任务中添加一个`no_log`键，以防止显示其值，如下所示：
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will execute this playbook in the same manner as we have before (but with
    added verbosity, as specified with the `-v` flag) by running the following command—remember
    to encrypt the variables file first if you need to:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与以前相同的方式执行此操作手册（但增加了冗长度，如使用`-v`标志指定的那样），通过运行以下命令来执行——如果需要的话，请记得先加密变量文件：
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We should see that our secret data is protected, even though we deliberately
    attempted to print it using `ansible.builtin.debug`, as shown in the following
    screenshot:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到我们的机密数据受到了保护，即使我们故意尝试使用`ansible.builtin.debug`打印它，如下面的屏幕截图所示：
- en: '![Figure 3.21 – Encrypting a variables file and running a playbook with the
    sensitive data protected'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.21 – 加密变量文件并运行一个保护敏感数据的操作手册'
- en: '](Images/B17462_03_21.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_03_21.jpg)'
- en: Figure 3.21 – Encrypting a variables file and running a playbook with the sensitive
    data protected
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21 – 加密变量文件并运行一个保护敏感数据的操作手册
- en: As you can see, Ansible censored itself to prevent showing sensitive data. The
    `no_log` key can be used as a directive for a play, a role, a block, or a task.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Ansible 对自身进行了审查，以防止显示敏感数据。`no_log` 键可用作指令，用于操作、角色、块或任务。
- en: That concludes our look at operational usage of Ansible Vault, and indeed the
    topic of Ansible Vault—it is hoped that this chapter has proved useful in teaching
    you how to secure your sensitive data when performing automation with Ansible.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对Ansible Vault的操作使用的介绍，也结束了对Ansible Vault主题的讨论——希望本章对教会您如何在使用Ansible进行自动化时保护敏感数据方面是有用的。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered how Ansible can deal with sensitive data effectively
    and securely, harnessing the latest Ansible features, including securing differing
    data with different passwords and mixing encrypted data with plain YAML. We have
    also shown how this data is stored at rest and how this data is treated when utilized,
    and that with a little care and attention, Ansible can keep your secrets secret.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Ansible如何有效且安全地处理敏感数据，利用最新的Ansible功能，包括使用不同密码保护不同数据和将加密数据与普通YAML混合。我们还展示了这些数据在静止状态下的存储方式以及在使用时如何处理这些数据，只要小心谨慎，Ansible就可以保护您的秘密。
- en: You learned how to use the `ansible-vault` tool to protect sensitive data by
    creating, editing, and modifying encrypted files, and the variety of methods available
    for providing the Vault password, including prompting the user, obtaining the
    password from a file, and running a script to retrieve it. You also learned how
    to mix encrypted strings with plain YAML files, and how this simplifies playbook
    layout. Finally, you learned the operational aspects of using Ansible Vault, thus
    preventing Ansible from leaking data to remote log files or onscreen displays.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您学会了如何使用`ansible-vault`工具来保护敏感数据，包括创建、编辑和修改加密文件以及提供Vault密码的各种方法，包括提示用户、从文件获取密码和运行脚本来检索密码。您还学会了如何将加密字符串与普通YAML文件混合，以及这如何简化playbook布局。最后，您学会了使用Ansible
    Vault的操作方面，从而防止Ansible将数据泄漏到远程日志文件或屏幕显示。
- en: In our next chapter, we will explore how the power of Ansible is now available
    for Windows hosts, and how to harness this.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一章中，我们将探讨如何将Ansible的强大功能应用于Windows主机，以及如何利用这一功能。
- en: Questions
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Ansible Vault encrypts your data at rest using which encryption technology?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible Vault使用哪种加密技术在静止状态下加密您的数据？
- en: a) Triple DES/3DES
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: a) 三重DES/3DES
- en: b) MD5
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: b) MD5
- en: c) AES
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: c) AES
- en: d) Twofish
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: d) Twofish
- en: 'Ansible Vault instances must always exist as separate files to the playbook
    itself:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible Vault实例必须始终存在为playbook本身的单独文件：
- en: a) True
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: a) 真
- en: b) False
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: b) 假
- en: 'You can ingest data from more than one Ansible Vault instance when running
    a playbook:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行playbook时，您可以从多个Ansible Vault实例中摄取数据：
- en: a) True
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: a) 真
- en: b) False
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: b) 假
- en: 'When executing a playbook that makes use of Vault-encrypted data, you can provide
    the password:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行使用Vault加密数据的playbook时，您可以提供密码：
- en: a) Interactively at playbook launch
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: a) 在playbook启动时进行交互
- en: b) Using a plaintext file containing just the password
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: b) 使用仅包含密码的明文文件
- en: c) Using a script to retrieve the password from another source
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: c) 使用脚本从另一个来源检索密码
- en: d) All of the above
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: d) 以上所有
- en: 'Ansible will never print vault data to the terminal during a playbook run:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在playbook运行期间，Ansible永远不会将vault数据打印到终端：
- en: a) True
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: a) 真
- en: b) False
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: b) 假
- en: 'You can prevent Ansible from inadvertently printing vault data to the terminal
    during a playbook run using the following task parameter:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下任务参数防止Ansible在playbook运行期间无意中将vault数据打印到终端：
- en: a) `no_print`
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: a) `no_print`
- en: b) `no_vault`
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: b) `no_vault`
- en: c) `no_log`
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: c) `no_log`
- en: 'An interrupted playbook run could leave sensitive unencrypted data on a remote
    host:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中断的playbook运行可能会在远程主机上留下敏感的未加密数据：
- en: a) True
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: a) 真
- en: b) False
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: b) 假
- en: What is used to differentiate different vaults (which may have different passwords)
    at runtime?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行时用于区分不同vault（可能具有不同密码）的是什么？
- en: a) Vault names
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: a) Vault名称
- en: b) Vault IDs
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: b) Vault ID
- en: c) Vault specifiers
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: c) Vault标识符
- en: d) None of the above
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: d) 以上都不是
- en: You can edit an existing encrypted vault using which Ansible command?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用哪个Ansible命令编辑现有的加密vault？
- en: a) `ansible-vault vi`
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: a) `ansible-vault vi`
- en: b) `ansible-vault change`
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: b) `ansible-vault change`
- en: c) `ansible-vault update`
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: c) `ansible-vault update`
- en: d) `ansible-vault edit`
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: d) `ansible-vault edit`
- en: Why might you not want to mix sensitive and non-sensitive data in a vault?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么您可能不希望在vault中混合敏感和非敏感数据？
- en: a) Doing so makes it difficult to run `diff` commands and see changes in a **version
    control system** (**VCS**).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: a) 这样做会使得难以运行`diff`命令并查看**版本控制系统**（**VCS**）中的更改。
- en: b) Only sensitive data is allowed in Ansible Vault.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: b) 只允许在Ansible Vault中放置敏感数据。
- en: c) Ansible Vault has a limited capacity.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: c) Ansible Vault的容量有限。
- en: d) Ansible Vault makes it difficult to access secured data.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: d) Ansible Vault使得访问受保护的数据变得困难。
