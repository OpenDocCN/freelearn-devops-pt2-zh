- en: '*Chapter 13*: Network Automation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：网络自动化'
- en: Historically, a network consisted of mostly hardware with just a modicum of
    software involvement. Changing the topology of it involved installing and configuring
    new switches or blades in a chassis or, at the very least, re-patching some cables.
    Now, the scenario has changed, and the complex infrastructures built to cater
    for multi-tenant environments such as cloud hosting, or microservice-based deployments,
    require a network that is more agile and flexible. This has led to the emergence
    of **Software-Defined Networking** (**SDN**), an approach that centralizes the
    network configuration (where historically it was configured on a per-device basis)
    and results in a network topology being defined as a whole, rather than as a series
    of component parts. It is, if you like, an abstraction layer for the network itself
    and thus implies that just like infrastructure as a service, networks can now
    be defined in code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，网络主要由硬件组成，只有少量软件参与。更改其拓扑结构涉及安装和配置新的交换机或机箱中的刀片，或者至少重新连接一些电缆。现在，情况已经改变，为了满足云托管或基于微服务的部署等多租户环境的复杂基础设施，需要一个更具敏捷性和灵活性的网络。这导致了**软件定义网络**（**SDN**）的出现，这种方法将网络配置集中化（在历史上是在每个设备上配置），并导致网络拓扑被定义为一个整体，而不是一系列组件部分。这可以说是网络本身的抽象层，因此意味着就像基础设施即服务一样，现在可以用代码来定义网络。
- en: Since the previous edition of this book was published, a great deal of work
    has gone into Ansible to enhance and standardize network automation within the
    project. In addition to this, the advent of collections has enabled the modules
    for many network devices to become decoupled from the `ansible-core` package,
    thus enabling network vendors to take greater ownership of their code and release
    them on an as-needed basis, rather than being driven by the cadence of the Ansible
    releases themselves. At the time of writing, only a handful of Ansible collections
    (and thus modules) remain under the remit of the Ansible Network team, with most
    now being maintained directly by the vendors themselves. This is a good thing
    for all concerned, and it ensures greater reliability and more rapid development
    of Ansible's network offering.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自本书上一版出版以来，Ansible已经进行了大量工作，以增强和标准化项目内的网络自动化。除此之外，集合的出现使得许多网络设备的模块能够从`ansible-core`软件包中解耦出来，从而使网络供应商能够更好地拥有他们的代码，并根据需要发布它们，而不是受到Ansible发布节奏的驱动。在撰写本文时，只有少数Ansible集合（因此模块）仍由Ansible网络团队负责，大多数现在直接由供应商自己维护。这对所有相关方都是件好事，并确保了Ansible网络产品的更可靠和更快速的发展。
- en: Ultimately, this means one thing – that you can now define your network infrastructure
    in an Ansible playbook, just as you can describe your compute infrastructure,
    as we described in the previous chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这意味着一件事 - 您现在可以在Ansible playbook中定义您的网络基础设施，就像您可以描述您的计算基础设施一样，就像我们在上一章中描述的那样。
- en: 'In this chapter, we will explore this area of rapidly growing importance by
    covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过以下主题探讨这一迅速增长的重要领域：
- en: Ansible for network management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于网络管理的Ansible
- en: Handling multiple device types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多种设备类型
- en: Working with the `cli_command` module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`cli_command`模块
- en: Configuring Arista EOS switches with Ansible
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible配置Arista EOS交换机
- en: Configuring Cumulus Networks switches with Ansible
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible配置Cumulus Networks交换机
- en: Best practices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the examples presented in this chapter, you will need a Linux machine
    running **Ansible 4.3** or newer. Almost any flavor of Linux should do – for those
    interested in specifics, all the code presented in this chapter was tested on
    **Ubuntu Server 20.04 LTS**, unless stated otherwise, and on Ansible 4.3\. The
    example code that accompanies this chapter can be downloaded from GitHub at this
    URL: [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter13).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中提出的示例，您需要一台运行**Ansible 4.3**或更新版本的Linux机器。几乎任何Linux版本都可以 - 对于那些对具体情况感兴趣的人，本章中提供的所有代码都是在**Ubuntu
    Server 20.04 LTS**上测试的，除非另有说明，并且在Ansible 4.3上进行了测试。本章附带的示例代码可以从GitHub的以下网址下载：[https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter13)。
- en: Check out the following video to see the Code in Action:[https://bit.ly/3G5pNjJ](https://bit.ly/3G5pNjJ).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[https://bit.ly/3G5pNjJ](https://bit.ly/3G5pNjJ)。
- en: Ansible for network management
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于网络管理的Ansible
- en: Core network devices, such as switches, routers, and firewalls, have long had
    management interfaces, especially in enterprise environments. **Command-Line Interfaces**
    (**CLIs**) have always been popular on such devices as they support scripting,
    so, as you have already guessed, they lend themselves extremely well to Ansible
    automation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 核心网络设备，如交换机、路由器和防火墙，在企业环境中一直具有管理接口。**命令行界面**（**CLI**）一直在这些设备上很受欢迎，因为它们支持脚本编写，因此，正如您已经猜到的那样，它们非常适合Ansible自动化。
- en: Historically, teams have faced a myriad of challenges when managing these devices,
    including maintaining configuration, coping with the failure/loss of a device,
    and obtaining support in the event of an issue. Often, companies found themselves
    locked into a single network vendor (or at best, a small handful) to enable the
    use of proprietary tools to manage the network. As with any situation where you
    are locked into a technology, this carries both benefits and drawbacks. Add to
    this the complexity of software-defined networks that are rapidly changing and
    evolving, and the challenge becomes even greater. In this section, we will explore
    how Ansible addresses these challenges.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，团队在管理这些设备时面临着一系列挑战，包括维护配置，应对设备的故障/丢失，并在出现问题时获得支持。通常，公司发现自己被锁定在单一网络供应商（或者说，最多是一小部分供应商）中，以便使用专有工具来管理网络。与任何被技术所束缚的情况一样，这既有好处也有坏处。再加上软件定义网络的复杂性正在迅速变化和发展，挑战变得更加严峻。在本节中，我们将探讨Ansible如何解决这些挑战。
- en: Cross-platform support
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨平台支持
- en: As we have seen throughout this book, Ansible has been designed to make automation
    code portable and reusable in as many scenarios as possible. In [*Chapter 12*](B17462_12_Final_JC_ePub.xhtml#_idTextAnchor224)*,
    Infrastructure Provisioning*, we used almost identical playbooks to configure
    infrastructure on four different providers, and to support this, the examples
    that were given were quite simplistic. Of course, we could have developed this
    further through the use of roles to remove the repetition of so much code if we
    had wished, but the simplicity was deliberate to demonstrate how similar the code
    was, regardless of the provider being used.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书中所看到的，Ansible旨在使自动化代码在尽可能多的场景中可移植和可重用。在[*第12章*]（B17462_12_Final_JC_ePub.xhtml#_idTextAnchor224）*，基础设施配置*中，我们使用了几乎相同的playbook来配置四个不同提供商的基础设施，并且为了支持这一点，所给出的示例相当简单。当然，如果我们愿意，我们可以通过使用角色来进一步开发这一点，以消除如此多的重复代码，但这种简单性是故意的，以演示代码的相似性，无论使用的是哪个提供商。
- en: In short, Ansible made it possible to write playbooks that ran on multiple environments
    to achieve the same thing with minimal effort once we had defined the first one.
    The same is true of networks. The advent of collections means that there is no
    central network module index anymore, as the collections themselves define which
    platforms are supported. However, the *Ansible for Network Automation* page, available
    at [https://docs.ansible.com/ansible/latest/network/index.html](https://docs.ansible.com/ansible/latest/network/index.html),
    is a great place to get started with all the basic concepts as it provides a list
    of many of the supported platforms. However, the list of platforms on this page
    is not complete – for example, later in this chapter, we will look at configuring
    a switch based on the Cumulus Linux platform, and support for this is not explicitly
    listed on the aforementioned page.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Ansible使得编写可以在多个环境中运行的playbook以最小的工作量实现相同的目标成为可能，一旦我们定义了第一个目标。网络也是如此。集合的出现意味着不再有中央网络模块索引，因为集合本身定义了支持哪些平台。然而，*用于网络自动化的Ansible*页面，可在[https://docs.ansible.com/ansible/latest/network/index.html](https://docs.ansible.com/ansible/latest/network/index.html)找到，这是一个很好的起点，因为它提供了许多受支持平台的列表。然而，此页面上的平台列表并不完整-例如，在本章的后面部分，我们将看到如何配置基于Cumulus
    Linux平台的交换机，而该平台的支持并未明确列在前述页面上。
- en: 'Part of the reason for this is that support for Cumulus Linux and a wide array
    of other network technologies are supported by the `Community.Network` collection.
    The list of supported platforms and modules can be found here: [https://docs.ansible.com/ansible/latest/collections/community/network/](https://docs.ansible.com/ansible/latest/collections/community/network/).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 部分原因是Cumulus Linux和其他广泛的网络技术的支持由`Community.Network`集合支持。支持的平台和模块列表可以在这里找到：[https://docs.ansible.com/ansible/latest/collections/community/network/](https://docs.ansible.com/ansible/latest/collections/community/network/)。
- en: As the Ansible documentation is automatically built, decentralizing modules
    into collections has been a little disruptive in areas such as networking, and
    will no doubt improve over time. In the meantime, with a little searching, you
    are sure to find support for your network platform as this support has only been
    expanding as Ansible has developed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ansible文档是自动构建的，将模块分散到集合中在诸如网络等领域有些许颠覆性，并且毫无疑问会随着时间的推移而改进。与此同时，通过一点搜索，您肯定会发现对您的网络平台的支持，因为随着Ansible的发展，这种支持一直在扩大。
- en: The result is that with such a wide (and growing) range of device support, it
    is easy for a network administrator to manage all of their devices from one central
    place, without the need for proprietary tools. However, the benefits are greater
    than just this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，由于有如此广泛（并且不断增长）的设备支持范围，网络管理员可以轻松地从一个中心位置管理所有设备，而无需专有工具。然而，好处不仅仅是这些。
- en: Configuration portability
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置可移植性
- en: As we have discussed already, Ansible code is highly portable. In the world
    of network automation, this is extremely valuable. To start with, it means that
    you could roll out a configuration change on a development network (or simulator)
    and test it, and then be able to roll out the same code against a different inventory
    (for example, a production one) once the configuration has been deemed to have
    been tested successfully.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们已经讨论过的，Ansible代码具有很高的可移植性。在网络自动化领域，这是非常有价值的。首先，这意味着您可以在开发网络（或模拟器）上推出配置更改并进行测试，然后一旦配置被认为已经成功测试，就可以对不同的清单（例如生产清单）使用相同的代码进行配置更改。 '
- en: The benefits don't stop there, however. Historically, in the event of issues
    with a software upgrade or configuration change, the network engineer's challenge
    was to engage the vendor for support and assistance successfully. This required
    sending sufficient detail to the vendor to enable them to at least understand
    the problem and most likely want to reproduce it (especially in the case of firmware
    issues). When the configuration for a network is defined in Ansible, the playbooks
    themselves can be sent to the vendor to enable them to quickly and accurately
    understand the network topology and diagnose the issue. I have come across cases
    where network vendors are now starting to insist on Ansible playbooks containing
    network configuration when a support ticket is raised. This is because it empowers
    them to resolve the issue faster than ever before.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，好处并不止于此。在软件升级或配置更改出现问题时，网络工程师的挑战是成功地与供应商联系寻求支持和帮助。这需要向供应商发送足够的细节，以使他们至少能够理解问题，并且很可能想要重现它（特别是在固件问题的情况下）。当网络的配置在Ansible中定义时，playbooks本身可以发送给供应商，使他们能够快速准确地理解网络拓扑并诊断问题。我遇到过一些情况，网络供应商现在开始坚持要求在提出支持票时包含网络配置的Ansible
    playbooks。这是因为这使他们能够比以往更快地解决问题。
- en: Effective use of **Ansible Vault** ensures that sensitive data is kept out of
    the main playbooks, which means it can easily be removed before being sent to
    a third party (and even if it was sent accidentally, it wouldn't be readable as
    it is encrypted at rest).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有效使用**Ansible Vault**确保敏感数据不会出现在主要playbooks中，这意味着可以在发送给第三方之前轻松删除它（即使它被意外发送，也不会被读取，因为它在静止状态下是加密的）。
- en: Backup, restore, and version control
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备份，恢复和版本控制
- en: Although most businesses have robust change control procedures, there is no
    guarantee that these are followed 100% of the time, and human beings have been known
    to tweak configurations without accurately recording the changes they've made.
    Moving the network configuration to Ansible removes this issue, as the configuration
    is a known state defined by the playbooks that can be compared easily to the running
    configuration using a `check` run.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数企业都有健全的变更控制程序，但并不能保证这些程序100%遵守，人类已经知道在不准确记录所做更改的情况下调整配置。将网络配置移至Ansible可以消除这个问题，因为配置是由playbooks定义的已知状态，可以轻松地使用`check`运行与运行配置进行比较。
- en: Not only is this possible, but configurations can be backed up and restored
    with ease. Say, for example, a switch fails and has to be replaced. If the replacement
    is of the same type, it can be configured and brought into service rapidly by
    running the same Ansible playbooks that configured its predecessor, with the playbook
    run perhaps limited to just the replacement switch inventory host if appropriate
    – though Ansible's idempotent nature means that running it across the entire network
    should be benign.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，配置也可以轻松地进行备份和恢复。例如，如果交换机故障并且需要更换，如果更换的是相同类型的交换机，可以通过运行与配置其前身相同的Ansible
    playbooks快速配置并投入使用，如果适当的话，playbook运行可能仅限于替换交换机的清单主机 - 尽管Ansible的幂等性意味着在整个网络上运行它应该是无害的。
- en: This lends itself to version control too – network configuration playbooks can
    be pushed to a source control repository, enabling configuration versions to be
    tracked, and differences over time to easily be examined.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于版本控制 - 网络配置playbooks可以推送到源代码控制存储库，从而可以跟踪配置版本，并轻松检查随时间的差异。
- en: Automated change requests
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动变更请求
- en: Often, minor changes to a network might be required to roll out a new project
    – perhaps a new VLAN or VXLAN, or some previously unused ports that have been
    brought into the service. The configuration parameters will be well-defined by
    a change request and/or network design, and it is probably not the best use of
    a highly qualified network engineer to be making simple configuration changes.
    Tasks such as these are typically routine, in that the configuration changes can
    be templated in an Ansible playbook, with variables passed to it that have been defined
    by the change request (for example, port numbers and VLAN membership details).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可能需要对网络进行微小更改以推出新项目 - 也许是新的VLAN或VXLAN，或者一些以前未使用的端口已被引入服务。配置参数将由变更请求和/或网络设计明确定，可能并不是高素质网络工程师最好的选择来进行简单的配置更改。这些任务通常是例行公事，因为配置更改可以在Ansible
    playbook中进行模板化，传递给它的变量已经由变更请求定义（例如，端口号和VLAN成员资格详情）。
- en: This then frees up the engineers' time for more important work, such as designing
    new architectures, and new product research and testing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就可以为工程师节省更多重要工作的时间，例如设计新架构，新产品研究和测试。
- en: Coupled with the use of a package such as AWX or Ansible Tower (as we discussed
    earlier in this book), simple and well-tested changes could be completely automated
    or passed to a frontline team to be executed safely by simply passing in the required
    parameters. In this way, the risk of human error is significantly reduced, regardless
    of the skillset of the person performing the change.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 结合使用AWX或Ansible Tower等软件包（正如我们在本书中早期讨论的那样），简单而经过充分测试的更改可以完全自动化，或者通过简单传递所需的参数传递给一线团队来安全执行。通过这种方式，无论执行更改的人的技能水平如何，人为错误的风险都会大大降低。
- en: With these benefits well established and understood, let's look at how we might
    start writing playbooks to handle a multi-device network.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些好处得到了很好的建立和理解，让我们看看如何开始编写playbooks来处理多设备网络。
- en: Handling multiple device types
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理多种设备类型
- en: In a world where we are not locked into a single vendor, it is important to
    know how we might handle the different network devices in an infrastructure. We
    established in the previous chapter that for different infrastructure providers,
    a similar process was established for each one in terms of getting Ansible to
    interact with it. This can be a little different with switches as not all command-line
    switch interfaces are created the same. Some, such as on a Cumulus Networks switch,
    can make use of straightforward SSH connectivity, meaning that everything we have
    learned about in this book so far on connecting to an SSH-capable device still
    applies.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个我们不被锁定在单一供应商的世界中，了解如何处理基础设施中的不同网络设备是很重要的。我们在前一章中已经确定，对于不同的基础设施提供商，已经建立了与Ansible交互的类似流程。这在交换机上可能会有所不同，因为并非所有命令行交换机接口都是相同的。例如，在Cumulus
    Networks交换机上，可以利用直接的SSH连接，这意味着到目前为止我们在本书中学到的关于连接到支持SSH的设备的一切仍然适用。
- en: However, other devices, such as F5 BIG-IP, do not use such an interface and
    therefore require the module to be run from the Ansible host. The configuration
    parameters must be passed to the module directly as opposed to using simple connection-related
    host variables such as `ansible_user`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其他设备，比如F5 BIG-IP，不使用这样的接口，因此需要从Ansible主机上运行模块。配置参数必须直接传递给模块，而不是使用简单的与连接相关的主机变量，比如`ansible_user`。
- en: There is, of course, a gray area in the middle of this discussion. Some devices,
    such as an Arista EOS or Cisco IOS-based device will be SSH managed, so you could
    be mistaken for thinking you can connect to them using a straightforward SSH connection
    as if they were any other Linux host. However, this is not the case – if we reflect
    on [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The* *System
    Architecture and Design of Ansible*, we learned that for Ansible to automate commands
    over SSH, it sends over a tiny chunk of Python code to the remote host for execution
    (or PowerShell, in the case of Windows hosts). Most switches, while having an
    SSH-based user interface, cannot be expected to have a Python environment present
    on them, so this mode of operation is not possible (Cumulus Linux is the exception
    here since it features a usable Python environment). As a result, devices such
    as the Arista EOS and Cisco IOS ones historically used to use local execution,
    whereby the Ansible code is run on the control node itself, and then the automation
    requests are translated into the appropriate CLI (or API) calls and passed directly
    to the device. Thus, no remote Python environment is required.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这个讨论中还存在一个灰色地带。一些设备，比如Arista EOS或基于Cisco IOS的设备，将由SSH管理，因此你可能会误以为可以像连接其他Linux主机一样直接使用SSH连接到它们。然而，事实并非如此——如果我们回顾[*第1章*]《Ansible的系统架构和设计》，我们了解到，为了让Ansible能够通过SSH自动化命令，它会发送一小段Python代码到远程主机进行执行（或者在Windows主机的情况下是PowerShell）。大多数交换机虽然有基于SSH的用户界面，但不能指望在其上有Python环境，因此这种操作模式是不可能的（Cumulus
    Linux是个例外，因为它具有可用的Python环境）。因此，像Arista EOS和Cisco IOS这样的设备在历史上使用本地执行，即Ansible代码在控制节点上运行，然后自动化请求被转换为适当的CLI（或API）调用并直接传递给设备。因此，不需要远程Python环境。
- en: 'You will find many historical examples that make use of this mode of operation,
    and they can easily be identified as they will have the following line somewhere
    in the play definition:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现许多历史示例使用了这种操作模式，并且它们很容易被识别，因为在play定义中会有以下行：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Possibly, this might also be defined as an inventory variable:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还可以将其定义为清单变量：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Regardless of how this happens, the local connection mode of operation has been
    deprecated, and while most legacy networking playbooks that utilize this connection
    mode will still run today, it is anticipated that support for this will be dropped
    next year.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，本地连接模式的操作已经被弃用，虽然大多数使用这种连接模式的传统网络playbook今天仍然可以运行，但预计明年将停止支持这种模式。
- en: 'Where possible, users are encouraged to use one of the following communication
    protocols instead:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，鼓励用户使用以下通信协议之一：
- en: '`ansible.netcommon.network_cli`: This protocol translates play tasks into CLI
    commands over SSH.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible.netcommon.network_cli`：这种协议将play任务转换为通过SSH的CLI命令。'
- en: '`ansible.netcommon.netconf`: This protocol translates play tasks into XML data
    sent over SSH to the device for configuration by `netconf`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible.netcommon.netconf`：这种协议将play任务转换为通过SSH发送到设备的XML数据，以便由`netconf`进行配置。'
- en: '`ansible.netcommon.httpapi`: This protocol talks to network devices using an
    HTTP or HTTPS-based API.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible.netcommon.httpapi`：这种协议使用基于HTTP或HTTPS的API与网络设备通信。'
- en: The three preceding communication protocols are all persistent – that is to
    say, they don't need to set up and tear down network connections for each task
    – the local connection method does not support this, so it is significantly less
    efficient than these modes. Of the preceding list, `ansible.netcommon.network_cli`
    is the most common you will come across, and we will look at this in the next
    section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面三种通信协议都是持久的——也就是说，它们不需要为每个任务建立和拆除网络连接——而本地连接方法不支持这一点，因此比这些模式要低效得多。在前面的列表中，`ansible.netcommon.network_cli`是你可能会遇到的最常见的，我们将在下一节中讨论这个问题。
- en: It is not expected that many of you will have access to a wide variety of network
    hardware to use in the examples in this chapter. Later, we will look at two examples
    that are freely available to download (at the time of writing, subject to you
    sharing a little personal information) that you can try out if you wish. For now,
    though, we will go into more detail on the process to be employed when automating
    a new network device for the first time so that you know to apply this to a situation
    and preferred network vendor.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望你们中的许多人能够访问各种各样的网络硬件来在本章的示例中使用。稍后，我们将看两个示例，这些示例可以免费下载（在撰写本文时，取决于您是否愿意分享一些个人信息），如果您愿意，您可以尝试。不过，现在，我们将更详细地介绍首次自动化新网络设备时要采用的流程，以便您知道如何将其应用到特定情况和首选网络供应商。
- en: Researching your modules
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 研究您的模块
- en: 'Your first task when working with any networking device is to understand what
    module you need to use with Ansible. This will involve two things:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何网络设备一起工作时的第一个任务是了解您需要使用哪个模块与Ansible一起使用。这将涉及两件事：
- en: What device do you wish to automate the management of?
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望自动管理哪个设备？
- en: What task(s) do you wish to perform on the device?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望在设备上执行什么任务？
- en: Armed with this information, you can search the Ansible documentation site and
    Ansible Galaxy to find out if your devices and desired tasks are supported. Let's
    say, for example, that you have an F5 BIG-IP device, and you want to save and
    load configuration on this device.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，您可以搜索Ansible文档站点和Ansible Galaxy，以了解您的设备和所需任务是否受支持。比如，例如，您有一个F5 BIG-IP设备，并且您想在该设备上保存和加载配置。
- en: A quick scan of the available collections on Ansible Galaxy suggests we should
    look at the `f5networks.f5_modules` collection ([https://galaxy.ansible.com/f5networks/f5_modules](https://galaxy.ansible.com/f5networks/f5_modules)),
    and that from this, we should look into the `f5networks.f5_modules.bigip_config` module,
    which will do just what we need. Thus, we can proceed with the module configuration
    (see the next section) and then write the desired playbook around this module.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 快速扫描Ansible Galaxy上可用集合的建议是我们应该查看`f5networks.f5_modules`集合（[https://galaxy.ansible.com/f5networks/f5_modules](https://galaxy.ansible.com/f5networks/f5_modules)），并且从中，我们应该查看`f5networks.f5_modules.bigip_config`模块，这将满足我们的需求。因此，我们可以继续进行模块配置（请参阅下一节），然后围绕此模块编写所需的playbook。
- en: What happens if there is no module for your device, though? In this instance,
    you have two choices. Firstly, you could write a new module for Ansible to perform
    the tasks you require. This is something you could contribute back to the community,
    and [*Chapter 10*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183), *Extending
    Ansible*, contains all the details you need to get started on this task.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您的设备没有模块会发生什么呢？在这种情况下，您有两种选择。首先，您可以编写一个新的模块，以便Ansible执行您需要的任务。这是您可以为社区做出贡献的事情，[*第10章*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183)，*扩展Ansible*，包含了您开始这项任务所需的所有细节。
- en: Alternatively, if you want to get something up and running quickly, remember
    that Ansible can send raw commands in most of the transport methods it supports.
    For example, in the author's lab setup, they have a TP-Link managed switch. There
    are no native Ansible modules that support this particular switch – however, as
    well as a web-based GUI, this switch also has an SSH management interface. If
    I wanted to quickly get something up and running, I could use Ansible's `ansible.builtin.raw`
    module to send raw commands over SSH to the switch. Naturally, this solution lacks
    elegance and makes it difficult to write playbooks that are idempotent, but it
    does enable me to get up and running quickly with Ansible and this device.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您想快速启动某些东西，请记住Ansible可以在大多数支持的传输方法中发送原始命令。例如，在作者的实验室设置中，他们有一个TP-Link托管交换机。没有原生的Ansible模块支持这个特定的交换机
    - 但是，除了基于Web的GUI之外，这个交换机还有一个SSH管理接口。如果我想快速启动某些东西，我可以使用Ansible的`ansible.builtin.raw`模块通过SSH发送原始命令到交换机。当然，这种解决方案缺乏优雅性，并且很难编写幂等的playbook，但它确实使我能够快速使用Ansible和这个设备。
- en: This captures the beauty of Ansible – the ease with which new devices can be
    managed, and how, with just a little ingenuity, it can be extended for the benefit
    of the community.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这捕捉了Ansible的美丽之处 - 新设备可以轻松管理，而且只需稍加巧思，就可以为社区的利益进行扩展。
- en: Configuring your modules
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置您的模块
- en: As we have already demonstrated the use of the `ansible.builtin.raw` module,
    as well as extending Ansible, earlier in this book, we will proceed with the case
    where we have found a module we want to work with. As you may have noticed in
    some of the earlier chapters in this book, although Ansible includes many modules
    out of the box, not all of them work straight away.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书的前面已经演示了`ansible.builtin.raw`模块的使用以及扩展Ansible，我们将继续处理我们找到了一个想要使用的模块的情况。正如您可能已经在本书的一些早期章节中注意到的那样，尽管Ansible包含了许多模块，但并非所有模块都可以立即使用。
- en: Ansible is written in Python and, in most cases, where there are dependencies,
    there will be Python modules. The important thing is to review the documentation.
    For example, take the `f5networks.f5_modules.bigip_config` module we selected
    in the previous section. A quick review of the *Requirements* section of the documentation
    shows that this requires (at the time of writing) the `ipaddress` Python module
    if you are running a Python version older than 3.5.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是用Python编写的，在大多数情况下，如果有依赖关系，就会有Python模块。重要的是要查看文档。例如，我们在前一节中选择的`f5networks.f5_modules.bigip_config`模块。快速查看文档的*Requirements*部分显示，如果您使用的是旧于3.5版本的Python，则需要（在撰写本文时）`ipaddress`
    Python模块。
- en: 'If you are not running Python 3.5 or later, you will need to install this for
    the collection''s modules to function correctly. There are multiple ways to install
    this – some operating systems may have a native package built, and if this is
    available, then provided it meets the version requirements, it is perfectly fine
    to use this. This may be advantageous in terms of vendor support. However, if
    such a package is not available, Python modules can easily be installed using
    the `pip` (or `pip3`) tool. Assuming this is already on your system, the installation
    is as simple as using the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有运行Python 3.5或更高版本，则需要安装此版本以使集合的模块正常运行。有多种安装方法——一些操作系统可能内置了一个本地包，如果可用并且满足版本要求，那么使用它是完全可以的。这可能在供应商支持方面具有优势。但是，如果没有这样的软件包可用，Python模块可以很容易地使用`pip`（或`pip3`）工具进行安装。假设这已经在您的系统上，安装就像使用以下代码一样简单：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Also, be sure to review the *Notes* section of the documentation (for the module
    we are currently discussing, go to [https://clouddocs.f5.com/products/orchestration/ansible/devel/modules/bigip_config_module.html#notes](https://clouddocs.f5.com/products/orchestration/ansible/devel/modules/bigip_config_module.html#notes)).
    Continuing with this example, we can see that it only supports BIG-IP software
    version 12 and newer, so if you are on an earlier version, you will have to find
    another route to automate your device (or upgrade the software if this is an acceptable
    path).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保查看文档的*Notes*部分（对于我们当前讨论的模块，请转到[https://clouddocs.f5.com/products/orchestration/ansible/devel/modules/bigip_config_module.html#notes](https://clouddocs.f5.com/products/orchestration/ansible/devel/modules/bigip_config_module.html#notes)）。继续这个例子，我们可以看到它只支持BIG-IP软件版本12及更高版本，因此，如果您使用的是早期版本，您将不得不找到另一种自动化设备的方法（或者如果这是可接受的路径，则升级软件）。
- en: Writing your playbooks
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写您的playbooks
- en: 'Once your modules have been configured and all the requirements (be they Python
    module dependencies or device software ones) have been met, it''s time to start
    writing your playbook. This should be a simple task of following the documentation
    for the module. Let''s suppose we want to reset the configuration on an **F5 BIG-IP**
    device. From the documentation, we can see that authentication parameters are
    passed to the module itself. Also, the example code shows the use of the `delegate_to` task
    keyword; both of these clues tell us that the module is not using the native SSH
    transport of Ansible, but rather one that is defined in the module itself. Thus,
    a playbook to reset the configuration of a single device might look something
    like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的模块已经配置好，并且满足了所有要求（无论是Python模块依赖项还是设备软件要求），就该开始编写您的playbook了。这应该是一个简单的任务，只需按照模块的文档进行。假设我们想要重置**F5
    BIG-IP**设备上的配置。从文档中，我们可以看到认证参数是传递给模块本身的。此外，示例代码显示了`delegate_to`任务关键字的使用；这两个线索告诉我们，该模块并没有使用Ansible的本地SSH传输，而是使用了模块本身定义的传输。因此，重置单个设备配置的playbook可能如下所示：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, we are using a textbook example from the documentation to reset
    our configuration. Note that as our `hosts` parameter only defines `localhost`,
    we do not need the `delegate_to` keyword, since the `f5networks.f5_modules.bigip_config`
    module will only be run from `localhost` in this playbook.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在使用文档中的一个经典示例来重置我们的配置。请注意，由于我们的`hosts`参数只定义了`localhost`，所以我们不需要`delegate_to`关键字，因为在这个playbook中，`f5networks.f5_modules.bigip_config`模块只会从`localhost`运行。
- en: 'In this way, we have automated a simple, but otherwise manual and repetitive,
    task that might need to be performed. Running the playbook would be as simple
    as executing the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经自动化了一个简单的、但否则需要手动和重复执行的任务。运行playbook就像执行以下命令一样简单：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Naturally, to test this playbook, you would have to have an F5 BIG-IP device
    to test against. Not everyone will have this available, so, later in this chapter,
    we will move on to demonstrate real-world examples that everyone reading this
    book can work with. However, this part of this chapter is intended to give you
    a solid overview of integrating your network devices, whatever they may be, with
    Ansible. Thus, it is hoped that even if you have a device that we haven't mentioned
    here, you understand the fundamentals of how to get it working.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要测试这个playbook，您需要有一个F5 BIG-IP设备进行测试。并非每个人都有这个设备，因此，在本章的后面，我们将继续演示每个读者都可以使用的真实示例。然而，本章的这一部分旨在为您提供一个关于如何将您的网络设备与Ansible集成的坚实概述。因此，希望即使您有一个我们在这里没有提到的设备，您也能理解如何使其工作的基本原理。
- en: Working with the cli_command module
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cli_command模块
- en: Before we get to the practical hands-on examples, we must look at a module that
    has become central to network device configuration since the previous edition
    of this book was published.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实际的实例之前，我们必须看一下自从上一版书籍出版以来已经成为网络设备配置中心的模块。
- en: 'As we discussed in the preceding section, most network devices cannot be expected
    to have a working Python environment on them, and as such, Ansible will use local
    execution – that is to say, all tasks related to network devices are executed
    on the Ansible control node itself, translated into the correct format for the
    device to receive (be that a CLI, an HTTP-based API, or otherwise), and then sent
    over the network to the device. Ansible 2.7 relied mostly on a communication protocol
    known as `local` for network device automation. This worked well but suffered
    from several drawbacks, including the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中讨论的，大多数网络设备不能指望在其上有一个可用的Python环境，因此，Ansible将使用本地执行——也就是说，与网络设备相关的所有任务都在Ansible控制节点上执行，转换为设备接收的正确格式（无论是CLI、基于HTTP的API还是其他格式），然后通过网络发送到设备。Ansible
    2.7主要依赖于一个名为`local`的通信协议进行网络设备自动化。这样做效果很好，但也存在一些缺点，包括以下几点：
- en: The `local` protocol does not support persistent network connections – a new
    connection needs to be set up and then torn down for each task that's executed.
    This is hugely inefficient and slow, and not in line with the original vision
    for Ansible at all.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local`协议不支持持久的网络连接 - 需要为执行的每个任务建立一个新连接，然后将其拆除。这是极其低效和缓慢的，与Ansible最初的愿景完全不符。'
- en: Each module was responsible for its own communication protocol, so the library
    requirements for each module were often different, and code was not being shared.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个模块负责自己的通信协议，因此每个模块的库要求通常是不同的，代码也没有被共享。
- en: There was little commonality in the manner in which credentials could be provided
    for network device communication, and credentials had to be provided in each task,
    again resulting in inefficient code.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提供网络设备通信的方式上几乎没有共同点，并且必须在每个任务中提供凭据，这再次导致了低效的代码。
- en: As a result of these issues, the `local` protocol is expected to be dropped
    from Ansible within the next year, and you are encouraged to start using one of
    the three new protocols listed in the *Handling multiple device types* section,
    earlier in this chapter. Of these, the most common is the `ansible.netcommon.network_cli`
    protocol, which can be used to connect to a great deal of the network devices
    you may wish to automate with Ansible – you can see how common the use of this
    module is for network device configuration by looking at the table provided at
    [https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#settings-by-platform](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#settings-by-platform).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些问题，预计“local”协议将在未来一年内从Ansible中删除，并鼓励您开始使用本章前面列出的三种新协议中的一种*处理多种设备类型*。其中，最常见的是`ansible.netcommon.network_cli`协议，它可以用于连接到您可能希望使用Ansible自动化的许多网络设备
    - 您可以通过查看提供的表格来看到此模块用于网络设备配置的普遍程度[https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#settings-by-platform](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#settings-by-platform)。
- en: The beauty of this protocol is that authentication parameters can now be set
    in the inventory, just like they can for any other operating system, simplifying
    playbooks and removing the need for repetitive credentials being set. Persistent
    connections are also supported, meaning a much faster automation run. So, how
    does it work?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种协议的美妙之处在于现在可以在清单中设置认证参数，就像对任何其他操作系统一样，简化了操作手册并消除了设置重复凭据的需要。还支持持久连接，意味着自动化运行速度更快。那么，它是如何工作的呢？
- en: 'Well, let''s suppose we have a Cisco IOS-based network device to configure.
    We could define a simple inventory file that looks like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，假设我们有一个要配置的基于Cisco IOS的网络设备。我们可以定义一个看起来像这样的简单清单文件：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice how easy that is? We set the same `ansible_user`, `ansible_password`,
    and `ansible_become` inventory variables that we have already seen throughout
    the examples in this book. However, we have added the `ansible_connection` variable
    here, which tells Ansible to make use of the `ansible.netcommon.network_cli` protocol.
    Of course, this is only half of the story – this protocol tells Ansible to send
    CLI commands over SSH but doesn't tell Ansible what device type is on the other
    end of the connection. As all CLIs are different in some way, this matters, so
    we use `ansible_network_os` to tell Ansible what type of device it's talking to
    so that it can speak the right CLI language to the device.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这是多么容易？我们设置了与本书中的示例中已经看到的相同的`ansible_user`，`ansible_password`和`ansible_become`清单变量。但是，我们在这里添加了`ansible_connection`变量，它告诉Ansible使用`ansible.netcommon.network_cli`协议。当然，这只是故事的一半
    - 这个协议告诉Ansible通过SSH发送CLI命令，但并没有告诉Ansible连接的另一端是什么类型的设备。由于所有的CLI在某种程度上都是不同的，这很重要，因此我们使用`ansible_network_os`告诉Ansible它正在与什么类型的设备交流，以便它可以向设备说出正确的CLI语言。
- en: Finally, we need to change the `ansible_become` method – on Linux, this would
    almost certainly be `sudo`, but on an IOS switch, it is `enable`. We also need
    to provide the password for the elevation of rights, just as you would if you
    had `sudo` configured to require a password.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更改`ansible_become`方法 - 在Linux上，这几乎肯定是`sudo`，但在IOS交换机上，它是`enable`。我们还需要提供权限提升的密码，就像如果您配置了需要密码的`sudo`一样。
- en: 'That''s as complex as it gets – a simple playbook that makes use of this inventory
    and its assigned variables might look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的复杂性 - 使用这个清单及其分配的变量的简单操作手册可能如下所示：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice how easy that is – we can now write playbooks in the same manner as
    when we work with Linux or Windows hosts. Of course, each networking platform
    has subtle differences, and the platform-specific options for a myriad of supported
    devices can be found here: [https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这是多么容易 - 现在我们可以以与处理Linux或Windows主机相同的方式编写操作手册。当然，每个网络平台都有微妙的差异，并且可以在此找到支持的各种设备的特定于平台的选项：[https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html)。
- en: 'The other great thing about using the `ansible.netcommon.network_cli` protocol
    is that it supports the `ansible_ssh_common_args` inventory variable, just as
    any other SSH managed host (Linux or Windows with OpenSSH) would. This is important
    because many network devices are managed over a secure, isolated network – and
    given the damage that could be caused if access to this fell into the wrong hands,
    rightly so. This means that these hosts are often accessed using a bastion host
    (also known as a jump host). To run your automation playbooks via this bastion,
    you can add the following to your inventory variables:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ansible.netcommon.network_cli`协议的另一个好处是，它支持`ansible_ssh_common_args`清单变量，就像任何其他SSH管理的主机（使用OpenSSH的Linux或Windows）一样。这很重要，因为许多网络设备是在安全的隔离网络上管理的
    - 如果这些访问权限落入错误的手中，可能会造成严重的损害。这意味着这些主机通常使用跳板主机（也称为跳板主机）进行访问。要通过这个跳板运行您的自动化playbook，您可以将以下内容添加到您的清单变量中：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding example assumes your bastion or jump host has a hostname of `jumphost.example.org`
    and that you have already set up passwordless key-based SSH access to it from
    your Ansible control node. There are other ways to authenticate with this bastion
    host, of course, and this is left as an exercise for you to explore.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例假设您的堡垒机或跳板主机的主机名为`jumphost.example.org`，并且您已经从Ansible控制节点为其设置了基于密钥的无密码SSH访问。当然，还有其他方法可以与这个堡垒主机进行身份验证，这留给您去探索。
- en: Of course, this is just one example, and Cisco IOS-based devices are not something
    that everyone reading this book will have access to. However, at the time of writing,
    you can easily and freely download the Arista vEOS images by signing up for a
    free account on their website and heading over to [https://www.arista.com/en/support/software-download](https://www.arista.com/en/support/software-download).
    From here, you can load these images into a network simulation tool such as GNS3
    and experiment with Ansible's network automation for yourself, without needing
    access to any expensive hardware. We'll look at this in the next section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个例子，而基于Cisco IOS的设备并不是每个阅读本书的人都能接触到的东西。然而，在撰写本文时，您可以轻松且免费地通过在其网站上注册免费帐户并转到[https://www.arista.com/en/support/software-download](https://www.arista.com/en/support/software-download)来下载Arista
    vEOS镜像。从这里，您可以将这些镜像加载到网络模拟工具（如GNS3）中，并自行尝试使用Ansible进行网络自动化，而无需访问任何昂贵的硬件。我们将在下一节中讨论这个问题。
- en: Configuring Arista EOS switches with Ansible
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible配置Arista EOS交换机
- en: 'Getting up and running with an Arista switch (or virtual switch) is left as
    an exercise f or you, but if you are interested in doing this in GNS3, a popular
    and freely available open source tool for learning about networks, there is some
    excellent guidance here: [https://gns3.com/marketplace/appliances/arista-veos](https://gns3.com/marketplace/appliances/arista-veos).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Arista交换机（或虚拟交换机）进行启动和运行是您的任务，但是如果您有兴趣在GNS3中进行此操作，GNS3是一个流行且免费的开源工具，用于学习网络知识，这里有一些很好的指导：[https://gns3.com/marketplace/appliances/arista-veos](https://gns3.com/marketplace/appliances/arista-veos)。
- en: You might be lucky enough to have an Arista EOS-based device at your fingertips,
    and that's fine too – the automation code in this section will work equally well
    in either case.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能很幸运，手边有一台基于Arista EOS的设备，这也没关系 - 本节中的自动化代码在任何情况下都能很好地工作。
- en: 'The following examples were created against an Arista vEOS device in GNS3,
    created using the instructions found in the aforementioned link. Upon booting
    the device for the first time, you will need to cancel ZeroTouch provisioning.
    To do this, log in with the `admin` username (the password is blank by default)
    and enter the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是针对GNS3中的Arista vEOS设备创建的，使用了上述链接中找到的说明。首次启动设备时，您需要取消ZeroTouch配置。要做到这一点，请使用`admin`用户名登录（默认情况下密码为空），并输入以下命令：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The virtual device will reboot, and when it comes up again, log in using the
    same credentials. Enter the following command to enter privileged user mode:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟设备将重新启动，当它再次启动时，使用相同的凭据登录。输入以下命令进入特权用户模式：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that this is the `ansible_become` method that we used in the Cisco IOS
    example earlier, and we''ll be using the same again here shortly. Now, enter configuration
    mode with the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是我们在之前的Cisco IOS示例中使用的`ansible_become`方法，我们将很快再次使用相同的方法。现在，使用以下命令进入配置模式：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You cannot administer a vEOS device over SSH if it has a blank password by
    default, so we''ll set a simple password for our virtual device with the following
    command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果vEOS设备默认密码为空，则无法通过SSH管理该设备，因此我们将使用以下命令为我们的虚拟设备设置一个简单的密码：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This sets the password for the `admin` user to `admin`. Next (assuming you
    have wired up the management interface of the vEOS device to your virtual network),
    you will need to enable this interface and give it a valid IP address. The exact
    IP address will depend on your test network, but the commands to achieve this
    would look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`admin`用户的密码设置为`admin`。接下来（假设您已经将vEOS设备的管理接口连接到虚拟网络），您需要启用此接口并为其分配一个有效的IP地址。确切的IP地址将取决于您的测试网络，但实现此目的的命令如下所示：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, exit configuration mode and write the configuration to the switch
    so that it comes up again on the next reboot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，退出配置模式并将配置写入交换机，以便在下次重新启动时再次启动：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That's it – your vEOS device is now ready for management with Ansible!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样 - 您的vEOS设备现在已准备好使用Ansible进行管理！
- en: 'With this configuration in place, you can now define an inventory for your
    test switch. I created mine as follows (based on the preceding configuration):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，现在您可以为测试交换机定义清单。我创建了我的清单如下（基于前面的配置）：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how similar this is to the Cisco IOS-based example inventory we created
    in the previous section? This is one of the great things about the `ansible.netcommon.network_cli`
    protocol – all your code is much easier to write when using this protocol. Of
    course, as with most of the examples in this book, you wouldn't leave your administrative
    password out in the clear, it but serves to keep the examples simple and concise,
    and you are encouraged to explore the use of Ansible Vault for storing them safely.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这与我们在上一节中创建的基于Cisco IOS的示例清单有多相似？这是`ansible.netcommon.network_cli`协议的伟大之处之一
    - 当使用此协议时，您的所有代码编写起来都更容易。当然，与本书中大多数示例一样，您不会将您的管理密码明文留在外面，但这有助于保持示例简单和简洁，鼓励您探索使用Ansible
    Vault来安全存储它们。
- en: 'From here, we can develop a simple playbook to demonstrate command automation
    against our virtual switch. Let''s pick a simple task – we''ll ensure that the
    `Ethernet1` interface on the switch is enabled, give it a meaningful name, and
    then write the config to the switch so that it persists across reboots. A playbook
    that achieves this might look something like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以开发一个简单的playbook来演示针对我们的虚拟交换机的命令自动化。让我们选择一个简单的任务 - 我们将确保交换机上的`Ethernet1`接口是启用的，给它一个有意义的名称，然后将配置写入交换机，以便在重新启动后保持不变。实现这一点的playbook可能看起来像这样：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can run this playbook in the same way you are used to. If you''re running
    the example code that accompanies this book, the command for this would be as
    follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以您习惯的方式运行此playbook。如果您正在运行本书附带的示例代码，那么命令将如下所示：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When you run this against your switch, you should see an Ansible output similar
    to the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对交换机运行此命令时，您应该看到类似以下的Ansible输出：
- en: '![Figure 13.1 – Configuring an Arista vEOS device with Ansible'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.1 - 使用Ansible配置Arista vEOS设备'
- en: '](Images/B17462_13_01.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_13_01.jpg)'
- en: Figure 13.1 – Configuring an Arista vEOS device with Ansible
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 - 使用Ansible配置Arista vEOS设备
- en: 'Now, of course, since we are performing this configuration change with Ansible,
    we expect the change to be idempotent – we should be able to run the same playbook
    again and nothing disruptive will happen. If you run your playbook a second time,
    the output should look like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当然，由于我们正在使用Ansible进行此配置更改，我们期望更改是幂等的 - 我们应该能够再次运行相同的playbook，而不会发生任何破坏性的事情。如果您再次运行playbook，输出应该如下所示：
- en: '![Figure 13.2 – Running the same playbook again to demonstrate idempotency'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.2 - 再次运行相同的playbook以演示幂等性'
- en: '](Images/B17462_13_02.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_13_02.jpg)'
- en: Figure 13.2 – Running the same playbook again to demonstrate idempotency
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 - 再次运行相同的playbook以演示幂等性
- en: As shown by the green `ok` task statuses, this playbook has run successfully
    a second time and that this time around, no changes were made to the switch configuration.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过绿色的`ok`任务状态，可以看到这个playbook第二次成功运行，并且这一次没有对交换机配置进行任何更改。
- en: 'If you choose to, you can validate the results of our playbook run by SSHing
    directly into the switch and executing the following commands:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以通过直接SSH到交换机并执行以下命令来验证我们playbook运行的结果：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'From here, you should see something like the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，您应该看到类似以下的内容：
- en: '![Figure 13.3 – Querying the configuration of our vEOS device manually'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.3 - 手动查询我们的vEOS设备的配置'
- en: '](Images/B17462_13_03.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_13_03.jpg)'
- en: Figure 13.3 – Querying the configuration of our vEOS device manually
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 - 手动查询我们的vEOS设备的配置
- en: Here, we can see that the `Ethernet1` interface has the description we set in
    our playbook and has no directive to disable it, thus ensuring it is enabled.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`Ethernet1`接口具有我们在playbook中设置的描述，并且没有禁用它的指令，因此确保它是启用的。
- en: That's it – by working through this example, you've just performed your first
    real-life network device automation in Ansible! Hopefully, this shows you that,
    particularly now, given the advent of the `ansible.netcommon.network_cli` protocol,
    it is very easy and quick to achieve the configuration you desire. Most devices
    that support this protocol will work similarly, and you are encouraged to explore
    this further if this is of interest to you. However, what if we want to work with
    another device? Well, Cumulus Linux (now owned by NVIDIA) is an open source operating
    system for network devices that can run on white box hardware – that is to say,
    it is not proprietary to any specific hardware. Fortunately, you can freely download
    a copy of Cumulus VX, a virtual version of their switch operating system to experiment
    with. We'll look at how Ansible can automate this network platform in the next
    section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样 - 通过完成这个示例，您刚刚在Ansible中执行了您的第一个真实的网络设备自动化！希望这能向您展示，特别是现在，鉴于`ansible.netcommon.network_cli`协议的出现，实现您想要的配置非常容易和快速。大多数支持此协议的设备将类似工作，如果您对此感兴趣，鼓励您进一步探索。但是，如果我们想要使用另一台设备怎么办？好吧，Cumulus
    Linux（现在由NVIDIA拥有）是一个网络设备的开源操作系统，可以在白盒硬件上运行 - 也就是说，它不是专有于任何特定的硬件。幸运的是，您可以免费下载Cumulus
    VX的副本，这是他们交换机操作系统的虚拟版本，以进行实验。我们将在下一节中看看Ansible如何自动化这个网络平台。
- en: Configuring Cumulus Networks switches with Ansible
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible配置Cumulus Networks交换机
- en: Cumulus Linux (created by Cumulus Networks, which was acquired by NVIDIA) is
    an open source network operating system that can run on a variety of bare metal
    switches, offering an open source approach to data center networking. This is
    a great leap forward for network design and a significant shift away from the
    proprietary models of the past. They offer a free version of their software that
    will run on the hypervisor of your choice for test and evaluation purposes called
    Cumulus VX. The examples in this section are based on Cumulus VX version 4.4.0.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Cumulus Linux（由NVIDIA收购的Cumulus Networks创建）是一种开源网络操作系统，可以在各种裸机交换机上运行，为数据中心网络提供了开源方法。这是网络设计的重大进步，也是从过去专有模型的重大转变。他们提供了一个免费版本的软件，可以在您选择的hypervisor上运行，用于测试和评估，称为Cumulus
    VX。本节中的示例基于Cumulus VX版本4.4.0。
- en: Defining our inventory
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义我们的清单
- en: A quick bit of research shows us that Cumulus VX will use the standard SSH transport
    method of Ansible. Since it is a Linux distribution designed specifically to run
    on switch hardware, it is capable of running in remote execution mode, so it does
    not require the `ansible.netcommon.network_cli` protocol. Furthermore, just one
    module has been defined for working with this system,`network.cumulus.nclu`, which
    is part of the `community.network` collection ([https://galaxy.ansible.com/community/network](https://galaxy.ansible.com/community/network)).
    No prerequisite modules are required to use this module, so we can proceed straight
    to defining our inventory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 快速的研究显示，Cumulus VX将使用Ansible的标准SSH传输方法。由于它是专门设计用于在交换机硬件上运行的Linux发行版，因此它能够以远程执行模式运行，因此不需要`ansible.netcommon.network_cli`协议。此外，仅为使用该系统而定义了一个模块，`network.cumulus.nclu`，它是`community.network`集合的一部分（[https://galaxy.ansible.com/community/network](https://galaxy.ansible.com/community/network)）。使用此模块不需要先决条件模块，因此我们可以直接定义我们的清单。
- en: By default, Cumulus VX boots up with the management interface that's been configured
    to get an IP address with DHCP. Depending on how you run it, you may find that
    it also has three other virtual switch ports for us to test and play with its
    configuration, though if you integrate it into a tool such as GNS3, you will find
    that you can easily reconfigure the number of virtual switch ports available to
    you.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Cumulus VX启动时使用已配置为使用DHCP获取IP地址的管理接口。根据您的运行方式，您可能会发现它还有其他三个虚拟交换机端口供我们测试和配置，尽管如果您将其集成到诸如GNS3之类的工具中，您将发现可以轻松重新配置可用于您的虚拟交换机端口的数量。
- en: 'If you run a version of Cumulus Linux older than 3.7, you will find that the
    image has default login credentials already set. So, provided you establish the
    IP address of your virtual switch, you can create a simple inventory such as the
    following one, which uses the default username and password:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行的Cumulus Linux版本旧于3.7，您会发现镜像已经设置了默认登录凭据。因此，只要您确定了虚拟交换机的IP地址，您可以创建一个简单的清单，例如以下清单，它使用默认用户名和密码：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Newer releases of Cumulus Linux, such as version 4.4.0 – the latest available
    at the time of writing and used for the examples in this section – require you
    to set the password for the switch upon first boot. If you are working with this
    version, you will need to boot the virtual switch for the first time, and then
    log in with the default username of `cumulus` and the default password of `cumulus`.
    You will then be prompted to change your password.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Cumulus Linux的新版本，例如4.4.0 - 在撰写本文时可用的最新版本，并用于本节示例 - 需要您在首次启动交换机时设置密码。如果您使用此版本，您需要首次启动虚拟交换机，然后使用默认用户名`cumulus`和默认密码`cumulus`登录。然后，您将被提示更改密码。
- en: With this done, you are ready to automate your switch configuration. You can
    use the inventory we defined previously and simply replace the `ansible_ssh_pass`
    value with the password that you set.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，您就可以开始自动化交换机配置。您可以使用我们之前定义的清单，并简单地将`ansible_ssh_pass`的值替换为您设置的密码。
- en: 'Note the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下内容：
- en: The IP address specified in `ansible_host` will almost certainly differ from
    mine – make sure you change this to the correct value for your Cumulus VX virtual
    machine. You might have to log into the VM console to get the IP address with
    a command such as `ip addr show`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_host`中指定的IP地址几乎肯定与我的不同 - 请确保将其更改为Cumulus VX虚拟机的正确值。您可能需要登录VM控制台以获取IP地址，例如使用`ip
    addr show`命令。'
- en: Once again, you would never put the password in clear text in the inventory
    file – however, for simplicity and to save time, we will specify the default password
    here. In a real-world use case, always use a vault, or set up key-based SSH authentication.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次强调，您绝对不会在清晰文本中放置密码在清单文件中 - 但是，为了简单起见并节省时间，我们将在这里指定默认密码。在实际用例中，始终使用保险库，或者设置基于密钥的SSH身份验证。
- en: 'With the inventory defined, let''s test connectivity with the `ping` module
    using an ad hoc command, like so:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了清单后，让我们使用临时命令使用`ping`模块测试连接，如下所示：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If all is set up correctly, you should receive the following output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切设置正确，您应该收到以下输出：
- en: '![Figure 13.4 – Checking Ansible connectivity to our virtual Cumulus Linux
    switch'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.4 - 检查Ansible与我们的虚拟Cumulus Linux交换机的连接'
- en: '](Images/B17462_13_04.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_13_04.jpg)'
- en: Figure 13.4 – Checking Ansible connectivity to our virtual Cumulus Linux switch
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 - 检查Ansible与我们的虚拟Cumulus Linux交换机的连接
- en: As we discussed in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015),
    *The* *System Architecture and Design of Ansible*, the `ansible.builtin.ping`
    module performs a complete end-to-end connectivity test, including authentication
    at the transport layer. As a result, if you received a successful test result
    like the one shown previously, we can proceed with confidence and write our first
    playbooks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第1章*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015)中讨论的那样，*Ansible的系统架构和设计*，`ansible.builtin.ping`模块执行完整的端到端连接测试，包括在传输层进行身份验证。因此，如果您收到了像之前显示的成功测试结果，我们可以有信心继续编写我们的第一个playbook。
- en: Practical examples
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际例子
- en: 'The Cumulus VX image comes completely unconfigured (save for the DHCP client
    configuration on the `eth0` management port). Depending on the version you download,
    it may have three switch ports labeled `swp1`, `swp2`, and `swp3`. Let''s query
    one of those interfaces to see whether there is any existing configuration. We
    can use a simple playbook called `switch-query.yaml` to query `swp1`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Cumulus VX镜像完全未配置（除了`eth0`管理端口上的DHCP客户端配置）。根据您下载的版本，它可能有三个标记为`swp1`、`swp2`和`swp3`的交换机端口。让我们查询其中一个接口，看看是否有任何现有配置。我们可以使用一个名为`switch-query.yaml`的简单playbook来查询`swp1`：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s say we run this with the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们使用以下命令运行：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We should see something like the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到类似以下的内容：
- en: '![Figure 13.5 – Querying the defaults of a switch port on Cumulus Linux with
    Ansible'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.5 - 使用Ansible在Cumulus Linux上查询交换机端口的默认设置'
- en: '](Images/B17462_13_05.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_13_05.jpg)'
- en: Figure 13.5 – Querying the defaults of a switch port on Cumulus Linux with Ansible
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 - 使用Ansible查询Cumulus Linux交换机端口的默认值
- en: 'This confirms our initial statement about the VM image – we can see that the
    switch port is not configured. It is very easy to turn this VM into a simple layer
    2 switch with Ansible and the `community.network.nclu` module. The following playbook,
    called `switch-l2-configure.yaml`, does exactly this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这证实了我们对VM镜像的初始说法 - 我们可以看到交换机端口没有配置。使用Ansible和`community.network.nclu`模块将这个VM变成一个简单的二层交换机非常容易。下面的playbook，名为`switch-l2-configure.yaml`，就是这样做的：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice how we are using some clever inline Jinja2 templating to run a `for` loop
    across the three interfaces, saving the need to create repetitive and cumbersome
    code. These commands bring up the three switch interfaces and add them to the
    default layer 2 bridge.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在使用一些巧妙的内联Jinja2模板来在三个接口上运行`for`循环，省去了创建重复和繁琐代码的需要。这些命令启动了三个交换机接口，并将它们添加到默认的二层桥接中。
- en: 'This also demonstrates the differences between the various networking modules
    available in Ansible. In the previous section, where we configured our EOS-based
    switch, we had numerous different modules to work with, each serving a different
    purpose – for example configuring interfaces, configuring routing, and configuring
    VLANs. In contrast, Cumulus Linux-based switches only have one module: `community.network.nclu`.
    This is not an issue, but as we are sending all our configuration commands through
    one module, making use of Jinja2 templates (which can support constructs such
    as `for` loops) serves us well.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这也展示了Ansible中可用的各种网络模块之间的差异。在前一节中，我们配置基于EOS的交换机时，有许多不同的模块可供使用，每个模块都有不同的目的 -
    例如配置接口、配置路由和配置VLAN。相比之下，基于Cumulus Linux的交换机只有一个模块：`community.network.nclu`。这并不是问题，但由于我们通过一个模块发送所有配置命令，利用Jinja2模板（可以支持诸如`for`循环之类的结构）对我们很有帮助。
- en: 'Finally, the `commit: true` line applies these configurations immediately to
    the switch. Now, let''s say we run this with the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，`commit: true`行立即将这些配置应用到交换机上。现在，让我们用以下命令运行它：'
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At this point, we will see a different status for `swp1`, as shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们将看到`swp1`的不同状态，如下所示：
- en: '![Figure 13.6 – Successfully configuring our Cumulus Linux virtual switch with
    Ansible'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.6 - 使用Ansible成功配置我们的Cumulus Linux虚拟交换机'
- en: '](Images/B17462_13_06.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_13_06.jpg)'
- en: Figure 13.6 – Successfully configuring our Cumulus Linux virtual switch with
    Ansible
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 - 使用Ansible成功配置我们的Cumulus Linux虚拟交换机
- en: As we can see, the `swp1` interface is now up and part of the bridge, ready
    to switch traffic. However, if you look closely at the preceding screenshot, you'll
    see that the `bring up ports swp[1-3]` task has a status of `ok`, rather than
    `changed`. Yet we can see from the `switch` query results that the configuration
    was changed. This appears to be a bug in version `3.0.0` of the `community.network`
    collection and has been raised by the author. Hopefully, newer releases of this
    collection will correctly show the changed status when the configuration of Cumulus
    switches is changed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`swp1`接口现在已经启动并加入了桥接，准备好进行交换流量。然而，如果您仔细观察前面的截图，您会发现`bring up ports
    swp[1-3]`任务的状态是`ok`，而不是`changed`。然而，我们可以从`switch`查询结果中看到配置已经改变。这似乎是`community.network`集合版本`3.0.0`中的一个bug，并已经被作者提出。希望这个集合的新版本能够正确显示当Cumulus交换机的配置发生变化时的改变状态。
- en: 'Since we''re querying the port''s status, though, we can still run the playbook
    a second time to test idempotency. Let''s see what happens if we run the playbook
    again without performing any other steps on the switch:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在查询端口的状态，我们仍然可以再次运行playbook来测试幂等性。让我们看看如果我们在交换机上不执行任何其他步骤的情况下再次运行playbook会发生什么：
- en: '![Figure 13.7 – Testing the idempotency of our playbook against our Cumulus
    Linux virtual switch'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.7 - 测试我们的playbook对Cumulus Linux虚拟交换机的幂等性'
- en: '](Images/B17462_13_07.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_13_07.jpg)'
- en: Figure 13.7 – Testing the idempotency of our playbook against our Cumulus Linux
    virtual switch
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 - 测试我们的playbook对Cumulus Linux虚拟交换机的幂等性
- en: This time, the state of this task is still `ok`, but we can see that the interface
    status query results are the same, showing that our configuration has persisted
    and not been modified in any adverse way (which could happen if idempotency was
    not supported). In this way, playbooks that automate the configuration of our
    Cumulus Linux switch are idempotent and result in a consistent state, even when
    they're run multiple times. This also means that if the configuration of the switch
    drifts (for example, due to user intervention), it is very easy to see that something
    has changed. Unfortunately, the `community.network.nclu` module doesn't currently
    support the `check` mode of `ansible-playbook`, but it still provides a powerful
    way to configure and manage your switches.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，这个任务的状态仍然是“ok”，但我们可以看到接口状态查询结果是相同的，显示我们的配置已经持久化，并且没有以任何不利的方式被修改（如果不支持幂等性，可能会发生这种情况）。通过这种方式，自动化配置我们的Cumulus
    Linux交换机的playbook是幂等的，并且在多次运行时会产生一致的状态。这也意味着，如果交换机的配置漂移（例如由于用户干预），很容易看出发生了变化。不幸的是，`community.network.nclu`模块目前不支持`ansible-playbook`的`check`模式，但它仍然提供了一种强大的方式来配置和管理您的交换机。
- en: Automating network hardware, such as that running Arista EOS and Cumulus Linux,
    with Ansible is as simple as that – just think what you could do to automate your
    network configuration using a combination such as this! I encourage you to explore
    these free tools to learn more about network automation; I think you'll quickly
    see the value in it. Hopefully, even with these simple examples, you can see that
    automating network infrastructure with Ansible is now no more difficult than automating
    anything else in your infrastructure.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ansible自动化运行Arista EOS和Cumulus Linux等网络硬件就是这么简单-只需想象一下使用这样的组合来自动化您的网络配置！我鼓励您探索这些免费工具，以了解更多关于网络自动化的知识；我相信您很快就会看到它的价值。希望即使在这些简单的示例中，您也能看到使用Ansible自动化网络基础设施现在不再比自动化基础设施中的任何其他内容更困难。
- en: Best practices
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: All the usual best practices of using Ansible apply when automating network
    devices with it. For example, never store passwords in the clear, and make use
    of `ansible-vault` where appropriate. Despite this, network devices are their
    own special class of devices when it comes to Ansible, and support for them started
    to flourish from the 2.5 release of Ansible onward. As such, there are a few special
    best practices that deserve to be mentioned when it comes to network automation
    with Ansible.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ansible自动化网络设备时，所有通常的最佳实践都适用。例如，永远不要以明文存储密码，并在适当的情况下使用`ansible-vault`。尽管如此，当涉及到Ansible时，网络设备是其自己特殊的设备类别，并且对它们的支持从Ansible
    2.5版本开始蓬勃发展。因此，在使用Ansible进行网络自动化时，有一些特殊的最佳实践值得一提。
- en: Inventory
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清单
- en: 'Make good use of the inventory structure supported by Ansible when it comes
    to organizing your network infrastructure and pay particular attention to grouping.
    Doing so will make your playbook development much easier. For example, suppose
    you have two switches on your network – one is a Cumulus Linux Switch, as we examined
    previously, and the other is an Arista EOS-based device. Your inventory may look
    like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织网络基础设施和特别关注分组时，充分利用Ansible支持的库存结构。这样做将使您的playbook开发变得更加容易。例如，假设您的网络上有两个交换机-一个是Cumulus
    Linux交换机，正如我们之前所检查的，另一个是基于Arista EOS的设备。您的清单可能如下所示：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We know that we cannot run the `community.network.nclu` module on anything
    other than a Cumulus switch, so, with some careful use of the `when` statement,
    we can build tasks in playbooks to ensure that we run the correct command on the
    correct device. Here is a task that will only run on devices in the `cumulus` group
    we defined in the preceding inventory:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们不能在除Cumulus交换机以外的任何设备上运行`community.network.nclu`模块，因此，通过谨慎使用`when`语句，我们可以在playbooks中构建任务，以确保我们在正确的设备上运行正确的命令。以下是一个只在我们在前面的清单中定义的`cumulus`组中的设备上运行的任务：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Similarly, good use of grouping enables us to set variables on a device basis.
    Although you would not put passwords in the clear into your inventory, it might
    be that your switches of a given type all use the same username (for example, `cumulus` in
    the case of Cumulus Linux devices). Alternatively, perhaps your EOS devices need
    specific Ansible host variables set for connectivity to work and to achieve the
    privilege escalation that''s required to perform configuration. Thus, we can extend
    our preceding inventory example by adding the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，良好的分组使用使我们能够根据设备设置变量。尽管您不会将密码明文放入库存中，但也许您的给定类型的交换机都使用相同的用户名（例如，在Cumulus Linux设备的情况下为`cumulus`）。或者，也许您的EOS设备需要设置特定的Ansible主机变量以使连接工作并实现所需的特权升级来执行配置。因此，我们可以通过添加以下代码来扩展我们之前的清单示例：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Good inventory structure and variable definition will make developing your playbooks
    a great deal easier, and the resulting code will be more manageable and easier
    to work with.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的库存结构和变量定义将使您的playbooks开发变得更加容易，结果代码将更易于管理和操作。
- en: Gathering facts
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集事实
- en: Ansible includes several specific fact-gathering modules for network devices,
    and these may be useful for running conditional tasks or simply reporting back
    data about your devices. If you are using the older `local` connection-based protocol,
    these device-specific fact modules cannot be run at the start of the playbook
    run since, at this stage, Ansible does not know what sort of device it is communicating
    with. Thus, we must tell it to gather the facts for each device as appropriate. Using
    the `ansible.netcommon.network_cli` protocol described earlier in this chapter
    resolves this issue, as Ansible knows from the inventory what sort of device it
    is talking to.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible包括几个专门的收集事实模块用于网络设备，这些模块可能对运行条件任务或简单地报告有关设备的数据非常有用。如果您正在使用较旧的基于`local`连接的协议，则这些特定于设备的事实模块不能在playbook运行开始时运行，因为在这个阶段，Ansible不知道它正在与什么类型的设备通信。因此，我们必须告诉它根据需要收集每个设备的事实。使用本章前面描述的`ansible.netcommon.network_cli`协议解决了这个问题，因为Ansible从清单中知道它正在与什么类型的设备交流。
- en: Even so, there are times when it is useful to manually gather facts on your
    devices – perhaps to validate some configuration work performed as part of a larger
    playbook. Whether you are doing this, or, for legacy reasons, still reliant on
    the `local` connection-based protocol, you need to be aware that you will use
    different fact-gathering modules for different connection types. Let's expand
    our Arista EOS and Cumulus Linux example to look at this.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 即便如此，有时手动收集设备的事实是有用的-也许是为了验证作为较大playbook的一部分执行的一些配置工作。无论您是这样做，还是出于传统原因，仍然依赖于`local`连接的协议，您都需要意识到对于不同的连接类型，您将使用不同的事实收集模块。让我们扩展我们的Arista
    EOS和Cumulus Linux示例来看看这一点。
- en: 'There is no specific facts module for Cumulus Linux switches (although, since
    they are based on Linux, the standard host facts can still be gathered). Using
    the example of our Arista EOS device, we would run the `arista.eos.eos_facts`
    module in our playbook based on a unique key in our inventory. In the example
    inventory that we defined in the previous section, our Arista EOS switches are
    in the `eos` group, and also have `ansible_network_os` set to `arista.eos.eos`.
    We can use either of these as a condition in a `when` statement to run the `arista.eos.eos_facts`
    module on our switches. As such, the beginning of our playbook might look like
    this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Cumulus Linux交换机没有专门的事实模块（尽管它们基于Linux，仍然可以收集标准主机事实）。以我们的Arista EOS设备为例，我们将在基于清单中的唯一密钥运行`arista.eos.eos_facts`模块的playbook中。在我们在上一节中定义的示例清单中，我们的Arista
    EOS交换机在`eos`组中，并且`ansible_network_os`也设置为`arista.eos.eos`。我们可以在`when`语句中使用其中任何一个作为条件来在我们的交换机上运行`arista.eos.eos_facts`模块。因此，我们的playbook开头可能是这样的：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that we set `gather_facts` to `false` at the beginning of this playbook.
    If you are using the `local` connection-based protocol, you would need to do this
    as we discussed previously – otherwise, using `ansible.netcommon.network_cli`,
    you can gather facts at the start of the play if you wish (obviously, though,
    this is redundant in this example!).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此playbook的开头将`gather_facts`设置为`false`。如果您使用基于`local`连接的协议，您需要像我们之前讨论的那样这样做-否则，使用`ansible.netcommon.network_cli`，您可以在play开始时收集事实（显然，在这个例子中是多余的！）。
- en: You will also note the more complex conditional we have used on our Arista EOS
    devices. As Cumulus Linux-based switches use the same SSH-based transport as Linux
    hosts, they do not need (or indeed have) `ansible_network_os` set, and if we attempt
    to test this variable in a conditional, we will produce a *variable undefined*
    error, and thus no subsequent tasks for hosts without the variable defined (our
    Cumulus Linux switches, in this case) will be attempted. This is hardly the outcome
    we are looking for! As a result, when combining these hosts with other network
    devices in the same play, we must always check that the `ansible_network_os` variable
    is defined before we attempt to perform any queries on it, just as we did in the
    preceding example.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到我们在Arista EOS设备上使用了更复杂的条件。由于Cumulus Linux交换机使用与Linux主机相同的基于SSH的传输，它们不需要（或者确实没有）设置`ansible_network_os`，如果我们尝试在条件中测试这个变量，将会产生*变量未定义*的错误，因此对于没有定义变量的主机（在这种情况下是我们的Cumulus
    Linux交换机），将不会尝试任何后续任务。这显然不是我们想要的结果！因此，在将这些主机与同一play中的其他网络设备组合时，我们必须始终检查`ansible_network_os`变量是否定义，然后再尝试执行任何查询，就像我们在前面的示例中所做的那样。
- en: 'If you have followed the examples in this chapter and set up your virtual Arista
    EOS and Cumulus Linux-based devices, you could run this playbook with the following
    command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照本章中的示例并设置了虚拟的Arista EOS和基于Cumulus Linux的设备，您可以使用以下命令运行此playbook：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of a successful playbook run should look like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 成功运行playbook的输出应该是这样的：
- en: '![Figure 13.8 – Gathering facts for multiple device types with a single playbook'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.8-使用单个playbook收集多种设备类型的事实'
- en: '](Images/B17462_13_08.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_13_08.jpg)'
- en: Figure 13.8 – Gathering facts for multiple device types with a single playbook
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8-使用单个playbook收集多种设备类型的事实
- en: Here, you can see how our different facts modules are run on the appropriate
    device type, thanks to the conditionals we used in our playbook. You can use the
    techniques outlined in this part of this chapter to build far more complex, multi-device
    setups by extrapolating the work we have done together. However, no chapter on
    network automation would be complete without a little more detail on jump hosts.
    We will look at these next.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们的不同事实模块是如何在适当的设备类型上运行的，这要归功于我们在playbook中使用的条件。您可以使用本章的这一部分中概述的技术来通过推断我们一起完成的工作来构建更复杂的多设备设置。然而，没有关于网络自动化的章节会完整无缺，没有更多关于跳板主机的细节。我们将在下一节中讨论这些。
- en: Jump hosts
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳板主机
- en: 'Finally, a word on jump hosts. It is common for network devices to be behind
    a bastion or jump host of some kind for important security reasons. Ansible provides
    several mechanisms for doing this, depending on the underlying network transport.
    For example, SSH connectivity (such as with Cumulus Linux switches) can make use
    of SSH''s ability to proxy commands. There are several ways to achieve these,
    but the simplest is to add another group variable to the inventory. For example,
    if we can only access our Cumulus Linux switch via a host called `bastion01.example.com`
    and are authenticating using an account called `jfreeman`, our inventory variables
    section would look like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于跳板主机的一点说明。出于重要的安全原因，网络设备通常位于某种跳板或跳转主机后面。根据底层网络传输，Ansible提供了几种机制来实现这一点。例如，SSH连接（例如Cumulus
    Linux交换机）可以利用SSH的代理命令功能。有几种方法可以实现这些，但最简单的方法是将另一个组变量添加到清单中。例如，如果我们只能通过名为`bastion01.example.com`的主机访问我们的Cumulus
    Linux交换机，并且使用名为`jfreeman`的账户进行身份验证，我们的清单变量部分将如下所示：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding proxy command assumes that passwordless authentication has already
    been configured and is working for the `jfreeman` account on `bastion01.example.com`,
    and that SSH host keys have already been accepted. Failure to complete these tasks
    will result in an error.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代理命令假定无密码身份验证已经配置并且在`bastion01.example.com`上的`jfreeman`账户上正常工作，并且SSH主机密钥已经被接受。未能完成这些任务将导致错误。
- en: SSH proxy commands like this would work for other `ansible_connection` modes
    that are used in network device management too, including `ansible.netcommon.netconf`
    and `ansible.netcommon.network_cli`, offering support for jump hosts to handle
    a wide range of network devices. As ever, the best method to be sure about the
    way to handle a specific type of connectivity is to check the documentation for
    your specific network device and follow the guidance therein.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的SSH代理命令也适用于用于网络设备管理的其他`ansible_connection`模式，包括`ansible.netcommon.netconf`和`ansible.netcommon.network_cli`，支持使用跳板主机处理各种网络设备。与往常一样，确保处理特定类型的连接的最佳方法是查阅特定网络设备的文档，并遵循其中的指导。
- en: 'If we repeat our earlier example for querying the `swp1` interface of our Cumulus
    Linux switch, we will see that (with the bastion host correctly set up) the playbook
    works exactly as it did earlier in this chapter and that no further steps or changes
    to the code are required:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重复之前的示例来查询Cumulus Linux交换机的`swp1`接口，我们会发现（在正确设置了堡垒主机的情况下），playbook的工作方式与本章早期完全相同，并且不需要进一步的步骤或代码更改：
- en: '![Figure 13.9 – Running an earlier example playbook, but this time through
    a preconfigured bastion host'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.9 - 运行之前的示例playbook，但这次通过预先配置的堡垒主机'
- en: '](Images/B17462_13_09.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_13_09.jpg)'
- en: Figure 13.9 – Running an earlier example playbook, but this time through a preconfigured
    bastion host
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 - 运行之前的示例playbook，但这次通过预先配置的堡垒主机
- en: This is yet another reason why Ansible has become so popular – there is no need
    to set up a special proxy application or server for it to access an isolated network.
    Using the standard SSH protocol, it can connect via any secure host on the network
    that has SSH configured.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么Ansible变得如此受欢迎的另一个原因 - 无需设置特殊的代理应用程序或服务器来访问隔离网络。使用标准的SSH协议，它可以通过网络上配置了SSH的任何安全主机进行连接。
- en: This concludes our exploration of network automation with Ansible. The number
    and range of devices you can automate the configuration of is limited only by
    your imagination, and I hope that this chapter has helped you gain a solid foundation
    in this important field and given you the confidence to explore further.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们对使用Ansible进行网络自动化的探索的结束。您可以自动化配置的设备数量和范围仅受您的想象力限制，我希望本章能够帮助您在这一重要领域建立坚实的基础，并给您探索更多的信心。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As more and more of our infrastructure gets defined and managed by code, it
    becomes ever more important that the network layer can be automated effectively
    by Ansible. A great deal of work has gone into Ansible since the previous release
    of this book in precisely this area, especially since the release of Ansible 2.5\.
    With these advancements, it is now easy to build playbooks to automate network
    tasks, from simple device changes to rolling out entire network architectures
    through Ansible. All of the benefits of Ansible relating to code reuse, portability,
    and so on are available to those who manage network devices.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 随着越来越多的基础设施被代码定义和管理，通过Ansible有效地自动化网络层变得更加重要。自上一版书籍发布以来，Ansible在这一领域做了大量工作，特别是在发布Ansible
    2.5之后。通过这些进步，现在可以轻松地构建playbook来自动化网络任务，从简单的设备更改到通过Ansible部署整个网络架构。所有与代码重用、可移植性等相关的Ansible好处都适用于管理网络设备的人员。
- en: In this chapter, you learned about how Ansible enables network management. You
    learned about effective strategies for handling different device types within
    your infrastructure and how to write playbooks for them, and then you expanded
    on this with some specific examples on Arista EOS and Cumulus Linux. Finally,
    you learned about some of the best practices that must be applied when using Ansible
    to manage network infrastructure.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了Ansible如何实现网络管理。您学习了处理基础设施中不同设备类型的有效策略，以及如何为它们编写playbook，然后通过一些特定的Arista
    EOS和Cumulus Linux示例进行了扩展。最后，您了解了在使用Ansible管理网络基础设施时必须应用的一些最佳实践。
- en: This brings us to the conclusion of this book. I would like to thank you for
    joining me on this journey into the very heart of Ansible, and I hope you have
    found it beneficial. I believe you should now know about the strategies and tools
    for managing everything, from small configuration changes to entire infrastructure
    deployments with Ansible, and wish you luck in this important and ever-evolving
    area of technology.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本书的结尾。感谢您加入我一起探索Ansible的旅程，希望您会觉得受益。我相信您现在应该了解了使用Ansible管理一切的策略和工具，从小的配置更改到整个基础设施部署，祝您在这个重要且不断发展的技术领域好运。
- en: Questions
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题，测试您对本章的了解：
- en: Ansible brings all the benefits of automation from infrastructure management
    to the world of network device management.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible将自动化的所有好处从基础设施管理带入到网络设备管理的世界中。
- en: a) True
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: a) 正确
- en: b) False
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: b) 错误
- en: When working with a new network device type for the first time, you should always
    do what?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一次使用新的网络设备类型时，您应该始终做什么？
- en: a) Perform a factory reset of the device.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: a) 对设备执行出厂重置。
- en: b) Consult the Ansible documentation to learn about which collections and modules
    support it, and what the requirements for those might be.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: b) 查阅Ansible文档，了解支持它的集合和模块，以及这些模块的要求。
- en: c) Use the `ansible.netcommon.network_cli` connection protocol.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: c) 使用`ansible.netcommon.network_cli`连接协议。
- en: d) Use the local connection protocol.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: d) 使用本地连接协议。
- en: Which execution type is described by Ansible as running its automation code
    on the remote host directly?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible描述的执行类型是指在远程主机上直接运行其自动化代码？
- en: a) Remote execution
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: a) 远程执行
- en: b) Local execution
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: b) 本地执行
- en: Which execution type is described by Ansible as running its automation code
    on the control node, and then sending the required data over a pre-selected channel
    (for example, SSH or an HTTP-based API)?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible描述的执行类型是指在控制节点上运行其自动化代码，然后通过预选通道（例如SSH或基于HTTP的API）发送所需的数据？
- en: a) Remote execution
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: a) 远程执行
- en: b) Local execution
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: b) 本地执行
- en: Which connection protocol has (for the most part) superseded the older local
    connection-based protocol for network devices?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种连接协议（在大多数情况下）已经取代了旧的基于本地连接的网络设备协议？
- en: a) `ansible.netcommon.netconf`
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: a) `ansible.netcommon.netconf`
- en: b) `ansible.netcommon.httpapi`
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: b) `ansible.netcommon.httpapi`
- en: c) `ansible.netcommon.network_cli`
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: c) `ansible.netcommon.network_cli`
- en: d) `local`
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: d) `本地`
- en: Can you gather facts for an Arista-based EOS device at the beginning of a play?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能在一场比赛开始时收集关于基于Arista EOS设备的事实吗？
- en: a) Yes.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: a) 是的。
- en: b) No.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: b) 不。
- en: c) Yes, but only when using the `ansible.netcommon.network_cli` protocol.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: c) 是的，但只有在使用`ansible.netcommon.network_cli`协议时。
- en: All network config on Arista EOS is performed using a single module.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Arista EOS上的所有网络配置都是使用单个模块执行的。
- en: a) True
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: a) 正确
- en: b) False
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: b) 错误
- en: Cumulus Linux does not require the `ansible.netcommon.network_cli` protocol
    because of which reason?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cumulus Linux不需要`ansible.netcommon.network_cli`协议，因为哪个原因？
- en: a) It is not a network operating system.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: a) 它不是一个网络操作系统。
- en: b) It contains a full Linux implementation, including Python.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: b) 它包含完整的Linux实现，包括Python。
- en: c) It uses the SSH protocol for management.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: c) 它使用SSH协议进行管理。
- en: d) It does not have a CLI.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: d) 它没有CLI。
- en: Good inventory management is especially important when working in multi-device-type
    networks.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 良好的库存管理在处理多种设备类型的网络时尤为重要。
- en: a) True
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: a) 正确
- en: b) False
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: b) 错误
- en: Ansible can support the use of bastion or jump hosts without the need for special
    configuration or software installation.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible可以支持跳板主机或跳转主机的使用，而无需特殊配置或软件安装。
- en: a) True
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: a) 正确
- en: b) False
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: b) 错误
