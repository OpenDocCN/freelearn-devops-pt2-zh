- en: '*Chapter 7*: Controlling Task Conditions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：控制任务条件'
- en: Ansible is a system for running tasks on one or more hosts, and ensuring that
    operators understand whether changes have occurred (and indeed whether any issues
    were encountered). As a result, Ansible tasks result in one of four possible statuses: `ok`, `changed`, `failed`,
    or `skipped`. These statuses perform a number of important functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个在一个或多个主机上运行任务的系统，并确保操作员了解是否发生了变更（以及是否遇到了任何问题）。因此，Ansible任务会产生四种可能的状态：`ok`、`changed`、`failed`或`skipped`。这些状态执行了许多重要的功能。
- en: From the perspective of an operator running an Ansible playbook, they provide
    an overview of the Ansible run that has been completed—whether anything changed
    or not and whether there were any failures that need addressing. In addition,
    they determine the flow of the playbook—for example, if a task results in a `changed` status,
    we might want to perform a restart of the service, but otherwise leave it running.
    Ansible possesses all the necessary functions to achieve this.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从运行Ansible playbook的操作员的角度来看，它们提供了已完成的Ansible运行的概述——无论是否发生了任何变更，以及是否有任何需要解决的失败。此外，它们确定了playbook的流程——例如，如果一个任务的状态是`changed`，我们可能希望执行服务的重启，否则保持运行。Ansible具有实现这一切所需的所有功能。
- en: Similarly, if a task results in a `failed` status, the default behavior of Ansible
    is not to attempt any further tasks on that host. Tasks can also make use of conditionals
    that check the status of previous tasks to control operations. As a result, these
    statuses, or task conditions, are central to just about everything Ansible does,
    and it is important to understand how to work with them and hence control the
    flow of a playbook to cater for cases where, for example, a failure might occur.
    We'll look at how exactly to handle such things in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果一个任务的状态是`failed`，那么Ansible的默认行为就是不在该主机上尝试任何进一步的任务。任务还可以使用条件来检查先前任务的状态以控制操作。因此，这些状态或任务条件对于Ansible的几乎所有操作都是至关重要的，重要的是要了解如何处理它们，从而控制playbook的流程，以满足例如可能发生失败的情况。我们将在本章中详细讨论如何处理这些情况。
- en: 'In this chapter, we''ll explore this in detail, focusing specifically on the
    following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细探讨这一点，特别关注以下主题：
- en: Controlling what defines a failure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制定义失败的内容
- en: Recovering gracefully from a failure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从失败中恢复
- en: Controlling what defines a change
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制定义变更的内容
- en: Iterating over a set of tasks using loops
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用循环迭代一组任务
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the examples presented in this chapter, you will need a Linux machine
    running **Ansible 4.3** or newer. Almost any flavor of Linux should do—for those
    interested in specifics, all the code presented in this chapter was tested on
    **Ubuntu Server 20.04 LTS** unless stated otherwise, and on Ansible 4.3\. The
    example code that accompanies this chapter can be downloaded from GitHub at this
    URL: [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter07).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中提出的示例，您需要一台运行**Ansible 4.3**或更新版本的Linux机器。几乎任何Linux版本都可以使用——对于那些对细节感兴趣的人，本章中提供的所有代码都是在**Ubuntu
    Server 20.04 LTS**上测试的，除非另有说明，并且在Ansible 4.3上。本章附带的示例代码可以从GitHub的以下网址下载：[https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter07)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3AVXxME](https://bit.ly/3AVXxME).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[https://bit.ly/3AVXxME](https://bit.ly/3AVXxME)。
- en: Defining a failure
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义失败
- en: Most modules that ship with Ansible have differing criteria for what constitutes
    an error. An error condition is highly dependent upon the module and what the
    module is attempting to accomplish. When a module returns an error, the host will
    be removed from the set of available hosts, preventing any further tasks or handlers
    from being executed on that host. Furthermore, the `ansible-playbook` and `ansible`
    executables will exit with a non-zero exit code to indicate failure. However,
    we are not limited by a module's opinion of what an error is. We can ignore errors
    or redefine an error condition.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数与Ansible一起提供的模块对于什么构成错误有不同的标准。错误条件高度依赖于模块以及模块试图实现的内容。当一个模块返回错误时，主机将从可用主机集合中移除，阻止在该主机上执行任何进一步的任务或处理程序。此外，`ansible-playbook`和`ansible`可执行文件将以非零退出代码退出以指示失败。然而，我们并不受限于模块对错误的看法。我们可以忽略错误或重新定义错误条件。
- en: Ignoring errors
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 忽略错误
- en: A task condition named `ignore_errors` is used to ignore errors. This condition
    is a Boolean, meaning that the value should be something Ansible understands to
    be `true`, such as `yes`, `on`, `true`, or `1` (string or integer).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`ignore_errors`的任务条件用于忽略错误。这个条件是一个布尔值，意味着值应该是`Ansible`理解为`true`的东西，比如`yes`、`on`、`true`或`1`（字符串或整数）。
- en: 'To demonstrate how to use `ignore_errors`, let''s create a playbook where we
    attempt to query a web server that doesn''t exist. Typically, this would be an
    error, and if we don''t define `ignore_errors`, we get the default behavior; that
    is, the host will be marked as failed and no further tasks will be attempted on
    that host. Create a new playbook called `error.yaml`, as follows, to look further
    at this behavior:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用`ignore_errors`，让我们创建一个playbook，尝试查询一个不存在的web服务器。通常，这将是一个错误，如果我们不定义`ignore_errors`，我们将得到默认行为；也就是说，主机将被标记为失败，并且不会在该主机上尝试任何进一步的任务。创建一个名为`error.yaml`的新playbook，如下所示，以进一步查看这种行为：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run this playbook with the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行此playbook：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The single task in this playbook should result in an error that looks like
    that shown in *Figure 7.1*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这本playbook中的单个任务应该导致一个看起来像*图7.1*中所示的错误：
- en: '![Figure 7.1 – Running a playbook that deliberately induces a task error'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 – 运行一个故意引发任务错误的playbook'
- en: '](Images/B17462_07_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_01.jpg)'
- en: Figure 7.1 – Running a playbook that deliberately induces a task error
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 运行一个故意引发任务错误的playbook
- en: 'Now, let''s imagine that we didn''t want Ansible to stop here, and instead
    we wanted it to continue. We can add the `ignore_errors` condition to our task
    like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们不希望Ansible在这里停止，而是希望它继续。我们可以像这样在我们的任务中添加`ignore_errors`条件：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This time, when we run the playbook using the same command as before, our error will
    be ignored, as shown in *Figure 7.2*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我们使用与之前相同的命令运行playbook时，我们的错误将被忽略，如*图7.2*所示：
- en: '![Figure 7.2 – Running the same playbook but with the ignore_errors task condition
    added'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 - 运行相同的playbook，但添加了`ignore_errors`任务条件'
- en: '](Images/B17462_07_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_02.jpg)'
- en: Figure 7.2 – Running the same playbook but with the ignore_errors task condition
    added
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 - 运行相同的playbook，但添加了`ignore_errors`任务条件
- en: Any further tasks for that host will still be attempted and the playbook does
    not register any failed hosts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于该主机的任何进一步任务仍将尝试，并且playbook不会注册任何失败的主机。
- en: Defining an error condition
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义错误条件
- en: The `ignore_errors` condition is a bit of a blunt instrument. Any error generated
    from the module used by the task will be ignored. Furthermore, the output, at
    first glance, still appears like an error and may be confusing to an operator
    attempting to discover a real failure. A more subtle tool is the `failed_when`
    condition. This condition is more like a fine scalpel, allowing a playbook author
    to be very specific as to what constitutes an error for a task. This condition
    performs a test to generate a Boolean result, much like the `when` condition.
    If the condition results in a Boolean `true` value, the task will be considered
    a failure. Otherwise, the task will be considered successful.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`ignore_errors`条件有点粗糙。来自任务使用的模块的任何错误都将被忽略。此外，乍一看，输出仍然看起来像一个错误，并且可能会让试图发现真正故障的操作员感到困惑。更微妙的工具是`failed_when`条件。这个条件更像是一把精细的手术刀，允许playbook作者非常具体地指出什么对于任务来说构成错误。这个条件执行一个测试来生成一个布尔结果，就像`when`条件一样。如果条件导致布尔`true`值，任务将被视为失败。否则，任务将被视为成功。'
- en: 'The `failed_when` condition is quite useful when used in combination with the
    `command` or `shell` module and registering the result of the execution. Many
    programs that are executed can have detailed non-zero exit codes that mean different
    things. However, these Ansible modules all consider an exit code of anything other
    than `0` to be a failure. Let''s look at the `iscsiadm` utility. This utility
    can be used for many things related to iSCSI. For the sake of demonstration, we''ll
    replace our `uri` module in `error.yaml` and attempt to discover any active `iscsi`
    sessions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当与`command`或`shell`模块结合使用并注册执行结果时，`failed_when`条件非常有用。许多执行的程序可能具有详细的非零退出代码，意味着不同的含义。然而，这些Ansible模块都认为除`0`之外的任何退出代码都是失败。让我们看看`iscsiadm`实用程序。这个实用程序可以用于与iSCSI相关的许多事情。为了演示，我们将在`error.yaml`中替换我们的`uri`模块，并尝试发现任何活动的`iscsi`会话：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run this playbook using the same command as before; unless you happen to be
    on a system with active iSCSI sessions, you will see output very much like that
    in *Figure 7.3*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与之前相同的命令运行这个playbook；除非您在具有活动iSCSI会话的系统上，否则您将看到与*图7.3*非常相似的输出：
- en: '![Figure 7.3 – Running a playbook to discover active iSCSI sessions without
    any failure handling'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 - 运行一个playbook来发现没有任何故障处理的活动iSCSI会话'
- en: '](Images/B17462_07_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_03.jpg)'
- en: Figure 7.3 – Running a playbook to discover active iSCSI sessions without any
    failure handling
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 - 运行一个playbook来发现没有任何故障处理的活动iSCSI会话
- en: Important Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `iscsiadm` tool may not be installed by default, in which case you will
    get a different error from the preceding one. On our Ubuntu Server 20.04 test
    machine, it was installed using the following command: `sudo apt install open-iscsi`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`iscsiadm`工具可能不是默认安装的，如果是这样，您将得到与前面不同的错误。在我们的Ubuntu Server 20.04测试机器上，它是使用以下命令安装的：`sudo
    apt install open-iscsi`。'
- en: 'We can just use the `ignore_errors` condition, but that would mask other problems
    with `iscsi`, so instead of this, we want to instruct Ansible that an exit code
    of `21` is acceptable. To that end, we can make use of the registered variable
    to access the `rc` variable, which holds the return code. We''ll make use of this
    in a `failed_when` statement:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以只使用`ignore_errors`条件，但这将掩盖`iscsi`的其他问题，所以我们不想这样做，而是想指示Ansible退出代码`21`是可以接受的。为此，我们可以利用注册变量来访问`rc`变量，该变量保存返回代码。我们将在`failed_when`语句中使用这个：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We simply stated that any exit code other than `0` or `21` should be considered
    a failure. Run the playbook again, but this time with added verbosity, using the
    `-v` flag on your command like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是声明除`0`或`21`之外的任何退出代码都应被视为失败。再次运行playbook，但这次增加了详细信息，使用命令的`-v`标志，就像这样：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Assuming again that you have no active iSCSI sessions, the output will look
    like that shown in *Figure 7.4*. Use of the `-v` flag is, of course, not mandatory,
    but it is helpful in this case as it shows us the exit code of the `iscsiadm`
    utility:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 再次假设您没有活动的iSCSI会话，输出将如*图7.4*所示。当然，使用`-v`标志并不是强制的，但在这种情况下很有帮助，因为它显示了`iscsiadm`实用程序的退出代码：
- en: '![Figure 7.4 – Running the same playbook but handling failures based on the
    command exit code'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 - 运行相同的playbook，但根据命令退出代码处理故障'
- en: '](Images/B17462_07_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_04.jpg)'
- en: Figure 7.4 – Running the same playbook but handling failures based on the command
    exit code
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 - 运行相同的playbook，但根据命令退出代码处理故障
- en: The output now shows no error, and, in fact, we see a new data key in the results—`failed_when_result`.
    This shows whether our `failed_when` statement rendered `true` or `false`; it
    was `false` in this case.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出显示没有错误，实际上，我们在结果中看到了一个新的数据键 - `failed_when_result`。这显示了我们的`failed_when`语句是否渲染为`true`或`false`；在这种情况下是`false`。
- en: 'Many command-line tools do not have detailed exit codes. In fact, most typically
    use `0` for success and another non-zero code for all failure types. Thankfully,
    the `failed_when` statement is not just limited to the exit code of the application;
    it is a free-form Boolean statement that can access any sort of data required.
    Let''s look at a different problem, one involving `Git`. We''ll imagine a scenario
    where we want to ensure that a particular branch does not exist in a `Git` checkout.
    This task assumes a `Git` repository is checked out in the `/srv/app` directory.
    The command to delete a `Git` branch is `git branch -D`. Let''s have a look at
    the following code snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 许多命令行工具没有详细的退出代码。实际上，大多数通常使用`0`表示成功，另一个非零代码表示所有失败类型。幸运的是，`failed_when`语句不仅仅限于应用程序的退出代码；它是一个自由形式的布尔语句，可以访问任何所需的数据。让我们看一个不同的问题，涉及`Git`。我们将想象一个场景，我们想要确保`Git`检出中不存在特定的分支。此任务假定`/srv/app`目录中已经检出了`Git`存储库。删除`Git`分支的命令是`git
    branch -D`。让我们看一下以下代码片段：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For this code to work, you will need to check a `Git` repository out into the
    preceding directory. If you don''t have one to test with, you can easily create
    one using the following commands (just make sure you don''t have anything important
    in `/srv/app` that could get overwritten!):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此代码工作，您需要将`Git`存储库检出到上一个目录中。如果您没有要测试的存储库，可以使用以下命令轻松创建一个（只需确保`/srv/app`中没有任何重要的内容会被覆盖！）：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once you have done this, you are ready to run the updated playbook task we detailed
    previously. Like before, we'll add verbosity to the output so that we can better
    understand the behavior of our playbook.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，您就可以运行我们之前详细介绍的更新后的playbook任务。与以前一样，我们将增加输出的详细信息，以便更好地理解我们playbook的行为。
- en: Important Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `ansible.builtin.command` and `ansible.builtin.shell` modules use a different
    format for providing module arguments. `ansible.buitin.command` itself is provided
    in free form, while module arguments go into an `args` hash.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible.builtin.command`和`ansible.builtin.shell`模块使用不同的格式来提供模块参数。`ansible.buitin.command`本身以自由形式提供，而模块参数进入`args`哈希。'
- en: 'Running the playbook as described should yield an error, as `git` will produce
    an exit code of `1`, as the branch does not exist, as shown in *Figure 7.5*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 按照描述运行playbook应该会产生错误，因为`git`将产生一个退出代码为`1`的错误，因为分支不存在，如*图7.5*所示：
- en: '![Figure 7.5 – Running a git command in an Ansible playbook with no error handling'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 - 在Ansible playbook中运行git命令而没有错误处理'
- en: '](Images/B17462_07_05.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_05.jpg)'
- en: Figure 7.5 – Running a git command in an Ansible playbook with no error handling
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 - 在Ansible playbook中运行git命令而没有错误处理
- en: As you can see, the error was not handled gracefully, and the play for `localhost`
    has been aborted.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，错误没有得到优雅处理，`localhost`的play已中止。
- en: Important Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We're using the `ansible.builtin.command` module to easily demonstrate our topic
    despite the existence of the `ansible.builtin.git` module. When dealing with Git
    repositories, the `ansible.builtin.git` module should be used instead.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ansible.builtin.command`模块来轻松演示我们的主题，尽管存在`ansible.builtin.git`模块。处理Git存储库时，应改用`ansible.builtin.git`模块。
- en: 'Without the `failed_when` and `changed_when` conditions, we would have to create
    a two-step task combo to protect ourselves from errors:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`failed_when`和`changed_when`条件，我们将不得不创建一个两步任务组合来保护自己免受错误的影响：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the scenario where the branch doesn''t exist, running these tasks should
    look as in *Figure 7.6*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在分支不存在的情况下，运行这些任务应该如*图7.6*所示：
- en: '![Figure 7.6 – Handling errors using two tasks in an Ansible playbook'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 - 在Ansible playbook中使用两个任务处理错误'
- en: '](Images/B17462_07_06.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_06.jpg)'
- en: Figure 7.6 – Handling errors using two tasks in an Ansible playbook
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 - 在Ansible playbook中使用两个任务处理错误
- en: 'While the two-task set is functional, it is not efficient. Let''s improve upon this
    and leverage the `failed_when` functionality to reduce the two tasks to one:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两个任务集是功能性的，但并不高效。让我们改进这一点，并利用`failed_when`功能将两个任务减少到一个：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Important Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Multiple conditions that would normally be joined with `and` can instead be
    expressed as list elements. This can make playbooks easier to read and logic issues
    easier to find.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会使用`and`连接的多个条件可以表示为列表元素。这可以使playbooks更易于阅读，逻辑问题更易于发现。
- en: 'We check the command return code for anything other than `0` and then use the
    `search` filter to search the `stderr` value with a `branch.*not found` regex.
    We use Jinja2 logic to combine the two conditions, which will evaluate to an inclusive `true` or `false` option,
    as shown in *Figure 7.7*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查命令返回代码是否为`0`以外的任何值，然后使用`search`过滤器来搜索带有`branch.*not found`正则表达式的`stderr`值。我们使用Jinja2逻辑来组合这两个条件，这将评估为包容的`true`或`false`选项，如*图7.7*所示：
- en: '![Figure 7.7 – Handling errors efficiently in a single task within an Ansible
    playbook'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 - 在Ansible playbook中单个任务内有效地处理错误'
- en: '](Images/B17462_07_07.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_07.jpg)'
- en: Figure 7.7 – Handling errors efficiently in a single task within an Ansible
    playbook
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 - 在Ansible playbook中单个任务内有效地处理错误
- en: This demonstrates how we can redefine failure in an Ansible playbook, and gracefully
    handle conditions that would otherwise disrupt a play. We can also redefine what
    Ansible sees as a change, and we will look at this next.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这演示了我们如何重新定义Ansible playbook中的失败，并优雅地处理否则会中断play的条件。我们还可以重新定义Ansible视为更改的内容，接下来我们将看到这一点。
- en: Defining a change
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义更改
- en: Similar to defining a task failure, it is also possible to define what constitutes
    a changed task result. This capability is particularly useful with the `ansible.builtin.command` family
    of modules (`command`, `shell`, `raw`, and `script`). Unlike most other modules,
    the modules of this family do not have an inherent idea of what a change may be.
    In fact, unless otherwise directed, these modules only result in `failed`, `changed`,
    or `skipped`. There is simply no way for these modules to assume a changed versus
    unchanged condition, as they cannot be expected to understand or interpret every
    possible shell command you might execute using them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与定义任务失败类似，也可以定义什么构成了更改的任务结果。这种能力在`ansible.builtin.command`系列模块（`command`，`shell`，`raw`和`script`）中特别有用。与大多数其他模块不同，这个系列的模块没有更改可能是什么的固有概念。事实上，除非另有指示，否则这些模块只会产生`failed`，`changed`或`skipped`。对于这些模块来说，根本没有办法假设更改与未更改的条件，因为它们不能期望理解或解释您可能使用它们执行的每个可能的shell命令。
- en: The `changed_when` condition allows a playbook author to instruct a module on
    how to interpret a change. Just like `failed_when`, `changed_when` performs a
    test to generate a Boolean result. Frequently, the tasks used with `changed_when` are
    commands that will exit non-zero to indicate that no work is needed to be done;
    so, often, authors will combine `changed_when` and `failed_when` to fine-tune
    the task result evaluation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`changed_when`条件允许playbook的作者指示模块如何解释更改。就像`failed_when`一样，`changed_when`执行测试以生成布尔结果。经常与`changed_when`一起使用的任务是会以非零退出来指示不需要进行任何工作的命令；因此，作者经常会结合`changed_when`和`failed_when`来微调任务结果的评估。'
- en: 'In our previous example, the `failed_when` condition caught the case where
    there was no work to be done but the task still showed a change. We want to register
    a change on the exit code `0`, but not on any other exit code. Let''s expand our
    example task to accomplish this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，`failed_when`条件捕捉到了没有需要做的工作但任务仍然显示了更改的情况。我们希望在退出码`0`时注册更改，但在任何其他退出码时不注册更改。让我们扩展我们的示例任务以实现这一点：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, if we run our task when the branch still does not exist (again adding
    verbosity to the output to help us see what''s going on under the hood), we''ll
    see output similar to that shown in *Figure 7.8*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在分支仍不存在的情况下运行我们的任务（再次增加输出的详细程度，以帮助我们看到底层发生了什么），我们将看到类似于*图7.8*所示的输出：
- en: '![Figure 7.8 – Extending our Git playbook with a changed_when task condition'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8 – 通过changed_when任务条件扩展我们的Git playbook'
- en: '](Images/B17462_07_08.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_08.jpg)'
- en: Figure 7.8 – Extending our Git playbook with a changed_when task condition
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 通过changed_when任务条件扩展我们的Git playbook
- en: Note how the `changed` key now has the value `false`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`changed`键现在的值为`false`。
- en: 'Just for the sake of completeness, we''ll change the scenario so that the branch
    does exist and run it again. To create the branch, simply run `git branch badfeature` from
    the `/srv/app` directory. Now, we can execute our playbook once again to see the
    output, which should now look like that shown in *Figure 7.9*:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我们将改变场景，使分支存在并再次运行它。要创建分支，只需从`/srv/app`目录运行`git branch badfeature`。现在，我们可以再次执行我们的playbook以查看输出，输出应该看起来像*图7.9*所示：
- en: '![Figure 7.9 – Testing the same playbook when the badfeature branch exists
    in our test repository'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9 – 在我们的测试存储库中存在badfeature分支时测试相同的playbook'
- en: '](Images/B17462_07_09.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_09.jpg)'
- en: Figure 7.9 – Testing the same playbook when the badfeature branch exists in
    our test repository
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 在我们的测试存储库中存在badfeature分支时测试相同的playbook
- en: This time, our output is different; it's registering a change, and the `stdout` data
    shows the branch being deleted.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们的输出不同了；它注册了一个更改，而`stdout`数据显示分支被删除了。
- en: Special handling of the command family
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令系列的特殊处理
- en: A subset of the command family of modules (`ansible.builtin.command`, `ansible.builtin.shell`,
    and `ansible.builtin.script`) has a pair of special arguments that will influence
    whether the task work has already been done, and thus, whether or not a task will
    result in a change. The options are `creates` and `removes`. These two arguments
    expect a file path as a value. When Ansible attempts to execute a task with the
    `creates` or `removes` arguments, it will first check whether the referenced file
    path exists.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 命令系列模块的一个子集（`ansible.builtin.command`，`ansible.builtin.shell`和`ansible.builtin.script`）有一对特殊参数，它们将影响任务工作是否已经完成，从而决定任务是否会导致更改。这些选项是`creates`和`removes`。这两个参数期望一个文件路径作为值。当Ansible尝试使用`creates`或`removes`参数执行任务时，它将首先检查引用的文件路径是否存在。
- en: If the path exists and the `creates` argument was used, Ansible will consider
    that the work has already been completed and will return `ok`. Conversely, if
    the path does not exist and the `removes` argument is used, then Ansible will
    again consider the work to be complete, and it will return `ok`. Any other combination
    will cause the work to actually happen. The expectation is that whatever work
    the task is doing will result in either the creation or removal of the file that
    is referenced.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路径存在并且使用了`creates`参数，Ansible将认为工作已经完成，并返回`ok`。相反，如果路径不存在并且使用了`removes`参数，那么Ansible将再次认为工作已经完成，并返回`ok`。任何其他组合将导致工作实际发生。预期是任务正在做的任何工作都将导致引用的文件的创建或删除。
- en: 'The convenience of `creates` and `removes` saves developers from having to
    do a two-task combo. Let''s create a scenario where we want to run the `frobitz`
    script from the `files/` subdirectory of our project root. In our scenario, we
    know that the `frobitz` script will create a path, `/srv/whiskey/tango`. In fact,
    the source of `frobitz` is the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`creates`和`removes`的便利性使开发人员无需进行两个任务的组合。让我们创建一个场景，我们想要从项目根目录的`files/`子目录运行`frobitz`脚本。在我们的场景中，我们知道`frobitz`脚本将创建一个路径`/srv/whiskey/tango`。实际上，`frobitz`的源代码如下：'
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We don''t want this script to run twice as it can be destructive to any existing
    data. Replacing the existing tasks in our `error.yaml` playbook, the two-task
    combo will look like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望这个脚本运行两次，因为它可能对任何现有数据造成破坏。替换我们的`error.yaml` playbook中的现有任务，两个任务的组合将如下所示：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the playbook with added verbosity as we have done throughout this chapter
    so far. If the `/srv/whiskey/tango` path already exists, the output will be as
    shown in *Figure 7.10*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们在本章中一样，以增加的详细程度运行playbook。如果`/srv/whiskey/tango`路径已经存在，输出将如*图7.10*所示：
- en: '![Figure 7.10 – A two-task play to conditionally run a destructive script only
    when necessary'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10 – 一个两个任务的play，有条件地运行破坏性脚本'
- en: '](Images/B17462_07_10.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_10.jpg)'
- en: Figure 7.10 – A two-task play to conditionally run a destructive script only
    when necessary
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – 一个两个任务的play，有条件地运行破坏性脚本
- en: If the `/srv/whiskey/tango` path did not exist, the `ansible.builtin.stat` module
    would have returned far less data, and the `exists` key would have a value of `false`.
    Thus, our `frobitz` script would have been run.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`/srv/whiskey/tango`路径不存在，`ansible.builtin.stat`模块将返回更少的数据，`exists`键的值将为`false`。因此，我们的`frobitz`脚本将被运行。
- en: 'Now, we''ll use `creates` to reduce this down to a single task:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`creates`将其减少为一个单独的任务：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Important Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `ansible.builtin.script` module is actually an `action_plugin`, which will
    be discussed in [*Chapter 10*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183), *Extending
    Ansible*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible.builtin.script`模块实际上是一个`action_plugin`，将在[*第10章*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183)中讨论，*扩展Ansible*。'
- en: 'This time, our output will be slightly different, as *Figure 7.11* shows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们的输出将会有些不同，如*图7.11*所示：
- en: '![Figure 7.11 – Making our previous playbook more efficient by combining all
    task conditions into one task'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.11 – 通过将所有任务条件合并为一个任务使我们以前的playbook更加高效'
- en: '](Images/B17462_07_11.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_11.jpg)'
- en: Figure 7.11 – Making our previous playbook more efficient by combining all task
    conditions into one task
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 通过将所有任务条件合并为一个任务使我们以前的playbook更加高效
- en: On this occasion, we simply skipped running the script altogether as the directory
    already existed before the playbook was even run. This saves time during the playbook
    execution and also prevents any potentially destructive actions that might occur
    from running a script.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们完全跳过了运行脚本，因为在playbook甚至运行之前目录已经存在。这样可以节省playbook执行时间，也可以防止运行脚本可能导致的任何潜在破坏性行为。
- en: Important Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Making good use of `creates` and `removes` will keep your playbooks concise
    and efficient.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 充分利用`creates`和`removes`将使您的playbook简洁高效。
- en: Suppressing a change
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抑制更改
- en: Sometimes, it can be desirable to completely suppress changes. This is often
    used when executing a command in order to gather data. The command execution isn't
    actually changing anything; instead, it's just gathering info, like the `ansible.builtin.setup` module.
    Suppressing changes on such tasks can be helpful for quickly determining whether
    a playbook run resulted in any actual change in the fleet.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，完全抑制更改是可取的。这经常用于执行命令以收集数据。命令执行实际上并没有改变任何东西；相反，它只是收集信息，就像`ansible.builtin.setup`模块一样。在这种任务上抑制更改可以帮助快速确定playbook运行是否导致了舰队中的任何实际更改。
- en: 'To suppress changes, simply use `false` as an argument to the `changed_when` task
    key. Let''s extend one of our previous examples to discover the active `iscsi` sessions
    to suppress changes:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要抑制更改，只需将`false`作为`changed_when`任务键的参数。让我们扩展我们以前的一个例子，以发现要抑制更改的活动`iscsi`会话：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, no matter what comes in the return data, Ansible will treat the task as `ok` rather
    than changed, as *Figure 7.12* shows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论返回的数据是什么，Ansible都会将任务视为`ok`而不是changed，如*图7.12*所示：
- en: '![Figure 7.12 – Suppressing changes in Ansible playbooks'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.12 – 抑制Ansible playbook中的更改'
- en: '](Images/B17462_07_12.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_12.jpg)'
- en: Figure 7.12 – Suppressing changes in Ansible playbooks
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 – 抑制Ansible playbook中的更改
- en: Thus, there are only two possible states to this task now—`failed` and `ok`.
    We have actually negated the possibility of a `changed` task result. Of course,
    failures when running code are a part of life, and it is important that we are
    able to handle these gracefully in our playbooks. In the next section, we will
    look at how this is achieved in Ansible.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个任务现在只有两种可能的状态——`failed`和`ok`。我们实际上否定了`changed`任务结果的可能性。当然，运行代码时出现故障是生活的一部分，重要的是我们能够在playbook中优雅地处理这些问题。在下一节中，我们将看看在Ansible中如何实现这一点。
- en: Error recovery
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误恢复
- en: While error conditions can be narrowly defined, there will be times when real
    errors happen. Ansible provides a method to react to true errors, a method that
    allows running additional tasks when an error occurs, defining specific tasks
    that always execute even if there was an error, or even both. This method is the
    **block** feature.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然错误条件可以被严格定义，但有时会发生真正的错误。Ansible提供了一种方法来对真正的错误做出反应，一种允许在发生错误时运行附加任务的方法，定义特定任务，即使出现错误也始终执行，或者两者都执行。这种方法就是**block**功能。
- en: The blocks feature, introduced with Ansible version 2.0, provides some additional
    structure to related sets of play task. Blocks can group tasks together into a
    logical unit, which can have task controls applied to the unit (or block) as a
    whole. In addition, a block of tasks can have optional `rescue` and `always` sections,
    which execute on condition of an error and regardless of the error state, respectively.
    We will explore how these work in the following two sections.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: block功能是在Ansible 2.0版本中引入的，它为相关的play任务集提供了一些额外的结构。块可以将任务组合成一个逻辑单元，该单元（或块）可以对整个单元（或块）应用任务控制。此外，一组任务的块可以有可选的`rescue`和`always`部分，它们分别在错误状态下执行和不管错误状态如何执行。我们将在接下来的两个部分中探讨它们的工作原理。
- en: Using the rescue section
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用rescue部分
- en: The `rescue` section of a block defines a logical unit of tasks that will be
    executed should an actual failure be encountered within the block. As Ansible
    performs the tasks within a block, executing from top to bottom as it normally
    does, when an actual failure is encountered, execution will jump to the first
    task of the `rescue` section of the block (if it exists; this section is optional).
    Then, tasks are performed from top to bottom until either the end of the `rescue`
    section is reached or another error is encountered.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`block`的`rescue`部分定义了一个逻辑单元的任务，当块内遇到实际失败时将执行。当Ansible执行块内的任务时，执行通常从上到下进行，当遇到实际失败时，执行将跳转到`rescue`部分的第一个任务（如果存在；此部分是可选的）。然后，任务将从上到下执行，直到到达`rescue`部分的末尾或遇到另一个错误为止。'
- en: After the `rescue` section completes, task execution continues with whatever
    comes after the block, as if there were no errors. This provides a way to gracefully
    handle errors, allowing `cleanup` tasks to be defined so that a system is not
    left in a completely broken state, and the rest of a play can continue. This is
    far cleaner than a complex set of task-registered results and task conditionals
    based on the error status.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`rescue`部分完成后，任务执行将继续进行，就像没有错误一样。这提供了一种优雅地处理错误的方式，允许定义`cleanup`任务，以便系统不会处于完全破碎的状态，并且play的其余部分可以继续。这比基于错误状态的一组复杂的任务注册结果和任务条件要干净得多。
- en: To demonstrate this, let's create a new task set inside a block. This task set
    will have an unhandled error in it that will cause execution to switch to the `rescue` section,
    from where we'll perform a `cleanup` task.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们在一个块内创建一个新的任务集。这个任务集中将有一个未处理的错误，这将导致执行切换到`rescue`部分，从那里我们将执行一个`cleanup`任务。
- en: 'We''ll also provide a task after the block to ensure execution continues. We''ll
    reuse the `error.yaml` playbook:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还将在块之后提供一个任务，以确保执行继续。我们将重用`error.yaml` playbook:'
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The two tasks listed in the `block` section are executed in the order in which
    they are listed. Should one of them result in a `failed` result, the following
    code shown in the `rescue` block will be executed:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`block`部分中列出的两个任务按照它们列出的顺序执行。如果其中一个导致`failed`结果，那么`rescue`块中显示的以下代码将被执行：'
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, this task is executed regardless of the earlier tasks. Note how the
    lower indentation level means it gets run at the same level as the block, rather
    than as part of the `block` structure:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，无论之前的任务如何，都会执行这个任务。请注意，较低的缩进级别意味着它与块的相同级别运行，而不是作为`block`结构的一部分运行：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Try executing this playbook to observe its behavior; add verbosity to the output
    as we have throughout this chapter to help you understand what is going on. When
    this play executes, the first task will result in an error, and the second task
    will be passed over. Execution continues with the `cleanup` tasks, and should
    look as in *Figure 7.13*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试执行此playbook以观察其行为；像我们在本章中一样，向输出添加详细信息，以帮助您理解发生了什么。当此play执行时，第一个任务将导致错误，并且第二个任务将被跳过。执行将继续进行`cleanup`任务，并且应该如*图7.13*所示：
- en: '![Figure 7.13 – Executing a playbook containing a block with a rescue section'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.13 - 执行包含救援部分的块的playbook'
- en: '](Images/B17462_07_13.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_13.jpg)'
- en: Figure 7.13 – Executing a playbook containing a block with a rescue section
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 - 执行包含救援部分的块的playbook
- en: Not only was the `rescue` section executed, but the rest of the play completed as
    well, and the whole `ansible-playbook` execution was considered successful in
    spite of the earlier task failure inside the block. Let's build on this example
    in the next section by looking at the `always` section of a block.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅执行了`rescue`部分，而且整个play也完成了，并且整个`ansible-playbook`执行被认为是成功的，尽管块内的先前任务失败。让我们在下一节中通过查看块的`always`部分来扩展这个例子。
- en: Using the always section
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用always部分
- en: In addition to `rescue`, we can also use another section, named `always`. This
    section of a block will always be executed irrespective of whether there were
    errors. This feature is handy for ensuring that the state of a system is always left
    functional, irrespective of whether a block of tasks was successful. As some tasks
    of a block may be skipped due to an error, and a `rescue` section is only executed
    when there is an error, the `always` section provides the guarantee of task execution
    in every instance.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`rescue`，我们还可以使用另一个部分，名为`always`。块的这部分将始终执行，无论是否出现错误。这个功能对于确保系统状态始终保持功能非常方便，无论一组任务是否成功。由于一些块任务可能由于错误而被跳过，而`rescue`部分仅在出现错误时执行，`always`部分提供了在每种情况下执行任务的保证。
- en: 'Let''s extend our previous example and add an `always` section to our block:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们之前的例子，并向我们的块添加一个`always`部分：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Rerunning our playbook as in the previous section, we see the additional task
    displayed, as shown in *Figure 7.14*:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行我们的playbook，如前一节所示，我们可以看到额外的任务显示如下，如*图7.14*所示：
- en: '![Figure 7.14 – Running an Ansible playbook containing a block with both rescue
    and always sections'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.14 - 运行包含救援和always部分的Ansible playbook的块'
- en: '](Images/B17462_07_14.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_14.jpg)'
- en: Figure 7.14 – Running an Ansible playbook containing a block with both rescue
    and always sections
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 - 运行包含救援和always部分的Ansible playbook的块
- en: 'To verify that the `always` section does indeed always execute, we can alter
    the play so that the Git task is considered successful using the task conditionals
    we developed in the earlier section, *Defining an error condition*. The first
    part of this modified playbook is shown in the following snippet for your reference:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证`always`部分确实总是执行，我们可以修改play，以便使用我们在前一节中开发的任务条件来使Git任务被认为是成功的。修改后的play的第一部分如下所示，供您参考：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the changed `failed_when` condition, which will enable the `git` command
    to run without being considered a failure. The rest of the playbook (which should,
    by now, have been built up in the previous examples) remains unchanged.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意更改的`failed_when`条件，这将使`git`命令在不被视为失败的情况下运行。playbook的其余部分（到目前为止在先前的示例中已经构建起来）保持不变。
- en: 'This time, when we execute the playbook, our `rescue` section is skipped over,
    our previously masked-by-error task is executed, and our `always` block is still
    executed, as *Figure 7.15* demonstrates:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，当我们执行playbook时，我们的`rescue`部分被跳过，我们之前由于错误而被屏蔽的任务被执行，我们的`always`块仍然被执行，正如*图7.15*所示：
- en: '![Figure 7.15 – Executing a playbook containing a block with rescue and always
    sections but without task errors'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.15 - 执行一个包含救援和总是部分但没有任务错误的块的playbook'
- en: '](Images/B17462_07_15.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_15.jpg)'
- en: Figure 7.15 – Executing a playbook containing a block with rescue and always
    sections but without task errors
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 - 执行一个包含救援和总是部分但没有任务错误的块的playbook
- en: Note also that our previously lost task is now executed, as the failure condition for
    the `delete branch bad` task was changed such that it no longer fails in this
    play. In a similar manner, our `rescue` section is no longer needed, and all other
    tasks (including the `always` section) complete as expected. In the final part
    of our look at error recovery in Ansible, we'll see how to handle errors caused
    by unreliable environments.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '还要注意，我们之前丢失的任务现在已经被执行，因为`delete branch bad`任务的失败条件已经更改，因此在此播放中不再失败。类似地，我们的`rescue`部分不再需要，并且所有其他任务（包括`always`部分）都如预期地完成。在ansible中处理由不可靠环境引起的错误的最后部分中，我们将看到如何处理这些错误。 '
- en: Handling unreliable environments
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理不可靠的环境
- en: So far in this chapter, we have focused on gracefully handling errors, and changing
    the default behavior of Ansible with respect to changes and failures. This is
    all well and good for tasks, but what about if you are running Ansible in an unreliable
    environment? For example, poor or transient connectivity might be used to reach
    the managed hosts, or hosts might be down on a regular basis for some reason.
    The latter example might be a dynamically scaled environment that could be scaled
    up in times of high load and scaled back when demand is low to save on resources—hence
    you cannot guarantee that all hosts will be available at all times.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经专注于优雅地处理错误，并改变了ansible对于更改和失败的默认行为。这对于任务来说都很好，但是如果您在一个不可靠的环境中运行ansible呢？例如，可能使用较差或瞬时的连接来到达受管主机，或者由于某种原因主机可能经常宕机。后一种情况可能是一个动态扩展的环境，可以在高负载时扩展，并在需求低时缩减以节省资源-因此您无法保证所有主机始终可用。
- en: 'Luckily, a playbook keyword, `ignore_unreachable`, handles exactly these cases,
    and ensures that all tasks are attempted on our inventory even for hosts that
    get marked as unreachable during the execution of a task. This is in contrast
    to the default behavior where Ansible will stop processing tasks for a given host
    once the first error occurs. As in so many cases, this is best explained by means
    of an example, so let''s reuse the `error.yaml` playbook to create such a case:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，playbook关键字`ignore_unreachable`恰好处理这些情况，并确保在我们的清单上尝试所有任务，即使在执行任务期间标记为不可达的主机。这与默认行为相反，即当ansible发生第一个错误时，将停止处理给定主机的任务。就像在许多情况下一样，最好通过一个例子来解释，所以让我们重用`error.yaml`
    playbook来创建这样一个情况：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are going to try to delete the `badfeature` branch from a Git repository
    on two remote hosts as defined in our inventory. This inventory will look a little
    different from the others we have used throughout this book, as we will deliberately
    create two fictitious hosts that are unreachable. It doesn''t matter what you
    actually call these hosts, or what IP addresses you define, but for the example
    to work as described in this section, the hosts must not be reachable. My inventory
    file looks like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试从我们的清单中定义的两个远程主机的Git仓库中删除`badfeature`分支。这个清单将与本书中使用的其他清单有所不同，因为我们将故意创建两个不可达的虚构主机。这些主机的实际名称或定义的IP地址并不重要，但是为了使本节中描述的示例能够正常工作，这些主机必须是不可达的。我的清单文件如下所示：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we have deliberately created an inventory of hosts that don''t exist, we
    know they will get marked as `unreachable` as soon as the first task is attempted.
    In spite of this, there is a second task that absolutely must be attempted if
    at all possible. Let''s run the playbook as it is and see what happens; the output
    should look like that shown in *Figure 7.16*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们故意创建了一个不存在的主机清单，我们知道它们将在尝试第一个任务时被标记为不可达。尽管如此，在第二个任务中仍然有一个绝对必须尝试的任务。让我们按原样运行playbook，看看会发生什么；输出应该如*图7.16*所示：
- en: '![Figure 7.16 – Attempting a two-task play on an inventory with unreachable
    hosts'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.16 - 尝试在不可达主机清单上进行两个任务的播放'
- en: '](Images/B17462_07_16.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_16.jpg)'
- en: Figure 7.16 – Attempting a two-task play on an inventory with unreachable hosts
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 - 尝试在不可达主机清单上进行两个任务的播放
- en: 'As you can see from the output, the task called `important task` was never
    attempted—the play was aborted after the first task since the hosts were unreachable.
    However, let''s use our newly discovered flag to change this behavior. Change
    the code so that it looks like the code here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，名为`important task`的任务从未被尝试过-在第一个任务后播放被中止，因为主机不可达。然而，让我们使用我们新发现的标志来改变这种行为。将代码更改为如下所示：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This time, note that even though the hosts were unreachable on the first attempt,
    our second task is still executed, as *Figure 7.17* shows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，请注意，即使在第一次尝试时主机不可达，我们的第二个任务仍然被执行，正如*图7.17*所示：
- en: '![Figure 7.17 – Attempting the same two-task play on unreachable hosts, but
    this time ignoring reachability'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.17 - 尝试在不可达主机上进行相同的两个任务播放，但这次忽略可达性'
- en: '](Images/B17462_07_17.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_17.jpg)'
- en: Figure 7.17 – Attempting the same two-task play on unreachable hosts, but this
    time ignoring reachability
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17 - 尝试在不可达主机上进行相同的两个任务播放，但这次忽略可达性
- en: This is useful if, like the `debug` command, it might run locally, or perhaps
    it is vital and should be attempted even if connectivity was down on the first
    attempt. So far in this chapter, you have learned about the tools Ansible provides
    to handle a variety of error conditions with grace. Next, we will proceed to look
    at controlling the flow of tasks using loops—an especially important tool for
    making code concise and preventing repetition.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果像`debug`命令一样，它可能在本地运行，或者它是至关重要的，并且即使在第一次尝试时连接失败也应该尝试。到目前为止，在本章中，你已经了解了Ansible提供的处理各种错误条件的工具。接下来，我们将继续探讨使用循环来控制任务流程——这是使代码简洁并防止重复的特别重要的工具。
- en: Iterative tasks with loops
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用循环的迭代任务
- en: Loops deserve a special mention in this chapter. So far, we have focused on
    controlling the flow of a playbook in a top-to-bottom fashion—we have changed
    the various conditions that might be evaluated as the playbook runs, and we have
    also focused on creating concise, efficient code. What happens, however, if you
    have a single task, but need to run it against a list of data; for example, creating
    several user accounts, directories, or indeed something more complex?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 循环在本章中值得特别提及。到目前为止，我们已经专注于以自上而下的方式控制playbook的流程——我们已经改变了在playbook运行时可能被评估的各种条件，并且我们也专注于创建简洁、高效的代码。然而，如果你有一个单独的任务，但需要针对一组数据运行它会发生什么呢？例如，创建多个用户帐户、目录，或者更复杂的东西？
- en: Looping changed in Ansible 2.5—prior to this, loops were generally created with
    keywords such as `with_items` and you may still see this in legacy code. Although
    some backward compatibility remains, it is advisable to move to the newer `loop` keyword
    instead.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 循环在Ansible 2.5中发生了变化——在此之前，循环通常是使用`with_items`等关键字创建的，你可能仍然在旧代码中看到这种情况。尽管一些向后兼容性仍然存在，但建议使用更新的`loop`关键字。
- en: 'Let''s take a simple example—we need to create two directories. Create `loop.yaml` as
    follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个简单的例子——我们需要创建两个目录。创建`loop.yaml`如下：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we run this, as expected, our two directories get created, as *Figure
    7.18* shows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个时，如预期的那样，我们的两个目录被创建了，就像*图7.18*所示：
- en: '![Figure 7.18 – Running a simple playbook to create two directories'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.18 – 运行一个简单的playbook来创建两个目录'
- en: '](Images/B17462_07_18.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_18.jpg)'
- en: Figure 7.18 – Running a simple playbook to create two directories
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18 – 运行一个简单的playbook来创建两个目录
- en: 'However, you can see this code is repetitive and inefficient. Instead, we could
    change it to something like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以看到这段代码是重复的和低效的。相反，我们可以将其改为以下内容：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note the use of the special `item` variable, which is now used to define the path from
    the `loop` items at the bottom of the task. Now, when we run this code, the output
    looks somewhat different, as *Figure 7.19* shows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意特殊的`item`变量的使用，它现在用于定义任务底部的`loop`项的`path`。现在，当我们运行这段代码时，输出看起来有些不同，就像*图7.19*所示：
- en: '![Figure 7.19 – A playbook to create the same two directories, but this time
    using'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.19 – 一个用循环创建相同两个目录的playbook'
- en: a loop for more efficient code
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于更高效的代码的循环
- en: '](Images/B17462_07_19.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_19.jpg)'
- en: Figure 7.19 – A playbook to create the same two directories, but this time using
    a loop for more efficient code
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19 – 一个用循环创建相同两个目录的playbook，这次使用循环以获得更高效的代码
- en: The two directories were still created exactly as before, but this time within
    a single task. This makes our playbooks much more concise and efficient. Ansible
    offers many more powerful looping options, including nested loops and the ability
    to create loops that will carry on until a given criterion is met (often referred
    to as `do until` loops in other languages), as opposed to a specific limited set
    of data.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个目录仍然像以前一样被创建，但这次是在一个任务中。这使得我们的playbook更加简洁和高效。Ansible提供了许多更强大的循环选项，包括嵌套循环和创建循环，直到满足给定条件（在其他语言中通常称为`do
    until`循环），而不是特定的有限数据集。
- en: '`do until` loops are incredibly useful when waiting for a certain condition
    to be met. For example, if we wanted to wait until a flag file is written to the
    filesystem, we could use the `ansible.builtin.stat` module to query the file,
    register the result of the module run to a variable, and then run this in a loop
    until the condition that the file exists is met. The following code fragment shows
    exactly this—it will loop (`retries`) five times, with a 10-second delay between
    each retry:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`do until`循环在等待满足某个条件时非常有用。例如，如果我们想要等待直到文件系统写入了一个标志文件，我们可以使用`ansible.builtin.stat`模块来查询文件，将模块运行的结果注册到一个变量中，然后在循环中运行，直到满足文件存在的条件。以下代码片段正是这样做的——它将循环（`retries`）五次，每次重试之间间隔10秒：'
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Nested loops can be created in one of two ways—either by iterating over nested
    lists or by iterating over an included tasks file. For example, let''s assume
    we want to create two new files, each in two paths (as defined by two lists in
    Ansible). Our code might look like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套循环可以通过两种方式创建——要么通过对嵌套列表进行迭代，要么通过对包含的任务文件进行迭代。例如，假设我们想要在两个路径中分别创建两个新文件（由Ansible中的两个列表定义）。我们的代码可能是这样的：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we have used the `product` Jinja2 filter to create a nested list out
    of the two variable lists, which `loop` then faithfully iterates for us. Running
    this playbook should yield output that looks like that in *Figure 7.20*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`product` Jinja2过滤器，将两个变量列表创建为嵌套列表，然后`loop`忠实地为我们迭代。运行这个playbook应该会产生类似*图7.20*中的输出：
- en: '![Figure 7.20 – Running a playbook using a nested loop built with the product
    Jinja2 filter'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.20 – 使用product Jinja2过滤器构建嵌套循环运行playbook'
- en: '](Images/B17462_07_20.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_20.jpg)'
- en: Figure 7.20 – Running a playbook using a nested loop built with the product
    Jinja2 filter
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20 – 使用product Jinja2过滤器构建嵌套循环运行playbook
- en: 'You can also create a nested loop by including an external tasks file within
    an outer loop and then placing an inner loop within the tasks file. Now, if you
    do this without doing anything further, both loops will use the `item` loop variable,
    which of course will clash. To prevent this from being an issue, it is necessary
    to use one of the special `loop_control` parameters to change the loop variable
    name for the outer loop. Thus, using the same header code and variables as before,
    we could change our original task to the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在外部循环中包含一个外部任务文件，然后在任务文件中放置一个内部循环来创建嵌套循环。现在，如果您这样做而不做任何进一步的操作，两个循环都将使用`item`循环变量，这当然会发生冲突。为了防止这成为一个问题，有必要使用特殊的`loop_control`参数之一来更改外部循环的循环变量名称。因此，使用与之前相同的标题代码和变量，我们可以将我们的原始任务更改为以下内容：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The included tasks file would then look like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后包含的任务文件将如下所示：
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This code performs exactly the same function as the first nested loop example,
    but is a little more cumbersome as it requires an external tasks file. In addition,
    you will see from the screenshot in *Figure 7.21* that the way that it operates
    is somewhat different. This is important to factor in when you are building nested
    loops as this may (or may not) be what you want:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行的功能与第一个嵌套循环示例完全相同，但稍微麻烦一些，因为它需要一个外部任务文件。此外，您将从*图7.21*的屏幕截图中看到它的操作方式有些不同。在构建嵌套循环时，这一点很重要，因为这可能（或可能不）是您想要的：
- en: '![Figure 7.21 – Building nested loops in Ansible through an included tasks
    file, using the loop_control variable'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.21 - 通过包含的任务文件在Ansible中构建嵌套循环，使用loop_control变量'
- en: '](Images/B17462_07_21.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_07_21.jpg)'
- en: Figure 7.21 – Building nested loops in Ansible through an included tasks file,
    using the loop_control variable
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21 - 通过包含的任务文件在Ansible中构建嵌套循环，使用loop_control变量
- en: It could be said that it's easier to read this format, though, and ultimately
    it is up to you to determine which you prefer for your needs, and indeed whether
    one is more suitable for you than the other. Full details of loop creation techniques
    and parameters are available in the Ansible documentation here: [https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说这种格式更容易阅读，但最终由您决定哪种更适合您的需求，以及是否有一种比另一种更适合您。有关循环创建技术和参数的完整详细信息，请参阅Ansible文档：[https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html)。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned that it is possible to define specifically how
    Ansible perceives a failure or a change when a specific task is run, how to use
    blocks to gracefully handle errors and perform cleanup, and how to write tight,
    efficient code using loops.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解到可以具体定义Ansible在运行特定任务时如何感知失败或更改，如何使用块来优雅地处理错误和执行清理，并且如何使用循环编写紧凑高效的代码。
- en: As a result, you should now be able to alter any given task to provide specific
    conditions under which Ansible will fail it or consider a change successful. This
    is incredibly valuable when running shell commands, as we have demonstrated in
    this chapter, and also serves when defining specialized use cases for existing
    modules. You should also now be able to organize your Ansible tasks into blocks,
    ensuring that if failures do occur, recovery actions can be taken that would otherwise
    not need to be run. Finally, you should now be able to write tight, efficient
    Ansible playbooks using loops, removing the need for repetitive code and lengthy,
    inefficient playbooks.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您现在应该能够修改任何给定任务，以提供特定条件，使得Ansible在失败或者考虑更改成功时失败。当运行shell命令时，这是非常有价值的，正如我们在本章中所演示的，也适用于定义现有模块的专门用例。您现在还应该能够将您的Ansible任务组织成块，确保如果发生故障，可以采取恢复操作，否则不需要运行。最后，您现在应该能够使用循环编写紧凑高效的Ansible
    Playbook，消除重复代码和冗长低效的Playbook的需要。
- en: In the next chapter, we'll explore the use of roles for organizing tasks, files,
    variables, and other content.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用角色来组织任务、文件、变量和其他内容。
- en: Questions
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'By default, Ansible will stop processing further tasks for a given host after
    the first failure occurs:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible在给定主机的第一个失败发生后将停止处理进一步的任务：
- en: a) True
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: a) 真
- en: b) False
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: b) 假
- en: 'The `ansible.builtin.command` and `ansible.builtin.shell` modules'' default
    behavior is to only ever give a task status of `changed` or `failed`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible.builtin.command`和`ansible.builtin.shell`模块的默认行为是只给出任务状态为`changed`或`failed`：'
- en: a) True
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: a) 真
- en: b) False
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: b) 假
- en: You can store the results from a task using which Ansible keyword?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用哪个Ansible关键字存储任务的结果？
- en: a) `store:`
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: a) `store:`
- en: b) `variable:`
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: b) `variable:`
- en: c) `register:`
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: c) `register:`
- en: d) `save:`
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: d) `save:`
- en: Which of the following directives can be used to change the failure condition
    of a task?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个指令可以用来改变任务的失败条件？
- en: a) `error_if:`
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: a) `error_if:`
- en: b) `failed_if:`
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: b) `failed_if:`
- en: c) `error_when:`
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: c) `error_when:`
- en: d) `failed_when:`
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: d) `failed_when:`
- en: You can combine multiple conditional statements in Ansible using which of the
    following?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下哪个来组合多个条件语句？
- en: a) `and`
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: a) `and`
- en: b) `or`
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: b) `或`
- en: c) The YAML list format (which works the same as a logical `AND`)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: c) YAML列表格式（与逻辑`AND`相同）
- en: d) All of the above
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: d) 以上所有
- en: Changes can be suppressed with which of the following?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个可以抑制更改？
- en: 'a) `suppress_changed: true`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'a) `suppress_changed: true`'
- en: 'b) `changed_when: false`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'b) `changed_when: false`'
- en: 'c) `changed: false`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'c) `changed: false`'
- en: 'd) `failed_when: false`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 'd) `failed_when: false`'
- en: 'In a `block` section, all tasks are executed in order on all hosts:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`block`部分中，所有任务都按顺序在所有主机上执行：
- en: a) Until the first error occurs
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: a) 直到发生第一个错误
- en: b) Regardless of any error condition
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: b) 无论任何错误条件
- en: Which optional section of a block gets run only if an error occurs in the block
    tasks?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块任务中的哪个可选部分只有在块任务中发生错误时才运行？
- en: a) `recover`
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: a) `recover`
- en: b) `rescue`
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: b) `rescue`
- en: c) `always`
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: c) `always`
- en: d) `on_error`
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: d) `on_error`
- en: 'Tasks in the `always` section of a block are run:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块中的`always`部分中的任务将被运行：
- en: a) Regardless of what happened in either the block tasks or the `rescue` section
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: a) 无论发生了什么，无论是在块任务还是在“rescue”部分
- en: b) Only if the `rescue` section did not get run
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: b) 只有在“rescue”部分没有运行时
- en: c) Only if no errors were encountered
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: c) 只有在没有遇到错误时
- en: d) When called manually by the user
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: d) 当用户手动调用时
- en: 'The default name of the variable referencing the current element of a loop
    is:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环中引用当前元素的变量的默认名称是：
- en: a) `loopvar`
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: a) `loopvar`
- en: b) `loopitem`
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: b) `loopitem`
- en: c) `item`
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: c) `item`
- en: d) `val`
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: d) `val`
