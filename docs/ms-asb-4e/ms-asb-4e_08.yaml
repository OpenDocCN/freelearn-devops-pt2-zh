- en: '*Chapter 6*: Unlocking the Power of Jinja2 Templates'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：解锁Jinja2模板的力量'
- en: Manipulating configuration files by hand is a tedious and error-prone task.
    Equally, performing pattern matching to make changes to existing files is risky,
    and ensuring that the patterns are reliable and accurate can be time-consuming.
    Whether you are using Ansible to define configuration file content, perform variable
    substitution in tasks, evaluate conditional statements, or beyond, templating
    comes into play with nearly every Ansible playbook. In fact, given the importance
    of this task, it could be said that templating is the lifeblood of Ansible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 手动操作配置文件是一项繁琐且容易出错的任务。同样，执行模式匹配以对现有文件进行更改是有风险的，并且确保模式可靠和准确可能是耗时的。无论您是使用Ansible来定义配置文件内容、在任务中执行变量替换、评估条件语句，还是其他操作，模板化几乎在每个Ansible
    playbook中都发挥作用。事实上，鉴于这项任务的重要性，可以说模板化是Ansible的命脉。
- en: 'The templating engine employed by Ansible is Jinja2, which is a modern and
    designer-friendly templating language for Python. Jinja2 deserves its own book;
    however, in this chapter, we will cover some of the more common usage patterns
    of Jinja2 templating in Ansible to demonstrate the power it can bring to your
    playbooks. In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible使用的模板引擎是Jinja2，这是一种现代且设计友好的Python模板语言。Jinja2值得有一本专门的书；然而，在本章中，我们将介绍Jinja2模板在Ansible中的一些常见用法模式，以展示它可以为您的playbook带来的强大功能。在本章中，我们将涵盖以下主题：
- en: Control structures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制结构
- en: Data manipulation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据操作
- en: Comparing values
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较值
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples presented in this chapter, you will need a Linux machine
    running Ansible 4.3 or newer. Almost any flavor of Linux should do; for those
    interested in specifics, all the code presented in this chapter was tested on
    Ubuntu Server 20.04 LTS unless stated otherwise, and on Ansible 4.3\. The example
    code that accompanies this chapter can be downloaded from GitHub at [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter06).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章中提供的示例，您需要一台运行Ansible 4.3或更新版本的Linux机器。几乎任何Linux版本都可以；对于那些对具体细节感兴趣的人，本章中提供的所有代码都是在Ubuntu
    Server 20.04 LTS上测试的，除非另有说明，并且在Ansible 4.3上测试。本章附带的示例代码可以从GitHub上下载：[https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter06)。
- en: 'Check out the following video to view the Code in Action: [https://bit.ly/3lZHTM1](https://bit.ly/3lZHTM1)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码示例：[https://bit.ly/3lZHTM1](https://bit.ly/3lZHTM1)
- en: Control structures
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制结构
- en: In Jinja2, a control structure refers to the statements in a template that control
    the flow of the engine parsing the template. These structures include conditionals,
    loops, and macros. Within Jinja2 (assuming the defaults are in use), a control
    structure will appear inside blocks of `{% ... %}`. These opening and closing
    blocks alert the Jinja2 parser that a control statement has been provided instead
    of a normal string or variable name.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jinja2中，控制结构是指模板中控制引擎解析模板流程的语句。这些结构包括条件、循环和宏。在Jinja2中（假设使用默认值），控制结构将出现在`{%
    ... %}`块内。这些开放和关闭块会提醒Jinja2解析器，提供了一个控制语句，而不是一个普通的字符串或变量名。
- en: Conditionals
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'A conditional within a template creates a decision path. The engine will consider
    the conditional and choose from two or more potential blocks of code. There is
    always a minimum of two: a path if the conditional is met (evaluated as `true`),
    and either an explicitly defined `else` path if the conditional is not met (evaluated
    as `false`) or, alternatively, an implied `else` path consisting of an empty block.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中的条件语句创建了一个决策路径。引擎将考虑条件，并从两个或更多潜在的代码块中进行选择。至少有两个：如果条件满足（评估为`true`）的路径，以及如果条件不满足（评估为`false`）的显式定义的`else`路径，或者另外一个隐含的`else`路径，其中包含一个空块。
- en: 'The statement for a conditional is the `if` statement. This statement works
    in the same way as it does in Python. An `if` statement can be combined with one
    or more optional `elif` statements and an optional final `else`, and, unlike Python,
    it requires an explicit `endif`. The following example shows a config file template
    snippet that combines both regular variable replacement and an `if else` structure:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句是`if`语句。这个语句的工作方式与Python中的工作方式相同。`if`语句可以与一个或多个可选的`elif`语句和一个可选的最终`else`结合使用，并且，与Python不同，它需要一个显式的`endif`。下面的示例显示了一个配置文件模板片段，结合了常规变量替换和`if
    else`结构：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we check the `feature.enabled` variable to see whether it exists
    and that it has not been set to `False`. If this is `True`, then the `feature
    = True` text is used; otherwise, the `feature = False` text is used. Outside of
    this control block, the parser performs a normal variable substitution for the
    variables inside the curly braces. Multiple paths can be defined by using an `elif` statement,
    which presents the parser with another test to perform should the previous tests
    equate to `False`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们检查`feature.enabled`变量是否存在，并且它没有被设置为`False`。如果是`True`，那么就使用`feature
    = True`文本；否则，使用`feature = False`文本。在这个控制块之外，解析器对大括号内的变量执行正常的变量替换。可以使用`elif`语句定义多个路径，这会给解析器提供另一个测试，如果前面的测试结果为`False`。
- en: 'To demonstrate the rendering of the template and variable substitution, we''ll
    save the example template as `demo.j2`. Then, we''ll create a playbook, named `template-demo.yaml`, that
    defines the variables in use and then uses a `template` lookup as part of a `ansible.builtin.pause`
    task to display the rendered template on the screen:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示模板和变量替换的渲染，我们将把示例模板保存为`demo.j2`。然后，我们将创建一个名为`template-demo.yaml`的playbook，定义要使用的变量，然后使用`template`查找作为`ansible.builtin.pause`任务的一部分来在屏幕上显示渲染后的模板：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Executing this playbook will display the rendered template on the screen while
    waiting for the input. You can use the following command to execute it:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此playbook将在屏幕上显示渲染的模板，并等待输入。您可以使用以下命令来执行它：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Simply press *Enter* to run the playbook, as shown in *Figure 6.1*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 只需按*Enter*运行playbook，如*图6.1*所示：
- en: '![Figure 6.1 – Rendering a simple template with conditionals using Ansible'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1-使用Ansible渲染带条件的简单模板'
- en: '](Images/B17462_06_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_01.jpg)'
- en: Figure 6.1 – Rendering a simple template with conditionals using Ansible
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1-使用Ansible渲染简单的带条件模板
- en: 'Remembering the variable order of precedence for Ansible that we discussed
    in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The* *System
    Architecture and Design of Ansible 3*, we can override the value of `feature.enabled`
    to `False`. We can do this by using the `--extra-vars` (or `-e`) parameter when
    running the playbook; this is because extra variables have higher priority than
    playbook-defined variables. You can achieve this by running the playbook again,
    but this time, using the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们在[*第1章*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015)中讨论过的Ansible变量优先顺序，我们可以将`feature.enabled`的值覆盖为`False`。当运行playbook时，我们可以使用`--extra-vars`（或`-e`）参数来实现这一点；这是因为额外变量比playbook定义的变量具有更高的优先级。您可以通过再次运行playbook来实现这一点，但这次使用以下命令：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this instance, the output should be slightly different, as shown in *Figure
    6.2*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出应该略有不同，如*图6.2*所示：
- en: '![Figure 6.2 – Rendering a simple template with conditionals using Ansible
    while overriding a variable value'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2-使用Ansible渲染带条件的简单模板，同时覆盖变量值'
- en: '](Images/B17462_06_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_02.jpg)'
- en: Figure 6.2 – Rendering a simple template with conditionals using Ansible while
    overriding a variable value
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2-使用Ansible渲染带条件的简单模板，同时覆盖变量值
- en: As you can see from these simple tests, Jinja2 provides a very simple yet powerful
    way of defining data through conditionals in a template.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些简单的测试中可以看出，Jinja2提供了一种非常简单但强大的方式来通过模板中的条件来定义数据。
- en: Inline conditionals
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内联条件
- en: 'Note that `if` statements can be used inside inline expressions. This can be
    useful in some scenarios where additional new lines are not desired. Let''s construct
    a scenario where we need to define an API as either `cinder` or `cinderv2`, as shown in
    the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`if`语句可以在内联表达式中使用。在某些不希望有额外换行的情况下，这可能很有用。让我们构建一个场景，我们需要将API定义为`cinder`或`cinderv2`，如下所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example assumes that `api.v2` is defined as Boolean `True` or `False`.
    Inline `if` expressions follow the syntax of `<do something> if <conditional is
    true> else <do something else>`. In an inline `if` expression, there is an implied `else`;
    however, that implied `else` is meant to be evaluated as an undefined object,
    which will normally create an error. We can protect against this by defining an
    explicit `else`, which renders a zero-length string.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子假设`api.v2`被定义为布尔值`True`或`False`。内联`if`表达式遵循`<条件为真时做某事> if <条件为真> else <否则做某事>`的语法。在内联`if`表达式中，有一个隐含的`else`；然而，这个隐含的`else`意味着要被评估为未定义对象，这通常会创建一个错误。我们可以通过定义一个显式的`else`来保护它，它会渲染一个零长度的字符串。
- en: 'Let''s modify our playbook to demonstrate an inline conditional. This time,
    we''ll use the `debug` module to render the simple template, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的playbook来演示内联条件。这次，我们将使用`debug`模块来渲染简单的模板，如下所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice that, this time, we are not defining an external template file; the
    template is actually in line with the Ansible tasks. Execute the playbook using
    the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次我们没有定义外部模板文件；模板实际上是与Ansible任务一起的。使用以下命令执行playbook：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output should look similar to the one shown in *Figure 6.3*:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该与*图6.3*中显示的类似：
- en: '![Figure 6.3 – Running a playbook with an inline template'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3-使用内联模板运行playbook'
- en: '](Images/B17462_06_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_03.jpg)'
- en: Figure 6.3 – Running a playbook with an inline template
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3-使用内联模板运行playbook
- en: 'Now, just as we did in our earlier example, we''ll use Ansible''s extra variables
    to change the value of `api.v2` to `false` to see the effect this has on the rendering
    of the inline template. Execute the playbook again using the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像我们在之前的例子中所做的那样，我们将使用Ansible的额外变量将`api.v2`的值更改为`false`，以查看这对内联模板渲染的影响。再次使用以下命令执行playbook：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This time, the output should look similar to the one shown in *Figure 6.4*.
    Pay attention to how the rendered string has changed:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，输出应该与*图6.4*中显示的类似。注意渲染的字符串如何改变：
- en: '![Figure 6.4 – Running a playbook with an inline template while changing the
    behavior with extra variables'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4-使用内联模板运行playbook，同时使用额外变量改变行为'
- en: '](Images/B17462_06_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_04.jpg)'
- en: Figure 6.4 – Running a playbook with an inline template while changing the behavior
    with extra variables
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4-使用内联模板运行playbook，同时使用额外变量改变行为
- en: In this way, we can create very concise and powerful code that defines values based on
    an Ansible variable, just as we have demonstrated here.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以创建非常简洁和强大的代码，根据Ansible变量定义值，就像我们在这里演示的那样。
- en: Loops
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'A loop allows you to build dynamically created sections in template files.
    It is useful when you know you need to operate on an unknown number of items in
    the same way. To start a loop control structure, we use the `for` statement. Let''s
    demonstrate a simple way to loop over a list of directories where a fictional
    service might find data:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 循环允许您在模板文件中构建动态创建的部分。当您知道需要以相同方式操作未知数量的项目时，这是很有用的。要启动循环控制结构，我们使用`for`语句。让我们演示一种简单的方法，循环遍历一个虚构服务可能找到数据的目录列表：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: By default, the `{% %}` blocks print an empty line when the template is rendered.
    This might not be desirable in our output, but luckily, we can trim this by ending
    the block with `-%}` instead. Please refer to the official Jinja2 documentation
    at [https://jinja.palletsprojects.com/en/3.0.x/templates/#whitespace-control](https://jinja.palletsprojects.com/en/3.0.x/templates/#whitespace-control) for
    more details.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当模板被渲染时，`{% %}`块会打印一个空行。这可能在我们的输出中是不可取的，但幸运的是，我们可以通过在块的结尾使用`-%}`来修剪它。更多详情请参考官方的Jinja2文档[https://jinja.palletsprojects.com/en/3.0.x/templates/#whitespace-control](https://jinja.palletsprojects.com/en/3.0.x/templates/#whitespace-control)。
- en: 'In this example, we will get one `data_dir =` line per item within the `data_dirs` variable,
    assuming that `data_dirs` is a list with at least one item in it. If the variable
    is not a list (or another iterable type) or is not defined, an error will be generated.
    If the variable is an iterable type but is empty, then no lines will be generated.
    Jinja2 can handle this scenario and also allows substituting in a line when no
    items are found in the variable via an `else` statement. In the following example,
    let''s assume that `data_dirs` is an empty list:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将得到一个`data_dir =`行，每个`data_dirs`变量中的项目，假设`data_dirs`是一个至少有一个项目的列表。如果变量不是列表（或其他可迭代类型），或者未定义，将生成一个错误。如果变量是一个可迭代类型但是空的，那么将不会生成任何行。Jinja2可以处理这种情况，并且还允许通过`else`语句在变量中找不到项目时替换一行。在下面的例子中，让我们假设`data_dirs`是一个空列表：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can test this by modifying our playbook and template file again. We''ll
    create a template file called `demo-for.j2` with the template content listed earlier.
    Additionally, we will create a subtle variation on the playbook we used in our
    first example on conditionals to render the template and then pause for user input.
    The playbook file with the following code should be named `template-demo-for.yaml`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改我们的playbook和模板文件来测试这一点。我们将创建一个名为`demo-for.j2`的模板文件，其中包含前面列出的模板内容。此外，我们将在我们第一个条件渲染模板并暂停用户输入的示例中创建一个playbook文件。应该命名为`template-demo-for.yaml`，并包含以下代码：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once you have created these two files, you can then run the playbook using
    the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这两个文件后，您可以使用以下命令运行playbook：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running our playbook will render the template and produce an output that is
    similar to the one shown in *Figure 6.5*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的playbook将渲染模板，并产生一个类似于*图6.5*所示的输出：
- en: '![Figure 6.5 – Rendering a template with a for loop in Ansible'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5 - 在Ansible中使用for循环渲染模板'
- en: '](Images/B17462_06_05.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_05.jpg)'
- en: Figure 6.5 – Rendering a template with a for loop in Ansible
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 - 在Ansible中使用for循环渲染模板
- en: As you can see, the `else` statement in the `for` loop handled the empty `data_dirs` list
    gracefully, which is exactly what we want in a playbook run.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在`for`循环中的`else`语句优雅地处理了空的`data_dirs`列表，这正是我们在playbook运行中想要的。
- en: Filtering loop items
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤循环项目
- en: 'Loops can be combined with conditionals, too. Within the loop structure, an `if` statement
    can be used to check a condition using the current loop item as part of the conditional.
    Let''s extend our example and prevent a user of this template from accidentally
    using `/` as a `data_dir` (any actions performed on the root directory of a filesystem
    can be dangerous, especially if they''re performed recursively):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 循环也可以与条件结合使用。在循环结构内部，可以使用`if`语句来检查当前循环项目作为条件的一部分。让我们扩展我们的例子，防止模板的用户意外使用`/`作为`data_dir`（对文件系统的根目录执行的任何操作都可能很危险，特别是如果它们是递归执行的）：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding example successfully filters out any `data_dirs` item that is `/`,
    but it requires far more typing than should be necessary. Jinja2 provides a convenient
    way that allows you to filter loop items easily as part of the `for` statement.
    Let''s repeat the previous example using this convenience:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子成功地过滤掉了任何`data_dirs`中是`/`的项目，但这需要的输入比必要的要多得多。Jinja2提供了一种方便的方法，允许你在`for`语句中轻松地过滤循环项目。让我们使用这种便利来重复前面的例子：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, not only does this structure require less typing, but it also correctly
    counts the loops, which we'll learn about in the next section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这种结构不仅需要输入更少，而且还正确计算了循环次数，我们将在下一节中学习。
- en: Loop indexing
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环索引
- en: 'Loop counting is provided for free, yielding an index of the current iteration
    of the loop. As variables, they can be accessed in a few different ways. The following
    table outlines the ways they can be referenced:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 循环计数是免费提供的，可以得到当前循环迭代的索引。作为变量，它们可以以几种不同的方式访问。以下表格概述了它们可以被引用的方式：
- en: '![](Images/Table_01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/Table_01.jpg)'
- en: 'Having information related to the position inside the loop can help with the
    logic around what content to render. Considering our previous examples, rather
    than rendering multiple lines of `data_dir` to express each data directory, instead,
    we could provide a single line with comma-separated values. Without having access
    to loop iteration data, this would be difficult. However, by using this data,
    it can be straightforward. For the sake of simplicity, this example assumes a
    trailing comma after the last item is allowed, and that any white space (newlines)
    between items is also allowed:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有关循环内部位置的信息可以帮助确定要渲染的内容。考虑到我们之前的例子，我们可以提供一个单行，其中包含逗号分隔的值，而不是渲染多行`data_dir`来表示每个数据目录。如果没有访问循环迭代数据，这将是困难的。然而，通过使用这些数据，可以变得简单。为了简单起见，本例假设允许在最后一项后面加上逗号，并且允许在项目之间有任何空格（换行符）：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding example made use of the `loop.first` variable to determine whether
    it needed to render the `data_dir =` part, or if it just needed to render the
    appropriately spaced padded directory. By using a filter in the `for` statement,
    we get a correct value for `loop.first`, even if the first item in `data_dirs` is
    an undesired `/`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子使用了`loop.first`变量来确定是否需要渲染`data_dir =`部分，或者是否只需要渲染适当间距的目录。通过在`for`语句中使用过滤器，我们可以得到`loop.first`的正确值，即使`data_dirs`中的第一项是不需要的`/`。
- en: Important note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Take a look at the indentation on the first `else` statement – why did we do
    that? The answer is all to do with white space control in Jinja2 when it is rendered.
    Put simply, if you don't indent the control statement (for example, an `if` or
    `else` statement) that precedes the template content you wish to render, the template
    content will have all the white space to the left trimmed out; therefore, our
    subsequent directory entries would not be indented at all. Indentation is vitally
    important in some files (including YAML and Python!), and so, this is a small
    but vitally important nuance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下第一个`else`语句的缩进 - 为什么我们要这样做？答案与Jinja2中的空格控制有关。简单地说，如果您不缩进控制语句（例如`if`或`else`语句），那么您希望渲染的模板内容将会将左侧的所有空格修剪掉；因此，我们随后的目录条目将不会有任何缩进。在某些文件中（包括YAML和Python），缩进非常重要，因此这是一个小但非常重要的细微差别。
- en: 'To test this, we''ll create a new template file, named `demo-for.j2`, with
    the contents listed earlier. Additionally, we''ll modify `template-demo-for.yaml` to
    define some `data_dirs`, including one of the `/`, which should be filtered out:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们将创建一个名为`demo-for.j2`的新模板文件，其中包含前面列出的内容。此外，我们将修改`template-demo-for.yaml`以定义一些`data_dirs`，包括一个`/`，应该被过滤掉：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can execute the playbook using the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令执行playbook：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When it runs, we should see our rendered content, as shown in *Figure 6.6*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当它运行时，我们应该看到我们渲染的内容，如*图6.6*所示：
- en: '![Figure 6.6 – Rendering a template using a for loop in Ansible while making
    use of loop indexing'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6 - 在Ansible中使用for循环渲染模板，同时利用循环索引'
- en: '](Images/B17462_06_06.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_06.jpg)'
- en: Figure 6.6 – Rendering a template using a for loop in Ansible while making use
    of loop indexing
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 - 在Ansible中使用for循环渲染模板，同时利用循环索引
- en: 'If, in the preceding example, trailing commas were not allowed, we could utilize inline `if` statements
    to determine whether we''re done with the loop and render the commas correctly.
    You can view this in the following enhancement to the preceding template code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果不允许有尾随逗号，我们可以利用内联`if`语句来确定我们是否已经完成循环并正确地渲染逗号。您可以在前面模板代码的以下增强版本中查看这一点：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using inline `if` statements allow us to construct a template that will only
    render a comma if there are more items in the loop that passed our initial filter.
    Once more, we''ll update `demo-for.j2` with the earlier content and execute the
    playbook using the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联`if`语句允许我们构建一个模板，只有在循环中有更多项目通过我们的初始过滤时才会渲染逗号。再次，我们将使用前面的内容更新`demo-for.j2`并使用以下命令执行playbook：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the rendered template should look similar to the one shown in
    *Figure 6.7*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染模板的输出应该与*图6.7*中显示的类似：
- en: '![Figure 6.7 – Rendering a template with a for loop in Ansible, making extended
    use of loop indexing'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7 - 在Ansible中使用for循环渲染模板，扩展使用循环索引'
- en: '](Images/B17462_06_07.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_07.jpg)'
- en: Figure 6.7 – Rendering a template with a for loop in Ansible, making extended
    use of loop indexing
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 - 在Ansible中使用for循环渲染模板，扩展使用循环索引
- en: The output is pretty much the same as before. However, this time, our template
    evaluates whether to place a comma after each value of `dir` in the loop using
    the inline `if` statement, removing the stray comma at the end of the final value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 输出基本上与以前一样。但是，这一次，我们的模板使用内联`if`语句评估是否在循环中的每个`dir`值后放置逗号，从而删除最终值末尾的多余逗号。
- en: Macros
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宏
- en: 'An astute reader will have noticed that, in the previous example, we had some
    repeated code. Repeating code is the enemy of any developer, and thankfully, Jinja2
    has a way to help! A macro is like a function in a regular programming language:
    it''s a way to define a reusable idiom. A macro is defined inside a `{% macro
    ... %} ... {% endmacro %}` block. It has a name and can take zero or more arguments.
    Code within a macro does not inherit the namespace of the block that is calling
    the macro, so all arguments must be explicitly passed in. Macros are called within
    curly brace blocks by name, and with zero or more arguments passed in via parentheses.
    Let''s create a simple macro named `comma` to take the place of our repeating
    code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 敏锐的读者会注意到，在前面的例子中，我们有一些重复的代码。重复的代码是任何开发人员的敌人，幸运的是，Jinja2有一种方法可以帮助！宏就像常规编程语言中的函数：它是定义可重用习语的一种方式。宏在`{%
    macro ... %} ... {% endmacro %}`块内定义。它有一个名称，可以接受零个或多个参数。宏内的代码不会继承调用宏的块的命名空间，因此所有参数必须显式传递。宏通过名称在花括号块内调用，并通过括号传递零个或多个参数。让我们创建一个名为`comma`的简单宏，以取代我们重复的代码：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Calling `comma` and passing it in the loop object allows the macro to examine
    the loop and decide whether a comma should be omitted or not.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`comma`并将循环对象传递给宏，允许宏检查循环并决定是否应省略逗号。
- en: Macro variables
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 宏变量
- en: 'Macros have access to any positional or keyword argument passed along when
    calling the macro. Positional arguments are arguments that are assigned to variables
    based on the order they are provided, while keyword arguments are unordered and
    explicitly assign data to variable names. Keyword arguments can also have a default
    value if they aren''t defined when the macro is called. There are three additional
    special variables that are available:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 宏在调用宏时可以访问传递的任何位置或关键字参数。位置参数是根据它们提供的顺序分配给变量的参数，而关键字参数是无序的，并明确地将数据分配给变量名。如果在调用宏时未定义关键字参数，关键字参数也可以具有默认值。还有三个额外的特殊变量可用：
- en: '`varargs`: This is a holding place for additional unexpected positional arguments
    that are passed along to the macro. These positional argument values will make
    up the `varargs` list.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`varargs`：这是一个额外的位置参数的占位符，这些参数将传递给宏。这些位置参数值将组成`varargs`列表。'
- en: '`kwargs`: This is the same as `varargs`; however, instead of holding extra
    positional argument values, it will hold a hash of extra keyword arguments and
    their associated values.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kwargs`：这与`varargs`相同；但是，它不是保存额外的位置参数值，而是保存额外关键字参数和它们的关联值的哈希。'
- en: '`caller`: This can be used to call back to a higher-level macro that might
    have called this macro (yes, macros can call other macros).'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`caller`：这可以用来回调到可能调用此宏的更高级宏（是的，宏可以调用其他宏）。'
- en: 'In addition to these three special variables, there are a number of variables
    that expose internal details regarding the macro itself. These are a bit complicated,
    but we''ll walk through their usage one by one. First, let''s take a look at a
    short description of each variable:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三个特殊变量之外，还有许多变量可以公开有关宏本身的内部细节。这些有点复杂，但我们将逐一介绍它们的用法。首先，让我们简要介绍一下每个变量：
- en: '`name`: This is the name of the macro itself.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是宏本身的名称。'
- en: '`arguments`: This is a tuple of the names of the arguments that the macro accepts.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments`：这是宏接受的参数的名称元组。'
- en: '`defaults`: This is a tuple of the default values.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaults`：这是默认值的元组。'
- en: '`catch_kwargs`: This is a Boolean that will be defined as `true` if the macro
    accesses (and, thus, accepts) the `kwargs` variable.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catch_kwargs`：这是一个布尔值，如果宏访问（因此接受）`kwargs`变量，则将其定义为`true`。'
- en: '`catch_varargs`: This is a Boolean that will be defined as `true` if the macro
    accesses (and, thus, accepts) the `varargs` variable.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catch_varargs`：这是一个布尔值，如果宏访问（因此接受）`varargs`变量，则将其定义为`true`。'
- en: '`caller`: This is a Boolean that will be defined as `true` if the macro accesses
    the `caller` variable (and, thus, could be called from another macro).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`caller`：这是一个布尔值，如果宏访问（因此可以从另一个宏调用）`caller`变量，则将其定义为`true`。'
- en: Similar to a class in Python, these variables need to be referenced via the
    name of the macro itself. Attempting to access these macros without prepending
    the name will result in undefined variables. Now, let's walk through and demonstrate
    the usage of each of them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python中的类类似，这些变量需要通过宏本身的名称引用。尝试在不加上名称的情况下访问这些宏将导致未定义的变量。现在，让我们逐一演示它们的用法。
- en: name
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 名称
- en: 'The `name` variable is actually very simple. It simply provides a way to access
    the name of the macro as a variable, perhaps for further manipulation or usage.
    The following template includes a macro that references the name of the macro
    to render it in the output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`变量实际上非常简单。它只是提供了一种访问宏名称作为变量的方式，也许用于进一步操作或使用。以下模板包括一个引用宏名称的宏，以在输出中呈现它：'
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s say we were to create `demo-macro.j2` with this template and the following `template-demo-macro.yaml` playbook:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要创建`demo-macro.j2`，其中包含此模板和以下`template-demo-macro.yaml` playbook：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will run this playbook using the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令运行此playbook：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When you run the playbook, your output should look similar to the one shown
    in *Figure 6.8*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行playbook时，您的输出应该类似于*图6.8*中显示的输出：
- en: '![Figure 6.8 – Rendering a template employing the name macro variable'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8 - 使用名称宏变量呈现模板'
- en: '](Images/B17462_06_08.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_08.jpg)'
- en: Figure 6.8 – Rendering a template employing the name macro variable
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 - 使用名称宏变量呈现模板
- en: As you see from this test run, our template is simply rendered with the macro
    name and nothing else, just as expected.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从这次测试运行中可以看出，我们的模板只是以宏名称呈现，没有其他内容，正如预期的那样。
- en: arguments
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数
- en: 'The `arguments` variable is a tuple of the arguments that the macro accepts.
    Note that these are the explicitly defined arguments, not the special `kwargs` or `varargs`.
    Our previous example would have rendered an empty tuple, `()`, so let''s modify
    it to get something else:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments`变量是宏接受的参数的元组。请注意，这些是明确定义的参数，而不是特殊的`kwargs`或`varargs`。我们之前的例子将呈现一个空元组`()`，所以让我们修改它以得到其他内容：'
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Running the same playbook as before, to render this template in the same manner,
    should yield the output shown in *Figure 6.9*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 像以前一样运行相同的playbook，以相同的方式呈现此模板，应该产生*图6.9*中显示的输出：
- en: '![Figure 6.9 – Running a playbook to render a Jinja2 template that prints its
    macro arguments'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9 - 运行一个playbook来呈现打印其宏参数的Jinja2模板'
- en: '](Images/B17462_06_09.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_09.jpg)'
- en: Figure 6.9 – Running a playbook to render a Jinja2 template that prints its
    macro arguments
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 - 运行一个playbook来呈现打印其宏参数的Jinja2模板
- en: In this example, we can clearly see that our template is rendered with the name
    of the arguments that the macro accepts (and not their values).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以清楚地看到我们的模板是使用宏接受的参数的名称（而不是它们的值）呈现的。
- en: Defaults
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 默认值
- en: The `defaults` variable is a tuple of the default values for any keyword arguments that
    the macro explicitly accepts. Although still present in the documentation for
    Jinja2 (at the time of writing, an issue is open to correct the documentation),
    this variable was removed from all versions of Jinja2 that are newer than version
    2.8.1\. If you need to access this variable, you will need to downgrade your Jinja2
    Python module to 2.8.1.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaults`变量是宏显式接受的任何关键字参数的默认值的元组。尽管在Jinja2的文档中仍然存在（在撰写本文时，有一个问题正在解决文档错误），但此变量已从所有新于版本2.8.1的Jinja2版本中删除。如果您需要访问此变量，您需要将您的Jinja2
    Python模块降级到2.8.1。'
- en: 'For those working with an older version of Jinja2, we can demonstrate this
    variable as follows; let''s change our macro to display the default values as
    well as the arguments:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用较旧版本的Jinja2的人，我们可以如下演示此变量；让我们将我们的宏更改为显示默认值以及参数：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can run our existing test playbook just as we have done before, but now
    using the newly updated template. If your version of Jinja2 supports the `defaults`
    variable, the output should look similar to the one shown in *Figure 6.10*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像以前一样运行我们现有的测试playbook，但现在使用新更新的模板。如果您的Jinja2版本支持`defaults`变量，输出应该类似于*图6.10*中显示的输出：
- en: '![Figure 6.10 – Rendering a Jinja2 template with the defaults and name macro
    variables'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.10 - 使用默认值和名称宏变量呈现Jinja2模板'
- en: '](Images/B17462_06_10.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_10.jpg)'
- en: Figure 6.10 – Rendering a Jinja2 template with the defaults and name macro variables
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 - 使用默认值和名称宏变量呈现Jinja2模板
- en: Here, we can see that the template is rendered with both the names and the default
    values of the arguments that are accepted by the macro.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到模板是使用宏接受的参数的名称和默认值进行渲染的。
- en: catch_kwargs
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: catch_kwargs
- en: 'This variable is only defined if the macro itself accesses the `kwargs` variable
    to catch any extra keyword arguments that might have been passed along. If defined,
    it will be set to `true`. Without accessing the `kwargs` variable, any extra keyword arguments in
    a call to the macro will result in an error when rendering the template. Likewise,
    accessing `catch_kwargs` without also accessing `kwargs` will result in an undefined
    error. Let''s modify our example template again so that we can pass along additional `kwargs`
    variables:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当宏本身访问`kwargs`变量以捕获可能传递的任何额外关键字参数时，此变量才被定义。如果定义了，它将被设置为`true`。如果没有访问`kwargs`变量，在调用宏时传递的任何额外关键字参数都将在渲染模板时导致错误。同样，访问`catch_kwargs`而不访问`kwargs`将导致未定义错误。让我们再次修改我们的示例模板，以便我们可以传递额外的`kwargs`变量：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can run our updated template through our existing rendering template again,
    using the same command as before. This time, the output should look similar to
    the one shown in *Figure 6.11*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次使用与之前相同的命令将更新后的模板通过现有的渲染模板运行。这次，输出应该类似于*图6.11*中显示的结果：
- en: '![Figure 6.11 – Rendering a template with the catch_kwargs variable'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11 - 渲染使用catch_kwargs变量的模板'
- en: '](Images/B17462_06_11.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_11.jpg)'
- en: Figure 6.11 – Rendering a template with the catch_kwargs variable
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 - 渲染使用catch_kwargs变量的模板
- en: As you can see from this output, the template does not give an error when an
    unexpected variable is passed to it and, instead, enables us to access the unexpected
    value(s) that were passed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中可以看出，当向模板传递意外变量时，模板不会产生错误，而是使我们能够访问传递的意外值。
- en: catch_varargs
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: catch_varargs
- en: 'Much like `catch_kwargs`, this variable only exists (and gets set to `true`) if
    the macro accesses the `varargs` variable. Modifying our example once more, we
    can see this in action:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与`catch_kwargs`类似，只有当宏访问`varargs`变量时，此变量才存在（并且设置为`true`）。再次修改我们的示例，我们可以看到它的作用：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The template''s rendered result should look similar to the one shown in *Figure
    6.12*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的渲染结果应该类似于*图6.12*中显示的结果：
- en: '![Figure 6.12 – Rendering a template that makes use of the varargs and catch_varargs
    macro variables'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.12 - 渲染使用varargs和catch_varargs宏变量的模板'
- en: '](Images/B17462_06_12.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_12.jpg)'
- en: Figure 6.12 – Rendering a template that makes use of the varargs and catch_varargs
    macro variables
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 - 渲染使用varargs和catch_varargs宏变量的模板
- en: Again, we can see that we were able to catch and render the unexpected value
    that was passed to the macro rather than returning an error on render, which would
    have happened if we hadn't used `catch_varargs`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以看到我们能够捕获并渲染传递给宏的意外值，而不是在渲染时返回错误，如果我们没有使用`catch_varargs`，那么将会发生错误。
- en: caller
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: caller
- en: The `caller` variable requires a bit more explanation. A macro can call out
    to another macro. This can be useful if the same chunk of the template will be
    used multiple times, but part of the internal data changes more than what could
    easily be passed as a macro parameter. The `caller` variable isn't exactly a variable;
    it's more of a reference back to the call to get the contents of that calling
    macro.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`caller`变量需要更多的解释。宏可以调用另一个宏。如果模板的同一部分将被多次使用，但内部数据的一部分更改比作为宏参数轻松传递的更多，这将非常有用。`caller`变量并不是一个确切的变量；它更像是一个引用，用于获取调用该调用宏的内容。'
- en: 'Let''s update our template to demonstrate its usage:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的模板来演示它的用法：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The rendered result should be similar to the one shown in *Figure 6.13*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染的结果应该类似于*图6.13*中显示的结果：
- en: '![Figure 6.13 – Rendering a template that makes use of the caller variable'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.13 - 渲染使用caller变量的模板'
- en: '](Images/B17462_06_13.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_13.jpg)'
- en: Figure 6.13 – Rendering a template that makes use of the caller variable
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 - 渲染使用caller变量的模板
- en: 'A call to a macro can still pass arguments to that macro; any combination of
    arguments or keyword arguments can be passed. If the macro utilizes `varargs` or `kwargs`,
    then more of those can be passed along as well. Additionally, a macro can pass
    arguments back to the caller, too! To demonstrate this, let''s create a bigger
    example. This time, our example will generate a file that''s suitable for an Ansible
    inventory:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 调用宏仍然可以向该宏传递参数；可以传递任意组合的参数或关键字参数。如果宏使用`varargs`或`kwargs`，那么也可以传递更多的参数。此外，宏还可以将参数传递回给调用者！为了演示这一点，让我们创建一个更大的示例。这次，我们的示例将生成一个适用于Ansible清单的文件：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once rendered using our test playbook, the result should be as shown in *Figure
    6.14*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的测试playbook进行渲染后，结果应该如*图6.14*中所示：
- en: '![Figure 6.14 – A more advanced example of a template rendered using the caller
    variable'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.14 - 使用caller变量渲染的模板的更高级示例'
- en: '](Images/B17462_06_14.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_14.jpg)'
- en: Figure 6.14 – A more advanced example of a template rendered using the caller
    variable
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 - 使用caller变量渲染的模板的更高级示例
- en: We called the `test` macro twice, once for each group we wanted to define. Each
    group had a subtly different set of `host` variables to apply, and those were
    defined in the call itself. We saved typing by having the macro call back to the
    caller, passing along the `host` variable from the current loop.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们两次调用了`test`宏，每次为我们想要定义的每个组调用一次。每个组都有略有不同的`host`变量集合要应用，并且这些变量是在调用本身中定义的。通过让宏回调到调用者，传递当前循环中的`host`变量，我们节省了输入。
- en: 'Control blocks provide programming power inside templates, allowing template
    authors to make their templates more efficient. The efficiency isn''t necessarily
    in the initial draft of the template; instead, efficiency really comes into play
    when a small change to a repeating value is needed. Now that we''ve looked, in
    detail, at building control structures within Jinja2, in the next section, we''ll
    move on to look at ways that this powerful templating language can help us with
    another common automation requirement: data manipulation.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 控制块在模板内提供了编程能力，允许模板作者使其模板更高效。效率不一定体现在模板的初始草稿中；相反，当需要对重复值进行小改动时，效率才真正发挥作用。现在我们已经详细地看了Jinja2中构建控制结构，接下来，我们将继续看看这种强大的模板语言如何帮助我们处理另一个常见的自动化需求：数据操作。
- en: Data manipulation
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据操作
- en: While control structures influence the flow of template processing, another
    tool exists that can help you to modify the contents of a variable. This tool
    is called a filter. Filters are the same as small functions, or methods, that
    can be run on the variable. Some filters operate without arguments, some take
    optional arguments, and some require arguments. Filters can be chained together
    as well, where the result of one filter action is fed into the next filter and
    then the next. Jinja2 comes with many built-in filters, and Ansible extends these
    with many custom filters that are available to you when using Jinja2 within templates,
    tasks, or any other place Ansible allows templating.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然控制结构影响模板处理的流程，但还有另一种工具可以帮助您修改变量的内容。这个工具叫做过滤器。过滤器与小函数或方法相同，可以在变量上运行。一些过滤器不带参数，一些带可选参数，一些需要参数。过滤器也可以链接在一起，一个过滤器操作的结果被馈送到下一个过滤器，然后是下一个。Jinja2带有许多内置过滤器，而Ansible通过许多自定义过滤器扩展了这些过滤器，当您在模板、任务或任何其他Ansible允许模板化的地方使用Jinja2时，这些过滤器都可以使用。
- en: Syntax
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法
- en: 'A filter is applied to a variable by way of the pipe symbol, `|`, followed
    by the name of the filter, and then any arguments for the filter inside parentheses.
    There can be a space between the variable name and the pipe symbol, as well as
    a space between the pipe symbol and the filter name. For example, if we wanted
    to apply the `lower` filter (which makes all the characters lowercase) to the `my_word` variable,
    we would use the following syntax:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过管道符号|将过滤器应用于变量，然后是过滤器的名称，以及括号内的过滤器参数。变量名称和管道符号之间可以有空格，管道符号和过滤器名称之间也可以有空格。例如，如果我们想将lower
    filter（使所有字符变为小写）应用于my_word变量，我们将使用以下语法：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Because the lower filter does not take any arguments, it is not necessary to
    attach an empty parentheses set to it. However, if we use a different filter that
    requires arguments, this all changes. Let''s use the `replace` filter, which allows
    us to replace all occurrences of a substring with another substring. In this example,
    we want to replace all occurrences of the `no` substring with `yes` in the `answers` variable:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因为lower filter不需要任何参数，所以不需要给它附加一个空的括号集。然而，如果我们使用一个需要参数的不同filter，情况就会改变。让我们使用replace
    filter，它允许我们用另一个子字符串替换所有出现的子字符串。在这个例子中，我们想要在answers变量中用yes替换所有出现的no子字符串：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Applying multiple filters is accomplished by simply adding more pipe symbols
    and more filter names. Let''s combine both `replace` and `lower` to demonstrate
    the syntax – the filters are applied in the sequence listed. In the following
    example, first, we replace all instances of the `no` substring with `yes`, and
    then convert the entire resulting string into lowercase:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地添加更多的管道符号和更多的过滤器名称来实现应用多个过滤器。让我们结合replace和lower来演示语法-过滤器按照列出的顺序应用。在下面的例子中，首先，我们将所有的no子字符串替换为yes，然后将整个结果字符串转换为小写：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As we are doing a case-sensitive string replacement, you might choose to perform
    the lowercase conversion first, as this means you won''t miss any instances of
    the word `no` regardless of the case – assuming, of course, this is the behavior
    you want! The code for this latter example would simply be as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在进行区分大小写的字符串替换，您可能选择先执行小写转换，这意味着您不会错过任何情况下的no单词-无论大小写如何-假设这是您想要的行为！后一个例子的代码将简单地如下所示：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can easily demonstrate this with a simple play that uses the `debug` command
    to render the line:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个简单的play来演示这一点，该play使用debug命令来渲染这一行：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we can execute the playbook using the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令执行playbook：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'All instances of the word `no` within our `answers` variable that have been
    declared in the code will be replaced with the word `yes`. Additionally, all characters
    will be converted into lowercase. The output should be similar to the one shown
    in *Figure 6.15*:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的answers变量中，代码中声明的所有单词no的实例都将被替换为单词yes。此外，所有字符都将转换为小写。输出应该类似于*图6.15*中显示的输出：
- en: '![Figure 6.15 – Demonstrating the use of chained filters in a simple Ansible
    playbook'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.15-演示在一个简单的Ansible playbook中使用链式过滤器'
- en: '](Images/B17462_06_15.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_15.jpg)'
- en: Figure 6.15 – Demonstrating the use of chained filters in a simple Ansible playbook
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15-演示在一个简单的Ansible playbook中使用链式过滤器
- en: Here, we can see that the playbook runs as expected and combines the two filters
    to operate on our test string, just as requested. Of course, these are just two
    of the filters available. In the next section, let's proceed to look at some of
    the more useful filters included with Jinja2.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到playbook按预期运行，并结合了两个过滤器来操作我们的测试字符串，就像我们要求的那样。当然，这只是可用的过滤器中的两个。在下一节中，让我们继续看一些Jinja2中包含的更有用的过滤器。
- en: Useful built-in filters
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的内置过滤器
- en: A full list of the filters that are built into Jinja2 can be found in the Jinja2
    documentation. At the time of writing this book, there are 50 built-in filters.
    We will take a look at some of the more commonly used filters next.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2内置的过滤器的完整列表可以在Jinja2文档中找到。在撰写本书时，有50个内置过滤器。接下来，我们将看一些更常用的过滤器。
- en: Tip
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to look at the list of all available filters, the Jinja2 documentation
    for the current version (which was available at the time of writing) can be found
    at [https://jinja.palletsprojects.com/en/3.0.x/templates/#builtin-filters](https://jinja.palletsprojects.com/en/3.0.x/templates/#builtin-filters).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看所有可用过滤器的列表，可以在当前版本的Jinja2文档中找到（在撰写时可用）：[https://jinja.palletsprojects.com/en/3.0.x/templates/#builtin-filters](https://jinja.palletsprojects.com/en/3.0.x/templates/#builtin-filters)。
- en: default
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: default
- en: 'The `default` filter is a way to provide a default value for an otherwise undefined
    variable, which, in turn, prevents Ansible from generating an error. It is shorthand
    for a complex `if` statement, which checks whether a variable is defined before
    trying to use it with an `else` clause to provide a different value. Let''s look
    at two examples that render the same thing. One uses the `if/else` structure,
    while the other uses the `default` filter:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`default` 过滤器是为了为一个未定义的变量提供默认值的一种方式，从而防止Ansible生成错误。它是一个复杂的`if`语句的简写，它在尝试使用`else`子句提供不同值之前检查变量是否已定义。让我们看两个渲染相同内容的例子。一个使用`if/else`结构，另一个使用`default`过滤器：'
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The rendered result of each of these examples is the same; however, the example
    using the `default` filter is much quicker to write and easier to read.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子的渲染结果是相同的；然而，使用`default`过滤器的例子写起来更快，阅读起来更容易。
- en: While `default` is very useful, proceed with caution if you are using the same
    variable in multiple locations. Changing a default value can become a hassle,
    and it might be more efficient to define the variable with a default at the play
    or role level.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`default`非常有用，但如果您在多个位置使用相同的变量，请谨慎操作。更改默认值可能会变得麻烦，定义默认值可能更有效，可以在play或角色级别定义变量的默认值。
- en: length
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: length
- en: 'The `length` filter will return the length of a sequence or a hash. In earlier
    editions of this book, we referenced a variable called `count`, which is an alias
    of `length` and accomplishes the same thing. This filter can be useful for performing
    any sort of math around the size of a set of hosts, or any other scenario where
    the count of some set needs to be known. Let''s create an example where we set
    a `max_threads` configuration entry to match the count of the hosts in the play:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`length` 过滤器将返回序列或哈希的长度。在本书的早期版本中，我们引用了一个名为`count`的变量，它是`length`的别名，完成了相同的功能。这个过滤器对于执行任何关于主机集大小的数学运算或任何其他需要知道某个集合计数的情况非常有用。让我们创建一个例子，其中我们将`max_threads`配置条目设置为与play中主机数量相匹配的计数：'
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This provides us with a nice, concise way of getting the number of hosts contained
    within the `play_hosts` variable and assigning the answer to the `max_threads` variable.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个简洁的方式来获取`play_hosts`变量中包含的主机数量，并将答案赋给`max_threads`变量。
- en: random
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: random
- en: 'The `random` filter is used to make a random selection from a sequence. Let''s
    use this filter to delegate a task to a random selection from the `db_servers` group:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`random` 过滤器用于从序列中进行随机选择。让我们使用这个过滤器将一个任务委派给`db_servers`组中的随机选择：'
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we can easily delegate this task to a single member of the `db_servers` group,
    which is picked at random using our filter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以很容易地将这个任务委派给`db_servers`组中的一个成员，使用我们的过滤器随机选择。
- en: round
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: round
- en: 'The `round` filter exists to round a number up or down. This can be useful
    if you need to perform floating-point math, and then turn the result into a rounded
    integer. The `round` filter takes optional arguments to define a precision (with
    a default of `0`) and a rounding method. The possible rounding methods are `common`
    (which rounds up or down and is the default), `ceil` (which always rounds up),
    and `floor` (which always rounds down). In this example, we''ll chain two filters
    together to round a math result to zero precision, and then turn that into an
    integer:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`round` 过滤器用于将数字四舍五入。如果您需要执行浮点数运算，然后将结果转换为四舍五入的整数，这可能很有用。`round` 过滤器接受可选参数来定义精度（默认为`0`）和舍入方法。可能的舍入方法有`common`（四舍五入，是默认值）、`ceil`（总是向上舍入）和`floor`（总是向下舍入）。在这个例子中，我们将两个过滤器链接在一起，将一个数学结果舍入到零精度，然后将其转换为整数：'
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Therefore, if the `math_result` variable was set to `3.4`, the output of the
    previous filter chain would be `3`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果`math_result`变量设置为`3.4`，则前一个过滤器链的输出将为`3`。
- en: Useful Ansible provided custom filters
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的Ansible提供的自定义过滤器
- en: While there are many filters provided with Jinja2, Ansible includes some additional
    filters that playbook authors might find particularly useful. We'll highlight
    these next.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Jinja2提供了许多过滤器，但Ansible还包括一些额外的过滤器，playbook作者可能会发现特别有用。我们将在下面重点介绍这些过滤器。
- en: Tip
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: These custom filters in Ansible change often between releases. They are worth
    reviewing, especially if you make heavy use of them. A full list of the custom
    Ansible filters is available at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible中的这些自定义过滤器在不同版本之间经常发生变化。它们值得审查，特别是如果您经常使用它们。自定义Ansible过滤器的完整列表可在[https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html)上找到。
- en: Filters related to task status
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与任务状态相关的过滤器
- en: Ansible tracks task data for each task. This data is used to determine whether
    a task has failed, resulted in a change, or was skipped altogether. Playbook authors
    can register the results of a task, and in previous versions of playbooks, they
    would have used filters to check the tasks' status. As of Ansible 2.9, this has
    been removed completely. So, if you have any legacy playbooks from earlier Ansible
    versions, you might need to update them accordingly.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible为每个任务跟踪任务数据。这些数据用于确定任务是否失败、是否导致更改或是否完全跳过。Playbook作者可以注册任务的结果，在先前版本的playbook中，他们将使用过滤器来检查任务的状态。从Ansible
    2.9开始，这完全被移除了。因此，如果您有来自早期Ansible版本的遗留playbook，您可能需要相应地进行更新。
- en: 'Before the release of Ansible 2.7, you would have used a conditional with a
    filter like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible 2.7发布之前，您可能会使用一个带有过滤器的条件语句，如下所示：
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You should now use the new syntax, which is shown in the following snippet.
    Note that the code in the following code block performs the same function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该使用新的语法，如下片段所示。请注意，以下代码块中的代码执行相同的功能：
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s view this in action in the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下代码中查看它的运行情况：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can run this playbook using the following command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令运行此playbook：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output is shown in *Figure 6.16*:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示在*图6.16*中：
- en: '![Figure 6.16 – Running an Ansible playbook with a conditional based on task
    status'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.16 – 根据任务状态运行Ansible playbook的条件'
- en: '](Images/B17462_06_16.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_16.jpg)'
- en: Figure 6.16 – Running an Ansible playbook with a conditional based on task status
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 – 根据任务状态运行Ansible playbook的条件
- en: As you can see, the `ansible.builtin.debug` statement resulted in `success`.
    So, we skipped the task to be run on a `change` and executed the one to be run
    on `success`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`ansible.builtin.debug`语句导致`success`。因此，我们跳过了要在`change`上运行的任务，并执行了要在`success`上运行的任务。
- en: shuffle
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: shuffle
- en: 'Similar to the `random` filter, the `shuffle` filter can be used to produce
    randomized results. Unlike the `random` filter, which selects one random choice from a
    list, the `shuffle` filter will shuffle the items in a sequence and return the
    full sequence:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与`random`过滤器类似，`shuffle`过滤器可用于生成随机结果。与从列表中选择一个随机选择的`random`过滤器不同，`shuffle`过滤器将对序列中的项目进行洗牌并返回完整的序列：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run this playbook using the following command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行此playbook：
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output is shown in *Figure 6.17*:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示在*图6.17*中：
- en: '![Figure 6.17 – Running a playbook that makes use of the shuffle filter'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.17 – 运行使用shuffle过滤器的playbook'
- en: '](Images/B17462_06_17.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_17.jpg)'
- en: Figure 6.17 – Running a playbook that makes use of the shuffle filter
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 – 运行使用shuffle过滤器的playbook
- en: As expected, the whole list returned but with the order shuffled. If you run
    the playbook repeatedly, you will see a different order of the returned list on
    each run. Try this for yourself!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，整个列表返回但顺序被打乱了。如果重复运行playbook，您将看到每次运行时返回列表的不同顺序。自己试试吧！
- en: Filters dealing with pathnames
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理路径名的过滤器
- en: Configuration management and orchestration frequently refer to pathnames, but
    often, only part of the path is desired. For example, we might need the full path
    to a file but not the filename itself. Or, perhaps we just need to extract the
    filename from a full path, ignoring the directories preceding it. Ansible provides
    a few filters to help with precisely these tasks, and we will examine them in
    the following sections.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理和编排经常涉及路径名，但通常只需要路径的一部分。例如，我们可能需要文件的完整路径，但不需要文件名本身。或者，我们只需要从完整路径中提取文件名，忽略其前面的目录。Ansible提供了一些过滤器来帮助处理这些任务，我们将在以下部分进行讨论。
- en: basename
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: basename
- en: 'Let''s say we have a requirement to work with just the filename from a full
    path. Of course, we could perform some complex pattern matching to do this. However,
    often, this results in code that is not easy to read and can be difficult to maintain.
    Luckily, Ansible provides a filter specifically for extracting the filename from
    a full path, as we will demonstrate next. In this example, we will use the `basename` filter
    to extract the filename from a full path:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个要求，只需使用完整路径中的文件名。当然，我们可以执行一些复杂的模式匹配来做到这一点。但是，通常情况下，这会导致代码难以阅读并且难以维护。幸运的是，Ansible提供了一个专门用于从完整路径中提取文件名的过滤器，我们将在下面进行演示。在这个例子中，我们将使用`basename`过滤器从完整路径中提取文件名：
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Run this playbook using the following command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行此playbook：
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output is shown in *Figure 6.18*:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示在*图6.18*中：
- en: '![Figure 6.18 – Running a playbook that makes use of the basename filter'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.18 – 运行使用basename过滤器的playbook'
- en: '](Images/B17462_06_18.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_18.jpg)'
- en: Figure 6.18 – Running a playbook that makes use of the basename filter
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 – 运行使用basename过滤器的playbook
- en: Here, you can see that just the filename was returned from the full path, as
    desired.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到只返回了所需的完整路径的文件名。
- en: dirname
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: dirname
- en: 'The inverse of `basename` is `dirname`. Instead of returning the final part
    of a path, `dirname` will return everything else (except the filename, which is
    the final part of the full path). Let''s change our previous play to use `dirname` and
    rerun it using the same command. The output should now look similar to the one
    shown in *Figure 6.19*:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`basename`的反义词是`dirname`。`dirname`不返回路径的最后部分，而是返回其他所有部分（除了文件名，文件名是完整路径的最后部分）。让我们更改之前的play以使用`dirname`，然后使用相同的命令重新运行它。输出现在应该与*图6.19*中显示的类似：'
- en: '![Figure 6.19 – Running a playbook using the dirname filter'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.19 – 使用dirname过滤器运行playbook'
- en: '](Images/B17462_06_19.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_19.jpg)'
- en: Figure 6.19 – Running a playbook using the dirname filter
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 – 使用dirname过滤器运行playbook
- en: Now, we have just the path of our variable, which could be extremely useful
    elsewhere in our playbook.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只有变量的路径，这在playbook的其他地方可能非常有用。
- en: expanduser
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: expanduser
- en: 'Often, paths to various things are supplied with a user shortcut, such as `~/.stackrc`.
    However, some tasks might require the full path to the file. Rather than the complicated
    command and register calls, the `expanduser` filter provides a way to expand the
    path to the full definition. In this example, the username is `jfreeman`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，各种东西的路径都使用用户快捷方式提供，例如`~/.stackrc`。但是，某些任务可能需要文件的完整路径。`expanduser`过滤器提供了一种将路径扩展到完整定义的方法，而不是复杂的命令和注册调用。在此示例中，用户名是`jfreeman`：
- en: '[PRE47]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can run this playbook with the same command as before, and the output should
    look similar to the one shown in *Figure 6.20*:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用与之前相同的命令运行此playbook，输出应该与*图6.20*中显示的类似：
- en: '![Figure 6.20 – Running a playbook using the expanduser filter'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.20 – 使用expanduser过滤器运行playbook'
- en: '](Images/B17462_06_20.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_20.jpg)'
- en: Figure 6.20 – Running a playbook using the expanduser filter
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20 – 使用expanduser过滤器运行playbook
- en: Here, we have successfully expanded the path, which could be useful for creating
    configuration files or performing other file operations that might need an absolute
    pathname rather than a relative pathname.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们成功地扩展了路径，这对于创建配置文件或执行其他可能需要绝对路径名而不是相对路径名的文件操作可能是有用的。
- en: Base64 encoding
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Base64编码
- en: When reading content from remote hosts, such as with the `ansible.builtin.slurp` module
    (which is used to read file content from remote hosts into a variable), the content
    will be Base64 encoded. To decode such content, Ansible provides a `b64decode` filter.
    Similarly, if running a task that requires Base64-encoded input, regular strings
    can be encoded using the `b64encode` filter.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 从远程主机读取内容时，例如使用`ansible.builtin.slurp`模块（用于将远程主机的文件内容读入变量中），内容将被Base64编码。为了解码这样的内容，Ansible提供了一个`b64decode`过滤器。同样，如果运行一个需要Base64编码输入的任务，常规字符串可以使用`b64encode`过滤器进行编码。
- en: 'Let''s use Ansible to create a test file, called `/tmp/derp`, which will contain
    a test string. Then, we''ll use the `ansible.builtin.slurp` module to obtain the
    file contents and decode them using the aforementioned filter:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Ansible创建一个名为`/tmp/derp`的测试文件，其中将包含一个测试字符串。然后，我们将使用`ansible.builtin.slurp`模块获取文件内容，并使用上述过滤器对其进行解码：
- en: '[PRE48]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you are working with the example code that accompanies this book, run the
    playbook using the following command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用本书附带的示例代码，可以使用以下命令运行playbook：
- en: '[PRE49]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output is shown in *Figure 6.21*:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示在*图6.21*中：
- en: '![Figure 6.21 – Running a playbook featuring the b64decode filter'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.21 - 运行包含b64decode过滤器的playbook'
- en: '](Images/B17462_06_21.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_21.jpg)'
- en: Figure 6.21 – Running a playbook featuring the b64decode filter
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21 - 运行包含b64decode过滤器的playbook
- en: Here, we successfully read the small file we created into a variable. Additionally,
    we can see the variable contents in Base64-encoded form (remember that this encoding
    was performed by the `ansible.builtin.slurp` module). We can then decode it using
    a filter to view the original file contents.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们成功地将创建的小文件读入一个变量中。此外，我们可以看到变量内容以Base64编码形式（请记住，这个编码是由`ansible.builtin.slurp`模块执行的）进行编码。然后，我们可以使用过滤器对其进行解码以查看原始文件内容。
- en: Searching for content
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索内容
- en: It is relatively common in Ansible to search a string for a substring. In particular,
    the common administrator task of running a command and grepping the output for
    a particular key piece of data is a reoccurring construct in many playbooks. While
    it's possible to replicate this with a shell task to execute a command, pipe the
    output into `grep`, and use careful handling of `failed_when` to catch the `grep` exit
    codes, a far better strategy is to use a command task, `register` the output,
    and then utilize the Ansible-provided **Regular Expression** (**regex**) filters
    in later conditionals.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible中，搜索字符串以查找子字符串是相对常见的。特别是，管理员常见的任务是运行命令并在输出中使用`grep`查找特定的关键数据片段，这在许多playbook中是一个常见的构造。虽然可以使用shell任务执行命令，将输出传递给`grep`，并使用`failed_when`的谨慎处理来捕获`grep`的退出代码，但更好的策略是使用命令任务`register`输出，然后在后续条件中使用Ansible提供的**正则表达式**（**regex**）过滤器。
- en: 'Let''s take a look at two examples: one using `ansible.builtin.shell`, the
    pipe, and the `grep` method, and another using the `search` test:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看两个例子：一个使用`ansible.builtin.shell`，管道和`grep`方法，另一个使用`search`测试：
- en: '[PRE50]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding example works by forcing Ansible to always see the task as successful
    but assumes that if the exit code from the shell is nonzero, then the `juno` string was
    not found in the output of the `neutron-manage` command. This construct is functional
    but complex to read, and it could mask real errors from the command. Let's try
    again using the `search` test.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子通过强制Ansible始终将任务视为成功来工作，但假设如果shell的退出代码为非零，则`juno`字符串未在`neutron-manage`命令的输出中找到。这种构造是功能性的，但阅读起来复杂，并且可能掩盖了来自命令的真实错误。让我们再试一次，使用`search`测试。
- en: 'As we previously mentioned, regarding the task status, using `search` on a
    string in Ansible is considered a test and is deprecated. Although it might read
    slightly odd, in order to be compliant with Ansible 2.9 and later versions, we
    must use the `is` keyword in place of the pipe when using `search` in this context:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，关于任务状态，使用`search`在Ansible中搜索字符串被认为是一个测试，并且已被弃用。尽管可能读起来有点奇怪，但为了符合Ansible
    2.9及更高版本，我们必须在这种情况下使用`is`关键字代替管道使用`search`：
- en: '[PRE51]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, we are requesting to run the task named `upgrade db` when `neutron_db_ver.stdout`
    does not contain the `juno` string. Once you get used to the concept of `when:
    not ... is`, you can see that this version is much cleaner to follow and does
    not mask errors from the first task.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们请求在`neutron_db_ver.stdout`不包含`juno`字符串时运行名为`upgrade db`的任务。一旦你习惯了`when:
    not ... is`的概念，你会发现这个版本更容易理解，并且不会掩盖第一个任务的错误。'
- en: The `search` filter searches a string and will return `True` if the substring
    is found anywhere inside the input string. However, if an exact complete match
    is desired instead, the `match` filter can be used. Full Python regex syntax can
    be utilized inside the `search`/`match` string.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`过滤器搜索字符串，如果在输入字符串的任何位置找到子字符串，则返回`True`。但是，如果需要精确完整匹配，可以使用`match`过滤器。在`search`/`match`字符串内可以利用完整的Python正则表达式语法。'
- en: Omitting undefined arguments
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 省略未定义的参数
- en: The `omit` variable requires a bit of explanation. Sometimes, when iterating
    over a hash of data to construct task arguments, it might be necessary to only
    provide some arguments for some of the items in the hash. Even though Jinja2 supports
    inline `if` statements to conditionally render parts of a line, this does not
    work well in an Ansible task. Traditionally, playbook authors would create multiple
    tasks, one for each set of potential arguments passed in, and use conditionals
    to sort the loop members between each task set. A recently added magic variable
    named `omit` solves this problem when used in conjunction with the `default` filter.
    The `omit` variable will remove the argument the variable was used with altogether.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`omit`变量需要一点解释。有时，在遍历数据哈希以构建任务参数时，可能只需要为哈希中的某些项目提供一些参数。即使Jinja2支持内联`if`语句来有条件地渲染一行的部分，但这在Ansible任务中效果不佳。传统上，playbook作者会创建多个任务，每个任务针对传入的一组潜在参数，并使用条件语句在每个任务集之间对循环成员进行排序。最近添加的魔术变量`omit`与`default`过滤器一起使用时解决了这个问题。`omit`变量将完全删除使用该变量的参数。'
- en: 'To illustrate how this works, let''s consider a scenario where we need to install
    a set of Python packages with `ansible.builtin.pip`. Some of the packages have
    a specific version, while others do not. These packages are in a list of hashes
    named `pips`. Each hash has a `name` key and, potentially, a `ver` key. Our first
    example utilizes two different tasks to complete the installation:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这是如何工作的，让我们考虑一个场景，我们需要使用`ansible.builtin.pip`安装一组Python包。一些包有特定版本，而其他包没有。这些包在一个名为`pips`的哈希列表中。每个哈希都有一个`name`键，可能还有一个`ver`键。我们的第一个示例利用了两个不同的任务来完成安装：
- en: '[PRE52]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This construct works, but the loop is iterated twice, and some of the iterations
    will be skipped in each task. The following example collapses the two tasks into
    one, and utilizes the `omit` variable:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构造方式可以工作，但是循环会被迭代两次，并且每个任务中的一些迭代将被跳过。下面的示例将两个任务合并为一个，并利用`omit`变量：
- en: '[PRE53]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This example is shorter, cleaner, and doesn't generate additional skipped tasks.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例更短、更清晰，不会生成额外的跳过任务。
- en: Python object methods
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python对象方法
- en: 'Jinja2 is a Python-based template engine, and so Python object methods are
    available within templates. Object methods are methods, or functions, that are
    directly accessible by the variable object (typically, a `string`, `list`, `int`,
    or `float`). A good way to think about this is as follows: if you were writing Python
    code and could write the variable, then a period, and then a method call, you
    would have access to do the same in Jinja2\. Within Ansible, only methods that
    return modified content or a Boolean are typically used. Let''s explore some common
    object methods that might be useful in Ansible.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2是一个基于Python的模板引擎，因此Python对象方法在模板中是可用的。对象方法是直接由变量对象（通常是`string`、`list`、`int`或`float`）访问的方法或函数。一个好的思路是：如果你在写Python代码时可以写变量，然后是一个句点，然后是一个方法调用，那么你在Jinja2中也可以做同样的事情。在Ansible中，通常只使用返回修改后的内容或布尔值的方法。让我们探索一些在Ansible中可能有用的常见对象方法。
- en: String methods
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串方法
- en: 'String methods can be used to return new strings, return a list of strings
    that have been modified in some way, or test a string for various conditions and
    return a Boolean. Some useful methods are as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串方法可以用来返回新的字符串，返回一组以某种方式被修改的字符串，或者测试字符串的各种条件并返回一个布尔值。一些有用的方法如下：
- en: '`endswith`: This determines whether the string ends with a substring.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endswith`：确定字符串是否以一个子字符串结尾。'
- en: '`startswith`: This is the same as `endswith` but from the start.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startswith`：与`endswith`相同，但是从开头开始。'
- en: '`split`: This splits the string on characters (the default is space) into a
    list of substrings.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`split`：将字符串按字符（默认为空格）分割成一个子字符串列表。'
- en: '`rsplit`: This is the same as `split`, but it starts from the end of the string
    and works backward.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rsplit`：与`split`相同，但是从字符串的末尾开始向后工作。'
- en: '`splitlines`: This splits the string at newlines into a list of substrings.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`splitlines`：将字符串在换行符处分割成一个子字符串列表。'
- en: '`upper`: This returns a copy of the string all in uppercase.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upper`：返回字符串的大写副本。'
- en: '`lower`: This returns a copy of the string all in lowercase.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lower`：返回字符串的小写副本。'
- en: '`capitalize`: This returns a copy of the string with just the first character
    in uppercase.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`capitalize`：返回字符串的副本，只有第一个字符是大写的。'
- en: 'We can create a simple playbook that will utilize some of these methods in
    a single task:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个简单的playbook，在一个任务中利用这些方法：
- en: '[PRE54]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you are using the example code that accompanies this book, run this playbook
    using the following command:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用本书附带的示例代码，请使用以下命令运行此playbook：
- en: '[PRE55]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output will look similar to the one shown in *Figure 6.22*:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于*图6.22*所示的内容：
- en: '![Figure 6.22 – Running a playbook that makes use of the Python string object
    methods'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.22 - 运行使用Python字符串对象方法的playbook'
- en: '](Images/B17462_06_22.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_22.jpg)'
- en: Figure 6.22 – Running a playbook that makes use of the Python string object
    methods
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22 - 运行使用Python字符串对象方法的playbook
- en: As these are object methods, we need to access them using dot notation rather
    than with a filter via `|`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是对象方法，我们需要使用点符号访问它们，而不是通过`|`过滤器。
- en: List methods
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表方法
- en: 'Most of the methods Ansible provides relating to lists perform modifications
    on the list itself. However, there are two list methods that are useful when working
    with lists, especially when loops are involved. These two functions are `index` and `count`,
    and their functionality is described as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Ansible提供的与列表相关的方法都是对列表本身进行修改。然而，在处理列表时，特别是涉及循环时，有两个列表方法非常有用。这两个函数分别是`index`和`count`，它们的功能描述如下：
- en: '`index`: This returns the first index position of a provided value.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`：返回提供数值的第一个索引位置。'
- en: '`count`: This counts the items in the list.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：计算列表中的项目数。'
- en: These functions can be incredibly useful when iterating through a list in a
    loop, as it allows positional logic to be performed and appropriate actions to
    be taken, given our position in the list as we work through it. This is common
    in other programming languages, and fortunately, Ansible also provides this.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当在循环中迭代列表时，这些函数可以非常有用，因为它允许执行位置逻辑，并在通过列表时采取适当的操作。这在其他编程语言中很常见，幸运的是，Ansible也提供了这个功能。
- en: The int and float methods
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: int和float方法
- en: Most `int` and `float` methods are not useful for Ansible. Sometimes, our variables are
    not exactly in the format we want them in. However, instead of defining more and
    more variables that slightly modify the same content, we can make use of Jinja2
    filters to carry out the manipulation for us in the various places that require
    that modification. This allows us to stay efficient with the definition of our
    data, preventing numerous duplicate variables and tasks that might have to be
    changed later.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数`int`和`float`方法对Ansible没有用。有时，我们的变量不完全符合我们想要的格式。但是，我们可以利用Jinja2过滤器在需要修改的各个地方执行操作，而不是定义更多的变量来轻微修改相同的内容。这使我们能够有效地定义数据，避免大量重复的变量和任务，这些变量和任务可能以后需要更改。
- en: Comparing values
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较值
- en: Comparisons are used in many places with Ansible. Task conditionals are comparisons.
    Jinja2 control structures, such as `if`/`elif`/`else` blocks, `for` loops, and
    macros, often use comparisons; some filters use comparisons as well. To master
    Ansible's usage of Jinja2, it is important to understand what comparisons are
    available.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 比较在Ansible中的许多地方都有用。任务条件是比较。 Jinja2控制结构，如`if`/`elif`/`else`块，`for`循环和宏，通常使用比较；一些过滤器也使用比较。要掌握Ansible对Jinja2的使用，了解可用的比较是很重要的。
- en: Comparisons
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较
- en: Like most languages, Jinja2 comes equipped with the standard set of comparison
    expressions you would expect, which will render a Boolean `true` or `false`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数语言一样，Jinja2配备了您期望的标准比较表达式集，这些表达式将生成布尔值`true`或`false`。
- en: 'The expressions in Jinja2 are as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2中的表达式如下：
- en: '![](Images/Table_02.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/Table_02.jpg)'
- en: If you have written comparison operations in almost any other programming language
    (usually in the form of an `if` statement), these should all seem very familiar.
    Jinja2 maintains this functionality in templates, allowing for the same powerful
    comparison operations you would expect in conditional logic from any good programming
    language.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在几乎任何其他编程语言中编写了比较操作（通常以`if`语句的形式），这些操作应该都很熟悉。Jinja2在模板中保持了这种功能，允许进行与任何良好的编程语言中条件逻辑相同的强大比较操作。
- en: Logic
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑
- en: 'Sometimes, performing a single comparison operation on its own is not enough
    – perhaps we might want to perform an action if two comparisons evaluate to `true` at
    the same time. Alternatively, we might want to perform an operation only if a
    comparison is not true. Logic in Jinja2 helps you to group two or more comparisons
    together, allowing for the formation of complex conditions from simple comparisons.
    Each comparison is referred to as an operand, and the logic that''s used to bind
    these together into complex conditionals is given in the following list:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，单独执行一个比较操作是不够的 - 也许我们希望在两个比较同时评估为`true`时执行一个操作。或者，我们可能只想在一个比较不为true时执行一个操作。Jinja2中的逻辑帮助您将两个或多个比较组合在一起，从简单的比较中形成复杂条件。每个比较被称为一个操作数，将这些操作数组合成复杂条件的逻辑在以下列表中给出：
- en: '`and`: This returns `true` if the left and the right operand are true.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`and`: 如果左操作数和右操作数为true，则返回`true`。'
- en: '`or`: This returns `true` if the left or the right operand is true.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or`: 如果左操作数或右操作数为true，则返回`true`。'
- en: '`not`: This negates an operand.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not`: 这否定一个操作数。'
- en: '`()`: This wraps a set of operands together to form a larger operand.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`()`: 这将一组操作数包装在一起，形成一个更大的操作数。'
- en: To build on the definition of logical conditions in Jinja2, we can perform tests
    for certain variable conditions such as if a variable is defined or not. We will
    look at this in more detail in the next section.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步定义Jinja2中的逻辑条件，我们可以对某些变量条件进行测试，比如变量是否已定义或未定义。我们将在下一节中更详细地讨论这个问题。
- en: Tests
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: 'A test in Jinja2 is used to determine whether a variable matches certain well-defined
    criteria, and we have already come across this in this chapter in specific scenarios.
    The `is` operator is used to initiate a test. Tests are used wherever a Boolean
    result is desired, such as with `if` expressions and task conditionals. There
    are many built-in tests, but we''ll highlight a few of the particularly useful
    ones, as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2中的测试用于确定变量是否符合某些明确定义的标准，在本章的特定场景中我们已经遇到过这种情况。`is`运算符用于启动测试。测试用于需要布尔结果的任何地方，例如`if`表达式和任务条件。有许多内置测试，但我们将重点介绍一些特别有用的测试，如下所示：
- en: '`defined`: This returns `true` if the variable is defined.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defined`: 如果变量已定义，则返回`true`。'
- en: '`undefined`: This is the opposite of `defined`.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`: 这是`defined`的相反。'
- en: '`none`: This returns `true` if the variable is defined, but the value is none.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`: 如果变量已定义但值为none，则返回`true`。'
- en: '`even`: This returns `true` if the number is divisible by `2`.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`even`: 如果数字可以被`2`整除，则返回`true`。'
- en: '`odd`: This returns `true` if the number is not divisible by `2`.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`odd`: 如果数字不能被`2`整除，则返回`true`。'
- en: To test whether a value is not something, simply use `is not`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个值是否不是某个值，只需使用`is not`。
- en: 'We can create a playbook to demonstrate some of these value comparisons:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个playbook来演示这些值的比较：
- en: '[PRE56]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you are running the code that accompanies this book, you can execute this
    example playbook using the following command:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行本书附带的代码，可以使用以下命令执行此示例playbook：
- en: '[PRE57]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is shown in *Figure 6.23*:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示在*图6.23*中：
- en: '![Figure 6.23 – Executing a playbook containing a complex conditional'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.23 - 执行包含复杂条件的playbook'
- en: '](Images/B17462_06_23.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_06_23.jpg)'
- en: Figure 6.23 – Executing a playbook containing a complex conditional
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.23 - 执行包含复杂条件的playbook
- en: Here, we can see that our complex conditional evaluated as `true`, and so the
    debug task was executed.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的复杂条件评估为`true`，因此执行了调试任务。
- en: That concludes our look at Ansible's extensive templating capabilities. We hope
    that this chapter has sown seeds of ideas for you on ways to efficiently automate
    your infrastructure.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '这就结束了我们对Ansible广泛的模板能力的探讨。我们希望本章为您提供了有效自动化基础设施的种子想法。 '
- en: Summary
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Jinja2 is a powerful language that is extensively used by Ansible. Not only
    is it used to generate file content, but it is also used to make portions of a
    playbook dynamic. Mastering Jinja2 is vital for creating and maintaining elegant
    and efficient playbooks and roles.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2是Ansible广泛使用的强大语言。它不仅用于生成文件内容，还用于使playbook的部分动态化。精通Jinja2对于创建和维护优雅高效的playbook和角色至关重要。
- en: In this chapter, we learned how to build simple templates with Jinja2 and render
    them from an Ansible playbook. Additionally, we learned how to make effective
    use of control structures, how to manipulate data, and even how to perform comparisons
    and tests on variables to both control the flow of Ansible playbooks (by keeping
    the code lightweight and efficient) and create and manipulate data without the
    need for duplicate definitions or excessive numbers of variables.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Jinja2构建简单模板，并从Ansible playbook中呈现它们。此外，我们还学习了如何有效地使用控制结构，如何操作数据，甚至如何对变量进行比较和测试，以控制Ansible
    playbook的流程（通过保持代码轻量和高效）并创建和操作数据，而无需重复定义或过多的变量。
- en: In the next chapter, we will explore Ansible's capability in more depth to define
    what constitutes a change or failure for tasks within a play.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨Ansible的能力，以定义play中任务的变化或失败。
- en: Questions
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Jinja2 conditionals can be used to render content inline with a playbook task.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jinja2条件可以用于在playbook任务中内联渲染内容。
- en: a) True
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: a）真
- en: b) False
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: b）假
- en: With of the following Jinja2 constructs will print an empty line each time it
    is evaluated?
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个Jinja2结构将在每次评估时打印一个空行？
- en: a) `{% if loop.first -%}`
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: a）`{% if loop.first -%}`
- en: b) `{% if loop.first %}`
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: b）`{% if loop.first %}`
- en: c) `{%- if loop.first -%}`
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: c）`{%- if loop.first -%}`
- en: d) `{%- if loop.first %}`
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: d）`{%- if loop.first %}`
- en: Jinja2 macros can be used to do which of the following?
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jinja2宏可用于执行以下哪些操作？
- en: a) Define a sequence of keystrokes that need to be automated.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: a）定义需要自动化的一系列按键。
- en: b) Define a function for automating spreadsheets with Ansible.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: b）定义一个用于使用Ansible自动化电子表格的函数。
- en: c) Define a function that gets called regularly from elsewhere in the template.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: c）定义一个经常从模板中的其他位置调用的函数。
- en: d) Macros are not used in Jinja2.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: d）宏不在Jinja2中使用。
- en: Which of the following is a valid expression for chaining two Jinja2 filters
    together to operate on an Ansible variable?
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个是将两个Jinja2过滤器链接在一起并对Ansible变量进行操作的有效表达式？
- en: a) `{{ value.replace('A', 'B').lower }}`
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: a）`{{ value.replace('A', 'B').lower }}`
- en: b) `{{ value | replace('A', 'B') | lower }}`
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: b）`{{ value | replace('A', 'B') | lower }}`
- en: c) `value.replace('A', 'B').lower`
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: c）`value.replace('A', 'B').lower`
- en: d) `lower(replace('A', 'B',value))`
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: d）`lower(replace('A', 'B',value))`
- en: Jinja2 filters always have mandatory arguments.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jinja2过滤器始终具有强制参数。
- en: a) True
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: a）真
- en: b) False
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: b）假
- en: Which Ansible custom filter would you use to retrieve a random entry from a
    list variable?
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将使用哪个Ansible自定义过滤器来从列表变量中检索随机条目？
- en: a) `shuffle`
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: a）`洗牌`
- en: b) `random`
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: b）`随机`
- en: c) `select`
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: c）`选择`
- en: d) `rand`
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: d）`rand`
- en: Ansible can extract the filename from a full path using which filter?
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible可以使用哪个过滤器从完整路径中提取文件名？
- en: a) `filename`
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: a）`文件名`
- en: b) `dirname`
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: b）`dirname`
- en: c) `expanduser`
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: c）`expanduser`
- en: d) `basename`
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: d）`basename`
- en: Ansible provides a construct for skipping optional arguments to prevent undefined
    variable errors. What is it called?
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible提供了一个构造来跳过可选参数以防止未定义的变量错误。它叫什么？
- en: a) `skip_var`
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: a）`skip_var`
- en: b) `skip`
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: b）`跳过`
- en: c) `omit`
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: c）`省略`
- en: d) `prevent_undefined`
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: d）`prevent_undefined`
- en: Complex conditionals can be constructed for Ansible tasks using which operators?
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用哪些运算符为Ansible任务构建复杂的条件？
- en: a) `and`, `or`, and `not`
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: a）`和`，`或`和`不`
- en: b) `and`, `nand`, `or`, `nor`, and `not`
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: b）`和`，`nand`，`或`，`nor`和`not`
- en: c) `&&`, `||`, and `!`
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: c）`&&`，`||`和`！`
- en: d) `&`, `|`, and `!`
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: d）`＆`，`|`和`！`
- en: Which of the following task execution conditionals will allow the task to run
    if the previous task has been completed successfully?
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个任务执行条件将允许任务在前一个任务成功完成时运行？
- en: a) `previoustask | success`
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: a）`previoustask | success`
- en: b) `previoustask = success`
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: b）`previoustask = success`
- en: c) `previoustask == success`
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: c）`previoustask == success`
- en: d) `previoustask is success`
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: d）`previoustask成功`
