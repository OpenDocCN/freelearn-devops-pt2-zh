- en: '*Chapter 1*: The System Architecture and Design of Ansible'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第1章*：Ansible的系统架构和设计'
- en: This chapter provides a detailed exploration of the architecture and design
    of **Ansible** and how it goes about performing tasks on your behalf. We will
    cover the basic concepts of inventory parsing and how data is discovered. Then,
    we will proceed onto playbook parsing. We will take a walk through module preparation,
    transportation, and execution. Finally, we will detail variable types and find
    out where variables are located, their scope of use, and how precedence is determined
    when variables are defined in more than one location. All these things will be
    covered in order to lay the foundation for mastering Ansible!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细探讨了**Ansible**的架构和设计，以及它如何代表您执行任务。我们将介绍清单解析的基本概念以及数据的发现方式。然后，我们将进行playbook解析。我们将详细介绍模块准备、传输和执行。最后，我们将详细介绍变量类型，并找出变量的位置、使用范围以及在多个位置定义变量时确定优先级的方式。所有这些内容将被覆盖，以奠定掌握Ansible的基础！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Ansible versions and configurations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible版本和配置
- en: Inventory parsing and data sources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清单解析和数据源
- en: Playbook parsing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Playbook解析
- en: Execution strategies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行策略
- en: Module transport and execution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块传输和执行
- en: Ansible collections
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible集合
- en: Variable types and locations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量类型和位置
- en: Magic variables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 魔术变量
- en: Accessing external data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问外部数据
- en: Variable precedence (and interchanging this with variable priority ordering)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量优先级（并将其与变量优先级排序互换）
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples presented in this chapter, you will need a Linux machine
    running **Ansible 4.3** or later. Almost any flavor of Linux should do. For those
    who are interested in specifics, all the code presented in this chapter was tested
    on **Ubuntu Server 20.04 LTS**, unless stated otherwise, and on Ansible 4.3\.
    The example code that accompanies this chapter can be downloaded from GitHub at
    [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter01).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章中提出的示例，您需要一台运行**Ansible 4.3**或更高版本的Linux机器。几乎任何Linux版本都可以。对于那些对细节感兴趣的人，本章中提出的所有代码都是在**Ubuntu
    Server 20.04 LTS**上测试的，除非另有说明，并且在Ansible 4.3上进行了测试。本章附带的示例代码可以从GitHub上下载：[https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter01)。
- en: 'Check out the following video to view the Code in Action: [https://bit.ly/3E37xpn](https://bit.ly/3E37xpn).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码实际操作：[https://bit.ly/3E37xpn](https://bit.ly/3E37xpn)。
- en: Ansible versions and configurations
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible版本和配置
- en: It is assumed that you have Ansible installed on your system. There are many
    documents out there that cover installing Ansible in a way that is appropriate
    to the operating system and version that you might be using. However, it is important
    to note that Ansible versions that are newer than 2.9.x feature some major changes
    from all of the earlier versions. For everyone reading this book who has had exposure
    to Ansible 2.9.x and earlier, [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047),
    *Migrating from Earlier Ansible Versions*, explains the changes in detail, along
    with how to address them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已在系统上安装了Ansible。有许多文档介绍了如何安装Ansible，适用于您可能使用的操作系统和版本。但是，重要的是要注意，新于2.9.x的Ansible版本与所有早期版本都有一些重大变化。对于阅读本书的每个人，都曾接触过2.9.x及更早版本的Ansible的[*第2章*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047)，*从早期的Ansible版本迁移*详细解释了这些变化，以及如何解决这些变化。
- en: 'This book will assume the use of Ansible version 4.0.0 (or later), coupled
    with ansible-core 2.11.1 (or newer), both of which are required and are the latest
    and greatest releases at the time of writing. To discover the version in use on
    a system where Ansible is already installed, make use of the `--version` argument,
    that is, either `ansible` or `ansible-playbook`, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将假定使用Ansible版本4.0.0（或更高版本），配合ansible-core 2.11.1（或更新版本），这两者都是必需的，并且是撰写时的最新版本。要发现已安装Ansible的系统上使用的版本，请使用`--version`参数，即`ansible`或`ansible-playbook`，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command should give you an output that''s similar to *Figure 1.1*; note
    that the screenshot was taken on Ansible 4.3, so you might see an updated version
    number corresponding to the version of your `ansible-core` package (for instance,
    for Ansible 4.3.0, this would be ansible-core 2.11.1, which is the version number
    that all of the commands will return):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应该给出与*图1.1*类似的输出；请注意，该屏幕截图是在Ansible 4.3上进行的，因此您可能会看到与您的`ansible-core`软件包版本相对应的更新版本号（例如，对于Ansible
    4.3.0，这将是ansible-core 2.11.1，这是所有命令将返回的版本号）：
- en: '![Figure 1.1 – An example output showing the installed version of Ansible on
    a Linux system'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1 - 一个示例输出，显示了Linux系统上安装的Ansible版本'
- en: '](Images/B17462_01_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_01_01.jpg)'
- en: Figure 1.1 – An example output showing the installed version of Ansible on a
    Linux system
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 - 一个示例输出，显示了Linux系统上安装的Ansible版本
- en: Important note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that `ansible` is the executable for doing ad hoc one-task executions,
    and `ansible-playbook` is the executable that will process playbooks to orchestrate
    multiple tasks. We will cover the concepts of ad hoc tasks and playbooks later
    in the book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ansible`是用于执行临时单个任务的可执行文件，而`ansible-playbook`是用于处理playbook以编排多个任务的可执行文件。我们将在本书的后面介绍临时任务和playbook的概念。
- en: 'The configuration for Ansible can exist in a few different locations, where
    the first file found will be used. The search involves the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的配置可以存在于几个不同的位置，将使用找到的第一个文件。搜索涉及以下内容：
- en: '`ANSIBLE_CFG`: This environment variable is used, provided that it is set.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANSIBLE_CFG`：如果设置了此环境变量，则会使用它。'
- en: '`ansible.cfg`: This is located in the current working directory.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible.cfg`：这位于当前工作目录中。'
- en: '`~/.ansible.cfg`: This is located in the user''s home directory.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~/.ansible.cfg`：这位于用户的主目录中。'
- en: '`/etc/ansible/ansible.cfg`: The default central Ansible configuration file
    for the system.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/ansible/ansible.cfg`：系统的默认中央Ansible配置文件。'
- en: Some installation methods could include placing a `config` file in one of these
    locations. Look around to check whether such a file exists and view what settings
    are in the file to get an idea of how the Ansible operation might be affected.
    This book assumes that there are no settings in the `ansible.cfg` file that can
    affect the default operation of Ansible.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 某些安装方法可能包括将`config`文件放置在其中一个位置。查看一下是否存在这样的文件，并查看文件中的设置，以了解Ansible操作可能会受到影响的情况。本书假设`ansible.cfg`文件中没有设置会影响Ansible的默认操作。
- en: Inventory parsing and data sources
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清单解析和数据源
- en: In Ansible, nothing happens without an inventory. Even ad hoc actions performed
    on the localhost require an inventory – although that inventory might just consist
    of the localhost. The inventory is the most basic building block of Ansible architecture.
    When executing `ansible` or `ansible-playbook`, an inventory must be referenced.
    Inventories are files or directories that exist on the same system that runs `ansible`
    or `ansible-playbook`. The location of the inventory can be defined at runtime
    with the `--inventory-file (-i)` argument or by defining the path in an Ansible
    `config` file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible中，没有清单就不会发生任何事情。即使在本地主机上执行的临时操作也需要清单-尽管该清单可能只包括本地主机。清单是Ansible架构的最基本构建块。在执行`ansible`或`ansible-playbook`时，必须引用清单。清单是存在于运行`ansible`或`ansible-playbook`的同一系统上的文件或目录。清单的位置可以在运行时使用`--inventory-file
    (-i)`参数或通过在Ansible `config`文件中定义路径来定义。
- en: Inventories can be static or dynamic, or even a combination of both, and Ansible
    is not limited to a single inventory. The standard practice is to split inventories
    across logical boundaries, such as staging and production, allowing an engineer
    to run a set of plays against their staging environment for validation, and then
    follow with the exact plays run against the production inventory set.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 清单可以是静态的或动态的，甚至可以是两者的组合，Ansible不限于单个清单。标准做法是将清单分割成逻辑边界，例如暂存和生产，允许工程师对暂存环境运行一组操作，然后跟随着对生产清单集运行相同的操作。
- en: Variable data, such as specific details a how to connect to a particular host
    in your inventory, can be included, along with an inventory in a variety of ways,
    and we'll explore the options available to you.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可以包括变量数据，例如如何连接到清单中特定主机的具体细节，以及以各种方式包含清单，我们将探讨可用的选项。
- en: Static inventories
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态清单
- en: 'The static inventory is the most basic of all the inventory options. Typically,
    a static inventory will consist of a single file in `ini` format. Other formats
    are supported, including YAML, but you will find that `ini` is commonly used when
    most people start out with Ansible. Here is an example of a static inventory file
    describing a single host, `mastery.example.name`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 静态清单是所有清单选项中最基本的。通常，静态清单将包含一个`ini`格式的单个文件。还支持其他格式，包括YAML，但您会发现当大多数人开始使用Ansible时，通常会使用`ini`。以下是描述单个主机`mastery.example.name`的静态清单文件的示例：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That is all there is to it. Simply list the names of the systems in your inventory.
    Of course, this does not take full advantage of all that an inventory has to offer.
    If every name were listed like this, all plays would have to reference specific
    hostnames, or the special built-in `all` group (which, as the name suggests, contains
    all hosts inside the inventory). This can be quite tedious when developing a playbook
    that operates across different environments within your infrastructure. At the
    very least, hosts should be arranged into groups.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。只需列出清单中系统的名称。当然，这并没有充分利用清单所提供的所有功能。如果每个名称都像这样列出，所有操作都必须引用特定的主机名，或者特殊的内置`all`组（顾名思义，包含清单中的所有主机）。在开发跨您的基础设施中的不同环境的playbook时，这可能会非常繁琐。至少，主机应该被分组。
- en: 'A design pattern that works well is arranging your systems into groups based
    on expected functionality. At first, this might seem difficult if you have an
    environment where single systems can play many different roles, but that is perfectly
    fine. Systems in an inventory can exist in more than one group, and groups can
    even consist of other groups! Additionally, when listing groups and hosts, it
    is possible to list hosts without a group. These would have to be listed first
    before any other group is defined. Let''s build on our previous example and expand
    our inventory with a few more hosts and groupings, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的设计模式是根据预期功能将系统分组。起初，如果您的环境中单个系统可以扮演许多不同的角色，这可能看起来很困难，但这完全没问题。清单中的系统可以存在于多个组中，甚至组中还可以包含其他组！此外，在列出组和主机时，可以列出没有组的主机。这些主机必须在定义任何其他组之前列出。让我们在之前的示例基础上扩展我们的清单，增加一些更多的主机和分组，如下所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we have created a set of three groups with one system in each, and then
    two more groups, which logically group all three together. Yes, that''s right:
    you can have groups of groups. The syntax used here is `[groupname:children]`,
    which indicates to Ansible''s inventory parser that this group, going by the name
    of `groupname`, is nothing more than a grouping of other groups.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个包含一个系统的三个组，然后又创建了两个逻辑上将所有三个组合在一起的组。是的，没错：您可以有组的组。这里使用的语法是`[groupname:children]`，这表明给Ansible的清单解析器，名为`groupname`的这个组只是其他组的分组。
- en: The `children`, in this case, are the names of the other groups. This inventory
    now allows writing plays against specific hosts, low-level role-specific groups,
    or high-level logical groupings, or any combination thereof.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`children`是其他组的名称。这个清单现在允许针对特定主机、低级别的角色特定组或高级别的逻辑分组编写操作，或者两者的任意组合。
- en: By utilizing generic group names, such as `dns` and `database`, Ansible plays
    can reference these generic groups rather than the explicit hosts within. An engineer
    can create one inventory file that fills in these groups with hosts from a preproduction
    staging environment, and another inventory file with the production versions of
    these groupings. The content of the playbook does not need to change when executing
    on either a staging or production environment because it refers to the generic
    group names that exist in both inventories. Simply refer to the correct inventory
    to execute it in the desired environment.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用通用的组名，比如`dns`和`database`，Ansible play可以引用这些通用组，而不是明确的主机。工程师可以创建一个清单文件，用预生产阶段环境中的主机填充这些组，另一个清单文件用于生产环境中这些组的版本。当在预生产或生产环境中执行时，playbook的内容不需要更改，因为它引用了存在于两个清单中的通用组名。只需引用正确的清单以在所需的环境中执行它。
- en: Inventory ordering
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清单排序
- en: 'A new play-level keyword, `order`, was added to Ansible in version 2.4\. Prior
    to this, Ansible processed the hosts in the order specified in the inventory file,
    and it continues to do so by default, even in newer versions. However, the following
    values can be set for the `order` keyword for a given play, resulting in the processing
    order of hosts, which is described as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible 2.4版本中，添加了一个新的play-level关键字`order`。在此之前，Ansible按照清单文件中指定的顺序处理主机，并且即使在更新的版本中，默认情况下仍然如此。但是，可以为给定的play设置`order`关键字的以下值，从而得到主机的处理顺序，如下所述：
- en: '`inventory`: This is the default option. It simply means that Ansible proceeds
    as it always has, processing the hosts in the order that is specified in the `inventory`
    file.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inventory`：这是默认选项。它只是意味着Ansible会像以往一样进行处理，按照`inventory`文件中指定的顺序处理主机。'
- en: '`reverse_inventory`: This results in the hosts being processed in the reverse
    order that is specified in the `inventory` file.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse_inventory`：这导致主机按照`inventory`文件中指定的相反顺序进行处理。'
- en: '`sorted`: The hosts are processed in alphabetical order by name.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sorted`：按名称按字母顺序处理主机。'
- en: '`reverse_sorted`: The hosts are processed in reverse alphabetical order.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse_sorted`：按照字母顺序的相反顺序处理主机。'
- en: '`shuffle`: The hosts are processed in a random order, with the order being
    randomized on each run.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shuffle`：主机以随机顺序处理，每次运行都会随机排序。'
- en: 'In Ansible, the alphabetical sorting used is alternatively known as lexicographical.
    Put simply, this means that values are sorted as strings, with the strings being
    processed from left to right. Therefore, let''s say that we have three hosts:
    `mastery1`, `mastery11`, and `mastery2`. In this list, `mastery1` comes first
    as the character, as position `8` is a `1`. Then comes `mastery11`, as the character
    at position `8` is still a `1`, but now there is an additional character at position
    `9`. Finally comes `mastery2`, as character `8` is a `2`, and `2` comes after
    `1`. This is important as, numerically, we know that `11` is greater than `2`.
    However, in this list, `mastery11` comes before `mastery2`. You can easily work
    around this by adding leading zeros to any numbers on your hostnames; for example,
    `mastery01`, `mastery02`, and `mastery11` will be processed in the order they
    have been listed in this sentence, resolving the lexicographical issue described.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible中，使用的字母排序也称为词典排序。简单地说，这意味着值按字符串排序，字符串从左到右处理。因此，假设我们有三个主机：`mastery1`，`mastery11`和`mastery2`。在这个列表中，`mastery1`首先出现在字符位置`8`是`1`。然后是`mastery11`，因为位置`8`的字符仍然是`1`，但现在在位置`9`有一个额外的字符。最后是`mastery2`，因为字符`8`是`2`，而`2`在`1`之后。这很重要，因为从数字上来看，我们知道`11`大于`2`。但是，在这个列表中，`mastery11`在`mastery2`之前。您可以通过在主机名上添加前导零来轻松解决这个问题；例如，`mastery01`，`mastery02`和`mastery11`将按照它们在这个句子中列出的顺序进行处理，解决了词典排序的问题。
- en: Inventory variable data
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清单变量数据
- en: 'Inventories provide more than just system names and groupings. Data regarding
    the systems can be passed along as well. This data could include the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 清单不仅提供系统名称和分组，还可以传递有关系统的数据。这些数据可能包括以下内容：
- en: Host-specific data to use in templates
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在模板中使用的特定于主机的数据
- en: Group-specific data to use in task arguments or conditionals
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于任务参数或条件的特定于组的数据
- en: Behavioral parameters to tune how Ansible interacts with a system
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整Ansible与系统交互的行为参数
- en: Variables are a powerful construct within Ansible and can be used in a variety
    of ways, not just those described here. Nearly every single thing done in Ansible
    can include a variable reference. While Ansible can discover data about a system
    during the setup phase, not all of the data can be discovered. Defining data with
    the inventory expands this. Note that variable data can come from many different
    sources, and one source could override another. We will cover the order of variable
    precedence later in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是Ansible中强大的构造，可以以各种方式使用，不仅仅是这里描述的方式。在Ansible中几乎可以包括变量引用的每一件事。虽然Ansible可以在设置阶段发现有关系统的数据，但并非所有数据都可以被发现。使用清单定义数据可以扩展这一点。请注意，变量数据可以来自许多不同的来源，一个来源可能会覆盖另一个。我们将在本章后面介绍变量优先级的顺序。
- en: 'Let''s improve upon our existing example inventory and add to it some variable
    data. We will add some host-specific data and group-specific data:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进现有的示例清单，并向其中添加一些变量数据。我们将添加一些特定于主机和特定于组的数据：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we defined `ansible_host` for `mastery.example.name` to be
    the IP address of `192.168.10.25`. The `ansible_host` variable is a **behavioral
    inventory variable**, which is intended to alter the way Ansible behaves when
    operating with this host. In this case, the variable instructs Ansible to connect
    to the system using the IP address provided, rather than performing a DNS lookup
    on the name using `mastery.example.name`. There are a number of other behavioral
    inventory variables that are listed at the end of this section, along with their
    intended use.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`mastery.example.name`的`ansible_host`定义为`192.168.10.25`的IP地址。`ansible_host`变量是一个**行为清单变量**，旨在改变Ansible在与此主机操作时的行为方式。在这种情况下，该变量指示Ansible使用提供的IP地址连接到系统，而不是使用`mastery.example.name`进行名称的DNS查找。在本节的末尾列出了许多其他行为清单变量，以及它们的预期用途。
- en: Our new inventory data also provides group-level variables for the web and backend
    groups. The web group defines `http_port`, which could be used in an **NGINX**
    configuration file, and `proxy_timeout`, which might be used to determine **HAProxy**
    behavior. The backend group makes use of another behavioral inventory parameter
    to instruct Ansible to connect to the hosts in this group using port `314` for
    SSH, rather than the default of `22`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新清单数据还为web和backend组提供了组级变量。web组定义了`http_port`，可以在**NGINX**配置文件中使用，并且`proxy_timeout`，可能用于确定**HAProxy**的行为。backend组利用了另一个行为清单参数，指示Ansible使用端口`314`连接到此组中的主机，而不是默认的`22`。
- en: Finally, a construct is introduced that provides variable data across all the
    hosts in the inventory by utilizing a built-in `all` group. Variables defined
    within this group will apply to every host in the inventory. In this particular
    example, we instruct Ansible to log in as the `otto` user when connecting to the
    systems. This is also a behavioral change, as the Ansible default behavior is
    to log in as a user with the same name as the user executing `ansible` or `ansible-playbook`
    on the control host.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，引入了一个构造，通过使用内置的`all`组在清单中的所有主机之间提供变量数据。在这个特定的例子中，我们指示Ansible在连接到系统时以`otto`用户登录。这也是一个行为变化，因为Ansible的默认行为是以在控制主机上执行`ansible`或`ansible-playbook`的用户相同的用户名登录。
- en: 'Here is a list of behavior inventory variables and the behaviors they intend
    to modify:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是行为清单变量及其意图修改的行为的列表：
- en: '`ansible_host`: This is the DNS name or the Docker container name that Ansible
    will initiate a connection to.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_host`：这是Ansible将要连接的DNS名称或Docker容器名称。'
- en: '`ansible_port`: This specifies the port number that Ansible will use to connect
    to the inventory host if it is not the default value of `22`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_port`：这指定了Ansible将用于连接清单主机的端口号，如果不是默认值`22`。'
- en: '`ansible_user`: This specifies the username that Ansible will use to connect
    with the inventory host, regardless of the connection type.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_user`：这指定了Ansible将用于与清单主机连接的用户名，无论连接类型如何。'
- en: '`ansible_password`: This is used to provide Ansible with the password for authentication
    to the inventory host in conjunction with `ansible_user`. Use this for testing
    purposes only – you should always use a vault to store sensitive data such as
    passwords (please refer to [*Chapter 3*](B17462_03_Final_JC_ePub.xhtml#_idTextAnchor061),
    *Protecting Your Secrets with Ansible*).'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_password`：这用于为认证到清单主机提供密码给Ansible，与`ansible_user`一起使用。仅用于测试目的 - 您应该始终使用保险库来存储诸如密码之类的敏感数据（请参阅[*第3章*](B17462_03_Final_JC_ePub.xhtml#_idTextAnchor061)，*使用Ansible保护您的秘密*）。'
- en: '`ansible_ssh_private_key_file`: This is used to specify which SSH private key
    file will be used to connect to the inventory host if you are not using the default
    one or `ssh-agent`.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_ssh_private_key_file`：这用于指定将用于连接到清单主机的SSH私钥文件，如果您没有使用默认值或`ssh-agent`。'
- en: '`ansible_ssh_common_args`: This defines SSH arguments to append to the default
    arguments for `ssh`, `sftp`, and `scp`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_ssh_common_args`：这定义了要附加到`ssh`、`sftp`和`scp`的默认参数的SSH参数。'
- en: '`ansible_sftp_extra_args`: This is used to specify additional arguments that
    will be passed to the `sftp` binary when called by Ansible.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_sftp_extra_args`：这用于指定在Ansible调用时将传递给`sftp`二进制文件的附加参数。'
- en: '`ansible_scp_extra_args`: This is used to specify additional arguments that
    will be passed to the `scp` binary when called by Ansible.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_scp_extra_args`：这用于指定在Ansible调用时将传递给`scp`二进制文件的附加参数。'
- en: '`ansible_ssh_extra_args`: This is used to specify additional arguments that
    will be passed to the `ssh` binary when called by Ansible.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_ssh_extra_args`：这用于指定在Ansible调用时将传递给`ssh`二进制文件的附加参数。'
- en: '`ansible_ssh_pipelining`: This setting uses a Boolean to define whether SSH
    pipelining should be used for this host.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_ssh_pipelining`：此设置使用布尔值来定义是否应该为此主机使用SSH流水线。'
- en: '`ansible_ssh_executable`: This setting overrides the path to the SSH executable
    for this host.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_ssh_executable`：此设置覆盖了此主机的SSH可执行文件的路径。'
- en: '`ansible_become`: This defines whether privilege escalation (`sudo` or something
    else) should be used with this host.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_become`：这定义了是否应该在此主机上使用特权升级（`sudo`或其他）。'
- en: '`ansible_become_method`: This is the method to use for privilege escalation
    and can be one of `sudo`, `su`, `pbrun`, `pfexec`, `doas`, `dzdo`, or `ksu`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_become_method`：这是用于特权升级的方法，可以是`sudo`、`su`、`pbrun`、`pfexec`、`doas`、`dzdo`或`ksu`之一。'
- en: '`ansible_become_user`: This is the user to switch to through privilege escalation,
    typically root on Linux and Unix systems.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_become_user`：这是通过特权升级要切换到的用户，通常在Linux和Unix系统上是root。'
- en: '`ansible_become_password`: This is the password to use for privilege escalation.
    Only use this for testing purposes; you should always use a vault to store sensitive
    data such as passwords (please refer to [*Chapter 3*](B17462_03_Final_JC_ePub.xhtml#_idTextAnchor061),
    *Protecting Your Secrets with Ansible*).'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_become_password`：这是用于特权升级的密码。仅用于测试目的；您应该始终使用保险库来存储诸如密码之类的敏感数据（请参阅[*第3章*](B17462_03_Final_JC_ePub.xhtml#_idTextAnchor061)，*使用Ansible保护您的秘密*）。'
- en: '`ansible_become_exe`: This is used to set the executable that was used for
    the chosen escalation method if you are not using the default one defined by the
    system.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_become_exe`：这用于设置所选升级方法的可执行文件，如果您没有使用系统定义的默认方法。'
- en: '`ansible_become_flags`: This is used to set the flags passed to the chosen
    escalation executable if required.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_become_flags`：这用于设置传递给所选升级可执行文件的标志（如果需要）。'
- en: '`ansible_connection`: This is the connection type of the host. Candidates are
    `local`, `smart`, `ssh`, `paramiko`, `docker`, or `winrm` (we will look at this
    in more detail later in the book). The default setting is `smart` in any modern
    Ansible distribution (this detects whether the `ControlPersist` SSH feature is
    supported and, if so, uses `ssh` as the connection type; otherwise, it falls back
    to `paramiko`).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_connection`：这是主机的连接类型。候选项包括`local`、`smart`、`ssh`、`paramiko`、`docker`或`winrm`（我们将在本书的后面更详细地讨论这个）。在任何现代Ansible发行版中，默认设置为`smart`（这会检测是否支持`ControlPersist`
    SSH功能，如果支持，则使用`ssh`作为连接类型；否则，它会回退到`paramiko`）。'
- en: '`ansible_docker_extra_args`: This is used to specify the extra argument that
    will be passed to a remote Docker daemon on a given inventory host.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_docker_extra_args`：这用于指定将传递给给定清单主机上的远程Docker守护程序的额外参数。'
- en: '`ansible_shell_type`: This is used to determine the shell type on the inventory
    host(s) in question. It defaults to the `sh`-style syntax but can be set to `csh`
    or `fish` to work with systems that use these shells.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_shell_type`：这用于确定问题清单主机的shell类型。默认为`sh`风格的语法，但可以设置为`csh`或`fish`以适用于使用这些shell的系统。'
- en: '`ansible_shell_executable`: This is used to determine the shell type on the
    inventory host(s) in question. It defaults to the `sh`-style syntax but can be
    set to `csh` or `fish` to work with systems that use these shells.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_shell_executable`：这用于确定问题清单主机的shell类型。默认为`sh`风格的语法，但可以设置为`csh`或`fish`以适用于使用这些shell的系统。'
- en: '`ansible_python_interpreter`: This is used to manually set the path to Python
    on a given host in the inventory. For example, some distributions of Linux have
    more than one Python version installed, and it is important to ensure that the
    correct one is set. For example, a host might have both `/usr/bin/python27` and
    `/usr/bin/python3`, and this is used to define which one will be used.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_python_interpreter`：这用于手动设置清单中给定主机上Python的路径。例如，某些Linux发行版安装了多个Python版本，确保设置正确的版本非常重要。例如，主机可能同时拥有`/usr/bin/python27`和`/usr/bin/python3`，这用于定义将使用哪个版本。'
- en: '`ansible_*_interpreter`: This is used for any other interpreted language that
    Ansible might depend upon (for example, Perl or Ruby). This replaces the interpreter
    binary with the one that is specified.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible_*_interpreter`：这用于Ansible可能依赖的任何其他解释语言（例如Perl或Ruby）。这将用指定的解释器二进制替换解释器二进制。'
- en: Dynamic inventories
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态清单
- en: A static inventory is great and can be enough for many situations. However,
    there are times when a statically written set of hosts is just too unwieldy to
    manage. Consider situations where inventory data already exists in a different
    system, such as **LDAP**, a cloud computing provider, or an in-house **configuration
    management database** (**CMDB**) (inventory, asset tracking, and data warehousing)
    system. It would be a waste of time and energy to duplicate that data and, in
    the modern world of on-demand infrastructure, that data would quickly grow stale
    or become disastrously incorrect.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 静态清单非常好，对许多情况可能足够。然而，有时静态编写的主机集合管理起来太过繁琐。考虑清单数据已经存在于不同系统中的情况，例如LDAP、云计算提供商或内部配置管理数据库（清单、资产跟踪和数据仓库）系统。复制这些数据将是浪费时间和精力，在按需基础设施的现代世界中，这些数据很快就会变得陈旧或变得灾难性不正确。
- en: Another example of when a dynamic inventory source might be desired is when
    your site grows beyond a single set of playbooks. Multiple playbook repositories
    can fall into the trap of holding multiple copies of the same inventory data,
    or complicated processes have to be created to reference a single copy of the
    data. An external inventory can easily be leveraged to access the common inventory
    data that is stored outside of the playbook repository to simplify the setup.
    Thankfully, Ansible is not limited to static inventory files.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的站点超出单一剧本集的范围时，可能需要动态清单源的另一个例子。多个剧本存储库可能会陷入持有相同清单数据的多个副本，或者必须创建复杂的流程来引用数据的单个副本。可以轻松利用外部清单来访问存储在剧本存储库之外的常见清单数据，以简化设置。幸运的是，Ansible不仅限于静态清单文件。
- en: 'A dynamic inventory source (or plugin) is an executable that Ansible will call
    at runtime to discover real-time inventory data. This executable can reach out
    to external data sources and return data, or it can just parse local data that
    already exists but might not be in the `ini/yaml` Ansible inventory format. While
    it is possible, and easy, to develop your own dynamic inventory source, which
    we will cover in a later chapter, Ansible provides an ever-growing number of example
    inventory plugins. This includes, but is not limited to, the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 动态清单源（或插件）是Ansible在运行时调用的可执行文件，用于发现实时清单数据。这个可执行文件可以访问外部数据源并返回数据，或者它可以只解析已经存在但可能不符合`ini/yaml`
    Ansible清单格式的本地数据。虽然可能并且很容易开发自己的动态清单源，我们将在后面的章节中介绍，但Ansible提供了越来越多的示例清单插件。这包括但不限于以下内容：
- en: OpenStack Nova
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenStack Nova
- en: Rackspace Public Cloud
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rackspace Public Cloud
- en: DigitalOcean
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DigitalOcean
- en: Linode
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linode
- en: Amazon EC2
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon EC2
- en: Google Compute Engine
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Compute Engine
- en: Microsoft Azure
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Azure
- en: Docker
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Vagrant
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vagrant
- en: Many of these plugins require some level of configuration, such as user credentials
    for EC2 or an authentication endpoint for **OpenStack Nova**. Since it is not
    possible to configure additional arguments for Ansible to pass along to the inventory
    script, the configuration for the script must either be managed via an `ini` config
    file that is read from a known location or environment variables that are read
    from the shell environment used to execute `ansible` or `ansible-playbook`. Also,
    note that, sometimes, external libraries are required for these inventory scripts
    to function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些插件都需要一定程度的配置，比如EC2的用户凭据或者**OpenStack Nova**的认证端点。由于无法为Ansible配置额外的参数以传递给清单脚本，因此脚本的配置必须通过从已知位置读取的`ini`配置文件或者从用于执行`ansible`或`ansible-playbook`的shell环境中读取的环境变量来管理。另外，请注意，有时这些清单脚本需要外部库才能正常运行。
- en: When `ansible` or `ansible-playbook` is directed at an executable file for an
    inventory source, Ansible will execute that script with a single argument, `--list`.
    This is so that Ansible can get a listing of the entire inventory in order to
    build up its internal objects to represent the data. Once that data is built up,
    Ansible will then execute the script with a different argument for every host
    in the data to discover variable data. The argument used in this execution is
    `--host <hostname>`, which will return any variable data that is specific to that
    host.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ansible`或`ansible-playbook`指向清单源的可执行文件时，Ansible将使用单个参数`--list`执行该脚本。这样，Ansible可以获取整个清单的列表，以便构建其内部对象来表示数据。一旦数据构建完成，Ansible将使用不同的参数执行脚本，以发现每个主机的变量数据。在此执行中使用的参数是`--host
    <hostname>`，它将返回特定于该主机的任何变量数据。
- en: The number of inventory plugins is too numerous for us to go through each of
    them in detail in this book. However, similar processes are needed to set up and
    use just about all of them. So, to demonstrate the process, we will work through
    the use of the EC2 dynamic inventory.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 清单插件的数量太多，我们无法在本书中详细介绍每一个。然而，设置和使用几乎所有这些插件都需要类似的过程。因此，为了演示该过程，我们将介绍如何使用EC2动态清单。
- en: 'Many of the dynamic inventory plugins are installed as part of the `community.general`
    collection, which is installed, by default, when you install Ansible 4.0.0\. Nonetheless,
    the first part of working with any dynamic inventory plugin is finding out which
    collection the plugin is part of and, if required, installing that collection.
    The EC2 dynamic inventory plugin is installed as part of the `amazon.aws` collection.
    So, your first step will be to install this collection – you can do this with
    the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 许多动态清单插件都作为`community.general`集合的一部分安装，默认情况下，当您安装Ansible 4.0.0时会安装该集合。尽管如此，使用任何动态清单插件的第一步是找出插件属于哪个集合，并在必要时安装该集合。EC2动态清单插件作为`amazon.aws`集合的一部分安装。因此，您的第一步将是安装此集合-您可以使用以下命令完成：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If all goes well, you should see a similar output on your Terminal to that
    in *Figure 1.2*:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该在终端上看到与*图1.2*中类似的输出。
- en: '![Figure 1.2 – The installation of the amazon.aws collection using ansible-galaxy'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 - 使用ansible-galaxy安装amazon.aws集合的安装'
- en: '](Images/B17462_01_02.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_01_02.jpg)'
- en: Figure 1.2 – The installation of the amazon.aws collection using ansible-galaxy
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 - 使用ansible-galaxy安装amazon.aws集合的安装
- en: 'Whenever you install a new plugin or collection, it is always advisable to
    read the accompanying documentation as some of the dynamic inventory plugins require
    additional libraries or tools to function correctly. For example, if you refer
    to the documentation for the `aws_ec2` plugin at [https://docs.ansible.com/ansible/latest/collections/amazon/aws/aws_ec2_inventory.html](https://docs.ansible.com/ansible/latest/collections/amazon/aws/aws_ec2_inventory.html),
    you will see that both the `boto3` and `botocore` libraries are required for this
    plugin to operate. Installing this will depend on your operating system and Python
    environment. However, on Ubuntu Server 20.04 (and other Debian variants), it can
    be done with the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您安装新的插件或集合时，都建议阅读附带的文档，因为一些动态清单插件需要额外的库或工具才能正常运行。例如，如果您参考[https://docs.ansible.com/ansible/latest/collections/amazon/aws/aws_ec2_inventory.html](https://docs.ansible.com/ansible/latest/collections/amazon/aws/aws_ec2_inventory.html)中`aws_ec2`插件的文档，您将看到该插件需要`boto3`和`botocore`库才能运行。安装这些库将取决于您的操作系统和Python环境。然而，在Ubuntu
    Server 20.04（以及其他Debian变体）上，可以使用以下命令完成：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here''s the output for the preceding command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述命令的输出：
- en: '![Figure 1.3 – Installing the Python dependencies for the EC2 dynamic inventory
    script'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3 - 为EC2动态清单脚本安装Python依赖项'
- en: '](Images/B17462_01_03.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_01_03.jpg)'
- en: Figure 1.3 – Installing the Python dependencies for the EC2 dynamic inventory
    script
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 - 为EC2动态清单脚本安装Python依赖项
- en: 'Now, looking at the documentation for the plugin (often, you can also find
    helpful hints by looking within the code and any accompanying configuration files),
    you will note that we need to provide our AWS credentials to this script in some
    manner. There are several possible ways in which to do this – one example is to
    use the `awscli` tool (if you have it installed) to define the configuration,
    and then reference this configuration profile from your inventory. For example,
    I configured my default AWS CLI profile using the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，查看插件的文档（通常情况下，您还可以通过查看代码和任何附带的配置文件来找到有用的提示），您会注意到我们需要以某种方式向此脚本提供我们的AWS凭据。有几种可能的方法可以做到这一点-一个例子是使用`awscli`工具（如果已安装）来定义配置，然后从您的清单中引用此配置文件。例如，我使用以下命令配置了我的默认AWS
    CLI配置文件：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output will appear similar to the following screenshot (the secure details
    have been redacted for obvious reasons!):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下屏幕截图（出于明显原因，已删除了安全细节！）：
- en: '![Figure 1.4 – Configuring AWS credentials using the AWS CLI utility'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4 - 使用AWS CLI实用程序配置AWS凭据'
- en: '](Images/B17462_01_04.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_01_04.jpg)'
- en: Figure 1.4 – Configuring AWS credentials using the AWS CLI utility
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 - 使用AWS CLI实用程序配置AWS凭据
- en: 'With this done, we can now create out inventory definition, telling Ansible
    which plugin to use, and passing the appropriate parameters to it. In our example
    here, we simply need to tell the plugin to use the default profile we created
    earlier. Create a file called `mastery_aws_ec2.yml`, which contains the following
    content:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，我们现在可以创建我们的清单定义，告诉Ansible使用哪个插件，并向其传递适当的参数。在我们的示例中，我们只需要告诉插件使用我们之前创建的默认配置文件。创建一个名为`mastery_aws_ec2.yml`的文件，其中包含以下内容：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we will test our new inventory plugin configuration by passing it
    to the `ansible-inventory` command with the `–graph` parameter:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过使用`-graph`参数将我们的新清单插件配置传递给`ansible-inventory`命令来测试它：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Assuming you have some instances running in AWS EC2, you will see a similar
    output to the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在AWS EC2中运行了一些实例，您将看到类似以下的输出：
- en: '![Figure 1.5 – An example output from the dynamic inventory plugin'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.5 - 动态清单插件的示例输出'
- en: '](Images/B17462_01_05.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_01_05.jpg)'
- en: Figure 1.5 – An example output from the dynamic inventory plugin
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 - 动态清单插件的示例输出
- en: Voila! We have a listing of our current AWS inventory, along with a glimpse
    into the automatic grouping performed by the plugin. If you want to delve further
    into the capabilities of the plugin and view, for example, all the inventory variables
    assigned to each host (which contain useful information, including instance type
    and sizing), try passing the–`-list` parameter to `ansible-inventory` instead
    of–`-graph`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们有我们当前AWS清单的列表，以及插件执行的自动分组的一瞥。如果您想进一步了解插件的功能，并查看每个主机分配的所有清单变量（其中包含有用的信息，包括实例类型和大小），请尝试将`-list`参数传递给`ansible-inventory`，而不是`-graph`。
- en: 'With the AWS inventory in place, you could use this right away to run a single
    task or the entire playbook against this dynamic inventory. For example, to use
    the `ansible.builtin.ping` module to check Ansible authentication and connectivity
    to all the hosts in the inventory, you could run the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有了AWS清单，您可以立即使用它来针对这个动态清单运行单个任务或整个playbook。例如，要使用`ansible.builtin.ping`模块检查Ansible对清单中所有主机的身份验证和连接性，您可以运行以下命令：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Of course, this is just one example. However, if you follow this process for
    other dynamic inventory providers, you should get them to work with ease.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个例子。然而，如果您对其他动态清单提供程序遵循这个过程，您应该能够轻松地使它们工作。
- en: In [*Chapter 10*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183), *Extending
    Ansible*, we will develop our own custom inventory plugin to demonstrate how they
    operate.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183)，*扩展Ansible*中，我们将开发自己的自定义清单插件，以演示它们的操作方式。
- en: Runtime inventory additions
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时清单添加
- en: Just like static inventory files, it is important to remember that Ansible will
    parse this data once, and only once, per the `ansible` or `ansible-playbook` execution.
    This is a fairly common stumbling point for users of cloud dynamic sources, where,
    frequently, a playbook will create a new cloud resource and then attempt to use
    it as if it were part of the inventory. This will fail, as the resource was not
    part of the inventory when the playbook launched. All is not lost, though! A special
    module is provided that allows a playbook to temporarily add an inventory to the
    in-memory inventory object, that is, the `ansible.builtin.add_host` module.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 就像静态清单文件一样，重要的是要记住，Ansible将在每次`ansible`或`ansible-playbook`执行时解析这些数据一次，而且只有一次。这对于云动态源的用户来说是一个相当常见的绊脚石，经常会出现playbook创建新的云资源，然后尝试将其用作清单的一部分。这将失败，因为在playbook启动时，该资源不是清单的一部分。然而，一切并非都已经丧失！提供了一个特殊的模块，允许playbook临时将清单添加到内存中的清单对象，即`ansible.builtin.add_host`模块。
- en: 'This module takes two options: `name` and `groups`. The `name` option should
    be obvious; it defines the hostname that Ansible will use when connecting to this
    particular system. The `groups` option is a comma-separated list of groups that
    you can add to this new system. Any other option passed to this module will become
    the host variable data for this host. For example, if we want to add a new system,
    name it `newmastery.example.name`, add it to the `web` group, and instruct Ansible
    to connect to it by way of IP address `192.168.10.30`. This will create a task
    that resembles the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块有两个选项：`name`和`groups`。`name`选项应该很明显；它定义了Ansible在连接到这个特定系统时将使用的主机名。`groups`选项是一个逗号分隔的组列表，您可以将其添加到这个新系统中。传递给该模块的任何其他选项都将成为该主机的主机变量数据。例如，如果我们想要添加一个新系统，命名为`newmastery.example.name`，将其添加到`web`组，并指示Ansible通过IP地址`192.168.10.30`连接到它。这将创建一个类似以下的任务：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This new host will be available to use – either by way of the name provided
    or by way of the `web` group – for the rest of the `ansible-playbook` execution.
    However, once the execution has been completed, this host will not be available
    unless it has been added to the inventory source itself. Of course, if this were
    a new cloud resource that had been created, the next `ansible` or `ansible-playbook`
    execution that sourced a dynamic inventory from that cloud would pick up the new
    member.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新主机将可供使用 - 无论是通过提供的名称还是通过`web`组 - 用于`ansible-playbook`执行的其余部分。然而，一旦执行完成，除非它已被添加到清单源本身，否则该主机将不可用。当然，如果这是一个新创建的云资源，下一个从该云源获取动态清单的`ansible`或`ansible-playbook`执行将会捕获到新的成员。
- en: Inventory limiting
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清单限制
- en: As mentioned earlier, every execution of `ansible` or `ansible-playbook` will
    parse the entire inventory it has been provided with. This is even true when a
    limit has been applied. Put simply, a limit is applied at runtime by making use
    of the `--limit` runtime argument to `ansible` or `ansible-playbook`. This argument
    accepts a pattern, which is essentially a mask to apply to the inventory. The
    entire inventory is parsed, and at each play, the limit mask that is supplied
    restricts the play to only run against the pattern that has been specified.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每次执行`ansible`或`ansible-playbook`都将解析其所提供的整个清单。即使应用了限制，这也是真实的。简单地说，通过使用`--limit`运行时参数来运行`ansible`或`ansible-playbook`来在运行时应用限制。该参数接受一个模式，本质上是应用于清单的掩码。整个清单被解析，每次play时，所提供的限制掩码都限制了play只针对已指定的模式运行。
- en: 'Let''s take our previous inventory example and demonstrate the behavior of
    Ansible with and without a limit. If you recall, we have a special group, `all`,
    that we can use to reference all of the hosts within an inventory. Let''s assume
    that our inventory is written out in the current working directory, in a file
    named `mastery-hosts`, and we will construct a playbook to demonstrate the host
    on which Ansible is operating. Let''s write this playbook out as `mastery.yaml`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以前的清单示例，并演示有限制和无限制时Ansible的行为。如果您还记得，我们有一个特殊的组`all`，我们可以用它来引用清单中的所有主机。假设我们的清单写在当前工作目录中，文件名为`mastery-hosts`，我们将构建一个playbook来演示Ansible正在操作的主机。让我们将这个playbook写成`mastery.yaml`：
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `ansible.builtin.debug` module is used to print out text or values of variables.
    We'll use this module a lot in this book to simulate the actual work being done
    on a host.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible.builtin.debug`模块用于打印文本或变量的值。在本书中，我们将经常使用这个模块来模拟在主机上实际执行的工作。'
- en: 'Now, let''s execute this simple playbook without supplying a limit. For simplicity''s
    sake, we will instruct Ansible to utilize a local connection method, which will
    execute locally rather than attempt to SSH to these nonexistent hosts. Run the
    following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行这个简单的playbook，而不提供限制。为了简单起见，我们将指示Ansible使用本地连接方法，这将在本地执行，而不是尝试SSH到这些不存在的主机。运行以下命令：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output should appear similar to *Figure 1.6*:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该与*图1.6*类似：
- en: '![Figure 1.6 – Running the simple playbook on an inventory without a limit
    applied'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6 - 在未应用限制的清单上运行简单的playbook'
- en: '](Images/B17462_01_06.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_01_06.jpg)'
- en: Figure 1.6 – Running the simple playbook on an inventory without a limit applied
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 - 在未应用限制的清单上运行简单的playbook
- en: 'As you can see, both the `backend.example.name` and `mastery.example.name`
    hosts were operated on. Now, let''s see what happens if we supply a limit, that
    is, to limit our run to the frontend systems only, by running the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`backend.example.name`和`mastery.example.name`主机都被操作了。现在，让我们看看如果我们提供一个限制会发生什么，也就是说，通过运行以下命令来限制我们的运行只针对前端系统：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This time around, the output should appear similar to *Figure 1.7*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，输出应该与*图1.7*类似：
- en: '![Figure 1.7 – Running the simple playbook on an inventory with a limit applied'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.7 - 在应用了限制的清单上运行简单的playbook'
- en: '](Images/B17462_01_07.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_01_07.jpg)'
- en: Figure 1.7 – Running the simple playbook on an inventory with a limit applied
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 - 在应用了限制的清单上运行简单的playbook
- en: Here, we can see that only `mastery.example.name` was operated on this time.
    While there are no visual clues that the entire inventory was parsed, if we dive
    into the Ansible code and examine the inventory object, we will indeed find all
    the hosts within. Additionally, we will see how the limit is applied every time
    the object is queried for items.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这次只有`mastery.example.name`被操作了。虽然没有视觉线索表明整个清单已被解析，但如果我们深入研究Ansible代码并检查清单对象，我们确实会发现其中的所有主机。此外，我们将看到每次查询对象时限制是如何应用的。
- en: 'It is important to remember that regardless of the host''s pattern used in
    a play, or the limit that is supplied at runtime, Ansible will still parse the
    entire inventory that is set during each run. In fact, we can prove this by attempting
    to access the host variable data for a system that would otherwise be masked by
    our limit. Let''s expand our playbook slightly and attempt to access the `ansible_port`
    variable from `backend.example.name`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，无论在play中使用的主机模式，还是在运行时提供的限制，Ansible都会在每次运行时解析整个清单。事实上，我们可以通过尝试访问`backend.example.name`的`ansible_port`变量数据来证明这一点，这个系统在其他情况下会被我们的限制掩盖。让我们稍微扩展一下我们的playbook，并尝试访问`backend.example.name`的`ansible_port`变量：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will still apply our limit by running the playbook with the same command
    we used in the previous run, which will restrict our operations to just `mastery.example.name`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然会通过与上一次运行相同的命令来应用我们的限制，这将限制我们的操作仅限于`mastery.example.name`：
- en: '![Figure 1.8 – Demonstrating that the entire inventory is parsed even with
    a limit applied'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.8 - 演示即使应用了限制，整个清单仍然被解析'
- en: '](Images/B17462_01_08.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_01_08.jpg)'
- en: Figure 1.8 – Demonstrating that the entire inventory is parsed even with a limit
    applied
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 - 演示即使应用了限制，整个清单仍然被解析
- en: We have successfully accessed the host variable data (by way of group variables)
    for a system that was otherwise limited out. This is a key skill to understand,
    as it allows for more advanced scenarios, such as directing a task at a host that
    is otherwise limited out. Additionally, delegation can be used to manipulate a
    load balancer; this will put a system into maintenance mode while it is being
    upgraded without you having to include the load balancer system in your limit
    mask.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功访问了主机变量数据（通过组变量）的系统，否则会被限制。这是一个重要的技能，因为它允许更高级的场景，比如将任务指向一个被限制的主机。此外，可以使用委托来操纵负载均衡器；这将在升级系统时将系统置于维护模式，而无需将负载均衡器系统包含在限制掩码中。
- en: Playbook parsing
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: playbook解析
- en: 'The whole purpose of an inventory source is to have systems to manipulate.
    The manipulation comes from playbooks (or, in the case of Ansible ad hoc execution,
    simple single-task plays). You should already have a basic understanding of playbook
    construction, so we won''t spend a lot of time covering that; however, we will
    delve into some specifics of how a playbook is parsed. Specifically, we will cover
    the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 清单来源的整个目的是有系统可以操作。操作来自playbook（或者，在Ansible即席执行的情况下，简单的单任务play）。您应该已经对playbook的构建有基本的了解，因此我们不会花太多时间来介绍；但是，我们将深入探讨playbook的解析方式的一些具体细节。具体来说，我们将涵盖以下内容：
- en: The order of operations
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作顺序
- en: Relative path assumptions
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对路径假设
- en: Play behavior keys
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放行为键
- en: The host selection for plays and tasks
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为play和任务选择主机
- en: Play and task names
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放和任务名称
- en: The order of operations
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作顺序
- en: Ansible is designed to be as easy as possible for humans to understand. The
    developers strive to strike the best balance of human comprehension and machine
    efficiency. To that end, nearly everything in Ansible can be assumed to be executed
    in a top-to-bottom order; that is, the operation listed at the top of a file will
    be accomplished before the operation listed at the bottom of a file. Having said
    that, there are a few caveats and even a few ways to influence the order of operations.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible旨在尽可能地让人类理解。开发人员努力在人类理解和机器效率之间取得最佳平衡。为此，几乎可以假定Ansible中的所有操作都是按自上而下的顺序执行的；也就是说，文件顶部列出的操作将在文件底部列出的操作之前完成。话虽如此，还有一些注意事项，甚至有一些影响操作顺序的方法。
- en: A playbook only has two main operations it can accomplish. It can either run
    a play, or it can include another playbook from somewhere on the filesystem. The
    order in which these are accomplished is simply the order in which they appear
    in the playbook file, from top to bottom. It is important to note that while the
    operations are executed in order, the entire playbook and any included playbooks
    are completely parsed before any executions. This means that any included playbook
    file has to exist at the time of the playbook parsing – they cannot be generated
    in an earlier operation. This is specific to playbook inclusions but not necessarily
    to task inclusions that might appear within a play, which will be covered in a
    later chapter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: playbook只有两个主要操作可以完成。它可以运行一个play，或者它可以从文件系统的某个地方包含另一个playbook。这些操作的完成顺序只是它们在playbook文件中出现的顺序，从上到下。重要的是要注意，虽然操作是按顺序执行的，但在任何执行之前整个playbook和任何包含的playbook都会被完全解析。这意味着任何包含的playbook文件必须在playbook解析时存在-它们不能在较早的操作中生成。这是特定于playbook包含的，但不一定适用于可能出现在play中的任务包含，这将在后面的章节中介绍。
- en: 'Within a play, there are a few more operations. While a playbook is strictly
    ordered from top to bottom, a play has a more nuanced order of operations. Here
    is a list of the possible operations and the order in which they will occur:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在play中，还有一些更多的操作。虽然playbook严格按照自上而下的顺序排列，但play具有更细致的操作顺序。以下是可能的操作列表以及它们将发生的顺序：
- en: Variable loading
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量加载
- en: Fact gathering
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事实收集
- en: The `pre_tasks` execution
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pre_tasks`执行'
- en: Handlers notified from the `pre_tasks` execution
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`pre_tasks`执行通知的处理程序
- en: The roles execution
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色执行
- en: The tasks execution
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务执行
- en: Handlers notified from the roles or tasks execution
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从角色或任务执行通知的处理程序
- en: The `post_tasks` execution
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post_tasks`执行'
- en: Handlers notified from the `post_tasks` execution
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`post_tasks`执行通知的处理程序
- en: 'The following is an example play with most of these operations shown:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例play，其中显示了大部分这些操作：
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Regardless of the order in which these blocks are listed in a play, the order
    detailed in the previous code block is the order in which they will be processed.
    Handlers (that is, the tasks that can be triggered by other tasks that result
    in a change) are a special case. There is a utility module, `ansible.builtin.meta`,
    that can be used to trigger handler processing at a specific point:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这些块在剧本中列出的顺序如何，前面代码块中详细说明的顺序就是它们将被处理的顺序。处理程序（即可以由其他任务触发并导致更改的任务）是一个特殊情况。有一个实用模块`ansible.builtin.meta`，可以用来在特定点触发处理程序的处理：
- en: '[PRE16]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will instruct Ansible to process any pending handlers at that point before
    continuing with the next task or next block of actions within a play. Understanding
    the order and being able to influence the order with `flush_handlers` is another
    key skill to have when there is a need to orchestrate complicated actions; for
    instance, where things such as service restarts are very sensitive to order. Consider
    the initial rollout of a service.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示Ansible在继续下一个任务或播放中的下一个操作块之前，在那一点处理任何待处理的处理程序。了解顺序并能够通过`flush_handlers`影响顺序是在需要编排复杂操作时必须具备的另一个关键技能；例如，诸如服务重启对顺序非常敏感的情况。考虑服务的初始部署。
- en: The play will have tasks that modify `config` files and indicate that the service
    should be restarted when these files change. The play will also indicate that
    the service should be running. The first time this play happens, the `config`
    file will change, and the service will change from not running to running. Then,
    the handlers will trigger, which will cause the service to restart immediately.
    This can be disruptive to any consumers of the service. It is better to flush
    the handlers before a final task to ensure the service is running. This way, the
    restart will happen before the initial start, so the service will start up once
    and stay up.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: play将有修改`config`文件并指示应该在这些文件更改时重新启动服务的任务。play还将指示服务应该在运行。第一次发生这个play时，`config`文件将更改，并且服务将从未运行变为运行。然后，处理程序将触发，这将导致服务立即重新启动。这可能会对服务的任何使用者造成干扰。最好在最后一个任务之前刷新处理程序，以确保服务正在运行。这样，重新启动将在初始启动之前发生，因此服务将启动一次并保持运行。
- en: Relative path assumptions
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相对路径假设
- en: 'When Ansible parses a playbook, there are certain assumptions that can be made
    about the relative paths of items referenced by the statements in a playbook.
    In most cases, paths for things such as variable files to include, task files
    to include, playbook files to include, files to copy, templates to render, and
    scripts to execute are all relative to the directory where the file that is referencing
    them resides. Let''s explore this with an example playbook and directory listing
    to demonstrate where the files are:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当Ansible解析一个playbook时，可以对playbook中的语句引用的项目的相对路径做出一些假设。在大多数情况下，诸如要包含的变量文件、要包含的任务文件、要包含的playbook文件、要复制的文件、要渲染的模板和要执行的脚本等的路径都是相对于引用它们的文件所在的目录的。让我们通过一个示例playbook和目录列表来探讨这一点，以演示文件的位置：
- en: 'The directory structure is as follows:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录结构如下：
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The content of `a_vars_file.yaml` is as follows:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a_vars_file.yaml`的内容如下：'
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The content of `relative.yaml` is as follows:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`relative.yaml`的内容如下：'
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The content of `tasks/a.yaml` is as follows:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasks/a.yaml`的内容如下：'
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The content of `tasks/b.yaml` is as follows:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasks/b.yaml`的内容如下：'
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The execution of the playbook is performed with the following command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令执行playbook：
- en: '[PRE22]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output should be similar to *Figure 1.9*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应类似于*图1.9*：
- en: '![Figure 1.9 – The expected output from running a playbook utilizing relative
    paths'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.9 - 运行利用相对路径的playbook的预期输出'
- en: '](Images/B17462_01_09.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_01_09.jpg)'
- en: Figure 1.9 – The expected output from running a playbook utilizing relative
    paths
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 - 运行利用相对路径的playbook的预期输出
- en: Here, we can clearly see the relative references to the paths and how they are
    relative to the file referencing them. When using roles, there are some additional
    relative path assumptions; however, we'll cover that, in detail, in a later chapter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以清楚地看到对路径的相对引用以及它们相对于引用它们的文件的位置。在使用角色时，还有一些额外的相对路径假设；然而，我们将在后面的章节中详细介绍。
- en: Play behavior directives
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Play行为指令
- en: 'When Ansible parses a play, there are a few directives it looks for in order
    to define various behaviors for a play. These directives are written at the same
    level as the `hosts:` directive. Here is a list of descriptions for some of the
    more frequently used keys that can be defined in this section of the playbook:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当Ansible解析一个play时，它会寻找一些指令，以定义play的各种行为。这些指令与`hosts:`指令在同一级别编写。以下是一些在playbook的这一部分中可以定义的一些更常用键的描述列表：
- en: '`any_errors_fatal`: This Boolean directive is used to instruct Ansible to treat
    any failure as a fatal error to prevent any further tasks from being attempted.
    This changes the default, where Ansible will continue until all the tasks have
    been completed or all the hosts have failed.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any_errors_fatal`：这是一个布尔指令，用于指示Ansible将任何失败都视为致命错误，以防止尝试进一步的任务。这会改变默认行为，其中Ansible将继续执行，直到所有任务完成或所有主机失败。'
- en: '`connection`: This string directive defines which connection system to use
    for a given play. A common choice to make here is `local`, which instructs Ansible
    to do all the operations locally but with the context of the system from the inventory.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connection`：这个字符串指令定义了在给定play中使用哪种连接系统。在这里做出的一个常见选择是`local`，它指示Ansible在本地执行所有操作，但使用清单中系统的上下文。'
- en: '`collections`: This is a list of the collection namespaces used within the
    play to search for modules, plugins, and roles, and it can be used to prevent
    the need to enter **Fully Qualified Collection Names** (**FQCNs**) – we will learn
    more about this in [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047),
    *Migrating from Earlier Ansible Versions*. Note that this value does not get inherited
    by role tasks, so you must set it separately in each role in the `meta/main.yml`
    file.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collections`：这是在play中用于搜索模块、插件和角色的集合命名空间列表，可以用来避免输入**完全限定的集合名称**（**FQCNs**）的需要
    - 我们将在[*第2章*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047)中了解更多，*从早期Ansible版本迁移*。请注意，这个值不会被角色任务继承，因此您必须在`meta/main.yml`文件中为每个角色单独设置它。'
- en: '`gather_facts`: This Boolean directive controls whether or not Ansible will
    perform the fact-gathering phase of the operation, where a special task will run
    on a host to uncover various facts about the system. Skipping fact gathering –
    when you are sure that you do not require any of the discovered data – can be
    a significant time-saver in a large environment.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gather_facts`：这个布尔指令控制Ansible是否执行操作的事实收集阶段，其中一个特殊任务将在主机上运行，以揭示关于系统的各种事实。跳过事实收集
    - 当您确定不需要任何已发现的数据时 - 可以在大型环境中节省大量时间。'
- en: '`Max_fail_percentage`: This number directive is similar to `any_errors_fatal`,
    but it is more fine-grained. It allows you to define what percentage of your hosts
    can fail before the whole operation is halted.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Max_fail_percentage`：这个数字指令类似于`any_errors_fatal`，但更加细致。它允许您定义在整个操作被停止之前，您的主机可以失败的百分比。'
- en: '`no_log`: This is a Boolean to control whether or not Ansible will log (to
    the screen and/or a configured `log` file) the command given or the results received
    from a task. This is important if your task or return deals with secrets. This
    key can also be applied to a task directly.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no_log`：这是一个布尔指令，用于控制Ansible是否记录（到屏幕和/或配置的`log`文件）给定的命令或从任务接收的结果。如果您的任务或返回涉及机密信息，这一点非常重要。这个键也可以直接应用于一个任务。'
- en: '`port`: This is a number directive to define what SSH port (or any other remote
    connection plugin) you should use to connect unless this is already configured
    in the inventory data.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`：这是一个数字指令，用于定义连接时应使用的SSH端口（或任何其他远程连接插件），除非这已经在清单数据中配置。'
- en: '`remote_user`: This is a string directive that defines which user to log in
    with on the remote system. The default setting is to connect as the same user
    that `ansible-playbook` was started with.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remote_user`：这是一个字符串指令，定义了在远程系统上使用哪个用户登录。默认设置是以与启动`ansible-playbook`的相同用户连接。'
- en: '`serial`: This directive takes a number and controls how many systems Ansible
    will execute a task on before moving to the next task in a play. This is a drastic
    change from the normal order of operations, where a task is executed across every
    system in a play before moving to the next. This is very useful in rolling update
    scenarios, which we will discuss in later chapters.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serial`：此指令接受一个数字，并控制在移动到播放中的下一个任务之前，Ansible将在多少个系统上执行任务。这与正常操作顺序有很大的改变，在正常操作顺序中，任务在移动到下一个任务之前会在播放中的每个系统上执行。这在滚动更新场景中非常有用，我们将在后面的章节中讨论。'
- en: '`become`: This is a Boolean directive that is used to configure whether privilege
    escalation (`sudo` or something else) should be used on the remote host to execute
    tasks. This key can also be defined at a task level. Related directives include
    `become_user`, `become_method`, and `become_flags`. These can be used to configure
    how the escalation will occur.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`become`：这是一个布尔指令，用于配置是否应在远程主机上使用特权升级（`sudo`或其他内容）来执行任务。此键也可以在任务级别定义。相关指令包括`become_user`、`become_method`和`become_flags`。这些可以用于配置升级的方式。'
- en: '`strategy`: This directive sets the execution strategy to be used for the play.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strategy`：此指令设置用于播放的执行策略。'
- en: Many of these keys will be used in the example playbooks throughout this book.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例playbooks将使用许多这些键。
- en: For a full list of available play directives, please refer to the online documentation
    at [https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#play](https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#play).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可用播放指令的完整列表，请参阅[https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#play](https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#play)上的在线文档。
- en: Execution strategies
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行策略
- en: 'With the release of Ansible 2.0, a new way to control play execution behavior
    was introduced: *strategy*. A strategy defines how Ansible coordinates each task
    across the set of hosts. Each strategy is a plugin, and three strategies come
    with Ansible: linear, debug, and free. The linear strategy, which is the default
    strategy, is how Ansible has always behaved. As a play is executed, all the hosts
    for a given play execute the first task.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Ansible 2.0的发布，引入了一种控制播放执行行为的新方法：*strategy*。策略定义了Ansible如何在一组主机上协调每个任务。每个策略都是一个插件，Ansible带有三种策略：linear、debug和free。线性策略是默认策略，这是Ansible一直以来的行为方式。在执行播放时，给定播放的所有主机执行第一个任务。
- en: Once they are all complete, Ansible moves to the next task. The serial directive
    can create batches of hosts to operate in this way, but the base strategy remains
    the same. All the targets for a given batch must complete a task before the next
    task is executed. The debug strategy makes use of the same linear mode of execution
    described earlier, except that here, tasks are run in an interactive debugging
    session rather than running to completion without any user intervention. This
    is especially valuable during the testing and development of complex and/or long-running
    automation code where you need to analyze the behavior of the Ansible code as
    it runs, rather than simply running it and hoping for the best!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它们全部完成，Ansible就会移动到下一个任务。串行指令可以创建批处理主机以这种方式操作，但基本策略保持不变。在执行下一个任务之前，给定批次的所有目标都必须完成一个任务。调试策略使用了前面描述的相同的线性执行模式，只是这里，任务是在交互式调试会话中运行，而不是在没有任何用户干预的情况下运行到完成。这在测试和开发复杂和/或长时间运行的自动化代码时特别有价值，您需要分析Ansible代码运行时的行为，而不仅仅是运行它并希望一切顺利！
- en: The free strategy breaks from this traditional linear behavior. When using the
    free strategy, as soon as a host completes a task, Ansible will execute the next
    task for that host, without waiting for any other hosts to finish.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 自由策略打破了这种传统的线性行为。使用自由策略时，一旦主机完成一个任务，Ansible将立即为该主机执行下一个任务，而不必等待其他主机完成。
- en: This will happen for every host in the set and for every task in the play. Each
    host will complete the tasks as fast as they can, thus minimizing the execution
    time of each specific host. While most playbooks will use the default linear strategy,
    there are situations where the free strategy would be advantageous; for example,
    when upgrading a service across a large set of hosts. If the play requires numerous
    tasks to perform the upgrade, which starts with shutting down the service, then
    it would be more important for each host to suffer as little downtime as possible.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发生在集合中的每个主机和播放中的每个任务。每个主机将尽可能快地完成任务，从而最大限度地减少每个特定主机的执行时间。虽然大多数playbooks将使用默认的线性策略，但也有一些情况下，自由策略会更有优势；例如，在跨大量主机升级服务时。如果播放需要执行大量任务来执行升级，从关闭服务开始，那么每个主机尽可能少地遭受停机时间就更为重要。
- en: Allowing each host to independently move through the play as fast as it can
    will ensure that each host is only down for as long as necessary. Without using
    the free strategy, the entire set will be down for as long as the slowest host
    in the set takes to complete the tasks.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 允许每个主机独立地尽快地通过播放，将确保每个主机只在必要的时间内停机。如果不使用自由策略，整个集合将会在集合中最慢的主机完成任务所需的时间内停机。
- en: As the free strategy does not coordinate task completion across hosts, it is
    not possible to depend on the data that is generated during a task on one host
    to be available for use in a later task on a different host. There is no guarantee
    that the first host will have completed the task that generates the data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于自由策略不协调主机之间的任务完成，因此不可能依赖在一个主机上生成的数据在另一个主机上的后续任务中可用。不能保证第一个主机已经完成生成数据的任务。
- en: Execution strategies are implemented as a plugin and, as such, custom strategies
    can be developed to extend Ansible behavior by anyone who wishes to contribute
    to the project.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 执行策略被实现为一个插件，因此任何希望为项目做出贡献的人都可以开发自定义策略来扩展Ansible的行为。
- en: The host selection for plays and tasks
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放和任务的主机选择
- en: 'The first thing that most plays define (after a name, of course) is a host
    pattern for the play. This is the pattern used to select hosts out of the inventory
    object to run the tasks on. Generally, this is straightforward; a host pattern
    contains one or more blocks indicating a host, group, wildcard pattern, or **regular
    expression** (**regex**) to use for the selection. Blocks are separated by a colon,
    wildcards are just an asterisk, and regex patterns start with a tilde:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数播放定义的第一件事（当然是名称之后）是播放的主机模式。这是用于从清单对象中选择主机以运行任务的模式。一般来说，这很简单；主机模式包含一个或多个块，指示主机、组、通配符模式或**正则表达式**（**regex**）用于选择。块之间用冒号分隔，通配符只是一个星号，正则表达式模式以波浪号开头：
- en: '[PRE23]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Advanced usage can include group index selections or even ranges within a group:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 高级用法可以包括组索引选择，甚至是组内的范围：
- en: '[PRE24]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Each block is treated as an inclusion block; that is, all the hosts found in
    the first pattern are added to all the hosts found in the next pattern, and so
    on. However, this can be manipulated with control characters to change their behavior.
    The use of an ampersand defines an inclusion-based selection (all the hosts that
    exist in both patterns).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 每个块都被视为包含块；也就是说，找到在第一个模式中的所有主机都被添加到在下一个模式中找到的所有主机中，依此类推。但是，可以使用控制字符来改变它们的行为。使用和符号定义了基于包含的选择（存在于两个模式中的所有主机）。
- en: 'The use of an exclamation point defines an exclusion-based selection (all the
    hosts that exist in the previous patterns but are NOT in the exclusion pattern):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 感叹号的使用定义了一个基于排除的选择（存在于先前模式中的所有主机，但不在排除模式中）：
- en: '`webservers:&dbservers`: Hosts must exist in both the `webservers` and `dbservers`
    groups.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webservers:&dbservers`：主机必须同时存在于`webservers`和`dbservers`组中。'
- en: '`webservers:!dbservers`: Hosts must exist in the `webservers` group but not
    the `dbservers` group.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webservers:!dbservers`：主机必须存在于`webservers`组中，但不能存在于`dbservers`组中。'
- en: Once Ansible parses the patterns, it will then apply restrictions if there are
    any. Restrictions come in the form of limits or failed hosts. This result is stored
    for the duration of the play, and it is accessible via the `play_hosts` variable.
    As each task is executed, this data is consulted, and an additional restriction
    could be placed upon it to handle serial operations. As failures are encountered,
    be it a failure to connect or a failure to execute a task, the failed host is
    placed in a restriction list so that the host will be bypassed in the next task.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Ansible解析模式，它将根据需要应用限制。限制以限制或失败的主机的形式出现。此结果将存储在播放的持续时间内，并且可以通过`play_hosts`变量访问。在执行每个任务时，将咨询此数据，并且可能会对其施加额外的限制以处理串行操作。当遇到故障时，无论是连接失败还是执行任务失败，故障主机都将被放置在限制列表中，以便在下一个任务中绕过该主机。
- en: If, at any time, a host selection routine gets restricted down to zero hosts,
    the play execution will stop with an error. A caveat here is that if the play
    is configured to have a `max_fail_precentage` or `any_errors_fatal` parameter,
    then the playbook execution stops immediately after the task where this condition
    is met.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何时候，主机选择例程被限制为零个主机，播放执行将停止并显示错误。这里的一个警告是，如果播放配置为具有`max_fail_precentage`或`any_errors_fatal`参数，那么在满足此条件的任务之后，播放簿执行将立即停止。
- en: Play and task names
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 播放和任务名称
- en: While not strictly necessary, it is a good practice to label your plays and
    tasks with names. These names will show up in the command-line output of `ansible-playbook`
    and will show up in the log file if the output of `ansible-playbook` is directed
    to log to a file. Task names also come in handy when you want to direct `ansible-playbook`
    to start at a specific task and to reference handlers.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是严格必要的，但将您的播放和任务标记为名称是一个好习惯。这些名称将显示在`ansible-playbook`的命令行输出中，并且如果将`ansible-playbook`的输出定向到日志文件中，这些名称也将显示在日志文件中。任务名称在您想要指示`ansible-playbook`从特定任务开始并引用处理程序时也会派上用场。
- en: 'There are two main points to consider when naming plays and tasks:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名播放和任务时，有两个主要要考虑的点：
- en: The names of the plays and tasks should be unique.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放和任务的名称应该是唯一的。
- en: Beware of the kinds of variables that can be used in play and task names.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小心可以在播放和任务名称中使用的变量类型。
- en: In general, naming plays and tasks uniquely is a best practice that will help
    to quickly identify where a problematic task could be residing in your hierarchy
    of playbooks, roles, task files, handlers, and more. When you first write a small
    monolithic playbook, they might not seem that important. However, as your use
    of and confidence in Ansible grows, you will quickly be glad that you named your
    tasks! Uniqueness is more important when notifying a handler or when starting
    at a specific task. When task names have duplicates, the behavior of Ansible could
    be non-deterministic, or at least non-obvious.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为播放和任务命名是一个最佳实践，可以帮助快速确定问题任务可能位于播放簿、角色、任务文件、处理程序等层次结构中的位置。当您首次编写一个小型的单片播放簿时，它们可能看起来并不重要。然而，随着您对Ansible的使用和信心的增长，您很快会为自己命名任务而感到高兴！当任务名称重复时，在通知处理程序或从特定任务开始时，唯一性更为重要。当任务名称重复时，Ansible的行为可能是不确定的，或者至少是不明显的。
- en: 'With uniqueness as a goal, many playbook authors will look to variables to
    satisfy this constraint. This strategy might work well, but authors need to be
    careful regarding the source of the variable data they are referencing. Variable
    data can come from a variety of locations (which we will cover later in this chapter),
    and the values assigned to variables can be defined a variety of times. For the
    sake of play and task names, it is important to remember that only variables for
    which the values can be determined at the playbook parse time will parse and render
    correctly. If the data of a referenced variable is discovered via a task or other
    operation, the variable string will be displayed as unparsed in the output. Let''s
    take a look at an example playbook that utilizes variables for play and task names:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以唯一性为目标，许多播放作者将寻求使用变量来满足这一约束。这种策略可能效果很好，但作者需要注意引用的变量数据的来源。变量数据可以来自各种位置（我们将在本章后面介绍），并且分配给变量的值可以多次定义。为了播放和任务名称的缘故，重要的是要记住，只有那些在播放解析时间可以确定值的变量才会正确解析和呈现。如果引用的变量的数据是通过任务或其他操作发现的，那么变量字符串将显示为未解析的输出。让我们看一个利用变量来命名播放和任务的示例播放：
- en: '[PRE25]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At first glance, you might expect at least `var_name` and `task_var_name` to
    render correctly. We can clearly see `task_var_name` being defined before its
    use. However, armed with our knowledge that playbooks are parsed in their entirety
    before execution, we know better. Run the example playbook with the following
    command:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，您可能期望至少`var_name`和`task_var_name`能够正确呈现。我们可以清楚地看到`task_var_name`在使用之前被定义。然而，凭借我们的知识，即播放在执行之前会被完全解析，我们知道得更多。使用以下命令运行示例播放：
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output should look something like *Figure 1.10*:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像*图1.10*：
- en: '![Figure 1.10 – A playbook run showing the effect of using variables in task
    names when they are not defined prior to execution'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.10 - 一个播放运行，显示在执行之前未定义变量时在任务名称中使用变量的效果'
- en: '](Images/B17462_01_10.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_01_10.jpg)'
- en: Figure 1.10 – A playbook run showing the effect of using variables in task names
    when they are not defined prior to execution
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 - 一个播放运行，显示在执行之前未定义变量时在任务名称中使用变量的效果
- en: As you can see in *Figure 1.10*, the only variable name that is properly rendered
    is `var_name`, as it was defined as a static play variable.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在*图1.10*中所看到的，唯一正确呈现的变量名称是`var_name`，因为它被定义为静态播放变量。
- en: Module transport and execution
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块传输和执行
- en: Once a playbook is parsed and the hosts are determined, Ansible is ready to
    execute a task. Tasks are made up of a name (this optional, but nonetheless important,
    as mentioned previously), a module reference, module arguments, and task control
    directives. In Ansible 2.9 and earlier, modules were identified by a single unique
    name. However, in versions of Ansible such as 2.10 and later, the advent of collections
    (which we will discuss in more detail in the next chapter) meant that Ansible
    module names could now be non-unique. As a result, those of you with prior Ansible
    experience might have noticed that, in this book, we are using `ansible.builtin.debug`
    instead of `debug`, which we would have used in Ansible 2.9 and earlier. In some
    cases, you can still get away with using the short-form module names (such as
    `debug`); however, remember that the presence of a collection with its own module
    called `debug` might cause unexpected results. And, as such, the advice from Ansible
    in their official documentation is to start making friends with the long-form
    module names as soon as possible – these are officially called FQCNs. We will
    use them throughout this book and will explain all of this in more detail in the
    next chapter. In addition to this, a later chapter will cover task control directives
    in detail, so we will only concern ourselves with the module reference and arguments.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦播放被解析并确定了主机，Ansible就准备执行一个任务。任务由名称（这是可选的，但仍然很重要，如前面提到的），模块引用，模块参数和任务控制指令组成。在Ansible
    2.9及更早版本中，模块由单个唯一名称标识。然而，在Ansible 2.10及更高版本中，集合的出现（我们将在下一章中更详细地讨论）意味着Ansible模块名称现在可以是非唯一的。因此，那些有先前Ansible经验的人可能已经注意到，在本书中，我们使用`ansible.builtin.debug`而不是在Ansible
    2.9及更早版本中使用的`debug`。在某些情况下，您仍然可以使用短形式的模块名称（如`debug`）；但是，请记住，具有自己名为`debug`的集合的存在可能会导致意想不到的结果。因此，Ansible在其官方文档中的建议是尽快开始与长形式的模块名称交朋友
    - 这些被官方称为FQCNs。我们将在本书中使用它们，并将在下一章中更详细地解释所有这些。除此之外，后面的章节将详细介绍任务控制指令，因此我们只关注模块引用和参数。
- en: The module reference
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块引用
- en: Every task has a module reference. This tells Ansible which bit of work to carry
    out. Ansible has been designed to easily allow for custom modules to live alongside
    a playbook. These custom modules can be a whole new functionality, or they can
    replace modules shipped with Ansible itself. When Ansible parses a task and discovers
    the name of the module to use for a task, it looks in a series of locations in
    order to find the module requested. Where it looks also depends on where the task
    lives, for example, whether inside a role or not.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务都有一个模块引用。这告诉Ansible要执行哪个工作。Ansible被设计为可以轻松地允许自定义模块与播放一起存在。这些自定义模块可以是全新的功能，也可以替换Ansible自身提供的模块。当Ansible解析一个任务并发现要用于任务的模块的名称时，它会在一系列位置中查找所请求的模块。它查找的位置也取决于任务所在的位置，例如，是否在一个角色内部。
- en: If a task is inside a role, Ansible will first look for the module within a
    directory tree named `library` within the role the task resides in. If the module
    is not found there, Ansible looks for a directory named `library` at the same
    level as the main playbook (the one referenced by the `ansible-playbook` execution).
    If the module is not found there, Ansible will finally look in the configured
    library path, which defaults to `/usr/share/ansible/`. This library path can be
    configured in an Ansible `config` file or by way of the `ANSIBLE_LIBRARY` environment
    variable.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务位于一个角色内，Ansible首先会在任务所在的角色内部名为`library`的目录树中查找模块。如果在那里找不到模块，Ansible会在与主要剧本（由`ansible-playbook`执行引用的剧本）相同级别的目录中查找名为`library`的目录。如果在那里找不到模块，Ansible最终会在配置的库路径中查找，该路径默认为`/usr/share/ansible/`。可以在Ansible的`config`文件或通过`ANSIBLE_LIBRARY`环境变量中配置此库路径。
- en: In addition to the preceding paths (which have been established as valid module
    locations in Ansible almost since its inception), the advent of Ansible 2.10 and
    newer versions bring with them *Collections*. Collections are now one of the key
    ways in which modules can be organized and shared with others. For instance, in
    the earlier example where we looked at the Amazon EC2 dynamic inventory plugin,
    we installed a collection called `amazon.aws`. In that example, we only made use
    of the dynamic inventory plugin; however, installing the collection actually installed
    a whole set of modules for us to use to automate tasks on Amazon EC2\. The collection
    would have been installed in `~/.ansible/collections/ansible_collections/amazon/aws`
    if you ran the command provided in this book. If you look in there, you will find
    the modules in the `plugins/modules` subdirectory. Further collections that you
    install will be located in similar directories, which have been named after the
    collection that they were installed from.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前已经确定为Ansible几乎自问世以来的有效模块位置之外，Ansible 2.10和更新版本的出现带来了*Collections*。Collections现在是模块可以组织和与他人共享的关键方式之一。例如，在之前的示例中，我们查看了Amazon
    EC2动态清单插件，我们安装了一个名为`amazon.aws`的集合。在该示例中，我们只使用了动态清单插件；但是，安装集合实际上安装了一整套模块供我们用于自动化Amazon
    EC2上的任务。如果您运行了本书中提供的命令，该集合将安装在`~/.ansible/collections/ansible_collections/amazon/aws`中。如果您在那里查看，您将在`plugins/modules`子目录中找到模块。您安装的其他集合将位于类似的目录中，这些目录的名称是根据安装的集合命名的。
- en: This design, which enables modules to be bundled with collections, roles, and
    playbooks, allows for the addition of functionality or the reparation of problems
    quickly and easily.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计使模块能够与集合、角色和剧本捆绑在一起，可以快速轻松地添加功能或修复问题。
- en: Module arguments
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块参数
- en: 'Arguments to a module are not always required; the help output of a module
    will indicate which arguments are required and which are not. Module documentation
    can be accessed with the `ansible-doc` command, as follows (here, we will use
    the `debug` module, which we have already used as an example):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的参数并非总是必需的；模块的帮助输出将指示哪些参数是必需的，哪些是可选的。模块文档可以通过`ansible-doc`命令访问，如下所示（在这里，我们将使用`debug`模块，这是我们已经用作示例的模块）：
- en: '[PRE27]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Figure 1.11* shows the kind of output you can expect from this command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.11*显示了您可以从此命令中期望的输出类型：'
- en: '![Figure 1.11 – An example of the output from the ansible-doc command run on
    the debug module'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.11 - 运行在debug模块上的ansible-doc命令的输出示例'
- en: '](Images/B17462_01_11.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_01_11.jpg)'
- en: Figure 1.11 – An example of the output from the ansible-doc command run on the
    debug module
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 - 运行在debug模块上的ansible-doc命令的输出示例
- en: If you scroll through the output, you will find a wealth of useful information
    including example code, the outputs from the module, and the arguments (that is,
    options), as shown in *Figure 1.11*
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您浏览输出，您将找到大量有用的信息，包括示例代码，模块的输出以及参数（即选项），如*图1.11*所示。
- en: Arguments can be templated with **Jinja2**, which will be parsed at module execution
    time, allowing for data discovered in a previous task to be used in later tasks;
    this is a very powerful design element.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以使用**Jinja2**进行模板化，在模块执行时将被解析，允许在以后的任务中使用在先前任务中发现的数据；这是一个非常强大的设计元素。
- en: 'Arguments can either be supplied in a `key=value` format or in a complex format
    that is more native to YAML. Here are two examples of arguments being passed to
    a module showcasing these two formats:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以以`key=value`格式或更符合YAML本机格式的复杂格式提供。以下是展示这两种格式的参数传递给模块的两个示例：
- en: '[PRE28]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, both formats will lead to the same result; however, the complex
    format is required if you wish to pass complex arguments into a module. Some modules
    expect a list object or a hash of data to be passed in; the complex format allows
    for this. While both formats are acceptable for many tasks, the complex format
    is the format used for the majority of examples in this book as, despite its name,
    it is actually easier for humans to read.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，这两种格式将导致相同的结果；但是，如果您希望将复杂参数传递给模块，则需要使用复杂格式。一些模块期望传递列表对象或数据的哈希；复杂格式允许这样做。虽然这两种格式对于许多任务都是可以接受的，但是复杂格式是本书中大多数示例使用的格式，因为尽管其名称如此，但实际上更容易阅读。
- en: Module blacklisting
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块黑名单
- en: Starting with Ansible 2.5, it is now possible for system administrators to blacklist
    Ansible modules that they do not wish to be available to playbook developers.
    This might be for security reasons, to maintain conformity or even to avoid the
    use of deprecated modules.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 从Ansible 2.5开始，系统管理员现在可以将他们不希望对剧本开发人员可用的Ansible模块列入黑名单。这可能是出于安全原因，为了保持一致性，甚至是为了避免使用已弃用的模块。
- en: The location for the module blacklist is defined by the `plugin_filters_cfg`
    parameter found in the `defaults` section of the Ansible configuration file. By
    default, it is disabled, and the suggested default value is set to `/etc/ansible/plugin_filters.yml`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 模块黑名单的位置由Ansible配置文件的`defaults`部分中找到的`plugin_filters_cfg`参数定义。默认情况下，它是禁用的，建议的默认值设置为`/etc/ansible/plugin_filters.yml`。
- en: 'The format for this file is, at present, very simple. It contains a version
    header to allow for the file format to be updated in the future and a list of
    modules to be filtered out. For example, if you were preparing for a transition
    to Ansible 4.0 and were currently on Ansible 2.7, you would note that the `sf_account_manager`
    module is to be completely removed in Ansible 4.0\. As a result, you might wish
    to prevent users from making use of this by blacklisting it to prevent anyone
    from creating code that would break when Ansible 4.0 is rolled out (please refer
    to [https://docs.ansible.com/ansible/devel/porting_guides/porting_guide_2.7.html](https://docs.ansible.com/ansible/devel/porting_guides/porting_guide_2.7.html)).
    Therefore, to prevent anyone from using this internally, the `plugin_filters.yml`
    file should look like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，该文件的格式非常简单。它包含一个版本头，以便将来更新文件格式，并列出要过滤掉的模块列表。例如，如果您准备过渡到 Ansible 4.0，当前使用的是
    Ansible 2.7，您会注意到 `sf_account_manager` 模块将在 Ansible 4.0 中被完全移除。因此，您可能希望将其列入黑名单，以防止任何人在推出
    Ansible 4.0 时创建会出错的代码（请参阅[https://docs.ansible.com/ansible/devel/porting_guides/porting_guide_2.7.html](https://docs.ansible.com/ansible/devel/porting_guides/porting_guide_2.7.html)）。因此，为了防止内部任何人使用这个模块，`plugin_filters.yml`
    文件应该如下所示：
- en: '[PRE29]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Although useful in helping to ensure high-quality Ansible code is maintained,
    this functionality is, at the time of writing, limited to modules. It cannot be
    extended to anything else, such as roles.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个功能在帮助确保高质量的 Ansible 代码得到维护方面非常有用，但在撰写本文时，这个功能仅限于模块。它不能扩展到其他任何东西，比如角色。
- en: Module transport and execution
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输和执行模块
- en: Once a module is found, Ansible has to execute it in some way. How the module
    is transported and executed depends on a few factors; however, the common process
    is to locate the module file on the local filesystem and read it into memory,
    and then add the arguments passed to the module. Then, the boilerplate module
    code from the Ansible core is added to the file object in memory. This collection
    is compressed, Base64-encoded, and then wrapped in a script. What happens next
    really depends on the connection method and runtime options (such as leaving the
    module code on the remote system for review).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到一个模块，Ansible 就必须以某种方式执行它。模块的传输和执行方式取决于一些因素；然而，通常的过程是在本地文件系统上定位模块文件并将其读入内存，然后添加传递给模块的参数。然后，在内存中的文件对象中添加来自
    Ansible 核心的样板模块代码。这个集合被压缩、Base64 编码，然后包装在一个脚本中。接下来发生的事情取决于连接方法和运行时选项（例如将模块代码留在远程系统上供审查）。
- en: The default connection method is `smart`, which most often resolves to the `ssh`
    connection method. With a default configuration, Ansible will open an SSH connection
    to the remote host, create a temporary directory, and close the connection. Ansible
    will then open another SSH connection in order to write out the wrapped ZIP file
    from memory (the result of local module files, task module arguments, and Ansible
    boilerplate code) into a file within the temporary directory that we just created
    and close the connection.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的连接方法是 `smart`，通常解析为 `ssh` 连接方法。在默认配置下，Ansible 将打开一个 SSH 连接到远程主机，创建一个临时目录，然后关闭连接。然后，Ansible
    将再次打开一个 SSH 连接，以便将内存中的包装 ZIP 文件（本地模块文件、任务模块参数和 Ansible 样板代码的结果）写入到我们刚刚创建的临时目录中的文件，并关闭连接。
- en: Finally, Ansible will open a third connection in order to execute the script
    and delete the temporary directory and all of its contents. The module results
    are captured from `stdout` in JSON format, which Ansible will parse and handle
    appropriately. If a task has an `async` control, Ansible will close the third
    connection before the module is complete and SSH back into the host to check the
    status of the task after a prescribed period until the module is complete or a
    prescribed timeout has been reached.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Ansible 将打开第三个连接，以执行脚本并删除临时目录及其所有内容。模块的结果以 JSON 格式从 `stdout` 中捕获，Ansible
    将适当地解析和处理。如果任务有一个 `async` 控制，Ansible 将在模块完成之前关闭第三个连接，并在规定的时间内再次 SSH 到主机上，以检查任务的状态，直到模块完成或达到规定的超时时间。
- en: Task performance
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务性能
- en: The previous discussion regarding how Ansible connects to hosts results in three
    connections to the host for every task. In a small environment with a small number
    of tasks, this might not be a concern; however, as the task set grows and the
    environment size grows, the time required to create and tear down SSH connections
    increases. Thankfully, there are a couple of ways to mitigate this.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Ansible 如何连接到主机的前面讨论导致每个任务对主机有三个连接。在一个任务数量较少的小环境中，这可能不是一个问题；然而，随着任务集的增长和环境规模的增长，创建和拆除
    SSH 连接所需的时间也会增加。幸运的是，有几种方法可以缓解这种情况。
- en: The first is an SSH feature, `ControlPersist`, which provides a mechanism that
    creates persistent sockets when first connecting to a remote host that can be
    reused in subsequent connections to bypass some of the handshaking required when
    creating a connection. This can drastically reduce the amount of time Ansible
    spends on opening new connections. Ansible automatically utilizes this feature
    if the host platform that runs Ansible supports it. To check whether your platform
    supports this feature, refer to the SSH man page for `ControlPersist`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是 SSH 功能 `ControlPersist`，它提供了一个机制，当首次连接到远程主机时创建持久套接字，可以在后续连接中重用，从而绕过创建连接时所需的一些握手。这可以大大减少
    Ansible 打开新连接所花费的时间。如果运行 Ansible 的主机平台支持它，Ansible 会自动利用这个功能。要检查您的平台是否支持这个功能，请参考
    SSH 的 `ControlPersist` 手册页。
- en: 'The second performance enhancement that can be utilized is an Ansible feature
    called pipelining. Pipelining is available to SSH-based connection methods and
    is configured in the Ansible configuration file within the `ssh_connection` section:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 可以利用的第二个性能增强功能是 Ansible 的一个特性，称为流水线。流水线适用于基于 SSH 的连接方法，并在 Ansible 配置文件的 `ssh_connection`
    部分进行配置：
- en: '[PRE30]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This setting changes how modules are transported. Instead of opening an SSH
    connection to create a directory, another to write out the composed module, and
    a third to execute and clean up, Ansible will instead open an SSH connection on
    the remote host. Then, over that live connection, Ansible will pipe in the zipped
    composed module code and script for execution. This reduces the connections from
    three to one, which can really add up. By default, pipelining is disabled to maintain
    compatibility with the many Linux distributions that have `requiretty` enabled
    in their `sudoers` configuration file.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置改变了模块的传输方式。与其打开一个SSH连接来创建一个目录，再打开一个连接来写入组合模块，再打开第三个连接来执行和清理，Ansible会在远程主机上打开一个SSH连接。然后，在这个实时连接上，Ansible会将压缩的组合模块代码和脚本输入，以便执行。这将连接数从三个减少到一个，这真的可以累积起来。默认情况下，为了与许多启用了`sudoers`配置文件中的`requiretty`的Linux发行版保持兼容性，流水线作业被禁用。
- en: Utilizing the combination of these two performance tweaks can keep your playbooks
    nice and fast even as you scale your environment. However, bear in mind that Ansible
    will only address as many hosts at once as the number of forks Ansible is configured
    to run. Forks are the number of processes Ansible will split off as a worker to
    communicate with remote hosts. The default is five forks, which will address up
    to five hosts at once. You can raise this number to address more hosts as your
    environment size grows by adjusting the `forks=` parameter in an Ansible configuration
    file or by using the `--forks (-f)` argument with `ansible` or `ansible-playbook`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这两种性能调整的组合可以使您的playbooks保持快速，即使在扩展环境中也是如此。但是，请记住，Ansible一次只会处理与配置为运行的forks数量相同的主机。Forks是Ansible将分裂为与远程主机通信的工作进程的进程数量。默认值是五个forks，这将一次处理最多五个主机。随着环境规模的增长，您可以通过调整Ansible配置文件中的`forks=`参数或使用`ansible`或`ansible-playbook`的`--forks
    (-f)`参数来提高这个数字，以处理更多的主机。
- en: Variable types and location
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量类型和位置
- en: Variables are a key component of the Ansible design. Variables allow for dynamic
    play content and reusable plays across different sets of an inventory. Anything
    beyond the most basic of Ansible use will utilize variables. Understanding the
    different variable types and where they can be located, as well as learning how
    to access external data or prompt users to populate variable data, is one of the
    keys to mastering Ansible.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是Ansible设计的一个关键组成部分。变量允许动态的play内容和在不同的清单集中重复使用play。除了最基本的Ansible使用之外，任何其他用途都会使用变量。了解不同的变量类型以及它们的位置以及学习如何访问外部数据或提示用户填充变量数据，是掌握Ansible的关键之一。
- en: Variable types
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量类型
- en: Before diving into the precedence of variables, first, we must understand the
    various types and subtypes of variables available to Ansible, their locations,
    and where they are valid for use.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解变量的优先级之前，首先我们必须了解Ansible可用的各种类型和子类型的变量，它们的位置以及可以在哪里使用。
- en: The first major variable type is **inventory variables**. These are the variables
    that Ansible gets by way of the inventory. These can be defined as variables that
    are specific to `host_vars`, to individual hosts, or applicable to entire groups
    as `group_vars`. These variables can be written directly into the inventory file,
    delivered by the dynamic inventory plugin, or loaded from the `host_vars/<host>`
    or `group_vars/<group>` directories.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个主要的变量类型是**清单变量**。这些是Ansible通过清单获取的变量。这些可以被定义为特定于`host_vars`、单个主机或适用于整个组的`group_vars`的变量。这些变量可以直接写入清单文件，通过动态清单插件传递，或者从`host_vars/<host>`或`group_vars/<group>`目录加载。
- en: These types of variables can be used to define Ansible behavior when dealing
    with these hosts or site-specific data related to the applications that these
    hosts run. Whether a variable comes from `host_vars` or `group_vars`, it will
    be assigned to a host's `hostvars`, and it can be accessed from the playbooks
    and template files. Accessing a host's own variables can be done by simply referencing
    the name, such as `{{ foobar }}`, and accessing another host's variables can be
    accomplished by accessing `hostvars`; for example, to access the `foobar` variable
    for `examplehost`, you can use `{{ hostvars['examplehost']['foobar'] }}`. These
    variables have global scope.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的变量可用于定义Ansible处理这些主机或与这些主机运行的应用程序相关的站点特定数据的行为。无论变量来自`host_vars`还是`group_vars`，它都将被分配给主机的`hostvars`，并且可以从playbooks和模板文件中访问。可以通过简单地引用名称来访问主机自己的变量，例如`{{
    foobar }}`，并且可以通过访问`hostvars`来访问另一个主机的变量；例如，要访问`examplehost`的`foobar`变量，可以使用`{{
    hostvars['examplehost']['foobar'] }}`。这些变量具有全局范围。
- en: The second major variable type is **role variables**. These are variables that
    are specific to a role and are utilized by the role tasks. However, it should
    be noted that once a role has been added to a playbook, its variables are generally
    accessible throughout the rest of the playbook, including from within other roles.
    In most simple playbooks, this won't matter, as the roles are typically run one
    at a time. But it is worth remembering this as the playbook structure becomes
    more complex; otherwise, unexpected behavior could result from variables being
    set within a different role!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个主要的变量类型是**角色变量**。这些变量是特定于角色的，并且被角色任务所利用。然而，值得注意的是，一旦一个角色被添加到一个playbook中，它的变量通常可以在playbook的其余部分中访问，包括在其他角色中。在大多数简单的playbooks中，这并不重要，因为角色通常是一个接一个地运行的。但是当playbook结构变得更加复杂时，记住这一点是值得的；否则，由于在不同的角色中设置变量可能会导致意外行为！
- en: These variables are often supplied as a **role default**, that is, they are
    meant to provide a default value for the variable but can easily be overridden
    when applying the role. When roles are referenced, it is possible to supply variable
    data at the same time, either by overriding role defaults or creating wholly new
    data. We'll cover roles in more depth in a later chapter. These variables apply
    to all hosts on which the role is executed and can be accessed directly, much
    like a host's own `hostvars`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量通常作为**角色默认值**提供，即它们旨在为变量提供默认值，但在应用角色时可以轻松覆盖。当引用角色时，可以同时提供变量数据，无论是覆盖角色默认值还是创建全新的数据。我们将在后面的章节中更深入地介绍角色。这些变量适用于执行角色的所有主机，并且可以直接访问，就像主机自己的`hostvars`一样。
- en: The third major variable type is **play variables**. These variables are defined
    in the control keys of a play, either directly by the `vars` key or sourced from
    external files via the `vars_files` key. Additionally, the play can interactively
    prompt the user for variable data using `vars_prompt`. These variables are to
    be used within the scope of the play and in any tasks or included tasks of the
    play. The variables apply to all hosts within the play and can be referenced as
    if they are `hostvars`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种主要的变量类型是**play变量**。这些变量在play的控制键中定义，可以直接通过`vars`键或通过`vars_files`键从外部文件获取。此外，play可以通过`vars_prompt`与用户交互地提示变量数据。这些变量应在play的范围内使用，并在play的任何任务或包含的任务中使用。这些变量适用于play中的所有主机，并且可以像`hostvars`一样被引用。
- en: 'The fourth variable type is **task variables**. Task variables are made from
    data that has been discovered while executing tasks or in the fact-gathering phase
    of a play. These variables are host-specific and are added to the host''s `hostvars`,
    and they can be used as such, which also means they have a global scope after
    the point in which they were discovered or defined. Variables of this type can
    be discovered via `gather_facts` and **fact modules** (that is, modules that do
    not alter state but instead return data), populated from task return data via
    the `register` task key, or defined directly by a task making use of the `set_fact`
    or `add_host` modules. Data can also be interactively obtained from the operator
    using the `prompt` argument to the `pause` module and registering the result:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种变量类型是**任务变量**。任务变量是由执行任务或在play的事实收集阶段发现的数据制成的。这些变量是特定于主机的，并添加到主机的`hostvars`中，并且可以像这样使用，这也意味着它们在发现或定义它们的点之后具有全局范围。可以通过`gather_facts`和**事实模块**（即不改变状态而是返回数据的模块）发现这种类型的变量，通过`register`任务键从任务返回数据中填充，或者由使用`set_fact`或`add_host`模块的任务直接定义。还可以通过使用`pause`模块的`prompt`参数与操作员交互地获取数据并注册结果：
- en: '[PRE31]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The **extra variables**, or the `extra-vars` type, are variables supplied on
    the command line when executing `ansible-playbook` via `--extra-vars`. Variable
    data can be supplied as a list of `key=value` pairs, a quoted piece of JSON data,
    or a reference to a YAML-formatted file with variable data defined within:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 额外变量，或者`extra-vars`类型，是在执行`ansible-playbook`时通过`--extra-vars`命令行提供的变量。变量数据可以作为`key=value`对的列表，一个带引号的JSON数据，或者一个包含在变量数据中定义的YAML格式文件的引用：
- en: '[PRE32]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Extra variables are considered global variables. They apply to every host and
    have scope throughout the entire playbook.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 额外变量被认为是全局变量。它们适用于每个主机，并在整个playbook中具有范围。
- en: Magic variables
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 魔术变量
- en: In addition to the previously listed variable types, Ansible offers a set of
    variables that deserve their own special mention – **magic variables**. These
    are variables that are always set when a playbook is run without them having to
    be explicitly created. Their names are always reserved and should not be used
    for other variables.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面列出的变量类型，Ansible还提供了一组值得特别提及的变量 - **魔术变量**。这些变量在运行playbook时始终设置，无需显式创建。它们的名称始终保留，不应用于其他变量。
- en: 'Magic variables are used to provide information about the current playbook
    run to the playbooks themselves and are extremely useful as Ansible environments
    become larger and more complex. For example, if one of your plays needs information
    about which groups the current host is in, the `group_names` magic variable returns
    a list of them. Similarly, if you need to configure the hostname for a service
    using Ansible, the `inventory_hostname` magic variable will return the current
    hostname as it is defined in the inventory. A simple example of this is as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 魔术变量用于向playbooks本身提供有关当前playbook运行的信息，并且在Ansible环境变得更大更复杂时非常有用。例如，如果您的play需要有关当前主机属于哪些组的信息，`group_names`魔术变量将返回它们的列表。同样，如果您需要使用Ansible配置服务的主机名，`inventory_hostname`魔术变量将返回在清单中定义的当前主机名。一个简单的例子如下：
- en: '[PRE33]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As with everything in the Ansible project, magic variables are well documented,
    and you can find a full list of them and what they contain in the official Ansible
    documentation at [https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html](https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html).
    A practical example of the use of magic variables is this: imagine, for example,
    setting up the hostnames on a new set of Linux servers from a blank template.
    The `inventory_hostname` magic variable provides us with the hostname we need
    directly from the inventory, without the need for another source of data (or,
    for example, a connection to the **CMDB**). Similarly, accessing `groups_names`
    allows us to define which plays should be run on a given host within a single
    playbook – perhaps, for example, installing **NGINX** if the host is in the `webservers`
    group. In this way, Ansible code can be made more versatile and efficient; hence,
    these variables deserve a special mention.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 与Ansible项目中的所有内容一样，魔术变量都有很好的文档记录，您可以在官方Ansible文档中找到它们的完整列表以及它们包含的内容[https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html](https://docs.ansible.com/ansible/latest/reference_appendices/special_variables.html)。魔术变量使用的一个实际例子是：例如，从空白模板设置新一组Linux服务器的主机名。`inventory_hostname`魔术变量直接从清单中提供了我们需要的主机名，无需另一个数据源（或者例如连接到**CMDB**）。类似地，访问`groups_names`允许我们定义在单个playbook中应在给定主机上运行哪些play
    - 例如，如果主机在`webservers`组中，则安装**NGINX**。通过这种方式，Ansible代码可以变得更加灵活和高效；因此，这些变量值得特别一提。
- en: Accessing external data
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问外部数据
- en: 'Data for role variables, play variables, and task variables can also come from
    external sources. Ansible provides a mechanism in which to access and evaluate
    data from the **control machine** (that is, the machine running `ansible-playbook`).
    The mechanism is called a **lookup plugin**, and a number of them come with Ansible.
    These plugins can be used to look up or access data by reading files, generate
    and locally store passwords on the Ansible host for later reuse, evaluate environment
    variables, pipe data in from executables or CSV files, access data in the `Redis`
    or `etcd` systems, render data from template files, query `dnstxt` records, and
    more. The syntax is as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 角色变量、play变量和任务变量的数据也可以来自外部来源。Ansible提供了一种机制，可以从**控制机器**（即运行`ansible-playbook`的机器）访问和评估数据。这种机制称为**查找插件**，Ansible附带了许多这样的插件。这些插件可以用于通过读取文件查找或访问数据，在Ansible主机上生成并本地存储密码以供以后重用，评估环境变量，从可执行文件或CSV文件中导入数据，访问`Redis`或`etcd`系统中的数据，从模板文件中呈现数据，查询`dnstxt`记录等。语法如下：
- en: '[PRE34]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For example, to use the `mastery` value from `etcd` in an `ansible.builtin.debug`
    task, execute the following command:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在`ansible.builtin.debug`任务中使用`etcd`中的`mastery`值，执行以下命令：
- en: '[PRE35]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Lookups are evaluated when the task referencing them is executed, which allows
    for dynamic data discovery. To reuse a particular lookup in multiple tasks and
    reevaluate it each time, a playbook variable can be defined with a lookup value.
    Each time the playbook variable is referenced, the lookup will be executed, potentially
    providing different values over time.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 查找在引用它们的任务执行时进行评估，这允许动态数据发现。要在多个任务中重用特定查找并在每次重新评估它时，可以使用查找值定义playbook变量。每次引用playbook变量时，查找将被执行，随时间可能提供不同的值。
- en: Variable precedence
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量优先级
- en: 'As you learned in the previous section, there are several major types of variables
    that can be defined in a myriad of locations. This leads to a very important question:
    what happens when the same variable name is used in multiple locations? Ansible
    has a precedence for loading variable data, and thus, it has an order and a definition
    to decide which variable will win. Variable value overriding is an advanced usage
    of Ansible, so it is important to fully understand the semantics before attempting
    such a scenario.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一节中学到的，有几种主要类型的变量可以在多种位置定义。这引发了一个非常重要的问题：当相同的变量名称在多个位置使用时会发生什么？Ansible有一个加载变量数据的优先级，因此，它有一个顺序和定义来决定哪个变量会获胜。变量值覆盖是Ansible的高级用法，因此在尝试这样的场景之前，完全理解语义是很重要的。
- en: Precedence order
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先级顺序
- en: 'Ansible defines the following precedence order, with those closest to the top
    of the list winning. Note that this can change from release to release. In fact,
    it has changed quite significantly since Ansible 2.4 was released, so it is worth
    reviewing if you are upgrading from an older version of Ansible:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible定义了以下优先顺序，靠近列表顶部的优先级最高。请注意，这可能会因版本而变化。实际上，自Ansible 2.4发布以来，它已经发生了相当大的变化，因此如果您正在从旧版本的Ansible进行升级，值得进行审查：
- en: Extra `vars` (from the command line) always win.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 额外的`vars`（来自命令行）总是优先。
- en: The `ansible.builtin.include` parameters.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible.builtin.include`参数。'
- en: The role (and `ansible.builtin.include_role`) parameters.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 角色（和`ansible.builtin.include_role`）参数。
- en: The variables defined with `ansible.builtin.set_facts`, and those created with
    the `register` task directive.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ansible.builtin.set_facts`定义的变量，以及使用`register`任务指令创建的变量。
- en: The variables included in a play with `ansible.builtin.include_vars`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在play中包含的变量`ansible.builtin.include_vars`。
- en: Task `vars` (only for the specific task).
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务`vars`（仅针对特定任务）。
- en: Block `vars` (only for the tasks within the block).
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块`vars`（仅适用于块内的任务）。
- en: Role `vars` (defined in `main.yml` in the `vars` subdirectory of the role).
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Role `vars`（在角色的`vars`子目录中的`main.yml`中定义）。
- en: Play `vars_files.`
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Play `vars_files`。
- en: Play `vars_prompt.`
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Play `vars_prompt`。
- en: Play `vars.`
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Play `vars`。
- en: The host facts (and also the cached results of `ansible.builtin.set_facts`).
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主机事实（以及`ansible.builtin.set_facts`的缓存结果）。
- en: The `host_vars` playbook.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`host_vars` playbook。'
- en: The `host_vars` inventory.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`host_vars`清单。'
- en: The inventory file (or script)-defined host `vars.`
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清单文件（或脚本）定义的主机`vars`。
- en: The `group_vars` playbook.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`group_vars` playbook。'
- en: The `group_vars` inventory.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`group_vars`清单。'
- en: The `group_vars/all` playbook.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`group_vars/all` playbook。'
- en: The `group_vars/all` inventory.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`group_vars/all`清单。'
- en: The inventory file (or script)-defined group `vars.`
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清单文件（或脚本）定义的组`vars`。
- en: The role defaults.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 角色默认值。
- en: The command-line values (for example, `-u REMOTE_USER`).
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令行值（例如，`-u REMOTE_USER`）。
- en: Ansible releases a porting guide with each release that details the changes
    you will need to make to your code in order for it to continue functioning as
    expected. It is important to review these as you upgrade your Ansible environment
    – the guides can be found at [https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.html](https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.html).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible每次发布都会附带一个移植指南，详细说明您需要对代码进行哪些更改，以便它能够继续按预期运行。在升级Ansible环境时，审查这些内容非常重要-这些指南可以在[https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.html](https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.html)找到。
- en: Variable group priority ordering
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量组优先级排序
- en: The previous list of priority ordering is obviously helpful when writing Ansible
    playbooks, and, in most cases, it is apparent that variables should not clash.
    For example, a `var` task clearly wins over a `var` play, and all tasks and, indeed,
    plays are unique. Similarly, all hosts in the inventory will be unique; so again,
    there should be no clash of variables with the inventory either.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的优先级排序列表在编写Ansible playbook时显然是有帮助的，并且在大多数情况下，很明显变量不应该冲突。例如，`var`任务显然胜过`var`
    play，所有任务和实际上，plays都是唯一的。同样，清单中的所有主机都是唯一的；因此，清单中也不应该有变量冲突。
- en: 'There is, however, one exception to this, that is, inventory groups. A one-to-many
    relationship exists between hosts and groups, and, as such, any given host can
    be a member of one or more groups. For example, let''s suppose that the following
    code is our inventory file:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个例外，即清单组。主机和组之间存在一对多的关系，因此任何给定的主机都可以是一个或多个组的成员。例如，假设以下代码是我们的清单文件：
- en: '[PRE36]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we have two hypothetical frontend servers, `host1.example.com` and `host2.example.com`,
    in the `frontend` group. Both hosts are `children` of the `web` group, which means
    they are assigned the group variable `http_port=80` from the inventory. `host1.example.com`
    is also a member of the `proxy` group, which has an identically named variable
    but a different assignment: `http_port=8080`.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个假想的前端服务器，`host1.example.com`和`host2.example.com`，在`frontend`组中。这两个主机都是`web`组的`children`，这意味着它们被分配了清单中的组变量`http_port=80`。`host1.example.com`也是`proxy`组的成员，该组具有相同名称的变量，但是不同的赋值：`http_port=8080`。
- en: Both of these variable assignments are at the `group_vars` inventory level,
    and so the order of precedence does not define a winner. So, what happens in this
    scenario?
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个变量分配都在`group_vars`清单级别，因此优先顺序并不定义获胜者。那么，在这种情况下会发生什么？
- en: The answer is, in fact, predictable and deterministic. The `group_vars` assignments
    are done in alphabetical order of the group names (as described in the *Inventory
    ordering* section), with the last loaded group overriding all preceding variable
    values that coincide.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，答案是可预测的和确定的。`group_vars`的赋值按照组名称的字母顺序进行（如*清单排序*部分所述），最后加载的组将覆盖所有之前处理的组的变量值。
- en: This means that any competing variables from `mastery2` will win over the other
    two groups. Those from the `mastery11` group will then take precedence of those
    from the `mastery1` group, so please be mindful of this when creating group names!
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着来自`mastery2`的任何竞争变量将胜过其他两个组。然后，来自`mastery11`组的变量将优先于`mastery1`组的变量，因此在创建组名称时请注意这一点！
- en: 'In our example, when the groups are processed in alphabetical order, `web`
    comes after `proxy`. Therefore, the `group_vars` assignments from `web` that coincide
    with those from any previously processed groups will win. Let''s run the previous
    inventory file through this example playbook to take a look at the behavior:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，当组按字母顺序处理时，`web`在`proxy`之后。因此，`web`的`group_vars`赋值将胜过任何先前处理的组的赋值。让我们通过这个示例playbook运行之前的清单文件来查看行为：
- en: '[PRE37]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s try running the following command:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试运行以下命令：
- en: '[PRE38]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We should get the following output:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到以下输出：
- en: '![Figure 1.12 – A playbook run showing how variables can be overridden at the
    inventory group level'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.12 - 一个展示变量如何在清单组级别被覆盖的playbook运行'
- en: '](Images/B17462_01_12.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_01_12.jpg)'
- en: Figure 1.12 – A playbook run showing how variables can be overridden at the
    inventory group level
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12 - 一个展示变量如何在清单组级别被覆盖的playbook运行
- en: As expected, the value assigned to the `http_port` variable for both hosts in
    the inventory is `80`. However, what if this behavior is not desired? Let's suppose
    that we want the value of `http_port` from the proxy group to take priority. It
    would be painful to have to rename the group and all associated references to
    it to change the alphanumerical sorting of the groups (although, this would work!).
    The good news is that Ansible 2.4 introduced the `ansible_group_priority` group
    variable, which can be used for just this eventuality. If not explicitly set,
    this variable defaults to `1`, leaving the rest of the inventory file unchanged.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，清单中两个主机的`http_port`变量的赋值都是`80`。但是，如果不希望出现这种行为怎么办？假设我们希望`proxy`组的`http_port`值优先。不得不重新命名组和所有相关引用以更改组的字母数字排序将是痛苦的（尽管这样也可以！）。好消息是，Ansible
    2.4引入了`ansible_group_priority`组变量，可以用于处理这种情况。如果没有明确设置，此变量默认为`1`，不会改变清单文件的其余部分。
- en: 'Let''s set this as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其设置如下：
- en: '[PRE39]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, when we run the same playbook using the same command as before, pay attention
    to how the value assigned to `http_ort` changes, while all variable names that
    were not coincidental behave exactly as before:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们使用与之前相同的命令运行相同的playbook时，请注意`http_ort`的赋值如何改变，而所有不巧合的变量名称都会像以前一样表现：
- en: '![Figure 1.13 – The effect of the ansible_group_priority variable on coincidental
    group variables'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.13 - ansible_group_priority变量对巧合组变量的影响'
- en: '](Images/B17462_01_13.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_01_13.jpg)'
- en: Figure 1.13 – The effect of the ansible_group_priority variable on coincidental
    group variables
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13 - ansible_group_priority变量对巧合组变量的影响
- en: As your inventory grows with your infrastructure, be sure to make use of this
    feature to gracefully handle any variable assignment collisions between your groups.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 随着清单随基础设施的增长，一定要利用这个功能，优雅地处理组之间的任何变量分配冲突。
- en: Merging hashes
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并哈希
- en: 'In the previous section, we focused on the precedence with which variables
    will override each other. The default behavior of Ansible is that any overriding
    definition for a variable name will completely mask the previous definition of
    that variable. However, that behavior can be altered for one type of variable:
    the hash variable. A hash variable (or, in Python terms, a dictionary) is a dataset
    of keys and values. Values can be of different types for each key and can even
    be hashes themselves for complex data structures.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们关注了变量将如何覆盖彼此的优先级。Ansible的默认行为是，对于变量名的任何覆盖定义将完全掩盖该变量的先前定义。但是，这种行为可以改变一种类型的变量：哈希变量。哈希变量（或者在Python术语中称为字典）是一组键和值的数据集。每个键的值可以是不同类型的，并且甚至可以是复杂数据结构的哈希本身。
- en: In some advanced scenarios, it is preferable to replace just one bit of a hash
    or add to an existing hash rather than replacing the hash altogether. To unlock
    this ability, a configuration change is necessary in the Ansible `config` file.
    The configuration entry is `hash_behavior`, which either takes the value `replace`
    or `merge`. A setting of `merge` will instruct Ansible to merge or blend the values
    of two hashes when presented with an override scenario rather than assume the
    default of `replace`, which will completely replace the old variable data with
    the new data.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些高级场景中，最好只替换哈希的一部分或添加到现有哈希中，而不是完全替换哈希。要解锁这种能力，需要在Ansible的`config`文件中进行配置更改。配置条目是`hash_behavior`，它可以取值`replace`或`merge`。设置为`merge`将指示Ansible在出现覆盖场景时合并或混合两个哈希的值，而不是假定默认的`replace`，它将完全用新数据替换旧的变量数据。
- en: Let's walk through an example of the two behaviors. We will start with a hash
    loaded with data and simulate a scenario where a different value for the hash
    is provided as a higher-priority variable.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来了解这两种行为。我们将从加载了数据的哈希开始，并模拟提供了作为更高优先级变量的哈希的不同值的情况。
- en: 'This is the starting data:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这是起始数据：
- en: '[PRE40]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is the new data loaded via `include_vars`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过`include_vars`加载的新数据：
- en: '[PRE41]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With the default behavior, the new value for `hash_var` will be as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 默认行为下，`hash_var`的新值将如下所示：
- en: '[PRE42]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'However, if we enable the `merge` behavior, we will get the following result:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们启用`merge`行为，我们将得到以下结果：
- en: '[PRE43]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There are even more nuances and undefined behaviors when using `merge`, and,
    as such, it is strongly recommended that you only use this setting if absolutely
    necessary – it is disabled by default for a good reason!
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`merge`时，甚至还有更多微妙和未定义的行为，因此强烈建议只在绝对必要时使用此设置 - 默认情况下禁用是有充分理由的！
- en: Summary
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: While the design of Ansible focuses on simplicity and ease of use, the architecture
    itself is very powerful. In this chapter, we covered the key design and architecture
    concepts of Ansible, such as versions and configurations, playbook parsing, module
    transport and execution, variable types and locations, and variable precedence.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Ansible的设计侧重于简单和易用性，但架构本身非常强大。在本章中，我们涵盖了Ansible的关键设计和架构概念，如版本和配置、playbook解析、模块传输和执行、变量类型和位置以及变量优先级。
- en: You learned that playbooks contain variables and tasks. Tasks link bits of code
    called modules with arguments, which can be populated by variable data. These
    combinations are transported to selected hosts from the inventory sources provided.
    The fundamental understanding of these building blocks is the platform on which
    you can build a mastery of all things Ansible!
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 您了解到playbook包含变量和任务。任务将称为模块的代码片段与参数链接在一起，这些参数可以由变量数据填充。这些组合从提供的清单来源传输到选定的主机。对这些构建块的基本理解是您可以掌握所有Ansible事物的平台！
- en: In the next chapter, you will learn, in detail, about the big new features in
    Ansible 4.3, especially the Ansible collections and FQCNs that we have touched
    on in this chapter.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将详细了解Ansible 4.3中的重大新功能，特别是我们在本章中提到的Ansible集合和FQCNs。
- en: Questions
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is an inventory important to Ansible?
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清单对于Ansible的重要性是什么？
- en: a) It forms part of Ansible's configuration management database.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: a）它是Ansible配置管理数据库的一部分。
- en: b) It is used to audit your servers.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: b）它用于审计您的服务器。
- en: c) It tells Ansible which servers to perform automation tasks on.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: c）它告诉Ansible在哪些服务器上执行自动化任务。
- en: d) None of the above.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: d）以上都不是。
- en: When working with frequently changing infrastructures (such as public cloud
    deployments), Ansible users must manually update their inventory on a regular
    basis. Is this true or false?
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理频繁变化的基础设施（如公共云部署）时，Ansible用户必须定期手动更新他们的清单。这是真的还是假的？
- en: a) True – this is the only way to do it.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: a）真 - 这是唯一的方法。
- en: b) False – dynamic inventories were invented for precisely this purpose.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: b）假 - 动态清单是为了这个目的而发明的。
- en: By default, Ansible processes hosts in an inventory in which order?
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible按照清单中的顺序处理主机？
- en: a) In alphabetical order
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: a）按字母顺序
- en: b) In lexicographical order
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: b）按字典顺序
- en: c) In random order
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: c）随机顺序
- en: d) In the order in which they appear in the inventory
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: d）按照它们在清单中出现的顺序
- en: By default, Ansible tasks in a simple playbook are executed in which order?
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，简单playbook中的Ansible任务是按照什么顺序执行的？
- en: a) In the order in which they are written, but each task must be completed on
    all inventory hosts before the next is executed.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: a）按照它们被写入的顺序，但必须在所有清单主机上完成每个任务，然后才能执行下一个任务。
- en: b) In the most optimal order.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: b）以最优化的顺序。
- en: c) In the order in which they are written but only on one inventory host at
    a time.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: c）按照它们被写入的顺序，但一次只能在一个清单主机上进行。
- en: d) Something else.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: d）其他
- en: Which variable type takes the highest priority, overriding all other variable
    sources?
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种变量类型具有最高优先级，可以覆盖所有其他变量来源？
- en: a) Inventory variables
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: a）清单变量
- en: b) Extra variables (from the command line)
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: b）额外变量（来自命令行）
- en: c) Role defaults
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: c）角色默认值
- en: d) Variables source via `vars_prompt`
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: d）通过`vars_prompt`获取变量源
- en: What is the name of the special Ansible variables that only exist at runtime?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特殊的Ansible变量名称只在运行时存在是什么？
- en: a) Special variables
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: a）特殊变量
- en: b) Runtime variables
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: b）运行时变量
- en: c) Magic variables
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: c）魔术变量
- en: d) User variables
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: d）用户变量
- en: If you wanted to access external data from a playbook, what would you use?
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想从playbook中访问外部数据，您会使用什么？
- en: a) A lookup plugin
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: a）查找插件
- en: b) A lookup module
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: b）查找模块
- en: c) A lookup executable
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: c）查找可执行文件
- en: d) A lookup role
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: d）查找角色
- en: What is Ansible's preferred default transport mechanism for most non-Windows
    hosts?
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于大多数非Windows主机，Ansible首选的默认传输机制是什么？
- en: a) The REST API
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: a）REST API
- en: b) RabbitMQ
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: b）RabbitMQ
- en: c) RSH
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: c）RSH
- en: d) SSH
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: d）SSH
- en: What can inventory variables be used to do?
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清单变量可以用来做什么？
- en: a) Define unique data for each host or group of hosts in an inventory.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: a）在清单中为每个主机或主机组定义唯一数据。
- en: b) Declare your playbook variables.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: b）声明您的playbook变量。
- en: c) Define connection parameters for your inventory hosts.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: c）为清单主机定义连接参数。
- en: d) Both (a) and (c).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: d）都是（a）和（c）。
- en: How can you override the default Ansible configuration on your system?
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何覆盖系统上的默认Ansible配置？
- en: a) By creating an Ansible configuration file in any location, and using the
    `ANSIBLE_CFG` environment variable to specify this location.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在任何位置创建Ansible配置文件，并使用`ANSIBLE_CFG`环境变量指定此位置。
- en: b) By creating a file called `ansible.cfg` in the current working directory.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: b）通过在当前工作目录中创建名为`ansible.cfg`的文件。
- en: c) By creating a file in your home directory called `~/.ansible.cfg`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: c）通过在您的主目录中创建一个名为`~/.ansible.cfg`的文件。
- en: d) Any of the above.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: d）以上任何一种。
