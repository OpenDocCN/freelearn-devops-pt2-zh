- en: '*Chapter 10*: Extending Ansible'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：扩展Ansible'
- en: It must be said that **Ansible** takes the *kitchen sink* approach to functionality
    and tries to provide, out of the box, every piece of functionality you might ever
    need. With the `ansible-core` package and its associated collections, there are
    almost 6,000 modules available for use within Ansible at the time of writing –
    compare that to the (roughly) 800 that were included when the second edition of
    this book was published! In addition to these, there is a rich plugin and filter
    architecture with numerous callback plugins, lookup plugins, filter plugins, and
    dynamic inventory plugins included. Now, collections provide a whole new vector
    through which new functionality can be provided.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 必须说**Ansible**采用了*厨房水槽*的功能方法，并试图在开箱即用时提供您可能需要的所有功能。随着`ansible-core`包及其相关集合，截至撰写本文时，几乎有6000个模块可供在Ansible中使用-与本书第二版出版时包含的（大约）800个相比！除此之外，还有丰富的插件和过滤器架构，包括多个回调插件、查找插件、过滤器插件和包括动态清单插件在内的插件。现在，集合提供了一个全新的向量，通过它可以提供新的功能。
- en: Despite this, there will always be cases where Ansible doesn't quite perform
    the tasks required, especially in large and complex environments, or ones where
    bespoke in-house systems have been developed. Luckily, the design of Ansible,
    coupled with its open source nature, makes it easy for anyone to extend it by
    developing features. The advent of collections with Ansible 3.0 has meant it is
    easier than ever to extend functionality. However, in this chapter, we will focus
    on the specifics of contributing to the `ansible-core` package. If you wish to
    contribute by creating a collection, you can easily follow the steps provided
    in this chapter to develop the code you require (for example, creating a new module)
    and then package it as a collection, as we described in *Chapter 2*, *Migrating
    from Earlier Ansible Versions*. How you contribute is up to you and your target
    audience – if you feel your code will help everyone who uses Ansible, then you
    may wish to submit it to `ansible-core`; otherwise, it is probably best built
    into a collection.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，总会有一些情况，Ansible并不能完全执行所需的任务，特别是在大型和复杂的环境中，或者在自定义的内部系统已经开发的情况下。幸运的是，Ansible的设计，加上其开源性质，使任何人都可以通过开发功能来扩展它变得很容易。随着Ansible
    3.0的集合的出现，扩展功能比以往任何时候都更容易。然而，在本章中，我们将专注于为`ansible-core`包做出贡献的具体内容。如果您希望通过创建集合来做出贡献，您可以按照本章提供的步骤轻松开发所需的代码（例如，创建一个新模块），然后将其打包为集合，就像我们在*第2章*中描述的那样，*从早期的Ansible版本迁移*。您如何做出贡献取决于您和您的目标受众-如果您觉得您的代码将帮助所有使用Ansible的人，那么您可能希望将其提交给`ansible-core`；否则，最好将其构建到一个集合中。
- en: 'This chapter will explore the following ways in which new capabilities can
    be added to Ansible:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨以下几种方式，可以向Ansible添加新功能：
- en: Developing modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发模块
- en: Developing plugins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发插件
- en: Developing dynamic inventory plugins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发动态清单插件
- en: Contributing code to the Ansible project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Ansible项目贡献代码
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the examples presented in this chapter, you will need a Linux machine
    running **Ansible 4.3** or newer. Almost any flavor of Linux should do – for those
    interested in the specifics, all the code presented in this chapter was tested
    on **Ubuntu Server 20.04 LTS** unless stated otherwise and on Ansible 4.3\. The
    example code that accompanies this chapter can be downloaded from GitHub at [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter10).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照本章中提供的示例，您需要一台运行**Ansible 4.3**或更新版本的Linux机器。几乎任何Linux发行版都可以-对于那些感兴趣的人，所有本章中提供的代码都是在**Ubuntu
    Server 20.04 LTS**上测试的，除非另有说明，并且在Ansible 4.3上测试。本章附带的示例代码可以从GitHub上下载：[https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter10)。
- en: 'Check out the following video to see the code in action: [https://bit.ly/3DTKL35](https://bit.ly/3DTKL35).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际操作：[https://bit.ly/3DTKL35](https://bit.ly/3DTKL35)。
- en: Developing modules
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发模块
- en: Modules are the workhorse of Ansible. They provide just enough abstraction so
    that playbooks can be stated simply and clearly. There are over 100 modules and
    plugins maintained by the core Ansible development team and they are distributed
    as part of the `ansible-core` package, covering commands, files, package management,
    source control, system, utilities, and so on. In addition, there are nearly 6,000
    other modules maintained by community contributors that expand functionality in
    many of these categories and many others, such as public cloud providers, databases,
    networking, and so on, through collections. The real magic happens inside the
    module's code, which takes in the arguments that are passed to it and works to
    establish the desired outcome.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是Ansible的工作马。它们提供了足够的抽象，使得playbook可以简单明了地陈述。由核心Ansible开发团队维护的模块和插件有100多个，并作为`ansible-core`包的一部分进行分发，涵盖命令、文件、软件包管理、源代码控制、系统、实用程序等。此外，社区贡献者维护了近6000个其他模块，扩展了许多这些类别和其他许多功能，例如公共云提供商、数据库、网络等，通过集合。真正的魔力发生在模块的代码内部，它接收传递给它的参数，并努力建立所需的结果。
- en: Modules in Ansible are the pieces of code that get transported to the remote
    host to be executed. They can be written in any language that the remote host
    can execute; however, Ansible provides some very useful shortcuts for writing
    modules in Python, and you will find that most are indeed written in Python.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible中，模块是被传输到远程主机以执行的代码片段。它们可以用远程主机可以执行的任何语言编写；然而，Ansible提供了一些非常有用的快捷方式，用于用Python编写模块，您会发现大多数模块确实是用Python编写的。
- en: The basic module construct
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本模块构造
- en: A module exists to satisfy a need – the need to do a piece of work on a host.
    Modules usually, but not always, expect input, and will return some sort of output.
    Modules also strive to be idempotent, allowing the module to be run over and over
    again without it having a negative impact. In Ansible, the input is in the form
    of command-line arguments to the module, and the output is delivered as JSON to
    `STDOUT`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 模块存在以满足需求-在主机上执行一项工作的需求。模块通常需要输入，但并不总是期望输入，并且将返回某种输出。模块还努力成为幂等，允许模块一遍又一遍地运行而不会产生负面影响。在Ansible中，输入以命令行参数的形式提供给模块，并且输出以JSON格式传递到`STDOUT`。
- en: Input is generally provided in the space-separated `key=value` syntax, and it's
    up to the module to deconstruct these into usable data. If you're using Python,
    there are convenience functions to manage this, and if you're using a different
    language, then it is up to your module code to fully process the input.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输入通常以空格分隔的`key=value`语法提供，模块负责将其解构为可用数据。如果您使用Python，有方便的函数来管理这一点，如果您使用不同的语言，那么完全处理输入就取决于您的模块代码。
- en: The output is JSON formatted. Convention dictates that in a successful scenario,
    the JSON output should have at least one key, changed, which is a Boolean, to
    indicate whether the module execution resulted in a change. Additional data can
    be returned as well, which may be useful for defining what changed or to provide
    important information back to the playbook for later use. Additionally, host facts
    can be returned in the JSON data to automatically create host variables based
    on the module execution results. We will look at this in more detail later, in
    the *Providing fact data* section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 输出采用JSON格式。惯例规定，在成功的情况下，JSON输出应至少有一个键`changed`，这是一个布尔值，表示模块执行是否导致更改。还可以返回其他数据，这些数据可能有助于定义发生了什么变化，或者为以后使用向playbook提供重要信息。此外，主机信息可以在JSON数据中返回，以根据模块执行结果自动创建主机变量。我们将在以后更详细地看一下这一点，在*提供事实数据*部分。
- en: Custom modules
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义模块
- en: Ansible provides an easy mechanism to utilize custom modules other than those
    that come with Ansible. As we learned in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015),
    *The System Architecture and Design of Ansible*, Ansible will search many locations
    to find a requested module. One such location, and indeed the first location,
    is the `library/` subdirectory of the path where the top-level playbook resides.
    This is where we will place our custom module so that we can use it in our example
    playbook, as our focus is on developing for the `ansible-core` package. However,
    as we have already stated, you can also distribute modules via collections, and
    [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047), *Migrating from
    Earlier Ansible Versions*, described (with a practical example taken from this
    chapter) how to package up modules for distribution via a collection.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible提供了一种简单的机制来利用除Ansible自带模块之外的自定义模块。正如我们在[*第1章*]（B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015）中学到的，*Ansible的系统架构和设计*，Ansible会搜索许多位置来找到所请求的模块。其中一个位置，实际上是第一个位置，是顶层playbook所在路径的`library/`子目录。这就是我们将放置自定义模块的地方，以便我们可以在示例playbook中使用它，因为我们的重点是为`ansible-core`软件包开发。但是，正如我们已经提到的，您也可以通过集合分发模块，并且[*第2章*]（B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047）描述了（以本章节为例的实际示例）如何打包模块以通过集合进行分发。
- en: In addition to this, modules can also be embedded within roles to deliver the
    added functionality that a role may depend upon. These modules are only available
    to the role that contains the module, or any other roles or tasks that are executed
    after the role containing the module. To deliver a module with a role, place the
    module in the `library/` subdirectory of the role's root. While this is still
    a viable route, it is expected that as Ansible releases of 3.0 and later become
    commonplace, you will distribute your modules via collections. A period of overlap
    is being provided to support the many Ansible 2.9 and earlier distributions that
    exist.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，模块也可以嵌入在角色中，以提供角色可能依赖的附加功能。这些模块仅对包含模块的角色或在包含模块的角色之后执行的任何其他角色或任务可用。要使用角色提供模块，将模块放在角色根目录的`library/`子目录中。虽然这仍然是一种可行的途径，但预计随着Ansible
    3.0及以后版本的普及，您将通过集合分发您的模块。提供了一个重叠期来支持许多现有的Ansible 2.9及更早版本的发行版。
- en: Example – simple module
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例-简单模块
- en: 'To demonstrate the ease of writing Python-based modules, let''s create a simple
    module. The purpose of this module will be to remotely copy a source file to a
    destination file, a simple task that we can build up from. To start our module,
    we need to create the module file. For easy access to our new module, we''ll create
    the file in the `library/` subdirectory of the working directory we''ve already
    been using. We''ll call this module `remote_copy.py`, and to start it off, we''ll
    need to put in a shebang line to indicate that this module is to be executed with
    Python:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示编写基于Python的模块的简易性，让我们创建一个简单的模块。这个模块的目的是远程复制源文件到目标文件，这是一个简单的任务，我们可以逐步构建起来。为了启动我们的模块，我们需要创建模块文件。为了方便访问我们的新模块，我们将在已经使用的工作目录的`library/`子目录中创建文件。我们将这个模块称为`remote_copy.py`，为了开始它，我们需要放入一个shebang行，以指示这个模块将使用Python执行：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For Python-based modules, the convention is to use `/usr/bin/python` as the
    listed executable. When executed on a remote system, the configured Python interpreter
    for the remote host is used to execute the module, so fret not if your Python
    code doesn''t exist in this path. Next, we''ll import a Python library we''ll
    use later in the module, called `shutil`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于Python的模块，约定使用`/usr/bin/python`作为列出的可执行文件。在远程系统上执行时，将使用远程主机的配置Python解释器来执行模块，因此如果您的Python代码不存在于此路径，也不必担心。接下来，我们将导入一个稍后在模块中使用的Python库，称为`shutil`：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we're ready to create our `main` function. The `main` function is essentially
    the entry point to the module, where the arguments to the module will be defined
    and where the execution will start. When creating modules in Python, we can take
    some shortcuts in this `main` function to bypass a lot of boilerplate code and
    get straight to the argument definitions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备创建我们的`main`函数。`main`函数本质上是模块的入口点，模块的参数将在这里定义，执行也将从这里开始。在Python中创建模块时，我们可以在这个`main`函数中采取一些捷径，绕过大量样板代码，直接进行参数定义。
- en: 'We can do this by creating an `AnsibleModule` object and giving it an `argument_spec`
    dictionary for the arguments:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个`AnsibleModule`对象并为参数提供一个`argument_spec`字典来实现这一点：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our module, we're providing two arguments. The first argument is `source`,
    which we'll use to define the source file for the copy. The second argument is
    `dest`, which is the destination for the copy. Both of these arguments are marked
    as required, which will raise an error when executed if one of the two is not
    provided. Both arguments are of the `string` type. The location of the `AnsibleModule`
    class has not been defined yet as that happens later in the file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模块中，我们提供了两个参数。第一个参数是`source`，我们将用它来定义复制的源文件。第二个参数是`dest`，它是复制的目的地。这两个参数都标记为必需，如果其中一个未提供，将引发错误。这两个参数都是`string`类型。`AnsibleModule`类的位置尚未定义，因为这将在文件的后面发生。
- en: 'With a module object at our disposal, we can now create the code that will
    do the actual work on the remote host. We''ll make use of `shutil.copy` and our
    provided arguments to accomplish this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有了模块对象，我们现在可以创建在远程主机上执行实际工作的代码。我们将利用`shutil.copy`和我们提供的参数来实现这一点：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `shutil.copy` function expects a source and a destination, which we''ve
    provided by accessing `module.params`. The `module.params` dictionary holds all
    of the parameters for the module. Having completed the copy, we are now ready
    to return the results to Ansible. This is done via another `AnsibleModule` method,
    `exit_json`. This method expects a set of `key=value` arguments and will format
    it appropriately for a JSON return. Since we''re always performing a copy, we
    will always return a change for simplicity''s sake:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`shutil.copy`函数期望一个源和一个目的地，我们通过访问`module.params`来提供这些。`module.params`字典包含模块的所有参数。完成复制后，我们现在准备将结果返回给Ansible。这是通过另一个`AnsibleModule`方法`exit_json`完成的。这个方法期望一组`key=value`参数，并将适当地格式化为JSON返回。由于我们总是执行复制，出于简单起见，我们将始终返回一个更改：'
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This line will exit the function, and thus the module. This function assumes
    a successful action and will exit the module with the appropriate return code
    for success: `0`. We''re not done with our module''s code, though; we still have
    to account for the `AnsibleModule` location. This is where a bit of magic happens,
    where we tell Ansible what other code to combine with our module to create a complete
    work that can be transported:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行将退出函数，因此也将退出模块。这个函数假设操作成功，并将以成功的适当返回代码`0`退出模块。不过，我们还没有完成模块的代码；我们仍然需要考虑`AnsibleModule`的位置。这是一个小魔术发生的地方，我们告诉Ansible要与我们的模块结合的其他代码，以创建一个完整的可传输的作品：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That''s all it takes! That one line gets us access to all of the basic `module_utils`,
    a decent set of helper functions and classes. There is one last thing we should
    put into our module: a couple of lines of code telling the interpreter to execute
    the `main()` function when the module file is executed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！这一行就可以让我们访问所有基本的`module_utils`，一组不错的辅助函数和类。我们应该在我们的模块中加入最后一件事：几行代码，告诉解释器在执行模块文件时执行`main()`函数。
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, our module file is complete, which means we can test it with a playbook.
    We''ll call our playbook `simple_module.yaml` and store it in the same directory
    as the `library/` directory, where we''ve just written our module file. We''ll
    run the play on `localhost` for simplicity''s sake and use a couple of filenames
    in `/tmp` for the source and destination. We''ll also use a task to ensure that
    we have a source file to begin with:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的模块文件已经完成，这意味着我们可以用一个playbook来测试它。我们将称我们的playbook为`simple_module.yaml`，并将其存储在与`library/`目录相同的目录中，我们刚刚编写了我们的模块文件。出于简单起见，我们将在`localhost`上运行play，并在`/tmp`中使用一些文件名作为源和目的地。我们还将使用一个任务来确保我们首先有一个源文件：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As our new module is being run from a `library/` directory local to the playbook,
    it does not have a **fully qualified collection name** (**FQCN**), so we will
    reference it by its short name only in the playbook. To run this playbook, we''ll
    run the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的新模块是从与playbook本地的`library/`目录运行的，它没有一个**完全合格的集合名称**（**FQCN**），因此在playbook中我们只会用它的简称来引用它。要运行这个playbook，我们将运行以下命令：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the `remote_copy` module file is written to the correct location, everything
    will work just fine, and the screen output will look as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`remote_copy`模块文件写入了正确的位置，一切都将正常工作，屏幕输出将如下所示：
- en: '![Figure 10.1 – Running a simple playbook to test our first custom Ansible
    module'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1-运行一个简单的playbook来测试我们的第一个自定义Ansible模块'
- en: '](Images/B17462_10_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_01.jpg)'
- en: Figure 10.1 – Running a simple playbook to test our first custom Ansible module
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1-运行一个简单的playbook来测试我们的第一个自定义Ansible模块
- en: Our first task touches on the `/tmp/rcfoo` path to ensure that it exists, and
    then our second task makes use of `remote_copy` to copy `/tmp/rcfoo` to `/tmp/rcbar`.
    Both tasks are successful, resulting in a `changed` status each time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个任务涉及`/tmp/rcfoo`路径，以确保它存在，然后我们的第二个任务使用`remote_copy`将`/tmp/rcfoo`复制到`/tmp/rcbar`。两个任务都成功，每次都会产生一个`changed`状态。
- en: Documenting a module
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录模块
- en: No module should be considered complete unless it contains documentation regarding
    how to operate it. Documentation for a module exists within the module itself,
    in special variables called `DOCUMENTATION`, `EXAMPLES`, and `RETURN`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除非包含了有关如何操作它的文档，否则不应该认为模块是完整的。模块的文档存在于模块本身中，称为`DOCUMENTATION`、`EXAMPLES`和`RETURN`的特殊变量中。
- en: 'The `DOCUMENTATION` variable contains a specially formatted string describing
    the module''s name, the version of either `ansible-core` or the parent collection
    that it was added to, a short description of the module, a longer description,
    a description of the module arguments, the author and license information, additional
    requirements, and any extra notes that are useful to users of the module. Let''s
    add a `DOCUMENTATION` string to our module under the existing `import shutil`
    statement:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`DOCUMENTATION`变量包含一个特殊格式的字符串，描述了模块的名称，`ansible-core`的版本或其添加到的父集合的版本，模块的简短描述，更长的描述，模块参数的描述，作者和许可信息，额外要求以及对模块用户有用的任何额外说明。让我们在现有的`import
    shutil`语句下为我们的模块添加一个`DOCUMENTATION`字符串：'
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The format of the string is essentially YAML, with some top-level keys containing
    hash structures within it (the same as the `options` key). Each option has sub-elements
    to describe the option, indicate whether the option is required, list any aliases
    for the option, list static choices for the option, or indicate a default value
    for the option. With this string saved to the module, we can test our formatting
    to ensure that the documentation will render correctly. This is done via the `ansible-doc`
    tool, with an argument to indicate where to search for the modules. If we run
    it from the same place as our playbook, the command will be as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的格式本质上是YAML，其中一些顶级键包含其中的哈希结构（与`options`键相同）。每个选项都有子元素来描述选项，指示选项是否是必需的，列出选项的任何别名，列出选项的静态选择，或指示选项的默认值。将此字符串保存到模块后，我们可以测试我们的格式，以确保文档将正确呈现。这是通过`ansible-doc`工具完成的，使用参数指示在哪里搜索模块。如果我们从与我们的playbook相同的位置运行它，命令将如下所示：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output should look as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 10.2 – Using the ansible-doc tool to view our new module''s documentation'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 - 使用ansible-doc工具查看我们的新模块的文档
- en: '](Images/B17462_10_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_02.jpg)'
- en: Figure 10.2 – Using the ansible-doc tool to view our new module's documentation
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 - 使用ansible-doc工具查看我们的新模块的文档
- en: In this example, I've piped the output into `cat` to prevent the pager from
    hiding the execution line. Our documentation string appears to be formatted correctly
    and provides the user with important information regarding the usage of the module.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我将输出导入`cat`以防止分页程序隐藏执行行。我们的文档字符串似乎格式正确，并为用户提供了有关模块使用的重要信息。
- en: 'The `EXAMPLES` string is used to provide one or more example uses of the module,
    snippets of the task code that you would use in a playbook. Let''s add an example
    task to demonstrate its usage. This variable definition traditionally goes after
    the `DOCUMENTATION` definition:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXAMPLES`字符串用于提供模块的一个或多个示例用法，以及在playbook中使用的任务代码片段。让我们添加一个示例任务来演示其用法。这个变量定义传统上是在`DOCUMENTATION`定义之后：'
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this variable defined, our `ansible-doc` output will now include the example,
    as shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个变量定义，我们的`ansible-doc`输出现在将包括示例，如下所示：
- en: '![Figure 10.3 – Expanding our module documentation with an EXAMPLES section'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 - 通过EXAMPLES部分扩展我们的模块文档
- en: '](Images/B17462_10_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_03.jpg)'
- en: Figure 10.3 – Expanding our module documentation with an EXAMPLES section
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 - 通过EXAMPLES部分扩展我们的模块文档
- en: 'The last documentation variable, `RETURN`, is used to describe the return data
    from a module''s execution. Return data is often useful as a registered variable
    for later usage and having documentation of what return data to expect can aid
    playbook development. Our module doesn''t have any return data yet; so, before
    we can document any, we have to add return data. This can be done by modifying
    the `module.exit_json` line to add more information. Let''s add the `source` and
    `dest` data to the return output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个文档变量`RETURN`用于描述模块执行的返回数据。返回数据通常作为注册变量对后续使用很有用，并且有关预期返回数据的文档可以帮助playbook的开发。我们的模块还没有任何返回数据；因此，在我们可以记录任何返回数据之前，我们必须添加返回数据。这可以通过修改`module.exit_json`行来添加更多信息来完成。让我们将`source`和`dest`数据添加到返回输出中：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Rerunning the playbook will show extra data being returned, as shown in the
    following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行playbook将显示返回额外数据，如下面的截图所示：
- en: '![Figure 10.4 – Running our expanded module with return data added'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 - 运行我们扩展的模块并添加返回数据
- en: '](Images/B17462_10_04.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_04.jpg)'
- en: Figure 10.4 – Running our expanded module with return data added
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 - 运行我们扩展的模块并添加返回数据
- en: 'Looking closely at the return data, we can see more data than we put in our
    module. This is a bit of helper functionality within Ansible; when a return dataset
    includes a `dest` variable, Ansible will gather more information about the destination
    file. The extra data that''s gathered is `gid` (group ID), `group` (group name),
    `mode` (permissions), `uid` (owner ID), `owner` (owner name), `size`, and `state`
    (file, link, or directory). We can document all of these return items in our `RETURN`
    variable, which is added after the `EXAMPLES` variable. Everything between the
    two sets of three single quotes (`''''''`) is returned – thus, this first part
    returns the file paths and ownership:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察返回数据，我们可以看到比我们在模块中放入的更多数据。这是Ansible中的一些辅助功能；当返回数据集包括`dest`变量时，Ansible将收集有关目标文件的更多信息。收集的额外数据是`gid`（组ID），`group`（组名），`mode`（权限），`uid`（所有者ID），`owner`（所有者名），`size`和`state`（文件，链接或目录）。我们可以在我们的`RETURN`变量中记录所有这些返回项，它是在`EXAMPLES`变量之后添加的。两组三个单引号（`'''`）之间的所有内容都会被返回
    - 因此，这第一部分返回文件路径和所有权：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Continuing with this part of the module definition file, this section returns
    the details about the file''s size, state, and permissions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 继续模块定义文件的这一部分，这一部分返回有关文件大小，状态和权限的详细信息：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Each returned item is listed with a description, the cases when the item would
    be in the return data, the type of item it is, and a sample of the value. The
    `RETURN` string is parsed by `ansible-doc` but the return values are sorted into
    alphabetical order, wherein the previous version of this book, we saw that the
    values were printed in the order in which they are listed in the module itself.
    The following screenshot shows this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个返回的项目都列有描述、项目在返回数据中的情况、项目的类型和值的示例。`RETURN`字符串由`ansible-doc`解析，但返回值按字母顺序排序，在本书的上一个版本中，我们看到值是按模块本身中列出的顺序打印的。以下屏幕截图显示了这一点：
- en: '![Figure 10.5 – Adding return data documentation to our module'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.5 - 向我们的模块添加返回数据文档'
- en: '](Images/B17462_10_05.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_05.jpg)'
- en: Figure 10.5 – Adding return data documentation to our module
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 - 向我们的模块添加返回数据文档
- en: In this way, we have built up a module that contains documentation that's incredibly
    useful for others if we are contributing it to the community, or even for ourselves
    when we come back to it after a while.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们建立了一个包含文档的模块，如果我们将其贡献给社区，对其他人来说非常有用，甚至对我们自己来说，当我们一段时间后回来时也很有用。
- en: Providing fact data
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供事实数据
- en: 'Similar to data returned as part of a module, such as `exit`, a module can
    directly create facts for a host by returning data in a key named `ansible_facts`.
    Providing facts directly from a module eliminates the need to register the return
    of a task with a subsequent `set_fact` task. To demonstrate this usage, let''s
    modify our module to return the `source` and `dest` data as facts. Because these
    facts will become top-level host variables, we''ll want to use more descriptive
    fact names than `source` and `dest`. Replace the current `module.exit_json` line
    in our module with the code listed here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与作为模块的一部分返回的数据类似，例如`exit`，模块可以通过在名为`ansible_facts`的键中返回数据来直接为主机创建事实。直接从模块提供事实可以消除需要使用后续的`set_fact`任务注册任务的返回的需要。为了演示这种用法，让我们修改我们的模块以返回`source`和`dest`数据作为事实。因为这些事实将成为顶级主机变量，我们希望使用比`source`和`dest`更具描述性的事实名称。用以下代码替换我们模块中的当前`module.exit_json`行：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ll also add a task to our playbook to use one of the facts in a `debug`
    statement:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将向我们的playbook添加一个任务，使用`debug`语句中的一个事实：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, running the playbook will show the new return data, plus the use of the
    variable, as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行playbook将显示新的返回数据，以及变量的使用，如下屏幕截图所示：
- en: '![Figure 10.6 – Adding facts to our custom module and viewing their values
    during playbook execution'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.6 - 向我们的自定义模块添加事实，并在playbook执行期间查看它们的值'
- en: '](Images/B17462_10_06.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_06.jpg)'
- en: Figure 10.6 – Adding facts to our custom module and viewing their values during
    playbook execution
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 - 向我们的自定义模块添加事实，并在playbook执行期间查看它们的值
- en: 'If our module does not return facts (and our previous version of `remote_copy.py`
    didn''t), we will have to register the output and use `set_fact` to create the
    fact for us, as shown in the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的模块不返回事实（我们之前的`remote_copy.py`版本没有），我们将不得不注册输出并使用`set_fact`为我们创建事实，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Although it is useful to be able to do this, when designing our modules, it
    is better to have the module define the facts required. If this is not done, then
    the previous register and the `set_fact` code would need to be repeated for every
    use of our module in a playbook!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然能够这样做很有用，但在设计我们的模块时，最好让模块定义所需的事实。如果不这样做，那么以前的注册和`set_fact`代码将需要在playbook中每次使用我们的模块时重复！
- en: Check mode
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查模式
- en: Since the early days of its existence, Ansible has supported **check mode**,
    a mode of operation that will pretend to make changes to a system without actually
    changing the system. Check mode is useful for testing whether a change will happen,
    or whether a system state has drifted since the last Ansible run. Check mode depends
    on modules to support it and return data, as if it had completed the change. Supporting
    check mode in our module requires two changes; the first is to indicate that the
    module supports check mode, while the second is to detect when check mode is active
    and return data before execution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 自其存在以来，Ansible就支持**检查模式**，这是一种操作模式，会假装对系统进行更改，而实际上并未更改系统。检查模式对于测试是否会发生更改或系统状态是否已漂移自上次Ansible运行以来非常有用。检查模式取决于模块是否支持它并返回数据，就好像已经完成了更改一样。在我们的模块中支持检查模式需要两个更改；第一个是指示模块支持检查模式，而第二个是在执行之前检测检查模式是否激活并返回数据。
- en: Supporting check mode
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 支持检查模式
- en: 'To indicate that a module supports check mode, an argument has to be set when
    creating the module object. This can be done before or after the `argument_spec`
    variable is defined in the module object; here, we will do it after it has been
    defined:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要指示模块支持检查模式，必须在创建模块对象时设置一个参数。这可以在定义模块对象中的`argument_spec`变量之前或之后完成；在这里，我们将在定义之后完成：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you're modifying your existing code, don't forget to add the comma after
    the `argument_spec` dictionary definition, as shown in the preceding code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在修改现有代码，请不要忘记在`argument_spec`字典定义之后添加逗号，如前面的代码所示。
- en: Handling check mode
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理检查模式
- en: 'Detecting when check mode is active is very easy. The module object will have
    a `check_mode` attribute, which will be set to a Boolean value of `true` when
    check mode is active. In our module, we want to detect whether check mode is active
    before performing the copy. We can simply move the copy action into an `if` statement
    to avoid copying when check mode is active. No further changes to the module are
    necessary beyond this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 检测检查模式是否激活非常容易。模块对象将具有一个`check_mode`属性，当检查模式激活时，它将设置为布尔值`true`。在我们的模块中，我们希望在执行复制之前检测检查模式是否激活。我们可以简单地将复制操作移到一个`if`语句中，以避免在检查模式激活时进行复制。除此之外，对模块不需要进行进一步的更改：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can run our playbook and add the `-C` argument to our execution. This
    argument engages check mode. We''ll also test to ensure that the playbook did
    not create and copy the files. The following screenshot shows this in action:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行我们的playbook，并在执行中添加`-C`参数。这个参数启用检查模式。我们还将测试以确保playbook没有创建和复制文件。以下截图显示了这一点：
- en: '![Figure 10.7 – Adding check mode support to our Ansible module'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7-为我们的Ansible模块添加检查模式支持'
- en: '](Images/B17462_10_07.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_07.jpg)'
- en: Figure 10.7 – Adding check mode support to our Ansible module
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7-为我们的Ansible模块添加检查模式支持
- en: Although the module's output looks as though it created and copied files, we
    can see that the files referenced did not exist before execution and still do
    not exist after execution, a clear indication that our simple module was run in
    check mode.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管模块的输出看起来好像创建并复制了文件，但我们可以看到在执行之前这些文件并不存在，并且在执行之后仍然不存在，这清楚地表明我们的简单模块是在检查模式下运行的。
- en: Now that we've looked at our simple example module, we'll explore how to extend
    the functionality of Ansible through another important item – plugins.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看了我们的简单示例模块，我们将探讨如何通过另一个重要的项目-插件来扩展Ansible的功能。
- en: Developing plugins
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发插件
- en: Plugins are another way of extending or modifying the functionality of Ansible.
    While modules are executed as tasks, plugins are utilized in a variety of other
    places. Plugins are broken down into a few types, based on where they would plug
    into the Ansible execution. Ansible ships some plugins for each of these areas,
    and end users can create their own to extend the functionality of these specific
    areas.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 插件是扩展或修改Ansible功能的另一种方式。虽然模块是作为任务执行的，但插件在各种其他地方使用。插件根据它们插入到Ansible执行的位置被分为几种类型。Ansible为每个领域提供了一些插件，最终用户可以创建自己的插件来扩展这些特定领域的功能。
- en: Connection-type plugins
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接类型插件
- en: 'Any time Ansible makes a connection to a host to perform a task, a connection
    plugin is used. Ansible ships with a few connection plugins, including `ssh`,
    `community.docker.docker`, `local`, and `winrm`. Additional connection mechanisms
    can be utilized by Ansible to connect to remote systems by creating a connection
    plugin, which may be useful if you must connect to some new type of system, such
    as a network switch, or perhaps your refrigerator someday. To create a new connection
    plugin, we would have to understand and work with an underlying communication
    protocol, which in itself could have a book devoted to it; as such, we won''t
    attempt to create one here. However, the easiest way to get started is to read
    through the existing plugins that ship with Ansible and pick one to modify as
    necessary. The existing plugins can be found in `plugins/connection/` wherever
    the Ansible Python libraries are installed on your system, such as `/usr/local/lib/python3.8/dist-packages/ansible/plugins/connection/`
    on my system. You can also view them on GitHub – for example, if you wanted to
    look up the files relevant to the `2.11.1` release of `ansible-core`, you could
    look here: [https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/connection](https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/connection).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每当Ansible连接到主机执行任务时，都会使用连接插件。Ansible附带了一些连接插件，包括`ssh`、`community.docker.docker`、`local`和`winrm`。Ansible可以通过创建连接插件来利用其他连接机制，这可能会有用，如果您必须连接到一些新类型的系统，比如网络交换机，或者也许有一天连接到您的冰箱。要创建一个新的连接插件，我们必须了解并使用底层通信协议，这本身可能需要一本专门的书籍；因此，我们不会在这里尝试创建一个。然而，开始的最简单方法是阅读与Ansible一起提供的现有插件，并选择一个进行必要的修改。现有的插件可以在您的系统上安装Ansible
    Python库的位置中找到，例如在我的系统上是`/usr/local/lib/python3.8/dist-packages/ansible/plugins/connection/`。您也可以在GitHub上查看它们-例如，如果您想查找与`ansible-core`的`2.11.1`版本相关的文件，您可以在这里查看：[https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/connection](https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/connection)。
- en: Shell plugins
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shell插件
- en: 'Much like connection plugins, Ansible makes use of **shell plugins** to execute
    things in a shell environment. Each shell has subtle differences that Ansible
    cares about to properly execute commands, redirect output, discover errors, and
    other such interactions. Ansible supports several shells, including `sh`, `ansible.posix.csh`,
    `ansible.posix.fish`, and `powershell`. We can add more shells by implementing
    a new shell plugin. You can view the code for them (for the `2.11.1` release of
    `ansible-core`) here: [https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/shell](https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/shell).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与连接插件类似，Ansible使用**shell插件**在shell环境中执行操作。每个shell都有Ansible关心的微妙差异，以正确执行命令，重定向输出，发现错误等交互。Ansible支持多种shell，包括`sh`、`ansible.posix.csh`、`ansible.posix.fish`和`powershell`。我们可以通过实现新的shell插件来添加更多的shell。您可以在这里查看它们的代码（对于`ansible-core`的`2.11.1`版本）：[https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/shell](https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/shell)。
- en: Lookup plugins
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找插件
- en: '**Lookup plugins** are how Ansible accesses outside data sources from the host
    system and implements language features, such as looping constructs (`loop` or
    `with_*`). A lookup plugin can be created to access data from an existing data
    store or to create a new looping mechanism. The existing lookup plugins can be
    found in `plugins/lookup/` or on GitHub here: [https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/lookup](https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/lookup).
    Lookup plugins can be added to introduce new ways of looping over content, or
    for looking up resources in external systems.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找插件**是Ansible从主机系统访问外部数据源并实现语言特性，比如循环结构（`loop`或`with_*`）的方式。可以创建查找插件来访问现有数据存储中的数据或创建新的循环机制。现有的查找插件可以在`plugins/lookup/`中找到，或者在GitHub上找到：[https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/lookup](https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/lookup)。查找插件可以添加以引入新的循环内容的方式，或者用于在外部系统中查找资源。'
- en: Vars plugins
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vars插件
- en: Constructs to inject variable data exist in the form of **vars plugins**. Data
    such as `host_vars` and `group_vars` are implemented via plugins. While it's possible
    to create new variable plugins, most often, it is better to create a custom inventory
    source or a fact module instead.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 存在用于注入变量数据的构造，形式为**vars插件**。诸如`host_vars`和`group_vars`之类的数据是通过插件实现的。虽然可以创建新的变量插件，但通常最好创建自定义清单源或事实模块。
- en: Fact-caching plugins
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事实缓存插件
- en: Ansible can cache facts between playbook runs. Where facts are cached depends
    on the configured cache plugin that is used. Ansible includes plugins to cache
    facts in `memory` (they're not cached between runs as this is not persistent),
    `community.general.memcached`, `community.general.redis`, and `jsonfile`. Creating
    a **fact-caching plugin** can enable additional caching mechanisms.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible可以在playbook运行之间缓存事实。事实的缓存位置取决于所使用的配置缓存插件。Ansible包括在`memory`（它们在运行之间不会被缓存，因为这不是持久的）、`community.general.memcached`、`community.general.redis`和`jsonfile`中缓存事实的插件。创建一个**事实缓存插件**可以启用额外的缓存机制。
- en: Filter plugins
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤插件
- en: While Jinja2 includes several filters, Ansible has made filters pluggable to
    extend the Jinja2 functionality. Ansible includes several filters that are useful
    for Ansible operations, and users of Ansible can add more. Existing plugins can
    be found in `plugins/filter/`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Jinja2包含了几个过滤器，但Ansible已经使过滤器可插拔以扩展Jinja2的功能。Ansible包括了一些对Ansible操作有用的过滤器，并且Ansible的用户可以添加更多过滤器。现有的插件可以在`plugins/filter/`中找到。
- en: To demonstrate the development of a filter plugin, we will create a simple filter
    plugin to do a silly thing to text strings. We will create a filter that will
    replace any occurrence of the words `the cloud` with the string `somebody else's
    computer`. We'll define our filter in a file within a new directory, `filter_plugins/`,
    in our existing working directory. The name of the file doesn't matter, as we'll
    define the name of the filter within the file; so, let's name our file `filter_plugins/sample_filter.py`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示过滤器插件的开发，我们将创建一个简单的过滤器插件来对文本字符串进行一些愚蠢的操作。我们将创建一个过滤器，它将用字符串`somebody else's
    computer`替换任何出现的`the cloud`。我们将在现有工作目录中的新目录`filter_plugins/`中的文件中定义我们的过滤器。文件的名称无关紧要，因为我们将在文件中定义过滤器的名称；所以，让我们将文件命名为`filter_plugins/sample_filter.py`。
- en: 'First, we need to define the function that will perform the translation and
    provide the code to translate the strings:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义执行翻译的函数，并提供翻译字符串的代码：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we''ll need to construct a `FilterModule` object and define our filter
    within it. This object is what Ansible will load, and Ansible expects there to
    be a `filters` function within the object that returns a set of filter names to
    functions within the file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要构建一个`FilterModule`对象，并在其中定义我们的过滤器。这个对象是Ansible将要加载的对象，Ansible期望在对象内有一个`filters`函数，该函数返回文件中的一组过滤器名称到函数的映射：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we can use this filter in a playbook, which we''ll call `simple_filter.yaml`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在一个playbook中使用这个过滤器，我们将其命名为`simple_filter.yaml`：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s run our playbook and see our filter in action:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行我们的playbook，看看我们的过滤器如何运行：
- en: '![Figure 10.8 – Executing a playbook to test our new filter plugin'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8 - 执行playbook以测试我们的新过滤器插件'
- en: '](Images/B17462_10_08.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_08.jpg)'
- en: Figure 10.8 – Executing a playbook to test our new filter plugin
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 - 执行playbook以测试我们的新过滤器插件
- en: Our filter worked, and it turned the words `the cloud` into `somebody else's
    computer`. This is a silly example without any error handling, but it demonstrates
    our capability to extend Ansible and Jinja2's filter capabilities.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的过滤器起作用了，它将`the cloud`这个词替换为`somebody else's computer`。这是一个愚蠢的例子，没有任何错误处理，但它展示了我们扩展Ansible和Jinja2的过滤器功能的能力。
- en: Important Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Although the name of the file that contains a filter definition can be whatever
    the developer wants, a best practice is to name it after the filter itself so
    that it can easily be found in the future, potentially by other collaborators.
    This example did not follow this, to demonstrate that the filename is not attached
    to the filter name.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然包含过滤器定义的文件的名称可以是开发人员想要的任何名称，但最佳做法是将其命名为过滤器本身，以便将来可以轻松找到它，可能是由其他合作者找到。这个例子没有遵循这个规则，以演示文件名不附加到过滤器名称。
- en: Callback plugins
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调插件
- en: '**Callbacks** are places in Ansible execution that can be plugged into for
    added functionality. There are expected callback points that can be registered
    against to trigger custom actions at those points. Here is a list of possible
    points that can be used to trigger functionality at the time of writing:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**回调**是可以插入以增加功能的Ansible执行中的位置。有预期的回调点可以注册以触发这些点的自定义操作。以下是可能用于在编写时触发功能的点的列表：'
- en: '`v2_on_any`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_on_any`'
- en: '`v2_runner_on_failed`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_runner_on_failed`'
- en: '`v2_runner_on_ok`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_runner_on_ok`'
- en: '`v2_runner_on_skipped`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_runner_on_skipped`'
- en: '`v2_runner_on_unreachable`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_runner_on_unreachable`'
- en: '`v2_runner_on_async_poll`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_runner_on_async_poll`'
- en: '`v2_runner_on_async_ok`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_runner_on_async_ok`'
- en: '`v2_runner_on_async_failed`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_runner_on_async_failed`'
- en: '`v2_runner_on_start`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_runner_on_start`'
- en: '`v2_playbook_on_start`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_playbook_on_start`'
- en: '`v2_playbook_on_notify`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_playbook_on_notify`'
- en: '`v2_playbook_on_no_hosts_matched`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_playbook_on_no_hosts_matched`'
- en: '`v2_playbook_on_no_hosts_remaining`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_playbook_on_no_hosts_remaining`'
- en: '`v2_playbook_on_task_start`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_playbook_on_task_start`'
- en: '`v2_playbook_on_cleanup_task_start`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_playbook_on_cleanup_task_start`'
- en: '`v2_playbook_on_handler_task_start`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_playbook_on_handler_task_start`'
- en: '`v2_playbook_on_vars_prompt`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_playbook_on_vars_prompt`'
- en: '`v2_playbook_on_import_for_host`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_playbook_on_import_for_host`'
- en: '`v2_playbook_on_not_import_for_host`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_playbook_on_not_import_for_host`'
- en: '`v2_playbook_on_play_start`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_playbook_on_play_start`'
- en: '`v2_playbook_on_stats`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_playbook_on_stats`'
- en: '`v2_on_file_diff`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_on_file_diff`'
- en: '`v2_playbook_on_include`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_playbook_on_include`'
- en: '`v2_runner_item_on_ok`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_runner_item_on_ok`'
- en: '`v2_runner_item_on_failed`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_runner_item_on_failed`'
- en: '`v2_runner_item_on_skipped`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_runner_item_on_skipped`'
- en: '`v2_runner_retry`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2_runner_retry`'
- en: As an Ansible run reaches each of these states, any plugins that have code to
    run at these points will be executed. This provides the tremendous ability to
    extend Ansible without having to modify the base code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当Ansible运行达到这些状态时，任何具有在这些点运行代码的插件都将被执行。这提供了在不修改基本代码的情况下扩展Ansible的巨大能力。
- en: 'Callbacks can be utilized in a variety of ways: to change how things are displayed
    on the screen, to update a central status system of progress, to implement a global
    locking system, or nearly anything imaginable. It''s the most powerful way to
    extend the functionality of Ansible. However, you will note that the previously
    listed items do not appear on the official Ansible documentation website ([https://docs.ansible.com](https://docs.ansible.com)),
    nor are they listed by the `ansible-doc` command. A great place to go to look
    up these callbacks to learn more about them is the `plugins/callback/__init__.py`
    file, under your `ansible-core` installation directory. For example, on my system,
    where Ansible was installed with pip, the full path is `/usr/local/lib/python3.8/dist-packages/ansible/plugins/callback/__init__.py`
    (if you want to look this up on the internet, the file for the `2.11.1` release
    of `ansible-core` can be found here: [https://github.com/ansible/ansible/blob/v2.11.1/lib/ansible/plugins/callback/__init__.py](https://github.com/ansible/ansible/blob/v2.11.1/lib/ansible/plugins/callback/__init__.py)).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 回调可以以各种方式使用：更改屏幕上的显示方式，更新进度的中央状态系统，实现全局锁定系统，或者几乎可以想象的任何事情。这是扩展Ansible功能的最强大方式。但是，您会注意到先前列出的项目在官方Ansible文档网站([https://docs.ansible.com](https://docs.ansible.com))上没有出现，也不会被`ansible-doc`命令列出。查找这些回调并了解更多关于它们的信息的好地方是`plugins/callback/__init__.py`文件，在您的`ansible-core`安装目录下。例如，在我的系统上，Ansible是使用pip安装的，完整路径是`/usr/local/lib/python3.8/dist-packages/ansible/plugins/callback/__init__.py`（如果您想在互联网上查找此文件，`ansible-core`的`2.11.1`版本的文件可以在此处找到：[https://github.com/ansible/ansible/blob/v2.11.1/lib/ansible/plugins/callback/__init__.py](https://github.com/ansible/ansible/blob/v2.11.1/lib/ansible/plugins/callback/__init__.py)）。
- en: 'To demonstrate our ability to develop a callback plugin, we''ll create a simple
    plugin that will print something silly on the screen when the playbook prints
    the summary of the play at the end:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示我们开发回调插件的能力，我们将创建一个简单的插件，当playbook在最后打印play摘要时，它将在屏幕上打印一些愚蠢的东西：
- en: First, we'll need to make a new directory to hold our callback. The location
    Ansible will look for is `callback_plugins/`. Unlike the `filter` plugin earlier,
    we do need to name our callback plugin file carefully, as it will also have to
    be reflected in an `ansible.cfg` file.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个新目录来保存我们的回调。Ansible将查找的位置是`callback_plugins/`。与之前的`filter`插件不同，我们确实需要仔细命名我们的回调插件文件，因为它也必须在`ansible.cfg`文件中反映出来。
- en: 'We''ll name ours `callback_plugins/shrug.py`. As Ansible versions greater than
    3.0 are being moved toward Python 3 support only (though Python 2.7 is supported
    still at the time of writing), your plugin code should be written for Python 3\.
    Start by adding the following Python 3 header to your plugin:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将命名为`callback_plugins/shrug.py`。由于Ansible版本大于3.0正在向Python 3支持移动（尽管在撰写本文时仍支持Python
    2.7），因此您的插件代码应该是为Python 3编写的。首先在插件中添加以下Python 3头：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next up, you will need to add a documentation block, much like we did in the
    *Developing modules* section of this chapter. In the previous edition of this
    book, there was no need to do this, but now, you will get a deprecation warning
    if you don''t, and your callback plugin may not work when `ansible-core` 2.14
    is released. Our documentation block will look like this:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要添加一个文档块，就像我们在本章的*开发模块*部分所做的那样。在本书的上一版中，不需要这样做，但现在，如果您不这样做，将会收到弃用警告，并且您的回调插件在`ansible-core`
    2.14发布时可能无法工作。我们的文档块将如下所示：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Most of the items in the documentation are self-explanatory, but the `extends_documentation_fragment`
    item is worth noting. This particular part of the documentation block is the piece
    that is required for compatibility with `ansible-core` 2.14, and as we are extending
    the `default_callback` plugin here, we need to tell Ansible that we are extending
    this piece of documentation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 文档中的大多数项目都是不言自明的，但值得注意的是`extends_documentation_fragment`项目。文档块的这一部分是与`ansible-core`
    2.14兼容所必需的部分，因为我们在这里扩展了`default_callback`插件，我们需要告诉Ansible我们正在扩展这一部分文档。
- en: With this complete, we'll need to create a `CallbackModule` class, subclassed
    from `CallbackModule`, defined in the `default` callback plugin found in `ansible.plugins.callback.default`,
    since we only need to change one aspect of the normal output.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们需要创建一个`CallbackModule`类，它是从`ansible.plugins.callback.default`中找到的`default`回调插件中定义的`CallbackModule`的子类，因为我们只需要更改正常输出的一个方面。
- en: Within this class, we will define variable values to indicate that it is a `2.0`
    version callback, that it is an `stdout` type of callback, and that it has the
    name `shrug`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类中，我们将定义变量值来指示它是`2.0`版本的回调，它是`stdout`类型的回调，并且它的名称是`shrug`。
- en: Also, within this class, we must initialize it so that we can define one or
    more of the callback points listed earlier that we'd like to plug into to make
    something happen. In our example, we want to modify the display of the playbook
    summary that is produced at the end of the run, for which we will modify the `v2_playbook_on_stats`
    callback.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在这个类中，我们必须初始化它，以便我们可以定义我们想要插入以使某些事情发生的回调点中的一个或多个。在我们的示例中，我们想要修改运行结束时生成的playbook摘要的显示，因此我们将修改`v2_playbook_on_stats`回调。
- en: 'To round off our plugin, we must call the original callback module itself.
    Ansible now only supports one `stdout` plugin at a time, so if we don''t call
    the original plugin, we will find that the output from our plugin is the only
    output that''s produced – all the other information regarding the playbook run
    will be missing! The final code below the documentation block should look like
    this:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的插件，我们必须调用原始的回调模块本身。Ansible现在一次只支持一个`stdout`插件，因此如果我们不调用原始插件，我们将发现我们的插件的输出是唯一产生的输出-有关playbook运行的所有其他信息都将丢失！文档块下面的最终代码应该如下所示：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As this callback is `stdout_callback`, we''ll need to create an `ansible.cfg`
    file and, within it, indicate that the `shrug` `stdout` callback should be used.
    The `ansible.cfg` file can be found in `/etc/ansible/` or in the same directory
    as the playbook:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于此回调是`stdout_callback`，我们需要创建一个`ansible.cfg`文件，并在其中指示应使用`shrug` `stdout`回调。`ansible.cfg`文件可以在`/etc/ansible/`中找到，也可以在与playbook相同的目录中找到：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'That''s all we have to write in our callback. Once it''s saved, we can rerun
    our previous playbook, which exercised our `sample_filter`, but this time, we''ll
    see something different on the screen:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是我们在回调中要写的全部内容。一旦保存，我们就可以重新运行之前的playbook，这个playbook练习了我们的`sample_filter`，但这次，在屏幕上会看到不同的东西：
- en: '![Figure 10.9 – Adding our shrug plugin to modify the playbook run output'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.9-将我们的shrug插件添加到修改playbook运行输出'
- en: '](Images/B17462_10_09.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_09.jpg)'
- en: Figure 10.9 – Adding our shrug plugin to modify the playbook run output
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9-将我们的shrug插件添加到修改playbook运行输出
- en: This is very silly, but it demonstrates the ability to plug into various points
    of a playbook execution. We chose to display a series of shrugs on screen, but
    we could have just as easily interacted with some internal audit and control system
    to record actions, or to reported progress to an IRC or Slack channel.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这很愚蠢，但它展示了插入到playbook执行的各个点的能力。我们选择在屏幕上显示一系列耸肩，但我们也可以与一些内部审计和控制系统进行交互，记录操作，或者向IRC或Slack频道报告进度。
- en: Action plugins
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作插件
- en: '**Action plugins** exist to hook into the task construct without actually causing
    a module to be executed, or to execute code locally on the Ansible host before
    executing a module on the remote host. Several action plugins are included with
    Ansible and they can be found in `plugins/action/`. One such action plugin is
    the `template` plugin, which can be used in place of a `template` module. When
    a playbook author writes a `template` task, that task will call the `template`
    plugin to do the work. The plugin, among other things, will render the template
    locally before copying the content to the remote host. Because actions have to
    happen locally, the work is done by an action plugin. Another action plugin we
    should be familiar with is the `debug` plugin, which we''ve used heavily in this
    book to print content. Creating a custom action plugin is useful when we''re trying
    to accomplish both local work and remote work in the same task.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**动作插件**用于在不实际执行模块的情况下钩入任务结构，或者在在远程主机上执行模块之前在Ansible主机上执行代码。Ansible包含多个动作插件，它们可以在`plugins/action/`中找到。其中一个动作插件是`template`插件，它可以用来代替`template`模块。当playbook作者编写`template`任务时，该任务将调用`template`插件来执行工作。该插件将在将内容复制到远程主机之前在本地渲染模板。因为动作必须在本地发生，所以由动作插件完成工作。我们应该熟悉的另一个动作插件是`debug`插件，在本书中我们大量使用它来打印内容。当我们尝试在同一个任务中完成本地工作和远程工作时，创建自定义动作插件是有用的。'
- en: Distributing plugins
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发插件
- en: Much like distributing custom modules, there are standard places to store custom
    plugins alongside playbooks that expect to use plugins. The default locations
    for plugins are the locations that are shipped with the Ansible code install,
    subdirectories within `~/.ansible/plugins/`, and subdirectories of the project
    root (the place where the top-level playbook is stored). Plugins can be distributed
    within the same subdirectories of a role as well, as well as collections, as we
    covered in [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047), *Migrating
    from Earlier Ansible Versions*. To utilize plugins from any other location, we
    need to define the location to find the plugin for the plugin type in an `ansible.cfg`
    file or reference the collection, as we demonstrated by loading our example filter
    module in [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047), *Migrating
    from Earlier Ansible Versions*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与分发自定义模块类似，存储自定义插件的标准位置与期望使用插件的playbooks一起。插件的默认位置是与Ansible代码安装一起提供的位置，`~/.ansible/plugins/`的子目录，以及项目根目录的子目录（顶级playbook存储的位置）。插件也可以在角色的相同子目录中分发，以及集合中，正如我们在[*第2章*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047)中所介绍的那样，*从早期Ansible版本迁移*。要使用来自任何其他位置的插件，我们需要在`ansible.cfg`文件中定义查找插件类型的插件的位置，或者引用集合，就像我们在[*第2章*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047)中加载示例过滤器模块时所演示的那样，*从早期Ansible版本迁移*。
- en: 'If you''re distributing plugins inside the project root, each plugin type gets
    its own top-level directory:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在项目根目录内分发插件，每种插件类型都有自己的顶级目录：
- en: '`action_plugins/`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action_plugins/`'
- en: '`cache_plugins/`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache_plugins/`'
- en: '`callback_plugins/`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback_plugins/`'
- en: '`connection_plugins/`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connection_plugins/`'
- en: '`shell_plugins/`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shell_plugins/`'
- en: '`lookup_plugins/`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lookup_plugins/`'
- en: '`vars_plugins/`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vars_plugins/`'
- en: '`filter_plugins/`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter_plugins/`'
- en: As with other Ansible constructs, the first plugin with a given name that's
    found will be used, and just as with modules, the paths relative to the project
    root are checked first, allowing a local override of an existing plugin. Simply
    place the filter file in the appropriate subdirectory, and it will be automatically
    used when referenced.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他Ansible结构一样，找到的具有相同名称的第一个插件将被使用，并且与模块一样，首先检查相对于项目根目录的路径，允许本地覆盖现有插件。只需将过滤器文件放在适当的子目录中，当引用时将自动使用它。
- en: Developing dynamic inventory plugins
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发动态清单插件
- en: '**Inventory plugins** are bits of code that will create inventory data for
    an Ansible execution. In many environments, the simple `ini` file-style inventory
    source and variable structure are not sufficient for representing the actual infrastructure
    being managed. In such cases, a dynamic inventory source is desired, one that
    will discover the inventory and data at runtime at every execution of Ansible.
    A number of these dynamic sources ship with Ansible, primarily to operate Ansible
    with the infrastructure built into one cloud computing platform or another. A
    short, incomplete list of dynamic inventory plugins that ship with Ansible 4.3
    (there are now over 40) includes the following – note from the FQCNs that many
    of these that were once shipped as part of the Ansible 2.x releases are now being
    included as part of the wider set of collections that form Ansible 4.3:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单插件**是一些代码，将为Ansible执行创建清单数据。在许多环境中，简单的`ini`文件样式的清单源和变量结构不足以表示实际管理的基础设施。在这种情况下，需要动态清单源，它将在每次执行Ansible时动态发现清单和数据。许多这些动态源与Ansible一起提供，主要是为了在一个云计算平台或另一个云计算平台内部构建的基础设施上操作Ansible。与Ansible
    4.3一起提供的动态清单插件的简短而不完整的列表（现在有超过40个）包括以下内容-请注意来自FQCNs的这些插件，这些插件曾经作为Ansible 2.x版本的一部分提供，现在作为构成Ansible
    4.3的更广泛集合的一部分被包含进来：'
- en: '`azure.azcollection.azure_rm`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`azure.azcollection.azure_rm`'
- en: '`community.general.cobbler`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`community.general.cobbler`'
- en: '`community.digitalocean.digitalocean`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`community.digitalocean.digitalocean`'
- en: '`community.docker.docker_containers`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`community.docker.docker_containers`'
- en: '`amazon.aws.aws_ec2`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`amazon.aws.aws_ec2`'
- en: '`google.cloud.gcp_compute`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google.cloud.gcp_compute`'
- en: '`community.libvirt.libvirt`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`community.libvirt.libvirt`'
- en: '`community.general.linode`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`community.general.linode`'
- en: '`kubernetes.core.openshift`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubernetes.core.openshift`'
- en: '`openstack.cloud.openstack`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openstack.cloud.openstack`'
- en: '`community.vmware.vmware_vm_inventory`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`community.vmware.vmware_vm_inventory`'
- en: '`servicenow.servicenow.now`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`servicenow.servicenow.now`'
- en: An inventory plugin is essentially an executable script. Ansible calls the script
    with set arguments (`--list` or `--host <hostname>`) and expects JSON formatted
    output on `STDOUT`. When the `--list` argument is provided, Ansible expects a
    list of all the groups to be managed. Each group can list host membership, child
    group membership, and group variable data. When the script is called with the
    `--host <hostname>` argument, Ansible expects host-specific data to be returned
    (or an empty JSON dictionary).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 清单插件本质上是可执行脚本。Ansible使用设置的参数（`--list`或`--host <hostname>`）调用脚本，并期望在`STDOUT`上以JSON格式输出。当提供`--list`参数时，Ansible期望列出要管理的所有组的列表。每个组可以列出主机成员资格、子组成员资格和组变量数据。当使用`--host
    <hostname>`参数调用脚本时，Ansible期望返回特定于主机的数据（或空的JSON字典）。
- en: Using a dynamic inventory source is easy. A source can be used directly by referring
    to it with the `-i` (`--inventory-file`) option to `ansible` and `ansible-playbook`,
    or by putting the plugin file inside the directory referred to by the inventory
    path in `ansible.cfg`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态清单源很容易。可以通过在`ansible`和`ansible-playbook`中使用`-i`（`--inventory-file`）选项直接引用源，也可以通过将插件文件放在`ansible.cfg`中清单路径引用的目录中。
- en: Before creating an inventory plugin, we must understand the expected format
    for when `--list` or `--host` is used with our script.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建清单插件之前，我们必须了解在使用我们的脚本时`--list`或`--host`的预期格式。
- en: Listing hosts
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出主机
- en: When the `--list` argument is passed to an inventory script, Ansible expects
    the JSON output data to have a set of top-level keys. These keys are named for
    the groups in the inventory. Each group gets a key. The structure within a group
    key varies, depending on what data needs to be represented in the group. If a
    group just has hosts and no group-level variables, the data within the key can
    simply be a list of hostnames. If the group has variables or children (a group
    of groups), then the data needs to be a hash, which can have one or more keys
    named `hosts`, `vars`, or `children`. The `hosts` and `children` subkeys have
    list values, a list of the hosts that exist in the group, or a list of the child
    groups. The `vars` subkey has a hash value, where each variable's name and value
    is represented by a key and value.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当`--list`参数传递给清单脚本时，Ansible期望JSON输出数据具有一组顶级键。这些键以清单中的组命名。每个组都有一个键。组键内的结构因需要在组中表示的数据而异。如果一个组只有主机而没有组级变量，则键内的数据可以简单地是主机名的列表。如果组有变量或子组（一组组），则数据需要是一个哈希，可以有一个或多个名为`hosts`、`vars`或`children`的键。`hosts`和`children`子键具有列表值，即组中存在的主机列表或子组列表。`vars`子键具有哈希值，其中每个变量的名称和值由键和值表示。
- en: Listing host variables
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出主机变量
- en: When the `--host <hostname>` argument is passed to an inventory script, Ansible
    expects the JSON output data to simply be a hash of the variables, where each
    variable name and value is represented by a key and a value. If there are no variables
    for a given host, an empty hash is expected.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '当`--host <hostname>`参数传递给清单脚本时，Ansible期望JSON输出数据只是变量的哈希，其中每个变量的名称和值由键和值表示。如果对于给定主机没有变量，则期望一个空的哈希。 '
- en: Simple inventory plugin
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的库存插件
- en: 'To demonstrate developing an inventory plugin, we''ll create one that simply
    prints some static inventory host data – it won''t be dynamic, but this is a great
    first step to understanding the basics and the output formats required. This is
    based on some of the inventories we have used throughout this book, so they may
    seem familiar in parts. We''ll write our inventory plugin to a file in the top
    level of our project root named `mastery-inventory.py` and make it executable.
    We''ll use Python for this file, to handle execution arguments and JSON formatting
    with ease, but remember that you can write inventory scripts in any language that
    you please, so long as they produce the required JSON output:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示开发清单插件，我们将创建一个简单打印一些静态清单主机数据的插件 - 它不会是动态的，但这是理解基础知识和所需输出格式的一个很好的第一步。这是基于我们在整本书中使用过的一些清单，所以它们在某些部分可能看起来很熟悉。我们将把我们的清单插件写入项目根目录中名为`mastery-inventory.py`的文件，并使其可执行。我们将使用Python编写此文件，以便轻松处理执行参数和JSON格式化，但请记住，您可以使用任何您喜欢的语言编写清单脚本，只要它们产生所需的JSON输出：
- en: 'First, we''ll need to add a shebang line to indicate that this script is to
    be executed with Python:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要添加一个shebang行来指示此脚本将使用Python执行：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we''ll need to import a couple of Python modules that we will need later
    in our plugin:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要导入一些稍后在插件中需要的Python模块：
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we''ll create a Python dictionary to hold all of our groups. Some of our
    groups just have hosts while others have variables or children. We''ll format
    each group accordingly:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个Python字典来保存我们所有的组。我们的一些组只有主机，而其他组有变量或子组。我们将相应地格式化每个组：
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To create our `failtest` group (you'll see this in action in the next chapter),
    which in our inventory file will be represented as `failer[01:10]`, we can use
    a Python list comprehension to produce the list for us, formatting the items in
    the list just the same as our `ini`-formatted inventory file. Every other group
    entry should be self-explanatory.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的`failtest`组（您将在下一章中看到此操作），在我们的清单文件中将表示为`failer[01:10]`，我们可以使用Python列表推导来为我们生成列表，格式化列表中的项目与我们的`ini`格式的清单文件完全相同。其他组条目应该是不言自明的。
- en: 'Our original inventory also had an `all` group variable, which provided a default
    variable, `ansible_ssh_user`, to all groups (which groups could override), which
    we''ll define here and make use of later in the file:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的原始清单还有一个`all`组变量，它为所有组提供了一个默认变量`ansible_ssh_user`（组可以覆盖），我们将在这里定义并在文件后面使用：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we need to enter the host-specific variables in their own dictionary.
    Only one node in our original inventory had host-specific variables – we''ll also
    add a new host, `scsihost`, to develop our example further:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在它们自己的字典中输入特定于主机的变量。我们原始清单中只有一个节点具有特定于主机的变量 - 我们还将添加一个新主机`scsihost`，以进一步开发我们的示例：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With all our data defined, we can now move on to the code that will handle
    argument parsing. This can be done via the `argparse` module we imported earlier
    in the file:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了所有数据后，我们现在可以继续处理参数解析的代码。这可以通过我们在文件中导入的`argparse`模块来完成：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After parsing the arguments, we can deal with either the `--list` or `--host`
    actions. If a list is requested, we simply print a JSON representation of our
    inventory. This is where we''ll take the `allgroupvars` data into account; the
    default `ansible_ssh_user` for each group. We''ll loop through each group, create
    a copy of the `allgroupvars` data, update that data with any data that may already
    exist in the group, then replace the group''s variable data with the newly updated
    copy. Finally, we''ll print out the result:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析参数后，我们可以处理`--list`或`--host`操作。如果请求列表，我们只需打印我们清单的JSON表示。这是我们将考虑`allgroupvars`数据的地方；每个组的默认`ansible_ssh_user`。我们将循环遍历每个组，创建`allgroupvars`数据的副本，更新该数据以及可能已经存在于组中的任何数据，然后用新更新的副本替换组的变量数据。最后，我们将打印结果：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we''ll handle the `--host` action by building up a dictionary of all
    the variables that can be applied to the host that is passed to this script. We''ll
    do this using an approximation of the precedence order that''s used in Ansible
    when parsing an `ini` format inventory. This code is iterative, and the nested
    loops would not be efficient in a production environment, but for this example,
    it serves us well. The output is the JSON formatted variable data for the provided
    host, or an empty hash if there is no host-specific variable data for the provided
    host:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将通过构建一个字典来处理`--host`操作，该字典包含可以应用于传递给此脚本的主机的所有变量。我们将使用Ansible在解析`ini`格式清单时使用的优先顺序的近似值来执行此操作。这段代码是迭代的，嵌套循环在生产环境中效率不高，但在这个例子中，它对我们很有用。输出是提供的主机的JSON格式的变量数据，如果提供的主机没有特定的变量数据，则为空哈希：
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, our inventory is ready to be tested! We can execute it directly and pass
    the `--help` argument we get for free using `argparse`. This will show us the
    usage of our script based on the `argparse` data we provided earlier in the file:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的清单已经准备好测试了！我们可以直接执行它，并传递`--help`参数，我们可以免费使用`argparse`获得。这将根据我们之前在文件中提供的`argparse`数据显示我们脚本的用法：
- en: '![Figure 10.10 – Testing the built-in help function of our dynamic inventory
    script'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.10 - 测试我们的动态清单脚本的内置帮助函数'
- en: '](Images/B17462_10_10.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_10.jpg)'
- en: Figure 10.10 – Testing the built-in help function of our dynamic inventory script
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 - 测试我们的动态清单脚本的内置帮助函数
- en: Important Note
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Don't forget to make the dynamic inventory script executable; for example, `chmod
    +x mastery-inventory.py`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记使动态清单脚本可执行；例如，`chmod +x mastery-inventory.py`。
- en: 'If we pass `--list`, we''ll get the output of all our groups, along with all
    the hosts in each group and all the associated inventory variables:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递`--list`，我们将得到所有组的输出，以及每个组中的所有主机和所有相关的清单变量：
- en: '![Figure 10.11 – Displaying the JSON output produced by the --list parameter
    of our dynamic inventory script'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.11 - 显示我们的动态清单脚本的--list参数产生的JSON输出'
- en: '](Images/B17462_10_11.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_11.jpg)'
- en: Figure 10.11 – Displaying the JSON output produced by the --list parameter of
    our dynamic inventory script
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11-显示我们的动态清单脚本的--list参数产生的JSON输出
- en: 'Similarly, if we run this Python script with the `--host` argument and a hostname
    we know is in the inventory, we''ll see the host variables for the hostname that
    was passed. If we pass a group name, nothing should be returned, as the script
    only returns data for valid individual hostnames:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们使用`--host`参数和我们知道在清单中的主机名运行这个Python脚本，我们将看到传递的主机名的主机变量。如果我们传递一个组名，什么都不应该返回，因为脚本只返回有效的单个主机名的数据：
- en: '![Figure 10.12 – Displaying the JSON output produced by the --list parameter
    of our dynamic inventory script'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.12-显示我们的动态清单脚本的--list参数产生的JSON输出'
- en: '](Images/B17462_10_12.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_12.jpg)'
- en: Figure 10.12 – Displaying the JSON output produced by the --list parameter of
    our dynamic inventory script
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12-显示我们的动态清单脚本的--list参数产生的JSON输出
- en: 'Now, we''re ready to use our inventory file with Ansible. Let''s make a new
    playbook (`inventory_test.yaml`) to display the hostname and the `ssh` username
    data:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备使用我们的清单文件与Ansible。让我们制作一个新的playbook（`inventory_test.yaml`）来显示主机名和`ssh`用户名数据：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There is one more thing we have to do before we can use our new inventory plugin.
    By default (and as a security feature), most of Ansible''s inventory plugins are
    disabled. To ensure our dynamic inventory script will run, open the applicable
    `ansible.cfg` file in an editor and look for the `enable_plugins` line in the
    `[inventory]` section. At a minimum, it should look like this (though you may
    choose to enable more plugins if you wish):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用新的清单插件之前，我们还有一件事要做。默认情况下（作为安全功能），大多数Ansible的清单插件都是禁用的。为了确保我们的动态清单脚本能够运行，打开适用的`ansible.cfg`文件编辑器，并在`[inventory]`部分查找`enable_plugins`行。至少，它应该看起来像这样（尽管如果您愿意，您可以选择启用更多插件）：
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To use our new inventory plugin with this playbook, we can simply refer to
    the plugin file with the `-i` argument. Because we are using the `all` hosts group
    in our playbook, we''ll also limit the run to a few groups to save screen space.
    We''ll also time the execution, which will become important in the next section,
    so run the following command to execute the playbook:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的新清单插件与这个playbook，我们可以简单地使用`-i`参数引用插件文件。因为我们在playbook中使用了`all`主机组，我们还将限制运行到一些组以节省屏幕空间。我们还将计时执行，这在下一节中将变得重要，所以运行以下命令来执行playbook：
- en: '[PRE37]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output from this run should look as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这次运行的输出应该如下所示：
- en: '![Figure 10.13 – Running a test playbook against our dynamic inventory script'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.13-运行测试playbook针对我们的动态清单脚本'
- en: '](Images/B17462_10_13.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_13.jpg)'
- en: Figure 10.13 – Running a test playbook against our dynamic inventory script
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13-运行测试playbook针对我们的动态清单脚本
- en: As you can see, we get the hosts we expect, and we get the default `ssh` user
    for `master.example.name`. `backend.example.name` and `scsihost` each show their
    host-specific `ssh` usernames.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们得到了我们期望的主机，我们得到了`master.example.name`的默认`ssh`用户。`backend.example.name`和`scsihost`分别显示了它们特定于主机的`ssh`用户名。
- en: Optimizing script performance
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化脚本性能
- en: 'With this inventory script, when Ansible starts, it will execute the script
    once with `--list` to gather the group data. Then, Ansible will execute the script
    again with `--host <hostname>` for each host it discovered in the first call.
    With our script, this takes very little time as there are very few hosts and our
    execution is very fast. However, in an environment with a large number of hosts
    or a plugin that takes a while to run, gathering the inventory data can be a lengthy
    process. Fortunately, there is an optimization that can be made in the return
    data from a `--list` call that will prevent Ansible from rerunning the script
    for every host. The host-specific data can be returned all at once inside the
    group data return, inside a top-level key named `_meta`, which has a subkey named
    `hostvars` that contains a hash of all the hosts that have host variables and
    the variable data itself. When Ansible encounters a `_meta` key in the `--list`
    return, it''ll skip the `--host` calls and assume that all of the host-specific
    data was already returned, potentially saving a significant amount of time! Let''s
    modify our inventory script to return host variables inside `_meta`, and then
    create an error condition inside the `--host` option to show that `--host` is
    not being called:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个清单脚本，当Ansible启动时，它将使用`--list`一次执行脚本来收集组数据。然后，Ansible将再次使用`--host <hostname>`执行脚本，对于第一次调用中发现的每个主机。使用我们的脚本，这需要很少的时间，因为主机很少，我们的执行非常快。然而，在具有大量主机或需要较长时间运行的插件的环境中，收集清单数据可能是一个耗时的过程。幸运的是，有一个优化可以在`--list`调用的返回数据中进行，这将防止Ansible为每个主机重新运行脚本。主机特定的数据可以一次性返回到组数据返回中，放在名为`_meta`的顶级键内，它有一个名为`hostvars`的子键，其中包含具有主机变量和变量数据本身的所有主机的哈希。当Ansible在`--list`返回中遇到`_meta`键时，它将跳过`--host`调用，并假定所有主机特定的数据已经返回，可能节省大量时间！让我们修改我们的清单脚本，将主机变量返回到`_meta`中，然后在`--host`选项中创建一个错误条件，以显示`--host`没有被调用：
- en: 'First, we''ll add the `_meta` key to the inventory dictionary once all of `hostvars`
    has been built up using the same algorithm as before, and just before argument
    parsing:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，一旦所有的`hostvars`都使用与之前相同的算法构建起来，我们将在清单字典中添加`_meta`键，并在参数解析之前：
- en: '[PRE38]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we''ll change the `--host` handling to raise an exception:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将改变`--host`处理以引发异常：
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, we'll rerun the `inventory_test.yaml` playbook using the same command as
    we did previously to ensure that we're still getting the right data:![Figure 10.14
    – Running our optimized dynamic inventory script
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用与之前相同的命令重新运行`inventory_test.yaml` playbook，以确保我们仍然得到正确的数据：![图10.14-运行我们优化的动态清单脚本
- en: '](Images/B17462_10_14.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_14.jpg)'
- en: Figure 10.14 – Running our optimized dynamic inventory script
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14-运行我们优化的动态清单脚本
- en: 'Just to be sure, we''ll manually run the inventory plugin with the `--host`
    argument to show the exception:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只是为了确保，我们将手动使用`--host`参数运行清单插件，以显示异常：
- en: '![Figure 10.15 – Demonstrating that the --host parameter does not work on our
    newly optimized script'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.15 - 演示--host参数在我们新优化的脚本上不起作用'
- en: '](Images/B17462_10_15.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_15.jpg)'
- en: Figure 10.15 – Demonstrating that the --host parameter does not work on our
    newly optimized script
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 - 演示--host参数在我们新优化的脚本上不起作用
- en: With this optimization, our simple playbook, which is using our inventory module,
    now runs a good few percent faster because of the gained efficiency in inventory
    parsing. This might not seem like much here, but when scaled up to a more complex
    inventory, this would be significant.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种优化，我们的简单playbook，使用我们的清单模块，现在运行速度快了几个百分点，因为清单解析效率提高了。这在这里可能看起来不算什么，但是当扩展到更复杂的清单时，这将是显著的。
- en: Contributing to the Ansible project
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Ansible项目做贡献
- en: Not all modifications need to be for local site requirements. Ansible users
    will often identify an enhancement that could be made to the project that others
    would benefit from. These enhancements can be contributed via a collection, and
    in the new structure of Ansible that proceeds from version 3.0, this is likely
    to be the most suitable route for most people. In this case, you will be able
    to follow the guidance given in [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047),
    *Migrating from Earlier Ansible Versions,* to build and release a collection.
    However, what if you develop the next killer plugin or filter that should be added
    to the `ansible-core` project itself? In this section, we'll look at how you can
    do this. Contributions could be in the form of updates to an existing built-in
    module or core Ansible code, updates to documentation, new filters or plugins,
    or simply testing proposed contributions from other community members.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有修改都需要符合本地站点的要求。Ansible用户通常会发现可以对项目进行增强的地方，从而使其他人受益。这些增强可以通过集合进行贡献，在Ansible
    3.0版本之后的新结构中，这很可能是大多数人最合适的途径。在这种情况下，您可以按照[*第2章*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047)中给出的指导，*从早期的Ansible版本迁移*，构建和发布一个集合。但是，如果您开发了下一个杀手级插件或过滤器，应该将其添加到`ansible-core`项目本身呢？在本节中，我们将看看您可以如何做到这一点。贡献可以是对现有内置模块或核心Ansible代码的更新，对文档的更新，新的过滤器或插件，或者仅仅是测试其他社区成员提出的贡献。
- en: Contribution submissions
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 贡献提交
- en: 'The Ansible project uses GitHub ([https://github.com](https://github.com))
    to manage code repositories, issues, and other aspects of the project. The Ansible
    organization ([https://github.com/ansible](https://github.com/ansible)) is where
    the code repositories can be found. The main repository is the `ansible` repository
    (which now houses the `ansible-core` code) and for legacy reasons, it is located
    here: [https://github.com/ansible/ansible](https://github.com/ansible/ansible).
    This is where the `ansible-core` code, the built-in modules, and the documentation
    can be found. This is the repository that should be forked to develop a contribution.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible项目使用GitHub ([https://github.com](https://github.com))来管理代码存储库、问题和项目的其他方面。Ansible组织([https://github.com/ansible](https://github.com/ansible))是代码存储库的所在地。主要存储库是`ansible`存储库（现在包含`ansible-core`代码），出于传统原因，它位于这里：[https://github.com/ansible/ansible](https://github.com/ansible/ansible)。这是`ansible-core`代码、内置模块和文档的所在地。这是应该分叉以开发贡献的存储库。
- en: Important Note
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The Ansible project uses a development branch named `devel` instead of the traditional
    name of `master`. Most contributions target the `devel` branch or a stable release
    branch.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible项目使用名为`devel`的开发分支，而不是传统的`master`名称。大多数贡献都针对`devel`分支或稳定发布分支。
- en: The Ansible repository
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ansible存储库
- en: The Ansible repository has several files and folders at its root. These files
    are mostly high-level documentation files, code licenses, or continuous integration
    test platform configurations.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible存储库的根目录下有几个文件和文件夹。这些文件主要是高级文档文件、代码许可证或持续集成测试平台配置。
- en: 'Of the directories, a few are worth noting:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些目录值得注意：
- en: '`bin`: Source for the various ansible core executables'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin`：各种ansible核心可执行文件的源代码'
- en: '`docs`: Source for the API documentation, the [https://docs.ansible.com](https://docs.ansible.com)
    website, and the main pages'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docs`：API文档、[https://docs.ansible.com](https://docs.ansible.com)网站和主要页面的源代码'
- en: '`hacking`: Guides and utilities for hacking on the Ansible source'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hacking`：用于在Ansible源上进行黑客攻击的指南和实用程序'
- en: '`lib/ansible`: The core Ansible source code'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib/ansible`：核心Ansible源代码'
- en: '`test`: Unit and integration testing code'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`：单元测试和集成测试代码'
- en: Contributions to Ansible will likely occur in one of those key folders.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对Ansible的贡献可能会出现在这些关键文件夹中的一个。
- en: Executing tests
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行测试
- en: 'Before any submission can be accepted by Ansible, the change must pass tests.
    These tests fall into three categories: unit tests, integration tests, and code-style
    tests. Unit tests cover very narrow aspects of source code functions, while integration
    tests take a more holistic approach and ensure the desired functionality happens.
    Code-style tests examine the syntax used, as well as whitespace and other style
    aspects.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible接受任何提交之前，更改必须通过测试。这些测试分为三类：单元测试、集成测试和代码风格测试。单元测试涵盖源代码功能的非常狭窄的方面，而集成测试则采用更全面的方法，确保所需的功能发生。代码风格测试检查使用的语法，以及空格和其他风格方面。
- en: 'Before any tests can be executed, the shell environment must be prepared to
    work with the Ansible code checkout. A shell environment file exists to set the
    required variables, which can be activated with this command:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任何测试之前，必须准备好与Ansible代码检出一起工作的shell环境。存在一个shell环境文件来设置所需的变量，可以使用以下命令激活：
- en: '[PRE40]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Ensuring tests are passing before modifications are made can save a lot of debugging
    time later, as the `devel` branch is bleeding edge and there are possibilities
    that code that has been committed to this branch does not pass all tests.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在进行修改之前通过测试可以节省大量的调试时间，因为`devel`分支是最前沿的，有可能已提交到该分支的代码未能通过所有测试。
- en: Unit tests
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元测试
- en: All of the unit tests are located within the directory tree starting at `test/units`.
    These tests should all be self-contained and do not require access to external
    resources. Running the tests is as simple as executing `make tests` from the root
    of the Ansible source checkout. This will test much of the code base, including
    the module code.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 所有单元测试都位于从`test/units`开始的目录树中。这些测试应该都是自包含的，不需要访问外部资源。运行测试就像从Ansible源代码检出的根目录执行`make
    tests`一样简单。这将测试大部分代码库，包括模块代码。
- en: Important Note
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Executing the tests may require installing additional software. When using a
    Python virtualenv to manage Python software installations, it's best to create
    a new `venv` to use for testing Ansible – one that does not have Ansible installed
    in it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 执行测试可能需要安装其他软件。在使用Python虚拟环境管理Python软件安装时，最好创建一个新的`venv`用于测试Ansible-一个没有安装Ansible的`venv`。
- en: 'To target a specific set of tests to run, the `pytest` (sometimes accessed
    as `py.test`) utility can be called directly, with a path provided to a directory
    or a specific file to test. On Ubuntu Server 20.04, you can install this tool
    with the following command:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行特定的一组测试，可以直接调用`pytest`（有时作为`py.test`访问），并提供要测试的目录或特定文件的路径。在Ubuntu Server
    20.04上，您可以使用以下命令安装此工具：
- en: '[PRE41]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Assuming you have checked out the `ansible-core` repository code, you could
    run just the `parsing` unit tests with the following commands. Note that some
    of the tests require that you install additional Python modules and that Ansible
    runs under Python 3 now by default, so you should always ensure you are installing
    and working with Python 3-based modules and tools. The following commands may
    not be sufficient for running all tests, but they are sufficient for running the
    parsing tests and give you an idea of the kinds of things you need to do to prepare
    for running the included test suite:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经检出了`ansible-core`存储库代码，您可以使用以下命令仅运行`parsing`单元测试。请注意，其中一些测试需要您安装额外的Python模块，并且Ansible现在默认在Python
    3下运行，因此您应始终确保安装和使用基于Python 3的模块和工具。以下命令可能不足以运行所有测试，但足以运行解析测试，并让您了解为准备运行包含的测试套件需要做的事情的类型：
- en: '[PRE42]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output should look as follows if all goes well, with any warnings and/or
    errors displayed, along with a summary at the end:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，输出应如下所示，并显示任何警告和/或错误，以及最后的摘要：
- en: '![Figure 10.16 – Using the pytest tool for Python 3 to run the parsing unit
    tests included with the ansible-core source code'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.16 - 使用Python 3的pytest工具运行ansible-core源代码中包含的解析单元测试'
- en: '](Images/B17462_10_16.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_16.jpg)'
- en: Figure 10.16 – Using the pytest tool for Python 3 to run the parsing unit tests
    included with the ansible-core source code
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 - 使用Python 3的pytest工具运行ansible-core源代码中包含的解析单元测试
- en: As you can see, the `pytest-3` utility is running through the defined unit tests
    and will report any errors it finds, aiding you greatly in checking any code you
    might be planning to submit. Everything seems to be going well in the preceding
    screenshot!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`pytest-3`实用程序正在运行定义的单元测试，并将报告它发现的任何错误，这将极大地帮助您检查您可能计划提交的任何代码。在前面的截图中一切似乎都很顺利！
- en: Integration tests
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'Ansible integration tests are tests designed to validate playbook functionality.
    Testing is executed by playbooks as well, making things a bit recursive. The tests
    are broken down into a few main categories:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible集成测试是旨在验证playbook功能的测试。测试也是由playbooks执行的，这使得事情有点递归。测试被分为几个主要类别：
- en: Non-destructive
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非破坏性
- en: Destructive
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破坏性
- en: Legacy Cloud
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遗留云
- en: Windows
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows
- en: Network
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: 'A more detailed explanation of these test categories can be found here: [https://docs.ansible.com/ansible/latest/dev_guide/testing_integration.html](https://docs.ansible.com/ansible/latest/dev_guide/testing_integration.html).'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试类别的更详细解释可以在这里找到：[https://docs.ansible.com/ansible/latest/dev_guide/testing_integration.html](https://docs.ansible.com/ansible/latest/dev_guide/testing_integration.html)。
- en: Important Note
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Many of the integration tests require `ssh` to localhost to be functional. Be
    sure that `ssh` works, ideally without a password prompt. Remote hosts can be
    used by altering the inventory file included with specific integration tests that
    require them. For example, if you are running the `connection_ssh` integration
    tests, be sure to look in `test/integration/targets/connection_ssh/test_connection.inventory`
    and update it as required. It is left as an exercise for you to explore this directory
    tree and locate the appropriate inventory files that you might need to update.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 许多集成测试需要`ssh`到localhost是可用的。请确保`ssh`正常工作，最好不需要密码提示。远程主机可以通过更改特定集成测试所需的清单文件来使用。例如，如果要运行`connection_ssh`集成测试，请确保查看`test/integration/targets/connection_ssh/test_connection.inventory`并根据需要进行更新。您可以自行探索此目录树，并找到可能需要更新的适当清单文件。
- en: 'As with unit tests, individual integration tests can be executed by using the
    `ansible-test` utility located at `bin/ansible-test`. Many of the integration
    tests require external resources, such as computer cloud accounts, and again,
    you will need to explore the documentation and directory tree to establish what
    you need to configure to run these tests in your environment. Each directory in
    `test/integration/targets` is a target that can be tested individually. Let''s
    choose a simple example for testing ping functionality with the `ping` target.
    This can be done with the following commands:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 与单元测试一样，可以使用位于`bin/ansible-test`的`ansible-test`实用程序来执行单个集成测试。许多集成测试需要外部资源，例如计算机云帐户，再次，您需要探索文档和目录树，以确定您需要配置什么来在您的环境中运行这些测试。`test/integration/targets`中的每个目录都是可以单独测试的目标。让我们选择一个简单的示例来测试`ping`目标的ping功能。可以使用以下命令完成：
- en: '[PRE43]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that we have specifically set the Python environment to test against here.
    This is important as my Ubuntu Server 20.04 test machine has some Python 2.7 installed
    and Ansible has been installed and configured to use Python 3.8 (which is also
    present). If the `ansible-test` tool makes use of the Python 2.7 environment,
    it might find that modules are missing and the tests will fail, but not because
    of anything that's wrong with our code – rather because we have failed to set
    the environment up correctly.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经专门设置了要针对的Python环境。这很重要，因为我的Ubuntu Server 20.04测试机安装了一些Python 2.7，并且已经安装和配置了使用Python
    3.8的Ansible（也已经存在）。如果`ansible-test`工具使用Python 2.7环境，它可能会发现缺少模块，测试将失败，但这并不是因为我们的代码有错
    - 而是因为我们没有正确设置环境。
- en: When you run `ansible-test`, ensure you know which Python environment you are
    using and set it accordingly in the command. If you want to test against another
    Python version, you will need to ensure that all the prerequisite Python modules
    that Ansible depends upon (such as Jinja2) are installed under that Python environment.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行`ansible-test`时，请确保知道您正在使用的Python环境，并相应地在命令中设置它。如果要针对另一个Python版本进行测试，您需要确保Ansible依赖的所有先决Python模块（如Jinja2）都安装在该Python环境下。
- en: 'A successful test run should look as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的测试运行应该如下所示：
- en: '![Figure 10.17 – Running the Ansible ping integration test against a Python
    3.8 environment'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.17 - 对Python 3.8环境运行Ansible ping集成测试'
- en: '](Images/B17462_10_17.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_17.jpg)'
- en: Figure 10.17 – Running the Ansible ping integration test against a Python 3.8
    environment
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 - 对Python 3.8环境运行Ansible ping集成测试
- en: 'Note that there is even a test in this suite that''s designed to fail – and
    that, in the end, we will see `ok=7` and `failed=0`, meaning all the tests passed.
    A large set of POSIX-compatible non-destructive integration tests run by continuous
    integration systems on proposed changes to Ansible can be executed with the following
    command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，甚至在这个测试套件中设计了一个旨在失败的测试 - 最终，我们将看到`ok=7`和`failed=0`，意味着所有测试都通过了。可以通过以下命令执行一组大型的与POSIX兼容的非破坏性集成测试，这些测试由持续集成系统在对Ansible的建议更改上运行：
- en: '[PRE44]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Important Note
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To ensure a consistent and stable testing environment, these tests are run in
    a local Fedora 32 container. You will need to ensure that Docker is set up and
    accessible on your test host for this command to work.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保一致和稳定的测试环境，这些测试在本地Fedora 32容器中运行。您需要确保Docker在您的测试主机上设置并可访问，以使此命令生效。
- en: Code-style tests
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码风格测试
- en: 'The third category of Ansible tests is the code-style category. These tests
    examine the syntax used in the Python files, ensuring a cohesive look across the
    code base. The code style that''s enforced is defined by PEP8, a style guide for
    Python. More information is available here: [https://docs.ansible.com/ansible/latest/dev_guide/testing/sanity/pep8.html](https://docs.ansible.com/ansible/latest/dev_guide/testing/sanity/pep8.html).
    This style is enforced via the `pep8` sanity test target. For this test to run,
    you must have installed the `pycodestyle` module for Python 3\. So, your commands
    from the root of your Ansible source directory might be as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible测试的第三类是代码风格类别。这些测试检查Python文件中使用的语法，确保代码库中的外观统一。强制执行的代码风格由PEP8定义，这是Python的风格指南。更多信息请参见：[https://docs.ansible.com/ansible/latest/dev_guide/testing/sanity/pep8.html](https://docs.ansible.com/ansible/latest/dev_guide/testing/sanity/pep8.html)。这种风格是通过`pep8`健全性测试目标来强制执行的。要运行此测试，您必须为Python
    3安装了`pycodestyle`模块。因此，您的命令可能如下所示：从您的Ansible源目录的根目录开始。
- en: '[PRE45]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If there are no errors, this target does not output any text; however, the
    return code can be verified. An exit code of `0` means there were no errors, as
    shown in the following screenshot:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，此目标不会输出任何文本；但是可以验证返回代码。退出代码为`0`表示没有错误，如下截图所示：
- en: '![Figure 10.18 – A successful run of the pep8 Python code style test'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.18 - 成功运行的pep8 Python代码风格测试'
- en: '](Images/B17462_10_18.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_18.jpg)'
- en: Figure 10.18 – A successful run of the pep8 Python code style test
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18 - 成功运行的pep8 Python代码风格测试
- en: Important Note
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As you have seen already, additional Python modules might be required to run
    any of the Ansible tests – the method for installing them will vary from system
    to system, and the modules required will vary from test to test. These could typically
    be installed by using the `pip3` tool or local operating system packages, as we
    have done here.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经看到的，运行任何Ansible测试可能需要额外的Python模块 - 安装它们的方法会因系统而异，所需的模块也会因测试而异。这些通常可以通过使用`pip3`工具或本地操作系统包来安装，就像我们在这里所做的那样。
- en: 'If a Python file does have a `pep8` violation, the output will reflect the
    violation – for example, we''ll deliberately edit the code for the `ansible.builtin.file`
    module, which can be found in `lib/ansible/modules/file.py` under the source code
    root. We''ll introduce several deliberate errors such as blank lines with whitespace,
    and we''ll replace some of the all-important indentation spaces with tabs, then
    rerun the test just as we did previously. We won''t need to reinstall the Python
    module or set up the environment again; the output of this test will show us exactly
    where the errors exist, as shown in the following screenshot:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Python文件确实存在`pep8`违规，输出将反映违规 - 例如，我们将故意编辑`ansible.builtin.file`模块的代码，该模块可以在源代码根目录下的`lib/ansible/modules/file.py`中找到。我们将故意引入一些错误，比如带有空格的空行，并将一些至关重要的缩进空格替换为制表符，然后像之前一样重新运行测试。我们不需要重新安装Python模块或重新设置环境；此测试的输出将准确显示错误的位置，如下截图所示：
- en: '![Figure 10.19 – Rerunning the pep8 sanity test with deliberate coding style
    errors introduced to the file module'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.19 - 重新运行带有故意引入文件模块的编码风格错误的pep8健全性测试'
- en: '](Images/B17462_10_19.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/B17462_10_19.jpg)'
- en: Figure 10.19 – Rerunning the pep8 sanity test with deliberate coding style errors
    introduced to the file module
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19 - 重新运行带有故意引入文件模块的pep8健全性测试
- en: '`pep8` errors will indicate an error code, which can be looked up for detailed
    explanations and guidance, along with a location and a filename, and even a line
    and column number to help you rapidly locate and rectify the issue.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`pep8`错误将指示一个错误代码，可以查找详细的解释和指导，以及位置和文件名，甚至行号和列号，以帮助您快速定位和纠正问题。'
- en: Making a pull request
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发起拉取请求
- en: Once all the tests have passed, a submission can be made. The Ansible project
    uses GitHub pull requests to manage submissions. To create a pull request, your
    changes must be committed and pushed to GitHub. Developers use a fork of the Ansible
    repository under their account to push proposed changes.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有测试都通过了，就可以提交。Ansible项目使用GitHub拉取请求来管理提交。要创建拉取请求，您的更改必须提交并推送到GitHub。开发者使用他们账户下的Ansible存储库的分支来推送建议的更改。
- en: Once pushed, a pull request can be opened using the GitHub website. This will
    create the pull request, which will start continuous integration tests and notify
    reviewers of a new submission. Further information about GitHub pull requests
    can be found at [https://docs.github.com/en/github/collaborating-with-pull-requests](https://docs.github.com/en/github/collaborating-with-pull-requests).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦推送，可以使用GitHub网站打开拉取请求。这将创建拉取请求，开始持续集成测试，并通知审阅者有一个新的提交。有关GitHub拉取请求的更多信息，请访问[https://docs.github.com/en/github/collaborating-with-pull-requests](https://docs.github.com/en/github/collaborating-with-pull-requests)。
- en: 'Once the pull request is open, reviewers will comment on the pull request,
    either asking for more information, suggesting changes, or approving the change.
    For new module submissions, you are encouraged to go down the collections route,
    but if you wish to explore this further, there is a great deal of valuable information
    available to would-be developers here: [https://docs.ansible.com/ansible/latest/dev_guide/index.html](https://docs.ansible.com/ansible/latest/dev_guide/index.html).'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦拉取请求打开，审阅者将对拉取请求进行评论，要么要求更多信息，要么建议更改，要么批准更改。对于新的模块提交，建议您使用集合路线，但如果您希望进一步探索，这里有大量有价值的信息可供开发者使用：[https://docs.ansible.com/ansible/latest/dev_guide/index.html](https://docs.ansible.com/ansible/latest/dev_guide/index.html)。
- en: Submissions that are found acceptable and merged will be made generally available
    in the next release of Ansible. That concludes our look at contributing code back
    to the Ansible project and this chapter on extending Ansible. Hopefully, this
    chapter has given you some ideas and inspiration on how to build on the excellent
    foundation that Ansible provides to solve your automation challenges.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 经过接受的提交将在下一个Ansible版本中普遍可用。这结束了我们对向Ansible项目贡献代码和对Ansible进行扩展的章节的讨论。希望本章能给您一些想法和灵感，让您能够在Ansible提供的优秀基础上解决自动化挑战。
- en: Summary
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Ansible is a great tool; however, sometimes, it doesn't offer all the functionality
    you might desire. Not every bit of functionality is appropriate to submit to the
    `ansible-core` project, nor is it possible to provide bespoke integration with
    custom proprietary data sources, as these would be different in every case. As
    a result, there are many facilities within Ansible to extend its functionality.
    Creating and using custom modules is made easy by the shared module base code.
    Many different types of plugins can be created and used with Ansible to affect
    operations in a variety of ways. Inventory sources beyond those provided with
    the Ansible release collections can still be used with relative ease and efficiency.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个很好的工具；然而，有时它并不能提供您所需的所有功能。并非所有功能都适合提交到`ansible-core`项目，也不可能为自定义专有数据源提供定制集成，因为每种情况都不同。因此，Ansible内部有许多设施来扩展其功能。通过共享的模块基础代码，创建和使用自定义模块变得非常容易。可以创建许多不同类型的插件，并与Ansible一起使用，以各种方式影响操作。除了Ansible发布集合提供的清单源之外，仍然可以相对轻松和高效地使用其他清单源。
- en: In this chapter, you learned about developing modules and including them in
    your playbooks. You then learned about extending Ansible through plugins, and
    we went into specific details about creating dynamic inventory plugins. Finally,
    you learned how to contribute code back to the Ansible project to enhance the
    code for everyone in the community. In summary, you learned that, in all cases,
    there are mechanisms to provide modules, plugins, and inventory sources alongside
    the playbooks and roles that depend on the enhanced functionality, making it seamless
    to distribute. This enables an almost infinite amount of expansion or customization
    of Ansible to your requirements, and the ability to easily contribute to the wider
    community if desired.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了开发模块并将其包含在playbooks中。然后，您了解了通过插件扩展Ansible，并详细介绍了创建动态清单插件的具体细节。最后，您学会了如何向Ansible项目贡献代码，以增强整个社区的代码。总之，您学会了，在所有情况下，都有机制可以在playbooks和依赖于增强功能的角色旁边提供模块、插件和清单源，使其无缝分发。这使得几乎可以无限地扩展或定制Ansible以满足您的需求，并且如果需要，可以轻松地为更广泛的社区做出贡献。
- en: In [*Chapter 12*](B17462_12_Final_JC_ePub.xhtml#_idTextAnchor224), *Infrastructure
    Provisioning*, we will explore the use of Ansible in creating the infrastructure
    to be managed.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第12章*](B17462_12_Final_JC_ePub.xhtml#_idTextAnchor224)，*基础设施配置*中，我们将探讨使用Ansible创建要管理的基础设施。
- en: Questions
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: For Ansible releases after 3.0, you would almost always develop a new module
    and distribute it via which of the following?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于3.0之后的Ansible版本，您几乎总是会开发一个新模块，并通过以下哪种方式分发？
- en: a) The `ansible-core` project.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: a) `ansible-core`项目。
- en: b) Your collection.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: b) 您的集合。
- en: c) An existing collection with overlapping functionality, with the project maintainer's
    approval.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: c) 与项目维护者批准的现有集合功能重叠。
- en: d) A role.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: d) 一个角色。
- en: e) b, c, and maybe d only
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: e) 只有b、c，也许d
- en: The easiest way to develop a custom module is to write it in what language?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发自定义模块的最简单方法是用哪种语言编写？
- en: a) Bash
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: a) Bash
- en: b) Perl
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: b) Perl
- en: c) Python
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: c) Python
- en: d) C++
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: d) C++
- en: Providing facts from a custom module does what?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从自定义模块提供事实会做什么？
- en: a) Saves you from needing to register the output to a variable and then using
    `set_fact`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: a) 节省您不需要注册输出到变量，然后使用`set_fact`。
- en: b) Gives your code greater capabilities.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: b) 使您的代码具有更大的能力。
- en: c) Helps you debug your code.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: c) 帮助您调试您的代码。
- en: d) Shows you how the module is running.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: d) 显示模块的运行方式。
- en: Callback plugins allow you to do what?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回调插件允许您做什么？
- en: a) Help you call other playbooks.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: a) 帮助您调用其他playbook。
- en: b) Easily alter the behavior of Ansible at key operational points without having
    to alter the `ansible-core` code.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: b) 在关键操作点轻松改变Ansible的行为，而无需修改`ansible-core`代码。
- en: c) Provide an efficient means of altering the code's state.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: c) 提供一种有效的方式来改变代码的状态。
- en: d) Help you to call back to your playbook during runtime.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: d) 帮助您在运行时回调到您的playbook。
- en: To distribute plugins, where would you place them?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要分发插件，您应该把它们放在哪里？
- en: a) In a specially named directory relevant to their function (for example, callback
    plugins would go in the `callback_plugins/` directory).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: a) 在与它们的功能相关的专门命名的目录中（例如，回调插件将放在`callback_plugins/`目录中）。
- en: b) In the Ansible installation directory.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: b) 在Ansible安装目录中。
- en: c) Under `~/.ansible/plugins`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: c) 在`~/.ansible/plugins`下。
- en: d) It doesn't matter where, provided you specify them in `ansible.cfg`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: d) 无论在哪里，只要您在`ansible.cfg`中指定它们。
- en: Dynamic inventory plugins should be written in what language?
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态清单插件应该用什么语言编写？
- en: a) Python.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: a) Python。
- en: b) Bash.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: b) Bash。
- en: c) C++.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: c) C++。
- en: d) Any language, provided the output is returned in the correct JSON data structure.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: d) 任何语言，只要输出以正确的JSON数据结构返回。
- en: Dynamic inventory plugins should parse which two command-line arguments?
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态清单插件应该解析哪两个命令行参数？
- en: a) `--list` and `--hostname`
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: a) `--list` 和 `--hostname`
- en: b) `--list` and `--host`
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: b) `--list` 和 `--host`
- en: c) `--list-all` and `--hosts`
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: c) `--list-all` 和 `--hosts`
- en: d) `--list` and `--server`
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: d) `--list` 和 `--server`
- en: Dynamic inventory performance can be improved by doing what?
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态清单性能可以通过做什么来提高？
- en: a) Returning all host-specific data under a `_meta` key when the `--list` parameter
    is passed.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: a) 当传递`--list`参数时，在`_meta`键下返回所有特定于主机的数据。
- en: b) Returning all host-specific data, regardless of which arguments are passed.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: b) 返回所有特定于主机的数据，无论传递了哪些参数。
- en: c) Caching the output of the script's run.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: c) 缓存脚本运行的输出。
- en: d) Compressing your output data to reduce transmission times.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: d) 压缩输出数据以减少传输时间。
- en: If you wish to contribute code to the `ansible-core` project, you should submit
    it via which of the following methods?
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您希望向`ansible-core`项目贡献代码，您应该通过以下哪种方法提交它？
- en: a) A ticket raised against the project detailing your changes
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: a) 对项目提出的一张票，详细说明您的更改
- en: b) Submitting a support ticket to Red Hat
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: b) 向Red Hat提交支持票
- en: c) A GitHub pull request once your code is passing all included tests
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: c) 一旦您的代码通过了所有包含的测试，就可以通过GitHub拉取请求提交。
- en: d) Complaining loudly on Twitter
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: d) 在Twitter上大声抱怨
- en: Which utility is used to launch and control most of the Ansible code tests?
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个实用程序用于启动和控制大部分Ansible代码测试？
- en: a) `test-runner`
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: a) `test-runner`
- en: b) `integration-test`
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: b) `integration-test`
- en: c) Jenkins
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: c) Jenkins
- en: d) `ansible-test`
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: d) `ansible-test`
