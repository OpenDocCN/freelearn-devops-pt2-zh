# 持续交付的基础知识

可以说，软件的最重要部分实际上是将其交付并准备供最终用户使用。持续交付（CD）是您将软件产品交付给最终用户的时刻，也是本章的基础。只有当您的预期用户实际上可以使用产品时，产品才有用。在本章中，我们将讨论部署流水线，并结合自动化和 CD 的概念。

本章将涵盖以下主题：

+   交付软件的问题

+   配置管理

+   部署流水线

+   部署脚本

+   部署生态系统

# 技术要求

本章假定您了解自动化和持续集成的概念。如果您对这些主题中的任何一个感到不确定，请先阅读第一章，“自动化测试的 CI/CD”和第二章，“持续集成的基础知识”，然后再阅读本章。

本章的代码文件可以在[`github.com/jbelmont/api-workshop/blob/master/Gopkg.toml`](https://github.com/jbelmont/api-workshop/blob/master/Gopkg.toml)找到。

# 交付软件的问题

在尝试将软件产品交付给最终用户时，可能会出现许多问题，我们将看看影响软件交付的几种情况。一个可能的情况是开发人员正在开发一个新功能，但新功能可能实际上无法通过 CI 构建阶段，或者可能不像产品所有者最初提出的那样运行。另一个可能的情况是，预期的受众没有得到适当的理解，这将影响用户对最终产品的使用。另一个可能的情况是，软件产品没有得到适当的解耦，并且是用泡泡糖和胶带拼凑在一起的，新功能请求会导致许多回归问题。

# 我们所说的交付软件是什么意思？

关于软件交付实际意味着什么可能会有很多争论。在本章中，所指的是实际的软件产品已交付给预期的用户，而不仅仅是软件产品被质量保证（QA）部门批准为有效。

# 常见的发布反模式

存在一些常见的发布反模式，您应该避免，例如手动部署软件，手动配置管理以及每个环境的不同环境配置。

# 手动部署软件

这种类型的反模式很常见，可能会导致软件交付中的瓶颈。软件交付的那一天是充满压力和错误的。运维人员 Tom 的一天是从将软件构件从版本控制系统复制到生产环境开始的。Tom 通过文件传输协议（FTP）复制文件，但忘记添加一个新的配置文件，登录页面不再工作。Tom 不得不与开发团队交谈，询问是否添加了新的配置文件，并等待数小时才得到回复。

一旦 Tom 得到了新的配置文件，他将其上传到生产环境。现在登录页面可以工作了，但一些页面加载时出现了奇怪的图像放置和不规则性。Tom 联系了 UI/UX 团队，发现生产环境中缺少一个 CSS 文件。Tom 上传了 CSS 文件，现在页面可以正确加载了。Tom 询问客户成功团队是否可以进一步测试生产环境中的新更改，最终在晚上 7 点左右结束了一天的工作。

如果存在一份详细描述软件产品交付的长文档，这可能表明存在手动流程。这进一步使产品的交付变得更加复杂，因为在整个过程中的任何错误都可能导致更多问题。如果交付变得不可预测，这也可能指向这种反模式。

# 部署自动化来拯救

正如我们在第一章中讨论的那样，*自动化测试的 CI/CD*，自动化是一个行为以可重复和自动化的方式完成的过程。软件交付应该是一个自动化的过程，因为这将有助于确保软件交付的一致实践和行为。我们将在本章后面看到一些工具，这些工具将帮助您自动化软件交付流程。

# 手动配置管理

这种反模式可能会让运维人员感到沮丧，因为他们将是最后一个了解产品新行为的人。如果软件交付的当天是运维团队第一次看到新功能，那么他们可能会对软件行为感到惊讶。辛迪是运维团队的成员，她被委托交付软件，并注意到安装脚本完全失效，因为它无法与**识别**（ID）服务器通信。辛迪向开发团队发送日志消息，发现 ID 服务器的一个客户端密钥已更改，并且安装脚本需要使用这个新值才能正确连接。

如果辛迪意识到 ID 服务器的这个新变化，这种问题可能会得到缓解，但开发人员正在另一个环境中工作，QA 部门得到了这个信息来测试新功能，但直到交付当天他们才遇到这个问题，没有人想到将这个信息传递给运维部门。

# 配置管理自动化

我们将讨论可以帮助解决配置管理问题的工具，比如之前遇到的问题。使用适当的工具，运维/DevOps 人员可以快速获得每个环境的正确环境配置，包括生产环境。

# 生产环境与其他环境的不同之处

这种反模式可能特别具有挑战性，因为在开发中测试了所有的更改，暂存环境在生产环境中可能表现不稳定。例如，特拉维斯在 QA 部门担任测试员，自新功能推出以来一直在测试暂存环境。比利是一名运维人员，由于暂存环境与生产环境完全不同，他无法看到新功能。比利还注意到生产环境中缺少在暂存环境中显示的关键信息。比利联系开发团队，发现必须运行数据库迁移脚本才能使新功能在生产环境中运行。

# 生产环境应该与暂存环境相同

所有环境，包括测试、暂存和生产环境，都应该有必要的迁移脚本和任何其他软件资产，以防止生产环境的故障，并且开发团队应该确保将操作指向脚本文件的任何更改，或者在共享文档中清楚地标记这些更改。

# 如何进行软件发布

在进行软件发布时，有一些重要的步骤需要考虑，比如频繁发布以避免一次引入太多的更改，并确保发布是自动化的。

# 频繁发布

软件发布必须频繁。大型软件发布往往充斥着问题，因此最好使发布之间的增量（更改）较小。通过增加软件发布的频率，您还可以获得更快的反馈。大型软件发布往往需要更长的时间，关键反馈可能无法及时传达。

# 自动化发布

手动发布存在问题，因为它们不可重复。每次进行手动发布时，由于配置更改、软件更改和环境更改，都会有所不同。手动发布步骤充满错误，因为每个步骤都是手动的，可能导致级联错误。手动更改的危险的一个很好的例子是，当最受欢迎的云提供商亚马逊网络服务（AWS）在美国东部地区遭受重大故障时，因为运维人员在手动流程的一系列步骤中输入了错误的命令。自动化是软件发布的关键，因为它确保了软件交付流程的可重复性和控制。在本章中，我们将进一步探讨部署脚本工具，以帮助自动化软件交付。

# 自动化在交付软件方面的好处

正如我们之前所阐述的，自动化在软件交付中非常重要，因为它确保了软件发布的可重复性、可靠性和可预测性。通过自动化软件交付流程，可以避免或减轻灾难性事件，而不是通过漫长的手动流程。

# 团队赋能

如果自动化已经实施，QA 部门可以安全地选择旧版本的软件发布来测试回归。运维人员可以运行在暂存中使用的脚本，而不会因为环境级别的差异而遇到问题。通过自动化软件流程，运维人员可以在交付过程中出现灾难时安全地回滚发布。此外，正如我们在第二章中所讨论的，自动化可以帮助实现一键式发布。

# 减少错误

自动化可以帮助减少手动流程可能造成的错误。正如我们之前所看到的，配置管理问题可能导致软件交付不佳。手动软件发布无法有效地确保可重复性，因此容易出错。

# 减轻压力

另一个好处是在软件交付期间减少所有人员的压力。手动流程往往会造成不必要的压力，因为执行手动流程的人必须要细心，不能在交付过程中犯任何错误。自动交付流程非常好，因为它确保每次运行都会以相同的方式执行。手动流程中的错误可能需要高级人员的支持来解决问题。

# 配置管理

包含重要信息的配置文件，如客户端密钥和密码，必须得到妥善管理，并且必须在其他环境中保持同步。每个环境可能有不同的环境变量，必须被使用并传递到应用程序中。

# 配置管理到底意味着什么？

配置管理可以简要描述为检索、存储、识别和修改与每个给定项目相关的所有软件工件以及软件工件之间的任何关系的过程。

# 版本控制

版本控制是保持所有软件工件之间修订的手段。版本控制对于配置管理非常重要，因为任何包含环境文件的文件的更改都应该在版本控制下。

托尼是开发团队的一员，他一直在使用一个未纳入源代码控制的属性文件，并且一直在对产品中的单点登录（SSO）流程进行更改。托尼不小心删除了文件，并且丢失了在 SSO 流程中必要的所有客户端 ID 和密钥。现在，托尼必须去不同的 API 门户，并重新生成一些属性的客户端密钥，因为它们在创建时只显示一次，现在他必须通知团队的其他成员更新他们的属性文件。

# 示例属性文件

我已经添加了一个示例属性文件，其中包含客户端秘密信息和身份验证秘密信息。这对于给定的环境正常运行是必要的，但不应该检入源代码控制，这里仅用于演示目的。

```
API_URL=http://localhost:8080
PORT=8080
AUTH_ZERO_CLIENT_ID=fakeClientId
AUTH_ZERO_JWT_TOKEN=someFakeToken.FakedToken.Faked
AUTH_ZERO_URL=https://fake-api.com
REDIS_PORT=redis:6379
SEND_EMAILS=true
SMTP_SERVER=fakeamazoninstance.us-east-1.amazonaws.com
SMTP_USERNAME=fakeUsername
SMTP_PASSWORD=fakePassword
SMTP_PORT=587
TOKEN_SECRET="A fake token secret"
```

`TOKEN_SECRET`环境变量只能看到一次，所以如果丢失了，那么你必须在 API 门户中重新生成它。

# 版本控制管理工具

这是一个版本控制管理工具的列表：

+   **Git** ([`git-scm.com/`](https://git-scm.com/)): Git 是一个分布式版本控制系统

+   **Mercurial** ([`www.mercurial-scm.org/`](https://www.mercurial-scm.org/)): Mercurial 也是一个分布式版本控制系统

+   **Subversion** ([`subversion.apache.org/`](https://subversion.apache.org/)): Subversion 被认为是一个集中式版本控制系统

+   **Fossil** ([`www.fossil-scm.org/`](https://www.fossil-scm.org/)): Fossil 是一个分布式版本控制系统，类似于 Git，尽管知名度较低

# 版本控制实践

一个重要的做法是尽可能将所有东西都放在版本控制下，以避免在软件产品中丢失重要工作。网络文件、配置文件、部署脚本、数据库脚本、构建脚本以及任何其他对应用程序正常运行很重要的工件都应该在版本控制下，否则你会冒着丢失关键数据的风险。

# 经常进行软件检查

经常检查主分支非常重要，否则你会冒着在代码库中引入破坏性更改的风险。此外，频繁的检查可以帮助开发人员随时注意带入小的更改。应避免对代码库进行大规模的更改，因为这样更难测试并且可能会引起回归。频繁的检查也是有益的，因为破坏性更改会更快地被注意到。

# 编写描述性和有意义的提交消息

使用包括问题跟踪信息的描述性提交消息，比如 Jira 问题，清楚地描述提交的意图。避免编写模糊的提交消息，比如`修复错误`或`完成`，因为这些类型的提交消息是没有用的，对开发人员以后也没有帮助。

这是一个示例描述性提交消息[DEV-1003]，添加了一个新的导航链接到零部件供应列表。还添加了一个新导航的测试用例。这显然更加描述性。此外，在 Jira 中，当你提供一个像 DEV-1003 这样的问题时，它会在 Jira 问题中创建一个引用此问题的链接。此外，如果你创建一个拉取请求并在`git commit`中放入 Jira 问题，它将把你的拉取请求与问题链接起来。

# 依赖管理

应用程序通常具有对软件产品至关重要的第三方依赖项。依赖管理是任何应用程序的重要部分，不同的编程语言以不同的方式处理依赖管理。

# 示例 Node.js 依赖文件和 Gopkg.toml 依赖文件

这是一个`Gopkg.toml`文件，其中包含存储库中每个依赖项的版本和包信息。

```
# Gopkg.toml example
#
# Refer to https://github.com/golang/dep/blob/master/docs/Gopkg.toml.md
# for detailed Gopkg.toml documentation.
#
# required = ["github.com/user/thing/cmd/thing"]
# ignored = ["github.com/user/project/pkgX", "bitbucket.org/user/project/pkgA/pkgY"]
#
# [[constraint]]
#   name = "github.com/user/project"
#   version = "1.0.0"
#
# [[constraint]]
#   name = "github.com/user/project2"
#   branch = "dev"
#   source = "github.com/myfork/project2"
#
# [[override]]
#   name = "github.com/x/y"
#   version = "2.4.0"
#
# [prune]
#   non-go = false
#   go-tests = true
#   unused-packages = true

[prune]
  go-tests = true
  unused-packages = true

[[constraint]]
  branch = "v2"
  name = "gopkg.in/mgo.v2"

[[constraint]]
  name = "github.com/dgrijalva/jwt-go"
  version = "3.1.0"

[[constraint]]
  name = "github.com/go-playground/locales"
  version = "0.11.2"

[[constraint]]
  name = "github.com/pkg/errors"
  version = "0.8.0"

[[constraint]]
  name = "github.com/pborman/uuid"
  version = "1.1.0"

[[constraint]]
  name = "gopkg.in/go-playground/validator.v9"
  version = "9.9.3"
```

像这样管理依赖是很重要的，因为第三方依赖项很容易给应用程序带来破坏性更改，第三方依赖项中的 API 更改可能会破坏任何正在运行的应用程序中的关键行为。

# 管理软件组件

通常，软件项目将以单片构建开始，所有工作组件都在一个层中。随着应用程序的规模和成熟度的增长，应用程序的层将分解为服务或不同的层，这就是需要单独的构建流水线的地方。也许一个 ID 服务用于应用程序中的身份验证，也许一个管理服务在单独的构建流水线中运行用于管理门户。微服务架构是应用程序的服务级组件化的延续，其中每个微服务在应用程序中有一个清晰而专注的目的。

# 软件配置管理

配置是任何应用程序的重要部分，应该像您在代码中使用的业务逻辑一样小心对待。因此，配置需要像源代码一样得到适当的管理和测试。

# 可配置性和灵活性概念

乍一想，似乎将配置尽可能灵活是合适的。*为什么不尽可能地使系统灵活，并允许它适应任何类型的环境呢？*这通常被称为*终极可配置性*的反模式，意味着配置可以像编程语言一样行为，并且可以被制作成任何方式。以这种方式进行的配置管理可能会使软件项目陷入困境，因为其用户将期望这种灵活性是必要的。为您的配置管理设置一些约束更有用。约束可以帮助控制配置环境中过度灵活性的影响。

# 特定类型的配置

以下是应用程序可以利用的可能类型的配置列表：

+   配置可以在**构建时间**中被拉取并合并到应用程序二进制文件中：

+   像 C/C++和 Rust 这样的语言可以进行构建时配置

+   在创建组件或 gems 时，配置可以在**打包时间**注入：

+   像 C#、Java 和 Ruby 这样的语言可以使用这样的配置选项

+   配置可以在**部署时间**进行，意味着部署脚本或安装程序可以根据需要获取任何必要的信息，或者部署脚本可以要求用户传递这样的信息：

+   我们将在本书的后面使用 Jenkins、Travis 和 CircleCI 工具进行讨论

+   配置可以在**启动时间或** **运行时**进行，意味着应用程序启动时：

+   像 Node.js 这样的语言在 Node.js 服务器运行时通常会注入环境变量

# 跨应用程序的配置管理

当您跨不同应用程序进行配置时，配置管理变得更加复杂。有一些工具可以帮助跨应用程序边界进行配置，以下是这样的工具列表：

+   CFEngine ([`cfengine.com/`](https://cfengine.com/))

+   Puppet ([`puppet.com/`](https://puppet.com/))

+   Chef ([`www.chef.io/chef/`](https://www.chef.io/chef/))

+   Ansible ([`www.ansible.com/`](https://www.ansible.com/))

+   Docker with Kubernetes ([`www.docker.com/`](https://www.docker.com/))

# 环境管理

应用程序依赖的硬件、软件、基础设施和任何外部系统可以被视为应用程序的环境。任何环境的创建都应该以完全自动化的方式进行，因为能够复制环境是重要的，我们将会说明。

# 手动环境设置

手动设置基础设施可能会出现几个问题：

+   手动设置的服务器实例可能被配置以适应单个运维人员。这个运维人员可能已经离开组织，导致核心基础设施破损。

+   修复手动设置的环境可能需要很长时间，而在这样的环境中解决问题是不可重现和可重复的。

+   手动设置的环境可能无法复制以进行测试。

# 环境的重要配置信息

以下是所有环境都需要的重要配置信息列表：

+   需要在每个环境上安装的第三方依赖和软件包

+   网络拓扑信息

+   应用程序运行所需的外部服务，如数据库服务

+   应用程序数据或种子数据，以便设置和运行新环境

# 容器化环境

像 Docker 和 Kubernetes 这样的工具因其隔离环境级别信息和创建可重现/可重复环境的能力而变得越来越受欢迎。使用 Docker，您可以声明所有外部服务，如 Redis 和 MongoDB。

这是 API 研讨会存储库（[`github.com/jbelmont/api-workshop`](https://github.com/jbelmont/api-workshop)）的`docker-compose` YML 脚本示例：

```
version: '3'
services:
  mongo:
    image: mongo:3.4.5
    command: --smallfiles --quiet --logpath=/dev/null --dbpath=/data/db
    ports:
      - "27017:27017"
    volumes:
      - data:/data/db
  redis:
    image: redis:3.2-alpine
    ports:
      - "6379:6379"
 apid:
    build:
      context: .
      dockerfile: Dockerfile-go
    depends_on:
      - mongo
      - redis
    env_file:
      - ./common.env
    links:
      - mongo
      - redis
    ports:
      - "8080:8080"
volumes:
    data:
```

我们已经声明了一个数据库，以及一个缓存服务（Redis）和一个 API，它们都作为独立的容器运行，所有这些都可以具有环境级别的信息，比如环境变量，可以单独配置。

# 部署管道

我们在第二章中谈到了 CI 的重要性，*持续集成的基础知识*，虽然 CI 是一个重要的生产力增强器，但它主要对开发团队有用。在等待修复或更新文档时，软件生命周期中常见的瓶颈是 QA 和运维团队。QA 可能需要等待开发团队的良好构建。开发团队可能在完成新功能后的几周内收到错误报告。所有这些情况都会导致无法部署的软件，最终导致无法交付给最终用户的软件。创建可以部署到测试、分级和生产环境的一键式部署构建可以帮助缓解这些问题，正如我们之前所指出的。

# 部署管道是什么？

部署管道可以被认为是构建、部署、测试和发布过程的端到端自动化。部署管道也可以被认为是将开发人员编写的软件交到用户手中的过程。

# 部署管道实践

在本节中，我们将讨论一些部署管道实践，比如只编译一次二进制文件，以相同的方式处理每个环境中的部署，并在部署管道中设置提交阶段。

# 只编译一次二进制文件

多次编译的二进制文件可能会出现问题，原因有几个：

+   二进制文件在每次运行时可能具有不同的上下文，这会给系统引入不可预测性

+   静态编译语言，如 C/C++，每次运行可能具有不同的编译器版本

+   第三方软件可能在不同的编译执行上下文中指定不同的版本

+   多次编译二进制文件也会导致低效的部署管道

+   重新编译二进制文件也可能很耗时

如果可以的话，最好在编译时只编译一次二进制文件。

# 在每个环境中应该以相同的方式进行部署

考虑到每次源代码检入时都会运行 CI 构建，开发人员通常会经常部署他们的软件。QA/测试人员不会那么频繁地部署，运维人员更少。与开发环境相比，部署到生产环境的频率要低得多，这是有充分理由的。

应该创建一个部署脚本，可以在开发、分级和生产环境中运行。每个环境中需要的任何更改都可以通过在版本控制中管理的属性文件来管理。例如，您可以在部署脚本中使用环境变量来区分不同的环境。

# 提交阶段-部署管道的第一步

部署流水线的第一个阶段是提交阶段，或者说是开发人员将代码提交到版本控制时。一旦代码提交到 CI 构建流水线，构建流水线应该在必要时编译任何代码，运行一套单元测试（希望有一些存在）和集成测试，如果需要为后续部署流水线创建任何二进制文件，则创建任何二进制文件，运行静态分析工具来检查代码库的健康状况，并准备后续部署流水线所需的任何构建工件。

提交阶段构建的其他重要指标包括代码覆盖率、代码库中的重复代码、圈复杂度（衡量代码库中的复杂性）、监控大量警告消息以及代码风格（通常由代码检查工具报告）。

如果提交构建阶段通过，那么我们可以将其视为通过的第一个关卡，尽管这是一个重要的关卡。

# 测试关卡

在极限编程中，开发人员创建验收测试，这些测试作为功能级别的测试，测试软件系统的某个方面。例如，用户登录系统和用户退出系统。另一个例子是用户访问其个人资料并更新信息。这些测试比单元测试和集成测试要广泛得多，因此如果存在系统级问题，它们会揭示出来。

# 验收测试构建阶段

运行一套验收测试应该是部署流水线的第二个关卡。验收测试还充当回归测试套件，以验证新功能是否已引入系统。在此阶段，验收测试套件中发生的任何测试失败都需要逐案评估。失败可能是由于系统中的有意行为更改，因此需要更新验收测试套件，或者失败可能代表需要解决的回归。无论哪种情况，都必须尽快修复验收测试套件。验收测试充当了部署流水线继续前进的另一个关卡。

# 手动测试

验收测试确实提供了系统行为应该如何的一定程度的保证，但只有人类才能发现系统中的异常。质量保证/测试人员可以对系统进行用户级测试，以确保系统的正确可用性。测试人员还可以对系统进行探索性测试。自动化验收测试套件有助于释放测试人员的时间，以进行这种更高价值的测试。

# 非功能测试

非功能测试的命名恰如其分，因为这些类型的测试不是系统的功能要求。相反，非功能测试测试系统中的容量和安全性等方面。在部署流水线的这一步中，失败可能不需要将构建标记为失败，而只是作为构建的决策指标。

# 发布准备

进行发布时总会伴随一定的风险，因此最好在进行软件发布时建立相应的流程。发布过程中出现的问题可以通过建立流程来预防或减轻。

在发布过程中可能要遵循的一些步骤如下：

+   创建一个涉及并由所有参与产品交付的人员共同创建的发布计划

+   尽可能自动化发布流程，以防止错误发生

+   在生产环境中经常排练发布，以帮助调试可能出现的问题

+   建立流程，以迁移正在使用的任何生产数据，并在回滚（将发布回滚到上一个版本）或升级系统时迁移配置信息

# 自动化发布流程

尽量自动化尽可能多的发布流程，因为自动化越多，您对发布流程的控制就越多。手动步骤往往容易出错，并可能导致意外结果。在生产环境中发生的任何更改都需要得到适当的锁定，这意味着更改是通过自动化流程完成的。

# 进行回滚

发布日往往会很紧张，因为在发布过程中发生的错误可能会导致难以检测的问题，或者正在发布的新系统可能存在缺陷。排练发布可以帮助减轻这些问题，并可以帮助人们快速解决可能遇到的问题。

在发布之前和发布之后，最佳策略是准备好软件系统的先前版本，以防需要将系统回滚到先前版本；这不包括任何必要的数据迁移或配置。作为另一种可行的选择，您可以重新部署已知的良好版本的应用程序。回滚应该能够通过点击按钮完成。

# 部署脚本

部署脚本是必要的，因为开发团队编写的软件不仅在他们的 IDE 或本地环境中运行，而是需要在部署流水线期间运行。部署脚本是指您用于编写部署流水线脚本的特定构建工具。

# 构建工具概述

已经有许多构建工具，每个都有其优缺点。以下是一小部分构建工具的列表：

+   **Make** ([`www.gnu.org/software/make/`](https://www.gnu.org/software/make/))：Make 是一种与语言无关的构建工具，已经使用了很长时间

+   **Maven** ([`maven.apache.org/`](https://maven.apache.org/))：Maven 是主要用于 Java 项目的构建工具

+   **MSBuild** ([`docs.microsoft.com/en-us/visualstudio/msbuild/msbuild`](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild))：MSBuild 是主要用于.NET 编程语言系列的构建工具

+   **Rake** ([`ruby.github.io/rake/`](https://ruby.github.io/rake/))：Rake 是一个类似于 Make 的构建工具，最初是为 Ruby 而设计的

+   **Gulp.js** ([`gulpjs.com/`](https://gulpjs.com/))：用于前端网页开发的构建工具

+   **Stack** ([`docs.haskellstack.org/en/stable/README/`](https://docs.haskellstack.org/en/stable/README/))：用于 Haskell 环境的构建工具

# 部署脚本概念

无论您使用什么构建工具，进行部署脚本时都需要遵循某些实践。

# 为部署流水线的每个阶段编写脚本

在部署流水线的提交阶段，您将需要部署脚本执行的操作。例如，您可能需要编译任何源文件，运行一套单元和集成测试，并运行一个检查代码风格和静态分析工具的代码检查工具。所有这些步骤可能需要使用不同的工具，因此编写一个执行所有这些操作的脚本是最好的。根据脚本的特定操作，您可能希望进一步将脚本分解为执行专注操作的子脚本。在验收测试阶段，您的脚本可能会运行整个验收测试套件，并额外生成一些关于测试的报告和指标。

# 每个环境应该使用相同的脚本

你应该在所有环境中使用完全相同的脚本，这将确保在每个环境中都以相同的方式进行构建和部署过程。如果每个环境都有不同的脚本，那么就无法确保在不同环境中运行的特定脚本的行为是相同的。开发人员在其本地环境中运行的部署脚本应该与在其他环境中运行的脚本相同，否则就会存在环境泄漏的风险。我们在这里的意思是，开发人员的环境可能设置了特定的环境变量，而部署脚本或每个环境，如开发、暂存和生产，可能设置了不同的环境变量，这将使在出现问题时调试变得更加困难。

# 部署过程不应在每次运行时都发生变化

部署过程应该在每次运行时保持不变。在数学中，有一个术语叫做**幂等**，它基本上表示某个操作可以多次执行并产生相同的结果。如果你的部署过程在任何给定的运行中发生变化，那么你无法保证每次运行的行为，这反过来将使故障排除变得更加困难。

# 部署脚本最佳实践

本节讨论了部署脚本的最佳实践，例如确保仅测试已知良好的基础、测试环境配置、使用相对路径和消除手动流程。

# 仅测试已知良好的基础

你不应该测试甚至无法编译的源代码，当单元测试和集成测试失败时也不应该运行任何验收测试。基本上，任何额外阶段的部署过程都必须存在已知良好的基线才能运行和继续。

# 测试环境配置

随着部署流水线通过每个阶段并随后通过每个阶段，检查相应阶段是否正常运行是很重要的。你对相关阶段进行的测试可以被视为**烟雾**测试。例如，通过访问 URL 检查网站是否正常运行，并检查数据库中的记录是否仍然可以获取。

# 使用相对路径

最好使用相对路径而不是绝对路径。开发人员可能有一定的文件系统或文件夹结构，在部署流水线运行的环境中不存在，因此最好使用相对路径，以免造成意外的破坏。有时可能会很难做到这一点，但尽量遵循这一点是最好的。Docker 容器可以为每个容器映射文件夹结构；例如，如果 Docker 容器在部署流水线的特定部分生成，它也可以映射到某个特定的相对文件夹结构。

# 消除手动流程

避免制作包含必须完成部署特定部分的步骤列表的构建脚本。

以下是手动流程中可能的步骤列表：

+   将项目根目录中的所有图像复制到`static/build`文件夹中

+   在新的生产发布中运行数据的手动迁移

+   如果有人必须 SSH 到一个盒子并运行一个脚本，这可能会有问题

任何必须手动完成的步骤在文档中很快就会过时，因此最容易遵循的指令是，如果你必须再次执行某个操作，就要制定自动化流程。

# 部署生态系统

在本节中，我们将简要介绍一些可以帮助你的部署流水线并提供不同用途的工具。

# 基础设施工具

我们在本章前面简要提到了 Chef；Chef 是一个很好的工具，可以可靠地自动化基础架构的搭建。如果没有适当的工具，很难确保每个新环境的设置都是以相同的方式进行的。潜在地，您可能会创建具有不同配置的新环境，这在故障排除时可能会带来很大问题。

# 云服务提供商和工具

三大主要云服务提供商都有各自相关的工具：

+   **AWS** ([`aws.amazon.com/`](https://aws.amazon.com/))：AWS 拥有一套用于 CI/CD 的工具：

+   **AWS CodeCommit** 是一个完全托管的源代码控制服务。更多信息，请参阅[`aws.amazon.com/codecommit/`](https://aws.amazon.com/codecommit/)。

+   **AWS CodeDeploy** 是一项自动化软件部署服务，可部署到各种计算服务，包括 Amazon EC2、AWS Lambda 和在本地运行的实例。更多信息，请参阅[`aws.amazon.com/codedeploy/`](https://aws.amazon.com/codedeploy/)。

+   **Microsoft Azure** ([`azure.microsoft.com/en-us/`](https://azure.microsoft.com/en-us/))：Visual Studio Team Services 是一个端到端的 CI/CD 服务。更多信息，请参阅[`visualstudio.microsoft.com/team-services/`](https://visualstudio.microsoft.com/team-services/)。

+   **Google App Engine** ([`visualstudio.microsoft.com/team-services/`](https://visualstudio.microsoft.com/team-services/))：Google App Engine 比其他云服务提供商更为中立。

您可以使用 Jenkins、Travis 和 CircleCI/CD 工具与所有主要的云服务提供商，尽管 Microsoft Azure 和 AWS 也已经创建了自己的 CI/CD 工具供您使用。

# 总结

CD，正如我们所见，围绕自动化的概念展开。在本章中，我们学习了软件交付的含义。我们首先研究了在交付软件时出现的常见问题。我们还详细讨论了配置管理以及版本控制和依赖管理在任何配置中所起的作用。我们还研究了部署流水线，并深入了解了不同的构建阶段。在部署脚本部分，我们研究了一些已有的构建工具，并制定了一些最佳实践。最后，我们简要介绍了部署生态系统和一些云服务提供商。在下一章中，我们将讨论不同团队之间沟通的问题，如何向其他团队成员传达痛点，如何在不同团队之间分享责任，向利益相关者展示 CI/CD 的重要性，以及如何获得业务利益相关者对 CI/CD 的批准。

# 问题

1.  我们所说的交付软件是什么意思？

1.  列举一些常见的发布反模式。

1.  在交付软件时，自动化的一些好处是什么？

1.  配置管理到底是什么意思？

1.  为什么应该编写描述性和有意义的提交消息？

1.  什么是部署流水线？

1.  为什么在每个环境中部署应该以相同的方式进行？

# 进一步阅读

考虑阅读 Packt Publishing 出版的《DevOps: Continuous Delivery, Integration, and Deployment with DevOps》一书，以更深入地了解 CD。
