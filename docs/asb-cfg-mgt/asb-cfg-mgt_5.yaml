- en: Chapter 5. Custom Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 自定义模块
- en: Until now we have been working solely with the tools provided to us by Ansible.
    This does afford us a lot of power, and make many things possible. However if
    you have something particularly complex or if you find yourself using the script
    module a lot, you will probably want to learn how to extend Ansible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用Ansible提供给我们的工具。这确实为我们提供了很多力量，并使许多事情成为可能。但是，如果您遇到特别复杂的情况，或者发现自己经常使用脚本模块，您可能希望学习如何扩展Ansible。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: How to write modules in Bash scripting or Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Bash脚本或Python编写模块
- en: Using the custom modules that you have developed
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您开发的自定义模块
- en: Writing a script to use an external data source as an inventory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个脚本以使用外部数据源作为清单
- en: Often when you approach something complex in Ansible, you write a script module.
    The issue with script modules is that you can't process their output, or trigger
    handlers based on their output easily. So, although the script module works in
    some cases, using a module can be better.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在处理Ansible中的复杂问题时，您会编写一个脚本模块。脚本模块的问题在于您无法轻松处理它们的输出，或者根据它们的输出触发处理程序。因此，尽管脚本模块在某些情况下有效，但使用模块可能更好。
- en: 'Use a module instead of writing a script when:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下使用模块而不是编写脚本：
- en: You don't want to run the script every single time
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不希望每次都运行脚本
- en: You need to process the output
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要处理输出
- en: Your script needs to make facts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的脚本需要生成事实
- en: You need to send complex variables as arguments
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要将复杂变量作为参数发送
- en: If you want to start writing modules, you should check out the Ansible repository.
    If you want your module to work with a particular version, you should also switch
    to that version to ensure compatibility. The following commands will set you up
    to develop modules for Ansible 1.3.0.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想开始编写模块，您应该查看Ansible存储库。如果您希望您的模块与特定版本兼容，您还应该切换到该版本以确保兼容性。以下命令将为您设置开发Ansible
    1.3.0的模块。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Checking out the Ansible code gives you access to a handy script that we will
    use later to test our modules. We will also make this script executable in anticipation
    of its use later in the chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Ansible代码可以让您访问一个方便的脚本，我们稍后将用它来测试我们的模块。我们还将使这个脚本可执行，以便在本章后期使用。
- en: Writing a module in Bash
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Bash编写模块
- en: Ansible allows you to write modules in any language that you prefer. Although
    most modules in Ansible work with JSON, you are allowed to use shortcuts if you
    don't have any JSON parsing facilities available. Ansible will hand you arguments
    in their original key value forms, if they were provided in that format. If complex
    arguments are provided, you will receive JSON-encoded data. You could parse this
    using something like jsawk ([https://github.com/micha/jsawk](https://github.com/micha/jsawk))
    or jq ([http://stedolan.github.io/jq/](http://stedolan.github.io/jq/)), but only
    if they are installed on your remote machine.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible允许您使用任何您喜欢的语言编写模块。尽管Ansible中的大多数模块都使用JSON，但如果您没有任何JSON解析工具可用，您可以使用快捷方式。如果以原始键值形式提供了参数，Ansible将以原始键值形式将其交给您。如果提供了复杂参数，您将收到JSON编码的数据。您可以使用类似jsawk
    ([https://github.com/micha/jsawk](https://github.com/micha/jsawk))或jq ([http://stedolan.github.io/jq/](http://stedolan.github.io/jq/))的工具进行解析，但前提是它们已安装在您的远程机器上。
- en: 'Ansible already has a module that lets you change the hostname of a system,
    but it only works with systemd-based systems. So let''s write one that works with
    the standard `hostname` command. We will start just printing the current hostname
    and then expand the script from there. Here is what that simple module looks like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible已经有一个模块，可以更改系统的主机名，但它只适用于基于systemd的系统。因此，让我们编写一个可以使用标准`hostname`命令的模块。我们将从打印当前主机名开始，然后从那里扩展脚本。这就是这个简单模块的样子：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you have written Bash scripts before, this should seem extremely basic. Essentially,
    what we are doing is grabbing the hostname and printing it out in a key value
    form. Now that we have written the first cut of the module, we should test it
    out.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前编写过Bash脚本，这应该看起来非常基础。基本上，我们所做的是获取主机名并以键值形式打印出来。现在我们已经编写了模块的第一个版本，我们应该测试一下。
- en: 'To test the Ansible modules, we use the script that we ran the `chmod` command
    on earlier. This command simply runs your module, records the output, and returns
    it to you. It also shows how Ansible interpreted the output of the module. The
    command that we will use looks like the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试Ansible模块，我们使用之前运行`chmod`命令的脚本。这个命令简单地运行你的模块，记录输出，并将其返回给你。它还显示了Ansible如何解释模块的输出。我们将使用的命令看起来像下面这样：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of the previous command should look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出应该如下所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Ignore the notice at the top; it does not apply to modules built with bash.
    You can see the raw output that our script sent, which looks exactly the way we
    expected. The test script also gives you the parsed output. In our example, we
    are using the short output format and we can see here that Ansible is correctly
    interpreting it into the JSON that it normally accepts from modules.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略顶部的通知；它不适用于使用bash构建的模块。您可以看到我们的脚本发送的原始输出，它看起来正是我们预期的样子。测试脚本还会给您解析后的输出。在我们的示例中，我们使用了短输出格式，我们可以看到Ansible正确地将其解释为它通常从模块接受的JSON。
- en: 'Let''s expand out the module to allow setting the `hostname`. We should write
    it so that it doesn''t make any changes unless required, and lets Ansible know
    whether changes were made or not. This is actually pretty simple for the small
    command that we are writing. The new script should look something like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展模块以允许设置`hostname`。我们应该这样写，以便除非需要，否则不做任何更改，并让Ansible知道是否已经进行了更改。对于我们正在编写的小命令来说，这实际上非常简单。新脚本应该看起来像这样：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous script works as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本的工作原理如下：
- en: We set Bash's exit on error mode, so that we don't have to deal with errors
    from the `hostname` method. Bash will automatically exit on failure with its exit
    code. This will signal Ansible that something went wrong.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置Bash的错误退出模式，这样我们就不必处理`hostname`方法的错误。Bash将在失败时自动退出并显示其退出代码。这将向Ansible发出信号，表明出现了问题。
- en: We source the argument file. This file is passed from Ansible as the first argument
    to the script. It contains the arguments that were sent to our module. Because
    we are sourcing the file, this can be used to run arbitrary commands; however,
    Ansible can already do this, so it's not that much of a security issue.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们获取参数文件。这个文件是从Ansible传递给脚本的第一个参数。它包含发送到我们模块的参数。因为我们正在获取文件，这可以用来运行任意命令；但是，Ansible已经可以做到这一点，所以这不是一个很大的安全问题。
- en: We collect the old hostname and default `CHANGED` to `False`. This allows us
    to see whether our module needs to perform any changes.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们收集旧的主机名并将默认的`CHANGED`设置为`False`。这样可以让我们看到我们的模块是否需要执行任何更改。
- en: We check whether we were sent a new hostname to set, and whether that hostname
    is different from the one that is currently set.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查是否发送了一个新的主机名来设置，以及该主机名是否与当前设置的主机名不同。
- en: If both these tests are true, we try to change the hostname, and set `CHANGED`
    to `True`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这两个测试都为真，我们尝试更改主机名，并将`CHANGED`设置为`True`。
- en: Finally, we output the results and exit. This includes the current hostname
    and whether we made changes or not.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们输出结果并退出。这包括当前的主机名以及我们是否进行了更改。
- en: 'Changing the hostname on a Unix machine requires root privileges. So while
    testing this script, you need to make sure to run it as the root user. Let''s
    test this script using `sudo` to see whether it works. This is the command you
    will use:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix机器上更改主机名需要root权限。因此，在测试这个脚本时，您需要确保以root用户身份运行它。让我们使用`sudo`来测试这个脚本，看看它是否有效。这是您将使用的命令：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If `test.example.com` is not the current hostname of the machine, you should
    get the following output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`test.example.com`不是机器的当前主机名，您应该会得到以下输出：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, our output is being parsed correctly, and the module claims
    that changes have been made to the system. You can check this yourself with the
    `hostname` command. Now, run the module for the second time with the same hostname.
    You should see an output that looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的输出被正确解析，并且模块声称已对系统进行了更改。您可以使用`hostname`命令自行检查。现在，再次使用相同的主机名运行模块。您应该会看到以下输出：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Again, we see that the output was parsed correctly. This time, however, the
    module claims to not have made any changes, which is what we expect. You can also
    check this with the `hostname` command.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看到输出被正确解析。然而，这次模块声称没有进行任何更改，这是我们所期望的。您也可以使用`hostname`命令进行检查。
- en: Using a custom module
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义模块
- en: Now that we have written our very first module for Ansible, we should give it
    a go in a playbook. Ansible looks at several places for its modules—first it looks
    at the place specified in the `library` key in its `config` file (`/etc/ansible/ansible.cfg`),
    next it will look at the location specified using the `--module-path` argument
    in the command line, then it will look in the same directory as the playbook for
    a `library` directory containing modules, and finally it will look in the `library`
    directory for any roles that may be set.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为Ansible编写了我们的第一个模块，我们应该在playbook中试一下。Ansible会在几个地方查找它的模块——首先它会查找`config`文件(`/etc/ansible/ansible.cfg`)中`library`键指定的位置，然后它会查找使用命令行中的`--module-path`参数指定的位置，然后它会在与playbook相同的目录中查找包含模块的`library`目录，最后它会在`library`目录中查找可能设置的任何角色。
- en: 'Let''s create a playbook that uses our new module and place it in a `library`
    directory in the same place so that we can see it in action. Here is a playbook
    that uses the `hostname` module:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个使用我们的新模块的playbook，并将其放在与playbook相同的位置的`library`目录中，以便我们可以看到它的效果。这是一个使用`hostname`模块的playbook：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then create a directory named `library` in the same directory as the playbook
    file. Place the `hostname` module inside the library. Your directory layout should
    look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在与playbook文件相同的目录中创建一个名为`library`的目录。将`hostname`模块放在库中。您的目录布局应该如下所示：
- en: '![Using a custom module](graphics/4267_05_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![使用自定义模块](graphics/4267_05_01.jpg)'
- en: 'Now when you run the playbook, it will find the `hostname` module in the `library`
    directory and execute it. You should see an output like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您运行playbook时，它将在`library`目录中找到`hostname`模块并执行它。您应该会看到以下输出：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Running it again should change the result from `changed` to `ok`. Congratulations!
    You have now created and executed your very first module. This module is very
    simple right now, but you can extend it to know about the `hostname` file, or
    other methods to configure the hostname at boot time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应该将结果从`changed`更改为`ok`。恭喜！您现在已经创建并执行了您的第一个模块。这个模块现在非常简单，但您可以扩展它以了解`hostname`文件，或其他配置主机名的方法。
- en: Writing modules in Python
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Python编写模块
- en: 'All of the modules that are distributed with Ansible are written in Python.
    Because Ansible is also written in Python, these modules can directly integrate
    with Ansible. Here are a few reasons why you should write modules in Python:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与Ansible一起分发的模块都是用Python编写的。因为Ansible也是用Python编写的，所以这些模块可以直接集成到Ansible中。以下是为什么应该用Python编写模块的几个原因：
- en: Modules written in Python can use boilerplate, which reduces the amount of code
    required
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Python编写的模块可以使用样板文件，这样可以减少所需的代码量
- en: Python modules can provide documentation to be used by Ansible
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python模块可以提供文档供Ansible使用
- en: Arguments to your module are handled automatically
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的参数会自动处理
- en: Output is automatically converted to JSON for you
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出会自动转换为JSON格式
- en: Ansible upstream only accepts plugins using Python with the boilerplate code
    included
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible仅接受使用包含样板代码的Python编写的插件
- en: You can still build Python modules without this integration by parsing the arguments
    and outputting JSON yourself. However, with all the things you get for free, it
    would be hard to make a case for it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以构建Python模块，而无需通过解析参数和自己输出JSON来实现此集成。但是，考虑到您可以免费获得的所有功能，很难提出这样做的理由。
- en: Let's build a Python module that lets us change the currently running init level
    of the system. There is a Python module named `pyutmp` that will let us parse
    the `utmp` file. Unfortunately, since Ansible modules have to be contained in
    a single file, we can't use it unless we know it will be installed on the remote
    systems, so we will resort to using the `runlevel` command and parsing its output.
    Setting the run level can be done with the `init` command.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个Python模块，让我们能够更改系统当前运行的初始化级别。有一个名为`pyutmp`的Python模块，它将允许我们解析`utmp`文件。不幸的是，由于Ansible模块必须包含在单个文件中，除非我们知道它将安装在远程系统上，否则我们无法使用它，因此我们将使用`runlevel`命令并解析其输出。可以使用`init`命令设置运行级别。
- en: 'The first step is to figure out what arguments and features the module supports.
    For the sake of simplicity, let''s have our module only accept one argument. We''ll
    use the argument `runlevel` to get the run level the user wants to change to.
    To do this, we will instantiate the `AnsibleModule` class with our data as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是弄清楚模块支持的参数和功能。为了简单起见，让我们的模块只接受一个参数。我们将使用参数`runlevel`来获取用户想要更改为的运行级别。为此，我们将使用我们的数据实例化`AnsibleModule`类，如下所示：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we need to implement the actual guts of the module. The module object that
    we created previously provides us with a few shortcuts. There are three shortcuts
    that we will be using in the next step. As there are way too many methods to document
    here, you can see the whole `AnsibleModule` class and all the available helper
    functions in `lib/ansible/module_common.py`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要实现模块的实际要点。我们之前创建的模块对象为我们提供了一些快捷方式。在下一步中，我们将使用三个快捷方式。由于有太多的方法需要在这里记录，您可以在`lib/ansible/module_common.py`中看到整个`AnsibleModule`类和所有可用的辅助函数。
- en: '`run_command`: This method is used to launch external commands and retrieve
    the return code, the output from `stdout`, and also the output from `stderr`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run_command`：此方法用于启动外部命令并检索返回代码、`stdout`的输出以及`stderr`的输出。'
- en: '`exit_json`: This method is used to return data to Ansible when the module
    has completed successfully.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exit_json`：此方法用于在模块成功完成时向Ansible返回数据。'
- en: '`fail_json`: This method is used to signal a failure to Ansible, with an error
    message and return code.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail_json`：此方法用于向Ansible发出失败信号，附带错误消息和返回代码。'
- en: 'The following code actually manages the init level of the system comments to
    explain what it does:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实际上管理了系统注释的初始化级别，以解释其功能：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There is one final thing to add to the boilerplate to let Ansible know that
    it needs to dynamically add the integration code into our module. This is the
    magic that lets us use the `AnsibleModule` class and enables our tight integration
    with Ansible. The boilerplate code needs to be placed right at the bottom of the
    file, with no code afterwards. The code to do this looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事要添加到样板中，让Ansible知道它需要动态地将集成代码添加到我们的模块中。这是让我们使用`AnsibleModule`类并启用与Ansible的紧密集成的魔法。样板代码需要放在文件底部，之后没有代码。这样做的代码如下：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can test this module the same way you tested the Bash module with the `test-module`
    script. However, you need to be careful, because if you run it with `sudo`, you
    might reboot your machine or alter the init level to something you don''t want.
    This module is probably better tested by using Ansible itself on a remote test
    machine. We follow the same process as described in the *Writing a module in Bash*
    section earlier in this chapter. We create a playbook that uses the module, and
    then place the module in a library directory that has been made in the same directory
    as the playbook. Here is the playbook we need to use:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`test-module`脚本测试此模块，就像您测试Bash模块一样。但是，您需要小心，因为如果您使用`sudo`运行它，可能会重新启动您的机器或更改初始化级别为您不想要的级别。最好使用Ansible本身在远程测试机器上测试此模块。我们遵循本章前面描述的“在Bash中编写模块”部分相同的过程。我们创建一个使用该模块的playbook，然后将该模块放在与playbook相同目录中创建的库目录中。这是我们需要使用的playbook：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now you should be able to try and run this on a remote machine. The first time
    you run it, if the machine is not already in run level 5, you should see it change
    the run level. Then you should be able to run it for a second time to see that
    nothing has changed. You might also want to check to make sure the module fails
    correctly when not run as root.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该能够尝试在远程机器上运行此模块。第一次运行时，如果机器尚未处于运行级别5，则应该看到它更改运行级别。然后您应该能够再次运行它，以查看是否没有发生任何更改。您可能还想检查以确保模块在非root用户运行时能够正确失败。
- en: External inventories
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部清单
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started with Ansible"), *Getting
    Started with Ansible*, we saw how Ansible needs an inventory file, so that it
    knows where its hosts are and how to access them. Ansible also allows you to specify
    a script that allows you to fetch the inventory from another source. External
    inventory scripts can be written in any language that you like as long as they
    output valid JSON.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。开始使用Ansible")*开始使用Ansible*中，我们看到Ansible需要一个清单文件，以便它知道其主机在哪里以及如何访问它们。Ansible还允许您指定一个脚本，允许您从另一个源获取清单。外部清单脚本可以用任何您喜欢的语言编写，只要它们输出有效的JSON。
- en: An external inventory script has to accept two different calls from Ansible.
    If called with `–list`, it must return a list of all the available groups and
    hosts. Additionally, it may be called with `--host`. In this case, the second
    argument will be a hostname and the script is expected to return a list of variables
    for that host. All the outputs are expected in JSON, so you should use a language
    that supports it naturally.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 外部清单脚本必须接受来自Ansible的两种不同调用。如果使用`–list`调用，它必须返回所有可用组和主机的列表。此外，它可能会被调用`--host`。在这种情况下，第二个参数将是主机名，脚本应返回该主机的变量列表。所有输出都应以JSON格式呈现，因此您应该使用自然支持它的语言。
- en: 'Let''s write a module that takes a CSV file listing all your machines and presents
    this to Ansible as an inventory. This will be handy if you have a **Configuration
    Management Database** (**CMDB**) that allows you to export your machine list as
    CSV, or for someone who keeps records of their machines in a spreadsheet. Additionally,
    it doesn''t require any dependencies outside Python, as a CSV processing module
    is already included with Python. This really just parses the CSV file into the
    right data structures and prints them out as JSON data structures. The following
    is an example CSV file we wish to process; you may wish to customize it for the
    machines in your environment:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个模块，它接受列出所有机器的CSV文件，并将其呈现给Ansible作为清单。如果您有一个允许您将机器列表导出为CSV的**配置管理数据库**（**CMDB**），或者有人在电子表格中记录他们的机器，这将非常方便。此外，它不需要Python之外的任何依赖项，因为Python已经包含了一个CSV处理模块。这只是将CSV文件解析为正确的数据结构，并将它们打印为JSON数据结构。以下是我们希望处理的示例CSV文件；您可能希望为您的环境中的机器定制它：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This file needs to be converted into two different JSON outputs. When `--list`
    is called, we need to output the whole thing in a form that looks like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件需要转换为两种不同的JSON输出。当调用`--list`时，我们需要以以下形式输出整个内容：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And when it is called with the arguments `--host example`, it should return
    this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用参数`--host example`调用时，它应该返回这个：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is the script that opens a file named `machines.csv` and produces the
    dictionary of the groups if `--list` is given: Additionally, when `--host` and
    a hostname are given, it parses that host''s variables and returns them as a dictionary.
    The script is well-commented, so you can see what it is doing. You can run the
    script manually with the `--list` and `--host` arguments to confirm that it behaves
    correctly.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是打开名为`machines.csv`的文件并在给出`--list`时生成组的字典的脚本：此外，当给出`--host`和主机名时，它会解析该主机的变量并将它们作为字典返回。脚本有很好的注释，所以您可以看到它在做什么。您可以手动运行脚本，使用`--list`和`--host`参数来确认它的行为是否正确。
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can now use this inventory script to provide the inventory when using Ansible.
    A quick way to test that everything is working correctly is to use the `ping`
    module to test the connection to all the machines. This command will not test
    whether the hosts are in the right groups; if you want to do that, you can use
    the same `ping` module command but instead of running it across all, you can simply
    use the group you would like to test**.** If your inventory file is executable,
    then Ansible will run it and use the output. You can also use a directory and
    Ansible will include all files inside, running them if they are executable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以使用此清单脚本在使用Ansible时提供清单。测试一切是否正常工作的快速方法是使用`ping`模块测试与所有机器的连接。此命令不会测试主机是否在正确的组中；如果您想要这样做，您可以使用相同的`ping`模块命令，但是不是在所有机器上运行，而是只使用您想要测试的组**。**如果您的清单文件是可执行的，那么Ansible将运行它并使用输出。您还可以使用一个目录，Ansible将包含其中的所有文件，并在它们可执行时运行它们。
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similar to when you used the `ping` module in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Ansible"), *Getting Started with Ansible*, you should see an output
    that looks like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与您在[第1章](ch01.html "第1章。开始使用Ansible")中使用`ping`模块时类似，*开始使用Ansible*，您应该看到类似以下的输出：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This indicates that you can connect and use Ansible on all the hosts from your
    inventory. You can use the same `-i` argument with `ansible-playbook` to run your
    playbooks with the same inventory.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明您可以连接并使用Ansible在清单中的所有主机上。您可以使用相同的`-i`参数与`ansible-playbook`一起使用相同的清单运行您的playbook。
- en: Extending Ansible
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Ansible
- en: 'Apart from writing modules and external inventory script, you can also extend
    the core functionality of Ansible itself. This allows you to include even more
    functionality into Ansible using Python. By writing plugins for Ansible, you can
    do the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编写模块和外部清单脚本，您还可以扩展Ansible本身的核心功能。这允许您使用Python将更多功能包含到Ansible中。通过为Ansible编写插件，您可以执行以下操作：
- en: Add new methods for controlling other machines with connection plugins
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用连接插件控制其他机器的新方法
- en: Use data from external sources outside Ansible in loops or lookups with lookup
    plugins
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用查找插件从Ansible外部的数据源中获取数据并进行循环或查找
- en: Add new filters for use with variables or in templates with filter plugins
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过滤器插件为变量或模板添加新的过滤器
- en: Include callbacks that run when certain actions happen inside Ansible with callback
    plugins
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用回调插件在Ansible内部发生某些操作时运行回调
- en: To add extra plugins to your Ansible projects, we create a Python file in the
    plugin directories specified in your `ansible.cfg` file. Alternatively, we can
    add new directories containing our plugins to the list of directories already
    present.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要向您的Ansible项目添加额外的插件，我们在`ansible.cfg`文件中指定的插件目录中创建一个Python文件。或者，我们可以将包含我们插件的新目录添加到已经存在的目录列表中。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not remove any of the existing directories, as you will be removing plugins
    that provide core Ansible features such as the ones we have mentioned earlier
    in this book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不要删除任何现有目录，因为您将删除提供核心Ansible功能的插件，例如我们在本书中早期提到的插件。
- en: When writing plugins to Ansible, you should focus on making them flexible and
    reusable where possible. This way you end up removing some complexity from your
    playbooks and templates into a few complex Python files. Focusing on re-usability
    of your plugins also means it is possible to submit them back to the Ansible project
    using a GitHub pull request. If you submit your plugins back to Ansible, then
    everybody will be able to take advantage of your plugin, and you would have played
    a part in the development of Ansible itself. More information on contributing
    to Ansible can be found in the `CONTRIBUTORS.md` file in the Ansible source code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 编写Ansible插件时，应该专注于使它们尽可能灵活和可重用。这样，您最终可以将一些复杂性从您的剧本和模板中移除，转移到几个复杂的Python文件中。专注于插件的可重用性也意味着可以通过GitHub拉取请求将它们提交回Ansible项目。如果将插件提交回Ansible，那么每个人都可以利用您的插件，并且您将在Ansible本身的开发中发挥作用。有关如何为Ansible做出贡献的更多信息，请参阅Ansible源代码中的`CONTRIBUTORS.md`文件。
- en: Connection plugins
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接插件
- en: Connection plugins are responsible for relaying files to and from the remote
    machine, and executing modules. You will no doubt have already used the SSH, local
    and possibly the winrm plugins with the playbooks used earlier in the book.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 连接插件负责在远程机器之间中继文件，并执行模块。您无疑已经在本书前面使用了SSH、本地和可能是winrm插件。
- en: 'Apart from the normal `__init__()` method, connection plugins must implement
    the following methods:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了普通的`__init__()`方法外，连接插件必须实现以下方法：
- en: '| Method | Purpose |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 目的 |'
- en: '| --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `connect()` | This opens the connection to the host we are managing |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `connect()` | 这将打开到我们正在管理的主机的连接 |'
- en: '| `exec_command()` | This executes a command on the managed host |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `exec_command()` | 这在托管主机上执行命令 |'
- en: '| `put_file()` | This copies a file to the managed host |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `put_file()` | 这将文件复制到托管主机 |'
- en: '| `fetch_file()` | This downloads a file from the managed host |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `fetch_file()` | 这从托管主机下载文件 |'
- en: '| `close()` | This closes the connection to the host we are managing |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `close()` | 这将关闭我们正在管理的主机的连接 |'
- en: Lookup plugins
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找插件
- en: 'Lookup plugins are used in two ways: to include data from outside as a `lookup()`,
    or in the `with_` style to loop over items. You can even combine the two to loop
    over external data as is done in the `with_fileglob` lookup plugin. Several lookup
    plugins have been demonstrated earlier in the book, particularly in *Looping*
    section of [Chapter 3](ch03.html "Chapter 3. Advanced Playbooks"), *Advanced Playbook*.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 查找插件有两种用法：作为`lookup()`从外部包含数据，或者以`with_`样式循环遍历项目。甚至可以将两者结合起来，循环遍历外部数据，就像在`with_fileglob`查找插件中所做的那样。本书前面已经演示了几个查找插件，特别是在[第3章](ch03.html
    "第3章.高级剧本")的*循环*部分，*高级剧本*。
- en: 'Lookup plugins are simple to write, and apart from the normal `__init__()`
    method, they only need you to implement a `run()` method. This method uses the
    `listify_lookup_plugin_terms()` method from the Ansible `utils` package to gather
    the arguments list passed to it, and returns the result. As an example, we will
    now demonstrate a lookup plugin to read data from a JSON encoded file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 查找插件很容易编写，除了普通的`__init__()`方法外，它们只需要你实现一个`run()`方法。这个方法使用Ansible `utils`包中的`listify_lookup_plugin_terms()`方法来收集传递给它的参数列表，并返回结果。例如，我们现在将演示一个查找插件，从JSON编码文件中读取数据：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This can be used either as a lookup plugin to fetch complex data or, if the
    file contains a JSON list, as a loop using `with_jsonfile`. Save the preceding
    example as `jsonfile.py` in one of your lookup plugin directories. You can see
    that we have declared a new class named `LookupModule`; this is what Ansible tries
    to find within your Python file, so you must use this name. We then create a constructor
    (named `__init__`) so that Ansible can create our class. Finally, we make a small
    method that simply opens a JSON file, parses it and returns the result to Ansible.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以作为查找插件来获取复杂数据，或者如果文件包含JSON列表，则可以使用`with_jsonfile`进行循环。将前面的示例保存为`jsonfile.py`，放在您的查找插件目录之一中。您可以看到我们声明了一个名为`LookupModule`的新类；这是Ansible尝试在您的Python文件中找到的内容，因此您必须使用这个名称。然后，我们创建一个构造函数（名为`__init__`），以便Ansible可以创建我们的类。最后，我们创建一个简单的方法，它只是打开一个JSON文件，解析它，并将结果返回给Ansible。
- en: We should note that this example is really simplified and only looks in the
    current working directory for the file. It could be extended later to look in
    a roles file directory or elsewhere in order to better conform to conventions
    set by other Ansible modules.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，这个例子真的很简化，只在当前工作目录中查找文件。稍后可以扩展以在角色文件目录或其他位置查找文件，以更好地符合其他Ansible模块设置的约定。
- en: 'You can then use this lookup plugin in a playbook like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以在剧本中像这样使用这个查找插件：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Filter plugins
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤器插件
- en: Filter plugins are extensions to the Jinja2 template engine that Ansible uses
    to process variables and generate files from templates. These extensions can be
    used in playbooks to perform data processing on variables, or they can be used
    inside templates to process data before it is included in the file. They simplify
    the processing of data by moving the complexity to a Python file and away from
    the templates or Ansible configuration.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器插件是Ansible用于处理变量并从模板生成文件的Jinja2模板引擎的扩展。这些扩展可以在剧本中用于对变量进行数据处理，也可以在模板中用于在包含在文件中之前处理数据。它们通过将复杂性转移到Python文件中，使数据处理变得简单，并远离模板或Ansible配置。
- en: Filter plugins are a little different from other plugins. To implement one,
    you first write a simple function that simply takes the input you need and returns
    the result. Second, you create a class named `FilterModule`, and implement a `filters`
    method on it, which returns a Python dictionary, where the keys are the filter
    names and the values the functions to call.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器插件与其他插件有些不同。要实现一个，首先编写一个简单的函数，它只需获取所需的输入并返回结果。其次，创建一个名为`FilterModule`的类，并在其中实现一个`filters`方法，该方法返回一个Python字典，其中键是过滤器名称，值是要调用的函数。
- en: 'Here is a sample implementation of a plugin that can be used to calculate the
    minimum number of servers required in any group to avoid a split-brain situation:
    This number in most systems is one greater than 50% of the nodes available.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可以用来计算任何组中所需的最小服务器数量以避免分裂脑情况的插件的示例实现：在大多数系统中，此数字比可用节点的50%多一个。
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Simply put, this module counts how many items were in the list passed to it,
    divides it by two, and then adds one. It is all done as integer math, so remainders
    are ignored and everything is done as whole numbers, which suits our purpose.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，此模块计算传递给它的列表中有多少项，将其除以2，然后加1。这都是整数运算，因此忽略了余数，并且所有内容都是整数，这适合我们的目的。
- en: 'This filter can then be used in a playbook or a template. For example, if we
    wanted to configure an Elasticsearch cluster to have a quorum and avoid split-brain
    issues, we will use the following line of code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过滤器可以在playbook或模板中使用。例如，如果我们想要配置一个Elasticsearch集群以具有法定人数并避免分裂脑问题，我们将使用以下代码行：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will get the list of hosts this play is being run on (from the `play_hosts`
    variable), and then calculate how many of those are required to obtain a quorum.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取此play正在运行的主机列表（从`play_hosts`变量中），然后计算需要多少个主机才能获得法定人数。
- en: Callback plugins
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调插件
- en: 'Callback plugins are used to provide information about actions that are happening
    in Ansible to external systems. They are automatically activated if they are found
    in the directories specified under the `callback_plugins` directory into Ansible
    configuration. They are often useful when playbooks are being run as automated
    tasks as they can give feedback via other channels than the standard output. Callback
    plugins have a wide variety of uses, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 回调插件用于向外部系统提供有关在Ansible中发生的操作的信息。如果在Ansible配置中的`callback_plugins`目录下找到它们，它们将自动激活。当playbook作为自动化任务运行时，它们通常很有用，因为它们可以通过标准输出以外的其他渠道提供反馈。回调插件有各种用途，如下所示：
- en: Sending an e-mail at the end of a playbook with the statistics of what changed
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在playbook结束时发送一封电子邮件，其中包含更改的统计信息
- en: Recording a running log of changes being made to `syslog`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录正在进行的更改的运行日志到`syslog`
- en: Notifying a chat channel when a playbook task fails
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当playbook任务失败时通知聊天频道
- en: Updating a CMDB as changes are made to ensure an accurate view of the configuration
    of every system.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在更改时更新CMDB以确保对每个系统的配置的准确视图。
- en: Alerting an admin when a play has exited early because all hosts have failed.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当play因为所有主机都失败而提前退出时向管理员发出警报。
- en: 'The callback plugins are the most complicated plugins to write because they
    have the ability to hook into most of Ansible''s features. Just because there
    are many options though does not mean you need to implement them all. You only
    need to implement the ones your callback will use. Here is a list of the methods
    you can implement, along with their description:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 回调插件是最复杂的插件，因为它们可以连接到Ansible的大多数功能。但是，只是因为有很多选项并不意味着您需要实现它们所有。您只需要实现您的回调将使用的那些。以下是您可以实现的方法列表，以及它们的描述：
- en: '`def on_any(self, *args, **kwargs)`: This is called before any of the other
    callbacks are called. Because the arguments differ from callback to callback,
    it expands its arguments into `args` and `kwargs`. This method is good for logging.
    Using it for anything else can become quite complicated.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def on_any(self, *args, **kwargs)`: 这在调用任何其他回调之前调用。由于参数因回调而异，它将其参数扩展为`args`和`kwargs`。这种方法适用于日志记录。将其用于其他任何事情可能会变得非常复杂。'
- en: '`runner_on_failed(self, host, res, ignore_errors=False)`: This is run after
    a task fails. The `host` argument contains the host on which the task was running,
    `res` contains the task data from the playbook and anything that was returned,
    and `ignore_errors` contains a boolean value specifying whether the playbook indicated
    errors should be ignored.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runner_on_failed(self, host, res, ignore_errors=False)`: 这在任务失败后运行。`host`参数包含运行任务的主机，`res`包含playbook中的任务数据和任何返回的数据，`ignore_errors`包含一个布尔值，指定是否应忽略playbook指示的错误。'
- en: '`runner_on_ok(self, host, res)`: This runs after a task succeeds or when a
    poll for an async job succeeds. The argument `host` contains the host on which
    the task was running and `res` contains the task data from the playbook and any
    data that was returned.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runner_on_ok(self, host, res)`: 这在任务成功或异步作业的轮询成功后运行。参数`host`包含运行任务的主机，`res`包含playbook中的任务数据和任何返回的数据。'
- en: '`runner_on_skipped(self, host, item=None)`: This runs after a task is skipped.
    The argument `host` contains the host on which the task would have run if it were
    not skipped and the `item` argument contains the loop item, which is currently
    being iterated over.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runner_on_skipped(self, host, item=None)`: 这在任务被跳过后运行。参数`host`包含如果未被跳过则将运行任务的主机，`item`参数包含当前正在迭代的循环项。'
- en: '`runner_on_unreachable(self, host, res)`:This runs when a host is found to
    be unreachable. The `host` argument contains the unreachable host and `res` contains
    the error message from the connection plugin.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runner_on_unreachable(self, host, res)`: 当发现主机无法访问时运行。`host`参数包含无法访问的主机，`res`包含连接插件的错误消息。'
- en: '`runner_on_no_hosts(self)`: This callback runs when a task is started without
    any hosts. It does not have any variables.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runner_on_no_hosts(self)`: 当没有任何主机启动任务时，此回调运行。它没有任何变量。'
- en: '`runner_on_async_poll(self, host, res, jid, clock)`: This runs whenever an
    async job is polled for status. The variable `host` contains the host that is
    being polled, `res` contains details of the polling, `jid` contains the job ID,
    and `clock` contains the amount of time remaining before the job fails.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runner_on_async_poll(self, host, res, jid, clock)`: 每当轮询异步作业的状态时运行。变量`host`包含正在轮询的主机，`res`包含轮询的详细信息，`jid`包含作业ID，`clock`包含作业失败之前剩余的时间。'
- en: '`runner_on_async_ok(self, host, res, jid)`: This runs when polling has completed
    without an error. The argument `host` contains the host that was being polled,
    `res` holds the results from the task, and `jid` contains the job ID.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runner_on_async_ok(self, host, res, jid)`: 当轮询完成且没有错误时运行。参数`host`包含被轮询的主机，`res`保存任务的结果，`jid`包含作业ID。'
- en: '`runner_on_async_failed(self, host, res, jid)`: This runs when polling has
    completed with an error. The argument `host` contains the host that was being
    polled, `res` holds the results from the task, and `jid` contains the job ID.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runner_on_async_failed(self, host, res, jid)`: 当轮询完成并出现错误时运行。参数`host`包含被轮询的主机，`res`保存任务的结果，`jid`包含作业ID。'
- en: '`playbook_on_start(self)`: This callback is executed when a playbook is started
    with `ansible-playbook`. It does not use any variables.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playbook_on_start(self)`: 当使用`ansible-playbook`启动playbook时执行此回调。它不使用任何变量。'
- en: '`playbook_on_notify(self, host, handler)`: This callback is run whenever a
    handler is notified. Because this is run when the notify happens and not when
    the handler runs, it may run multiple times for each handler. It has two variables:
    `host` stores the hostname on which the task notified and `handler` stores the
    name of the handler that was notified.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playbook_on_notify(self, host, handler)`: 每当通知处理程序时运行此回调。因为这是在通知发生时而不是处理程序运行时运行的，所以对于每个处理程序可能会运行多次。它有两个变量：`host`存储了任务通知的主机名，`handler`存储了被通知的处理程序的名称。'
- en: '`playbook_on_no_hosts_matched(self)`: This callback runs if a play starts that
    does not match any host. It does not have any variables.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playbook_on_no_hosts_matched(self)`: 如果开始了一个不匹配任何主机的play，则运行此回调。它没有任何变量。'
- en: '`playbook_on_no_hosts_remaining(self)`: This callback runs when all the hosts
    in a play have errors and the play is unable to continue.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playbook_on_no_hosts_remaining(self)`: 当play中的所有主机都有错误且play无法继续时运行此回调。'
- en: '`playbook_on_task_start(self, name, is_conditional)`: This callback runs right
    before each task, even if the task is going to be skipped. The `name` variable
    is set to the name of the task, and `is_conditional` is set to the outcome of
    the when clause—`True` if the task will run, and `False` if not.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playbook_on_task_start(self, name, is_conditional)`: 此回调在每个任务之前运行，即使任务将被跳过也是如此。`name`变量设置为任务的名称，`is_conditional`设置为when子句的结果——如果任务将运行，则为`True`，否则为`False`。'
- en: '`playbook_on_setup(self)`: This callback is executed right before the setup
    module executes across the hosts. It runs once no matter how many hosts are included.
    It does not include any variables.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playbook_on_setup(self)`: 此回调在setup模块在主机上执行之前执行。无论包含多少主机，它只运行一次。它不包括任何变量。'
- en: '`playbook_on_play_start(self, name)`: This callback runs at the beginning of
    each play. The `name` variable contains the name of the play that is starting.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playbook_on_play_start(self, name)`: 此回调在每个play开始时运行。`name`变量包含正在开始的play的名称。'
- en: '`playbook_on_stats(self, stats)`: This callback runs at the end of a playbook
    right before the stats are to be printed. The `stats` variable contains the details
    of the playbook.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playbook_on_stats(self, stats)`: 此回调在playbook结束之前运行，就在统计信息打印之前。`stats`变量包含playbook的详细信息。'
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Having read this chapter, you should now be able to build modules using either
    Bash or any other languages that you know. You should be able to install modules
    that you have either obtained from the Internet, or written yourself. We also
    covered how to write modules more efficiently using the boilerplate code in Python,
    and we wrote an inventory script that allows you to pull your inventory from an
    external source. Finally we covered adding new features to Ansible itself by writing
    connection, lookup, filter, and callback plugins.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您现在应该能够使用Bash或其他任何您了解的语言构建模块。您应该能够安装模块，无论是从互联网上获取的还是自己编写的。我们还介绍了如何使用Python中的样板代码更有效地编写模块，并编写了一个库存脚本，允许您从外部来源获取库存。最后，我们介绍了通过编写连接、查找、过滤和回调插件向Ansible本身添加新功能。
- en: We have tried to cover most of the things you will need when getting to know
    Ansible, but we can't possibly cover everything. If you would like to continue
    learning about Ansible, you can visit the official Ansible documentation at [http://docs.ansible.com/](http://docs.ansible.com/).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经尽量涵盖了您在了解Ansible时需要的大部分内容，但我们不可能涵盖一切。如果您想继续学习有关Ansible的知识，可以访问官方Ansible文档[http://docs.ansible.com/](http://docs.ansible.com/)。
- en: 'The Ansible project is currently working on a rewrite, which will eventually
    be released as version 2.0\. This book should stay compatible with this version
    and others going forward, but there will be new features that are not covered
    here. In version 2.0 of Ansible, you can expect the following features, which
    may change in the future (as it has not yet been released):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible项目目前正在进行重写，最终将作为2.0版本发布。本书应该与此版本和以后的版本保持兼容，但会有一些未在此处介绍的新功能。在Ansible 2.0版本中，您可以期待以下功能，这些功能可能会在未来发生变化（因为尚未发布）：
- en: The ability to recover from failures within a playbook
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在playbook中从失败中恢复的能力
- en: Allowing you to run lots of tasks in parallel
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许您并行运行大量任务
- en: Compatibility with Python 3
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Python 3兼容
- en: Easier debugging as errors will contain line numbers
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易调试，因为错误将包含行号
