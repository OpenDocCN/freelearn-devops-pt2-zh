- en: Chapter 2. Simple Playbooks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。简单的Playbooks
- en: Ansible can be used as a command-line tool for making small changes. However,
    its real power lies in its scripting abilities. While setting up machines, we
    almost always need to do more than one thing at a time. Ansible uses a concept
    named **playbook** to do this. Using playbooks, we can perform many actions at
    once, and across multiple systems. They provide a way to orchestrate deployments,
    ensure a consistent configuration, or simply perform a common task.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible可以作为一个命令行工具来进行小的更改。然而，它真正的力量在于其脚本能力。在设置机器时，我们几乎总是需要一次做多件事情。Ansible使用名为**playbook**的概念来实现这一点。使用playbooks，我们可以一次执行多个操作，并跨多个系统执行。它们提供了一种编排部署、确保一致的配置，或者简单执行常见任务的方式。
- en: Playbooks are expressed in **YAML,** and for the most part, Ansible uses a standard
    YAML parser. This means that we have all the features of YAML available to us
    as we write them. For example, we can use the same commenting system in playbook
    as we would in YAML. Many lines of a playbook can also be written and represented
    in YAML data types. See [http://www.yaml.org/](http://www.yaml.org/) for more
    information.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Playbooks以**YAML**形式表示，大部分情况下，Ansible使用标准的YAML解析器。这意味着我们在编写playbooks时可以使用YAML的所有功能。例如，我们可以在playbook中使用与YAML相同的注释系统。playbook的许多行也可以用YAML数据类型编写和表示。有关更多信息，请参阅[http://www.yaml.org/](http://www.yaml.org/)。
- en: Playbooks also open up many opportunities. They allow us to carry the state
    from one command to the other. For example, we can grab the content of a file
    on one machine, register it as a variable, and then use the value on another machine.
    This allows us to make complex deployment mechanisms that will be impossible with
    the Ansible command alone. Additionally, since each module tries to be idempotent,
    we should be able to run a playbook several times and changes will only be made
    if they need to be.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Playbooks还开启了许多机会。它们允许我们将状态从一个命令传递到另一个命令。例如，我们可以在一台机器上获取文件的内容，将其注册为变量，然后在另一台机器上使用该值。这使我们能够创建复杂的部署机制，这是仅使用Ansible命令无法实现的。此外，由于每个模块都试图是幂等的，我们应该能够多次运行playbook，只有在需要时才会进行更改。
- en: 'The command to execute a playbook is `ansible-playbook`. It accepts arguments
    similar to the Ansible command-line tool. For example, `-k` (`--ask-pass`) and
    `-K` (`--ask-sudo`) make Ansible prompt for the SSH and sudo passwords, respectively;
    `-u` can be used to set the user to use for SSH. However, these options can also
    be set inside the playbooks themselves in the target section. For example, to
    use the play named `example-play.yml`, we can use the following command:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 执行playbook的命令是`ansible-playbook`。它接受类似于Ansible命令行工具的参数。例如，`-k`（`--ask-pass`）和`-K`（`--ask-sudo`）会让Ansible分别提示输入SSH和sudo密码；`-u`可以用来设置SSH连接的用户名。然而，这些选项也可以在playbook的目标部分内设置。例如，要使用名为`example-play.yml`的play，我们可以使用以下命令：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The Ansible playbooks are made up of one or more plays. A play consists of
    three sections:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible playbooks由一个或多个play组成。一个play包括三个部分：
- en: The **target section** defines the hosts on which the play will be run, and
    how it will be run. This is where we set the SSH username and other SSH-related
    settings.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标部分**定义了play将在哪些主机上运行以及如何运行。这是我们设置SSH用户名和其他SSH相关设置的地方。'
- en: The **variable section** defines variables, which will be made available to
    the play while running.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量部分**定义了在运行play时将可用的变量。'
- en: The **task section** lists all the modules in the order we want them to be run
    by Ansible.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务部分**按照我们希望Ansible运行的顺序列出了所有模块。'
- en: We can include as many plays as we want in a single YAML file. YAML files start
    with `---` and contain many key values and lists. In YAML line indentation is
    used to indicate variable nesting to the parser, which also makes the file easier
    to read.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在单个YAML文件中包含尽可能多的play。YAML文件以`---`开头，并包含许多键值和列表。在YAML中，行缩进用于指示变量嵌套给解析器，这也使文件更易于阅读。
- en: 'A full example of an Ansible play looks like the following code snippet:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的Ansible play示例如下代码片段所示：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the next few sections, we will examine each section and explain in detail
    how they work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个部分中，我们将逐一检查每个部分，并详细解释它们的工作原理。
- en: The target section
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标部分
- en: 'The target section looks like the following code snippet:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 目标部分看起来像以下代码片段：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is an incredibly simple version, but likely to be all we need in most cases.
    Each play exists within a list. As per the YAML syntax, the line must start with
    a dash. The hosts that a play will be run on must be set in the value of `hosts`.
    This value uses the same syntax as the one used when selecting hosts using the
    Ansible command line, which we discussed in the previous chapter. The host-pattern-matching
    features of Ansible were also discussed in the previous chapter. In the next line,
    the user tells the Ansible playbook which user to connect to the machine as.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的版本，但在大多数情况下可能是我们所需要的。每个play都存在于一个列表中。根据YAML语法，行必须以破折号开头。play将要运行的主机必须在`hosts`的值中设置。这个值使用与使用Ansible命令行选择主机时相同的语法，我们在上一章中讨论过。Ansible的主机模式匹配功能也在上一章中讨论过。在下一行中，用户告诉Ansible
    playbook要连接到机器的用户。
- en: 'The other lines that we can provide in this section are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个部分中，我们可以提供的其他行如下：
- en: '| Name | Description |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `sudo` | Set this to `yes` if you want Ansible to use `sudo` to become the
    root once it is connected to the machines in the play. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `sudo` | 如果要让Ansible在连接到play中的机器后使用`sudo`成为root用户，则将其设置为`yes`。|'
- en: '| `user` | This defines the username to connect to the machine originally,
    before running `sudo` if configured. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `user` | 这定义了最初连接到机器的用户名，在配置了`sudo`之前。|'
- en: '| `sudo_user` | This is the user that Ansible will try and become using `sudo`.
    For example, if we set `sudo` to `yes` and `user` to `daniel`, setting `sudo_user`
    to `kate` will cause Ansible to use `sudo` to get from `daniel` to `kate` once
    logged in. If you were doing this in an interactive SSH session, we could use
    `sudo -u kate` while you are logged in as `daniel`. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `sudo_user` | 这是Ansible将尝试使用`sudo`成为的用户。例如，如果我们将`sudo`设置为`yes`，`user`设置为`daniel`，将`sudo_user`设置为`kate`将导致Ansible在登录后使用`sudo`从`daniel`到`kate`。如果您在交互式SSH会话中执行此操作，我们可以在以`daniel`登录时使用`sudo
    -u kate`。'
- en: '| `connection` | This allows us to tell Ansible what transport to use to connect
    to the remote host. We will mostly use `ssh` or `paramiko` for remote hosts. However,
    we could also use `local` to avoid a connection overhead when running things on
    the `localhost`. Most of the time we will be using either `local`, `winrm` or
    `ssh` here. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `connection` | 这允许我们告诉Ansible要使用什么传输来连接到远程主机。我们将主要使用`ssh`或`paramiko`来连接远程主机。但是，当在`localhost`上运行时，我们也可以使用`local`来避免连接开销。大多数情况下，我们将在这里使用`local`、`winrm`或`ssh`。'
- en: '| `gather_facts` | Ansible will automatically run the setup module on the remote
    hosts unless we tell it not to. If we don''t need the variables from the setup
    module, we could set this now and save some time. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `gather_facts` | 除非我们告诉它不要这样做，否则Ansible将自动在远程主机上运行setup模块。如果我们不需要来自setup模块的变量，我们可以现在设置这个并节省一些时间。'
- en: The variable section
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量部分
- en: Here, we can define variables that apply to the entire play on all machines.
    We can also make Ansible prompt for variables if they weren't supplied on the
    command line. This allows us to make easily maintainable plays, and prevents us
    from changing the same thing in several parts of the play. This also allows us
    to have the entire configuration for the play stored at the top, where we can
    easily read and modify it without worrying about what the rest of the play does.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以定义适用于所有机器上整个play的变量。我们还可以让Ansible提示变量，如果它们没有在命令行上提供。这使我们可以轻松地维护play，并防止我们在play的几个部分中更改相同的内容。这也使我们可以将整个play的整个配置存储在顶部，这样我们可以轻松阅读和修改它，而不用担心play的其余部分。
- en: Variables in this section of a play can be overridden by machine facts (those
    that are set by modules), but they themselves override the facts we set in our
    inventory. So they are useful to define defaults that we might collect in a module
    later, but they can't be used to keep defaults for inventory variables as they
    will override those defaults.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: play中的这一部分变量可以被机器事实（由模块设置的事实）覆盖，但它们本身会覆盖我们在清单中设置的事实。因此，它们用于定义我们可能在稍后的模块中收集的默认值，但不能用于保留清单变量的默认值，因为它们将覆盖这些默认值。
- en: 'Variable declarations, which happen in the `vars` section, look like the values
    in the target section and contain a YAML dictionary or a list. An example looks
    like the following code snippet:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 变量声明发生在`vars`部分，看起来像目标部分中的值，并包含一个YAML字典或列表。一个例子看起来像以下代码片段：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Variables can also be loaded from external YAML files by giving Ansible a list
    of variable files to load. This is done in a similar way using the `vars_files`
    directive. Then simply provide the name of another YAML file that contains its
    own dictionary. This means that instead of storing the variables in the same file,
    they can be stored and distributed separately, allowing us to share our playbook
    with others.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也可以通过给Ansible提供要加载的变量文件列表来从外部YAML文件中加载。这是通过使用`vars_files`指令以类似的方式完成的。然后简单地提供另一个包含自己的字典的YAML文件的名称。这意味着，我们可以将变量存储和分发分开，从而可以与他人共享我们的playbook。
- en: 'Using `vars_files`, the files look like the following code snippet in our playbook:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`vars_files`，在我们的playbook中，文件看起来像以下代码片段：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the previous example, Ansible looks for `country-AU.yml`, `datacenter-SYD.yml`,
    and `cluster-mysql.yml` in the `conf` folder relative to the playbook path. Each
    YAML file looks similar to the following code snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，Ansible会在与playbook路径相关的`conf`文件夹中查找`country-AU.yml`、`datacenter-SYD.yml`和`cluster-mysql.yml`。每个YAML文件看起来类似于以下代码片段：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, we can make Ansible ask the user for each variable interactively. This
    is useful when we have variables that we don't want to make available for automation,
    and instead require human input. One example where this is useful is when prompting
    for the passphrases used to decrypt secret keys for the HTTPS servers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以让Ansible与用户交互地询问每个变量。当我们有不希望用于自动化的变量，并且需要人工输入时，这是很有用的。一个有用的例子是提示输入用于解密HTTPS服务器的秘密密钥的密码短语。
- en: 'We can instruct Ansible to prompt for variables with the following code snippet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码片段指示Ansible提示变量：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previous example, `https_passphrase` is where the entered data will be
    stored. The user will be prompted with `Key Passphrase`, and because `private`
    is set to `yes`, the value will not be printed on the screen as the user enters
    it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`https_passphrase`是输入数据将被存储的地方。用户将被提示输入`Key Passphrase`，因为`private`设置为`yes`，所以当用户输入时，值不会在屏幕上显示。
- en: We can use variables, facts, and inventory variables with the help of `{{ variablename
    }}`. We can even refer to complex variables, such as dictionaries, with a dotted
    notation. For example a variable named `httpd`, with a key in it named `maxclients`,
    will be accessed as `{{ httpd.maxclients }}`. This works with facts from the setup
    module too. For example, we can get the IPv4 address of a network interface named
    `eth0` using `{{ ansible_eth0.ipv4.address }}`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`{{ variablename }}`来使用变量、事实和清单变量。我们甚至可以使用点表示法引用复杂的变量，比如字典。例如，一个名为`httpd`的变量，其中有一个名为`maxclients`的键，将被访问为`{{
    httpd.maxclients }}`。这也适用于来自setup模块的事实。例如，我们可以使用`{{ ansible_eth0.ipv4.address
    }}`来获取名为`eth0`的网络接口的IPv4地址。
- en: Variables that are set in the variable section do not survive between different
    plays in the same playbook. However, facts gathered by the setup module or set
    by `set_fact` do. This means if we are running a second play on the same machines,
    or a subset of the machines in an earlier play, we can set `gather_facts` in the
    target section to `false`. The `setup` module can sometimes take a while to run,
    so this can dramatically speed up plays, especially in plays where the serial
    is set to a low value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量部分设置的变量在同一playbook中的不同play之间不会保留。但是，由setup模块收集的事实或由`set_fact`设置的事实会保留。这意味着如果我们在同一台机器上运行第二个play，或者在较早的play中运行机器的子集，我们可以在目标部分将`gather_facts`设置为`false`。`setup`模块有时可能需要一段时间才能运行，因此这可以显著加快play的速度，特别是在将串行设置为较低值的play中。
- en: The task section
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务部分
- en: 'The task section is the last section of each play. It contains a list of actions
    that we want Ansible to perform in the order we want them to be performed. There
    are several styles in which we can express each module''s arguments. We suggest
    you try to stick with one as much as possible, and use the others only when required.
    This makes our playbooks easier to read and maintain. The following code snippet
    is what a task section looks like with all three styles shown:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 任务部分是每个剧本的最后部分。它包含我们希望Ansible按照我们希望的顺序执行的操作列表。我们可以用几种风格来表达每个模块的参数。我们建议您尽可能坚持一种风格，并仅在必要时使用其他风格。这样可以使我们的playbooks更容易阅读和维护。以下代码片段展示了任务部分的三种风格：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we see the three different styles of syntax being used to install, configure,
    and start the Apache web server as it will look on a CentOS machine. The first
    task shows us how to install Apache using the original syntax, which requires
    us to call the module as the first keyword inside an `action` key. The second
    task copies Apache's configuration file into place using the second style of the
    task. In this style, use the module name in place of the `action` keyword and
    its value simply becomes its argument. Finally, the last task, the third style,
    shows how to use the service module to restart Apache. In this style, we use the
    module name as the key, as usual, but we supply the arguments as a YAML dictionary.
    This can come in handy when we are providing a large number of arguments to a
    single module, or if the module wants the arguments in a complex form, such as
    the cloud formation module. The latter style is quickly becoming the preferred
    way of writing playbooks, as an increasing number of modules require complex arguments.
    In this book, we will be using this style in order to save space for the examples
    and prevent line wrapping.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了三种不同的语法风格被用来在CentOS机器上安装、配置和启动Apache web服务器。第一个任务向我们展示了如何使用原始语法安装Apache，这需要我们在`action`关键字内部首先调用模块。第二个任务使用了第二种风格，将Apache的配置文件复制到指定位置。在这种风格中，使用模块名称代替`action`关键字，其值简单地成为其参数。最后，第三种风格的最后一个任务展示了如何使用服务模块来重新启动Apache。在这种风格中，我们像往常一样使用模块名称作为关键字，但我们将参数作为YAML字典提供。当我们向单个模块提供大量参数时，或者模块需要以复杂形式提供参数时，这种风格会很有用，比如云形成模块。后一种风格正在迅速成为编写playbooks的首选方式，因为越来越多的模块需要复杂的参数。在本书中，我们将使用这种风格，以节省示例的空间并防止行换行。
- en: Note that names are not required for tasks. However, they make good documentation
    and allow us to refer to each task later on, if required. This will become useful
    especially when we come to handlers. The names are also outputted to the console
    when the playbook is run, so that the user can tell what is happening. If we don't
    provide a name, Ansible will just use the action line of the task or the handler.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，任务不需要名称。但是，它们可以成为良好的文档，并且在需要时允许我们稍后引用每个任务。当运行playbook时，名称也会输出到控制台，以便用户了解发生了什么。如果我们不提供名称，Ansible将只使用任务或处理程序的动作行。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike other configuration management tools, Ansible does not provide a fully
    featured dependency system. This is a blessing and a curse; with a complete dependency
    system, we can get to a point where we are never quite sure what changes will
    be applied to a particular machine. Ansible, however, does guarantee that our
    changes will be executed in the order they are written. So, if one module depends
    on another module that is executed before it, simply place one before the other
    in the playbook.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他配置管理工具不同，Ansible不提供完整的依赖系统。这既是一种福音也是一种诅咒；有了完整的依赖系统，我们可能永远不确定对特定机器将应用哪些更改。然而，Ansible确保我们的更改将按照它们编写的顺序执行。因此，如果一个模块依赖于在其之前执行的另一个模块，只需在playbook中将一个放在另一个之前即可。
- en: The handlers section
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理程序部分
- en: The handlers section is syntactically the same as the task section and supports
    the same format for calling modules. Handlers are called only when the task they
    were called from, records that something changed during execution. To trigger
    a handler, add a notify key to the task with the value set to the name of the
    task.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序部分在语法上与任务部分相同，并支持调用模块的相同格式。只有当调用处理程序的任务在执行过程中记录到有变化发生时，处理程序才会被调用。要触发处理程序，向任务添加一个notify关键字，其值设置为任务的名称。
- en: 'Handlers are run if previously triggered when Ansible has finished running
    the task list. They are run in the order that they are listed in the handlers
    section, and even if they are called multiple times in the task section, they
    will run only once. This is often used to restart daemons after they have been
    upgraded and configured. The following play demonstrates how we will upgrade an
    **ISC** **DHCP** (**Dynamic Host Configuration Protocol**) server to the latest
    version, configure it, and set it to start at boot. If this playbook is run on
    a server where the ISC DHCP daemon is already running the latest version and the
    config files are not changed, the handler will not be called and DHCP will not
    be restarted. Consider the following code for example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当Ansible完成任务列表的运行时，处理程序将在先前触发时运行。它们按照处理程序部分中列出的顺序运行，即使它们在任务部分中被多次调用，它们也只会运行一次。这经常用于在升级和配置后重新启动守护程序。以下play演示了我们将如何将**ISC**
    **DHCP**（动态主机配置协议）服务器升级到最新版本、配置它并设置它在启动时启动。如果这个playbook在ISC DHCP守护程序已经运行最新版本并且配置文件没有改变的服务器上运行，处理程序将不会被调用，DHCP也不会被重新启动。例如，考虑以下代码：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Each handler can only be a single module, but we can notify a list of handlers
    from a single task. This allows us to trigger many handlers from a single step
    in the task list. For example, if we have just checked out a newer version of
    any Django application, we can set a handler to migrate the database, deploy the
    static files, and restart Apache. We can do this by simply using a YAML list on
    the notify action. This might look something like the following code snippet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个处理程序只能是一个单独的模块，但我们可以从单个任务中通知一系列处理程序。这使我们能够从任务列表中的单个步骤触发许多处理程序。例如，如果我们刚刚检出了任何Django应用的更新版本，我们可以设置一个处理程序来迁移数据库，部署静态文件并重新启动Apache。我们可以通过在通知操作上简单使用YAML列表来实现这一点。这可能看起来像以下代码片段：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see that the `git` module is used to check out some public GitHub code,
    and if that caused anything to change, it triggers the `migrate db`, `generate
    static`, and `restart httpd` actions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`git`模块用于检出一些公共GitHub代码，如果导致任何更改，它会触发`migrate db`、`generate static`和`restart
    httpd`操作。
- en: The playbook modules
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: playbook模块
- en: Using modules in playbooks is a little bit different from using them in the
    command line. This is mainly because we have many facts available from the previous
    modules and the `setup` module. Certain modules don't work in the Ansible command
    line because they require access to those variables. Other modules will work in
    the command-line version, but are able to provide enhanced functionalities when
    used in a playbook.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在playbooks中使用模块与在命令行中使用模块有一些不同。这主要是因为我们可以从先前的模块和`setup`模块中获得许多事实。某些模块在Ansible命令行中无法工作，因为它们需要访问这些变量。其他模块在命令行版本中可以工作，但在playbook中使用时可以提供增强功能。
- en: The template module
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板模块
- en: 'One of the most frequently used examples of a module that requires facts from
    Ansible is the `template` module. This module allows us to design an outline of
    a configuration file and then have Ansible insert values in the right places.
    To perform this, Ansible uses the Jinja2 templating language. In reality, the
    Jinja2 templates can be much more complicated than this, including things such
    as conditionals, `for` loops, and macros. The following is an example of a Jinja2
    configuration template for configuring BIND:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`template`模块是一个需要Ansible提供事实的最常用的模块之一。该模块允许我们设计配置文件的大纲，然后让Ansible在正确的位置插入值。为了实现这一点，Ansible使用Jinja2模板语言。实际上，Jinja2模板可以比这更复杂，包括条件语句、`for`循环和宏等内容。以下是一个用于配置BIND的Jinja2配置模板的示例：'
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By convention, Jinja2 templates are named with the file extension of `.j2`;
    however, this is not strictly required. Now let''s break this example down into
    its parts. The example starts with the following line of code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，Jinja2模板的文件扩展名为`.j2`；然而，这并不是严格要求的。现在让我们将这个示例分解成其各个部分。示例从以下代码行开始：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This line adds a comment at the top of the file that shows which template the
    file came from, the host, modification time of the template, and the owner. Putting
    this somewhere in the template as a comment is a good practice, and it ensures
    that people know what they should edit if they wish to alter it permanently.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行在文件顶部添加了一个注释，显示文件来自哪个模板、主机、模板的修改时间和所有者。将这些作为注释放在模板中是一个好的做法，它确保人们知道如果他们希望永久更改它们应该编辑什么。
- en: 'Later, on the fifth line, there is a `for` loop:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，在第五行，有一个`for`循环：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`For` loops go through all the elements of a list once for each item in the
    list. They optionally assign the item to the variable of our choice so that we
    can use it inside the loop. This one loops across all the values in `ansible_all_ipv4_addresses`,
    which is a list provided by the `setup` module that contains all the IPv4 addresses
    that the machine has. Inside the `for` loop, it simply adds each of them into
    the configuration to make sure BIND will listen on that interface.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`For`循环会遍历列表中的所有元素，每个元素遍历一次。它们可以选择将项目分配给我们选择的变量，以便我们可以在循环内部使用它。这个循环遍历`ansible_all_ipv4_addresses`中的所有值，这是由`setup`模块提供的一个列表，其中包含主机的所有IPv4地址。在`for`循环内部，它简单地将它们中的每一个添加到配置中，以确保BIND将在该接口上监听。'
- en: 'Comments are also possible in templates such as the one on line 24:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第24行的模板中也可以添加注释。
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Anything in between `{#` and `#}` is simply ignored by the Jinja2 template processor.
    This allows us to add comments in the template that do not make it into the final
    file. This is especially handy if we are doing something complicated, setting
    variables within the template, or if the configuration file does not allow comments.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`{#`和`#}`之间的任何内容都会被Jinja2模板处理器忽略。这使我们可以在模板中添加注释，而这些注释不会出现在最终文件中。如果我们正在做一些复杂的事情，在模板中设置变量，或者配置文件不允许注释，这是特别方便的。
- en: 'The next few lines are part of an `if` statement, which sets up `zone_type`
    and `zone_dir` variables for use later in the template:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行是`if`语句的一部分，为模板后面的使用设置了`zone_type`和`zone_dir`变量：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Anything between `{% if %}` and `{% else %}` is ignored if the statement in
    the `if` tag is `false`. Here we check whether the value `authorativenames` is
    in the list of group names that apply to this host. If this is `true`, the next
    two lines are set two custom variables. `zone_type` is set to master and `zone_dir`
    is set to data. If this host is not in the `authorativenames` group, `zone_type`
    and `zone_dir` will be set to `slave` and `slaves`, respectively.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`{% if %}`和`{% else %}`之间的任何内容，如果`if`标签中的语句为`false`，则会被忽略。在这里，我们检查值`authorativenames`是否在适用于此主机的组名称列表中。如果是`true`，则下面的两行将设置两个自定义变量。`zone_type`设置为master，`zone_dir`设置为data。如果此主机不在`authorativenames`组中，则`zone_type`和`zone_dir`将分别设置为`slave`和`slaves`。
- en: 'Finally, starting at line 33, we provide the actual configuration for the zone:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从第33行开始，我们提供了区域的实际配置：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We set the type to the `zone_type` variable we created earlier, and the location
    to `zone_dir`. Finally we check whether the zone type is a slave, and if it is,
    we configure its master to a particular IP address.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将类型设置为我们之前创建的`zone_type`变量，并将位置设置为`zone_dir`。最后，我们检查区域类型是否为从属，如果是，我们将其主配置为特定的IP地址。
- en: To get this template to set up an authoritative nameserver, we need to create
    a group in our inventory file named `authorativenames` and add some hosts under
    it. How to do this was discussed back in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Ansible"), *Getting Started with Ansible*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此模板设置权威名称服务器，我们需要在清单文件中创建一个名为`authorativenames`的组，并在其中添加一些主机。如何做到这一点在[第1章](ch01.html
    "第1章。开始使用Ansible")中已经讨论过，*开始使用Ansible*。
- en: 'We can simply call the `templates` module and the facts from the machines will
    be sent through, including the groups the machine is in. This is as simple as
    calling any other module. The `template` module also accepts similar arguments
    to the `copy` module such as owner, group, and mode. Consider the following code
    for example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地调用`templates`模块和机器的事实将被发送，包括机器所在的组。这就像调用任何其他模块一样简单。`template`模块还接受类似`copy`模块的参数，如owner、group和mode。例如考虑以下代码：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The set_fact module
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: set_fact模块
- en: The `set_fact` module allows us to build our own facts on the machine inside
    an Ansible play. These facts can then be used inside templates or as variables
    in the playbook. Facts act just like arguments that come from modules such as
    the `setup` module, in that they work on a per-host basis. We should use this
    to avoid putting complex logic into templates. For example, if we are trying to
    configure a buffer to take a certain percentage of RAM, we should calculate the
    value in the playbook.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_fact`模块允许我们在Ansible play中在机器上构建自己的事实。然后可以在模板中使用这些事实或作为playbook中的变量。事实就像来自`setup`模块等模块的参数一样，它们是基于每个主机的。我们应该使用这个来避免将复杂的逻辑放入模板中。例如，如果我们试图配置一个缓冲区以占用内存的一定百分比，我们应该在playbook中计算该值。'
- en: 'The following example shows how to use `set_fact` to configure a MySQL server
    to have an InnoDB buffer size of approximately half of the total RAM available
    on the machine:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何使用`set_fact`来配置MySQL服务器，使其具有大约机器上可用总内存的一半的InnoDB缓冲区大小：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first task here simply installs MySQL using yum. The second task creates
    a fact by getting the total memory of the managed machine, dividing it by two,
    losing any non-integer remainder, and putting it in a fact called `innodb_buffer_pool_size_mb`.
    The next line then loads a template into `/etc/my.cnf` to configure MySQL. Finally,
    MySQL is started and set to start at boot time. A handler is also included to
    restart MySQL when its configuration changes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个任务只是使用yum安装MySQL。第二个任务通过获取受管机器的总内存，除以二，去除任何非整数余数，并将其放入名为`innodb_buffer_pool_size_mb`的事实中。然后下一行将一个模板加载到`/etc/my.cnf`中以配置MySQL。最后，启动MySQL并设置为在启动时启动。还包括一个处理程序，以在其配置更改时重新启动MySQL。
- en: 'The template then only needs to get the value of `innodb_buffer_pool_size`
    and place it into the configuration. This means we can re-use the same template
    in places where the buffer pool should be one-fifth of the RAM, or one-eighth,
    and simply change the playbook for those hosts. In this case, the template will
    look something like the following code snippet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后模板只需要获取`innodb_buffer_pool_size`的值并将其放入配置中。这意味着我们可以在缓冲池应该是内存的五分之一或八分之一的地方重复使用相同的模板，并简单地更改那些主机的playbook。在这种情况下，模板将看起来像以下代码片段：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can see that in the previous template, we are simply putting the variables
    we get from the play into the template. If the template doesn't see the `innodb_buffer_pool_size_mb`
    fact, it simply uses a default of `128`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在前面的模板中，我们只是将play中获取的变量放入模板中。如果模板没有看到`innodb_buffer_pool_size_mb`事实，它将简单地使用默认值`128`。
- en: The pause module
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂停模块
- en: The `pause` module stops the execution of a playbook for a certain period of
    time. We can configure it to wait for a particular period, or we can make it prompt
    for the user to continue. While effectively useless when used from the Ansible
    command line, it can be very handy when used inside a playbook.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`pause`模块停止playbook的执行一段时间。我们可以配置它等待一段特定的时间，或者我们可以让它提示用户继续。当从Ansible命令行使用时实际上是无用的，但在playbook中使用时非常方便。'
- en: Generally, the `pause` module is used when we want the user to provide confirmation
    to continue, or if manual intervention is required at a particular point. For
    example, if we have just deployed a new version of a web application to a server,
    and we need to have the user check manually to make sure it looks okay before
    we configure them to receive production traffic, we can put a pause there. It
    is also handy to warn the user of a possible problem and give them the option
    of continuing. This will make Ansible print out the names of the servers and ask
    the user to press *Enter* to continue. If used with the serial key in the target
    section, it will ask once for each group of hosts that Ansible is running on.
    This way we can give the user the flexibility of running the deployment at our
    own pace while they interactively monitor the progress.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们希望用户确认后继续，或者在特定点需要手动干预时，会使用`pause`模块。例如，如果我们刚刚将新版本的Web应用部署到服务器上，并且需要用户手动检查以确保它看起来正常，然后再配置它们接收生产流量之前，我们可以在那里设置一个暂停。它还可以方便地警告用户可能出现的问题，并给他们继续的选项。这将使Ansible打印出服务器的名称，并要求用户按*Enter*键继续。如果与目标部分中的serial键一起使用，它将针对Ansible正在运行的每组主机询问一次。这样，我们可以让用户以自己的节奏运行部署，同时他们可以交互式地监视进度。
- en: 'Less usefully, this module can simply wait for a specified period of time.
    This is not useful always as we usually don''t know how long a particular action
    might take, and guessing might have disastrous outcomes. We should not use it
    for waiting for networked daemons to start up; instead we should use the `wait_for`
    module (described in the next section) for this task. The following play demonstrates
    using the `pause` module first in the user interactive mode and then in the timed
    mode:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 不太有用的是，此模块可以简单地等待指定的一段时间。这并不总是有用，因为通常我们不知道特定操作可能需要多长时间，猜测可能会产生灾难性的结果。我们不应该用它来等待网络守护程序启动；相反，我们应该使用`wait_for`模块（在下一节中描述）来执行此任务。以下播放首先演示了在用户交互模式和定时模式中使用`pause`模块：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The wait_for module
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: wait_for模块
- en: The `wait_for` module is used to poll a particular TCP port and not continue
    until that port accepts a remote connection. The polling is done from the remote
    machine. If we only provide a port, or set the host argument to `localhost`, the
    poll will try to connect to the managed machine. We can utilize `local_action`
    to run the command from the controller machine and use the `ansible_hostname`
    variable as our host argument to make it try and connect to the managed machine
    from the controller machine.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait_for`模块用于轮询特定的TCP端口，并且直到该端口接受远程连接后才继续执行。轮询是从远程机器进行的。如果我们只提供一个端口，或者将主机参数设置为`localhost`，则轮询将尝试连接到受控机器。我们可以利用`local_action`从控制器机器运行命令，并使用`ansible_hostname`变量作为我们的主机参数，使其尝试从控制器机器连接到受控机器。'
- en: 'This module is particularly useful for daemons that can take a while to start,
    or things that we want to run in the background. Apache Tomcat ships with an init
    script, which immediately returns when we try to start it, leaving Tomcat starting
    in the background. Depending on the application that Tomcat is configured to load,
    it might take anywhere between two seconds to 10 minutes to fully start up and
    be ready for connections. We can time our application''s start up and use the
    `pause` module. However, the next deployment might take longer or shorter, and
    this will break our deployment mechanism. With the `wait_for` module, we have
    Ansible to recognize when Tomcat is ready to accept connections. The following
    is a play that does exactly this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块特别适用于需要一段时间才能启动的守护程序，或者我们希望在后台运行的事物。Apache Tomcat附带一个init脚本，当我们尝试启动它时，它会立即返回，使Tomcat在后台启动。根据Tomcat配置加载的应用程序，它可能需要2秒到10分钟不等的时间才能完全启动并准备好接受连接。我们可以计时应用程序的启动并使用`pause`模块。然而，下一次部署可能需要更长或更短的时间，这将破坏我们的部署机制。使用`wait_for`模块，我们可以让Ansible识别Tomcat何时准备好接受连接。以下是一个执行此操作的播放：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After the completion of this play, Tomcat should be installed, started, and
    ready to accept requests. We can append further modules to this example and depend
    on Tomcat being available and listening.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在此播放完成后，Tomcat应该已安装、启动并准备好接受请求。我们可以在此示例中追加更多模块，并依赖于Tomcat可用并监听。
- en: The assemble module
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: assemble模块
- en: 'The `assemble` module combines several files on the managed machine and saves
    them to another file on the managed machine. This is useful in playbooks when
    we have a `config` file which does not allow includes or globbing in its includes.
    This is useful for the `authorized_keys` file for say, the root user. The following
    play will send a bunch of SSH public keys to the managed machine, then make it
    assemble them all together and place it in the root user''s home directory:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`assemble`模块将受控机器上的多个文件组合在一起，并将它们保存到受控机器上的另一个文件中。在playbooks中，当我们有一个`config`文件不允许包含或在其包含中使用通配符时，这是有用的。对于例如root用户的`authorized_keys`文件非常有用。以下播放将发送一堆SSH公钥到受控机器，然后让它将它们全部组合在一起并放置在root用户的主目录中：'
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By now, this should all look familiar. We might note the `with_items` key in
    the task that copies the keys over, and the `{{ items }}` variable. These will
    be explained later in [Chapter 3](ch03.html "Chapter 3. Advanced Playbooks"),
    *Advanced Playbooks*, but all we need to know now is that whatever item we supply
    to the `with_items` key is substituted into the `{{ items }}` variable, similar
    to how a `for` loop works. This simply lets us easily copy many files to the remote
    host at once.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这一切应该看起来很熟悉。我们可能会注意到任务中的`with_items`键以及`{{ items }}`变量。这些将在[第3章](ch03.html
    "第3章.高级Playbooks")中稍后解释，但现在我们需要知道的是，我们提供给`with_items`键的任何项目都将替换为`{{ items }}`变量，类似于`for`循环的工作方式。这简单地让我们一次轻松地将多个文件复制到远程主机。
- en: The last task shows the usage of the `assemble` module. We pass the directory
    containing the files to be concatenated into the output as the `src` argument,
    and then pass `dest` as the output file. It also accepts many of the same arguments
    (`owner`, `group`, and `mode`) as the other modules that create files. It also
    combines the files in the same order as the `ls -1` command lists them. This means
    we can use the same approach as `udev` and `rc.d`, and prepend numbers to the
    files to ensure that they end up in the correct order.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个任务展示了`assemble`模块的用法。我们将包含要连接到输出中的文件的目录作为`src`参数传递，然后将`dest`作为输出文件传递。它还接受许多创建文件的其他模块相同的参数（`owner`、`group`和`mode`）。它还按照`ls
    -1`命令列出的顺序组合文件。这意味着我们可以使用与`udev`和`rc.d`相同的方法，并在文件前面添加数字，以确保它们以正确的顺序结束。
- en: The add_host module
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: add_host模块
- en: The `add_host` module is one of the most powerful modules that are available
    in playbooks. `add_host` lets us dynamically add new machines inside a play. We
    can do this using the `uri` module to get a host from our **Configuration Management
    Database** (**CMDB**) and then adding it to the current play. This module will
    also add our host to a group, dynamically creating that group if it does not already
    exist.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_host`模块是playbook中可用的最强大的模块之一。`add_host`让我们可以在play中动态添加新的机器。我们可以使用`uri`模块从我们的**配置管理数据库**（**CMDB**）中获取主机，然后将其添加到当前play中。该模块还会将我们的主机添加到一个组中，如果该组尚不存在，则动态创建该组。'
- en: The module simply takes a `name` and a `groups` argument, which are rather self-explanatory,
    and sets the hostname and groups. We can also send extra arguments, and these
    are treated in the same way in which extra values in the inventory file are treated.
    This means we can set `ansible_ssh_user`, `ansible_ssh_port`, and so on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块简单地接受`name`和`groups`参数，这些参数相当不言自明，并设置主机名和组。我们还可以发送额外的参数，这些参数的处理方式与清单文件中的额外值的处理方式相同。这意味着我们可以设置`ansible_ssh_user`、`ansible_ssh_port`等。
- en: 'If we are using a cloud provider, such as RackSpace or Amazon EC2, there are
    modules available in Ansible that will let us manage our compute resources. We
    might decide to create machines at the start of the play, if we can''t find them
    in the inventory. If we do this, we can use this module to add the machines to
    the inventory so that we can configure them later. Here is an example of using
    Google Compute Modules to do this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用云提供商，如RackSpace或Amazon EC2，Ansible中有可用的模块可以让我们管理计算资源。如果我们找不到它们在清单中，我们可能会决定在play开始时创建机器。如果我们这样做，我们可以使用此模块将机器添加到清单中，以便稍后对其进行配置。以下是使用Google
    Compute模块执行此操作的示例：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The group_by module
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: group_by模块
- en: In addition to creating hosts dynamically in our play, we can also create groups.
    The `group_by` module can create groups based on the facts about the machines,
    including the ones we set up ourselves using the `add_fact` module explained earlier.
    The `group_by` module accepts one argument, `key`, which takes the name of a group
    the machine will be added to. By combining this with the use of variables, we
    can make the module add a server to a group based on its operating system, virtualization
    technology, or any other fact that we have access to. We can then use this group
    in the target section of any subsequent plays, or in templates.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在play中动态创建主机，我们还可以创建组。`group_by`模块可以根据关于机器的事实创建组，包括我们使用之前解释的`add_fact`模块设置的事实。`group_by`模块接受一个参数`key`，它接受机器将被添加到的组的名称。通过将其与变量的使用结合起来，我们可以使模块根据其操作系统、虚拟化技术或我们可以访问的任何其他事实将服务器添加到组中。然后我们可以在任何后续play的目标部分或模板中使用此组。
- en: 'So if we want to create a group that groups the hosts by the operating system,
    we will call the module as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想创建一个根据操作系统对主机进行分组的组，我们将调用该模块如下：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can then use these groups to install packages using the right packager.
    In practice, this is often used to avoid Ansible outputting lots of "skipped"
    messages while it is executing. Instead of adding `when` clauses to each task
    that needs to be skipped, we can create a group for machines where the action
    should happen and then use a separate play to configure those machines separately.
    Here is an example of installing an ssl private key across Debian and RedHat machines
    without using a `when` clause:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用这些组来使用正确的打包程序安装软件包。在实践中，这经常用于避免Ansible在执行时输出大量的“跳过”消息。我们可以创建一个组，用于应该发生操作的机器，而不是为每个需要跳过的任务添加`when`子句，然后使用一个单独的play来单独配置这些机器。以下是在不使用`when`子句的情况下在Debian和RedHat机器上安装ssl私钥的示例：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The slurp module
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: slurp模块
- en: The `slurp` module grabs a file from the remote system, encodes it with base
    64, and then returns the result. We can utilize the register keyword in order
    to place the contents into a fact. When using the `slurp` module to fetch files,
    we should be wary of the file size. This module loads the entire file into memory,
    so using `slurp` with large files can consume all available RAM and cause our
    system to crash. Files also need to be transferred from the managed machine to
    the controller machine, and for large files, this could take a considerable amount
    of time.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`slurp`模块从远程系统抓取文件，使用base 64对其进行编码，然后返回结果。我们可以利用register关键字将内容放入事实中。在使用`slurp`模块获取文件时，我们应该注意文件大小。该模块将整个文件加载到内存中，因此使用`slurp`处理大文件可能会消耗所有可用的RAM并导致系统崩溃。文件还需要从受控机器传输到控制器机器，对于大文件，这可能需要相当长的时间。'
- en: 'Combining this module with the copy module provides a way to copy files between
    two machines. This is demonstrated in the following playbook:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将此模块与复制模块结合使用可以在两台机器之间复制文件。这在以下playbook中进行了演示：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that because the `slurp` module encodes the data with base 64, we have
    to use the jinja2 filter named `b64decode` to decode the data before the copy
    module can use it. Filters will be covered in more detail in [Chapter 3](ch03.html
    "Chapter 3. Advanced Playbooks"), *Advanced Playbooks*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于`slurp`模块使用base 64对数据进行编码，因此我们必须使用名为`b64decode`的jinja2过滤器来在复制模块使用数据之前对数据进行解码。过滤器将在[第3章](ch03.html
    "第3章.高级Playbooks")*高级Playbooks*中进行更详细的介绍。
- en: Windows playbook modules
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows playbook modules
- en: Windows support is new to Ansible and as such, there aren't many modules available
    for it. Modules that are windows only are named beginning with `win_`. There are
    also a few modules available, which work on both Windows and Unix systems such
    as the `slurp` module, which we covered earlier.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Windows支持是Ansible的新功能，因此没有为其提供许多模块。仅适用于Windows的模块以`win_`开头命名。还有一些可用的模块，可以在Windows和Unix系统上使用，例如我们之前介绍的`slurp`模块。
- en: 'Extra care should be taken in Windows modules to quote the path strings. Backslashes
    are an important character in both YAML, where they escape characters and in windows
    paths, where they denote directories. Because of this, YAML might confuse parts
    of our paths for escape sequences. To prevent this, we use single quotes on our
    strings. Additionally, if our path is a directory itself, we should leave off
    the trailing backspace so that YAML doesn''t confuse the end of the string with
    an escape sequence. If we have to end our path with a backslash, make it a double
    backslash, and the second one will be ignored. The following are some examples
    of correct and incorrect strings:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows模块中，需要特别注意引用路径字符串。反斜杠是YAML中的重要字符，它们用于转义字符，并且在Windows路径中，它们表示目录。因此，YAML可能会将我们路径的某些部分误解为转义序列。为了防止这种情况，我们在字符串上使用单引号。此外，如果我们的路径本身是一个目录，我们应该省略尾随的反斜杠，以便YAML不会将字符串的结尾误解为转义序列。如果我们必须以反斜杠结尾，那么将其变为双反斜杠，第二个将被忽略。以下是一些正确和不正确的字符串示例：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Cloud Infrastructure modules
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云基础设施模块
- en: Infrastructure modules allow us to not only manage the setup of our machines,
    but also the creation of those machines themselves. Apart from this, we can also
    automate much of the infrastructure surrounding them. This can be used as a simple
    replacement for services such as Amazon Cloud Formation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施模块不仅允许我们管理机器的设置，还允许我们创建这些机器本身。除此之外，我们还可以自动化围绕它们的大部分基础设施。这可以作为对亚马逊云形成等服务的简单替代。
- en: When creating machines that we want to manage in a later play in the same playbook,
    we will want to use the `add_hosts` module that we discussed earlier in the chapter
    to add the machine to the in-memory inventory so that it can be the target of
    further plays. We might also wish to run the `group_by` module to arrange them
    into groups as we would arrange other machines. The `wait_for` module should also
    be used to check that the machine is responding to SSH connections before trying
    to manage it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们希望在同一playbook中的后续play中管理的机器时，我们将希望使用`add_hosts`模块将机器添加到内存中的清单中，以便它可以成为进一步play的目标。我们可能还希望运行`group_by`模块，将它们排列成我们将其他机器排列的组。还应该使用`wait_for`模块来检查机器是否响应SSH连接，然后再尝试管理它。
- en: The Cloud Infrastructure modules can be a bit complicated to use, so we will
    be showing how to setup and install the Amazon modules. For details on how to
    configure the other modules, see their documentation using `ansible-doc`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 云基础设施模块可能有点复杂，因此我们将展示如何设置和安装Amazon模块。有关如何配置其他模块的详细信息，请参阅其文档，使用`ansible-doc`。
- en: The AWS modules
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS模块
- en: The AWS modules work similar to how most AWS tools work. This is because they
    use the python **boto** library, which is popular with many other tools and follows
    the conventions of the original AWS tools that were released by Amazon.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: AWS模块的工作方式类似于大多数AWS工具的工作方式。这是因为它们使用了流行的python **boto**库，该库与许多其他工具一起使用，并遵循了亚马逊发布的原始AWS工具的约定。
- en: 'It is best to install boto the same way that we installed Ansible. For most
    use cases, we will be running the module on the managed machine, so we will only
    need to install the boto module there. We can install the boto library in the
    following ways:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最好以与我们安装Ansible相同的方式安装boto。对于大多数用例，我们将在托管的机器上运行模块，因此我们只需要在那里安装boto模块。我们可以以以下方式安装boto库：
- en: 'Centos/RHEL/Fedora: `yum install python-boto`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Centos/RHEL/Fedora: `yum install python-boto`'
- en: 'Ubuntu: `apt-get install python-boto`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ubuntu: `apt-get install python-boto`'
- en: 'Pip: `pip install boto`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Pip: `pip install boto`'
- en: 'Then we need to setup the correct environment variables. The easiest way to
    do this is by running the modules using the localhost connection on our local
    machine. If we do this, then the variables from our shell are passed through and
    automatically become available to the Ansible module. Here, are the variables
    that the boto library uses to connect to AWS:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要设置正确的环境变量。最简单的方法是在本地机器上使用localhost连接运行模块。如果我们这样做，那么我们的shell中的变量将被传递并自动可用于Ansible模块。这里是boto库用于连接到AWS的变量：
- en: '| Variable Name | Description |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 变量名 | 描述 |'
- en: '| --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `AWS_ACCESS_KEY` | This is the access key for a valid IAM account |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `AWS_ACCESS_KEY` | 这是有效IAM帐户的访问密钥 |'
- en: '| `AWS_SECRET_KEY` | This is the secret key corresponding to the access key
    above |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `AWS_SECRET_KEY` | 这是对应于上面访问密钥的秘密密钥 |'
- en: '| `AWS_REGION` | This is the default region to use unless overridden |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `AWS_REGION` | 这是默认区域，除非被覆盖 |'
- en: 'We can set these environment variables in our example using the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码在我们的示例中设置这些环境变量：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'These are just example credentials and will not work. Once we have these set,
    we can then use the AWS modules. In the next block of code, we combine several
    modules from this chapter to create a machine and add it to the inventory. Several
    features not yet discussed, such as `register` and `delegate_to`, are used in
    the following example, which will be covered in [Chapter 3](ch03.html "Chapter 3. Advanced
    Playbooks"), *Advanced Playbooks*:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是示例凭据，不起作用。一旦我们设置好这些，我们就可以使用AWS模块。在下一段代码中，我们将结合本章的几个模块来创建一个机器并将其添加到清单中。以下示例中使用了一些尚未讨论的功能，比如`register`和`delegate_to`，这些将在[第3章](ch03.html
    "第3章.高级Playbooks") *高级Playbooks*中介绍：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the sections that are available in the playbook
    file. We also learned how to use variables to make our playbooks maintainable,
    how to trigger handlers when changes have been made, and finally, we looked at
    how certain modules are more useful when used inside a playbook. You can explore
    further modules provided with Ansible using the official documentation at [http://docs.ansible.com/modules_by_category.html](http://docs.ansible.com/modules_by_category.html).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了playbook文件中可用的部分。我们还学习了如何使用变量使我们的playbooks易于维护，如何在进行更改时触发处理程序，最后，我们看了一下在playbook中使用某些模块时更有用的一些模块。您可以使用官方文档进一步探索Ansible提供的模块，网址为[http://docs.ansible.com/modules_by_category.html](http://docs.ansible.com/modules_by_category.html)。
- en: In the next chapter, we will be looking into the more complex features of playbooks.
    This will allow us to build more complex playbooks capable of deploying and configuring
    entire systems.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究playbooks的更复杂功能。这将使我们能够构建更复杂的playbooks，能够部署和配置整个系统。
