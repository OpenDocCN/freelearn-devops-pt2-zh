- en: Securing Applications and Clusters
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 保护应用程序和集群
- en: 00000000000000In this chapter, we will discuss the fundamental steps of reducing
    the attack surface and securing Kubernetes clusters before we go live from test
    to production. We will talk about security auditing, building DevSecOps into CI/CD
    pipelines, detecting metrics for performance analysis, and how to securely manage
    secrets and credentials.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 00000000000000在本章中，我们将讨论在从测试到生产的过程中，减少攻击面和保护Kubernetes集群的基本步骤。我们将讨论安全审计，将DevSecOps构建到CI/CD流水线中，检测性能分析的指标，以及如何安全地管理秘密和凭据。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Using RBAC to harden cluster security
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RBAC加固集群安全
- en: Configuring Pod Security Policies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Pod安全策略
- en: Using Kubernetes CIS Benchmark for security auditing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes CIS基准进行安全审计
- en: Building DevSecOps into the pipeline using Aqua Security
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将DevSecOps构建到流水线中，使用Aqua Security
- en: Monitoring suspicious application activities using Falco
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Falco监视可疑的应用程序活动
- en: Securing credentials using HashiCorp Vault
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HashiCorp Vault安全保护凭据
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The recipes in this chapter require that you have a functional Kubernetes cluster
    deployed by following one of the recommended methods described in [Chapter 1](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml),
    *Building Production-Ready Kubernetes Clusters*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的配方要求您通过遵循[第1章](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml)中描述的建议方法之一部署了功能齐全的Kubernetes集群，*构建生产就绪的Kubernetes集群*。
- en: The Kubernetes command-line tool, `kubectl` ,will be used for the rest of the
    recipes in this chapter since it's the main command-line interface for running
    commands against Kubernetes clusters. We will also use `helm` where Helm charts
    are available to deploy solutions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes命令行工具`kubectl`将用于本章中其余的配方，因为它是针对Kubernetes集群运行命令的主要命令行界面。我们还将使用`helm`，在那里Helm图表可用于部署解决方案。
- en: Using RBAC to harden cluster security
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RBAC加固集群安全
- en: In a complex system such as Kubernetes, authorization mechanisms are used to
    set who is allowed to make what changes to the cluster resources and manipulate
    them. **Role-based access control** (**RBAC**) is a mechanism that's highly integrated
    into Kubernetes that grants users and applications granular access to Kubernetes
    APIs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在诸如Kubernetes之类的复杂系统中，授权机制用于设置谁被允许对集群资源进行何种更改并操纵它们。**基于角色的访问控制**（**RBAC**）是一种高度集成到Kubernetes中的机制，它授予用户和应用程序对Kubernetes
    API的细粒度访问权限。
- en: As good practice, you should use the Node and RBAC authorizers together with
    the `NodeRestriction` admission plugin.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为良好的实践，您应该与`NodeRestriction`准入插件一起使用Node和RBAC授权器。
- en: In this section, we will cover getting RBAC enabled and creating Roles and RoleBindings
    to grant applications and users access to the cluster resources.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何启用RBAC并创建角色和角色绑定，以授予应用程序和用户对集群资源的访问权限。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have an RBAC-enabled Kubernetes cluster ready (since Kubernetes
    1.6, RBAC is enabled by default) and that `kubectl` and `helm` have been configured
    so that you can manage the cluster resources. Creating private keys will also
    require that you have the `openssl` tool before you attempt to create keys for
    users.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已准备好启用RBAC的Kubernetes集群（自Kubernetes 1.6以来，默认情况下已启用RBAC），并且已配置`kubectl`和`helm`，以便您可以管理集群资源。在尝试为用户创建密钥之前，还需要确保您拥有`openssl`工具来创建私钥。
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation to use the
    manifest files IN the `chapter9` directory, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将`k8sdevopscookbook/src`存储库克隆到您的工作站，以便在`chapter9`目录中使用清单文件，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: RBAC is enabled by default starting with Kubernetes 1.6\. If it is disabled
    for any reason, start the API server with `--authorization-mode=RBAC` to enable
    RBAC.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC从Kubernetes 1.6版本开始默认启用。如果由于任何原因禁用了RBAC，请使用`--authorization-mode=RBAC`启动API服务器以启用RBAC。
- en: How to do it…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'This section is further divided into the following subsections to make this
    process easier:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本节进一步分为以下子节，以使此过程更容易：
- en: Viewing the default Roles
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看默认角色
- en: Creating user accounts
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户帐户
- en: Creating Roles and RoleBindings
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建角色和角色绑定
- en: Testing the RBAC rules
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试RBAC规则
- en: Viewing the default Roles
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看默认角色
- en: RBAC is a core component of the Kubernetes cluster that allows us to create
    and grant roles to objects and control access to resources within the cluster.
    This recipe will help you understand the content of roles and role bindings.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC是Kubernetes集群的核心组件，允许我们创建和授予对象角色，并控制对集群内资源的访问。这个步骤将帮助您了解角色和角色绑定的内容。
- en: 'Let''s perform the following steps to view the default roles and role bindings
    in our cluster:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来查看我们集群中的默认角色和角色绑定：
- en: 'View the default cluster roles using the following command. You will see a
    long mixed list of `system:`, `system:controller:`, and a few other prefixed `roles. system:*`
    roles are used by the infrastructure, `system:controller`  roles are used by a
    Kubernetes controller manager, which is a control loop that watches the shared
    state of the cluster. In general, they are both good to know about when you need
    to troubleshoot permission issues, but they''re not something we will be using
    very often:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令查看默认的集群角色。您将看到一个长长的混合列表，其中包括`system:`、`system:controller:`和一些其他带有前缀的角色。`system:*`角色由基础设施使用，`system:controller`角色由Kubernetes控制器管理器使用，它是一个监视集群共享状态的控制循环。一般来说，当您需要解决权限问题时，了解它们都是很好的，但我们不会经常使用它们：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'View one of the system roles owned by Kubernetes to understand their purpose
    and limits. In the following example, we''re looking at `system:node`, which defines
    the permission for kubelets. In the output in Rules, `apiGroups:` indicates the
    core API group, `resources` indicates the Kubernetes resource type, and `verbs` indicates
    the API actions allowed on the role:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看由Kubernetes拥有的系统角色之一，以了解它们的目的和限制。在下面的示例中，我们正在查看`system:node`，它定义了kubelet的权限。在规则的输出中，`apiGroups:`表示核心API组，`resources`表示Kubernetes资源类型，`verbs`表示角色上允许的API操作：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s view the default user-facing roles since they are the ones we are more
    interested in. The roles that don''t have the `system:` prefix are intended to
    be user-facing roles. The following command will only list the non-system: prefix
    roles. The main roles that are intended to be granted within a specific namespace
    using RoleBindings are the `admin`, `edit`, and `view` roles:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们查看默认的用户角色，因为它们是我们更感兴趣的角色。没有`system:`前缀的角色是面向用户的角色。以下命令将仅列出非`system:`前缀的角色。通过RoleBindings在特定命名空间中授予的主要角色是`admin`、`edit`和`view`角色：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, review the default cluster binding, that is, `cluster-admin`, using the
    following command. You will see that this binding gives the `system:masters` group
    cluster-wide superuser permissions with the `cluster-admin` role:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令查看默认的集群绑定，即`cluster-admin`。您将看到此绑定使用`cluster-admin`角色为`system:masters`组提供了集群范围的超级用户权限：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since the Kubernetes 1.6 release, RBAC is enabled by default and new users can
    be created and start with no permissions until permissions are assigned by an
    admin user to a specific resource. Now, you know about the available default roles.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 自Kubernetes 1.6版本发布以来，默认情况下启用了RBAC，并且新用户可以创建并在管理员用户将权限分配给特定资源之前不具备任何权限。现在，您已经了解了可用的默认角色。
- en: In the following recipes, you will learn how to create new Roles and RoleBindings
    and grant accounts the permissions that they need.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的教程中，您将学习如何创建新的角色和角色绑定，并授予帐户所需的权限。
- en: Creating user accounts
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户帐户
- en: As explained in the Kubernetes docs, Kubernetes doesn't have objects to represent
    normal user accounts. Therefore, they need to be managed externally (check the *Kubernetes
    Authentication* documentation in the *See also* section for more details). This
    recipe will show you how to create and manage user accounts using private keys.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Kubernetes文档中所解释的，Kubernetes没有用于表示普通用户帐户的对象。因此，它们需要在外部进行管理（查看*参见*部分的*Kubernetes身份验证*文档，以获取更多详细信息）。本教程将向您展示如何使用私钥创建和管理用户帐户。
- en: 'Let''s perform the following steps to create a user account:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来创建一个用户帐户：
- en: 'Create a private key for the example user. In our example, the key file is
    `user3445.key`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为示例用户创建一个私钥。在我们的示例中，密钥文件是`user3445.key`：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a **certificate sign request** (**CSR**) called `user3445.csr` using
    the private key we created in *Step 1*. Set the username (`/CN`) and group name
    (`/O`) in the `-subj` parameter. In the following example, the username is `john.geek`,
    while the group is `development`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`user3445.csr`的**证书签名请求**（**CSR**），使用我们在*步骤1*中创建的私钥。在`-subj`参数中设置用户名（`/CN`）和组名（`/O`）。在以下示例中，用户名是`john.geek`，而组名是`development`：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To use the built-in signer, you need to locate the cluster-signing certificates
    for your cluster. By default, the `ca.crt` and `ca.key` files should be in the
    `/etc/kubernetes/pki/` directory.If you are using kops to deploy, your cluster
    signing keys can be downloaded from `s3://$BUCKET_NAME/$KOPS_CLUSTER_NAME/pki/private/ca/*.key`
    and `s3://$BUCKET_NAME/$KOPS_CLUSTER_NAME/pki/issued/ca/*.crt`. Once you''ve located
    the keys, change the `CERT_LOCATION` mentioned in the following code to the current
    location of the files and generate the final signed certificate:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用内置签名者，您需要定位集群的集群签名证书。默认情况下，`ca.crt`和`ca.key`文件应位于`/etc/kubernetes/pki/`目录中。如果您正在使用kops进行部署，您可以从`s3://$BUCKET_NAME/$KOPS_CLUSTER_NAME/pki/private/ca/*.key`和`s3://$BUCKET_NAME/$KOPS_CLUSTER_NAME/pki/issued/ca/*.crt`下载集群签名密钥。一旦您找到了密钥，将以下代码中提到的`CERT_LOCATION`更改为文件的当前位置，并生成最终签名证书：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If all the files have been located, the command in *Step 3* should return an
    output similar to the following:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有文件都已找到，*步骤3*中的命令应返回类似以下的输出：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Before we move on, make sure you store the signed keys in a safe directory.
    As an industry best practice, using a secrets engine or Vault storage is recommended.
    You will learn more about Vault storage later in this chapter IN the *Securing
    credentials using HashiCorp Vault* recipe.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，请确保将签名密钥存储在安全的目录中。作为行业最佳实践，建议使用秘密引擎或Vault存储。您将在本章后面的*使用HashiCorp Vault保护凭据*中了解有关Vault存储的更多信息。
- en: 'Create a new context using the new user credentials:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新用户凭据创建一个新的上下文：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'List the existing context using the following comment. You will see that the
    new `user3445-context` has been created:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令列出现有上下文。您将看到已创建新的`user3445-context`：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, try to list the pods using the new user context. You will get an access
    denied error since the new user doesn''t have any roles and new users don''t come
    with any roles assigned to them by default:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试使用新用户上下文列出pod。由于新用户没有任何角色，并且新用户默认情况下没有分配任何角色，因此您将收到访问被拒绝的错误：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Optionally, you can `base64` encode all three files (`user3445.crt`, `user3445.csr`,
    and `user3445.key`) using the `openssl base64 -in <infile> -out <outfile>` command
    and distribute the populated `config-user3445.yml` file to your developers. An
    example file can be found in this book''s GitHub repository in the `src/chapter9/rbac`
    directory. There are many ways to distribute user credentials. Review the example
    using your text editor:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，您可以使用`openssl base64 -in <infile> -out <outfile>`命令对所有三个文件（`user3445.crt`，`user3445.csr`和`user3445.key`）进行`base64`编码，并将填充的`config-user3445.yml`文件分发给您的开发人员。示例文件可以在本书的GitHub存储库的`src/chapter9/rbac`目录中找到。有许多方法可以分发用户凭据。使用文本编辑器查看示例：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With that, you've learned how to create new users. Next, you will create roles
    and assign them to the user.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，您已经学会了如何创建新用户。接下来，您将创建角色并将其分配给用户。
- en: Creating Roles and RoleBindings
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建角色和RoleBindings
- en: Roles and RolesBindings are always used in a defined namespace, meaning that the
    permissions can only be granted for the resources that are in the same namespace
    as the Roles and the RoleBindings themselves compared to the ClusterRoles and
    ClusterRoleBindings that are used to grant permissions to cluster-wide resources
    such as nodes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 角色和RoleBindings始终在定义的命名空间中使用，这意味着权限只能授予与角色和RoleBindings本身相同命名空间中的资源，而不是用于授予集群范围资源（如节点）权限的ClusterRoles和ClusterRoleBindings。
- en: 'Let''s perform the following steps to create an example Role and RoleBinding
    in our cluster:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤在我们的集群中创建一个示例角色和RoleBinding：
- en: 'First, create a namespace where we will create the Role and RoleBinding. In
    our example, the namespace is `secureapp`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个我们将创建角色和RoleBinding的命名空间。在我们的示例中，命名空间是`secureapp`：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a role using the following rules. This role basically allows all operations
    to be performed on deployments, replica sets, and pods for the `deployer` role
    in the `secureapp` namespace we created in *Step 1.* Note that any permissions
    that are granted are only additive and there are no deny rules:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下规则创建一个角色。该角色基本上允许在我们在*步骤1.*中创建的`secureapp`命名空间中对部署、副本集和Pod执行所有操作。请注意，授予的任何权限都只是增量的，没有拒绝规则：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a RoleBinding using the `deployer` role and for the username `john.geek`
    in the `secureapp` namespace. We''re doing this since a RoleBinding can only reference
    a Role that exists in the same namespace:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`deployer`角色为用户名`john.geek`在`secureapp`命名空间中创建一个RoleBinding。我们这样做是因为RoleBinding只能引用同一命名空间中存在的角色：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With that, you've learned how to create a new Role and grant permissions to
    a user using RoleBindings.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，您已经学会了如何创建一个新的角色，并使用RoleBindings授予用户权限。
- en: Testing the RBAC rules
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试RBAC规则
- en: 'Let''s perform the following steps to test the Role and RoleBinding we created
    earlier:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来测试我们之前创建的角色和RoleBinding：
- en: 'Deploy a test pod in the `secureapp` namespace where the user has access:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户有权限访问的`secureapp`命名空间中部署一个测试Pod：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'List the pods in the new user''s context. The same command that failed in the
    *Creating user accounts* recipe in *Step 7* should now execute successfully:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列出新用户上下文中的Pod。在*创建用户帐户*中失败的相同命令在*步骤7*中现在应该能够成功执行：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you try to create the same pod in a different namespace, you will see that
    the command will fail to execute.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试在不同的命名空间中创建相同的Pod，您将看到该命令将无法执行。
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe showed you how to create new users in Kubernetes and quickly create
    Roles and RoleBindings to grant permission to user accounts on Kubernetes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例向您展示了如何在Kubernetes中创建新用户，并快速创建角色和RoleBindings以授予用户帐户对Kubernetes的权限。
- en: 'Kubernetes clusters have two types of users:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群有两种类型的用户：
- en: '**User accounts**: User accounts are normal users that are managed externally.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户帐户**：用户帐户是外部管理的普通用户。'
- en: '**Service accounts**: Service accounts are the users who are associated with
    the Kubernetes services and are managed by the Kubernetes API with its own resources.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务账户**：服务账户是与Kubernetes服务相关联并由Kubernetes API管理其自己资源的用户。'
- en: You can read more about service accounts by looking at the *Managing service
    accounts* link in the *See also* section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看*另请参阅*部分中的*管理服务账户*链接来了解更多关于服务账户的信息。
- en: In the *Creating Roles and RoleBindings* recipe, in *Step 1*, we created a Role
    named `deployer`. Then, in *Step 2*, we granted the rules associated with the
    deployer Role to the user account `john.geek`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在*创建角色和RoleBindings*配方中，在*步骤1*中，我们创建了一个名为`deployer`的角色。然后，在*步骤2*中，我们将与deployer角色关联的规则授予了用户账户`john.geek`。
- en: RBAC uses the `rbac.authorization.k8s.io` API to make authorization decisions.
    This allows admins to dynamically configure policies using the Kubernetes APIs.
    If you wanted to use the existing Roles and give someone cluster-wide superuser
    permission, you could use the `cluster-admin` ClusterRole with a ClusterRoleBinding
    instead. ClusterRoles don't have namespace limits and can execute commands in
    any namespace with the granted permissions. Overall, you should be careful while
    assigning the `cluster-admin` ClusterRole to users. ClusterRoles can be also limited
    to namespaces, similar to Roles if they are used with RoleBindings to grant permissions
    instead.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC使用`rbac.authorization.k8s.io` API来做出授权决策。这允许管理员使用Kubernetes API动态配置策略。如果您想要使用现有的角色并给予某人集群范围的超级用户权限，您可以使用`cluster-admin`
    ClusterRole和ClusterRoleBinding。ClusterRoles没有命名空间限制，并且可以在任何命名空间中执行具有授予的权限的命令。总的来说，在分配`cluster-admin`
    ClusterRole给用户时应该小心。ClusterRoles也可以像Roles一样限制到命名空间，如果它们与RoleBindings一起使用来授予权限。
- en: See also
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: RBAC Authorization in Kubernetes documentation: [https://kubernetes.io/docs/reference/access-authn-authz/rbac/#rolebinding-and-clusterrolebinding](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#rolebinding-and-clusterrolebinding)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes中的RBAC授权文档：[https://kubernetes.io/docs/reference/access-authn-authz/rbac/#rolebinding-and-clusterrolebinding](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#rolebinding-and-clusterrolebinding)
- en: 'More on the default roles and role bindings: [https://kubernetes.io/docs/reference/access-authn-authz/rbac/#default-roles-and-role-bindings](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#default-roles-and-role-bindings)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关默认角色和角色绑定的更多信息：[https://kubernetes.io/docs/reference/access-authn-authz/rbac/#default-roles-and-role-bindings](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#default-roles-and-role-bindings)
- en: 'Autogenerating RBAC policies based on Kubernetes audit logs: [https://github.com/liggitt/audit2rbac](https://github.com/liggitt/audit2rbac)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Kubernetes审计日志自动生成RBAC策略：[https://github.com/liggitt/audit2rbac](https://github.com/liggitt/audit2rbac)
- en: 'Kubernetes Authentication: [https://kubernetes.io/docs/reference/access-authn-authz/authentication/](https://kubernetes.io/docs/reference/access-authn-authz/authentication/)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes认证：[https://kubernetes.io/docs/reference/access-authn-authz/authentication/](https://kubernetes.io/docs/reference/access-authn-authz/authentication/)
- en: 'Managing Service Accounts: [https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/](https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理服务账户：[https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/](https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/)
- en: The kubectl-bindrole tool for finding Kubernetes Roles bound to a specified
    ServiceAccount: [https://github.com/Ladicle/kubectl-bindrole](https://github.com/Ladicle/kubectl-bindrole)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl-bindrole工具用于查找绑定到指定ServiceAccount的Kubernetes角色：[https://github.com/Ladicle/kubectl-bindrole](https://github.com/Ladicle/kubectl-bindrole)
- en: Configuring Pod Security Policies
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Pod安全策略
- en: '**Pod Security Policies** (**PSP**) are used on Kubernetes clusters to enable
    granular authorization of pod creation and to control security aspects of pods.
    PodSecurityPolicy objects define the conditions for a pod to be accepted into
    the cluster and run as expected.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Pod安全策略（PSP）在Kubernetes集群上用于启用对Pod创建的细粒度授权，并控制Pod的安全方面。PodSecurityPolicy对象定义了接受Pod进入集群并按预期运行的条件。
- en: In this section, we will cover the recreation and configuration of PSPs on Kubernetes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍在Kubernetes上重新创建和配置PSP。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have an RBAC-enabled Kubernetes cluster ready (since Kubernetes
    1.6, RBAC is enabled by default) and `kubectl` and `helm` configured to manage
    the cluster resources.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已准备好启用RBAC的Kubernetes集群（自Kubernetes 1.6以来，RBAC默认已启用），并配置`kubectl`和`helm`来管理集群资源。
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation to use the
    manifest files in the `chapter9` directory, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将`k8sdevopscookbook/src`存储库克隆到您的工作站，以便使用`chapter9`目录中的清单文件，如下所示：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Verify if PodSecurityPolicy needs to be enabled on your cluster by running the
    `kubectl get psp` command. If you get a message stating `the server doesn't have
    a resource type "podSecurityPolicies".`, then PSP needs to be enabled on your
    cluster.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`kubectl get psp`命令来验证集群是否需要启用PodSecurityPolicy。如果收到消息说明`服务器没有资源类型"podSecurityPolicies"。`，则需要在集群上启用PSP。
- en: How to do it…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤：
- en: 'This section is further divided into the following subsections to make this
    process easier:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本节进一步分为以下子节，以使此过程更加简单：
- en: Enabling PSPs on EKS
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在EKS上启用PSP
- en: Enabling PSPs on GKE
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GKE上启用PSP
- en: Enabling PSPs on AKS
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在AKS上启用PSP
- en: Creating a restricted PSPs
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建受限制的PSP
- en: Enabling PSPs on EKS
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在EKS上启用PSP
- en: As a best practice, PSPs should not be enabled before you create your own policies. This
    recipe will take you through how to enable PSP on Amazon EKS and how to review
    default policies.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，在创建自己的策略之前，不应该启用PSP。本文将带您了解如何在Amazon EKS上启用PSP以及如何审查默认策略。
- en: 'Let''s perform the following steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'Deploy Kubernetes version 1.13 or higher. PSP will be enabled by default. The
    default configuration comes with a non-disruptive policy named `eks.privileged`
    that has no restrictions. View the default policy with the following command:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署Kubernetes版本1.13或更高版本。PSP将默认启用。默认配置带有一个名为`eks.privileged`的非破坏性策略，没有限制。使用以下命令查看默认策略：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Describe the policy to see its full details, as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述策略以查看其完整详情，如下所示：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To review, restore, or delete the default PSP, use the YAML manifest in the
    example repository in `src/chapter9/psp` named `eks-privileged-psp.yaml`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要审查、恢复或删除默认PSP，请使用示例存储库中`src/chapter9/psp`目录中名为`eks-privileged-psp.yaml`的YAML清单。
- en: Enabling PSPs on GKE
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在GKE上启用PSP
- en: As a best practice, PSPs should not be enabled before you create your own policies. This
    recipe will take you through how to enable PSP on **Google Kubernetes Engine**
    (**GKE**) and how to review default policies.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，在创建自己的策略之前，不应该启用PSP。本文将带您了解如何在Google Kubernetes Engine（GKE）上启用PSP以及如何审查默认策略。
- en: 'Let''s perform the following steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'You can enable PSP on the cluster you deployed by following the instructions
    given in [Chapter 1](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml), *Building Production-Ready
    Kubernetes Clusters*, in the *Provisioning a managed Kubernetes cluster on GKE* recipe
    by running the following command. Replace `k8s-devops-cookbook-1` with your own
    cluster name:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令在部署的集群上启用PSP，按照[第1章](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml)中的说明，*构建生产就绪的Kubernetes集群*，在*在GKE上配置托管的Kubernetes集群*中。将`k8s-devops-cookbook-1`替换为您自己的集群名称：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The default configuration comes with a non-disruptive policy named `gce.privileged`
    that has no restrictions and couple of other policies. View the default policies
    with the following command:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认配置带有一个名为`gce.privileged`的非破坏性策略，没有限制，还有其他几个策略。使用以下命令查看默认策略：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Describe the policy to see its full details, as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述策略以查看其完整详情，如下所示：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To review, restore, or delete the default PSP, use the YAML manifest in the
    example repository in `src/chapter9/psp` named `gce-privileged-psp.yaml`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看、恢复或删除默认PSP，请使用示例存储库中的YAML清单，在`src/chapter9/psp`中命名为`gce-privileged-psp.yaml`。
- en: Enabling PodSecurityPolicy on AKS
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在AKS上启用PodSecurityPolicy
- en: As a best practice, PodSecurityPolicy should not be enabled before you create
    your own policies. This recipe will take you through how to enable PSP on **Azure
    Kubernetes Service** (**AKS**) and how to review default policies.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，在创建自己的策略之前，不应启用PodSecurityPolicy。本教程将带您了解如何在**Azure Kubernetes Service**（**AKS**）上启用PSP以及如何查看默认策略。
- en: 'Let''s perform the following steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤：
- en: 'You can enable PSP on the cluster you have deployed by following the instructions
    given in [Chapter 1](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml) *Building Production-Ready
    Kubernetes Clusters*, in the *Provisioning a managed Kubernetes cluster on AKS* recipe
    by running the following command. Replace `k8sdevopscookbook` with your own resource
    group and `AKSCluster` with your cluster name:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以按照[第1章](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml) *构建生产就绪的Kubernetes集群*中给出的说明，在*在AKS上配置托管的Kubernetes集群*教程中运行以下命令来在部署的集群上启用PSP。将`k8sdevopscookbook`替换为您自己的资源组，将`AKSCluster`替换为您的集群名称：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'he default configuration comes with a non-disruptive policy named `privileged`
    that has no restrictions. View the default policy with the following command:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认配置带有一个名为`privileged`的非破坏性策略，没有限制。使用以下命令查看默认策略：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Describe the policy to see its full details, as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述策略以查看其完整详情，如下所示：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To review, restore, or delete the default PSP, use the YAML manifest in the
    example repository in `src/chapter9/psp` named `aks-privileged-psp.yaml`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看、恢复或删除默认PSP，请使用示例存储库中的YAML清单，在`src/chapter9/psp`中命名为`aks-privileged-psp.yaml`。
- en: Creating a restricted PSPs
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建受限的PSPs
- en: As a security best practice, it is recommended to restrict containers in pods
    from running with root user privileges to limit any possible risks. When running
    in privileged mode, processes that run inside the container have the same privileges
    and access as the processes outside the container, which can raise the risk of
    some management capabilities being accessed by attackers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为安全最佳实践，建议限制容器在Pod中以root用户特权运行，以限制任何可能的风险。在特权模式下运行时，容器内运行的进程具有与容器外进程相同的特权和访问权限，这可能会增加攻击者访问一些管理能力的风险。
- en: 'Let''s perform the following steps to create a root access restricted PodSecurityPolicy:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来创建一个受限的PodSecurityPolicy：
- en: 'Deploy a new restricted `PodSecurityPolicy`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署一个新的受限`PodSecurityPolicy`：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Confirm that the policy has been created. You will notice that the `RUNASUSER`
    column shows `MustRunAsNonRoot`, which indicates that using root privileges is
    not allowed:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认策略已创建。您会注意到`RUNASUSER`列显示`MustRunAsNonRoot`，这表示不允许使用root权限：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Verify the PSP by running a pod that requires root access. The deployment will
    fail and show a message stating `container has runAsNonRoot and image will run
    as root`, as shown in the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行需要root访问权限的pod来验证PSP。部署将失败，并显示一条消息，指出`container has runAsNonRoot and image
    will run as root`，如下代码所示：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With that, you've learned how to create a root access restricted PodSecurityPolicy.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，您已经学会了如何创建一个受限的PodSecurityPolicy。
- en: There's more…
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This section is further divided into the following subsections to make this
    process easier:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分进一步分为以下子部分，以使此过程更加简单：
- en: Restricting pods to access certain volume types
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制Pod访问特定卷类型
- en: Using Kubernetes PSPs advisor
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes PSPs顾问
- en: Restricting pods to access certain volume types
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制Pod访问特定卷类型
- en: As part of the PodSecurityPolicy rule, you may want to limit the use of a specific
    type of volume. In this recipe, you will learn how to restricts containers to
    volume types.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 作为PodSecurityPolicy规则的一部分，您可能希望限制使用特定类型的卷。在本教程中，您将学习如何限制容器访问卷类型。
- en: 'Let''s perform the following steps to create a PodSecurityPolicy:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来创建PodSecurityPolicy：
- en: 'Create a new restricted `PodSecurityPolicy`. This policy limits the type of
    volume to `nfs` only:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的受限`PodSecurityPolicy`。此策略仅限制卷类型为`nfs`：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Verify the policy by deploying an application that requires persistent storage.
    Here, we will use the MinIO example from previous chapters. The deployment should
    fail with a message stating `persistentVolumeClaim volumes are not allowed to
    be used`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过部署需要持久存储的应用程序来验证策略。在这里，我们将使用前几章的MinIO示例。部署应该失败，并显示消息“不允许使用persistentVolumeClaim卷”。
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Delete both the PSPs and the deployment:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除PSP和部署：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The recommended set of allowed volumes for new PSPs are `configMap`, `downwardAPI`,
    `emptyDir`, `persistentVolumeClaim`, `secret`, and `projected`. You can find the
    complete list of volume types by going to the *Type of volumes supported* link
    in the *See also* section. Create a new restricted PodSecurityPolicy using the
    following content. This policy limits the type of volume to `persistentVolumeClaim` only:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新PSP允许的卷集包括`configMap`、`downwardAPI`、`emptyDir`、`persistentVolumeClaim`、`secret`和`projected`。您可以通过转到*支持的卷类型*链接在*另请参阅*部分找到卷类型的完整列表。使用以下内容创建新的受限PodSecurityPolicy。此策略仅限制卷类型为`persistentVolumeClaim`：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Repeat *Step 2* to deploy the application. This time, `persistentVolumeClaim`
    creation will be allowed and the PVC that was requested by the pod will be created.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤2*以部署应用程序。这次，将允许创建`persistentVolumeClaim`，并将创建Pod请求的PVC。
- en: Using Kubernetes PodSecurityPolicy advisor
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Kubernetes PodSecurityPolicy顾问
- en: Kubernetes PodSecurityPolicy Advisor is a simple tool from Sysdig that's used
    to enforce best security practices in Kubernetes. `kube-psp-advisor` scans the
    existing security context of Kubernetes resources and generates the PSPs for the
    resources in the cluster to remove unnecessary privileges.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes PodSecurityPolicy Advisor是Sysdig的一个简单工具，用于强制执行Kubernetes中的最佳安全实践。`kube-psp-advisor`扫描Kubernetes资源的现有安全上下文，并为集群中的资源生成PSP，以删除不必要的特权。
- en: 'Let''s perform the following steps to enable `kube-psp-advisor` on our cluster:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤在我们的集群上启用`kube-psp-advisor`：
- en: 'Clone the repository and build the project using the following command:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆存储库并使用以下命令构建项目：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the scan process by executing the binary. If you want to limit the scan
    to a namespace, you can specify it by adding the `--namespace=` parameter to the
    command, similar to what can be seen in the following code. If you don''t do this,
    it will scan the whole cluster. After doing this, a `PodSecurityPolicy` will be
    generated:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行二进制文件运行扫描过程。如果要将扫描限制为命名空间，可以通过向命令添加`--namespace=`参数来指定，类似于以下代码中所示。如果不这样做，它将扫描整个集群。这样做后，将生成一个`PodSecurityPolicy`：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Review the content of the `psp-advisor.yaml` file and apply the generated PSP:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查`psp-advisor.yaml`文件的内容，并应用生成的PSP：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With that, you've learned how to generate a PSP in a simpler way to reduce the
    unnecessary permissions that may increase the attack surface.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，您已经学会了如何以更简单的方式生成PSP，以减少可能增加攻击面的不必要权限。
- en: See also
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Kubernetes documentation – PodSecurityPolicy: [https://kubernetes.io/docs/concepts/policy/pod-security-policy/](https://kubernetes.io/docs/concepts/policy/pod-security-policy/)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes文档-PodSecurityPolicy：[https://kubernetes.io/docs/concepts/policy/pod-security-policy/](https://kubernetes.io/docs/concepts/policy/pod-security-policy/)
- en: Type of volumes supported: [https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes](https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的卷类型：[https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes](https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes)
- en: Using Kubernetes CIS Benchmark for security auditing
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes CIS基准进行安全审计
- en: Kubernetes CIS Benchmarks are the security configuration best practices that
    are accepted by industry experts. The CIS Benchmark guide can be download as a
    PDF file from the **Center for Internet Security** (**CIS**) website at [https://www.cisecurity.org/](https://www.cisecurity.org/).
    `kube-bench` is an application that automates documented checks.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes CIS基准是业界专家接受的安全配置最佳实践。CIS基准指南可以从**互联网安全中心**（**CIS**）网站[https://www.cisecurity.org/](https://www.cisecurity.org/)下载为PDF文件。`kube-bench`是一个自动化记录检查的应用程序。
- en: In this section, we will cover the installation and use of the open source `kube-bench`
    tool to run Kubernetes CIS Benchmarks for security auditing of Kubernetes clusters.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍安装和使用开源的`kube-bench`工具，以运行Kubernetes CIS基准，对Kubernetes集群进行安全审计。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: For this recipe, we need to have a Kubernetes cluster ready and the Kubernetes
    command-line tool `kubectl` installed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要准备好一个Kubernetes集群，并安装Kubernetes命令行工具`kubectl`。
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation to use the
    manifest files in the `chapter9` directory, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 将`k8sdevopscookbook/src`存储库克隆到您的工作站，以使用`chapter9`目录中的清单文件，如下所示：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Some of the tests target Kubernetes nodes and can only be executed on fully
    self-managed clusters where you have control over the master nodes. Therefore,
    managed clusters such as EKS, GKE, AKS, and so on will not be able to execute
    all the tests and require different job descriptions or parameters to execute
    the tests. These will be mentioned when necessary.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一些测试针对Kubernetes节点，只能在完全自我管理的集群上执行，您可以控制主节点。因此，托管集群（如EKS、GKE、AKS等）将无法执行所有测试，并需要不同的作业描述或参数来执行测试。在必要时会提到这些。
- en: How to do it…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'This section is further divided into the following subsections to make this
    process easier:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本节进一步分为以下子节，以使此过程更加简单：
- en: Running kube-bench on Kubernetes
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes上运行kube-bench
- en: Running kube-bench on managed Kubernetes services
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在托管的Kubernetes服务上运行kube-bench
- en: Running kube-bench on OpenShift
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在OpenShift上运行kube-bench
- en: Running kube-hunter
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行kube-hunter
- en: Running kube-bench on Kubernetes
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Kubernetes上运行kube-bench
- en: The CIS Benchmark has tests for both master and worker nodes. Therefore, the
    full scope of the test can only be completed on self-managed clusters where you
    have control over the master nodes. In this recipe, you will learn how to run
    kube-bench directly on the master and worker nodes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: CIS基准对主节点和工作节点都有测试。因此，只有在您可以控制主节点的自我管理集群上才能完成测试的全部范围。在这个配方中，您将学习如何直接在主节点和工作节点上运行kube-bench。
- en: 'Let''s perform the following steps to run the CIS recommended tests:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来运行CIS推荐的测试：
- en: 'Download and install the `kube-bench` command-line interface on one of your
    master nodes and one of your worker nodes:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并安装`kube-bench`命令行界面到您的一个主节点和一个工作节点：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'SSH into your Kubernetes master node and run the following command. It will
    quickly return the result of the test with an explanation and a list of additional
    manual tests that are recommended to be run after. Here, you can see that `31`
    checks passed and `36` tests failed:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSH登录到您的Kubernetes主节点并运行以下命令。它将快速返回测试结果，并附有解释和建议在之后运行的其他手动测试的列表。在这里，您可以看到`31`个检查通过，`36`个测试失败：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To save the results, use the following command. After the test is complete, move
    the `kube-bench-master.txt` file to your localhost for further review:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存结果，请使用以下命令。测试完成后，将`kube-bench-master.txt`文件移动到本地主机进行进一步审查：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Review the content of the `kube-bench-master.txt` file. You will see the status
    of the checks from the CIS Benchmark for the Kubernetes guide, similar to the
    following:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查`kube-bench-master.txt`文件的内容。您将看到与以下类似的内容，这是来自Kubernetes指南的CIS基准检查的状态：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Tests are split into categories that have been suggested in the CIS Benchmark
    guidelines, such as API Server, Scheduler, Controller Manager, Configuration Manager,
    etcd, General Security Primitives, and PodSecurityPolicies.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 测试被分成了几个类别，这些类别是根据CIS基准指南中建议的，比如API服务器、调度器、控制器管理器、配置管理器、etcd、一般安全原语和PodSecurityPolicies。
- en: 'Follow the methods suggested in the *Remediations* section of the report to
    fix the failed issues and rerun the test to confirm that the correction has been
    made. You can see some of the remediations that were suggested by the preceding
    report here:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照报告中*修复*部分建议的方法来修复失败的问题，并重新运行测试以确认已进行修正。您可以在先前报告中建议的一些修复措施如下：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s take one of the issues from the preceding list. `1.2.1` suggests that
    we disable the profiling API endpoint. The reason for this is that highly sensitive system
    information can be uncovered by profiling data and the amount of data and load
    that''s created by profiling your cluster could be put out of service (denial-of-service
    attack) by this feature. Edit the `kube-scheduler.manifest` file and add `--profiling=false`
    right after the `kube-schedule` command, as shown in the following code:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从先前的列表中选取一个问题。`1.2.1`建议我们禁用分析API端点。原因是通过分析数据可以揭示高度敏感的系统信息，并且通过对集群进行分析可能会产生大量数据和负载，从而使该功能使集群无法服务（拒绝服务攻击）。编辑`kube-scheduler.manifest`文件，并在`kube-schedule`命令之后添加`--profiling=false`，如下所示：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run the test again and confirm that the issue on `1.2.1` has been corrected.
    Here, you can see that the number of passed tests has increased from `31` to `32`.
    One more check has been cleared:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试并确认`1.2.1`上的问题已经得到纠正。在这里，您可以看到通过的测试数量从`31`增加到`32`。还有一个检查已经通过：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the test on the worker nodes by using the following command:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工作节点上运行以下命令进行测试：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To save the results, use the following command. After the test has completed, move
    the `kube-bench-worker.txt` file to your localhost for further review:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存结果，请使用以下命令。测试完成后，将`kube-bench-worker.txt`文件移动到本地主机进行进一步审查：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Review the content of the `kube-bench-worker.txt` file. You will see the status
    of the checks from the CIS Benchmark for the Kubernetes guide, similar to the
    following:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查`kube-bench-worker.txt`文件的内容。您将看到与以下类似的内容，这是来自Kubernetes指南的CIS基准检查的状态：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Similarly, follow all the remediations until you've cleared all the failed tests
    on the master and worker nodes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，按照所有的修复措施，直到您清除了主节点和工作节点上的所有失败测试。
- en: Running kube-bench on managed Kubernetes services
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在托管的Kubernetes服务上运行kube-bench
- en: The difference between managed Kubernetes services such as EKS, GKE, AKS, and
    so on is that you can't run the checks on the master. Instead, you have to either
    only follow the worker checks from the previous recipe or run a Kubernetes job
    to validate your environment. In this recipe, you will learn how to run kube-bench
    on managed Kubernetes service-based nodes and also in cases where you don't have
    direct SSH access to the nodes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 托管的Kubernetes服务（如EKS、GKE、AKS等）与您无法在主节点上运行检查的区别在于，您要么只能遵循上一个教程中的工作节点检查，要么运行一个Kubernetes作业来验证您的环境。在本教程中，您将学习如何在托管的Kubernetes服务节点上运行kube-bench，以及在您没有直接SSH访问节点的情况下运行kube-bench的情况。
- en: 'Let''s perform the following steps to run the CIS recommended tests:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来运行CIS推荐的测试：
- en: 'For this recipe, we will use EKS as our Kubernetes service, but you can change
    the Kubernetes and container registry services to other cloud providers if you
    wish. First, create an ECR repository where we will host the kube-bench image:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于本教程，我们将使用EKS作为我们的Kubernetes服务，但如果您愿意，您可以将Kubernetes和容器注册服务更改为其他云提供商。首先，创建一个ECR存储库，我们将在其中托管kube-bench镜像：
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Clone the `kube-bench` repository to your localhost:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`kube-bench`存储库克隆到本地主机：
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Log in to your **Elastic Container Registry** (**ECR**) account. You need to
    be authenticated before you can push images to the registry:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到您的**弹性容器注册表**（**ECR**）帐户。在将图像推送到注册表之前，您需要进行身份验证：
- en: '[PRE50]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Build the kube-bench image by running the following command:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令构建kube-bench镜像：
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Replace `<AWS_ACCT_NUMBER>` with your AWS account number and execute it to
    push it to the ECR repository. The first command will create a tag, while the
    second command will push the image:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用您的AWS帐户号替换`<AWS_ACCT_NUMBER>`并执行它以将其推送到ECR存储库。第一个命令将创建一个标签，而第二个命令将推送图像：
- en: '[PRE52]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Edit the `job-eks.yaml` file and replace the image name on line 12 with the
    URI of the image you pushed in *Step 5*. It should look similar to the following,
    except you should use your AWS account number in the image URI:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`job-eks.yaml`文件，并将第12行的图像名称替换为您在*步骤5*中推送的图像的URI。它应该看起来类似于以下内容，除了您应该在图像URI中使用您的AWS帐户号：
- en: '[PRE53]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Run the job using the following command. It will be executed and completed
    shortly:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行作业。它将很快被执行和完成：
- en: '[PRE54]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'List the kube-bench pods that were created in your cluster. It should show
    `Completed` as the status, similar to the following example:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出在您的集群中创建的kube-bench pod。它应该显示`Completed`作为状态，类似于以下示例：
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Replace the pod name with the output of the previous command and view the pod
    logs to retrieve the `kube-bench` results. In our example, the pod name is `kube-bench-7lxzn`:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用上一个命令的输出替换pod名称，并查看pod日志以检索`kube-bench`的结果。在我们的示例中，pod名称是`kube-bench-7lxzn`：
- en: '[PRE56]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now, you can run kube-bench on any managed Kubernetes cluster. After you get
    the logs, follow all the remediation suggestions until you clear the failed tests
    on the worker nodes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在任何托管的Kubernetes集群上运行kube-bench。获取日志后，按照所有的修复建议，直到清除工作节点上的失败测试。
- en: Running kube-bench on OpenShift
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在OpenShift上运行kube-bench
- en: OpenShift has different command-line tools, so if we run the default test jobs,
    we won't be able to gather the required information on our cluster unless specified. In
    this recipe, you will learn how to run `kube-bench` on OpenShift.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift有不同的命令行工具，因此，如果我们运行默认的测试作业，我们将无法在我们的集群上收集所需的信息，除非另有说明。在本教程中，您将学习如何在OpenShift上运行`kube-bench`。
- en: 'Let''s perform the following steps to run the CIS recommended tests:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来运行CIS推荐的测试：
- en: 'SSH into your OpenShift master node and run the following command using `--version
    ocp-3.10` or `ocp-3.11` based on your OpenShift version. Currently, only 3.10
    and 3.11 are supported:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSH进入您的OpenShift主节点，并使用`--version ocp-3.10`或`ocp-3.11`运行以下命令，根据您的OpenShift版本。目前，只支持3.10和3.11：
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To save the results, use the following command. After the test has been completed, move
    the `kube-bench-master.txt` file to your localhost for further review:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存结果，请使用以下命令。测试完成后，将`kube-bench-master.txt`文件移动到本地主机以进行进一步审查：
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'SSH into your OpenShift worker node and repeat the first two steps of this
    recipe, but this time using the `node` parameter for the OpenShift version you
    are running. In our example, this is OCP 3.11:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSH进入您的OpenShift工作节点，并重复此配方的前两步，但这次使用您正在运行的OpenShift版本的`node`参数。在我们的示例中，这是OCP
    3.11：
- en: '[PRE59]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Follow the *Running kube-bench on Kubernetes* recipe's instructions to patch
    security issues with the suggested remediations.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 按照*在Kubernetes上运行kube-bench*的配方说明来修补建议的安全问题。
- en: How it works...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe showed you how to quickly run CIS Kubernetes Benchmarks on your
    cluster using kube-bench.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方向您展示了如何快速在您的集群上使用kube-bench运行CIS Kubernetes基准。
- en: 'In the *Running kube-bench on Kubernetes* recipe, in s*tep 1*, after you executed
    the checks, kube-bench accessed the configuration files that were kept in the
    following directories: `/var/lib/etcd`, `/var/lib/kubelet`, `/etc/systemd`, `/etc/kubernetes`,
    and `/usr/bin`. Therefore, the user who runs the checks needs to provide root/sudo
    access to all the config files.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在*在Kubernetes上运行kube-bench*的配方中，在*步骤1*中，执行完检查后，kube-bench访问了保存在以下目录中的配置文件：`/var/lib/etcd`、`/var/lib/kubelet`、`/etc/systemd`、`/etc/kubernetes`和`/usr/bin`。因此，运行检查的用户需要为所有配置文件提供root/sudo访问权限。
- en: 'If the configuration files can''t be found in their default directories, the
    checks will fail. The most common issue is the missing `kubectl` binary in the
    `/usr/bin` directory. kubectl is used to detect the Kubernetes version. You can
    skip this directory by specifying the Kubernetes version using `--version` as
    part of the command, similar to the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配置文件无法在其默认目录中找到，则检查将失败。最常见的问题是在`/usr/bin`目录中缺少`kubectl`二进制文件。kubectl用于检测Kubernetes版本。您可以通过在命令的一部分中使用`--version`来跳过此目录，从而指定Kubernetes版本，类似于以下内容：
- en: '[PRE60]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '*Step 1* will return four different states. The `PASS` and `FAIL` states are
    self-explanatory as they indicate whether the tests were run successfully or failed. `WARN`
    indicates that the test requires manual validation, which means it requires attention.
    Finally, `INFO` means that no further action is required.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤1*将返回四种不同的状态。`PASS`和`FAIL`状态是不言自明的，因为它们指示测试是否成功运行或失败。`WARN`表示测试需要手动验证，这意味着需要注意。最后，`INFO`表示不需要进一步操作。'
- en: See also
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: CIS Kubernetes Benchmarks: [https://www.cisecurity.org/benchmark/kubernetes/](https://www.cisecurity.org/benchmark/kubernetes/)
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CIS Kubernetes基准：[https://www.cisecurity.org/benchmark/kubernetes/](https://www.cisecurity.org/benchmark/kubernetes/)
- en: kube-bench repository: [https://github.com/aquasecurity/kube-bench](https://github.com/aquasecurity/kube-bench)
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kube-bench存储库：[https://github.com/aquasecurity/kube-bench](https://github.com/aquasecurity/kube-bench)
- en: How to customize the default configuration: [https://github.com/aquasecurity/kube-bench/blob/master/docs/README.md#configuration-and-variables](https://github.com/aquasecurity/kube-bench/blob/master/docs/README.md#configuration-and-variables)
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何自定义默认配置：[https://github.com/aquasecurity/kube-bench/blob/master/docs/README.md#configuration-and-variables](https://github.com/aquasecurity/kube-bench/blob/master/docs/README.md#configuration-and-variables)
- en: Automating compliance checking for Kubernetes-based applications: [https://github.com/cds-snc/security-goals](https://github.com/cds-snc/security-goals)
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为基于Kubernetes的应用程序自动执行合规性检查：[https://github.com/cds-snc/security-goals](https://github.com/cds-snc/security-goals)
- en: Hardening Kubernetes from Scratch: [https://github.com/hardening-kubernetes/from-scratch](https://github.com/hardening-kubernetes/from-scratch)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始加固Kubernetes：[https://github.com/hardening-kubernetes/from-scratch](https://github.com/hardening-kubernetes/from-scratch)
- en: 'CNCF Blog on 9 Kubernetes Security Best Practices Everyone Must Follow: [https://www.cncf.io/blog/2019/01/14/9-kubernetes-security-best-practices-everyone-must-follow/](https://www.cncf.io/blog/2019/01/14/9-kubernetes-security-best-practices-everyone-must-follow/)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CNCF博客上的9个Kubernetes安全最佳实践：[https://www.cncf.io/blog/2019/01/14/9-kubernetes-security-best-practices-everyone-must-follow/](https://www.cncf.io/blog/2019/01/14/9-kubernetes-security-best-practices-everyone-must-follow/)
- en: Hardening Guide for Rancher [https://rancher.com/docs/rancher/v2.x/en/security/hardening-2.2/](https://rancher.com/docs/rancher/v2.x/en/security/hardening-2.2/)
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rancher的加固指南[https://rancher.com/docs/rancher/v2.x/en/security/hardening-2.2/](https://rancher.com/docs/rancher/v2.x/en/security/hardening-2.2/)
- en: 'Must-have Kubernetes security audit tools:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必备的Kubernetes安全审计工具：
- en: Kube-bench: [https://github.com/aquasecurity/kube-bench](https://github.com/aquasecurity/kube-bench)
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kube-bench: [https://github.com/aquasecurity/kube-bench](https://github.com/aquasecurity/kube-bench)'
- en: Kube-hunter: [https://kube-hunter.aquasec.com/](https://kube-hunter.aquasec.com/)
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kube-hunter: [https://kube-hunter.aquasec.com/](https://kube-hunter.aquasec.com/)'
- en: Kubeaudit: [https://github.com/Shopify/kubeaudit](https://github.com/Shopify/kubeaudit)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kubeaudit: [https://github.com/Shopify/kubeaudit](https://github.com/Shopify/kubeaudit)'
- en: Kubesec:[https://github.com/controlplaneio/kubesec](https://github.com/controlplaneio/kubesec)
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kubesec: [https://github.com/controlplaneio/kubesec](https://github.com/controlplaneio/kubesec)'
- en: Open Policy Agent:[https://www.openpolicyagent.org/](https://www.openpolicyagent.org/)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Open Policy Agent: [https://www.openpolicyagent.org/](https://www.openpolicyagent.org/)'
- en: K8Guard: [https://k8guard.github.io/](https://k8guard.github.io/)
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'K8Guard: [https://k8guard.github.io/](https://k8guard.github.io/)'
- en: Building DevSecOps into the pipeline using Aqua Security
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将DevSecOps构建到流水线中，使用Aqua Security
- en: The **Shift Left** approach to DevOps Security is becoming increasingly popular,
    which means that security must be built into the process and pipeline. One of
    the biggest problems with shortened pipelines is that they often leave little room
    for proper security checks. Due to this, another approach called **deploy changes
    as quickly as possible** was introduced, which is key to the success of DevOps.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: “左移”方法逐渐变得越来越受欢迎，这意味着安全必须内置到流程和流水线中。缩短流水线的最大问题之一是它们通常留下很少的空间进行适当的安全检查。因此，另一种称为“尽快部署更改”的方法被引入，这对DevOps的成功至关重要。
- en: In this section, we will cover automating vulnerability checks in container
    images using Aqua Security to reduce the application attack surface.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍使用Aqua Security自动化容器镜像中的漏洞检查，以减少应用程序的攻击面。
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have an existing CI/CD pipeline configured using your preferred
    CI/CD tool. If not, follow the instructions in [Chapter 3](811c24c7-debf-4487-91e9-81db1520c0aa.xhtml), *Building
    CI/CD Pipelines*, to configure GitLab or CircleCI.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经使用您喜欢的CI/CD工具配置了现有的CI/CD流水线。如果没有，请按照[第3章](811c24c7-debf-4487-91e9-81db1520c0aa.xhtml)中的说明，*构建CI/CD流水线*，配置GitLab或CircleCI。
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation to use the
    manifest files in the `chapter9` directory, as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 将`k8sdevopscookbook/src`存储库克隆到您的工作站，以便使用`chapter9`目录中的清单文件，方法如下：
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Make sure you have a Kubernetes cluster ready and `kubectl` configured to manage
    the cluster resources.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您有一个准备好的Kubernetes集群，并配置`kubectl`来管理集群资源。
- en: How to do it…
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'This section will show you how to integrate Aqua with your CI/CD platform.
    This section is further divided into the following subsections to make this process
    easier:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示如何将Aqua集成到您的CI/CD平台。本节进一步分为以下子节，以使此过程更加简单：
- en: Scanning images using Aqua Security Trivy
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Aqua Security Trivy扫描镜像
- en: Building vulnerability scanning into GitLab
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将漏洞扫描构建到GitLab中
- en: Building vulnerability scanning into CircleCI
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将漏洞扫描构建到CircleCI中
- en: Scanning images using Trivy
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Trivy扫描镜像
- en: Trivy is an open source container scanning tool that's used to identify container
    vulnerabilities. It is one of the simplest and most accurate scanning tools in
    the market. In this recipe, we will learn how to install and scan container images
    using Trivy.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Trivy是一个用于识别容器漏洞的开源容器扫描工具。它是市场上最简单和最准确的扫描工具之一。在这个示例中，我们将学习如何安装和扫描使用Trivy的容器映像。
- en: 'Let''s perform the following steps to run Trivy:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来运行Trivy：
- en: 'Get the latest Trivy release number and keep it in a variable:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取最新的Trivy发布号并将其保存在一个变量中：
- en: '[PRE62]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Download and install the `trivy` command-line interface:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并安装`trivy`命令行界面：
- en: '[PRE63]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Verify that `trivy` is functional by running the following command. It will
    return its current version:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令验证`trivy`是否正常工作。它将返回其当前版本：
- en: '[PRE64]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Execute `trivy` checks by replacing the container image name with your target
    image. In our example, we scanned the `postgres:12.0` image from the Docker Hub
    repository:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过用目标映像替换容器映像名称来执行`trivy`检查。在我们的示例中，我们扫描了来自Docker Hub存储库的`postgres:12.0`映像：
- en: '[PRE65]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The test summary will show the number of vulnerabilities that have been detected
    and will include a detailed list of vulnerabilities, along with their IDs and
    an explanation of each of them:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试摘要将显示已检测到的漏洞数量，并将包括漏洞的详细列表，以及它们的ID和每个漏洞的解释：
- en: '[PRE66]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: With that, you've learned how to quickly scan your container images. Trivy supports
    a variety of container base images (CentOS, Ubuntu, Alpine, Distorless, and so
    on) and natively supports container registries such as Docker Hub, Amazon ECR,
    and Google Container Registry GCR. Trivy is completely suitable for CI. In the
    next two recipes, you will learn how you can add Trivy into CI pipelines.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，您已经学会了如何快速扫描您的容器映像。Trivy支持各种容器基础映像（CentOS，Ubuntu，Alpine，Distorless等），并原生支持Docker
    Hub、Amazon ECR和Google Container Registry GCR等容器注册表。Trivy完全适用于CI。在接下来的两个示例中，您将学习如何将Trivy添加到CI流水线中。
- en: Building vulnerability scanning into GitLab
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将漏洞扫描构建到GitLab中
- en: With GitLab Auto DevOps, the container scanning job uses CoreOS Clair to analyze
    Docker images for vulnerabilities. However, it is not a complete database of all
    security issues for Alpine-based images. Aqua Trivy has nearly double the number
    of vulnerabilities and is more suitable for CI. For a detailed comparison, please
    refer to the *Trivy Comparison* link in the *See also* section. This recipe will
    take you through adding a test stage to a GitLab CI pipeline.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GitLab Auto DevOps，容器扫描作业使用CoreOS Clair来分析Docker映像的漏洞。然而，它并不是针对基于Alpine的映像的所有安全问题的完整数据库。Aqua
    Trivy几乎有两倍的漏洞数量，更适合于CI。有关详细比较，请参阅*Trivy Comparison*链接中的*另请参阅*部分。本示例将带您完成在GitLab
    CI流水线中添加测试阶段的过程。
- en: 'Let''s perform the following steps to add Trivy vulnerability checks in GitLab:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来在GitLab中添加Trivy漏洞检查：
- en: 'Edit the CI/CD pipeline configuration `.gitlab-ci.yml` file in your project:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑项目中的CI/CD流水线配置`.gitlab-ci.yml`文件：
- en: '[PRE67]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Add a new stage to your pipeline and define the stage. You can find an example
    in the `src/chapter9/devsecops` directory. In our example, we''re using the `vulTest` stage
    name:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的流水线中添加一个新的阶段并定义该阶段。您可以在`src/chapter9/devsecops`目录中找到一个示例。在我们的示例中，我们使用了`vulTest`阶段名称：
- en: '[PRE68]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Add the new stage, that is, `vulTest`. When you define a new stage, you specify
    a stage name parent key. In our example, the parent key is `trivy`. The commands
    in the `before_script` section will download the `trivy` binaries:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新的阶段，即`vulTest`。当您定义一个新的阶段时，您需要指定一个阶段名称父键。在我们的示例中，父键是`trivy`。`before_script`部分的命令将下载`trivy`二进制文件：
- en: '[PRE69]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, review and add the Trivy scan script and complete the `vulTest` stage.
    The following script will return `--exit-code 1` for the critical severity vulnerabilities,
    as shown here:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，审查并添加Trivy扫描脚本，并完成`vulTest`阶段。以下脚本将对关键严重性漏洞返回`--exit-code 1`，如下所示：
- en: '[PRE70]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now, you can run your pipeline and the new stage will be included in your pipeline.
    The pipeline will fail if a critical vulnerability is detected. If you don't want
    the stage to fail your pipeline, you can also specify `--exit-code 0` for critical
    vulnerabilities.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以运行您的流水线，新阶段将包含在您的流水线中。如果检测到关键漏洞，流水线将失败。如果您不希望该阶段使您的流水线失败，您还可以为关键漏洞指定`--exit-code
    0`。
- en: Building vulnerability scanning into CircleCI
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将漏洞扫描构建到CircleCI中
- en: CircleCI uses Orbs to wrap predefined examples to speed up your project configurations.
    Currently, Trivy doesn't have a CircleCI Orb, but it is still easy to configure
    Trivy with CircleCI. This recipe will take you through adding a test stage to
    the CircleCI pipeline.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: CircleCI使用Orbs来包装预定义的示例，以加快项目配置的速度。目前，Trivy没有CircleCI Orb，但是仍然很容易使用CircleCI配置Trivy。本示例将带您完成向CircleCI流水线添加测试阶段的过程。
- en: 'Let''s perform the following steps to add Trivy vulnerability checks in CircleCI:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来在CircleCI中添加Trivy漏洞检查：
- en: 'Edit the CircleCI configuration file located in our project repository in `.circleci/config.yml`. You
    can find our example in the `src/chapter9/devsecops` directory:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑位于我们项目存储库中的`.circleci/config.yml`的CircleCI配置文件。您可以在`src/chapter9/devsecops`目录中找到我们的示例：
- en: '[PRE71]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Start by adding the job and the image. In this recipe, the job name is `build`:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加作业和镜像。在这个示例中，作业名称是`build`：
- en: '[PRE72]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Start adding the steps to build your image. The `checkout` step will checkout
    the project from its code repository. Since our job will require docker commands,
    add `setup_remote_docker`. When this step is executed, a remote environment will
    be created and your current primary container will be configured appropriately:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始添加构建图像的步骤。`checkout`步骤将从其代码存储库中检出项目。由于我们的作业将需要docker命令，因此添加`setup_remote_docker`。执行此步骤时，将创建远程环境，并且将适当地配置您当前的主要容器：
- en: '[PRE73]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Add the necessary step to install Trivy:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加必要的步骤来安装Trivy：
- en: '[PRE74]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Add the step that will scan a local image with Trivy. Modify the `trivy` parameters
    and preferred exit codes as needed. Here, `trivy` only checks for critical vulnerabilities
    (`--severity CRITICAL`) and fails if a vulnerability is found (`--exit-code 1`).
    It suppresses the progress bar (`--no-progress`) and refreshes the database automatically
    when updating its version (`--auto-refresh`):'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加使用Trivy扫描本地镜像的步骤。根据需要修改`trivy`参数和首选退出代码。在这里，`trivy`仅检查关键漏洞（`--severity CRITICAL`），如果发现漏洞，则失败（`--exit-code
    1`）。它抑制进度条（`--no-progress`），并在更新版本时自动刷新数据库（`--auto-refresh`）：
- en: '[PRE75]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finally, update the workflows to trigger the vulnerability scan:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新工作流以触发漏洞扫描：
- en: '[PRE76]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now, you can run your pipeline in CircleCI and the new stage will be included
    in your pipeline.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在CircleCI中运行您的流水线，新阶段将包含在您的流水线中。
- en: See also
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请参阅
- en: Aqua Security Trivy Comparison: [https://github.com/aquasecurity/trivy#comparison-with-other-scanners](https://github.com/aquasecurity/trivy#comparison-with-other-scanners)
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aqua Security Trivy比较：[https://github.com/aquasecurity/trivy#comparison-with-other-scanners](https://github.com/aquasecurity/trivy#comparison-with-other-scanners)
- en: Aqua Security Trivy CI examples: [https://github.com/aquasecurity/trivy#comparison-with-other-scanners](https://github.com/aquasecurity/trivy#comparison-with-other-scanners)
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aqua Security Trivy CI示例：[https://github.com/aquasecurity/trivy#comparison-with-other-scanners](https://github.com/aquasecurity/trivy#comparison-with-other-scanners)
- en: 'Aqua Security Trivy Alternatives for image vulnerability testing:'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aqua Security Trivy替代品用于图像漏洞测试：
- en: Aqua Security Microscanner: [https://github.com/aquasecurity/microscanner](https://github.com/aquasecurity/microscanner)
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Aqua Security Microscanner: [https://github.com/aquasecurity/microscanner](https://github.com/aquasecurity/microscanner)'
- en: Clair: [https://github.com/coreos/clair](https://github.com/coreos/clair)
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Clair: [https://github.com/coreos/clair](https://github.com/coreos/clair)'
- en: Docker Hub: [https://beta.docs.docker.com/v17.12/docker-cloud/builds/image-scan/](https://beta.docs.docker.com/v17.12/docker-cloud/builds/image-scan/)
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Docker Hub: [https://beta.docs.docker.com/v17.12/docker-cloud/builds/image-scan/](https://beta.docs.docker.com/v17.12/docker-cloud/builds/image-scan/)'
- en: GCR: [https://cloud.google.com/container-registry/docs/container-analysis](https://cloud.google.com/container-registry/docs/container-analysis)
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GCR: [https://cloud.google.com/container-registry/docs/container-analysis](https://cloud.google.com/container-registry/docs/container-analysis)'
- en: Layered Insight: [https://layeredinsight.com/](https://layeredinsight.com/)
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Layered Insight: [https://layeredinsight.com/](https://layeredinsight.com/)'
- en: NeuVector: [https://neuvector.com/vulnerability-scanning/](https://neuvector.com/vulnerability-scanning/)
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NeuVector: [https://neuvector.com/vulnerability-scanning/](https://neuvector.com/vulnerability-scanning/)'
- en: Sysdig Secure: [https://sysdig.com/products/secure/](https://sysdig.com/products/secure/)
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Sysdig Secure: [https://sysdig.com/products/secure/](https://sysdig.com/products/secure/)'
- en: Quay: [https://coreos.com/quay-enterprise/docs/latest/security-scanning.html](https://coreos.com/quay-enterprise/docs/latest/security-scanning.html)
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Quay: [https://coreos.com/quay-enterprise/docs/latest/security-scanning.html](https://coreos.com/quay-enterprise/docs/latest/security-scanning.html)'
- en: Twistlock: [https://www.twistlock.com/platform/vulnerability-management-tools/](https://www.twistlock.com/platform/vulnerability-management-tools/)
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Twistlock: [https://www.twistlock.com/platform/vulnerability-management-tools/](https://www.twistlock.com/platform/vulnerability-management-tools/)'
- en: Monitoring suspicious application activities using Falco
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Falco监视可疑的应用程序活动
- en: Falco is a cloud-native runtime security toolset. Falco gains deep insight into
    system behavior through its runtime rule engine. It is used to detect intrusions
    and abnormalities in applications, containers, hosts, and the Kubernetes orchestrator.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Falco是一个云原生的运行时安全工具集。Falco通过其运行时规则引擎深入了解系统行为。它用于检测应用程序、容器、主机和Kubernetes编排器中的入侵和异常。
- en: In this section, we will cover the installation and basic usage of Falco on
    Kubernetes.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍在Kubernetes上安装和基本使用Falco。
- en: Getting ready
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation to use the
    manifest files in the `chapter9` directory, as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 将`k8sdevopscookbook/src`存储库克隆到您的工作站，以使用`chapter9`目录中的清单文件，如下所示：
- en: '[PRE77]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Make sure you have a Kubernetes cluster ready and `kubectl` and `helm` configured
    to manage the cluster resources.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已准备好一个Kubernetes集群，并配置好`kubectl`和`helm`来管理集群资源。
- en: How to do it…
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'This section will show you how to configure and run Falco. This section is
    further divided into the following subsections to make this process easier:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示如何配置和运行Falco。本节进一步分为以下子节，以使此过程更加简单：
- en: Installing Falco on Kubernetes
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes上安装Falco
- en: Detecting anomalies using Falco
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Falco检测异常
- en: Defining custom rules
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义自定义规则
- en: Installing Falco on Kubernetes
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Kubernetes上安装Falco
- en: Falco can be installed in various ways, including directly on Linux hosts by
    deploying Falco as a DaemonSet or by using Helm. This recipe will show you how
    to install Falco as a DaemonSet.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Falco可以通过多种方式安装，包括直接在Linux主机上部署Falco作为DaemonSet，或者使用Helm。本教程将向您展示如何将Falco安装为DaemonSet。
- en: 'Let''s perform the following steps to get Falco deployed on our cluster:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤，在我们的集群上部署Falco：
- en: 'Clone the Falco repository into your current working directory:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Falco存储库克隆到您当前的工作目录：
- en: '[PRE78]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Create a Service Account for Falco. The following command will also create
    the ClusterRole and ClusterRoleBinding for it:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Falco创建一个服务账户。以下命令还将为其创建ClusterRole和ClusterRoleBinding：
- en: '[PRE79]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Create a service using the following command from the cloned repository location:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从克隆存储库位置的以下命令创建一个服务：
- en: '[PRE80]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create a `config` directory and copy the deployment configuration file and
    rule files in the `config` directory. We will need to edit these later:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`config`目录并将部署配置文件和规则文件复制到`config`目录中。稍后我们需要编辑这些文件：
- en: '[PRE81]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create a ConfigMap using the config files in the `config/` directory. Later,
    the DaemonSet will make the configuration available to Falco pods using the ConfigMap:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`config/`目录中的配置文件创建一个ConfigMap。稍后，DaemonSet将使用ConfigMap使配置对Falco pods可用：
- en: '[PRE82]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finally, deploy Falco using the following command:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下命令部署Falco：
- en: '[PRE83]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Verify that the DaemonSet pods have been successfully created. You should see
    one pod per schedulable worker node on the cluster. In our example, we used a
    Kubernetes cluster with four worker nodes:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证DaemonSet pods已成功创建。您应该在集群上的每个可调度的工作节点上看到一个pod。在我们的示例中，我们使用了一个具有四个工作节点的Kubernetes集群：
- en: '[PRE84]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: With that, Falco has been deployed and started monitoring behavioral activity
    to detect anomalous activities in our applications on our nodes.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，Falco已经部署并开始监视行为活动，以检测我们节点上应用程序中的异常活动。
- en: Detecting anomalies using Falco
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Falco检测异常
- en: Falco detects a variety of suspicious behavior. In this recipe, we will produce
    some activities that would be suspicious on a normal production cluster.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Falco检测到各种可疑行为。在这个教程中，我们将产生一些在正常生产集群中可能会引起怀疑的活动。
- en: 'Let''s perform the following steps to produce activities that would trigger
    a syscall event drop:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来产生可能触发系统调用事件丢弃的活动：
- en: 'First, we need to review the full rules before we test some of the behaviors.
    Falco has two rules files. The default rules are located at `/etc/falco/falco_rules.yaml`,
    while the local rules file is located at `/etc/falco/falco_rules.local.yaml`.
    Your custom rules and modifications should be in the `falco_rules.local.yaml`
    file:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在测试一些行为之前审查完整的规则。Falco有两个规则文件。默认规则位于`/etc/falco/falco_rules.yaml`，而本地规则文件位于`/etc/falco/falco_rules.local.yaml`。您的自定义规则和修改应该在`falco_rules.local.yaml`文件中：
- en: '[PRE85]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'You will see a long list of default rules and macros. Some of them are as follows:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一长串的默认规则和宏。其中一些如下所示：
- en: '[PRE86]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Let''s test that Falco is working by getting a bash shell into one of the Falco
    pods and view the logs afterward. List the Falco pods:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过获取一个bash shell进入其中一个Falco pods并查看日志来测试Falco是否正常工作。列出Falco pods：
- en: '[PRE87]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Get bash shell access to one of the Falco pods from the output of the preceding
    command and view the logs:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上述命令的输出中获取对一个Falco pod的bash shell访问并查看日志：
- en: '[PRE88]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In the logs, you will see that Falco detects our shell access to the pods:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在日志中，您将看到Falco检测到我们对pods的shell访问：
- en: '[PRE89]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: With that, you've learned how to use Falco to detect anomalies and suspicious
    behavior.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，您已经学会了如何使用Falco来检测异常和可疑行为。
- en: Defining custom rules
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义自定义规则
- en: Falco rules can be extended by adding our own rules. In this recipe, we will
    deploy a simple application and create a new rule to detect a malicious application
    accessing our database.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Falco规则可以通过添加我们自己的规则来扩展。在这个教程中，我们将部署一个简单的应用程序，并创建一个新规则来检测恶意应用程序访问我们的数据库。
- en: 'Perform the following steps to create an application and define custom rules
    for Falco:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来创建一个应用程序并为Falco定义自定义规则：
- en: 'Change to the `src/chapter9/falco` directory, which is where our examples are
    located:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`src/chapter9/falco`目录，这是我们示例所在的位置：
- en: '[PRE90]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Create a new `falcotest` namespace:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`falcotest`命名空间：
- en: '[PRE91]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Review the YAML manifest and deploy them using the following commands. These
    commands will create a MySQL pod, web application, a client that we will use to
    ping the application, and its services:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查YAML清单并使用以下命令部署它们。这些命令将创建一个MySQL pod，Web应用程序，我们将用来ping应用程序的客户端，以及它的服务：
- en: '[PRE92]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now, use the client pod with the default credentials of `bob/foobar` to send
    a ping to our application. As expected, we will be able to authenticate and complete
    the task successfully:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用默认凭据`bob/foobar`的客户端pod发送ping到我们的应用程序。预期地，我们将能够进行身份验证并成功完成任务：
- en: '[PRE93]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Edit the `falco_rules.local.yaml` file:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`falco_rules.local.yaml`文件：
- en: '[PRE94]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Add the following rule to the end of the file and save it:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下规则添加到文件末尾并保存：
- en: '[PRE95]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Update the ConfigMap that''s being used for the DaemonSet and delete the pods
    to get a new configuration by running the following command:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新用于DaemonSet的ConfigMap并通过运行以下命令删除pod以获得新的配置：
- en: '[PRE96]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We will execute a SQL injection attack and access the file where our MySQL
    credentials are stored. Our new custom rule should be able to detect it:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将执行SQL注入攻击并访问存储我们的MySQL凭据的文件。我们的新自定义规则应该能够检测到它：
- en: '[PRE97]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The preceding command will return the content of the PHP file. You will be
    able to find the MySQL credentials there:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述命令将返回PHP文件的内容。您将能够在那里找到MySQL凭据：
- en: '[PRE98]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'List the Falco pods:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出Falco pod：
- en: '[PRE99]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'View the logs from a Falco pod:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看来自Falco pod的日志：
- en: '[PRE100]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'In the logs, you will see that Falco detects our shell access to the pods:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在日志中，您将看到Falco检测到我们对pod的shell访问：
- en: '[PRE101]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: With that, you know how to add custom rules using Kubernetes metadata such as `k8s.ns.name`
    and `k8s.deployment.name`. You can also use other filters. This is described in
    more detail in the *Supported filters* link in *See also* section.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，您就知道如何使用Kubernetes元数据（如`k8s.ns.name`和`k8s.deployment.name`）添加自定义规则。您还可以使用其他过滤器。这在*参见*部分的*支持的过滤器*链接中有更详细的描述。
- en: How it works...
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe showed you how to detect anomalies based on the predefined and custom
    rules of your applications when they're running on Kubernetes.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程向您展示了如何在Kubernetes上运行应用程序时，基于预定义和自定义规则来检测异常。
- en: In the *Installing Falco on Kubernetes* recipe, in *Step 5,* we created a ConfigMap
    to be used by the Falco pods. Falco has two types of rules files.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Kubernetes上安装Falco*的步骤中，在*第5步*，我们创建了一个ConfigMap供Falco pod使用。Falco有两种类型的规则文件。
- en: In Step 6, when we created the DaemonSet, all the default rules are provided
    through the `falco_rules.yaml` file in the ConfigMap.These are placed in `/etc/falco/falco_rules.yaml`
    inside the pods, while the local rules file ,  `falco_rules.local.yaml,` can be
    found at `/etc/falco/falco_rules.local.yaml`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步中，当我们创建了DaemonSet时，所有默认规则都是通过ConfigMap中的`falco_rules.yaml`文件提供的。这些放置在pod内的`/etc/falco/falco_rules.yaml`中，而本地规则文件`falco_rules.local.yaml`可以在`/etc/falco/falco_rules.local.yaml`中找到。
- en: The default rules file contains rules for many common anomalies and threats.
    All pieces of customization must be added to the `falco_rules.local.yaml` file,
    which we did in the *Defining custom rules* recipe*.*
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 默认规则文件包含许多常见异常和威胁的规则。所有定制的部分都必须添加到`falco_rules.local.yaml`文件中，我们在*定义自定义规则*教程中已经做到了。
- en: 'In the *Defining custom rules r*ecipe, in *Step 6*, we created a custom rule
    file containing the `rules` element. The Falco rule file is a YAML file that uses
    three kinds of elements: `rules`, `macros`, and `lists`.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在*定义自定义规则*教程中，在*第6步*，我们创建了一个包含`rules`元素的自定义规则文件。Falco规则文件是一个使用三种元素的YAML文件：`rules`，`macros`和`lists`。
- en: 'The rules define certain conditions to send alerts about them. A rule is a
    file that contains at least the following keys:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 规则定义了发送有关特定条件的警报。规则是一个包含至少以下键的文件：
- en: '`rule`: The name of the rule'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rule`：规则的名称'
- en: '`condition`: An expression that''s applied to events to check if they match
    the rule'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`condition`：应用于事件的表达式，用于检查它们是否匹配规则'
- en: '`desc`: Detailed description of what the rule is used for'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`desc`：规则用途的详细描述'
- en: '`output`: The message that is displayed to the user'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output`：显示给用户的消息'
- en: '`priority`: Either emergency, alert, critical, error, warning, notice, informational,
    or debug'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`priority`：紧急、警报、关键、错误、警告、通知、信息或调试'
- en: You can find out more about these rules by going to the *Understanding Falco
    Rules* link that's provided in the *See also* section.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过转到“了解Falco规则”链接来了解更多关于这些规则的信息，该链接提供在“另请参阅”部分中。
- en: See also
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Falco documentation: [https://falco.org/docs/](https://falco.org/docs/)
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Falco文档：[https://falco.org/docs/](https://falco.org/docs/)
- en: Falco repository and integration examples: [https://github.com/falcosecurity/falco](https://github.com/falcosecurity/falco)
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Falco存储库和集成示例：[https://github.com/falcosecurity/falco](https://github.com/falcosecurity/falco)
- en: Understanding Falco Rules:[ https://falco.org/dochttps://falco.org/docs/rules/s/rules/](https://falco.org/dochttps://falco.org/docs/rules/s/rules/)
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Falco规则：[https://falco.org/dochttps://falco.org/docs/rules/s/rules/](https://falco.org/dochttps://falco.org/docs/rules/s/rules/)
- en: Comparing Falco with other tools: [https://sysdig.com/blog/selinux-seccomp-falco-technical-discussion/](https://sysdig.com/blog/selinux-seccomp-falco-technical-discussion/)
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Falco与其他工具进行比较：[https://sysdig.com/blog/selinux-seccomp-falco-technical-discussion/](https://sysdig.com/blog/selinux-seccomp-falco-technical-discussion/)
- en: 'Supported filters: [https://github.com/draios/sysdig/wiki/Sysdig-User-Guide#all-supported-filters](https://github.com/draios/sysdig/wiki/Sysdig-User-Guide#all-supported-filters)'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的过滤器：[https://github.com/draios/sysdig/wiki/Sysdig-User-Guide#all-supported-filters](https://github.com/draios/sysdig/wiki/Sysdig-User-Guide#all-supported-filters)
- en: Securing credentials using HashiCorp Vault
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HashiCorp Vault保护凭据
- en: HashiCorp Vault is a popular tool for securely storing and accessing secrets
    such as credentials, API keys, and certificates. Vault provides secure secret
    storage, on-demand dynamic secrets, data encryption, and support for secret revocation.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp Vault是一个流行的工具，用于安全存储和访问诸如凭据、API密钥和证书之类的秘密。 Vault提供安全的秘密存储，按需动态秘密，数据加密以及支持秘密吊销。
- en: In this section, we will cover the installation and basic use case of accessing
    and storing secrets for Kubernetes.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍访问和存储Kubernetes秘密的安装和基本用例。
- en: Getting ready
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation to use the
    manifest files in the `chapter9` directory, as follows:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 将`k8sdevopscookbook/src`存储库克隆到您的工作站，以便在`chapter9`目录中使用清单文件，方法如下：
- en: '[PRE102]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Make sure you have a Kubernetes cluster ready and `kubectl` and `helm` configured
    to manage the cluster resources.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已准备好Kubernetes集群，并配置了`kubectl`和`helm`以管理集群资源。
- en: How to do it…
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'This section is further divided into the following subsections to make this
    process easier:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 本节进一步分为以下小节，以使此过程更加简单：
- en: Installing Vault on Kubernetes
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes上安装Vault
- en: Accessing the Vault UI
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问Vault UI
- en: Storing credentials on Vault
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vault上存储凭据
- en: Installing Vault on Kubernetes
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Kubernetes上安装Vault
- en: 'This recipe will show you how to get a Vault service on Kubernetes. Let''s
    perform the following steps to get Vault installed using Helm charts:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 此教程将向您展示如何在Kubernetes上获取Vault服务。 让我们执行以下步骤，使用Helm图表安装Vault：
- en: 'Clone the chart repository:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆图表存储库：
- en: '[PRE103]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Check out the latest stable release:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查最新的稳定版本：
- en: '[PRE104]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'If you would like to install a highly available Vault, skip to *Step 4*; otherwise,
    install the standalone version using the Helm chart parameters shown here:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想要安装高可用的Vault，请跳至*步骤4*；否则，请使用此处显示的Helm图表参数安装独立版本：
- en: '[PRE105]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'To deploy a highly available version that uses an HA storage backend such as
    Consul, use the following Helm chart parameters. This will deploy Vault using
    a StatefulSet with three replicas:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要部署使用HA存储后端（如Consul）的高可用版本，请使用以下Helm图表参数。 这将使用具有三个副本的StatefulSet部署Vault：
- en: '[PRE106]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Verify the status of the pods. You will notice that the pods aren''t ready
    since the readiness probe requires Vault to be initialized first:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证pod的状态。您会注意到pod尚未准备就绪，因为就绪探针要求首先初始化Vault：
- en: '[PRE107]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Check the initialization status. It should be `false`:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查初始化状态。它应该是`false`：
- en: '[PRE108]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Initialize the Vault instance. The following command will return an unseal
    key and root token:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化Vault实例。以下命令将返回一个解封密钥和根令牌：
- en: '[PRE109]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Unseal Vault using the unseal key from the output of the following command:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令的输出中的解封密钥解封Vault：
- en: '[PRE110]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Verify the pod''s status. You will see that the readiness probe has been validated
    and that the pod is ready:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证pod的状态。您将看到就绪探针已经验证，并且pod已准备就绪：
- en: '[PRE111]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Vault is ready to be used after it is initialized. Now, you know how to get
    Vault running on Kubernetes.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: Vault在初始化后即可使用。现在，您知道如何在Kubernetes上运行Vault了。
- en: Accessing the Vault UI
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问Vault UI
- en: 'By default, the Vault UI is enabled when using a Helm chart installation. Let''s
    perform the following steps to access the Vault UI:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在使用Helm图表安装时，启用Vault UI。让我们执行以下步骤来访问Vault UI：
- en: 'Since access to Vault is a security concern, it is not recommended to expose
    it with a service. Use port-forwarding to access the Vault UI using the following
    command:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于访问Vault是一个安全问题，不建议使用服务暴露它。使用端口转发来访问Vault UI，使用以下命令：
- en: '[PRE112]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Once forwarding is complete, you can access the UI at `http://localhost:8200`:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦转发完成，您可以在`http://localhost:8200`上访问UI：
- en: '![](assets/1b504490-441c-4b87-9a8f-a44ab9159dc2.png)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1b504490-441c-4b87-9a8f-a44ab9159dc2.png)'
- en: Now, you have access to the web UI. Take the Vault Web UI tour to familiarize
    yourself with its functionality.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以访问Web UI。参加Vault Web UI之旅，熟悉其功能。
- en: Storing credentials on Vault
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Vault中存储凭据
- en: This recipe will show you how to use Vault in Kubernetes and retrieve secrets
    from Vault.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 此教程将向您展示如何在Kubernetes中使用Vault，并从Vault中检索秘密。
- en: 'Let''s perform the following steps to enable the Kubernetes authentication
    method in Vault:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来在Vault中启用Kubernetes认证方法：
- en: 'Log in to Vault using your token:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的令牌登录Vault：
- en: '[PRE113]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Write a secret to Vault:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向Vault写入一个秘密：
- en: '[PRE114]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Let''s configure Vault''s Kubernetes authentication backend. First, create
    a ServiceAccount:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们配置Vault的Kubernetes认证后端。首先，创建一个ServiceAccount：
- en: '[PRE115]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Create a RoleBinding for the `vault-k8s` ServiceAccount:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`vault-k8s` ServiceAccount创建一个RoleBinding：
- en: '[PRE116]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Get the token:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取令牌：
- en: '[PRE117]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Enable the Kubernetes auth backend in the vault:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在vault中启用Kubernetes认证后端：
- en: '[PRE118]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Create a new policy called `vault-policy` from the example repository using
    the `policy.hcl`: file:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`policy.hcl`文件从示例存储库创建一个名为`vault-policy`的新策略：
- en: '[PRE119]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Next, create a Role for the ServiceAccount:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为ServiceAccount创建一个角色：
- en: '[PRE120]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Authenticate with the Role by running the following command:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令使用角色进行身份验证：
- en: '[PRE121]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Log in to the Vault with the token by running the following command:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令使用令牌登录Vault：
- en: '[PRE122]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Create a secret at the `secret/demo` path:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`secret/demo`路径下创建一个秘密：
- en: '[PRE123]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: With that, you've learned how to create a Kubernetes auth backend with Vault
    and use Vault to store Kubernetes secrets.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，您已经学会了如何在Vault中创建Kubernetes认证后端，并使用Vault存储Kubernetes秘密。
- en: See also
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Hashicorp Vault documentation: [https://www.vaultproject.io/docs/](https://www.vaultproject.io/docs/)
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hashicorp Vault文档：[https://www.vaultproject.io/docs/](https://www.vaultproject.io/docs/)
- en: Hashicorp Vault repository: [https://github.com/hashicorp/vault-helm ](https://github.com/hashicorp/vault-helm)
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hashicorp Vault存储库：[https://github.com/hashicorp/vault-helm](https://github.com/hashicorp/vault-helm)
- en: Hands-on with Vault on Kubernetes: [https://github.com/hashicorp/hands-on-with-vault-on-kubernetes](https://github.com/hashicorp/hands-on-with-vault-on-kubernetes)
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes上使用Vault的实践：[https://github.com/hashicorp/hands-on-with-vault-on-kubernetes](https://github.com/hashicorp/hands-on-with-vault-on-kubernetes)
