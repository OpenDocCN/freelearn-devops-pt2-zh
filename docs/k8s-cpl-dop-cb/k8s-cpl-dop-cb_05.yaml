- en: Preparing for Stateful Workloads
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 为有状态的工作负载做准备
- en: In this chapter, we will discuss using popular open source storage solutions
    on Kubernetes and how to protect the state of applications from node or application
    failures and share the same data, or how to handle reattaching volumes when the
    pod is rescheduled on a different node. After following the recipes in this chapter,
    you will have acquired the skills to use both block and file storage options in
    self-managed infrastructure or private clouds.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论在Kubernetes上使用流行的开源存储解决方案，以及如何保护应用程序的状态免受节点或应用程序故障，并共享相同的数据，或者如何在Pod被重新调度到不同节点时处理重新附加卷。在本章的示例中，您将学会在自管理基础设施或私有云中使用块和文件存储选项的技能。
- en: 'In this chapter, we will be covering the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下示例：
- en: Managing Amazon EBS volumes in Kubernetes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes中管理Amazon EBS卷
- en: Managing GCE PD volumes in Kubernetes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes中管理GCE PD卷
- en: Managing Azure Disk volumes in Kubernetes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes中管理Azure Disk卷
- en: Configuring and managing persistent storage using Rook
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rook配置和管理持久存储
- en: Configuring and managing persistent storage using OpenEBS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenEBS配置和管理持久存储
- en: Setting up NFS for shared storage on Kubernetes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes上设置NFS共享存储
- en: Troubleshooting storage issues
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除存储问题
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Recipes in this section assume that you have a functional Kubernetes cluster
    deployed according to one of the recommended methods described in  [Chapter 1](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml), *Building
    Production-Ready Kubernetes Clusters*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例假定您已根据[第1章](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml)中描述的推荐方法之一部署了功能性Kubernetes集群，*构建生产就绪的Kubernetes集群*。
- en: Kubernetes' command-line tool, `kubectl`, will be used for the remainder of
    the recipes in this section since it is the main command-line interface for running
    commands against Kubernetes clusters. We will also use `helm` where helm charts
    are available to deploy solutions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的命令行工具`kubectl`将在本节的其余示例中使用，因为它是针对Kubernetes集群运行命令的主要命令行界面。我们还将使用`helm`在可用helm图表的情况下部署解决方案。
- en: Managing Amazon EBS volumes in Kubernetes
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes中管理Amazon EBS卷
- en: Amazon Elastic Block Store (Amazon EBS) provides persistent block-level storage
    volumes for Amazon EC2 instances used in both `kops`-created Kubernetes clusters
    and Amazon EKS clusters in AWS. In this section, we will create storage classes
    for your applications in Kubernetes running in AWS. You will learn how to create
    a StorageClass resource in Kubernetes, you will learn about the parameters available with
    the variation in performance of EBS volume types and also use the new **Container
    Storage Interface** (**CSI**) to consume EBS volumes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Elastic Block Store（Amazon EBS）为在AWS中使用的Amazon EC2实例提供持久的块级存储卷，这些实例用于`kops`创建的Kubernetes集群和Amazon
    EKS集群。在本节中，我们将为在AWS中运行的Kubernetes应用程序创建存储类。您将学习如何在Kubernetes中创建`StorageClass`资源，了解EBS卷类型性能差异的参数，并使用新的**容器存储接口**（**CSI**）来消耗EBS卷。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation in order to
    be able to use manifest files under the `chapter5` directory:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆`k8sdevopscookbook/src`存储库到您的工作站，以便能够使用`chapter5`目录下的清单文件：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Make sure that you have a Kubernetes cluster ready and `kubectl` configured
    to manage the cluster resources.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已准备好一个Kubernetes集群，并配置了`kubectl`来管理集群资源。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '如何做到… '
- en: 'This section is sub-divided further into the following subsections to facilitate
    the process:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本节进一步细分为以下子节，以便促进流程：
- en: Creating an EBS storage class
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建EBS存储类
- en: Changing the default storage class
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改默认存储类
- en: Using EBS volumes for persistent storage
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用EBS卷进行持久存储
- en: Using EBS storage classes to dynamically create persistent volumes
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用EBS存储类动态创建持久卷
- en: Deleting EBS persistent volumes
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除EBS持久卷
- en: Installing the EBS CSI driver to manage EBS volumes
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装EBS CSI驱动程序以管理EBS卷
- en: Creating an EBS storage class
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建EBS存储类
- en: 'Let''s perform the following steps to learn the storage class parameters required
    to construct an EBS storage class that we can use to dynamically request new persistent
    volumes from AWS Cloud:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来学习构建EBS存储类所需的存储类参数，我们可以使用它来动态请求AWS Cloud中的新持久卷：
- en: 'Create a basic storage class with the provisioner, `kubernetes.io/aws-ebs`,
    and `gp2` type specified:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基本的存储类，指定提供程序`kubernetes.io/aws-ebs`和类型`gp2`：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Other type values accepted here include `io1`, `sc1`, and `st1`. You can find
    the definition and use cases for different volume types on the AWS EBS volume
    types link in the *See also* section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此处还接受其他类型值，包括`io1`、`sc1`和`st1`。您可以在*另请参阅*部分的AWS EBS卷类型链接中找到不同卷类型的定义和用例。
- en: On Amazon EKS clusters, the default EBS volume type is `gp2`. For database workloads,
    such as MongoDB, Cassandra, and PostgreSQL, `io1-type`, high-performance SSDs
    are recommended.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Amazon EKS集群上，默认的EBS卷类型是`gp2`。对于数据库工作负载，如MongoDB、Cassandra和PostgreSQL，建议使用`io1-type`高性能SSD。
- en: 'List the storage classes. Confirm that you have new `aws-gp2` on the list.
    Depending on the cloud provider or Kubernetes deployment tool, you may see other
    storage classes on the list similar to the following:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出存储类。确认列表中是否有新的`aws-gp2`。根据云提供商或Kubernetes部署工具，您可能会在列表中看到类似以下的其他存储类：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Storage classes are the foundation of dynamic provisioning. As you can see in
    our example, you may have more than one storage class in your cluster. Ideally,
    storage classes should be created with an application's requirements in mind,
    since certain applications require faster volumes, while others may take advantage
    of multi-availability zone replication provided by solutions such as Rook and
    OpenEBS, which we will deploy later in this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 存储类是动态配置的基础。正如我们在示例中所看到的，您的集群中可能有多个存储类。理想情况下，存储类应该根据应用程序的需求创建，因为某些应用程序需要更快的卷，而其他应用程序可能会利用Rook和OpenEBS等解决方案提供的多可用区复制。
- en: Changing the default storage class
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改默认存储类
- en: 'Dynamic storage provisioning is a key part of scaling applications. When a
    storage class is not specified by a **Persistent Volume Claim** (**PVC**), Kubernetes
    uses the default option. Let''s perform the following steps to set our preferred
    storage class as the default:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 动态存储配置是扩展应用程序的关键部分。当未指定存储类时，Kubernetes会使用默认选项。让我们执行以下步骤来将我们首选的存储类设置为默认选项：
- en: 'Create a new storage class and define it as the default at the same time by
    setting the `is-default-class` value to `true`. Our example here uses the `io1`
    volume type and limits `iopsPerGB` to `10`. It also sets `reclaimPolicy` to `Retain`,
    meaning that, if the user deletes the related PVC, the volume will be retained
    (the other two retain policy options are `Recycle` and `Delete`):'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`is-default-class`值设置为`true`，同时创建一个新的存储类并将其定义为默认存储类。我们的示例在此处使用`io1`卷类型，并将`iopsPerGB`限制为`10`。它还将`reclaimPolicy`设置为`Retain`，这意味着，如果用户删除相关的PVC，卷将被保留（其他两个保留策略选项是`Recycle`和`Delete`）：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To change the status of an existing storage class after it has been created,
    first pick a storage class:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建存储类后更改现有存储类的状态之前，首先选择一个存储类：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s set the existing storage class, `aws-io1-slow`, as the non-default option:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将现有的存储类`aws-io1-slow`设置为非默认选项：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, define `aws-gp2` as the default storage class again:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次将`aws-gp2`定义为默认存储类：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Confirm the new default storage class:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认新的默认存储类：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Make sure that there is always one default storage class at a time, otherwise
    PVCs without a storage class defined that are expecting a default storage class
    will fail.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 确保始终只有一个默认存储类，否则没有定义存储类但期望默认存储类的PVC将失败。
- en: Using EBS volumes for persistent storage
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用EBS卷进行持久存储
- en: 'As an alternative to creating PVCs and dynamically creating volumes, you can
    also manually create a volume and attach it to your application directly as a
    persistent volume by carrying out the following steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 作为创建PVC和动态创建卷的替代方案，您还可以手动创建卷并将其直接附加到您的应用程序作为持久卷，执行以下步骤：
- en: 'Create an EBS volume in the same zone as your worker nodes by using the following `aws`
    CLI:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下`aws` CLI在与您的工作节点相同的区域创建EBS卷：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Deploy a test application using the EBS `volumeID` you created in *Step 1:*
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您在*步骤1*中创建的EBS `volumeID` 部署一个测试应用程序：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Verify that your pod is in the `Running` state:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您的pod处于`Running`状态：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The main advantage of manually created persistent volumes (PVs) is that PVs
    are not attached to a single cluster or namespace. They exist as a resource on
    your AWS cloud account and they can even be shared across clusters where dynamically
    created PVCs only exist in the namespace created and can only be used by a pod
    within that same namespace.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建持久卷（PV）的主要优势在于PV不附加到单个集群或命名空间。它们作为您AWS云账户上的资源存在，甚至可以跨集群共享，而动态创建的PVC只存在于创建的命名空间中，并且只能被同一命名空间内的pod使用。
- en: Using EBS storage classes to dynamically create persistent volumes
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用EBS存储类动态创建持久卷
- en: 'As part of a StatefulSet, `volumeClaimTemplates` can provide persistent storage
    using `PersistentVolumes` provisioned by a `PersistentVolume` provisioner of your
    choice. In this recipe, we will use StorageClass to dynamically create PVs for
    your application. Let''s begin with the following steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为StatefulSet的一部分，`volumeClaimTemplates`可以使用您选择的`PersistentVolume`提供持久存储。在这个示例中，我们将使用StorageClass动态为您的应用程序创建PV。让我们从以下步骤开始：
- en: 'Add the `aws-gp2` storage class line under the `volumeClaimTemplates` section
    of your application deployment manifest, similar to the following example:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序部署清单的`volumeClaimTemplates`部分下添加`aws-gp2`存储类行，类似于以下示例：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this recipe, we will deploy the Redis StatefulSet using the `aws-gp2` storage
    class. Review the YAML manifest under the `src/chapter5/aws` directory in the
    example repository before we execute it:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`aws-gp2`存储类部署Redis StatefulSet。在执行之前，请查看示例存储库中`src/chapter5/aws`目录下的YAML清单：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create the Redis StatefulSet using the following example:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下示例创建Redis StatefulSet：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Verify that pods have been created. In this recipe, our example has StatefulSet
    with three replicas. As a result, you should see three replicas running, similar
    to the following output:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证已创建pod。在这个示例中，我们的示例有带有三个副本的StatefulSet。因此，您应该看到三个运行的副本，类似于以下输出：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'List the PVC and PVs created. You should expect to see three PVCs and three
    PVs created similar to our example output here:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出已创建的PVC和PV。您应该期望看到创建的三个PVC和三个PV，类似于我们这里的示例输出：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, you know how to dynamically create persistent volumes as part of your deployment.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您知道如何在部署中动态创建持久卷了。
- en: Deleting EBS persistent volumes
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除EBS持久卷
- en: 'When the reclaim policy is set to retain the volumes, they need to be removed
    separately by observing the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当回收策略设置为保留卷时，需要通过以下步骤单独删除卷：
- en: 'Remember that deleting your workload will not remove the PVCs and PVs, unless
    the PVC manifest was included in the manifest:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，删除您的工作负载不会删除PVC和PV，除非PVC清单包含在清单中：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'List the remaining PVs:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出剩余的PV：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Delete the PVCs. You can delete multiple PVCs at once by adding their names
    in a single command, similar to the following:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除PVC。您可以通过在单个命令中添加它们的名称来一次删除多个PVC，类似于以下内容：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Delete the PVs. You can delete multiple PVs at once by adding their names in
    a single command, similar to the following:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除PV。您可以通过在单个命令中添加它们的名称来一次删除多个PV，类似于以下内容：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Although we removed PVCs and PVs, our EBS volumes are still retained. Let''s
    now remove these as well:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们删除了PVC和PV，但我们的EBS卷仍然保留。现在让我们也删除这些：
- en: 'Open your AWS Management Console and click on EC2 under the Compute options:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的AWS管理控制台，然后在“计算”选项下单击EC2：
- en: '![](assets/e950d5e0-afe9-48f7-b588-31547287014d.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e950d5e0-afe9-48f7-b588-31547287014d.png)'
- en: 'Under the Resources section, click on Volumes:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“资源”部分下，单击“卷”：
- en: '![](assets/d70688f4-a325-4cab-afbe-ab46f6fbfa53.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d70688f4-a325-4cab-afbe-ab46f6fbfa53.png)'
- en: 'Select the available and unused volumes. From the *Using EBS storage classes
    to create dynamic persistent volumes *recipe, we have three unused volumes:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择可用且未使用的卷。从*使用EBS存储类创建动态持久卷*中，我们有三个未使用的卷：
- en: '![](assets/5bf71b92-1704-4166-af24-4ce639775da0.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5bf71b92-1704-4166-af24-4ce639775da0.png)'
- en: 'From the Actions drop-down menu, select Delete Volumes:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“操作”下拉菜单中，选择“删除卷”：
- en: '![](assets/9d9a918f-52e3-4ff9-ab64-6989ef4c5c27.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9d9a918f-52e3-4ff9-ab64-6989ef4c5c27.png)'
- en: We have successfully removed all storage resources related to the application
    that was created as part of the Redis StatefulSet resource.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功删除了与作为Redis StatefulSet资源的一部分创建的应用程序相关的所有存储资源。
- en: Installing the EBS CSI driver to manage EBS volumes
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装EBS CSI驱动程序以管理EBS卷
- en: 'The Amazon EBS CSI driver provides a Kubernetes CSI interface that allows Amazon
    EKS clusters to simply manage the life cycle of Amazon EBS volumes for persistent
    volumes. In this recipe, we will learn how to install the EBS CSI driver by observing
    the following steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon EBS CSI驱动程序提供了一个允许Amazon EKS集群简单管理Amazon EBS卷的生命周期的Kubernetes CSI接口。在本教程中，我们将学习如何通过以下步骤安装EBS
    CSI驱动程序：
- en: 'EBS CSI communicates with your AWS volume to create volumes on demand. Therefore,
    it requires access credentials. Replace the `key_id` and `access_key` values here
    with your AWS credentials and configure CSI driver permission using a secret resource:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: EBS CSI与您的AWS卷通信，以按需创建卷。因此，它需要访问凭据。请在此处用您的AWS凭据替换`key_id`和`access_key`的值，并使用秘密资源配置CSI驱动程序权限：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Deploy the AWS EBS CSI driver from its repository location. The following command
    will create ClusterRoleBindings, CSI controller deployment, and an `ebs-csi-node`
    DaemonSet that will run every worker node you have:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其存储库位置部署AWS EBS CSI驱动程序。以下命令将创建ClusterRoleBindings、CSI控制器部署和将在每个工作节点上运行的`ebs-csi-node`
    DaemonSet：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Verify that the driver is running:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证驱动程序是否正在运行：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, create a new storage class that will use `ebs.csi.aws.com` as the provisioner:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个新的存储类，该存储类将使用`ebs.csi.aws.com`作为提供者：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a PVC:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建PVC：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a pod that will use the PVC and that writes to the `/data/out.txt` file:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将使用PVC并写入`/data/out.txt`文件的pod：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Verify that our `mytestapp` pod writes data to the volume:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证我们的`mytestapp` pod是否将数据写入卷：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Remove resources by deleting the pod and the PVC by using the following command:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用以下命令删除pod和PVC来删除资源：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now you know how to use CSI drivers to provision EBS volumes. A CSI driver provides
    a unified interface to answer storage requests on Kubernetes. As long as the driver
    is installed and has the functionality implemented by the driver, it can be consumed
    by the user regardless of the underlying storage system.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何使用CSI驱动程序来配置EBS卷。CSI驱动程序提供了一个统一的接口来响应Kubernetes上的存储请求。只要驱动程序已安装并且具有驱动程序实现的功能，无论底层存储系统如何，用户都可以使用它。
- en: See also
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: AWS EBS volume types: [https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS EBS卷类型：[https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html)
- en: AWS EBS CSI driver repository: [https://github.com/kubernetes-sigs/aws-ebs-csi-driver](https://github.com/kubernetes-sigs/aws-ebs-csi-driver)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS EBS CSI驱动程序存储库：[https://github.com/kubernetes-sigs/aws-ebs-csi-driver](https://github.com/kubernetes-sigs/aws-ebs-csi-driver)
- en: 'AWS EBS CSI driver documentation: [https://docs.aws.amazon.com/eks/latest/userguide/ebs-csi.html](https://docs.aws.amazon.com/eks/latest/userguide/ebs-csi.html)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS EBS CSI驱动程序文档：[https://docs.aws.amazon.com/eks/latest/userguide/ebs-csi.html](https://docs.aws.amazon.com/eks/latest/userguide/ebs-csi.html)
- en: Managing GCE PD volumes in Kubernetes
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes中管理GCE PD卷
- en: '**Google Cloud Platform** (**GCP**) provides persistent block-level storage
    volumes for use with **Google Kubernetes Engine** (**GKE**) instances. In this section,
    we will create storage classes for your applications in Kubernetes running in
    the GKE. You will learn to create a StorageClass resource in Kubernetes, you will
    learn about the parameters available with the variation in performance of GCP
    PD volume types, and also use the new CSI.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Platform（GCP）为Google Kubernetes Engine（GKE）实例提供持久的块级存储卷。在本节中，我们将为在GKE中运行的Kubernetes应用程序创建存储类。您将学习在Kubernetes中创建StorageClass资源，了解GCP
    PD卷类型性能变化的参数，并使用新的CSI。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将`k8sdevopscookbook/src`存储库克隆到您的工作站：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Make sure that you have a regional GKE cluster ready and `kubectl` configured
    to manage the cluster resources.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您有一个区域性的GKE集群准备就绪，并配置`kubectl`来管理集群资源。
- en: How to do it…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'This section is sub-divided further into the following subsections to facilitate
    the process:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本节进一步细分为以下子节，以便进行操作：
- en: Creating a GCE persistent disk storage class
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建GCE持久磁盘存储类
- en: Changing the default storage class
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改默认存储类
- en: Using GCE PD volumes for persistent storage
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GCE PD卷进行持久存储
- en: Using GCE PD storage classes to create dynamic persistent volumes
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GCE PD存储类创建动态持久卷
- en: Deleting GCE PD persistent volumes
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除GCE PD持久卷
- en: Installing the GCP Compute PD CSI driver to manage PD volumes
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装GCP Compute PD CSI驱动程序来管理PD卷
- en: Creating a GCE persistent disk storage class
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建GCE持久磁盘存储类
- en: 'Let''s perform the following steps to learn the storage class parameters to
    construct a GCE PD storage class that we can use to dynamically request new persistent
    volumes:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来学习存储类参数，以构建一个GCE PD存储类，我们可以用来动态请求新的持久卷：
- en: 'GKE-based Kubernetes clusters are created with a default storage class. List
    the storage classes as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于GKE的Kubernetes集群创建时会有默认的存储类。列出存储类如下：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Describe the `standard` storage class:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述`standard`存储类：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a basic storage class with the provisioner, `kubernetes.io/gce-pd`,
    and the `pd-standard` type specified:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建基本的存储类，指定`kubernetes.io/gce-pd`的provisioner和`pd-standard`类型：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can find the definition and use cases for different volume types on the
    *GCE PD volume types* link in the *See also* section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*GCE PD卷类型*链接中找到不同卷类型的定义和用例，位于*另请参阅*部分。
- en: On GKE clusters, the default PD volume type is `pd-standard`. For database workloads,
    such as MongoDB, Cassandra, and PostgreSQL, `pd-ssd-type`, high-performance SSDs
    are recommended.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在GKE集群上，默认的PD卷类型是`pd-standard`。对于MongoDB、Cassandra和PostgreSQL等数据库工作负载，建议使用`pd-ssd-type`高性能SSD。
- en: 'List the storage classes:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出存储类：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: GKE comes with a default storage class called `standard`. You may have more
    than one storage class in your cluster. Ideally, storage classes should be created
    with an application's requirements in mind, since certain applications require
    faster volumes, while others may take advantage of multi-availability zone replication
    provided by other solutions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: GKE带有一个名为`standard`的默认存储类。您的集群中可能有多个存储类。理想情况下，存储类应根据应用程序的要求创建，因为某些应用程序需要更快的卷，而其他应用程序可能利用其他解决方案提供的多可用区复制。
- en: Changing the default storage class
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改默认存储类
- en: 'Dynamic storage provisioning is a key part of scaling applications. When a
    storage class is not specified by a PVC, Kubernetes uses the default option. Let''s
    perform the following steps to set our preferred storage class as the default:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 动态存储配置是扩展应用程序的关键部分。当PVC未指定存储类时，Kubernetes将使用默认选项。让我们执行以下步骤，将我们首选的存储类设置为默认值：
- en: 'Let''s create a new storage class and define it as the default option at the
    same time by setting `is-default-class` to `true`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的存储类，并通过将`is-default-class`设置为`true`来同时将其定义为默认选项：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Having more than one default storage class will cause a problem. You need to
    remove one. To change the status of an existing storage class after it has been
    created, first pick a storage class:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拥有多个默认存储类将会导致问题。您需要删除一个。要更改已创建的存储类的状态，请首先选择一个存储类：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s set the `standard` and `gce-pd-ssd` storage classes as non-default:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`standard`和`gce-pd-ssd`存储类设置为非默认值：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s now define `gce-pd` as the default storage class again:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们再次将`gce-pd`定义为默认存储类：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Confirm the new default storage class:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认新的默认存储类：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now you have learned how to replace the default storage class with a new storage
    class. Make sure that there is always one default storage class at a time; otherwise
    PVCs without a storage class defined that are expecting a default storage class
    will fail.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何用新的存储类替换默认存储类。确保始终只有一个默认存储类；否则，没有定义存储类的PVC将失败。
- en: Using GCE PD volumes for persistent storage
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用GCE PD卷进行持久存储
- en: 'As an alternative to creating PVCs and dynamically creating volumes, you can
    also create a volume manually and attach it to your application directly as a
    persistent volume by observing the following steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 作为创建PVC和动态创建卷的替代方案，您还可以手动创建卷，并将其直接附加到应用程序作为持久卷，观察以下步骤：
- en: 'Create a GCE PD volume in the same zone as your worker nodes:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与工作节点相同的区域创建GCE PD卷：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create a PV using the existing volume name, `gce-disk-1`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用现有卷名`gce-disk-1`创建PV：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a PVC using the PV name, `gce-disk-1`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用PV名称`gce-disk-1`创建PVC：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Deploy a test application using the `volumeMounts` name, `gce-disk-1`, that you
    have created in *Step 1:*
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您在*步骤1*中创建的`volumeMounts`名称`gce-disk-1`部署测试应用程序。
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Verify that your pod is in the `Running` state:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您的pod处于`Running`状态：
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The main advantage of manually created PVs is that PVs are not attached to a
    single cluster or namespace. They exist as a resource on your GCP account and
    they can even be shared across clusters. On the other hand, dynamically created
    PVCs only exist in the namespace created and can only be used by a pod within
    that same namespace.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建PV的主要优势在于PV不附加到单个集群或命名空间。它们作为您的GCP帐户上的资源存在，甚至可以跨集群共享。另一方面，动态创建的PVC仅存在于创建的命名空间中，并且只能被同一命名空间内的pod使用。
- en: Using GCE PD storage classes to create dynamic persistent volumes
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用GCE PD存储类创建动态持久卷
- en: 'As part of a StatefulSet, `volumeClaimTemplates` can provide persistent storage
    using `PersistentVolumes` provisioned by a `PersistentVolume` provisioner of your
    choice. In this recipe, we will use StorageClass to dynamically create PVs for
    your application:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 作为StatefulSet的一部分，`volumeClaimTemplates`可以使用您选择的`PersistentVolume`提供程序提供持久存储。在这个示例中，我们将使用StorageClass为您的应用程序动态创建PV：
- en: 'Add the `gce-pd` storage class line under the `volumeClaimTemplates` section
    of your application deployment manifest, similar to the following example:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序部署清单的`volumeClaimTemplates`部分下添加`gce-pd`存储类行，类似于以下示例：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this recipe, we will deploy the Redis Statefulset using the `gce-pd` storage
    class. Review the YAML manifest under the `src/chapter5/gcp` directory in the
    example repository before we execute it:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`gce-pd`存储类部署Redis Statefulset。在执行之前，请查看示例存储库中`src/chapter5/gcp`目录下的YAML清单：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create the Redis StatefulSet:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Redis StatefulSet：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Verify that pods have been created:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证已创建了Pod：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'List the PVCs and PVs created:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出已创建的PVC和PV：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now you know how to dynamically create GCE PD persistent volumes as part of
    your application deployment.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何在应用程序部署的一部分动态创建GCE PD持久卷。
- en: Deleting GCE PD persistent volumes
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除GCE PD持久卷
- en: 'When the reclaim policy is set to retain the volumes, they need to be removed
    separately by observing the following steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当回收策略设置为保留卷时，需要通过以下步骤单独删除它们：
- en: 'Remember that deleting your workload will not remove the PVCs and PVs, unless
    a PVC manifest was included in the manifest:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，删除工作负载不会删除PVC和PV，除非清单中包含PVC清单：
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'List the remaining PVs:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出剩余的PV：
- en: '[PRE49]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Delete the PVCs. You can delete multiple PVCs at once by adding their names
    in a single command, similar to the following:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除PVC。您可以通过在单个命令中添加它们的名称一次性删除多个PVC，类似于以下内容：
- en: '[PRE50]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We have successfully removed all storage resources related to the application
    that was created as part of the Redis StatefulSet resource.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功删除了与Redis StatefulSet资源一起创建的应用程序相关的所有存储资源。
- en: Installing the GCP Compute PD CSI driver to manage PD volumes
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装GCP Compute PD CSI驱动程序来管理PD卷。
- en: 'The GCP Compute PD CSI driver provides a Kubernetes CSI interface that allows
    GKE clusters to simply manage the life cycle of GKE volumes for persistent volumes.
    In this recipe, we will learn the steps required to install the GCP Compute PD
    CSI driver by observing the following steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: GCP Compute PD CSI驱动程序提供了一个Kubernetes CSI接口，允许GKE集群简单地管理持久卷的GKE卷的生命周期。在这个示例中，我们将学习安装GCP
    Compute PD CSI驱动程序所需的步骤，通过以下步骤观察：
- en: 'Clone the GCP CSI driver project:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆GCP CSI驱动程序项目：
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Replace the `PROJECT` name with your GCP project name, `GCE_PD_SA_DIR`, in
    the location where your service account private key file is stored and set the
    GCP service account variables:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PROJECT`名称替换为您的GCP项目名称，在存储服务帐户私钥文件的位置设置`GCE_PD_SA_DIR`，并设置GCP服务帐户变量：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Deploy the GCP Compute PD CSI driver:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署GCP Compute PD CSI驱动程序：
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Verify that the driver is running:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证驱动程序是否正在运行：
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, create a new regional storage class using the `pd.csi.storage.gke.io` provisioner:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`pd.csi.storage.gke.io`提供程序创建一个新的区域性存储类：
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create a PVC:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建PVC：
- en: '[PRE56]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a pod that will use the PVC and that writes to the `/data/out.txt` file:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将使用PVC并写入`/data/out.txt`文件的Pod：
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Verify that our `mytestapp` pod writes data to the volume:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证我们的`mytestapp` Pod是否将数据写入卷：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Remove the resources:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除资源：
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now you know how to utilize a CSI driver to deploy GCE PD volumes on GKE clusters.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何利用CSI驱动程序在GKE集群上部署GCE PD卷。
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe showed you how to quickly provision a dynamic persistent volume
    using Kubernetes storage classes, and PVC and PV concepts.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱向您展示了如何使用Kubernetes存储类、PVC和PV概念快速提供动态持久卷。
- en: In the *Creating a GCP persistent disk storage class* recipe, in *Step 3*, you
    created `gce-pd` storage classes by using the `allowedTopologies` parameter and
    set two GKE zones, `us-central1-a` and `us-central1-b`, under the values.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在*创建GCP持久磁盘存储类*食谱中，在*步骤3*中，您使用`allowedTopologies`参数创建了`gce-pd`存储类，并设置了两个GKE区域，`us-central1-a`和`us-central1-b`。
- en: When `allowedTopologies` is defined in a storage class, GCP creates a regional
    persistent disk and replicates the data between two zones in the same region for
    higher availability.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当在存储类中定义了`allowedTopologies`时，GCP会创建一个区域性持久磁盘，并在同一区域的两个区域之间复制数据，以提高可用性。
- en: 'Volumes that are created with this option also get labeled in a similar manner
    to the label here: `failure-domain.beta.kubernetes.io/region : us-central1` and `failure-domain.beta.kubernetes.io/region
    : us-central1-a`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '使用此选项创建的卷也会以类似于此处标签的方式进行标记：`failure-domain.beta.kubernetes.io/region : us-central1`和`failure-domain.beta.kubernetes.io/region
    : us-central1-a`'
- en: Regional PDs help to survive a zonal outage. In that case, your Kubernetes cluster
    will failover workloads using the volume to the other zone.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 区域性PD有助于在区域性故障中存活。在这种情况下，您的Kubernetes集群将使用卷故障转移工作负载到另一个区域。
- en: This option is recommended when building highly available stateful workloads
    on GKE clusters.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建高可用状态工作负载的GKE集群上，建议使用此选项。
- en: See also
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'GCE PD types: [https://cloud.google.com/persistent-disk/](https://cloud.google.com/persistent-disk/)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCE PD 类型：[https://cloud.google.com/persistent-disk/](https://cloud.google.com/persistent-disk/)
- en: GCE PD CSI driver repository: [https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver](https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCE PD CSI 驱动程序存储库：[https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver](https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver)
- en: Managing Azure Disk volumes in Kubernetes
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes中管理Azure Disk卷
- en: Azure Cloud provides persistent block-level storage volumes for use with **Azure
    Kubernetes Engine** (**AKS**). In this section, we will create storage classes
    for your applications in Kubernetes running in the AKS. You will learn how to
    create a StorageClass resource in Kubernetes, you will learn about the parameters
    available with the variation in performance of Azure Disk volume types, and you
    will also learn how to use the new CSI.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Cloud为与**Azure Kubernetes Engine**（**AKS**）一起使用的持久块级存储卷提供支持。在本节中，我们将为在AKS中运行的Kubernetes应用程序创建存储类。您将学习如何在Kubernetes中创建StorageClass资源，了解Azure
    Disk卷类型性能变化的参数，以及如何使用新的CSI。
- en: Getting ready
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation in order to
    use manifest files under the `chapter5` directory:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆`k8sdevopscookbook/src`存储库到您的工作站，以便使用`chapter5`目录下的清单文件：
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Make sure you have a regional GKE cluster ready and `kubectl` configured to
    manage the cluster resources.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您有一个区域性的GKE集群，并配置`kubectl`来管理集群资源。
- en: How to do it…
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'This section is sub-divided further into the following subsections to facilitate
    the process:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本节进一步细分为以下子节，以便促进流程：
- en: Creating an Azure Disk storage class
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Azure Disk存储类
- en: Changing the default storage class to ZRS
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将默认存储类更改为 ZRS
- en: Using Azure Disk storage classes to create dynamic PVs
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Azure Disk存储类创建动态PV
- en: Deleting Azure Disk persistent volumes
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除Azure Disk持久卷
- en: Installing the Azure Disk CSI driver
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Azure Disk CSI 驱动程序
- en: Creating an Azure Disk storage class
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Azure Disk存储类
- en: 'Let''s perform the following steps to learn the storage class parameters required
    to construct an Azure Disk storage class that we can use to dynamically request
    new persistent volumes from AKS:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤，以了解构建Azure磁盘存储类所需的存储类参数，我们可以使用这些参数从AKS动态请求新的持久卷：
- en: 'AKS-based Kubernetes clusters are created with two locally redundant (LRS)
    storage classes by default. Let''s list the storage classes on your AKS cluster:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于AKS的Kubernetes集群默认创建两个本地冗余（LRS）存储类。让我们列出AKS集群上的存储类：
- en: '[PRE61]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Describe the `default` storage class:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述`default`存储类：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Create a zone-redundant storage class with the provisioner, `kubernetes.io/azure-disk`,
    and the `Standard_ZRS` skuName specified:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供程序`kubernetes.io/azure-disk`和指定`Standard_ZRS` skuName创建区域冗余存储类：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You can find the definition and use cases for different volume types on the
    *Azure Disk volume types* link in the *See also* section.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在“Azure磁盘卷类型”链接中找到不同卷类型的定义和用例。
- en: On Azure Cloud clusters, the default Azure Disk volume type is `Standard_LRS`.
    For database workloads, such as MongoDB, Cassandra, and PostgreSQL, `Premium_LRS`-type,
    high-performance SSDs are recommended.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure云集群上，默认的Azure磁盘卷类型是`Standard_LRS`。对于数据库工作负载，如MongoDB、Cassandra和PostgreSQL，建议使用`Premium_LRS`类型的高性能SSD。
- en: 'List the storage classes:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出存储类：
- en: '[PRE64]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As you can see in our example, AKS clusters come with two predefined storage
    classes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在我们的示例中所见，AKS集群配备了两个预定义的存储类。
- en: Changing the default storage class to ZRS
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将默认存储类更改为ZRS
- en: 'Dynamic storage provisioning is a key part of scaling applications. When a
    storage class is not specified by a PVC, Kubernetes uses the default option. Let''s
    perform the following steps to set our preferred storage class as the default:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 动态存储配置是扩展应用程序的关键部分。当PVC未指定存储类时，Kubernetes使用默认选项。让我们执行以下步骤，将我们首选的存储类设置为默认值：
- en: 'Let''s set the existing `default` storage class as the non-default option:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的`default`存储类设置为非默认选项：
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, define `azure-zrs` as the default storage class again:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次将`azure-zrs`定义为默认存储类：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Confirm the new default storage class. You should see new `azure-zrs` as the
    default, similar to the following output:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认新的默认存储类。您应该看到新的`azure-zrs`作为默认值，类似于以下输出：
- en: '[PRE67]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now you know how to set your preferred storage class as the default on your
    AKS cluster.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何在AKS集群上将首选的存储类设置为默认值。
- en: Using Azure Disk storage classes to create dynamic PVs
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Azure磁盘存储类创建动态PV
- en: 'As part of a StatefulSet, `volumeClaimTemplates` can provide persistent storage
    using `PersistentVolumes` provisioned by a `PersistentVolume` provisioner of your
    choice. In this recipe, we will use the Azure storage class to dynamically create
    PVs for your application:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 作为StatefulSet的一部分，`volumeClaimTemplates`可以使用您选择的`PersistentVolume`提供程序提供的`PersistentVolumes`来提供持久存储。在这个示例中，我们将使用Azure存储类为您的应用程序动态创建PV：
- en: 'Add the `azure-zrs` storage class line under the `volumeClaimTemplates` section
    of your application deployment manifest, similar to the following example:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序部署清单的`volumeClaimTemplates`部分下添加`azure-zrs`存储类行，类似于以下示例：
- en: '[PRE68]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In this recipe, we will deploy Redis Statefulset using the `azure-zrs` storage
    class. Review the YAML manifest under the `src/chapter5/azure` directory in the
    example repository before we execute it:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`azure-zrs`存储类部署Redis Statefulset。在执行之前，请查看示例存储库中`src/chapter5/azure`目录下的YAML清单：
- en: '[PRE69]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create the Redis StatefulSet:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Redis StatefulSet：
- en: '[PRE70]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Verify that pods have been created. In this recipe, our example has StatefulSet
    with three replicas. As a result, you should see three replicas running, similar
    to the following output:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证已创建Pod。在这个示例中，我们的示例有三个副本的StatefulSet。因此，您应该看到三个副本正在运行，类似于以下输出：
- en: '[PRE71]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'List the PVCs and PVs created. You should expect to see three PVCs and three
    PVs created, similar to our example output here:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出创建的PVC和PV。您应该期望看到创建了三个PVC和三个PV，类似于我们这里的示例输出：
- en: '[PRE72]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now you know how to dynamically create persistent volumes as part of your application
    deployment on AKS clusters.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何在AKS集群上动态创建持久卷作为应用程序部署的一部分。
- en: Deleting Azure Disk persistent volumes
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除Azure磁盘持久卷
- en: 'When the reclaim policy is set to retain the volumes, they need to be removed
    separately by observing the following steps:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当回收策略设置为保留卷时，需要按照以下步骤单独删除卷：
- en: 'Remember that deleting your workload will not remove the PVCs and PVs unless
    the PVC manifest was included in the manifest:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，除非PVC清单包含在清单中，否则删除工作负载不会删除PVC和PV：
- en: '[PRE73]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'List the remaining PVs:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出剩余的PV：
- en: '[PRE74]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Delete the PVCs. You can delete multiple PVCs at once by adding their names
    in a single command, similar to the following:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除PVC。您可以通过将它们的名称添加到单个命令中一次删除多个PVC，类似于以下操作：
- en: '[PRE75]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We have now successfully removed all storage resources related to the application
    that was created as part of the Redis StatefulSet resource.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已成功删除了与Redis StatefulSet资源的创建相关的应用程序的所有存储资源。
- en: Installing the Azure Disk CSI driver
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Azure Disk CSI驱动程序
- en: 'The Azure Disk CSI driver provides a Kubernetes CSI that allows AKS clusters
    to simply manage the life cycle of Azure Disk volumes for persistent volumes.
    In this recipe, we will learn the steps required to install the Azure Disk CSI
    driver by observing the following steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Disk CSI驱动程序提供了一个Kubernetes CSI，允许AKS集群简单地管理Azure磁盘卷的生命周期，用于持久卷。在这个教程中，我们将学习安装Azure
    Disk CSI驱动程序所需的步骤，观察以下步骤：
- en: 'Deploy the Azure Disk CSI driver:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署Azure Disk CSI驱动程序：
- en: '[PRE76]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Verify that the driver is running that controller and that the `azuredisk-node`
    DaemonSet is running:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证驱动程序正在运行控制器，并且`azuredisk-node` DaemonSet正在运行：
- en: '[PRE77]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, create a new storage class:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个新的存储类：
- en: '[PRE78]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Create a PVC using the storage class name, `disk.csi.azure.com`:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用存储类名称`disk.csi.azure.com`创建PVC：
- en: '[PRE79]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Create a pod that will use the `csi-azure-pvc` PVC and that writes to the `/data/out.txt` file:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将使用`csi-azure-pvc` PVC并写入`/data/out.txt`文件的pod：
- en: '[PRE80]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Verify that our `mytestapp` pod writes data to the volume:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证我们的`mytestapp` pod是否将数据写入卷：
- en: '[PRE81]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Now you know how to use the Azure Disk CSI driver to provision persistent volumes
    on your AKS clusters.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何在AKS集群上使用Azure Disk CSI驱动程序来提供持久卷。
- en: See also
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Azure Disk volume types: [https://azure.microsoft.com/en-us/pricing/details/managed-disks/](https://azure.microsoft.com/en-us/pricing/details/managed-disks/)
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure磁盘卷类型：[https://azure.microsoft.com/en-us/pricing/details/managed-disks/](https://azure.microsoft.com/en-us/pricing/details/managed-disks/)
- en: AWS EBS CSI driver repository: [https://github.com/kubernetes-sigs/azuredisk-csi-driver](https://github.com/kubernetes-sigs/azuredisk-csi-driver)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS EBS CSI驱动程序存储库：[https://github.com/kubernetes-sigs/azuredisk-csi-driver](https://github.com/kubernetes-sigs/azuredisk-csi-driver)
- en: Configuring and managing persistent storage using Rook
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Rook配置和管理持久存储
- en: Rook is a cloud-native, open source storage orchestrator for Kubernetes. Rook
    provides self-managing, self-scaling, and self-healing distributed storage systems
    in Kubernetes. In this section, we will create multiple storage providers using
    the Rook storage orchestrator for your applications in Kubernetes. You will learn
    to create a Ceph provider for your stateful applications that require persistent
    storage.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Rook是一个面向Kubernetes的云原生开源存储编排器。Rook在Kubernetes中提供自管理、自扩展和自愈的分布式存储系统。在本节中，我们将使用Rook存储编排器为Kubernetes中的应用程序创建多个存储提供程序。您将学习为需要持久存储的有状态应用程序创建Ceph提供程序。
- en: Getting ready
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you have a Kubernetes cluster ready and `kubectl` configured
    to manage the cluster resources.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经准备好一个Kubernetes集群，并且`kubectl`已配置好以管理集群资源。
- en: How to do it…
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'This section is sub-divided further into the following subsections to facilitate
    the process:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分进一步细分为以下子部分，以便进行流程：
- en: Installing a Ceph provider using Rook
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rook安装Ceph提供程序
- en: Creating a Ceph cluster
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Ceph集群
- en: Verifying a Ceph cluster's health
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证Ceph集群的健康状态
- en: Create a Ceph block storage class
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Ceph块存储类
- en: Using a Ceph block storage class to create dynamic PVs
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ceph块存储类创建动态PVs
- en: Installing a Ceph provider using Rook
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Rook安装Ceph提供程序
- en: 'Let''s perform the following steps to get a Ceph scale-out storage solution
    up and running using the Rook project:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤，使用Rook项目来运行Ceph扩展存储解决方案：
- en: 'Clone the Rook repository:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆Rook存储库：
- en: '[PRE82]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Deploy the Rook Operator:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署Rook Operator：
- en: '[PRE83]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Verify the Rook Operator:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证Rook Operator：
- en: '[PRE84]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now you have learned how to deploy the Rook orchestration components for the
    Ceph provider running on Kubernetes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何在Kubernetes上运行Ceph提供程序的Rook编排组件。
- en: Creating a Ceph cluster
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个Ceph集群
- en: 'Let''s perform the following steps to deploy a Ceph cluster using the Rook
    Operator:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤，使用Rook Operator部署Ceph集群：
- en: 'Create a Ceph cluster:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Ceph集群：
- en: '[PRE85]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Verify that all pods are running:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证所有的pod是否正在运行：
- en: '[PRE86]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Within a minute, a fully functional Ceph cluster will be deployed and ready
    to be used. You can read more about Ceph in the *Rook Ceph Storage Documentation*
    link in the *See also* section.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在一分钟内，一个完全功能的Ceph集群将被部署并准备好使用。你可以在*参见*部分的*Rook Ceph存储文档*链接中了解更多关于Ceph的信息。
- en: Verifying a Ceph cluster's health
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证Ceph集群的健康状态
- en: 'The Rook toolbox is a container with common tools used for rook debugging and
    testing. Let''s perform the following steps to deploy the Rook toolbox to verify
    cluster health:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Rook工具箱是一个包含常用工具的容器，用于Rook调试和测试。让我们执行以下步骤来部署Rook工具箱以验证集群健康状态：
- en: 'Deploy the Rook toolbox:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署Rook工具箱：
- en: '[PRE87]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Verify that the toolbox is running:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证工具箱是否正在运行：
- en: '[PRE88]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Connect to the toolbox:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到工具箱：
- en: '[PRE89]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Verify that the cluster is in a healthy state (`HEALTH_OK`):'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证集群是否处于健康状态（`HEALTH_OK`）：
- en: '[PRE90]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'When you are finished troubleshooting, remove the deployment using the following
    command:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成故障排除后，使用以下命令删除部署：
- en: '[PRE91]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Now you know how to deploy the Rook toolbox with its common tools that are used
    to debug and test Rook.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何部署Rook工具箱及其常用工具，用于调试和测试Rook。
- en: Create a Ceph block storage class
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个Ceph块存储类
- en: 'Let''s perform the following steps to create a storage class for Ceph storage.:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤，为Ceph存储创建一个存储类：
- en: 'Create `CephBlockPool`:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`CephBlockPool`：
- en: '[PRE92]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Create a Rook Ceph block storage class:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Rook Ceph块存储类：
- en: '[PRE93]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Confirm that the storage class has been created:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认存储类已创建：
- en: '[PRE94]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: As you can see from the preceding provisioner name, `rook-ceph.rbd.csi.ceph.com`,
    Rook also uses CSI to interact with Kubernetes APIs. This driver is optimized
    for RWO pod access where only one pod may access the storage.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的提供者名称`rook-ceph.rbd.csi.ceph.com`可以看出，Rook还使用CSI与Kubernetes API进行交互。该驱动程序针对RWO
    pod访问进行了优化，其中只有一个pod可以访问存储。
- en: Using a Ceph block storage class to create dynamic PVs
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Ceph块存储类创建动态PVs
- en: 'In this recipe, we will deploy Wordpress using dynamic persistent volumes created
    by the Rook Ceph block storage provider. Let''s perform the following steps:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Rook Ceph块存储提供程序创建动态持久卷来部署Wordpress。让我们执行以下步骤：
- en: 'Clone the examples repository:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆示例存储库：
- en: '[PRE95]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Review both `mysql.yaml` and `wordpress.yaml`. Note that PVCs are using the
    `rook-ceph-block` storage class:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看`mysql.yaml`和`wordpress.yaml`。注意PVC正在使用`rook-ceph-block`存储类：
- en: '[PRE96]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Deploy MySQL and WordPress:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署MySQL和WordPress：
- en: '[PRE97]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Confirm the persistent volumes created:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认已创建持久卷：
- en: '[PRE98]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Get the external IP of the WordPress service:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取WordPress服务的外部IP：
- en: '[PRE99]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Open the external IP of the WordPress service in your browser to access your
    Wordpress deployment:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开WordPress服务的外部IP以访问您的WordPress部署：
- en: '![](assets/0903a69e-08b1-472b-b066-e1f786c21455.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0903a69e-08b1-472b-b066-e1f786c21455.png)'
- en: Now you know how to get the popular WordPress service, with persistent storage
    stored on Rook-based Ceph storage, up and running.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何获取流行的WordPress服务，并在基于Rook的Ceph存储上存储持久存储。
- en: See also
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Rook documentation: [https://rook.io/docs/rook/master/](https://rook.io/docs/rook/master/)
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rook文档：[https://rook.io/docs/rook/master/](https://rook.io/docs/rook/master/)
- en: Rook Ceph storage documentation: [https://rook.io/docs/rook/master/ceph-storage.html](https://rook.io/docs/rook/master/ceph-storage.html)
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rook Ceph存储文档：[https://rook.io/docs/rook/master/ceph-storage.html](https://rook.io/docs/rook/master/ceph-storage.html)
- en: 'Rook community slack channel: [https://slack.rook.io/](https://slack.rook.io/)'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rook社区slack频道：[https://slack.rook.io/](https://slack.rook.io/)
- en: Configuring and managing persistent storage using OpenEBS
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenEBS配置和管理持久存储
- en: OpenEBS is a popular open source, cloud-native storage (CNS) project with a
    large community. In this section, we will install an OpenEBS persistent storage
    provider. You will learn how to create volumes using different types of storage
    engine options for stateful workloads on Kubernetes.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: OpenEBS是一个受欢迎的开源、云原生存储（CNS）项目，拥有庞大的社区。在本节中，我们将安装OpenEBS持久存储提供程序。您将学习如何在Kubernetes上为有状态工作负载使用不同类型的存储引擎选项创建卷。
- en: Getting ready
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we need to have `helm` and `kubectl` installed. Make sure you
    have a Kubernetes cluster ready and `kubectl` configured to manage the cluster
    resources.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个步骤，我们需要安装`helm`和`kubectl`。确保您已经准备好一个Kubernetes集群，并且`kubectl`配置好以管理集群资源。
- en: How to do it…
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'This section is sub-divided further into the following subsections to facilitate
    the process:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 本节进一步细分为以下子节，以便促进流程：
- en: Installing iSCSI client prerequisites
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装iSCSI客户端先决条件
- en: Installing OpenEBS
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装OpenEBS
- en: Using ephemeral storage to create persistent volumes
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用临时存储创建持久卷
- en: Creating storage pools
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建存储池
- en: Creating OpenEBS storage classes
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建OpenEBS存储类
- en: Using an OpenEBS storage class to create dynamic PVs
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenEBS存储类创建动态PV
- en: Installing iSCSI client prerequisites
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装iSCSI客户端先决条件
- en: 'The OpenEBS storage provider requires that the iSCSI client runs on all worker
    nodes:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: OpenEBS存储提供程序要求iSCSI客户端在所有工作节点上运行：
- en: 'On all your worker nodes, follow the steps to install and enable `open-iscsi`:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有工作节点上，按照安装和启用`open-iscsi`的步骤进行操作：
- en: '[PRE100]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Validate that the iSCSI service is running:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证iSCSI服务是否在运行：
- en: '[PRE101]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'If the service status is showing as inactive, then enable and start the iscsid
    service:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果服务状态显示为非活动状态，则启用并启动iscsid服务：
- en: '[PRE102]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: After installing the iSCSI service, you are ready to install OpenEBS on your
    cluster.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 安装iSCSI服务后，您可以在集群上安装OpenEBS。
- en: Installing OpenEBS
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装OpenEBS
- en: 'Let''s perform the following steps to quickly get the OpenEBS control plane
    installed:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤，快速安装OpenEBS控制平面：
- en: 'Install OpenEBS services by using the operator:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用运算符安装OpenEBS服务：
- en: '[PRE103]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Confirm that all OpenEBS pods are running:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认所有OpenEBS pod都在运行：
- en: '[PRE104]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: OpenEBS consists of the core components listed here. Node Disk Manager (NDM)
    is one of the important pieces of OpenEBS that is responsible for detecting disk
    changes and runs as DaemonSet on your worker nodes.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: OpenEBS由以下核心组件组成。Node Disk Manager (NDM)是OpenEBS的重要组成部分之一，负责检测磁盘更改，并作为DaemonSet在您的工作节点上运行。
- en: Using ephemeral storage to create persistent volumes
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用临时存储创建持久卷
- en: 'OpenEBS currently provides three storage engine options (Jiva, cStor, and LocalPV).
    The first storage engine option, `Jiva`, can create replicated storage on top
    of the ephemeral storage. Let''s perform the following steps to get storage using
    ephemeral storage configured:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: OpenEBS目前提供三种存储引擎选项（Jiva、cStor和LocalPV）。第一个存储引擎选项`Jiva`可以在临时存储之上创建复制存储。让我们执行以下步骤来使用临时存储配置存储：
- en: 'List the default storage classes:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出默认存储类：
- en: '[PRE105]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Describe the `openebs-jiva-default` storage class:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述`openebs-jiva-default`存储类：
- en: '[PRE106]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Create a persistent volume claim using `openebs-jiva-default`:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`openebs-jiva-default`创建持久卷声明：
- en: '[PRE107]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Confirm that the PVC status is `BOUND`:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认PVC状态为“BOUND”：
- en: '[PRE108]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Now, use the PVC to dynamically provision a persistent volume:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用PVC动态提供持久卷：
- en: '[PRE109]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now list the pods and make sure that your workload, OpenEBS controller, and
    replicas are all in the running state:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在列出Pod，并确保您的工作负载、OpenEBS控制器和副本都处于运行状态：
- en: '[PRE110]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Now you know how to get highly available, cloud-native storage configured for
    your stateful applications on Kubernetes.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何为Kubernetes上的有状态应用程序配置高可用的云原生存储。
- en: Creating storage pools
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建存储池
- en: 'In this recipe, we will use raw block devices attached to your nodes to create
    a storage pool. These devices can be AWS EBS volumes, GCP PDs, Azure Disk, virtual
    disks, or vSAN volumes. Devices can be attached to your worker node VMs, or basically
    physical disks if you are using a bare-metal Kubernetes cluster. Let''s perform
    the following steps to create a storage pool out of raw block devices:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用附加到您的节点的原始块设备来创建存储池。这些设备可以是AWS EBS卷、GCP PD、Azure磁盘、虚拟磁盘或vSAN卷。设备可以附加到您的工作节点VM，或者如果您使用裸金属Kubernetes集群，则可以是基本物理磁盘。让我们执行以下步骤来从原始块设备创建存储池：
- en: 'List unused and unclaimed block devices on your nodes:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出节点上未使用和未声明的块设备：
- en: '[PRE111]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: In our example, we have a three-node Kubernetes cluster on AWS EC2 with one
    additional EBS volume attached to each node.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们在AWS EC2上有一个三节点的Kubernetes集群，每个节点附加了一个额外的EBS卷。
- en: 'Create a storage pool using the unclaimed devices from *Step 1*:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用未声明的设备从*步骤1*创建存储池：
- en: '[PRE112]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'List the storage pool claims:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出存储池声明：
- en: '[PRE113]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Verify that a cStor pool has been created and that its status is `Healthy`:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证是否已创建cStor池并且其状态为“健康”：
- en: '[PRE114]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Now we can use the storage pool in storage classes to provision dynamic volumes.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用存储类中的存储池来提供动态卷。
- en: Creating OpenEBS storage classes
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建OpenEBS存储类
- en: 'Let''s perform the following steps to create a new storage class to consume
    StoragePool, which we created previously in the *Creating storage pools* recipe:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来创建一个新的存储类来使用之前创建的StoragePool：
- en: 'Create an OpenEBS cStor storage class using the cStor `StoragePoolClaim` name, `cstor-disk-pool`,
    with three replicas:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用cStor `StoragePoolClaim`名称`cstor-disk-pool`创建一个OpenEBS cStor存储类，带有三个副本：
- en: '[PRE115]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'List the storage classes:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出存储类：
- en: '[PRE116]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Set the `gp2` AWS EBS storage class as the non-default option:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`gp2` AWS EBS存储类设置为非默认选项：
- en: '[PRE117]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Define `openebs-cstor-default` as the default storage class:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`openebs-cstor-default`定义为默认存储类：
- en: '[PRE118]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Make sure that the previous storage class is no longer set as the default and
    that you only have one default storage class.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 确保以前的存储类不再设置为默认，并且您只有一个默认存储类。
- en: Using an OpenEBS storage class to create dynamic PVs
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用OpenEBS存储类创建动态PVs
- en: 'Let''s perform the following steps to deploy dynamically created persistent
    volumes using the OpenEBS storage provider:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来使用OpenEBS存储提供程序动态创建持久卷：
- en: 'Clone the examples repository:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆示例存储库：
- en: '[PRE119]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Review `minio.yaml` and note that PVCs are using the `openebs-stor-default` storage
    class.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查`minio.yaml`，注意PVC正在使用`openebs-stor-default`存储类。
- en: 'Deploy Minio:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署Minio：
- en: '[PRE120]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Get the Minio service load balancer''s external IP:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取Minio服务负载均衡器的外部IP：
- en: '[PRE121]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Add port `9000` to the end of the address and open the external IP of the Minio
    service in your browser:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在地址末尾添加端口`9000`，并在浏览器中打开Minio服务的外部IP：
- en: 'Use the username `minio`, and the password `minio123` to log in to the Minio
    deployment backed by persistent OpenEBS volumes:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用用户名`minio`和密码`minio123`登录由持久OpenEBS卷支持的Minio部署：
- en: '![](assets/04aacbb2-701d-474e-bc57-dd66a0ae32f3.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/04aacbb2-701d-474e-bc57-dd66a0ae32f3.png)'
- en: You have now successfully deployed a stateful application that is deployed on
    the OpenEBS cStor storage engine.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已成功部署了一个部署在OpenEBS cStor存储引擎上的有状态应用程序。
- en: How it works...
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe showed you how to quickly provision a persistent storage provider
    using OpenEBS.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方向您展示了如何快速使用OpenEBS提供持久存储。
- en: In the *Using ephemeral storage to create persistent volumes* recipe, in *Step
    6*, when we deployed a workload using the `openebs-jiva-default` storage class,
    OpenEBS launched OpenEBS volumes with three replicas.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用临时存储创建持久卷*配方中，在*步骤6*中，当我们使用`openebs-jiva-default`存储类部署工作负载时，OpenEBS启动了具有三个副本的OpenEBS卷。
- en: 'To set one replica, as is the case with a single-node Kubernetes cluster, you
    can create a new storage class (similar to the one we created in the *Creating
    OpenEBS storage class* recipe) and set the `ReplicaCount` variable value to `1`:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个副本，就像单节点Kubernetes集群一样，您可以创建一个新的存储类（类似于我们在*创建OpenEBS存储类*配方中创建的存储类），并将`ReplicaCount`变量值设置为`1`：
- en: '[PRE122]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: When ephemeral storage is used, the OpenEBS Jiva storage engine uses the `/var/openebs`
    directory on every available node to create replica sparse files. If you would
    like to change the default or create a new StoragePool resource, you can create
    a new storage pool and set a custom path.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用临时存储时，OpenEBS Jiva存储引擎使用每个可用节点上的`/var/openebs`目录来创建副本稀疏文件。如果您想要更改默认值或创建新的StoragePool资源，您可以创建一个新的存储池并设置自定义路径。
- en: See also
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: OpenEBS documentation: [https://docs.openebs.io/](https://docs.openebs.io/)
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenEBS文档：[https://docs.openebs.io/](https://docs.openebs.io/)
- en: 'Beyond the basics: OpenEBS workshop: [https://github.com/openebs/community/tree/master/workshop](https://github.com/openebs/community/tree/master/workshop)'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础之外：OpenEBS研讨会：[https://github.com/openebs/community/tree/master/workshop](https://github.com/openebs/community/tree/master/workshop)
- en: OpenEBS Community Slack channel: [https://openebs.io/join-our-slack-community](https://openebs.io/join-our-slack-community)
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenEBS社区Slack频道：[https://openebs.io/join-our-slack-community](https://openebs.io/join-our-slack-community)
- en: OpenEBS enterprise platform: [https://mayadata.io/product](https://mayadata.io/product)
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenEBS企业平台：[https://mayadata.io/product](https://mayadata.io/product)
- en: OpenEBS director for managing stateful workloads: [https://account.mayadata.io/login](https://account.mayadata.io/login)
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于管理有状态工作负载的OpenEBS director：[https://account.mayadata.io/login](https://account.mayadata.io/login)
- en: Setting up NFS for shared storage on Kubernetes
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Kubernetes设置NFS共享存储
- en: Although it's not the best-performing solution, NFS is still used with cloud-native
    applications where multi-node write access is required. In this section, we will
    create an NFS-based persistent storage for this type of application. You will
    learn how to use OpenEBS and Rook to **ReadWriteMany** (**RWX**) accessible persistent
    volumes for stateful workloads that require shared storage on Kubernetes.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它不是最佳性能的解决方案，但NFS仍然与需要多节点写访问的云原生应用程序一起使用。在本节中，我们将为这种类型的应用程序创建基于NFS的持久存储。您将学习如何使用OpenEBS和Rook为需要在Kubernetes上共享存储的有状态工作负载提供**ReadWriteMany**（**RWX**）可访问的持久卷。
- en: Getting ready
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: For this recipe, we need to have either `rook` or `openebs` installed as an
    orchestrator. Make sure that you have a Kubernetes cluster ready and `kubectl`
    configured to manage the cluster resources.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我们需要安装`rook`或`openebs`作为编排器。确保您已准备好Kubernetes集群，并配置了`kubectl`以管理集群资源。
- en: How to do it…
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'There are two popular alternatives when it comes to providing an NFS service.
    This section is sub-divided further into the following subsections to explain
    the process using Rook and OpenEBS:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供NFS服务时，有两种常用的选择。本节进一步细分为以下子节，以解释使用Rook和OpenEBS的过程：
- en: Installing NFS prerequisites
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装NFS先决条件
- en: Installing an NFS provider using a Rook NFS operator
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rook NFS运算符安装NFS提供程序
- en: Using a Rook NFS operator storage class to create dynamic NFS PVs
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Rook NFS运算符存储类创建动态NFS PV
- en: Installing an NFS provider using OpenEBS
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenEBS安装NFS提供程序
- en: Using the OpenEBS operator storage class to create dynamic NFS PVs
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenEBS运算符存储类创建动态NFS PV
- en: Installing NFS prerequisites
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装NFS先决条件
- en: 'To be able to mount NFS volumes, NFS client packages need to be preinstalled
    on all worker nodes where you plan to have NFS-mounted pods:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够挂载NFS卷，需要在计划挂载NFS的所有工作节点上预先安装NFS客户端软件包：
- en: 'If you are using Ubuntu, install `nfs-common` on all worker nodes:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用Ubuntu，在所有工作节点上安装`nfs-common`：
- en: '[PRE123]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'If using CentOS, install `nfs-common` on all worker nodes:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用CentOS，在所有工作节点上安装`nfs-common`：
- en: '[PRE124]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Now we have `nfs-utils` installed on our worker nodes and are ready to get the
    NFS server to deploy.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在工作节点上安装了`nfs-utils`，准备部署NFS服务器。
- en: Installing an NFS provider using a Rook NFS operator
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Rook NFS运算符安装NFS提供程序
- en: 'Let''s perform the following steps to get an NFS provider functional using
    the Rook NFS provider option:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤，使用Rook NFS提供程序选项使NFS提供程序功能正常：
- en: 'Clone the Rook repository:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆Rook存储库：
- en: '[PRE125]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Deploy the Rook NFS operator:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署Rook NFS运算符：
- en: '[PRE126]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Confirm that the operator is running:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认运算符正在运行：
- en: '[PRE127]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Create a namespace, `rook-nfs`:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个命名空间`rook-nfs`：
- en: '[PRE128]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Make sure that you have defined your preferred storage provider as the default
    storage class. In this recipe, we are using `openebs-cstor-default`, defined in
    persistent storage using the OpenEBS recipe.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已将首选存储提供程序定义为默认存储类。在本教程中，我们使用在OpenEBS教程中定义的`openebs-cstor-default`。
- en: 'Create a PVC:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建PVC：
- en: '[PRE129]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Create the NFS instance:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建NFS实例：
- en: '[PRE130]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Verify that the NFS pod is in the `Running` state:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证NFS pod处于“运行”状态：
- en: '[PRE131]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: By observing the preceding command, an NFS server instance type will be created.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察上述命令，将创建一个NFS服务器实例类型。
- en: Using a Rook NFS operator storage class to create dynamic NFS PVs
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Rook NFS运算符存储类创建动态NFS PV
- en: 'NFS is used in the Kubernetes environment on account of its `ReadWriteMany`
    capabilities for the application that requires access to the same data at the
    same time. In this recipe, we will perform the following steps to dynamically
    create an NFS-based persistent volume:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NFS具有对Kubernetes环境中的`ReadWriteMany`功能，因此需要同时访问相同数据的应用程序。在本教程中，我们将执行以下步骤，动态创建基于NFS的持久卷：
- en: 'Create Rook NFS storage classes using `exportName`, `nfsServerName`, and `nfsServerNamespace`
    from the *Installing an NFS provider using a Rook NFS operator* recipe:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用来自*使用Rook NFS运算符安装NFS提供程序*教程的`exportName`、`nfsServerName`和`nfsServerNamespace`创建Rook
    NFS存储类：
- en: '[PRE132]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Now, you can use the `rook-nfs-share1` storage class to create PVCs for applications
    that require `ReadWriteMany` access:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以使用`rook-nfs-share1`存储类为需要`ReadWriteMany`访问的应用程序创建PVC：
- en: '[PRE133]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: By observing the preceding command, an NFS PV will be created.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察上述命令，将创建一个NFS PV。
- en: Installing an NFS provisioner using OpenEBS
  id: totrans-497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用OpenEBS安装NFS提供程序
- en: 'OpenEBS provides an NFS provisioner that is protected by the underlying storage
    engine options of OpenEBS. Let''s perform the following steps to get an NFS service
    with OpenEBS up and running:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: OpenEBS提供了一个NFS提供程序，该提供程序受到OpenEBS的基础存储引擎选项的保护。让我们执行以下步骤来启动并运行OpenEBS的NFS服务：
- en: 'Clone the examples repository:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆示例存储库：
- en: '[PRE134]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'In this recipe, we are using the `openebs-jiva-default` storage class. Review
    the directory content and apply the `YAML` file under the NFS directory:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了`openebs-jiva-default`存储类。查看目录内容，并在NFS目录下应用`YAML`文件：
- en: '[PRE135]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'List the PVCs and confirm that a PVC named `openebspvc` has been created:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出PVC，并确认是否创建了名为`openebspvc`的PVC：
- en: '[PRE136]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Using the OpenEBS NFS provisioner storage class to create dynamic NFS PVs
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用OpenEBS NFS提供程序存储类创建动态NFS PV
- en: 'Let''s perform the following steps to dynamically deploy an NFS PV protected
    by the OpenEBS storage provider:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来动态部署由OpenEBS存储提供程序保护的NFS PV：
- en: 'List the storage classes, and confirm that `openebs-nfs` exists:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出存储类，并确认`openebs-nfs`是否存在：
- en: '[PRE137]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Now, you can use the `openebs-nfs` storage class to create PVCs for applications
    that require `ReadWriteMany` access:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以使用`openebs-nfs`存储类为需要`ReadWriteMany`访问的应用程序创建PVC：
- en: '[PRE138]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: See also
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Rook NFS operator documentation: [https://github.com/rook/rook/blob/master/Documentation/nfs.md](https://github.com/rook/rook/blob/master/Documentation/nfs.md)'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rook NFS操作员文档：[https://github.com/rook/rook/blob/master/Documentation/nfs.md](https://github.com/rook/rook/blob/master/Documentation/nfs.md)
- en: OpenEBS provisioning read-write-many PVCs: [https://docs.openebs.io/docs/next/rwm.html](https://docs.openebs.io/docs/next/rwm.html)
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenEBS提供读写多PVC：[https://docs.openebs.io/docs/next/rwm.html](https://docs.openebs.io/docs/next/rwm.html)
- en: Troubleshooting storage issues
  id: totrans-514
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除存储问题
- en: In this section, you will learn how to solve the most common storage issues
    associated with Kubernetes. After following the recipes in this chapter, you will
    gain the basic skills required to troubleshoot persistent volumes stuck in pending
    or termination states.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何解决与Kubernetes相关的最常见存储问题。在本章的示例中，您将获得解决持久卷挂起或终止状态所需的基本技能。
- en: Getting ready
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: Make sure that you have a Kubernetes cluster ready and `kubectl` configured
    to manage the cluster resources.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已准备好Kubernetes集群，并配置了`kubectl`以管理集群资源。
- en: How to do it…
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'This section is sub-divided further into the following subsections to facilitate
    the process:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分进一步细分为以下子部分，以便促进流程：
- en: Persistent volumes in the pending state
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久卷处于挂起状态
- en: A PV is stuck once a PVC has been deleted
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦PVC被删除，PV就会卡住
- en: Persistent volumes in the pending state
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久卷处于挂起状态
- en: 'You have deployed an application, but both pods and persistent volume claims
    are stuck in the pending state, similar to the following:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 您已部署了一个应用程序，但是pod和持久卷声明都卡在挂起状态，类似于以下情况：
- en: '[PRE139]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Let''s perform the following steps to start troubleshooting:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来开始故障排除：
- en: 'First, describe the PVC to understand the root cause:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，描述PVC以了解根本原因：
- en: '[PRE140]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'A PVC is stuck due to an incorrect or non-existing storage class. We need to
    change the storage class with a valid resource. List the storage classes as follows:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于存储类不正确或不存在，PVC被卡住。我们需要用有效的资源更改存储类。列出存储类如下：
- en: '[PRE141]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Delete the deployment using `kubectl delete -f <deployment.yaml>`.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl delete -f <deployment.yaml>`删除部署。
- en: Edit the deployment and replace the `storageClassName` field with a valid storage
    class from the output of the previous step, in our case, `openebs-cstor-default`.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑部署并用前一步骤输出的有效存储类替换`storageClassName`字段，我们的情况下是`openebs-cstor-default`。
- en: Redeploy the application using `kubectl apply -f <deployment.yaml>`.
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新部署应用程序使用`kubectl apply -f <deployment.yaml>`。
- en: 'Confirm that the PVC status is `Bound`:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认PVC状态为“已绑定”：
- en: '[PRE142]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Now you have successfully troubleshooted PVC issues caused by a missing StorageClass
    resource.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已成功排除了由于缺少StorageClass资源而引起的PVC问题。
- en: A PV is stuck once a PVC has been deleted
  id: totrans-536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一旦删除了PVC，PV就会卡住
- en: 'You have deleted a PVC. However, either the PVC or PV deletion is stuck in
    the terminating state, similar to the following:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 您已删除了一个PVC。但是，无论是PVC还是PV的删除都卡在终止状态，类似于以下情况：
- en: '[PRE143]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Edit the stuck PVs or PVCs in the terminating state:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑卡在终止状态的PV或PVC：
- en: '[PRE144]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Remove finalizers similar to `- kubernetes.io/pv-protection`, and save the changes.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 删除类似于“- kubernetes.io/pv-protection”的finalizers，并保存更改。
