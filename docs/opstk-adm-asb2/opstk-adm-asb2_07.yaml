- en: Chapter 7. Managing Containers on Your Cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。在您的云上管理容器
- en: 'In this chapter, we will cover one of the currently most discussed technology
    approaches, containers. The popularity around containers continues to build and
    rightfully so, who does not want an easier method of deploying applications and
    a consolidated approach to consuming computing resources? The best analogy I like
    to use, outside of the obvious shipping container on a ship analogy, when talking
    about containers is imagine putting all your code into a car or SUV. Then a vehicle
    carrier shows up at your door to pick up your vehicle. The maintenance for your
    vehicle will be minimal to none since the vehicle carrier is doing all the work.
    You only need to worry about making sure the vehicle carrier is working. This
    is the principle behind containers, we will go deeper into the container concept
    and also learn how you can leverage OpenStack and/or Ansible to build and deploy
    them. As in our usual fashion, as we go through each section we will be creating
    a few Ansible examples of how you can possibly manage various different container
    formats. We will cover the following topic in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍当前最受讨论的技术方法之一，即容器。围绕容器的流行度不断增加，这是理所当然的，谁不希望有一种更容易部署应用程序和一种整合的方法来使用计算资源？我喜欢使用的最佳类比之一是，在谈论容器时，除了显而易见的船上的集装箱类比之外，想象把所有的代码放进一辆汽车或SUV中。然后一辆车辆载体出现在你家门口来接你的车辆。你的车辆的维护将几乎没有，因为车辆载体正在做所有的工作。你只需要担心确保车辆载体正常工作。这就是容器背后的原理，我们将深入探讨容器概念，还将学习如何利用OpenStack和/或Ansible来构建和部署它们。与我们通常的做法一样，当我们逐个部分进行时，我们将创建一些Ansible示例，以展示您可能如何管理各种不同的容器格式。本章将涵盖以下主题：
- en: Container concept explained
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释容器概念
- en: Build and deploy containers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和部署容器
- en: Building containers with Ansible Container
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible Container构建容器
- en: Deploying Kubernetes on OpenStack
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在OpenStack上部署Kubernetes
- en: Managing CoreOS and Docker with Ansible
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible管理CoreOS和Docker
- en: Deploying Nova LXD on OpenStack
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在OpenStack上部署Nova LXD
- en: Reviewing playbooks and roles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查playbooks和roles
- en: The container concept explained
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释容器概念
- en: I have to believe that most folks that are into technology already know what
    containerization (aka containers) is, but in the freakish chance that my assumption
    is wrong, it felt like a good idea to start off by explaining what exactly it
    is. I will try to do my best not to just give you the Wikipedia definition and
    try to put some solid meaning around why the container model is a very useful
    addition to resource virtualization.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须相信大多数对技术感兴趣的人已经知道容器化（又称容器）是什么，但在我假设错误的怪异机会中，开始解释它究竟是什么感觉是一个好主意。我会尽力不只是给出维基百科的定义，而是尽力为为什么容器模型是资源虚拟化的一个非常有用的补充提供一些实质性的意义。
- en: With the start of traditional virtualization, folks realized that I can sort
    of slice up my server into consumable chunks. No more is the need to dedicate
    a whole server to just being a web or application server. Quickly came on the
    adoption of cloud as many started to realize they were not using those virtualized
    resources correctly. Virtual machines sitting out there with no use or with too
    many resources that were not needed. One of the clouds major selling points is
    the fact that you can consume only what you need and that those resources are
    meant to be disposable, meaning use it and then dispose of it. All along while
    these technologies made consuming compute resources easier, none of them really
    helped in improving how you deploy applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着传统虚拟化的开始，人们意识到我可以将我的服务器切成可消耗的块。不再需要将整个服务器专用于成为网络或应用程序服务器。随之而来的是云的采用，因为许多人开始意识到他们没有正确使用这些虚拟化资源。虚拟机闲置或拥有不需要的过多资源。云的一个主要卖点是你可以只使用你需要的资源，并且这些资源是可丢弃的，即使用后就丢弃。尽管这些技术使消耗计算资源变得更容易，但它们都没有真正帮助改善应用程序的部署方式。
- en: Remember why you need those VM and instances, it is to run applications. What
    is the point of getting your hands on resources faster if it still takes days
    to still deploy a new application? In my opinion, this is the basis of why the
    containerization approach was crafted. Developers and system administrators (mainly
    system admins) wanted a more efficient method of deploying applications. I can
    personally remember the extremely painful process of deploying a new application
    or API. It consisted of attempting to step through a deployment document written
    by a developer, who most likely had never even logged into a server before or
    managed web/application server software before. Let's just say it was riddled
    with missed steps, wrong commands, and could never take into account any environment
    modifications that could be needed (such as dependent software versions).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 记住你为什么需要那些虚拟机和实例，那就是为了运行应用程序。如果获取资源的速度更快，但部署新应用程序仍然需要几天，那有什么意义呢？在我看来，这就是容器化方法被设计的基础。开发人员和系统管理员（主要是系统管理员）希望有一种更有效的部署应用程序的方法。我个人还记得部署新应用程序或API的极其痛苦的过程。它包括尝试按照开发人员编写的部署文档进行部署，而这些开发人员很可能以前从未登录过服务器或管理过网络/应用程序服务器软件。让我们只说它充满了遗漏的步骤、错误的命令，并且永远无法考虑到可能需要的任何环境修改（例如依赖软件版本）。
- en: Fast forwarding to the current time where you now have more options. There are
    quite a few different container technologies that now allow for developers to
    package up an application into a container and literally *ship it* to your container
    platform of choice. No more deployment documents, no more 2 AM deployment parties,
    and most importantly no more deployment mistakes. Since the container consists
    of a complete runtime environment for your applications all you need to manage
    is the container technology itself and the operating system it runs on. Containers
    are then also very easily moved between environments or across systems, as the
    only dependency is a server running the same container technology.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 快进到现在，你现在有更多的选择。现在有很多不同的容器技术，允许开发人员将应用程序打包到容器中，然后将其直接*部署*到你选择的容器平台。不再需要部署文档，不再需要凌晨2点的部署派对，最重要的是不再有部署错误。由于容器包含了应用程序的完整运行时环境，你只需要管理容器技术本身和它运行的操作系统。容器也很容易在环境之间或系统之间移动，因为唯一的依赖是运行相同容器技术的服务器。
- en: Now that you have some facts on containers you have to choose the platform that
    best suits your needs. Some of the most popular container technologies are Docker
    ([https://www.docker.com](https://www.docker.com)), Kubernetes ([http://kubernetes.io](http://kubernetes.io)),
    CoreOS ([https://coreos.com](https://coreos.com)) and LXC/LXD ([https://linuxcontainers.org](https://linuxcontainers.org)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了一些关于容器的知识，你必须选择最适合你需求的平台。一些最流行的容器技术包括Docker ([https://www.docker.com](https://www.docker.com))，Kubernetes
    ([http://kubernetes.io](http://kubernetes.io))，CoreOS ([https://coreos.com](https://coreos.com))和LXC/LXD
    ([https://linuxcontainers.org](https://linuxcontainers.org))。
- en: So before you ask, you are probably thinking that since containers are relatively
    new can it be trusted, has the containerization concept been proven to work? Well
    the answer is yes, due to the simple fact that containers are not a new concept.
    Containers, or the concept of containerization, has been around for 10 years.
    The first container technology was LXC and it has been part of the Linux kernel
    for years now. With that said I would certainly say it has been tested true and
    certainly a technology to add to your organization's portfolio.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在你问之前，你可能会想，由于容器相对较新，它是否可以被信任，容器化概念是否已被证明有效？答案是肯定的，因为容器并不是一个新概念。容器或容器化的概念已经存在了10年。第一个容器技术是LXC，它已经成为Linux内核的一部分多年了。因此，我可以肯定地说它已经经过了测试，并且绝对是一个值得加入你的组织组合中的技术。
- en: We can now embark on our journey of exploring containers further and strategize
    on how you can automate building and deploying them on your OpenStack cloud. The
    first path we need to go down in our journey is building our first container.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始探索容器并制定如何在你的OpenStack云上自动构建和部署它们的旅程。我们旅程中需要走的第一步是构建我们的第一个容器。
- en: Building and deploying containers
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和部署容器
- en: 'In this section, we will learn how to design, build, and deploy containers
    to various container technologies. The breakdown of topics we will cover here
    are listed as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习如何设计、构建和部署各种容器技术的容器。我们将在这里涵盖的主题包括：
- en: Building Containers with Ansible Container
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible Container构建容器
- en: Deploying Kubernetes on OpenStack
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在OpenStack上部署Kubernetes
- en: Managing CoreOS and Docker with Ansible
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible管理CoreOS和Docker
- en: Deploying Nova LXD on OpenStack
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在OpenStack上部署Nova LXD
- en: As mentioned previously, we will first start with learning how to build our
    first container using what I consider to be the easiest container tool there is,
    Ansible Container. Hope you are excited because I surely am, let's go!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将首先学习如何使用我认为是最简单的容器工具Ansible Container构建我们的第一个容器。希望你也很兴奋，因为我肯定是，让我们开始吧！
- en: Building containers with Ansible Container
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ansible Container构建容器
- en: What is Ansible Container?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是Ansible Container？
- en: '*Ansible describes Ansible Container as "the ultimate workflow for container
    development, testing, and deployment"                                        
             –  ([https://docs.ansible.com/ansible-container](https://docs.ansible.com/ansible-container))*'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Ansible将Ansible Container描述为"容器开发、测试和部署的终极工作流" - ([https://docs.ansible.com/ansible-container](https://docs.ansible.com/ansible-container))*'
- en: 'Consider it a workflow tool that enables you to not only build Docker images
    but also orchestrate the deployment of them and applications using Ansible playbooks.
    I will give you a second to pull yourself together now. Yes, our friends at Ansible
    have done it again and delivered another fantastic tool to put in our toolbox.
    No more having to be solely dependent on Dockerfile. All the power Ansible bring
    to the table can now be directly combined with building, running, deploying, and
    even pushing container images to the registry of choice. Everything you would
    like to know about Ansible Container can be found here: [http://docs.ansible.com/ansible-container](http://docs.ansible.com/ansible-container).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 把它看作是一个工作流工具，它不仅可以帮助你构建Docker镜像，还可以使用Ansible playbooks编排它们和应用程序的部署。我会给你一点时间来整理一下自己。是的，我们的朋友Ansible又一次做到了，并提供了另一个很棒的工具放入我们的工具箱中。不再只依赖Dockerfile。Ansible带来的所有功能现在可以直接与构建、运行、部署，甚至将容器镜像推送到选择的注册表相结合。关于Ansible
    Container的所有信息都可以在这里找到：[http://docs.ansible.com/ansible-container](http://docs.ansible.com/ansible-container)。
- en: Just like with every other tool Ansible enables the center focus around Ansible
    Container, to be, simplicity and ease of use. Personally, I was able to install
    it and deploy my first container in just a few hours. One of the key features
    to Ansible Container is the ability to leverage shared container builds from Ansible
    Galaxy ([https://galaxy.ansible.com/intro](https://galaxy.ansible.com/intro))
    to get a jump start on designing your container images. Remember Open Source is
    all about sharing with the community.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对待每个其他工具一样，Ansible使得以Ansible Container为中心的焦点变得简单易用。就我个人而言，我能够在短短几个小时内安装它并部署我的第一个容器。Ansible
    Container的关键功能之一是能够利用来自Ansible Galaxy（[https://galaxy.ansible.com/intro](https://galaxy.ansible.com/intro)）的共享容器构建，以便快速设计您的容器映像。请记住，开源就是与社区分享。
- en: Automation considerations
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化考虑
- en: 'The first step is to get it installed, and since Ansible documentation is like
    none other there would be no need for me to reinvent the wheel. The installation
    options and details can be found at the following location: [http://docs.ansible.com/ansible-container/installation.html](http://docs.ansible.com/ansible-container/installation.html).
    After you get it running the very next step I would suggest is to review the Getting
    Started guide found here: [http://docs.ansible.com/ansible-container/getting_started.html](http://docs.ansible.com/ansible-container/getting_started.html).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是安装它，由于Ansible文档与众不同，我无需重新发明轮子。安装选项和详细信息可以在以下位置找到：[http://docs.ansible.com/ansible-container/installation.html](http://docs.ansible.com/ansible-container/installation.html)。在您运行它之后，我建议的下一步是查看此处的入门指南：[http://docs.ansible.com/ansible-container/getting_started.html](http://docs.ansible.com/ansible-container/getting_started.html)。
- en: We will now step through an example Ansible Container project that I have created
    to get started. This to me is the best way of learning a new technology. Spend
    some time with it, get your hands dirty, and come out more knowledgeable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将逐步介绍我创建的一个示例Ansible Container项目以供开始使用。对我来说，这是学习新技术的最佳方式。花些时间，动手尝试一下，然后变得更有见识。
- en: Step 1
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 步骤1
- en: 'Getting started with an Ansible Container project starts with something as
    simple as creating a new directory. Once the new directory has been created you
    then need to move into that directory and execute the Ansible Container initialization
    command. A working example of those commands is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ansible Container项目开始就像创建一个新目录一样简单。创建新目录后，您需要进入该目录并执行Ansible Container初始化命令。这些命令的工作示例如下：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the command would resemble this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出将类似于这样：
- en: '![Step 1](graphics/image_07_001.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![步骤1](graphics/image_07_001.jpg)'
- en: 'In the example shown, our project will be named `elk-containers` and will be
    initialized in a directory named the same. Now that you have initialized your
    project, you will find that the Ansible Container files were created in a directory
    named `ansible`. The directory structure for your project will look like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在所示的示例中，我们的项目将被命名为`elk-containers`，并将在同名的目录中初始化。现在您已经初始化了您的项目，您会发现Ansible Container文件被创建在一个名为`ansible`的目录中。您的项目的目录结构将如下所示：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The files created here are skeleton files providing a shell to get you started.
    If you examine the two most important files, `container.yml` and `main.yml`, they
    will look something like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里创建的文件是提供一个起点的骨架文件。如果您检查两个最重要的文件`container.yml`和`main.yml`，它们将看起来像这样：
- en: '**container.yml**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**container.yml**'
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**main.yml**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.yml**'
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Step 2
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 步骤2
- en: Now we are ready to either manually configure our container and/or leverage
    any of the many pre-packaged Ansible Container configs hosted on Ansible Galaxy.
    For our example here, we will pull down and use three different configs from Ansible
    Galaxy. Our example project will deploy three containers that collectively will
    be running the ELK stack (Elasticsearch, Logstash, and Kibana).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以手动配置我们的容器和/或利用Ansible Galaxy上托管的许多预打包的Ansible Container配置。在这里的示例中，我们将从Ansible
    Galaxy拉取并使用三种不同的配置。我们的示例项目将部署三个容器，这些容器将共同运行ELK堆栈（Elasticsearch，Logstash和Kibana）。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before executing the commands below, please make sure you have installed Ansible
    Container and all the prerequisite software.  Refer to the Ansible Container installation
    instructions for details: [https://docs.ansible.com/ansible-container/installation.html](https://docs.ansible.com/ansible-container/installation.html).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行以下命令之前，请确保您已安装了Ansible Container和所有先决软件。有关详细信息，请参阅Ansible Container安装说明：[https://docs.ansible.com/ansible-container/installation.html](https://docs.ansible.com/ansible-container/installation.html)。
- en: 'The commands to handle this are mentioned here; make sure you are in the `root`
    directory of your project directory when executed:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 处理此的命令在此处提到；确保在执行时您在项目目录的`root`目录中：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the command would resemble this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出将类似于这样：
- en: '![Step 2](graphics/image_07_002.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![步骤2](graphics/image_07_002.jpg)'
- en: Once the base image is downloaded, Ansible Container will load it into a virtual
    container with all possible image dependencies to ready it to be built.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下载基础镜像后，Ansible Container将其加载到一个虚拟容器中，其中包含所有可能的镜像依赖项，以准备构建它。
- en: '![Step 2](graphics/image_07_003.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![步骤2](graphics/image_07_003.jpg)'
- en: Step 3
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 步骤3
- en: 'Next we will now review what the previous `ansible-container` install commands
    did to our project. If we take a look at our `container.yml` and `main.yml` files
    now, we will notice that all the automation code we need to deploy the ELK stack
    to the containers is now there. Let''s take a look at the changes to those files:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾之前的`ansible-container`安装命令对我们的项目做了什么。如果我们现在查看我们的`container.yml`和`main.yml`文件，我们会注意到部署ELK堆栈到容器所需的所有自动化代码都在那里。让我们看看这些文件的变化：
- en: '**container.yml**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**container.yml**'
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**main.yml**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**main.yml**'
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The other file that we need to examine as well now is the `requirements.yml`
    file. Since we are using pre-packaged configs, a link to those configs will be
    added in this file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要检查的另一个文件是`requirements.yml`文件。由于我们使用预打包的配置，这些配置的链接将被添加到此文件中：
- en: '**requirements.yml**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**requirements.yml**'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At this point you have the option to make changes to the files if you have the
    need to adjust variables, specific application changes, or add additional orchestration
    steps. The best thing out of all of this is you can also choose not to make any
    changes at all. You can build and run this container project just as it is.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果您需要调整变量、特定应用程序更改或添加额外的编排步骤，您可以选择对文件进行更改。最好的是，您也可以选择不进行任何更改。您可以构建和运行这个容器项目就像它是的那样。
- en: Step 4
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 步骤4
- en: In our final step, here we will take what we have designed, execute the Ansible
    Container build process, and finally deploy those containers locally. Again, for
    our example, we did not need to make any changes to container design files.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一步中，我们将采用我们设计的内容，执行Ansible Container构建过程，并最终在本地部署这些容器。同样，对于我们的示例，我们不需要对容器设计文件进行任何更改。
- en: 'The build process is very powerful as all the container dependencies and orchestration
    will be implemented in order to create the container images. Those images will
    be used when you wish to deploy the containers. The following is the command to
    be used to build our containers:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程非常强大，因为所有容器依赖关系和编排将被实现以创建容器映像。当您希望部署容器时，将使用这些映像。以下是用于构建我们的容器的命令：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A snippet of the output of the command would resemble this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出片段将类似于这样：
- en: '![Step 4](graphics/B06086_07_04_resized-769x1024.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![步骤4](graphics/B06086_07_04_resized-769x1024.jpg)'
- en: 'Last, and certainly not least, we are ready to test out our brand new containers.
    As they say in the containerization world, *just ship it!.* Using Ansible Container
    to deploy the container images locally in order to test them out is yet another
    feature that just makes perfect sense. The `ansible-container run` command is
    what you will use to deploy the containers to your locally configured **Docker
    Engine** installation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备测试我们全新的容器。正如容器化世界所说，“只需发布它！”。使用Ansible Container在本地部署容器映像以测试它们是另一个非常合理的功能。您将使用`ansible-container
    run`命令将容器部署到您本地配置的Docker Engine安装中：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once run, the output of the command would resemble this, and we can confirm
    our container deployment by executing the `docker ps command`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，命令的输出将类似于这样，我们可以通过执行`docker ps`命令来确认我们的容器部署：
- en: '![Step 4](graphics/image_07_005.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![步骤4](graphics/image_07_005.jpg)'
- en: 'As you can see, we have done well as we now have three containers running locally.
    *We did it*! Our very first container has been designed, configured, built, and
    deployed (all in less than an hour nevertheless). Before we move on we should
    probably stop or removed our containers for now.  Please use the following command
    to either stop or remove your containers:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在本地运行了三个容器，做得很好。我们成功了！我们的第一个容器已经设计、配置、构建和部署（在不到一个小时的时间内）。在我们继续之前，我们应该暂停或移除我们的容器。请使用以下命令来停止或移除您的容器：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Deploying Kubernetes on OpenStack
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在OpenStack上部署Kubernetes
- en: At the time of writing, Kubernetes has been the market choice for container
    orchestration with being one of the top GitHub projects and emerging as the leading
    enterprise choice to manage containers. Some of the high-level features of Kubernetes
    are being able to perform rolling upgrades, zero downtime deployments, manage
    large-scale complex workloads, and highly available/fault tolerant out of the
    box. If you are looking to manage clusters of containers in a production environment,
    you should definitely give Kubernetes a go.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Kubernetes已成为容器编排的市场选择，成为顶级GitHub项目之一，并成为管理容器的领先企业选择。Kubernetes的一些高级功能包括能够执行滚动升级、零停机部署、管理大规模复杂工作负载以及开箱即用的高可用/容错。如果您希望在生产环境中管理容器集群，您绝对应该尝试一下Kubernetes。
- en: In that light, the question often arises, why would I want to run Kubernetes
    on a platform such as OpenStack? Many folks often forget that OpenStack is a hypervisor
    manager and not a hypervisor itself. OpenStack enables an operator to manage many
    different kinds of hypervisors, with container orchestration software being just
    another kind of hypervisor so to speak. Within OpenStack, you have a few ways
    you can choose to manage and deploy a Kubernetes cluster. It can be done via Magnum,
    the container management project within OpenStack. Another way is using Heat templates
    to manage the Kubernetes cluster as a stack. Lastly, you can use a GitHub project
    named **kargo**, which allows you to deploy Kubernetes using Ansible on many different
    systems and cloud platforms.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，经常出现的问题是，为什么我要在OpenStack等平台上运行Kubernetes？许多人经常忘记OpenStack是一个虚拟化管理器，而不是虚拟化本身。OpenStack使操作员能够管理许多不同类型的虚拟化管理器，容器编排软件只是另一种虚拟化管理器。在OpenStack中，您可以选择几种方式来管理和部署Kubernetes集群。可以通过Magnum来完成，这是OpenStack中的容器管理项目。另一种方法是使用Heat模板来将Kubernetes集群作为堆栈进行管理。最后，您可以使用一个名为kargo的GitHub项目，它允许您在许多不同的系统和云平台上使用Ansible部署Kubernetes。
- en: 'For our example here, we will cover the last option and use kargo to deploy
    Kubernetes on our OpenStack cloud. It did not feel like a good use of time to
    try and reinvent the wheel by creating our own Ansible playbooks/roles to deploy
    Kubernetes. The kargo project can be found at: [https://github.com/kubernetes-incubator/kargo](https://github.com/kubernetes-incubator/kargo).
    There are instructions in the repository that will walk you through how to set
    up in order to run the setup playbook.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将涵盖最后一个选项，并使用kargo在我们的OpenStack云上部署Kubernetes。尝试通过创建我们自己的Ansible playbooks/roles来部署Kubernetes似乎不是一个很好的时间利用。kargo项目可以在以下网址找到：[https://github.com/kubernetes-incubator/kargo](https://github.com/kubernetes-incubator/kargo)。存储库中有说明，将指导您如何设置以运行设置playbook。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please keep in mind that kargo is an open source project, and just like every
    other open source project it is subject to change. Change could include reorganizing
    the repository layout, changes in deployment instructions and even depreciation.
    At the time of writing, the project is alive and working.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，kargo是一个开源项目，就像其他开源项目一样，它可能会发生变化。变化可能包括重新组织存储库布局、更改部署说明甚至废弃。在撰写本文时，该项目仍在运行。
- en: 'The OpenStack specific instructions can be found here: [https://github.com/kubernetes-incubator/kargo/blob/master/docs/openstack.md](https://github.com/kubernetes-incubator/kargo/blob/master/docs/openstack.md).
    To get started, you would clone the kargo repository to your Utility container
    on your OpenStack cloud:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: OpenStack特定的说明可以在这里找到：[https://github.com/kubernetes-incubator/kargo/blob/master/docs/openstack.md](https://github.com/kubernetes-incubator/kargo/blob/master/docs/openstack.md)。要开始，您需要将kargo存储库克隆到OpenStack云上的Utility容器中：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Automation considerations
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化考虑
- en: 'For the most part, the installation will go smoothly. I did have to tweak two
    small things to get the playbooks to finish successfully. The first tweak was
    within my OpenRC file. As you will note in the instructions, the second step is
    to source your OpenRC file before running the setup playbook. My file was missing
    two parameters that the playbook checked for; it was the `OS_TENANT_ID` and `OS_REGION_NAME`
    parameters. A working example of my OpenRC file is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，安装将顺利进行。我确实不得不调整两个小细节，以确保playbooks成功完成。第一个调整是在我的OpenRC文件中。正如您在说明中所注意到的，第二步是在运行设置playbook之前源化您的OpenRC文件。我的文件缺少playbook检查的两个参数；它是`OS_TENANT_ID`和`OS_REGION_NAME`参数。我的OpenRC文件的工作示例如下：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The other tweak that I had to make was adjusting how a particular Kubernetes
    dependent software container was pulled. The container repository tag was changed
    and the kargo project had not updated it yet. The update performed to the `roles/download/defaults/main.yml`
    file within the project. A snippet of the original file looked like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我不得不做的另一个调整是调整如何拉取特定的Kubernetes依赖软件容器。容器存储库标签已更改，而kargo项目尚未更新。在项目中对`roles/download/defaults/main.yml`文件执行更新。原始文件的片段如下：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The file needed to be changed to look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更改的文件如下所示：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With those two changes in place, all you need to do is spin up instances to
    serve as the Kubernetes master, etcd, and node. The instances can be any Linux-based
    operating system you wish. The way you layout your Kubernetes cluster varies on
    the type of environment and ultimately the use case. Reference architecture for
    a stable Kubernetes cluster would be to have two instances as masters, three instances
    as etcds, and leverage Ironic to deploy at least three bare metal servers to be
    the nodes. Of course, for testing purposes you can deploy the whole cluster as
    instances on your OpenStack cloud.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个更改，您所需要做的就是启动实例，作为Kubernetes主节点、etcd和节点。实例可以是您希望的任何基于Linux的操作系统。您布置Kubernetes集群的方式取决于环境类型和最终用例。稳定的Kubernetes集群的参考架构是将两个实例作为主节点，三个实例作为etcd，并利用Ironic来部署至少三个裸金属服务器作为节点。当然，出于测试目的，您可以将整个集群部署为OpenStack云上的实例。
- en: 'The next step would be to configure your inventory file to include the instances
    you spun up to act as your Kubernetes cluster. My inventory file was named `os-inventory`.
    A working example of an inventory file is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是配置您的清单文件，以包括您启动的实例，以充当您的Kubernetes集群。我的清单文件名为`os-inventory`。清单文件的工作示例如下：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Believe it or not, you are now ready to run the setup playbook to deploy your
    Kubernetes cluster. The command to do so is as follows, please make sure you are
    within the `root` directory of the kargo repository:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，您现在已经准备好运行设置playbook来部署您的Kubernetes集群了。要这样做的命令如下，请确保您在kargo存储库的`root`目录中：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The installation will run for a bit, but at the end of it all you will have
    a working Kubernetes cluster to experiment with. We will now transition into another
    container orchestration technology and experiment with how we can use Ansible
    to manage containers while also leveraging OpenStack.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 安装将运行一段时间，但最终您将拥有一个可用的Kubernetes集群进行实验。现在我们将转向另一种容器编排技术，并尝试如何使用Ansible来管理容器，同时利用OpenStack。
- en: Managing CoreOS and Docker with Ansible
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ansible管理CoreOS和Docker
- en: 'CoreOS seemed like another great fit to run on top of OpenStack because it
    is:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS似乎是另一个很好的选择，可以在OpenStack上运行，因为它是：
- en: '*A lightweight Linux operating system designed for clustered deployments providing
    automation, security, and scalability for your most critical applications    
                                                                         –  ([https://coreos.com/why/#cluster](https://coreos.com/why/#cluster))*'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*一种专为集群部署设计的轻量级Linux操作系统，为您最关键的应用程序提供自动化、安全性和可伸缩性                          
                                                   –  ([https://coreos.com/why/#cluster](https://coreos.com/why/#cluster))*'
- en: CoreOS's focus is to provide an operating system that is by default cluster
    aware, making it a perfect fit for platforms such as container technologies. Docker
    was also an obvious choice for experimenting with containers since it was what
    made containers popular again. As well as, Docker has a vast variety of images
    ready to be pulled down and deployed as is. For our example, here we will review
    a very simple playbook that will deploy the ELK stack in containers on CoreOS.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS的重点是提供一个默认情况下具有集群意识的操作系统，使其非常适合容器技术等平台。Docker也是一个明显的选择，用于实验容器，因为它是使容器再次流行的原因。此外，Docker有各种各样的镜像可以随时拉取和部署。在我们的示例中，我们将审查一个非常简单的playbook，它将在CoreOS上的容器中部署ELK堆栈。
- en: Automation considerations
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化考虑
- en: 'The first step in this process is to spin up a minimum of three instances with
    a flavor that has at least 2 GB of memory and a stable CoreOS image. Since I enjoy
    using Heat for things such as this, I spun up my instances using a Heat template.
    The template I created to accomplish this can be found here: [https://github.com/wbentley15/openstack-heat-templates/tree/master/coreos](https://github.com/wbentley15/openstack-heat-templates/tree/master/coreos).
    The command to then deploy the stack with Heat looked like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的第一步是启动至少三个具有至少2GB内存和稳定CoreOS镜像的flavor的实例。由于我喜欢使用Heat来做这样的事情，我使用了一个Heat模板来启动我的实例。我创建的模板可以在这里找到：[https://github.com/wbentley15/openstack-heat-templates/tree/master/coreos](https://github.com/wbentley15/openstack-heat-templates/tree/master/coreos)。然后使用Heat部署堆栈的命令如下：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Automation considerations](graphics/image_07_006.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![自动化考虑](graphics/image_07_006.jpg)'
- en: Coding the playbooks and roles
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写playbooks和角色
- en: 'Once your CoreOS stack is online, you can execute the playbook we will now
    create. For this example, all the tasks will be in the playbook named `base.yml`,
    of which is located within the `root` directory of the `playbook` directory. The
    beginning contents of this file will look like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的CoreOS堆栈在线，您可以执行我们将要创建的playbook。在本例中，所有任务将在名为`base.yml`的playbook中，该文件位于`playbook`目录的`root`目录中。该文件的初始内容将如下所示：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The very first task in the playbook is key to running packages such as Ansible
    against the target CoreOS instances. Since CoreOS is a minimal operating system
    it ships without any versions of Python. As we know, one of the major prerequisites
    to running Ansible against a host is to have Python installed. To circumvent this
    limitation we will use a role named `defunctzombie.coreos-bootstrap`, which will
    install `pypy` on our CoreOS instances. We will learn later how to tell Ansible
    where to find our Python interpreter on these nodes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: playbook中的第一个任务对于运行诸如Ansible之类的软件包对目标CoreOS实例至关重要。由于CoreOS是一个最小的操作系统，它没有安装任何版本的Python。我们知道，运行Ansible对主机的一个主要先决条件是安装Python。为了规避这个限制，我们将使用一个名为`defunctzombie.coreos-bootstrap`的角色，在我们的CoreOS实例上安装`pypy`。我们将在稍后学习如何告诉Ansible在这些节点上找到我们的Python解释器。
- en: 'You can pull down this role from Galaxy by executing the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行以下命令从Galaxy上拉取此角色：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The next two tasks will now set up the environment on the CoreOS instances
    to run Docker images as containers. Please make note that we will pin the `docker-py`
    and `docker-compose` packages to a particular version; this was due to a known
    bug with the `docker_image` and `docker_container` modules. This dependency can
    be removed once the bug is addressed, or those versions may need to be adjusted
    as time goes on:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个任务将在CoreOS实例上设置环境，以便将Docker镜像作为容器运行。请注意，我们将固定`docker-py`和`docker-compose`软件包的版本；这是由于`docker_image`和`docker_container`模块的已知错误。一旦错误得到解决，这种依赖关系可以被移除，或者随着时间的推移，这些版本可能需要进行调整：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The final remaining tasks will handle pulling down the Docker images for the
    ELK stack and then launching those containers on your CoreOS cluster:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后剩下的任务将处理拉取ELK堆栈的Docker镜像，然后在您的CoreOS集群上启动这些容器：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The Docker images are pulled down from repositories on [https://hub.docker.com](https://hub.docker.com)
    and then deployed on the CoreOS instances hosting Docker.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像是从[https://hub.docker.com](https://hub.docker.com)上的存储库中拉取下来，然后部署在托管Docker的CoreOS实例上。
- en: 'Our `hosts` file for this example was a bit unique again because of the custom
    Python interpreter we had to install for CoreOS. We were required to configure
    Ansible to use that alternative Python interpreter. In the following working example,
    you will find that we configured Ansible to use the Python interpreter located
    at `/home/core/bin/python` and the pip package at `/home/core/bin/pip`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个例子的`hosts`文件又有点独特，因为我们不得不为CoreOS安装自定义的Python解释器。我们需要配置Ansible来使用这个替代的Python解释器。在下面的工作示例中，您会发现我们配置了Ansible来使用位于`/home/core/bin/python`的Python解释器和位于`/home/core/bin/pip`的pip软件包：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Later in this chapter, we will wrap up by reviewing these playbooks and roles
    again, then also conclude with a test in order to see the finished results.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将通过再次审查这些playbooks和角色来结束，然后进行测试，以查看最终的结果。
- en: Deploying Nova LXD on OpenStack
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署Nova LXD在OpenStack
- en: 'Last, but certainly not least, we will conclude the chapter with the container
    option that really started it all, LXC, or rather its newer bigger brother, LXD.
    LXD is described as:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但肯定不是最不重要的，我们将以真正开始一切的容器选项LXC或者它的新的大哥LXD来结束本章。LXD被描述为：
- en: '*an container "hypervisor" and a new user experience for LXC              
                                                           –   ([https://www.ubuntu.com/cloud/lxd](https://www.ubuntu.com/cloud/lxd))*'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*LXC的容器“hypervisor”和一个新的用户体验*                                              
                           –   ([https://www.ubuntu.com/cloud/lxd](https://www.ubuntu.com/cloud/lxd))'
- en: The three major components of LXD are its system-wide daemon (**lxd**), command
    line client (**lxc**), and the OpenStack Nova plugin. It is that very plugin which
    will enable us to run LXD as a hypervisor under OpenStack control and use traditional
    OpenStack commands to spin up containers. With something like this you can literally
    run instances and containers on separate compute nodes under the same control
    plane. LXD is further described as being secure by design, scalable, intuitive,
    image, based, and the ability to perform live migrations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: LXD的三个主要组件是其系统范围的守护程序（**lxd**）、命令行客户端（**lxc**）和OpenStack Nova插件。正是这个插件使我们能够在OpenStack控制下将LXD作为hypervisor运行，并使用传统的OpenStack命令来启动容器。有了这样的东西，您可以在相同的控制平面下在单独的计算节点上运行实例和容器。LXD进一步被描述为安全设计、可扩展、直观、基于镜像和具有执行实时迁移的能力。
- en: Fortunately for us the Ansible gods have heard and answered our prayers. Within
    the **openstack-ansible project **(**OSA**) under the Newton release (and going
    forward) you can now deploy LXD as an alternative hypervisor to KVM. It is now
    as simple as editing two configuration files before deploying your OSA cloud.
    We will outline those changes and demonstrate how you can spin up your first LXD
    container using OpenStack.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Ansible之神已经听到并回答了我们的祈祷。在**openstack-ansible项目**（**OSA**）的Newton版本（以及以后），您现在可以将LXD作为KVM的替代hypervisor部署。现在只需在部署OSA云之前编辑两个配置文件即可。我们将概述这些更改，并演示如何使用OpenStack启动您的第一个LXD容器。
- en: 'Before we get started you should know that the detailed instructions for enabling
    LXD on OSA could be found here: [http://docs.openstack.org/developer/openstack-ansible-os_nova/](http://docs.openstack.org/developer/openstack-ansible-os_nova/).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，您应该知道在OSA上启用LXD的详细说明可以在这里找到：[http://docs.openstack.org/developer/openstack-ansible-os_nova/](http://docs.openstack.org/developer/openstack-ansible-os_nova/)。
- en: Automation considerations
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化考虑
- en: 'An OSA deployment revolves around three main configuration files located within
    the `/etc/openstack_deploy` directory on your deployment node. You will need to
    edit the `user_variables.yml` and `user_secrets.yml` files. Starting with the
    `user_variables.yml` file, you will need to set the `nova_virt_type` variable
    to use LXD. A working example is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: OSA部署围绕部署节点上`/etc/openstack_deploy`目录中的三个主要配置文件展开。您需要编辑`user_variables.yml`和`user_secrets.yml`文件。从`user_variables.yml`文件开始，您需要将`nova_virt_type`变量设置为使用LXD。一个工作示例如下：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The second file that needs to be edited is the `user_secrets.yml` file. You
    will just need to supply a password for the LXD trust. An example of the line
    that needs to be edited is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 需要编辑的第二个文件是`user_secrets.yml`文件。您只需要为LXD信任提供密码。需要编辑的行的示例如下：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In the event you are planning to set up a mixed compute node farm and wish to
    have both KVM and LXD hosts. You will need to edit the `openstack_user_config.yml`
    file and set the `nova_virt_type` for each host. A working example of how to configure
    this can be found in the preceding documentation link.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划设置混合计算节点农场并希望拥有KVM和LXD主机。您需要编辑`openstack_user_config.yml`文件，并为每个主机设置`nova_virt_type`。如何配置的工作示例可以在前面的文档链接中找到。
- en: 'Now you can begin your OSA installation knowing that you will be able to spin
    up LXD containers as well as instances running on KVM. After the installation
    finishes you have one last step to complete. We now have to create an LXD compatible
    image that will be used when you spin up your containers. LXD requires the use
    of raw images, so we will pull down an image that meets those requirements. From
    within the Utility container on your OSA cloud, execute the following commands:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以开始安装OSA，知道您将能够启动LXD容器以及在KVM上运行的实例。安装完成后，您还需要完成最后一步。我们现在必须创建一个LXD兼容的镜像，该镜像将在您启动容器时使用。LXD需要使用原始镜像，因此我们将下载符合这些要求的镜像。在OSA云的实用程序容器中，执行以下命令：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Automation considerations](graphics/image_07_007.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![自动化考虑](graphics/image_07_007.jpg)'
- en: 'With your new image in place you are now ready to spin up your first LXD container.
    The LXD containers are managed in a similar manner as instances running on KVM.
    You can create a container via the Horizon dashboard or via the OpenStack Client
    CLI. For this example, we will use the OpenStack Client to create the containers.
    The following command will create your containers:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有了您的新镜像，现在您已经准备好启动您的第一个LXD容器了。LXD容器的管理方式与在KVM上运行的实例类似。您可以通过Horizon仪表板或通过OpenStack
    Client CLI创建容器。在本例中，我们将使用OpenStack Client来创建容器。以下命令将创建您的容器：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can count it as a success if your output looks similar to this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的输出看起来与此类似，您可以将其视为成功：
- en: '![Automation considerations](graphics/image_07_008.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![自动化考虑](graphics/image_07_008.jpg)'
- en: You can then execute the `openstack server list` command to verify that your
    new containers are running.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以执行`openstack server list`命令来验证您的新容器是否正在运行。
- en: '![Automation considerations](graphics/image_07_009.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![自动化考虑](graphics/image_07_009.jpg)'
- en: Very cool my friend, you did great yet again! I know we covered a lot, but you
    are an old pro by now so no worries. Keeping with our tradition, we will finish
    up the chapter with a quick review of what we covered and what to expect in the
    next chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 非常棒，我的朋友，你又做得很好！我知道我们涵盖了很多内容，但是你现在已经是一个老手了，所以不用担心。保持我们的传统，我们将以快速回顾我们所涵盖的内容以及下一章的预期结束本章。
- en: Reviewing playbooks and roles
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查playbooks和roles
- en: 'Let''s jump right into examining the master playbook that we created earlier
    to deploy Docker containers on CoreOS called **ansible-coreos**. The completed
    playbook and file, named `base.yml`, located in the root of the `ansible-coreos`
    directory, looks like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接开始检查我们之前创建的主playbook，以部署名为**ansible-coreos**的CoreOS上的Docker容器。位于`ansible-coreos`目录的根目录中的已完成的playbook和文件名为`base.yml`，看起来是这样的：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The corresponding role we pulled down from Galaxy is located in the `ansible-coreos/roles/defunctzombie.coreos-bootstrap/tasks`
    directory, and looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Galaxy中拉下来的相应角色位于`ansible-coreos/roles/defunctzombie.coreos-bootstrap/tasks`目录中，看起来是这样的：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we created the `hosts` file, which also is located in the `root` directory
    of the `playbook` directory:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了`hosts`文件，也位于`playbook`目录的`root`目录中：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The complete set of code can again be found in the following GitHub repository:
    [https://github.com/os-admin-with-ansible/os-admin-with-ansible-v2](https://github.com/os-admin-with-ansible/os-admin-with-ansible-v2).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码集可以再次在以下GitHub存储库中找到：[https://github.com/os-admin-with-ansible/os-admin-with-ansible-v2](https://github.com/os-admin-with-ansible/os-admin-with-ansible-v2)。
- en: 'We are finally ready to give this playbook a try. Assuming you have cloned
    the previous GitHub repository, the command to test out the playbook from the
    deployment node would be as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好尝试这个playbook了。假设您已经克隆了之前的GitHub存储库，则从部署节点测试playbook的命令如下：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Assuming all goes well, the output should resemble the snippet in the following
    screenshot:![Reviewing playbooks and roles](graphics/image_07_010.jpg)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切顺利，输出应该类似于以下截图中的片段：![审查playbooks和角色](graphics/image_07_010.jpg)
- en: Normally, I also like to take the extra step of verifying that the containers
    are running by executing the `docker ps` command on the CoreOS instances.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我还喜欢采取额外的步骤，通过在CoreOS实例上执行`docker ps`命令来验证容器是否正在运行。
- en: '![Reviewing playbooks and roles](graphics/image_07_011.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![审查playbooks和角色](graphics/image_07_011.jpg)'
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Crossing the finish line does feel nice for sure. I hope that the raw power
    of what containers can offer you will inspire you to start deploying them on your
    OpenStack clouds. It always feels good to have options outside of the traditional
    VM's and instances.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 穿过终点线确实感觉不错。我希望容器的原始力量能激励您开始在OpenStack云上部署它们。在传统虚拟机和实例之外拥有选择总是让人感觉良好。
- en: Before concluding this chapter, let's take a moment to recap this chapter. We
    started the chapter with exploring the concept of Containerization and why it
    has become so very popular. You learned how to use Ansible Container to create
    our very first container image and build. We reviewed the kargo project that enables
    you to deploy Kubernetes using Ansible on multiple cloud platforms, including
    OpenStack. Next we demonstrated how to use Ansible to manage CoreOS running a
    Docker cluster on OpenStack. Lastly, we reviewed the configuration changes needed
    to deploy LXD with the **openstack-ansible** project.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，让我们花一点时间回顾本章。我们从探索容器化的概念以及为什么它变得如此流行开始本章。您学会了如何使用Ansible Container来创建我们的第一个容器镜像和构建。我们审查了kargo项目，该项目使您能够使用Ansible在多个云平台上部署Kubernetes，包括OpenStack。接下来，我们演示了如何使用Ansible来管理在OpenStack上运行Docker集群的CoreOS。最后，我们审查了部署LXD所需的配置更改与**openstack-ansible**项目。
- en: The next chapter will also be a very interesting one because as a cloud operator
    you will eventually have to think about scaling up/out your cloud footprint. OpenStack
    has useful built-in features, which makes the process of scaling fairly easy and
    simple. In the next chapter, we will cover the concept of setting up active-active
    cloud regions and then take it up a notch with automating this task to alleviate
    the stress of scaling when the time arises. If you are ready for some unchartered
    waters, set a course for [Chapter 8](ch08.html "Chapter 8. Setting Up Active-Active
    Regions"), *Setting Up Active-Active Regions*!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章也将是非常有趣的一章，因为作为云运营商，您最终将不得不考虑扩展/缩小您的云足迹。OpenStack具有有用的内置功能，使得扩展的过程相当容易和简单。在下一章中，我们将介绍设置活跃-活跃云区域的概念，然后通过自动化这项任务来减轻在需要时进行扩展的压力。如果您准备好迎接一些未知的领域，请前往[第8章](ch08.html
    "第8章。设置活跃-活跃区域")*设置活跃-活跃区域*！
